- en: Chapter 8\. Ray Workflows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 Ray Workflows
- en: With contributions from Carlos Andrade Costa
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由Carlos Andrade Costa贡献
- en: Real-life and modern applications in a wide range of domains are often a combination
    of multiple interdependent steps. For example, in AI/ML workflows, training workloads
    require multiple steps for data cleaning, balancing, and augmentation, while model
    serving often includes many subtasks and integration with long-running business
    processes. Different steps in the workflows can depend on multiple upstreams and
    sometimes require different scaling tools.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在广泛的领域中，现实生活和现代应用程序通常是多个相互依赖步骤的组合。例如，在AI/ML工作流中，训练工作负载需要进行多个步骤的数据清洗、平衡和增强，而模型服务通常包括许多子任务和与长期运行的业务流程的集成。工作流中的不同步骤可以依赖于多个上游，并且有时需要不同的扩展工具。
- en: Computer libraries for workflow management date back over 25 years, with new
    tools focused on AI/ML emerging. Workflow specifications range from graphical
    user interfaces to custom formats, YAML Ain’t Markup Language (YAML) and Extensible
    Markup Language (XML), and libraries in full-fledged programming languages. Specifying
    workflows in code allows you to use general programming tools, like source control
    for versioning and collaboration.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流管理的计算机库追溯到25年前，新工具聚焦于AI/ML的出现。工作流规范涵盖从图形用户界面到自定义格式、YAML Ain't Markup Language
    (YAML)和Extensible Markup Language (XML)，以及全功能编程语言中的库。在代码中指定工作流允许您使用通用的编程工具，如版本控制和协作。
- en: In this chapter, you will learn the basics of Ray’s Workflows implementation
    and some simple examples of its usage.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习Ray Workflows实现的基础知识以及其使用的一些简单示例。
- en: What Is Ray Workflows?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Ray Workflows？
- en: '*Ray Workflows* extends Ray Core by adding workflow primitives, providing support
    for programmatic workflow execution with a shared interface with tasks and actors.
    This allows you to use Ray’s core primitives as part of your workflow’s steps.
    Ray Workflows is targeted at supporting both traditional ML and data workflows
    (e.g., data preprocessing and training) and long-running business workflows, including
    model-serving integration. It leverages Ray tasks for execution to provide scalability
    and reliability. Ray’s workflow primitives greatly reduce the burden of embedding
    workflow logic into application steps.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ray Workflows*通过添加工作流原语扩展了Ray Core，提供了对任务和演员的程序化工作流执行支持，并提供了与任务和演员共享接口的支持。这使您可以将Ray的核心原语作为工作流步骤的一部分使用。Ray
    Workflows旨在支持传统的ML和数据工作流（例如数据预处理和训练），以及长时间运行的业务工作流，包括模型服务集成。它利用Ray任务进行执行，以提供可伸缩性和可靠性。Ray的工作流原语极大地减少了将工作流逻辑嵌入应用程序步骤的负担。'
- en: How Is It Different from Other Solutions?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他解决方案有何不同？
- en: Unlike other popular workflow frameworks—​e.g., [Apache Airflow](https://oreil.ly/ZKymk),
    [Kubeflow Pipelines](https://oreil.ly/dgEk7), and others—​which focus on tool
    integration and deployment orchestration, Ray Workflows focuses on lower-level
    workflow primitives enabling programmatic workflows.^([1](ch08.html#idm45354770928336))
    This programmatic approach can be considered a lower level compared to other implementations;
    this low-level approach allows for unique workflow management features.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他流行的工作流框架（例如[Apache Airflow](https://oreil.ly/ZKymk)，[Kubeflow Pipelines](https://oreil.ly/dgEk7)等）不同，这些框架侧重于工具集成和部署编排，Ray
    Workflows专注于支持较低级别的工作流原语，从而实现程序化工作流。^([1](ch08.html#idm45354770928336))这种程序化方法相对于其他实现可以被认为是较低级别的；这种低级别方法允许独特的工作流管理功能。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Ray Workflows focuses on embedding core workflow primitives into Ray Core to
    enable rich programmatic workflows, as opposed to supporting tools integration
    and deployment orchestration.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Ray Workflows专注于将核心工作流原语嵌入Ray Core中，以实现丰富的程序化工作流，而不是支持工具集成和部署编排。
- en: Ray Workflows Features
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ray Workflows特点
- en: In this section, we will walk through the main features of Ray Workflows, review
    the core primitives, and see how they are used in simple examples.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将介绍Ray Workflows的主要特性，回顾核心原语，并看看它们在简单示例中的使用方式。
- en: What Are the Main Features?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要特性是什么？
- en: 'The main features provided by Ray Workflows include the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Ray Workflows提供的主要功能包括以下内容：
- en: Durability
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 耐久性
- en: By adding virtual actors (see [“Virtual Actors”](#virtual-actors-section)),
    Ray Workflows adds durability guarantees to steps executed with Ray’s dynamic
    task graph.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加虚拟演员（参见[“虚拟演员”](#virtual-actors-section)），Ray Workflows为使用Ray的动态任务图执行的步骤添加了耐久性保证。
- en: Dependency management
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖管理
- en: Ray Workflows leverages Ray’s runtime environment feature to snapshot the code
    dependencies of a workflow. This enables management of workflows and virtual actors
    as code is upgraded over time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Ray Workflows 利用 Ray 的运行时环境特性来快照工作流的代码依赖关系。这使得可以随着时间的推移管理工作流和虚拟演员的代码升级。
- en: Low-latency and scale
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 低延迟和规模
- en: By leveraging Ray’s zero-copy overhead with Plasma (a shared memory store),
    Ray Workflows provides subsecond overhead when launching tasks. Ray’s scalability
    extends to workflows, allowing you to create workflows with thousands of steps.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Ray 与 Plasma（共享内存存储）的零拷贝开销，Ray Workflows 在启动任务时提供亚秒级的开销。Ray 的可伸缩性扩展到工作流，允许您创建包含数千个步骤的工作流。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Ray Workflows provides durable execution of workflow steps using any of Ray’s
    distributed libraries, with low-latency and dynamic dependency management.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Ray Workflows 使用 Ray 的任何分布式库提供工作流步骤的持久执行，具有低延迟和动态依赖管理。
- en: Workflow Primitives
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作流基元
- en: 'Ray Workflows provides core primitives to build workflows with steps and a
    *virtual actor*. The following list summarizes the core primitives and basic concepts
    in Ray Workflows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Ray Workflows 提供了构建带有步骤和 *虚拟演员* 的工作流的核心基元。以下列表总结了 Ray Workflows 中的核心基元和基本概念：
- en: Steps
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤
- en: Annotated functions with the `@workflow.step` decorator. Steps are executed
    once when finished successfully, and retried on failure. Steps can be used as
    arguments for other step futures. To ensure recoverability, steps don’t support
    the `ray.get` and `ray.wait` calls.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 `@workflow.step` 装饰器的注释函数。步骤在成功完成时执行一次，并在失败时重试。步骤可以作为其他步骤未来的参数使用。为确保可恢复性，步骤不支持
    `ray.get` 和 `ray.wait` 调用。
- en: Objects
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对象
- en: Data objects stored in the Ray object store, with references to these objects
    being passed into and returned from steps. When initially returned from a step,
    objects are checkpointed and can be shared with other Workflows steps through
    the Ray object store.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 Ray 对象存储中的数据对象，这些对象的引用被传递到步骤中，并从步骤返回。当从步骤最初返回时，对象被检查点并可以通过 Ray 对象存储与其他工作流步骤共享。
- en: Workflows
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流
- en: Execution graph created with `@Workflow.run` and `Workflow.run_async`. The workflow
    execution, after starting, is logged to storage for durability and can be resumed
    upon failure on any Ray cluster with access to the storage.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@Workflow.run` 和 `Workflow.run_async` 创建的执行图。工作流执行在启动后被记录到存储中以保证耐久性，并可以在任何具有访问存储权限的
    Ray 集群上失败后恢复。
- en: Workflows can also be dynamic, generating new steps in subworkflows at runtime.
    Workflows support dynamic looping, nesting, and recursion. You can even dynamically
    add new steps to your workflow directed acyclic graph (DAG) by returning more
    workflow steps from a workflow step.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流也可以是动态的，在运行时生成新的子工作流步骤。工作流支持动态循环、嵌套和递归。甚至可以通过从工作流步骤返回更多的工作流步骤来动态添加新的步骤到您的工作流有向无环图（DAG）中。
- en: Virtual actors
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟演员
- en: Virtual actors are like regular Ray actors, which can hold member states. The
    main difference is that virtual actors are backed by durable storage instead of
    only in-process memory, which does not survive cluster restarts or worker failures.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟演员类似于常规的 Ray 演员，可以保存成员状态。主要区别在于虚拟演员由耐久性存储支持，而不仅仅是进程内存，这使得其能够在集群重新启动或工作节点失败时存活。
- en: Virtual actors manage long-running business workflows. They save their state
    into external storage for durability. They also support the launch of sub­work⁠flows
    from method calls and receive externally triggered events.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟演员管理长时间运行的业务工作流程。它们将其状态保存到外部存储以保证耐久性。它们还支持从方法调用启动子工作流程，并接收外部触发的事件。
- en: You can use virtual actors to add state to an otherwise stateless workflow.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用虚拟演员为本质上无状态的工作流添加状态。
- en: Events
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 事件
- en: Workflows can be triggered by timers and external events through pluggable event
    listeners. Events can also be used as an argument for a step, making the step
    execution wait until the event is received.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流可以通过定时器和可插拔事件监听器触发，并作为步骤的参数使用，使步骤执行等待直到接收到事件。
- en: Working with Basic Workflow Concepts
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基本工作流概念进行工作
- en: Workflows are built out of various primitives, and you’ll start with learning
    how to use steps and objects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流是由各种基元构建而成，您将从学习如何使用步骤和对象开始。
- en: Workflows, Steps, and Objects
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作流、步骤和对象
- en: '[Example 8-1](#basic_workflow) shows a simple Hello World workflow example,
    demonstrating how the step, object, and workflow primitives work in a simple case.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-1](#basic_workflow) 展示了一个简单的 Hello World 工作流示例，演示了在简单情况下步骤、对象和工作流基元的工作方式。'
- en: Example 8-1\. [Hello World workflow](https://oreil.ly/4G4VW)
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-1\. [Hello World 工作流](https://oreil.ly/4G4VW)
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Similar to Ray tasks and actors (described in Chapters [3](ch03.html#ch03)
    and [4](ch04.html#ch04)), you can explicitly assign computing resources (e.g.,
    CPU core, GPUs) to a step with the same arguments as in core Ray: `num_cpus`,
    `num_gpus`, and `resources`. See [Example 8-2](#step_resources).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Ray 任务和演员类似（在第 [3](ch03.html#ch03) 章和第 [4](ch04.html#ch04) 章中描述），您可以显式地为步骤分配计算资源（例如，CPU
    核心、GPU），方法与核心 Ray 中相同：`num_cpus`、`num_gpus` 和 `resources`。参见 [示例 8-2](#step_resources)。
- en: Example 8-2\. Adding resources to steps
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-2\. 为步骤添加资源
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Dynamic Workflows
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态工作流
- en: 'In addition to the workflows with the predefined DAG, Ray allows you to create
    steps programmatically based on the current state of workflow execution: *dynamic
    workflows*. You can use this type of workflow, for example, to implement recursion
    and more complex execution flows. A simple recursion can be illustrated with a
    recursive factorial program. [Example 8-3](#basic_dynamic_workflow) shows how
    you can use recursion within a workflow (note that this is for illustration only
    and that other implementations with better performance exist without the need
    of Ray Workflows).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了预定义的有向无环图工作流之外，Ray 还允许您根据工作流执行的当前状态以编程方式创建步骤：*动态工作流*。您可以使用这种类型的工作流，例如，来实现递归和更复杂的执行流程。一个简单的递归可以用递归阶乘程序来说明。[示例 8-3](#basic_dynamic_workflow)
    展示了如何在工作流中使用递归（请注意，这仅供说明，其他实现方式具有更好的性能，无需 Ray 工作流）。
- en: Example 8-3\. [Dynamically creating workflow steps](https://oreil.ly/3vtT5)
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-3\. [动态创建工作流步骤](https://oreil.ly/3vtT5)
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Virtual Actors
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟演员
- en: '*Virtual actors* are Ray actors (see [Chapter 4](ch04.html#ch04)) backed by
    durable storage instead of memory; they are created with the decorator `@virtual_actor`.
    [Example 8-4](#basic_virtual_actor) shows how to use a persistent virtual actor
    to implement a counter.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟演员*是由持久性存储支持的 Ray 演员（参见 [第四章](ch04.html#ch04)），而不是内存；它们是用装饰器 `@virtual_actor`
    创建的。[示例 8-4](#basic_virtual_actor) 展示了如何使用持久性虚拟演员来实现一个计数器。'
- en: Example 8-4\. [Virtual actors](https://oreil.ly/1lV4k)
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-4\. [虚拟演员](https://oreil.ly/1lV4k)
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Warning
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Because a virtual actor retrieves and stores its state before and after every
    step of execution, its state either has to be JSON serializable (in the form of
    state dictionary) or `getstate` and `setstate` methods should be provided that
    convert the actor’s state to and from a JSON serializable dictionary.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为虚拟演员在执行每一步之前和之后检索和存储其状态，所以其状态必须是 JSON 可序列化的（以状态字典的形式）或者应提供 `getstate` 和 `setstate`
    方法，这些方法将演员的状态转换为 JSON 可序列化字典。
- en: Workflows in Real Life
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实生活中的工作流
- en: Let’s take a look at the common steps for creating and managing a reference
    use case implementation with Ray Workflows.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看使用 Ray 工作流创建和管理参考用例实现的常见步骤。
- en: Building Workflows
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建工作流
- en: As seen before, you start with implementing individual workflow steps and declaring
    them with the `@workflow.step` annotation. Similarly to a Ray task, steps can
    receive one or more inputs, where each input can be a specific value or a future—​the
    result of executing one or more previous workflow steps. The return type of workflow
    is `Workflow[T]` and is a future with the value available after the execution
    of the workflow is completed. [Example 8-5](#workflow_step) illustrates this process.
    In this case, the steps `get_value1` and `get_value2` return futures that are
    passed to the `sum` step function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所看到的，您首先要实现单个工作流步骤，并使用 `@workflow.step` 注解声明它们。与 Ray 任务类似，步骤可以接收一个或多个输入，其中每个输入可以是一个特定值或一个
    future—​执行一个或多个先前工作流步骤的结果。工作流的返回类型是 `Workflow[T]`，并且是一个 future，在工作流执行完成后可用该值。[示例 8-5](#workflow_step)
    说明了这个过程。在这种情况下，步骤 `get_value1` 和 `get_value2` 返回 future，这些 future 被传递给 `sum` 步骤函数。
- en: Example 8-5\. [Implementing workflow steps](https://oreil.ly/Sl5bx)
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-5\. [实现工作流步骤](https://oreil.ly/Sl5bx)
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To simplify accessing step execution results and passing data between steps,
    Ray Workflows allows you to explicitly name the steps. You can, for example, retrieve
    the results of step execution by calling `workflow.get_output(workflow_id, name="step_name")`,
    which will return an `ObjectRef[T]`. If you do not explicitly name the step, Ray
    will automatically generate one in the format of `<*WORK⁠FLOW_ID*>​.<*MOD⁠ULE_NAME*>.<*FUNC_NAME*>`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化访问步骤执行结果并在步骤之间传递数据，Ray Workflows 允许您显式命名步骤。例如，您可以通过调用`workflow.get_output(workflow_id,
    name="step_name")`来检索步骤执行结果，这将返回一个`ObjectRef[T]`。如果没有显式命名步骤，Ray 将自动生成一个格式为`<*WORK⁠FLOW_ID*>​.<*MOD⁠ULE_NAME*>.<*FUNC_NAME*>`的名称。
- en: Note that you can call `ray.get` on the returned reference, which will block
    until the workflow is completed. For example, `ray.get(workflow.get_output("sum​_exam⁠ple"))
    == 100`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以在返回的引用上调用`ray.get`，它将阻塞直到工作流完成。例如，`ray.get(workflow.get_output("sum​_exam⁠ple"))
    == 100`。
- en: 'Steps can be named in two ways:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤可以用两种方式命名：
- en: Using `.options(name="step_name")`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.options(name="step_name")`
- en: Using the decorator `@workflows.step(name=”step_name”)`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器`@workflows.step(name=”step_name”)`
- en: Managing Workflows
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理工作流
- en: Each workflow in Ray Workflows has a unique `workflow_id`. You can explicitly
    set a workflow ID during workflow startup, using `.run(workflow_id="workflow_id")`.
    The same option is also applicable to `.run_async`. If no ID is provided when
    calling `.run` and `run_async`, a random ID is generated.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Ray Workflows 中的每个工作流都有一个唯一的`workflow_id`。您可以在启动工作流时显式设置工作流 ID，使用`.run(workflow_id="workflow_id")`。对于`.run`和`run_async`调用时如果没有提供
    ID，则会生成一个随机 ID。
- en: 'Once created, workflows can be in the following states:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，工作流可以处于以下状态之一：
- en: Running
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行
- en: Currently running in the cluster.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当前在集群中运行。
- en: Failed
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 失败
- en: Failed with an application error. It may be resumed from the failed step.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序错误失败。可以从失败的步骤恢复。
- en: Resumable
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可恢复
- en: Workflow that failed with a system error and can be resumed from the failed
    step.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系统错误而失败的工作流，可以从失败的步骤恢复。
- en: Canceled
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 已取消
- en: Workflow has been canceled. It cannot be resumed, and results are unavailable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流已取消。无法恢复，结果不可用。
- en: Successful
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 成功
- en: Workflow completed successfully.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流成功完成。
- en: '[Table 8-1](#table-workflow-mgmt-apis) shows a summary of the management APIs
    and how you can use them to manage workflows both individually or in bulk.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-1](#table-workflow-mgmt-apis) 显示了管理 API 的摘要以及如何使用它们来管理工作流，无论是单独还是批量。'
- en: Table 8-1\. Workflow management APIs
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1\. 工作流管理 API
- en: '| Single workflow | Action | Bulk workflow | Action |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 单个工作流 | 操作 | 批量工作流 | 操作 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `.get_status(​work⁠flow_id=<>)` | Get status of workflows (running, resumable,
    failed, canceled, successful) | `.list_all(​<*work⁠flow_state1*, *work⁠flow_state2*,
    …>)` | List all workflows in the states listed |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `.get_status(​work⁠flow_id=<>)` | 获取工作流状态（运行中、可恢复、失败、已取消、成功） | `.list_all(​<*work⁠flow_state1*,
    *work⁠flow_state2*, …>)` | 列出所有处于列出状态的工作流 |'
- en: '| `.resume(​work⁠flow_id=<>)` | Resume a workflow | `.resume_all` | Resume
    all resumable workflows |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `.resume(​work⁠flow_id=<>)` | 恢复工作流 | `.resume_all` | 恢复所有可恢复的工作流 |'
- en: '| `.cancel(​work⁠flow_id=<>)` | Cancel a workflow |  |  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `.cancel(​work⁠flow_id=<>)` | 取消工作流 |  |  |'
- en: '| `.delete(​work⁠flow_id=<>)` | Delete a workflow |  |  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `.delete(​work⁠flow_id=<>)` | 删除工作流 |  |  |'
- en: Ray Workflows stores workflow information in your configured storage location.
    You configure the location either when creating the workflow with the decorator
    `workflow.init(storage=<*path*>)`, or by setting the environment variable `RAY_WORKFLOW_STORAGE`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Ray Workflows 将工作流信息存储在您配置的存储位置中。您可以在使用装饰器`workflow.init(storage=<*path*>)`创建工作流时配置位置，或者通过设置环境变量`RAY_WORKFLOW_STORAGE`进行配置。
- en: 'You can use either regular/local storage or distributed storage using an S3-compatible
    API:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用常规/本地存储或使用兼容 S3 API 的分布式存储：
- en: Local filesystem
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本地文件系统
- en: Either single node, for testing purposes only, or through a shared filesystem
    (e.g., NFS mount) across the nodes in the cluster. Location is passed as an absolute
    path.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 单节点，仅用于测试目的，或通过集群中节点之间的共享文件系统（例如 NFS 挂载）。位置作为绝对路径传递。
- en: S3 backend
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: S3 后端
- en: Enable workflow data to be written to an S3-based backend for use in production.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 启用将工作流数据写入基于 S3 的后端以供生产使用。
- en: 'If you do not specify a path, Workflows will use the default location: */tmp/ray/work​flow_data*.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定路径，则 Workflows 将使用默认位置：*/tmp/ray/work​flow_data*。
- en: Warning
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If no storage data location is specified, workflow data is saved locally and
    works for only a single-node Ray cluster.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定存储数据位置，则工作流数据将保存在本地，并且仅适用于单节点 Ray 集群。
- en: Ray’s Workflows dependencies are actively under development. Once available,
    this feature will allow Ray to log the full runtime environment to storage, at
    the workflow submission time. By tracking this information, Ray can ensure that
    the workflow can run on a different cluster.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Ray 的工作流依赖项正在积极开发中。一旦可用，此功能将允许 Ray 在工作流提交时将完整的运行时环境记录到存储中。通过跟踪此信息，Ray 可以确保工作流可以在不同的集群上运行。
- en: Building a Dynamic Workflow
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建动态工作流
- en: As mentioned before, you can create workflows dynamically by creating steps
    based on the current state of a given step. When such a step is created, it is
    inserted into the original workflow DAG. [Example 8-6](#dynamic_workflow) shows
    how to use a dynamic workflow to calculate the Fibonacci sequence.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前文所述，您可以通过基于给定步骤的当前状态创建步骤来动态创建工作流。当创建这样的步骤时，它将插入到原始工作流 DAG 中。[示例 8-6](#dynamic_workflow)
    展示了如何使用动态工作流计算斐波那契数列。
- en: Example 8-6\. [Dynamic workflow](https://oreil.ly/zaIwk)
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-6\. [动态工作流](https://oreil.ly/zaIwk)
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Building Workflows with Conditional Steps
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用条件步骤构建工作流
- en: Workflows with conditional steps are central to many use cases. [Example 8-7](#flight_booking_example)
    shows a simplified scenario of a workflow implementing a trip booking.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 带有条件步骤的工作流对许多用例至关重要。[示例 8-7](#flight_booking_example) 展示了实现旅行预订工作流的简化场景。
- en: Example 8-7\. [Trip-booking example](https://oreil.ly/i7jro)
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-7\. [旅行预订示例](https://oreil.ly/i7jro)
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Handling Exceptions
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异常
- en: 'You can choose to have Ray handle exceptions in one of two ways:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择让 Ray 以以下两种方式处理异常：
- en: Automatic retry, until a maximum number of retries is reached
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动重试，直到达到最大重试次数
- en: Catching and handling the exception
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获和处理异常
- en: 'You configure this in either the step decorator or via `.options`. You specify
    the settings for the two techniques, respectively, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在步饰器或通过 `.options` 中配置此选项。分别指定两种技术的设置如下：
- en: '`max_retries`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`max_retries`'
- en: The step is retried upon failure until `max_retries` is reached. The `max_retries`
    default is `3`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在失败时，步骤将重试直到达到 `max_retries`。`max_retries` 的默认值为 `3`。
- en: '`catch_exceptions`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch_exceptions`'
- en: When `True`, this option will convert the return value of the function to a
    `Tuple[Optional[T], Optional[Exception]]`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当设为 `True` 时，此选项将把函数的返回值转换为 `Tuple[Optional[T], Optional[Exception]]`。
- en: You can also pass these to the `workflow.step` decorator.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将这些传递给 `workflow.step` 的装饰器。
- en: '[Example 8-8](#exception_handling_example) illustrates exception handling with
    these options.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-8](#exception_handling_example) 说明了使用这些选项进行异常处理。'
- en: Example 8-8\. [Exception handling](https://oreil.ly/Itn5V)
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-8\. [异常处理](https://oreil.ly/Itn5V)
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Handling Durability Guarantees
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理耐久性保证
- en: Ray Workflows ensures that once a step succeeds, it will never be reexecuted.
    To enforce this guarantee, Ray Workflows logs the step result to durable storage,
    ensuring that results from previous successful steps will not change when used
    in subsequent steps.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Ray 的工作流确保一旦步骤成功，将不会重新执行。为了强制执行此保证，Ray 的工作流将步骤结果记录到耐久性存储中，确保在后续步骤中使用之前成功步骤的结果不会改变。
- en: 'Ray’s workflows go beyond the durability of retrying within a cluster or single
    application. Workflows implements a failure model based on two statuses:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Ray 的工作流不仅限于在集群或单个应用程序内重试的耐久性。工作流实现基于两种状态的故障模型：
- en: Cluster failure
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 集群故障
- en: If the cluster fails, any workflow running on the cluster is set to `RESUMABLE`
    state. Workflows in `RESUMABLE` state can be resumed on a different cluster. This
    can be done with `ray.workflow.resume.all`, which will resume all resumable workflow
    jobs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集群发生故障，则在集群上运行的任何工作流将设置为 `RESUMABLE` 状态。处于 `RESUMABLE` 状态的工作流可以在不同的集群上恢复。可以通过
    `ray.workflow.resume.all` 完成此操作，它将恢复所有可恢复的工作流作业。
- en: Driver failure
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序故障
- en: The workflow will transition to the failed state, and once the issue is resolved,
    it can be resumed from the failed step.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流将转换为失败状态，一旦问题解决，可以从失败的步骤恢复。
- en: Warning
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Workflow resumability is a beta API at the moment of writing and may change
    before becoming stable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此时写作流恢复性为 beta API，可能会在稳定之前发生变化。
- en: You can use durability guarantees to create idempotent workflows that include
    steps that have side effects. This is needed because a step can fail before its
    output is logged. [Example 8-9](#idempotent_workflow_example) shows how to use
    a durability guarantee to make a workflow idempotent.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用持久性保证来创建幂等工作流，其中包含具有副作用的步骤。这是必要的，因为步骤可能在其输出被记录之前失败。[示例 8-9](#idempotent_workflow_example)
    展示了如何使用持久性保证使工作流具有幂等性。
- en: Example 8-9\. [Idempotent workflow](https://oreil.ly/wmmp1)
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-9\. [幂等工作流](https://oreil.ly/wmmp1)
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Extending Dynamic Workflows with Virtual Actors
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展动态工作流程与虚拟演员
- en: Virtual actors, described previously, also allow subworkflows to be called from
    each of their methods.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，虚拟演员还允许从其每个方法中调用子工作流。
- en: When you create a virtual actor, Ray stores its initial state and class definition
    in durable storage. As a workflow name is used in the actor’s definition, Ray
    stores it in durable storage. When the actor’s method creates new steps, they
    are dynamically appended to the workflow and executed. In this case, both the
    step definition and its result are stored in the actor’s state. To retrieve the
    actor, you can use the decorator `.get_actor(workflow_id="workflow_id")`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个虚拟演员时，Ray 将其初始状态和类定义存储在持久性存储中。由于工作流名称在演员的定义中使用，Ray 将其存储在持久性存储中。当演员的方法创建新的步骤时，它们会动态附加到工作流并执行。在这种情况下，步骤定义及其结果都存储在演员的状态中。要检索演员，您可以使用装饰器
    `.get_actor(workflow_id="workflow_id")`。
- en: You can also define workflows as read-only. Because they don’t require logging,
    they incur less overhead. Additionally, because they don’t imply conflict issues
    with mutating methods in the actor, Ray can execute them concurrently.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将工作流定义为只读的。因为它们不需要记录，所以它们的开销较小。此外，由于它们不会与演员中的变异方法冲突，Ray 可以并行执行它们。
- en: '[Example 8-10](#virtual_actor_workflow_example) shows how virtual actors can
    be used to manage state in a workflow.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-10](#virtual_actor_workflow_example) 展示了虚拟演员如何用于管理工作流程中的状态。'
- en: Example 8-10\. [Workflow management with virtual actors](https://oreil.ly/zTWOk)
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-10\. [使用虚拟演员进行工作流管理](https://oreil.ly/zTWOk)
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Virtual actors can also create subworkflows that involve other methods in the
    virtual actor or steps defined outside the actor class to be invoked. This means
    that a workflow can be launched inside a method or passed to another method. See
    [Example 8-11](#subworkflow_example).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟演员还可以创建涉及虚拟演员中其他方法或定义在演员类外部的步骤以供调用的子工作流。这意味着工作流可以在方法内启动或传递给另一个方法。参见 [示例 8-11](#subworkflow_example)。
- en: Example 8-11\. [Using subworkflows](https://oreil.ly/exFyJ)
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-11\. [使用子工作流](https://oreil.ly/exFyJ)
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Virtual actors can also be used for sharing data among multiple workflows (even
    running on different Ray clusters). For example, virtual actors may be used to
    store fitted parameters in an ML model such as a Python scikit-learn pipeline.
    [Example 8-12](#machine_learning_workflow) illustrates a simple two-stage pipeline
    consisting of a standard scalar followed by a decision tree classifier. Each stage
    is implemented as a workflow step, directly invoking an instance of a virtual
    actor defined in the class `estimator_virtual_actor`. Its member estimator uses
    the `getstate` and `setstate` methods to convert its state to and from the JSON
    serializable dictionary. The pipeline is trained when the third input parameter
    of the input tuple is specified as `'fit'`, and the pipeline is used for prediction
    when that parameter is specified as `'predict'`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟演员还可用于在多个工作流之间共享数据（甚至在不同的 Ray 集群上运行）。例如，虚拟演员可以用于存储像 Python scikit-learn 流水线中的
    ML 模型中已拟合的参数。[示例 8-12](#machine_learning_workflow) 展示了一个简单的两阶段流水线，由标准标量和决策树分类器组成。每个阶段都作为工作流步骤实现，直接调用在
    `estimator_virtual_actor` 类中定义的虚拟演员的实例。其成员估算器使用 `getstate` 和 `setstate` 方法将其状态转换为和从可
    JSON 序列化的字典。当输入元组的第三个输入参数指定为 `'fit'` 时，流水线被训练，并且当该参数指定为 `'predict'` 时，流水线用于预测。
- en: 'To train a pipeline, the workflow execution submits `training_tuple` to the
    standard scalar, whose output is then piped through the classification model to
    train:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了训练一个流水线，工作流执行将 `training_tuple` 提交给标准标量，其输出然后通过分类模型管道进行训练：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To use the trained pipeline for prediction, the workflow execution submits
    `predict_tuple` to the same chain of steps, although its `''predict''` parameter
    invokes the `predict` function in the virtual actor. The prediction result is
    returned as another tuple with labels found in `pred_y`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要将训练好的管道用于预测，工作流执行将 `predict_tuple` 提交给相同的步骤链，尽管其 `'predict'` 参数调用虚拟 actor 中的
    `predict` 函数。预测结果作为另一个包含在 `pred_y` 中的标签元组返回：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The power of the workflow virtual actor is to make the trained model available
    to another Ray cluster. Furthermore, the ML workflow backed by a virtual actor
    can incrementally update its state, such as recalculated time-series features.
    This makes it easier to implement stateful time-series analysis, including forecasting,
    prediction, and anomaly detection.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流虚拟 actor 的威力在于使训练模型可用于另一个 Ray 集群。此外，由虚拟 actor 支持的 ML 工作流可以增量更新其状态，例如重新计算时间序列特征。这使得实现具有状态的时间序列分析更容易，包括预测、预测和异常检测。
- en: Example 8-12\. [Machine learning workflow](https://oreil.ly/mQBVn)
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-12\. [机器学习工作流](https://oreil.ly/mQBVn)
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Long-running workflows require special attention when used as subworkflows,
    since subworkflows block future actor calls when running. To properly handle long-running
    workflows, it is recommended to use the Workflows API to monitor execution and
    to run separate workflows with deterministic names. This approach prevents a duplicate
    workflow from being launched in the case of a failure.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间运行的工作流在作为子工作流使用时需要特别注意，因为子工作流在运行时会阻塞未来的 actor 调用。为了正确处理长时间运行的工作流，建议使用 Workflows
    API 来监视执行，并运行具有确定性名称的单独工作流。这种方法可以防止在失败情况下启动重复的工作流。
- en: Warning
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Subworkflows block future actor method calls. It is not recommended to run a
    long running workflow as a subworkflow of a virtual actor.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 子工作流会阻塞未来的 actor 方法调用。不建议将长时间运行的工作流作为虚拟 actor 的子工作流运行。
- en: '[Example 8-13](#non_blocking_example) shows how to run a long-running workflow
    without blocking.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-13](#non_blocking_example) 展示了如何运行一个长时间运行的工作流而不阻塞。'
- en: Example 8-13\. [Nonblocking workflow](https://oreil.ly/eRs6K)
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-13\. [非阻塞工作流](https://oreil.ly/eRs6K)
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Integrating Workflows with Other Ray Primitives
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将工作流与其他 Ray 原语集成
- en: 'Ray workflows can be used with Ray’s core primitives. Here we will describe
    some common scenarios where the Workflows API is integrated with a common Ray
    program. There are two main scenarios when integrating workflows with tasks and
    actors:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Ray 工作流可以与 Ray 的核心原语一起使用。这里我们将描述一些常见的场景，其中 Workflows API 与常见的 Ray 程序集成。在将工作流与任务和
    actor 集成时有两种主要场
- en: Running a workflow from within a Ray task or actor
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Ray 任务或 actor 中运行工作流
- en: Using a Ray task or actor within a workflow step
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作流步骤中使用 Ray 任务或 actor
- en: Another common case is passing object references between steps in a workflow.
    Ray object references can be passed as arguments and returned from any workflow
    step, as shown in [Example 8-14](#object_reference_example).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见情况是在工作流的步骤之间传递对象引用。Ray 对象引用可以作为参数传递，并从任何工作流步骤返回，如 [示例 8-14](#object_reference_example)
    所示。
- en: Example 8-14\. [Using object references](https://oreil.ly/NaZs2)
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-14\. [使用对象引用](https://oreil.ly/NaZs2)
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To ensure recoverability, Ray Workflows logs the contents to persistent storage.
    Thankfully, when passed to multiple steps, Ray will not checkpoint the object
    more than once.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保可恢复性，Ray Workflows 将内容记录到持久存储中。幸运的是，当传递到多个步骤时，Ray 不会多次检查对象。
- en: Warning
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Ray actor handlers cannot be passed between steps.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Ray actor 处理程序无法在步骤之间传递。
- en: Another consideration when integrating actors and tasks with Workflows is handling
    nested arguments. As described before, workflow outputs are fully resolved when
    passed to a step, as a form to guarantee that all the ancestors of a step are
    executed before the current step is executed. [Example 8-15](#output_arguments_example)
    illustrates this behavior.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 actor 和任务与 Workflows 集成时，另一个需要考虑的因素是处理嵌套参数。如前所述，当传递到步骤时，工作流输出会被完全解析，以确保在执行当前步骤之前执行所有祖先步骤。[示例 8-15](#output_arguments_example)
    说明了这种行为。
- en: Example 8-15\. [Using output arguments](https://oreil.ly/RiOl3)
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-15\. [使用输出参数](https://oreil.ly/RiOl3)
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Triggering Workflows (Connecting to Events)
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发工作流（连接到事件）
- en: Workflows has a pluggable event system, allowing external events to trigger
    workflows. This framework provides an efficient built-in wait mechanism and guarantee
    of exactly-once event delivery semantics. This implies that the user doesn’t need
    to implement a trigger mechanism based on a running workflow step to react to
    an event. As with the rest of workflows, for fault-tolerance, events are checkpointed
    upon occurrence.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Workflows具有可插拔的事件系统，允许外部事件触发工作流。这个框架提供了一个高效的内置等待机制，并保证了一次性事件交付语义。这意味着用户不需要基于运行中的工作流步骤实现触发机制来响应事件。与工作流的其余部分一样，为了容错，事件在发生时进行了检查点。
- en: Workflow *events* can be seen as a type of workflow step that completes only
    when the event occurs. The decorator `.wait_for_event` is used to create an event
    step.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流*事件*可以看作是一种只有在事件发生时才完成的工作流步骤。修饰符`.wait_for_event`用于创建事件步骤。
- en: '[Example 8-16](#event_integration_example) shows a workflow step that finishes
    after 90 seconds and triggers the execution for an outer workflow.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-16](#event_integration_example)显示了一个在90秒后完成的工作流步骤，并触发了外部工作流的执行。'
- en: Example 8-16\. [Using events](https://oreil.ly/7hwaG)
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-16。[使用事件](https://oreil.ly/7hwaG)
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Events also support customer listeners by subclassing the `EventListener` interface,
    as shown in [Example 8-17](#custom_listeners_example).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 事件还支持通过子类化`EventListener`接口来实现自定义监听器，如[示例 8-17](#custom_listeners_example)所示。
- en: Example 8-17\. [Custom event listeners](https://oreil.ly/3j532)
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-17。[自定义事件监听器](https://oreil.ly/3j532)
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Working with Workflow Metadata
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理工作流元数据
- en: 'One of the important requirements for workflow execution is observability.
    Typically, you want not only to see the workflow execution results but also to
    get the information about the internal states (e.g., paths that execution took,
    their performance, and values of variables). Ray’s [workflow metadata](https://oreil.ly/kgiX2)
    provides support for some of the standard and user-defined metadata options. Standard
    metadata is split between workflow-level metadata:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流执行的一个重要需求是可观察性。通常，你不仅想要看到工作流的执行结果，还想获取关于内部状态的信息（例如，执行所采取的路径，它们的性能以及变量的值）。Ray的[工作流元数据](https://oreil.ly/kgiX2)支持一些标准和用户定义的元数据选项。标准元数据分为工作流级别的元数据：
- en: '`status`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`status`'
- en: Workflow states, which can be one of `RUNNING`, `FAILED`, `RESUMABLE`, `CANCELED`,
    or `SUCCESSFUL`
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流状态，可以是`RUNNING`、`FAILED`、`RESUMABLE`、`CANCELED`或`SUCCESSFUL`
- en: '`user_metadata`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`user_metadata`'
- en: A Python dictionary of custom metadata by the user via `workflow.run`
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过`workflow.run`添加的自定义元数据的Python字典
- en: '`stats`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`stats`'
- en: Workflow running stats, including workflow start time and end time
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流运行统计信息，包括工作流开始时间和结束时间
- en: 'And step-level metadata:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以及步骤级别的元数据：
- en: '`name`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`'
- en: Name of the step, either provided by the user via `step.options` or generated
    by the system
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤的名称，可以是用户通过`step.options`提供的，也可以是系统生成的
- en: '`step_options`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`step_options`'
- en: Options of the step, either provided by the user via `step.options` or the system
    default
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤的选项，可以是用户通过`step.options`提供的，也可以是系统默认的
- en: '`user_metadata`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`user_metadata`'
- en: A Python dictionary of custom metadata by the user via `step.options`
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过`step.options`添加的自定义元数据的Python字典
- en: '`stats`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`stats`'
- en: The step’s running stats, including step start time and end time
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤的运行统计信息，包括步骤开始时间和结束时间
- en: 'Ray Workflows provides a simple API to obtain standard metadata:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Ray Workflows提供了一个简单的API来获取标准元数据：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can also get metadata about the workflow and a step:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以获取有关工作流和步骤的元数据：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Both versions of the API return a dictionary containing all the metadata for
    either the workflow itself or an individual step.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: API的两个版本都返回一个包含工作流本身或单个步骤的所有元数据的字典。
- en: 'In addition to the standard metadata, you can add custom ones, capturing parameters
    of interest either in the workflow or specific step:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准元数据之外，你还可以添加自定义元数据，捕获工作流或特定步骤中感兴趣的参数：
- en: Workflow-level metadata can be added via `.run(metadata=metadata)`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过`.run(metadata=metadata)`添加工作流级别的元数据。
- en: Step-level metadata can be added via `.options(metadata=metadata)` or in the
    decorator `@workflow.step(metadata=metadata)`.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过`.options(metadata=metadata)`或修饰符`@workflow.step(metadata=metadata)`添加步骤级别的元数据。
- en: Finally, you can expose metadata from the virtual actors execution and also
    retrieve workflow/steps metadata to control execution.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以从虚拟执行器执行中公开元数据，也可以检索工作流/步骤元数据来控制执行。
- en: Tip
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The metrics that you add to Ray metrics are exposed as Prometheus metrics, just
    like Ray’s built-in metrics.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加到Ray指标的指标被公开为Prometheus指标，就像Ray的内置指标一样。
- en: Be aware that `get_metadata` returns an immediate result at invocation time,
    which means that not all fields might be available in the result.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`get_metadata`在调用时会立即返回结果，这意味着结果可能不会包含所有字段。
- en: Conclusion
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, you learned how Ray Workflows adds workflow primitives to Ray,
    allowing you to create dynamic pipelines with rich workflow management support.
    Ray Workflows allows you to create common pipelines involving multiple steps,
    like data preprocessing, training, and long-running business workflows. With Ray,
    the possibility of a programmatic workflow execution engine became feasible with
    a shared interface with Ray tasks and actors. This capability can greatly reduce
    the burden of orchestrating workflows and embedding workflow logic into application
    steps.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了 Ray Workflows 如何向 Ray 添加工作流原语，使您能够创建具有丰富工作流管理支持的动态管道。Ray Workflows
    允许您创建涉及多个步骤的常见管道，如数据预处理、训练和长时间运行的业务工作流。有了 Ray，通过与 Ray 任务和执行器共享接口，编程式工作流执行引擎的可能性变得可行。这种能力可以极大地减轻编排工作流和将工作流逻辑嵌入应用程序步骤的负担。
- en: This said, be aware that Ray remote functions (see [Chapter 3](ch03.html#ch03))
    provide basic execution sequencing and fork/merge capabilities based on an argument’s
    availability. As a result, for some simple use cases, using Ray Workflows might
    seem like overkill, but if you need execution reliability, restartability, programmatic
    control, and metadata management (which you typically do), Ray Workflows is a
    preferred implementation approach.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是说，要注意，Ray 远程函数（参见[第三章](ch03.html#ch03)）基于参数的可用性提供基本的执行顺序和分支/合并功能。因此，对于一些简单的用例来说，使用
    Ray Workflows 可能会显得有些大材小用，但如果你需要执行可靠性、可重启性、编程控制和元数据管理（通常都需要），Ray Workflows 是一种首选的实现方法。
- en: ^([1](ch08.html#idm45354770928336-marker)) The approach was originally introduced
    by [Cadence workflow](https://oreil.ly/UNfII). Cadence consists of a programming
    framework (or client library) that provides what its documentation calls a “fault-oblivious”
    stateful programming model, allowing developers to create workflows the same way
    they are writing normal code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.html#idm45354770928336-marker)) 这种方法最初是由[Cadence工作流](https://oreil.ly/UNfII)引入的。
    Cadence 包括一个编程框架（或客户端库），提供了其文档称之为“无视错误”的有状态编程模型，使开发人员能够像编写普通代码一样创建工作流。
