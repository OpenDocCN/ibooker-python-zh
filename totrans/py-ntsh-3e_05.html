<html><head></head><body>
<div id="sbo-rt-content"><section data-nutshell-tab="Type Annotations" data-pdf-bookmark="Chapter 5. Type Annotations" data-type="chapter" epub:type="chapter"><div class="chapter" id="type_annotations">
<h1><span class="label">Chapter 5. </span>Type Annotations</h1>
<p>Annotating your Python code with type information is an optional step which can be very helpful during development and maintenance of a large project or a library. Static type checkers and lint tools help identify and locate data type mismatches in function arguments and return values. IDEs can use these <em>type annotations</em> (also called <em>type hints</em>)<a contenteditable="false" data-primary="type hints" data-type="indexterm" id="idm44924594170752"/> to improve autocompletion and to provide pop-up documentation. Third-party packages and frameworks can use type annotations to tailor runtime behavior, or to autogenerate code based on type annotations for methods and variables.</p>
<p>Type annotations and checking in Python continue to evolve, and touch on many complicated issues. This chapter covers some of the most common use cases for type annotations; you can find more comprehensive material in the resources listed at the end of the chapter.</p>
<div data-type="note" epub:type="note">
<h1>Type Annotation Support Varies by Python Version</h1>
<p>Python’s features supporting type annotations have evolved from version to version, with some significant additions and deletions. The rest of this chapter will describe the type annotation support in the most recent versions of Python (3.10 and later), with notes to indicate features that might be present or absent in other versions.</p>
</div>
<section data-pdf-bookmark="History" data-type="sect1"><div class="sect1" id="history">
<h1>History</h1>
<p>Python<a contenteditable="false" data-primary="type annotations" data-secondary="history of" data-type="indexterm" id="idm44924594124960"/> is, fundamentally, a<a contenteditable="false" data-primary="dynamically typed languages" data-type="indexterm" id="idm44924594123424"/> <em>dynamically typed</em> language. This lets you rapidly develop code by naming and using variables without having to declare them. Dynamic typing allows for flexible coding idioms, generic containers, and polymorphic data handling without requiring explicit definition of interface types or class hierarchies. The downside is that the language offers no help during development in flagging variables of incompatible types being passed to or returned from functions. In place of the development-time compile step that some languages utilize to detect and report data type issues, Python relies on developers to maintain comprehensive unit tests, especially (though far from exclusively!<sup><a data-type="noteref" href="ch05.xhtml#ch01fn72" id="ch01fn72-marker">1</a></sup>) to uncover data type errors by re-creating the runtime environment in a series of test cases.</p>
<div data-type="warning" epub:type="warning">
<h1>Type Annotations Are Not Enforced</h1>
<p>Type annotations are <em>not</em> enforced at runtime. Python does not perform any type validation or data conversion based on them; the executable Python code is still responsible for using variables and function arguments properly. However, type annotations must be syntactically correct. A late-imported or dynamically imported module containing an invalid type annotation raises a <span class="code">SyntaxError</span> exception in your running Python program, just like any invalid Python statement.</p>
</div>
<p>Historically, the absence of any kind of type checking was often seen as a shortcoming of Python, with some programmers citing this as a reason for choosing other programming languages. However, the community wanted Python to maintain its runtime type freedom, so the logical approach was to add support for static type checks performed at development time by lint-like tools (described further in the following section) and IDEs. Some attempts were made at type checking based on parsing function signatures or docstrings. Guido van Rossum<a contenteditable="false" data-primary="van Rossum, Guido" data-type="indexterm" id="idm44924594116704"/> cited several cases on the <a href="https://oreil.ly/GFMBC">Python Developers mailing list</a> showing that type annotations could be helpful; for example, when maintaining large legacy codebases. With an annotation syntax, development tools could perform static type checks to highlight variable and function usages that conflict with the intended types.</p>
<p>The first official version of type annotations used specially formatted comments to indicate variable types and return codes, as defined in <a href="https://oreil.ly/61GSZ">PEP 484</a>, a provisional PEP for Python 3.5.<sup><a data-type="noteref" href="ch05.xhtml#ch01fn73" id="ch01fn73-marker">2</a></sup> Using comments allowed for rapid implementation of, and experimentation with, the new typing syntax, without having to modify the Python compiler itself.<sup><a data-type="noteref" href="ch05.xhtml#ch01fn74" id="ch01fn74-marker">3</a></sup> The<a contenteditable="false" data-primary="mypy utility" data-type="indexterm" id="mypy05"/> third-party package <a href="http://mypy-lang.org"><span class="code">mypy</span></a> gained broad acceptance performing static type checking using these comments. With the adoption of <a href="https://oreil.ly/S8kI3">PEP 526</a> in Python 3.6, type annotations were fully incorporated into the Python language itself, with a supporting <span class="code">typing</span> module added to the standard library.</p>
</div></section>
<section data-pdf-bookmark="Type-Checking Utilities" data-type="sect1"><div class="sect1" id="type_checking_utilities">
<h1>Type-Checking Utilities</h1>
<p>As<a contenteditable="false" data-primary="type annotations" data-secondary="utilities for type checking" data-type="indexterm" id="idm44924594104560"/><a contenteditable="false" data-primary="type checking" data-secondary="utilities for" data-type="indexterm" id="idm44924594103184"/> type annotations have become an established part of Python, type-checking utilities and IDE plug-ins have also become part of the Python ecosystem.</p>
<section data-pdf-bookmark="mypy" data-type="sect2"><div class="sect2" id="mypy">
<h2>mypy</h2>
<p>The standalone <a href="https://oreil.ly/6fMPM"><span class="code">mypy</span></a> utility continues to be a mainstay for static type checking, always up-to-date (give or take a Python version!) with evolving Python type annotation forms. <span class="code">mypy</span> is also available as a plug-in for editors including Vim, Emacs, and SublimeText, and for the Atom, PyCharm, and VS Code IDEs. (PyCharm, VS Code, and Wing IDE also incorporate their own type-checking features separate from <span class="code">mypy</span>.) The most common command for running <span class="code">mypy</span> is simply <span class="code"><strong>mypy my_python_script.py</strong></span>.</p>
<p>You can find more detailed usage examples and command-line options in the <a href="https://oreil.ly/rQPK0"><span class="code">mypy</span> online documentation</a>, as well as a <a href="https://oreil.ly/CT6FE">cheat sheet</a> that serves as a handy reference. Code examples later in this section will include example <span class="code">mypy</span> error messages to illustrate the kinds of Python errors that can be caught using type<a contenteditable="false" data-primary="" data-startref="mypy05" data-type="indexterm" id="idm44924594092512"/> checking.</p>
</div></section>
<section data-pdf-bookmark="Other Type Checkers" data-type="sect2"><div class="sect2" id="other_type_checkers">
<h2>Other Type Checkers</h2>
<p>Other type checkers to consider using include:</p>
<dl>
<dt>MonkeyType</dt>
<dd>Instagram’s <a href="https://oreil.ly/RHqNo">MonkeyType</a> uses<a contenteditable="false" data-primary="MonkeyType" data-type="indexterm" id="idm44924594086432"/> the <span class="code">sys.setprofile</span> hook to detect types dynamically at runtime; like <span class="code">pytype</span> (see below), it can also generate a <em>.pyi</em> (stub) file instead of, or in addition to, inserting type annotations in the Python code file itself.</dd>
<dt class="plain"><span class="code">pydantic</span></dt>
<dd><a href="https://oreil.ly/-zNQj"><span class="code">pydantic</span></a> also<a contenteditable="false" data-primary="pydantic" data-type="indexterm" id="idm44924594080832"/> works at runtime, but it does not generate stubs or insert type annotations; rather, its primary goal is to parse inputs and ensure that Python code receives clean data. As described in the <a href="https://oreil.ly/0Ucvm">online docs</a>, it also allows you to extend its validation features for your own environment. See <a data-type="xref" href="ch20.xhtml#fastapi">“FastAPI”</a> for a simple example.</dd>
<dt>Pylance</dt>
<dd><a href="https://oreil.ly/uB5XN">Pylance</a> is a type checking module<a contenteditable="false" data-primary="Pylance" data-type="indexterm" id="idm44924594076496"/> primarily meant to embed Pyright (see below) into VS Code.</dd>
<dt>Pyre</dt>
<dd>Facebook’s <a href="https://oreil.ly/HJ-qQ">Pyre</a> can also<a contenteditable="false" data-primary="Pyre" data-type="indexterm" id="idm44924594073680"/> generate <em>.pyi</em> files. It currently does not run on Windows, unless you have the <a href="https://oreil.ly/DwB82">Windows Subsystem for Linux (WSL)</a> installed.</dd>
<dt>Pyright</dt>
<dd><a href="https://oreil.ly/wwuA8">Pyright</a> is Microsoft’s static type<a contenteditable="false" data-primary="Pyright" data-type="indexterm" id="idm44924594069856"/> checking tool, available as a command-line utility and a VS Code extension.</dd>
<dt class="plain"><span class="code">pytype</span></dt>
<dd><a href="https://oreil.ly/QuhCB"><span class="code">pytype</span></a> from Google<a contenteditable="false" data-primary="pytype" data-type="indexterm" id="idm44924594065872"/> is a static type checker that focuses on<a contenteditable="false" data-primary="type inferencing" data-type="indexterm" id="idm44924594064640"/> <em>type inferencin</em>g (and offers advice even in the absence of type hints) in addition to type annotations. Type inferencing offers a powerful capability for detecting type errors even in code without annotations. <span class="code">pytype</span> can also generate <em>.pyi</em> files and merge stub files back into <em>.py</em> sources (the most recent versions of <span class="code">mypy</span> are following suit on this). Currently, <span class="code">pytype</span> does not run on Windows unless you first install <a href="https://oreil.ly/7G_j-">WSL</a>.</dd>
</dl>
<p>The emergence of type-checking applications from multiple major software organizations is a testimonial to the widespread interest in the Python developer community in using type annotations.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Type Annotation Syntax" data-type="sect1"><div class="sect1" id="type_annotation_syntax">
<h1>Type Annotation Syntax</h1>
<p>A<a contenteditable="false" data-primary="type annotations" data-secondary="syntax for" data-type="indexterm" id="TAsyntax05"/> <em>type annotation</em> is specified in Python using the form:</p>
<pre data-code-language="python" data-type="programlisting">
<em><code class="n">identifier</code></em><code class="p">:</code><code> </code><em><code class="n">type_specification</code></em></pre>
<p><span class="code"><em>type_specification</em></span> can be any Python expression, but usually involves one or more built-in types (for example, just mentioning a Python type is a perfectly valid expression) and/or attributes imported from the <span class="code">typing</span> module (discussed in the following section). The typical form is:</p>
<pre data-code-language="python" data-type="programlisting">
<em><code class="n">type_specifier</code></em><code class="p">[</code><em><code class="n">type_parameter</code></em><code class="p">,</code><code> </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code class="p">]</code></pre>
<p>Here are some examples of type expressions used as type annotations for a variable:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">typing</code><code>
</code><code>
</code><em><code class="c1"># an int</code></em><code>
</code><code class="n">count</code><code class="p">:</code><code> </code><code class="nb">int</code><code>
</code><code>
</code><em><code class="c1"># a list of ints, with a default value</code></em><code>
</code><code class="n">counts</code><code class="p">:</code><code> </code><code class="nb">list</code><code class="p">[</code><code class="nb">int</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="p">]</code><code>
</code><code>
</code><em><code class="c1"># a dict with str keys, values are tuples containing 2 ints and a str</code></em><code>
</code><code class="n">employee_data</code><code class="p">:</code><code> </code><code class="nb">dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code><code> </code><code class="nb">tuple</code><code class="p">[</code><code class="nb">int</code><code class="p">,</code><code> </code><code class="nb">int</code><code class="p">,</code><code> </code><code class="nb">str</code><code class="p">]</code><code class="p">]</code><code>
</code><code>
</code><em><code class="c1"># a callable taking a single str or bytes argument and returning a bool</code></em><code>
</code><code class="n">str_predicate_function</code><code class="p">:</code><code> </code><code class="n">typing</code><code class="o">.</code><code class="n">Callable</code><code class="p">[</code><code class="p">[</code><code class="nb">str</code><code> </code><code class="o">|</code><code> </code><code class="nb">bytes</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nb">bool</code><code class="p">]</code><code>
</code><code>
</code><em><code class="c1"># a dict with str keys, whose values are functions that take and return</code></em><code class="c1"> </code><code>
</code><em><code class="c1"># an int</code></em><code>
</code><code class="n">str_function_map</code><code class="p">:</code><code> </code><code class="nb">dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code><code> </code><code class="n">typing</code><code class="o">.</code><code class="n">Callable</code><code class="p">[</code><code class="p">[</code><code class="nb">int</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nb">int</code><code class="p">]</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>
</code><code>    </code><code class="s1">'</code><code class="s1">square</code><code class="s1">'</code><code class="p">:</code><code> </code><strong><code class="k">lambda</code></strong><code> </code><code class="n">x</code><code class="p">:</code><code> </code><code class="n">x</code><code> </code><code class="o">*</code><code> </code><code class="n">x</code><code class="p">,</code><code>
</code><code>    </code><code class="s1">'</code><code class="s1">cube</code><code class="s1">'</code><code class="p">:</code><code> </code><strong><code class="k">lambda</code></strong><code> </code><code class="n">x</code><code class="p">:</code><code> </code><code class="n">x</code><code> </code><code class="o">*</code><code> </code><code class="n">x</code><code> </code><code class="o">*</code><code> </code><code class="n">x</code><code class="p">,</code><code>
</code><code class="p">}</code></pre>
<p>Note that<a contenteditable="false" data-primary="lambda" data-type="indexterm" id="idm44924593870944"/> <span class="code"><strong>lambda</strong></span>s do <em>not</em> accept type annotations.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="typing_syntax_changes_in_python_threedo">
<h5>Typing Syntax Changes in Python 3.9 and 3.10</h5>
<p>One of the most significant changes in type annotations during the span of Python versions covered in this book was the support added in Python 3.9 for using built-in Python types, as shown in these examples.</p>
<p><span class="version">-3.9</span> Prior to Python 3.9, these annotations required the use of type names imported from the <span class="code">typing</span> module, such as <span class="code">Dict</span>, <span class="code">List</span>, <span class="code">Tuple</span>, etc.</p>
<p><span class="version">3.10+</span> Python 3.10 added support for using <span class="code">|</span> to indicate alternative types, as a more readable, concise alternative to the <span class="code">Union[</span><em><span class="code">atype</span></em><span class="code">,</span> <em><span class="code">btype</span></em><span class="code">, ...]</span> notation. The <span class="code">|</span> operator can also be used to replace <span class="code">Optional[</span><em><span class="code">atype</span></em><span class="code">]</span> with <em><span class="code">atype</span></em> <span class="code">| None</span>.</p>
<p>For instance, the previous <span class="code">str_predicate_function</span> definition would take one of the following forms, depending on your version of Python:</p>
<pre data-code-language="python" data-type="programlisting">
<em><code class="c1"># prior to 3.10, specifying alternative types </code><code>
</code><code class="c1"># requires use of the Union type</code></em><code>
</code><strong><code class="kn">from</code></strong><code> </code><code class="nn">typing</code><code> </code><strong><code class="kn">import</code></strong><code> </code><code class="n">Callable</code><code class="p">,</code><code> </code><code class="n">Union</code><code>
</code><code class="n">str_predicate_function</code><code class="p">:</code><code> </code><code class="n">Callable</code><code class="p">[</code><code class="n">Union</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code><code> </code><code class="nb">bytes</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nb">bool</code><code class="p">]</code><code>
</code><code>
</code><em><code class="c1"># prior to 3.9, built-ins such as list, tuple, dict, </code><code>
</code><code class="c1"># set, etc. required types imported from the typing</code><code>
</code><code class="c1"># module</code></em><code>
</code><strong><code class="kn">from</code></strong><code> </code><code class="nn">typing</code><code> </code><strong><code class="kn">import</code></strong><code> </code><code class="n">Dict</code><code class="p">,</code><code> </code><code class="n">Tuple</code><code class="p">,</code><code> </code><code class="n">Callable</code><code class="p">,</code><code> </code><code class="n">Union</code><code>
</code><code class="n">employee_data</code><code class="p">:</code><code> </code><code class="n">Dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code><code> </code><code class="n">Tuple</code><code class="p">[</code><code class="nb">int</code><code class="p">,</code><code> </code><code class="nb">int</code><code class="p">,</code><code> </code><code class="nb">str</code><code class="p">]</code><code class="p">]</code><code>
</code><code class="n">str_predicate_function</code><code class="p">:</code><code> </code><code class="n">Callable</code><code class="p">[</code><code class="n">Union</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code><code> </code><code class="nb">bytes</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nb">bool</code><code class="p">]</code></pre>
</div></aside>
<p>To annotate a function with a return type, use the form:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="nf">identifier</code><code class="p">(</code><code class="n">argument</code><code class="p">,</code><code> </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code class="p">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><code class="n">type_specification</code><code> </code><code class="p">:</code></pre>
<p>where each <span class="code"><em>argument</em></span> takes the form:</p>
<pre data-code-language="python" data-type="programlisting">
<em><code class="n">identifier</code></em><code class="p">[</code><code class="p">:</code><code> </code><em><code class="n">type_specification</code></em><code class="p">[</code><code> </code><code class="o">=</code><code> </code><em><code class="n">default_value</code></em><code class="p">]</code><code class="p">]</code></pre>
<p>Here’s an example of an annotated function:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="nf">pad</code><code class="p">(</code><code class="n">a</code><code class="p">:</code><code> </code><code class="nb">list</code><code class="p">[</code><code class="nb">str</code><code class="p">]</code><code class="p">,</code><code> </code><code class="n">min_len</code><code class="p">:</code><code> </code><code class="nb">int</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">,</code><code> </code><code class="n">padstr</code><code class="p">:</code><code> </code><code class="nb">str</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1"> </code><code class="s1">'</code><code class="p">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><code class="nb">list</code><code class="p">[</code><code class="nb">str</code><code class="p">]</code><code class="p">:</code><code>
</code><code>    </code><em><code class="sd">"""Given a list of strings and a minimum length, return a copy of</code></em><code class="sd">
</code><em><code class="sd">       the list extended with "padding" strings to be at least the</code></em><code class="sd">
</code><em><code class="sd">       minimum length.</code></em><code class="sd">
</code><em><code class="sd">    """</code></em><code>
</code><code>    </code><strong><code class="k">return</code></strong><code> </code><code class="n">a</code><code> </code><code class="o">+</code><code> </code><code class="p">(</code><code class="p">[</code><code class="n">padstr</code><code class="p">]</code><code> </code><code class="o">*</code><code> </code><code class="p">(</code><code class="n">min_len</code><code> </code><code class="o">-</code><code> </code><code class="nb">len</code><code class="p">(</code><code class="n">a</code><code class="p">)</code><code class="p">)</code><code class="p">)</code></pre>
<p>Note that when an annotated parameter has a default value, PEP 8 recommends using spaces around the equals sign.</p>
<div data-type="tip">
<h1>Forward-Referencing Types That Are Not Yet Fully Defined</h1>
<p>At<a contenteditable="false" data-primary="forward-referencing types" data-type="indexterm" id="idm44924593584128"/><a contenteditable="false" data-primary="function signatures" data-secondary="forward-referencing types" data-type="indexterm" id="idm44924593597456"/> times, a function or variable definition needs to reference a type that has not yet been defined. This is quite common in class methods, or methods that must define arguments or return values of the type of the current class. Those function signatures are parsed at compile time, and at that point the type is not yet defined. For example, this <span class="code">classmethod</span> fails to compile:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">A</code><code class="p">:</code><code>
</code><code>    </code><code class="nd">@classmethod</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">factory_method</code><code class="p">(</code><code class="bp">cls</code><code class="p">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><code class="n">A</code><code class="p">:</code><code>
</code><code>        </code><em><code class="c1"># ... method body goes here ...</code></em></pre>
<p>Since class <span class="code">A</span> has not yet been defined when Python compiles <span class="code">factory_method</span>, the code raises <span class="code">NameError</span>.</p>
<p>The problem can be resolved by enclosing the return type <span class="code">A</span> in quotes:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">A</code><code class="p">:</code><code>
</code><code>    </code><code class="nd">@classmethod</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">factory_method</code><code class="p">(</code><code class="bp">cls</code><code class="p">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><code class="s1">'</code><code class="s1">A</code><code class="s1">'</code><code class="p">:</code><code>
</code><code>        </code><em><code class="c1"># ... method body goes here ...</code></em></pre>
<p>A<a contenteditable="false" data-primary="__annotations__" data-type="indexterm" id="idm44924593497648"/> future version of Python may defer the evaluation of type annotations until runtime, making the enclosing quotes unnecessary (Python’s Steering Committee is evaluating various possibilities). You can preview this behavior using <span class="code"><strong>from</strong></span> <span class="code">__future__</span> <span class="code"><strong>import</strong></span> <span class="code">annotations</span>.<a contenteditable="false" data-primary="" data-startref="TAsyntax05" data-type="indexterm" id="idm44924593493616"/></p>
</div>
</div></section>
<section data-pdf-bookmark="The typing Module" data-type="sect1"><div class="sect1" id="the_typing_module">
<h1>The typing Module</h1>
<p>The<a contenteditable="false" data-primary="type annotations" data-secondary="typing module" data-type="indexterm" id="TAmod05"/> <span class="code">typing</span> module supports type hints. It contains definitions that are useful when creating type annotations, including:</p>
<ul>
<li>
<p>Classes and functions for defining types</p>
</li>
<li>
<p>Classes and functions for modifying type expressions</p>
</li>
<li>
<p>Abstract base classes (ABCs)</p>
</li>
<li>
<p>Protocols</p>
</li>
<li>
<p>Utilities and decorators</p>
</li>
<li>
<p>Classes for defining custom types</p>
</li>
</ul>
<section data-pdf-bookmark="Types" data-type="sect2"><div class="sect2" id="types">
<h2>Types</h2>
<p>The<a contenteditable="false" data-primary="typing module" data-secondary="types" data-type="indexterm" id="TMtypes05"/> initial implementations of the <span class="code">typing</span> module included definitions of types corresponding to Python built-in containers and other types, as well as types from standard library modules. Many of these types have since been deprecated (see below), but some are still useful, since they do not correspond directly to any Python built-in type. <a data-type="xref" href="#useful_definitions_in_the_typing_module">Table 5-1</a> lists the <span class="code">typing</span> types still useful in Python 3.9 and later.</p>
<table class="border" id="useful_definitions_in_the_typing_module">
<caption><span class="label">Table 5-1. </span>Useful definitions in the <span class="code">typing</span> module</caption>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code">Any</span></td>
<td>Matches<a contenteditable="false" data-primary="Any (typing module)" data-type="indexterm" id="idm44924593446544"/> any type.</td>
</tr>
<tr>
<td><span class="code">AnyStr</span></td>
<td>Equivalent to <span class="code">str | bytes</span>. <span class="code">AnyStr</span> is meant to be used to annotate function arguments and return types where either string type is acceptable, but the types should not be mixed between multiple arguments, or arguments and return types.</td>
</tr>
<tr>
<td><span class="code">BinaryIO</span></td>
<td>Matches streams with binary (<span class="code">bytes</span>) content such as those returned from <span class="code">open</span> with <span class="code">mode='b'</span>, or <span class="code">io.BytesIO</span>.</td>
</tr>
<tr>
<td><span class="code">Callable</span></td>
<td><span class="code">Callable[[<em>argument_type</em>, ...],</span> <span class="code"><em>return_type</em></span><span class="code">]</span><br/>
			Defines<a contenteditable="false" data-primary="Callable (typing module)" data-type="indexterm" id="idm44924593433040"/> the<a contenteditable="false" data-primary="function signatures" data-secondary="callable object" data-type="indexterm" id="idm44924593431792"/> type signature for a callable object. Takes a list of types corresponding to the arguments to the callable, and a type for the return value of the function. If the callable takes no arguments, indicate this with an empty list, <span class="code">[]</span>. If the callable has no return value, use <span class="code"><strong>None</strong></span> for <span class="code"><em>return_type</em></span>.</td>
</tr>
<tr>
<td><span class="code">IO</span></td>
<td>Equivalent to <span class="code">BinaryIO | TextIO</span>.</td>
</tr>
<tr>
<td><span class="code">Lit⁠e⁠r⁠a⁠l​[<em>⁠e⁠x⁠p⁠ression</em>,...]</span></td>
<td><span class="version">3.8+</span> Specifies<a contenteditable="false" data-primary="Literal (typing module)" data-type="indexterm" id="idm44924593422816"/> a list of valid values that the variable may take.</td>
</tr>
<tr>
<td><span class="code">LiteralString</span></td>
<td><span class="version">3.11+</span> Specifies a <span class="code">str</span> that must be implemented as a literal quoted value. Used to guard against leaving code open to injection attacks.</td>
</tr>
<tr>
<td><span class="code">NoReturn</span></td>
<td>Use as the return type for functions that “run forever,” such as those that call <span class="code">http.serve_forever</span> or <span class="code">event_loop.run_forever</span> without returning. This is <em>not</em> intended for functions that simply return with no explicit value; for those use <span class="code">-&gt;</span> <span class="code"><strong>None</strong></span>. More discussion of return types can be found in <a data-type="xref" href="#adding_type_annotations_to_existing_cod">“Adding Type Annotations to Existing Code (Gradual Typing)”</a>.</td>
</tr>
<tr>
<td><span class="code">Self</span></td>
<td><span class="version">3.11+</span> Use as the return type for instance functions that <span class="code"><strong>return</strong></span> <span class="code">self</span> (and in a few other cases, as exemplified in <a href="https://oreil.ly/NMMaw">PEP 673</a>).</td>
</tr>
<tr>
<td><span class="code">TextIO</span></td>
<td>Matches streams with text (<span class="code">str</span>) content, such as those returned from <span class="code">open</span> with <span class="code">mode='t'</span>, or <span class="code">io.StringIO</span>.</td>
</tr>
</tbody>
</table>
<p><span class="version">-3.9</span> Prior to 3.9, the definitions in the <span class="code">typing</span> module were used to create types representing built-in types, such as <span class="code">List[int]</span> for a list of <span class="code">int</span>s. From 3.9 onward, these names are deprecated, as their corresponding built-in or standard library types now support the <span class="code">[]</span> syntax: a list of <span class="code">int</span>s is now simply typed using <span class="code">list[int]</span>. <a data-type="xref" href="#python_built_in_types_and_their_pre_thr">Table 5-2</a> lists the definitions from the <span class="code">typing</span> module that were necessary prior to Python 3.9 for type annotations using built-in types.</p>
<table class="border" id="python_built_in_types_and_their_pre_thr">
<caption class="width-full"><span class="label">Table 5-2. </span>Python built-in types and their pre-3.9 definitions in the <span class="code">typing</span> module</caption>
<thead>
<tr>
<th>Built-in type</th>
<th>Pre-3.9 typing module equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code">dict</span></td>
<td><span class="code">Dict</span></td>
</tr>
<tr>
<td><span class="code">frozenset</span></td>
<td><span class="code">FrozenSet</span></td>
</tr>
<tr>
<td><span class="code">list</span></td>
<td><span class="code">List</span></td>
</tr>
<tr>
<td><span class="code">set</span></td>
<td><span class="code">Set</span></td>
</tr>
<tr>
<td><span class="code">str</span></td>
<td><span class="code">Text</span></td>
</tr>
<tr>
<td><span class="code">tuple</span></td>
<td><span class="code">Tuple</span></td>
</tr>
<tr>
<td><span class="code">type</span></td>
<td><span class="code">Type</span></td>
</tr>
<tr>
<td><span class="code">collections.ChainMap</span></td>
<td><span class="code">ChainMap</span></td>
</tr>
<tr>
<td><span class="code">collections.Counter</span></td>
<td><span class="code">Counter</span></td>
</tr>
<tr>
<td><span class="code">collections.defaultdict</span></td>
<td><span class="code">DefaultDict</span></td>
</tr>
<tr>
<td><span class="code">collections.deque</span></td>
<td><span class="code">Deque</span></td>
</tr>
<tr>
<td><span class="code">collections.OrderedDict</span></td>
<td><span class="code">OrderedDict</span></td>
</tr>
<tr>
<td><span class="code">re.Match</span></td>
<td><span class="code">Match</span></td>
</tr>
<tr>
<td><span class="code">re.Pattern</span></td>
<td><span class="code">Pattern</span><a contenteditable="false" data-primary="" data-startref="TMtypes05" data-type="indexterm" id="idm44924593361408"/></td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Type Expression Parameters" data-type="sect2"><div class="sect2" id="type_expression_parameter">
<h2>Type Expression Parameters</h2>
<p>Some<a contenteditable="false" data-primary="typing module" data-secondary="type expression parameters" data-type="indexterm" id="idm44924593358304"/> types defined in the <span class="code">typing</span> module modify other type expressions. The types listed in <a data-type="xref" href="#type_expression_parameters">Table 5-3</a> provide additional typing information or constraints for the modified types in <span class="code"><em>type_expression</em></span>.</p>
<table class="border" id="type_expression_parameters">
<caption><span class="label">Table 5-3. </span>Type expression parameters</caption>
<thead>
<tr>
<th>Parameter</th>
<th>Usage and description</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code">Annotated</span></td>
<td><span class="code">Annotated[<em>type_expression, expression, ...</em>]</span><br/>
<span class="version">3.9+</span> Extends the <span class="code"><em>type_expression</em></span> with additional metadata. The extra metadata values for function <span class="code"><em>fn</em></span> can be retrieved at runtime using <span class="code">get_type_hints(<em>fn</em>, include_extras=<strong>True</strong>)</span>.</td>
</tr>
<tr>
<td><span class="code">ClassVar</span></td>
<td><span class="code">ClassVar[<em>type_expression</em>]</span><br/>
			Indicates that the variable is a class variable, and should not be assigned as an instance variable.</td>
</tr>
<tr>
<td><span class="code">Final</span></td>
<td><span class="code">Final[<em>type_expression</em>]</span><br/>
<span class="version">3.8+</span> Indicates that the variable should not be written to or overridden in a subclass.</td>
</tr>
<tr>
<td><span class="code">Optional</span></td>
<td><span class="code">Optional[<em>type_expression</em>] </span> Equivalent to <span class="code"><em>type_expression</em></span> <span class="code">|</span> <span class="code"><strong>None</strong></span>. Often used for<a contenteditable="false" data-primary="Optional (typing module)" data-type="indexterm" id="idm44924593331856"/> named arguments with a default value of <span class="code"><strong>None</strong></span>. (<span class="code">Optional</span> does not automatically define <span class="code"><strong>None</strong></span> as the default value, so you must still follow it with <span class="code">=</span><span class="code"><strong>None</strong></span> in a function signature.) <span class="version">3.10+</span> With the availability of the <span class="code">|</span> operator for specifying alternative type attributes, there is a growing consensus to prefer <span class="code"><em>type_expression</em></span> <span class="code">|</span> <span class="code"><strong>None</strong></span> over using <span class="code">Optional[<em>type_expression</em>]</span>.</td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Abstract Base Classes" data-type="sect2"><div class="sect2" id="abstract_base_classes">
<h2>Abstract Base Classes</h2>
<p>Just<a contenteditable="false" data-primary="typing module" data-secondary="abstract base classes (ABCs)" data-type="indexterm" id="idm44924593319392"/><a contenteditable="false" data-primary="abstract base classes (ABCs)" data-type="indexterm" id="idm44924593317968"/> as for built-in types, the initial implementations of the <span class="code">typing</span> module included definitions of types corresponding to abstract base classes in the <span class="code">collections.abc</span> module. Many of these types have since been deprecated (see below), but two definitions have been retained as aliases to ABCs in <span class="code">collections.abc</span> (see <a data-type="xref" href="#abstract_base_class_aliases">Table 5-4</a>).</p>
<table class="border" id="abstract_base_class_aliases">
<caption><span class="label">Table 5-4. </span>Abstract base class aliases</caption>
<thead>
<tr>
<th>Type</th>
<th>Method subclasses must implement</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code">Hashable</span></td>
<td><span class="code">__hash__</span></td>
</tr>
<tr>
<td><span class="code">Sized</span></td>
<td><span class="code">__len__</span></td>
</tr>
</tbody>
</table>
<p><span class="version">-3.9</span> Prior to Python 3.9, the following definitions in the <span class="code">typing</span> module represented abstract base classes defined in the <span class="code">collections.abc</span> module, such as <span class="code">Sequence[int]</span> for a sequence of <span class="code">int</span>s. From 3.9 onward, these names in the <span class="code">typing</span> module are deprecated, as their corresponding types in <span class="code">collections.abc</span> now support the <span class="code">[]</span> syntax:</p>
<table class="border no-lines">
<tbody>
<tr>
<td><span class="code">AbstractSet</span></td>
<td><span class="code">Container</span></td>
<td><span class="code">Mapping</span></td>
</tr>
<tr>
<td><span class="code">AsyncContextManager</span></td>
<td><span class="code">ContextManager</span></td>
<td><span class="code">MappingView</span></td>
</tr>
<tr>
<td><span class="code">AsyncGenerator</span></td>
<td><span class="code">Coroutine</span></td>
<td><span class="code">MutableMapping</span></td>
</tr>
<tr>
<td><span class="code">AsyncIterable</span></td>
<td><span class="code">Generator</span></td>
<td><span class="code">MutableSequence</span></td>
</tr>
<tr>
<td><span class="code">AsyncIterator</span></td>
<td><span class="code">ItemsView</span></td>
<td><span class="code">MutableSet</span></td>
</tr>
<tr>
<td><span class="code">Awaitable</span></td>
<td><span class="code">Iterable</span></td>
<td><span class="code">Reversible</span></td>
</tr>
<tr>
<td><span class="code">ByteString</span></td>
<td><span class="code">Iterator</span></td>
<td><span class="code">Sequence</span></td>
</tr>
<tr>
<td><span class="code">Collection</span></td>
<td><span class="code">KeysView</span></td>
<td><span class="code">ValuesView</span></td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Protocols" data-type="sect2"><div class="sect2" id="protocols">
<h2>Protocols</h2>
<p>The<a contenteditable="false" data-primary="typing module" data-secondary="protocols" data-type="indexterm" id="idm44924593272416"/> <span class="code">typing</span> module defines several <em>protocols</em>, which are similar to what some other languages call “interfaces.” Protocols are abstract base classes intended to concisely express constraints on a type, ensuring it contains certain methods. Each protocol currently defined in the <span class="code">typing</span> module relates to a single special method, and its name starts with <span class="code">Supports</span> followed by the name of the method (however, other libraries, such as those defined in <a href="https://oreil.ly/adB9Z"><span class="code">typeshed</span></a>, need not follow the same constraints). Protocols can be used as minimal abstract classes to determine a class’s support for that protocol’s capabilities: all that a class needs to do to comply with a protocol is to implement the protocol’s special method(s).</p>
<p><a data-type="xref" href="#protocols_in_the_typing_module_and_thei">Table 5-5</a> lists the protocols defined in the <span class="code">typing</span> module.</p>
<table class="border" id="protocols_in_the_typing_module_and_thei">
<caption class="width-full"><span class="label">Table 5-5. </span>Protocols in the <span class="code">typing</span> module and their required methods</caption>
<thead>
<tr>
<th>Protocol</th>
<th>Has method</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code">SupportsAbs</span><a contenteditable="false" data-primary="SupportsAbs and other protocols (typing module)" data-type="indexterm" id="idm44924593259600"/></td>
<td><span class="code">__abs__</span></td>
</tr>
<tr>
<td><span class="code">SupportsBytes</span></td>
<td><span class="code">__bytes__</span></td>
</tr>
<tr>
<td><span class="code">SupportsComplex</span></td>
<td><span class="code">__complex__</span></td>
</tr>
<tr>
<td><span class="code">SupportsFloat</span></td>
<td><span class="code">__float__</span></td>
</tr>
<tr>
<td><span class="code">SupportsIndex</span> <span class="version">3.8+</span></td>
<td><span class="code">__index__</span></td>
</tr>
<tr>
<td><span class="code">SupportsInt</span></td>
<td><span class="code">__int__</span></td>
</tr>
<tr>
<td><span class="code">SupportsRound</span></td>
<td><span class="code">__round__</span></td>
</tr>
</tbody>
</table>
<p>A class does not have to explicitly inherit from a protocol in order to satisfy <span class="code">issubclass(<em>cls</em>,</span> <span class="code"><em>protocol_type</em></span><span class="code">)</span>, or for its instances to satisfy <span class="code">isinstance(<em>obj</em>,</span> <span class="code"><em>protocol_type</em></span><span class="code">)</span>. The class simply has to implement the method(s) defined in the protocol. Imagine, for example, a class implementing Roman numerals:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">RomanNumeral</code><code class="p">:</code><code>
</code><code>    </code><em><code class="sd">"""Class representing some Roman numerals and their int</code></em><code class="sd"> 
</code><em><code class="sd">       values.</code></em><code class="sd">
</code><em><code class="sd">    """</code></em><code>
</code><code>    </code><code class="n">int_values</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="s1">'</code><code class="s1">I</code><code class="s1">'</code><code class="p">:</code><code> </code><code class="mi">1</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">II</code><code class="s1">'</code><code class="p">:</code><code> </code><code class="mi">2</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">III</code><code class="s1">'</code><code class="p">:</code><code> </code><code class="mi">3</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">IV</code><code class="s1">'</code><code class="p">:</code><code> </code><code class="mi">4</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">V</code><code class="s1">'</code><code class="p">:</code><code> </code><code class="mi">5</code><code class="p">}</code><code>
</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">label</code><code class="p">:</code><code> </code><code class="nb">str</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">label</code><code> </code><code class="o">=</code><code> </code><code class="n">label</code><code>
</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__int__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><code class="nb">int</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="n">RomanNumeral</code><code class="o">.</code><code class="n">int_values</code><code class="p">[</code><code class="bp">self</code><code class="o">.</code><code class="n">label</code><code class="p">]</code></pre>
<p>To create an instance of this class (to, say, represent a sequel in a movie title) and get its value, you could use the following code:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;&gt;</code> <code class="n">movie_sequel</code> <code class="o">=</code> <code class="n">RomanNumeral</code><code class="p">(</code><code class="s1">'II'</code><code class="p">)</code>
<code class="o">&gt;&gt;&gt;</code> <code class="nb">print</code><code class="p">(</code><code class="nb">int</code><code class="p">(</code><code class="n">movie_sequel</code><code class="p">))</code></pre>
<pre data-type="programlisting">
<strong>2</strong></pre>
<p><span class="code">RomanNumeral</span> satisfies <span class="code">issubclass</span>, and <span class="code">isinstance</span> checks with <span class="code">SupportsInt</span> because it implements <span class="code">__int__</span>, even though it does not inherit explicitly from the protocol class <span class="code">SupportsInt</span>:<sup><a data-type="noteref" href="ch05.xhtml#ch01fn75" id="ch01fn75-marker">4</a></sup></p>
<pre data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;&gt;</code> <code class="nb">issubclass</code><code class="p">(</code><code class="n">RomanNumeral</code><code class="p">,</code> <code class="n">typing</code><code class="o">.</code><code class="n">SupportsInt</code><code class="p">)</code></pre>
<pre data-type="programlisting">
<strong>True</strong></pre>
<pre data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;&gt;</code> <code class="nb">isinstance</code><code class="p">(</code><code class="n">movie_sequel</code><code class="p">,</code> <code class="n">typing</code><code class="o">.</code><code class="n">SupportsInt</code><code class="p">)</code></pre>
<pre data-type="programlisting">
<strong>True</strong></pre>
</div></section>
<section data-pdf-bookmark="Utilities and Decorators" data-type="sect2"><div class="sect2" id="utilities_and_decorators">
<h2>Utilities and Decorators</h2>
<p><a data-type="xref" href="#commonly_used_functions_and_decorators">Table 5-6</a> lists<a contenteditable="false" data-primary="typing module" data-secondary="utilities and decorators" data-type="indexterm" id="TMutil05"/><a contenteditable="false" data-primary="decorators" data-type="indexterm" id="decor05"/> commonly used functions and decorators defined in the <span class="code">typing</span> module; it’s followed by a few examples.</p>
<table class="border" id="commonly_used_functions_and_decorators">
<caption><span class="label">Table 5-6. </span>Commonly used functions and decorators defined in the <span class="code">typing</span> module</caption>
<thead>
<tr>
<th>Function/decorator</th>
<th>Usage and description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="width-15"><span class="code">cast</span></td>
<td><span class="code">cast(<em>type</em>,</span> <span class="code"><em>var</em></span><span class="code">)</span><br/>
			Signals<a contenteditable="false" data-primary="cast (typing module)" data-type="indexterm" id="idm44924586542144"/> to the static type checker that <span class="code"><em>var</em></span> should be considered as type <span class="code"><em>type</em></span>. Returns <span class="code"><em>var</em></span>; at runtime there is no change, conversion, or validation of <span class="code"><em>var</em></span>. See the example after the table.</td>
</tr>
<tr>
<td><span class="code">final</span></td>
<td><span class="code">@final</span><br/>
<span class="version">3.8+</span> Used<a contenteditable="false" data-primary="final (typing module)" data-type="indexterm" id="idm44924586534624"/> to decorate a method in a class definition, to warn if the method is overridden in a subclass. Can also be used as a class decorator, to warn if the class itself is being subclassed.</td>
</tr>
<tr>
<td><span class="code">get_args</span></td>
<td><span class="code">get_args(<em>custom_type</em>)</span><br/>
			Returns the arguments used to construct a custom type.</td>
</tr>
<tr>
<td><span class="code">get_origin</span></td>
<td><span class="code">get_origin(<em>custom_type</em>)</span><br/>
<span class="version">3.8+</span> Returns the base type used to construct a custom type.</td>
</tr>
<tr>
<td><span class="code">get_type_hints</span></td>
<td><span class="code">get_type_hints(<em>obj</em>)</span><br/>
			Returns results as if accessing <span class="code"><em>obj</em></span><span class="code">.__annotations__</span>. Can be called with optional <span class="code">globalns</span> and <span class="code">localns</span> namespace arguments to resolve forward type references given as strings, and/or with optional Boolean <span class="code">include_extras</span> argument to include any nontyping annotations added using <span class="code">Annotations</span>.</td>
</tr>
<tr>
<td><span class="code">NewType</span></td>
<td><span class="code">NewType(<em>type_name</em>,</span> <span class="code"><em>type</em></span><span class="code">)</span><br/>
			Defines<a contenteditable="false" data-primary="NewType (typing module)" data-type="indexterm" id="idm44924586515248"/> a custom type derived from <span class="code"><em>type</em></span>. <span class="code"><em>type_name</em></span> is a string that should match the local variable to which the <span class="code">NewType</span> is being assigned. Useful for distinguishing different uses for common types, such as a <span class="code">str</span> used for an employee name versus a <span class="code">str</span> used for a department name. See <a data-type="xref" href="#newtype">“NewType”</a> for more on this function.</td>
</tr>
<tr>
<td><span class="code">no_type_check</span></td>
<td><span class="code">@no_type_check</span><br/>
			Used to indicate that annotations are not intended to be used as type information. Can be applied to a class or function.</td>
</tr>
<tr>
<td><span class="code">no_type_che⁠c⁠k⁠_​d⁠e⁠c⁠orator</span></td>
<td><span class="code">@no_type_check_decorator</span><br/>
			Used to add <span class="code">no_type_check</span> behavior to another decorator.</td>
</tr>
<tr>
<td><span class="code">overload</span></td>
<td><span class="code">@overload</span><br/>
			Used<a contenteditable="false" data-primary="overload (typing module)" data-type="indexterm" id="idm44924586501312"/> to allow defining multiple methods with the same name but differing types in their<a contenteditable="false" data-primary="function signatures" data-secondary="overload decorator" data-type="indexterm" id="idm44924586500016"/> signatures. See the example after the table.</td>
</tr>
<tr>
<td><span class="code">r⁠u⁠n⁠t⁠i⁠m⁠e⁠_​c⁠h⁠e⁠c⁠k⁠a⁠b⁠l⁠e</span></td>
<td><span class="code">@runtime_checkable</span><br/>
<span class="version">3.8+</span> Used<a contenteditable="false" data-primary="runtime_checkable (typing module)" data-type="indexterm" id="idm44924586495264"/> to add <span class="code">isinstance</span> and <span class="code">issubclass</span> support for custom protocol classes. See <a data-type="xref" href="#using_type_annotations_at_runtime">“Using Type Annotations at Runtime”</a> for more on this decorator.</td>
</tr>
<tr>
<td><span class="code">TypeAlias</span></td>
<td><span class="code"><em>name</em></span><span class="code">: TypeAlias =</span> <span class="code"><em>type_expression</em></span><br/>
<span class="version">3.10+</span> Used<a contenteditable="false" data-primary="TypeAlias (typing module)" data-type="indexterm" id="idm44924586486848"/> to distinguish the definition of a type alias from a simple assignment. Most useful in cases where <span class="code"><em>type_expression</em></span> is a simple class name or a string value referring to a class that is not yet defined, which might look like an assignment. <span class="code">TypeAlias</span> may only be used at module scope. A common use is to make it easier to consistently reuse a lengthy type expression, e.g.: <span class="code">Number: TypeAlias = int | float | Fraction</span>. See <a data-type="xref" href="#typealias">“TypeAlias”</a> for more on this annotation.</td>
</tr>
<tr>
<td><span class="code">type_check_only</span></td>
<td><span class="code">@type_check_only</span><br/>
			Used to indicate that the class or function is only used at type-checking time and is not available at runtime.</td>
</tr>
<tr>
<td><span class="code">TYPE_CHECKING</span></td>
<td>A<a contenteditable="false" data-primary="TYPE_CHECKING (typing module)" data-type="indexterm" id="idm44924586478176"/> special constant that static type checkers evaluate as <span class="code"><strong>True</strong></span> but that is set to <span class="code"><strong>False</strong></span> at runtime. Use this to skip imports of large, slow-to-import modules used solely to support type checking (so that the import is not needed at runtime).</td>
</tr>
<tr>
<td><span class="code">TypeVar</span></td>
<td><span class="code">TypeVar(<em>type_name</em>,</span> <span class="code">*<em>types</em>)</span><br/>
			Defines<a contenteditable="false" data-primary="TypeVar (typing module)" data-type="indexterm" id="idm44924586470784"/> a type expression element for use in complex generic types using <span class="code">Generic</span>. <span class="code"><em>type_name</em></span> is a string that should match the local variable to which the <span class="code">TypeVar</span> is being assigned. If <span class="code"><em>types</em></span> are not given, then the associated <span class="code">Generic</span> will accept any type. If <span class="code"><em>types</em></span> are given, then the <span class="code">Generic</span> will only accept instances of any of the provided types or their subclasses. Also accepts the named Boolean arguments <span class="code">covariant</span> and <span class="code">contravariant</span> (both defaulting to <span class="code">False</span>), and the argument <span class="code">bound</span>. These are described in more detail in <a data-type="xref" href="#generics_and_typevars">“Generics and TypeVars”</a> and in the <a href="https://oreil.ly/069u4">typing module docs</a>.</td>
</tr>
</tbody>
</table>
<p>Use <span class="code">overload</span> at type-checking time to flag named arguments that must be used in particular combinations. In this case, <span class="code">fn</span> must be called with either a <span class="code">str</span> key and <span class="code">int</span> value pair, or with a single <span class="code">bool</span> value:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="nd">@typing</code><code class="o">.</code><code class="n">overload</code><code>
</code><strong><code class="k">def</code></strong><code> </code><code class="nf">fn</code><code class="p">(</code><code class="o">*</code><code class="p">,</code><code> </code><code class="n">key</code><code class="p">:</code><code> </code><code class="nb">str</code><code class="p">,</code><code> </code><code class="n">value</code><code class="p">:</code><code> </code><code class="nb">int</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="o">.</code><code class="o">.</code><code class="o">.</code></strong><code>
</code><code>
</code><code class="nd">@typing</code><code class="o">.</code><code class="n">overload</code><code>
</code><strong><code class="k">def</code></strong><code> </code><code class="nf">fn</code><code class="p">(</code><code class="o">*</code><code class="p">,</code><code> </code><code class="n">strict</code><code class="p">:</code><code> </code><code class="nb">bool</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="o">.</code><code class="o">.</code><code class="o">.</code></strong><code>
</code><code>
</code><strong><code class="k">def</code></strong><code> </code><code class="nf">fn</code><code class="p">(</code><code class="o">*</code><code class="o">*</code><code class="n">kwargs</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><em><code class="c1"># implementation goes here, including handling of differing</code></em><code class="c1"> </code><code>
</code><code>    </code><em><code class="c1"># named arguments</code></em><code>
</code><code>    </code><strong><code class="k">pass</code></strong><code>
</code><code>
</code><em><code class="c1"># valid calls</code></em><code>
</code><code class="n">fn</code><code class="p">(</code><code class="n">key</code><code class="o">=</code><code class="s1">'</code><code class="s1">abc</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">value</code><code class="o">=</code><code class="mi">100</code><code class="p">)</code><code>
</code><code class="n">fn</code><code class="p">(</code><code class="n">strict</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code>
</code><code>
</code><em><code class="c1"># invalid calls</code></em><code>
</code><code class="n">fn</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code>
</code><code class="n">fn</code><code class="p">(</code><code class="s1">'</code><code class="s1">abc</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">fn</code><code class="p">(</code><code class="s1">'</code><code class="s1">abc</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="mi">100</code><code class="p">)</code><code>
</code><code class="n">fn</code><code class="p">(</code><code class="n">key</code><code class="o">=</code><code class="s1">'</code><code class="s1">abc</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">fn</code><code class="p">(</code><strong><code class="kc">True</code></strong><code class="p">)</code><code>
</code><code class="n">fn</code><code class="p">(</code><code class="n">strict</code><code class="o">=</code><code class="kc">True</code><code class="p">,</code><code> </code><code class="n">value</code><code class="o">=</code><code class="mi">100</code><code class="p">)</code></pre>
<p>Note that the <span class="code">overload</span> decorator is used purely for static type checking. To actually dispatch to different methods based on a parameter type at runtime, use <span class="code">functools.singledispatch</span>.</p>
<p>Use the <span class="code">cast</span> function to force a type checker to treat a variable as being of a particular type, within the scope of the cast:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="nf">func</code><code class="p">(</code><code class="n">x</code><code class="p">:</code><code> </code><code class="nb">list</code><code class="p">[</code><code class="nb">int</code><code class="p">]</code><code> </code><code class="o">|</code><code> </code><code class="nb">list</code><code class="p">[</code><code class="nb">str</code><code class="p">]</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">try</code></strong><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="nb">sum</code><code class="p">(</code><code class="n">x</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">except</code></strong><code> </code><code class="ne">TypeError</code><code class="p">:</code><code>
</code><code>        </code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="n">cast</code><code class="p">(</code><code class="nb">list</code><code class="p">[</code><code class="nb">str</code><code class="p">]</code><code class="p">,</code><code> </code><code class="n">x</code><code class="p">)</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="s1">'</code><code class="s1">,</code><code class="s1">'</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">x</code><code class="p">)</code></pre>
<div data-type="warning" epub:type="warning">
<h1>Use cast with Caution</h1>
<p><span class="code">cast</span> is a way of overriding any inferences or prior annotations that may be present at a particular place in your code. It may hide actual type errors in your code, rendering the type-checking pass incomplete or inaccurate. The <span class="code">func</span> in the preceding example raises no <span class="code">mypy</span> warnings itself, but fails at runtime if passed a list of mixed <span class="code">int</span>s and <span class="code">str</span>s.<a contenteditable="false" data-primary="" data-startref="TMutil05" data-type="indexterm" id="idm44924586238384"/><a contenteditable="false" data-primary="" data-startref="decor05" data-type="indexterm" id="idm44924586236976"/></p>
</div>
</div></section>
<section data-pdf-bookmark="Defining Custom Types" data-type="sect2"><div class="sect2" id="defining_custom_types">
<h2>Defining Custom Types</h2>
<p>Just<a contenteditable="false" data-primary="typing module" data-secondary="defining custom types" data-type="indexterm" id="TMcustom05"/> as Python’s <span class="code"><strong>class</strong></span> syntax permits the creation of new runtime types and behavior, the <span class="code">typing</span> module constructs discussed in this section enable the creation of specialized type expressions for advanced type checking.</p>
<p>The<a contenteditable="false" data-primary="custom types" data-secondary="base classes for defining" data-type="indexterm" id="idm44924586197616"/> <span class="code">typing</span> module includes three classes from which your classes can inherit to get type definitions and other default features, listed in <a data-type="xref" href="#base_classes_for_defining_custom_types">Table 5-7</a>.</p>
<table class="border" id="base_classes_for_defining_custom_types">
<caption><span class="label">Table 5-7. </span>Base classes for defining custom types</caption>
<tbody>
<tr>
<td class="width-15"><span class="code">Generic</span></td>
<td><span class="code">Generic[<em>type_var</em>,</span> <span class="code">...</span><span class="code">]</span><br/>
			Defines<a contenteditable="false" data-primary="Generic (typing module)" data-type="indexterm" id="idm44924586188592"/> a type-checking abstract base class for a class whose methods reference one or more <span class="code">TypeVar</span>-defined types. Generics are described in more detail in the following subsection.</td>
</tr>
<tr>
<td><span class="code">NamedTuple</span></td>
<td><span class="code">NamedTuple</span><br/>
			A<a contenteditable="false" data-primary="NamedTuple (typing module)" data-type="indexterm" id="idm44924586184240"/> typed implementation of <span class="code">collections.namedtuple</span>. See <a data-type="xref" href="#namedtuple">“NamedTuple”</a> for further details and examples.</td>
</tr>
<tr>
<td><span class="code">TypedDict</span></td>
<td><span class="code">TypedDict</span><br/>
<span class="version">3.8+</span> Defines<a contenteditable="false" data-primary="TypedDict (typing module)" data-type="indexterm" id="idm44924586178016"/> a type-checking <span class="code">dict</span> that has specific keys and value types for each key. See <a data-type="xref" href="#typeddict">“TypedDict”</a> for details.</td>
</tr>
</tbody>
</table>
<section data-pdf-bookmark="Generics and TypeVars" data-type="sect3"><div class="sect3" id="generics_and_typevars">
<h3>Generics and TypeVars</h3>
<p><em>Generics<a contenteditable="false" data-primary="custom types" data-secondary="generics and TypeVars" data-type="indexterm" id="idm44924586172160"/></em> are types<a contenteditable="false" data-primary="function signatures" data-secondary="generics and TypeVars" data-type="indexterm" id="idm44924586170736"/><a contenteditable="false" data-primary="TypeVar (typing module)" data-type="indexterm" id="typevar05"/> that define a template for classes that can adapt the type annotations of their method signatures based on one or more type parameters. For instance, <span class="code">dict</span> is a generic that takes two type parameters: the type for the dictionary keys and the type for the dictionary values. Here is how <span class="code">dict</span> might be used to define a dictionary that maps color names to RGB triples:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">color_lookup</code><code class="p">:</code> <code class="nb">dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="nb">tuple</code><code class="p">[</code><code class="nb">int</code><code class="p">,</code> <code class="nb">int</code><code class="p">,</code> <code class="nb">int</code><code class="p">]]</code> <code class="o">=</code> <code class="p">{}</code></pre>
<p>The variable <span class="code">color_lookup</span> will support statements like:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">color_lookup</code><code class="p">[</code><code class="s1">'red'</code><code class="p">]</code> <code class="o">=</code> <code class="p">(</code><code class="mi">255</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>
<code class="n">color_lookup</code><code class="p">[</code><code class="s1">'red'</code><code class="p">][</code><code class="mi">2</code><code class="p">]</code></pre>
<p>However, the following statements generate <span class="code">mypy</span> errors, due to a mismatched key or value type:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">color_lookup</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code></pre>
<pre data-type="programlisting">
<strong>error: Invalid index type "int" for "dict[str, tuple[int, int, int]]";</strong>
<strong>expected type "str"</strong></pre>
<pre data-code-language="python" data-type="programlisting">
<code class="n">color_lookup</code><code class="p">[</code><code class="s1">'red'</code><code class="p">]</code> <code class="o">=</code> <code class="p">(</code><code class="mi">255</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code></pre>
<pre data-type="programlisting">
<strong>error: Incompatible types in assignment (expression has type</strong>
<strong>"tuple[int, int, int, int]", target has type "tuple[int, int, int]")</strong></pre>
<p>Generic typing permits the definition of behavior in a class that is independent of the specific types of the objects that class works with. Generics are often used for defining container types, such as <span class="code">dict</span>, <span class="code">list</span>, <span class="code">set</span>, etc. By defining a generic type, we avoid the necessity of exhaustively defining types for <span class="code">DictOfStrInt</span>, <span class="code">DictOfIntEmployee</span>, and so on. Instead, a generic <span class="code">dict</span> is defined as <span class="code">dict[<em>KT</em>,</span> <span class="code"><em>VT</em></span><span class="code">]</span>, where <span class="code"><em>KT</em></span> and <span class="code"><em>VT</em></span> are placeholders for the <span class="code">dict</span>’s key type and value type, and the specific types for any particular <span class="code">dict</span> can be defined when the <span class="code">dict</span> is instantiated.</p>
<p>As an example, let’s define a hypothetical generic class: an accumulator that can be updated with values, but which also supports an <span class="code">undo</span> method. Since the <span class="keep-together">accumulator</span> is a generic container, we declare a <span class="code">TypeVar</span> to represent the type of the contained objects:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">typing</code><code>
</code><code class="n">T</code><code> </code><code class="o">=</code><code> </code><code class="n">typing</code><code class="o">.</code><code class="n">TypeVar</code><code class="p">(</code><code class="s1">'</code><code class="s1">T</code><code class="s1">'</code><code class="p">)</code></pre>
<p>The <span class="code">Accumulator</span> class is defined as a subclass of <span class="code">Generic</span>, with <span class="code">T</span> as a type parameter. Here is the class declaration and its <span class="code">__init__</span> method, which creates a contained list, initially empty, of objects of type <span class="code">T</span>:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">Accumulator</code><code class="p">(</code><code class="n">typing</code><code class="o">.</code><code class="n">Generic</code><code class="p">[</code><code class="n">T</code><code class="p">]</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">_contents</code><code class="p">:</code><code> </code><code class="nb">list</code><code class="p">[</code><code class="n">T</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="p">]</code></pre>
<p>To add the <span class="code">update</span> and <span class="code">undo</span> methods, we define arguments that reference the contained objects as being of type <span class="code">T</span>:</p>
<pre data-code-language="python" data-type="programlisting">
<code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">update</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="o">*</code><code class="n">args</code><code class="p">:</code><code> </code><code class="n">T</code><code class="p">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="kc">None</code></strong><code class="p">:</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">_contents</code><code class="o">.</code><code class="n">extend</code><code class="p">(</code><code class="n">args</code><code class="p">)</code><code>
</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">undo</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="kc">None</code></strong><code class="p">:</code><code>
</code><code>        </code><em><code class="c1"># remove last value added</code></em><code>
</code><code>        </code><strong><code class="k">if</code></strong><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">_contents</code><code class="p">:</code><code>
</code><code>            </code><code class="bp">self</code><code class="o">.</code><code class="n">_contents</code><code class="o">.</code><code class="n">pop</code><code class="p">(</code><code class="p">)</code></pre>
<p>Lastly, we add <span class="code">__len__</span> and <span class="code">__iter__</span> methods so that <span class="code">Accumulator</span> instances can be iterated over:</p>
<pre data-code-language="python" data-type="programlisting">
<code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__len__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><code class="nb">int</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="nb">len</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">_contents</code><code class="p">)</code><code>
</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__iter__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><code class="n">typing</code><code class="o">.</code><code class="n">Iterator</code><code class="p">[</code><code class="n">T</code><code class="p">]</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="nb">iter</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">_contents</code><code class="p">)</code></pre>
<p>Now this class can be used to write code using <span class="code">Accumulator[int]</span> to collect a number of <span class="code">int</span> values:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">acc</code><code class="p">:</code> <code class="n">Accumulator</code><code class="p">[</code><code class="nb">int</code><code class="p">]</code> <code class="o">=</code> <code class="n">Accumulator</code><code class="p">()</code>
<code class="n">acc</code><code class="o">.</code><code class="n">update</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code>
<code class="nb">print</code><code class="p">(</code><code class="nb">sum</code><code class="p">(</code><code class="n">acc</code><code class="p">))</code>  <code class="c1"># prints 6</code>
<code class="n">acc</code><code class="o">.</code><code class="n">undo</code><code class="p">()</code>
<code class="nb">print</code><code class="p">(</code><code class="nb">sum</code><code class="p">(</code><code class="n">acc</code><code class="p">))</code>  <code class="c1"># prints 3</code></pre>
<p>Because <span class="code">acc</span> is an <span class="code">Accumulator</span> containing <span class="code">int</span>s, the following statements generate <span class="code">mypy</span> error messages:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">acc</code><code class="o">.</code><code class="n">update</code><code class="p">(</code><code class="s1">'A'</code><code class="p">)</code></pre>
<pre data-type="programlisting">
<strong>error: Argument 1 to "update" of "Accumulator" has incompatible type</strong>
<strong>"str"; expected "int"</strong></pre>
<pre data-code-language="python" data-type="programlisting">
<code class="nb">print</code><code class="p">(</code><code class="s1">''</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">acc</code><code class="p">))</code></pre>
<pre data-type="programlisting">
<strong>error: Argument 1 to "join" of "str" has incompatible type</strong>
<strong>"Accumulator[int]"; expected "Iterable[str]"</strong></pre>
</div></section>
<section data-pdf-bookmark="Restricting TypeVar to specific types" data-type="sect3"><div class="sect3" id="restricting_typevar_to_specific_types">
<h3>Restricting TypeVar to specific types</h3>
<p>Nowhere<a contenteditable="false" data-primary="custom types" data-secondary="restricting TypeVar to specific types" data-type="indexterm" id="idm44924585679792"/> in our <span class="code">Accumulator</span> class do we ever invoke methods directly on the contained <span class="code">T</span> objects themselves. For this example, the <span class="code">T</span> <span class="code">TypeVar</span> is purely untyped, so type checkers like <span class="code">mypy</span> cannot infer the presence of any attributes or methods of the <span class="code">T</span> objects. If the generic needs to access attributes of the <span class="code">T</span> objects it contains, then <span class="code">T</span> should be defined using a modified form of <span class="code">TypeVar</span>.</p>
<p>Here are some examples of <span class="code">TypeVar</span> definitions:</p>
<pre data-code-language="python" data-type="programlisting">
<em><code class="c1"># T must be one of the types listed (int, float, complex, or str)</code></em><code>
</code><code class="n">T</code><code> </code><code class="o">=</code><code> </code><code class="n">typing</code><code class="o">.</code><code class="n">TypeVar</code><code class="p">(</code><code class="s1">'</code><code class="s1">T</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="nb">int</code><code class="p">,</code><code> </code><code class="nb">float</code><code class="p">,</code><code> </code><code class="nb">complex</code><code class="p">,</code><code> </code><code class="nb">str</code><code class="p">)</code><code>
</code><em><code class="c1"># T must be the class MyClass or a subclass of the class MyClass</code></em><code>
</code><code class="n">T</code><code> </code><code class="o">=</code><code> </code><code class="n">typing</code><code class="o">.</code><code class="n">TypeVar</code><code class="p">(</code><code class="s1">'</code><code class="s1">T</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">bound</code><code class="o">=</code><code class="n">MyClass</code><code class="p">)</code><code>
</code><em><code class="c1"># T must implement __len__ to be a valid subclass of the Sized protocol</code></em><code>
</code><code class="n">T</code><code> </code><code class="o">=</code><code> </code><code class="n">typing</code><code class="o">.</code><code class="n">TypeVar</code><code class="p">(</code><code class="s1">'</code><code class="s1">T</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">bound</code><code class="o">=</code><code class="n">collections</code><code class="o">.</code><code class="n">abc</code><code class="o">.</code><code class="n">Sized</code><code class="p">)</code></pre>
<p>These forms of <span class="code">T</span> allow a generic defined on <span class="code">T</span> to use methods from these types in <span class="code">T</span>’s <span class="code">TypeVar</span> definition.<a contenteditable="false" data-primary="" data-startref="typevar05" data-type="indexterm" id="idm44924585569024"/></p>
</div></section>
<section data-pdf-bookmark="NamedTuple" data-type="sect3"><div class="sect3" id="namedtuple">
<h3>NamedTuple</h3>
<p>The<a contenteditable="false" data-primary="NamedTuple" data-type="indexterm" id="idm44924585565424"/><a contenteditable="false" data-primary="custom types" data-secondary="NamedTuple" data-type="indexterm" id="idm44924585564288"/> <span class="code">collections.namedtuple</span> function simplifies the definition of class-like tuple types that support named access to the tuple elements. <span class="code">NamedTuple</span> provides a typed version of this feature, using a class with attributes-style syntax similar to <span class="code">dataclasses</span> (covered in <a data-type="xref" href="ch04.xhtml#data_classes">“Data Classes”</a>). Here’s a <span class="code">NamedTuple</span> with four elements, with names, types, and optional default values:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">HouseListingTuple</code><code class="p">(</code><code class="n">typing</code><code class="o">.</code><code class="n">NamedTuple</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">address</code><code class="p">:</code><code> </code><code class="nb">str</code><code>
</code><code>    </code><code class="n">list_price</code><code class="p">:</code><code> </code><code class="nb">int</code><code>
</code><code>    </code><code class="n">square_footage</code><code class="p">:</code><code> </code><code class="nb">int</code><code> </code><code class="o">=</code><code> </code><code class="mi">0</code><code>
</code><code>    </code><code class="n">condition</code><code class="p">:</code><code> </code><code class="nb">str</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">Good</code><code class="s1">'</code></pre>
<p><span class="code">NamedTuple</span> classes generate a default constructor, accepting positional or named arguments for each named field:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">listing1</code><code> </code><code class="o">=</code><code> </code><code class="n">HouseListingTuple</code><code class="p">(</code><code>
</code><code>    </code><code class="n">address</code><code class="o">=</code><code class="s1">'</code><code class="s1">123 Main</code><code class="s1">'</code><code class="p">,</code><code>
</code><code>    </code><code class="n">list_price</code><code class="o">=</code><code class="mi">100_000</code><code class="p">,</code><code>
</code><code>    </code><code class="n">square_footage</code><code class="o">=</code><code class="mi">2400</code><code class="p">,</code><code>
</code><code>    </code><code class="n">condition</code><code class="o">=</code><code class="s1">'</code><code class="s1">Good</code><code class="s1">'</code><code class="p">,</code><code>
</code><code class="p">)</code><code>
</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">listing1</code><code class="o">.</code><code class="n">address</code><code class="p">)</code><code>  </code><em><code class="c1"># prints: 123 Main</code></em><code>
</code><code class="nb">print</code><code class="p">(</code><code class="nb">type</code><code class="p">(</code><code class="n">listing1</code><code class="p">)</code><code class="p">)</code><code>    </code><em><code class="c1"># prints: &lt;class 'HouseListingTuple'&gt;</code></em></pre>
<p>Attempting to create a tuple with too few elements raises a runtime error:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">listing2</code><code> </code><code class="o">=</code><code> </code><code class="n">HouseListingTuple</code><code class="p">(</code><code>
</code><code>    </code><code class="s1">'</code><code class="s1">123 Main</code><code class="s1">'</code><code class="p">,</code><code>
</code><code class="p">)</code><code>
</code><em><code class="c1"># raises a runtime error: TypeError: HouseListingTuple.__new__() </code><code>
</code><code class="c1"># missing 1 required positional argument: 'list_price'</code></em></pre>
</div></section>
<section data-pdf-bookmark="TypedDict" data-type="sect3"><div class="sect3" id="typeddict">
<h3>TypedDict</h3>
<p><span class="version">3.8+</span> Python<a contenteditable="false" data-primary="TypedDict (typing module)" data-type="indexterm" id="idm44924585384752"/><a contenteditable="false" data-primary="custom types" data-secondary="TypedDict" data-type="indexterm" id="CTtypeddict05"/> <span class="code">dict</span> variables are often difficult to decipher in legacy codebases, because <span class="code">dict</span>s are used in two ways: as collections of key/value pairs (such as a mapping from user ID to username), and records mapping known field names to values. It is usually easy to see that a function argument is to be passed as a <span class="code">dict</span>, but the actual keys and value types are dependent on the code that may call that function. Beyond simply defining that a <span class="code">dict</span> may be a mapping of <span class="code">str</span> values to <span class="code">int</span> values, as in <span class="code">dict[str, int]</span>, a <span class="code">TypedDict</span> defines the expected keys and the types of each corresponding value. The following example defines a <span class="code">TypedDict</span> version of the previous house listing type (note that <span class="code">TypedDict</span> definitions do not accept default value definitions):</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">HouseListingDict</code><code class="p">(</code><code class="n">typing</code><code class="o">.</code><code class="n">TypedDict</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">address</code><code class="p">:</code><code> </code><code class="nb">str</code><code>
</code><code>    </code><code class="n">list_price</code><code class="p">:</code><code> </code><code class="nb">int</code><code>
</code><code>    </code><code class="n">square_footage</code><code class="p">:</code><code> </code><code class="nb">int</code><code>
</code><code>    </code><code class="n">condition</code><code class="p">:</code><code> </code><code class="nb">str</code></pre>
<p><span class="code">TypedDict</span> classes generate a default constructor, accepting named arguments for each defined key:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">listing1</code><code> </code><code class="o">=</code><code> </code><code class="n">HouseListingDict</code><code class="p">(</code><code>
</code><code>    </code><code class="n">address</code><code class="o">=</code><code class="s1">'</code><code class="s1">123 Main</code><code class="s1">'</code><code class="p">,</code><code>
</code><code>    </code><code class="n">list_price</code><code class="o">=</code><code class="mi">100_000</code><code class="p">,</code><code>
</code><code>    </code><code class="n">square_footage</code><code class="o">=</code><code class="mi">2400</code><code class="p">,</code><code>
</code><code>    </code><code class="n">condition</code><code class="o">=</code><code class="s1">'</code><code class="s1">Good</code><code class="s1">'</code><code class="p">,</code><code>
</code><code class="p">)</code><code>
</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">listing1</code><code class="p">[</code><code class="s1">'</code><code class="s1">address</code><code class="s1">'</code><code class="p">]</code><code class="p">)</code><code>  </code><code class="c1"># prints </code><em><code class="c1">123 Main</code></em><code>
</code><code class="nb">print</code><code class="p">(</code><code class="nb">type</code><code class="p">(</code><code class="n">listing1</code><code class="p">)</code><code class="p">)</code><code>  </code><code class="c1"># prints </code><em><code class="c1">&lt;class 'dict'&gt;</code></em><code>
</code><code>
</code><code class="n">listing2</code><code> </code><code class="o">=</code><code> </code><code class="n">HouseListingDict</code><code class="p">(</code><code>
</code><code>    </code><code class="n">address</code><code class="o">=</code><code class="s1">'</code><code class="s1">124 Main</code><code class="s1">'</code><code class="p">,</code><code>
</code><code>    </code><code class="n">list_price</code><code class="o">=</code><code class="mi">110_000</code><code class="p">,</code><code>
</code><code class="p">)</code></pre>
<p>Unlike the <span class="code">NamedTuple</span> example, <span class="code">listing2</span> will not raise a runtime error, simply creating a <span class="code">dict</span> with just the given keys. However, <span class="code">mypy</span> will flag <span class="code">listing2</span> as a type error with the message:</p>
<pre data-type="programlisting">
<strong>error: Missing keys ("square_footage", "condition") for TypedDict</strong>
<strong>"HouseListing"</strong></pre>
<p>To indicate to the type checker that some keys may be omitted (but to still validate those that are given), add <span class="code">total=False</span> to the class declaration:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">HouseListing</code><code class="p">(</code><code class="n">typing</code><code class="o">.</code><code class="n">TypedDict</code><code class="p">,</code><code> </code><code class="n">total</code><code class="o">=</code><code class="kc">False</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><em><code class="c1"># ...</code></em></pre>
<p><span class="version">3.11+</span> Individual fields can also use the <span class="code">Required</span> or <span class="code">NotRequired</span> type annotations to explicitly mark them as required or optional:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">HouseListing</code><code class="p">(</code><code class="n">typing</code><code class="o">.</code><code class="n">TypedDict</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">address</code><code class="p">:</code><code> </code><code class="n">typing</code><code class="o">.</code><code class="n">Required</code><code class="p">[</code><code class="nb">str</code><code class="p">]</code><code>
</code><code>    </code><code class="n">list_price</code><code class="p">:</code><code> </code><code class="nb">int</code><code>
</code><code>    </code><code class="n">square_footage</code><code class="p">:</code><code> </code><code class="n">typing</code><code class="o">.</code><code class="n">NotRequired</code><code class="p">[</code><code class="nb">int</code><code class="p">]</code><code>
</code><code>    </code><code class="n">condition</code><code class="p">:</code><code> </code><code class="nb">str</code></pre>
<p><span class="code">TypedDict</span> can be used to define a generic type, too:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">T</code><code> </code><code class="o">=</code><code> </code><code class="n">typing</code><code class="o">.</code><code class="n">TypeVar</code><code class="p">(</code><code class="s1">'</code><code class="s1">T</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">Node</code><code class="p">(</code><code class="n">typing</code><code class="o">.</code><code class="n">TypedDict</code><code class="p">,</code><code> </code><code class="n">typing</code><code class="o">.</code><code class="n">Generic</code><code class="p">[</code><code class="n">T</code><code class="p">]</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">label</code><code class="p">:</code><code> </code><code class="n">T</code><code>
</code><code>    </code><code class="n">neighbors</code><code class="p">:</code><code> </code><code class="nb">list</code><code class="p">[</code><code class="n">T</code><code class="p">]</code><code>
</code><code>
</code><code class="n">n</code><code> </code><code class="o">=</code><code> </code><code class="n">Node</code><code class="p">(</code><code class="n">label</code><code class="o">=</code><code class="s1">'</code><code class="s1">Acme</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">neighbors</code><code class="o">=</code><code class="p">[</code><code class="s1">'</code><code class="s1">anvil</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">magnet</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">bird seed</code><code class="s1">'</code><code class="p">]</code><code class="p">)</code></pre>
<div data-type="warning" epub:type="warning">
<h1>Do Not Use the Legacy TypedDict(name, **fields) Format</h1>
<p>To support backporting to older versions of Python, the initial release of <span class="code">TypedDict</span> also let you use a syntax similar to that for <span class="code">namedtuple</span>, such as:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">HouseListing</code> <code class="o">=</code> <code class="n">TypedDict</code><code class="p">(</code><code class="s1">'HouseListing'</code><code class="p">,</code>
                         <code class="n">address</code><code class="o">=</code><code class="nb">str</code><code class="p">,</code> 
                         <code class="n">list_price</code><code class="o">=</code><code class="nb">int</code><code class="p">,</code> 
                         <code class="n">square_footage</code><code class="o">=</code><code class="nb">int</code><code class="p">,</code> 
                         <code class="n">condition</code><code class="o">=</code><code class="nb">str</code><code class="p">)</code></pre>
<p>or:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">HouseListing</code> <code class="o">=</code> <code class="n">TypedDict</code><code class="p">(</code><code class="s1">'HouseListing'</code><code class="p">,</code>
                         <code class="p">{</code><code class="s1">'address'</code><code class="p">:</code> <code class="nb">str</code><code class="p">,</code> 
                          <code class="s1">'list_price'</code><code class="p">:</code> <code class="nb">int</code><code class="p">,</code> 
                          <code class="s1">'square_footage'</code><code class="p">:</code> <code class="nb">int</code><code class="p">,</code>
                          <code class="s1">'condition'</code><code class="p">:</code> <code class="nb">str</code><code class="p">})</code></pre>
<p>These forms are deprecated in Python 3.11, and are planned to be removed in Python 3.13.</p>
</div>
<p>Note that <span class="code">TypedDict</span> does not actually define a new type. Classes created by inheriting from <span class="code">TypedDict</span> actually serve as <span class="code">dict</span> factories, such that instances created from them <em>are</em> <span class="code">dict</span>s. Reusing the previous code snippet defining the <span class="code">Node</span> class, we can see this using the <span class="code">type</span> built-in function:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">n</code><code> </code><code class="o">=</code><code> </code><code class="n">Node</code><code class="p">(</code><code class="n">label</code><code class="o">=</code><code class="s1">'</code><code class="s1">Acme</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">neighbors</code><code class="o">=</code><code class="p">[</code><code class="s1">'</code><code class="s1">anvil</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">magnet</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">bird seed</code><code class="s1">'</code><code class="p">]</code><code class="p">)</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="nb">type</code><code class="p">(</code><code class="n">n</code><code class="p">)</code><code class="p">)</code><code>           </code><em><code class="c1"># prints: &lt;class 'dict'&gt;</code></em><code>
</code><code class="nb">print</code><code class="p">(</code><code class="nb">type</code><code class="p">(</code><code class="n">n</code><code class="p">)</code><code> </code><code class="ow">is</code><code> </code><code class="nb">dict</code><code class="p">)</code><code>   </code><em><code class="c1"># prints: True</code></em></pre>
<p>There is no special runtime conversion or initialization when using <span class="code">TypedDict</span>; the benefits of <span class="code">TypedDict</span> are those of static type checking and self documentation, which naturally accrue from using type annotations.<a contenteditable="false" data-startref="CTtypeddict05" data-type="indexterm" id="idm44924584863504"/></p>
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="which_should_you_usecomma_namedtuple_or">
<h5>Which Should You Use, NamedTuple or TypedDict?</h5>
<p>The<a contenteditable="false" data-primary="NamedTuple" data-type="indexterm" id="idm44924584860208"/><a contenteditable="false" data-primary="custom types" data-secondary="NamedTuple versus TypedDict" data-type="indexterm" id="idm44924584859072"/> two data types appear similar in terms of their supported features, but there are significant differences that should help you determine which one to use.</p>
<p><span class="code">NamedTuple</span>s are immutable, so they can be used as dictionary keys or stored in sets, and are inherently safe to share across threads. As a <span class="code">NamedTuple</span> object is a tuple, you can get its property values in order simply by iterating over it. However, to get the attribute names, you need to use the<a contenteditable="false" data-primary="__annotations__" data-type="indexterm" id="idm44924584855888"/> special <span class="code">__annotations__</span> attribute.</p>
<p>Since classes created with <span class="code">TypedDict</span> are actually <span class="code">dict</span> factories, instances created from them are <span class="code">dict</span>s, with all the behavior and attributes of <span class="code">dict</span>s. They are mutable, so their values can be updated without creating a new container instance, and they support all the <span class="code">dict</span> methods, such as <span class="code">keys</span>, <span class="code">values</span>, and <span class="code">items</span>. They are also easily serialized using JSON or <span class="code">pickle</span>. However, being mutable, they cannot be used as keys in another <span class="code">dict</span>, nor can they be stored in a <span class="code">set</span>.</p>
<p><span class="code">TypedDict</span>s are more lenient than <span class="code">NamedTuple</span>s about missing keys. When a key is omitted when constructing a <span class="code">TypedDict</span>, there is no error (though you will get a type-check warning from the static type checker). On the other hand, if an attribute is omitted when constructing a <span class="code">NamedTuple</span>, this will raise a runtime <span class="code">TypeError</span>.</p>
<p>In short, there is no across-the-board rule for when to use a <span class="code">NamedTuple</span> versus a <span class="code">TypedDict</span>. Consider these alternative behaviors and how they relate to your program and its use of these data objects when deciding between a <span class="code">NamedTuple</span> and a <span class="code">TypedDict</span>—and don’t forget the other, often preferable, alternative of using a <span class="code">dataclass</span> (covered in <a data-type="xref" href="ch04.xhtml#data_classes">“Data Classes”</a>) instead!<a contenteditable="false" data-primary="" data-startref="typeddict05" data-type="indexterm" id="idm44924584805536"/></p>
</div></aside>
</div></section>
<section data-pdf-bookmark="TypeAlias" data-type="sect3"><div class="sect3" id="typealias">
<h3>TypeAlias</h3>
<p><span class="version">3.10+</span> Defining<a contenteditable="false" data-primary="TypeAlias (typing module)" data-type="indexterm" id="idm44924584802064"/><a contenteditable="false" data-primary="custom types" data-secondary="TypeAlias" data-type="indexterm" id="idm44924584800864"/> a simple type alias can be misinterpreted as assigning a class to a variable. For instance, here we define a type for record identifiers in a database:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">Identifier</code> <code class="o">=</code> <code class="nb">int</code></pre>
<p>To clarify that this statement is intended to define a custom type name for the purposes of type checking, use <span class="code">TypeAlias</span>:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">Identifier</code><code class="p">:</code> <code class="n">TypeAlias</code> <code class="o">=</code> <code class="nb">int</code></pre>
<p><span class="code">TypeAlias</span> is also useful when defining an alias for a type that is not yet defined, and so referenced as a string value:</p>
<pre data-code-language="python" data-type="programlisting">
<em><code class="c1"># Python will treat this like a standard str assignment</code></em><code>
</code><code class="n">TBDType</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">ClassNotDefinedYet</code><code class="s1">'</code><code>
</code><code>
</code><em><code class="c1"># indicates that this is actually a forward reference to a class</code></em><code>
</code><code class="n">TBDType</code><code class="p">:</code><code> </code><code class="n">TypeAlias</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">ClassNotDefinedYet</code><code class="s1">'</code></pre>
<p class="pagebreak-before"><span class="code">TypeAlias</span> types may only be defined at module scope. Custom types defined using <span class="code">TypeAlias</span> are interchangeable with the target type. Contrast <span class="code">TypeAlias</span> (which does not create a new type, just gives a new name for an existing one) with <span class="code">NewType</span>, covered in the following section, which does create a new type.</p>
</div></section>
<section data-pdf-bookmark="NewType" data-type="sect3"><div class="sect3" id="newtype">
<h3>NewType</h3>
<p><span class="code">NewType</span><a contenteditable="false" data-primary="NewType" data-type="indexterm" id="idm44924584727552"/><a contenteditable="false" data-primary="custom types" data-secondary="NewType" data-type="indexterm" id="idm44924584726448"/> allows you to define application-specific subtypes, to avoid confusion that might result from using the same type for different variables. If your program uses <span class="code">str</span> values for different types of data, for example, it is easy to accidentally interchange values. Suppose you have a program that models employees in departments. The following type declaration is not sufficiently descriptive—which is the key and which is the value?</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">employee_department_map</code><code class="p">:</code> <code class="nb">dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="nb">str</code><code class="p">]</code> <code class="o">=</code> <code class="p">{}</code></pre>
<p>Defining types for employee and department IDs makes this declaration clearer:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">EmpId</code> <code class="o">=</code> <code class="n">typing</code><code class="o">.</code><code class="n">NewType</code><code class="p">(</code><code class="s1">'EmpId'</code><code class="p">,</code> <code class="nb">str</code><code class="p">)</code>
<code class="n">DeptId</code> <code class="o">=</code> <code class="n">typing</code><code class="o">.</code><code class="n">NewType</code><code class="p">(</code><code class="s1">'DeptId'</code><code class="p">,</code> <code class="nb">str</code><code class="p">)</code>
<code class="n">employee_department_map</code><code class="p">:</code> <code class="nb">dict</code><code class="p">[</code><code class="n">EmpId</code><code class="p">,</code> <code class="n">DeptId</code><code class="p">]</code> <code class="o">=</code> <code class="p">{}</code></pre>
<p>These type definitions will also allow type checkers to flag this incorrect usage:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="nf">transfer_employee</code><code class="p">(</code><code class="n">empid</code><code class="p">:</code><code> </code><code class="n">EmpId</code><code class="p">,</code><code> </code><code class="n">to_dept</code><code class="p">:</code><code> </code><code class="n">DeptId</code><code class="p">)</code><code class="p">:</code><code>
</code><strong><code>   </code></strong><code> </code><em><code class="c1"># update department for employee</code><code>
</code></em><code>     </code><code class="n">employee_department_map</code><code class="p">[</code><code class="n">to_dept</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">empid</code></pre>
<p>Running <span class="code">mypy</span> reports these errors for the line <span class="code">employee_department_map[to_dept] = empid</span>:</p>
<pre data-type="programlisting">
<strong>error: Invalid index type "DeptId" for "Dict[EmpId, DeptId]"; expected</strong>
<strong>type "EmpId"</strong>
<strong>error: Incompatible types in assignment (expression has type "EmpId",</strong>
<strong>target has type "DeptId")</strong></pre>
<p>Using <span class="code">NewType</span> often requires you to use <span class="code">typing.cast</span> too; for example, to create an <span class="code">EmpId</span>, you need to cast a <span class="code">str</span> to the <span class="code">EmpId</span> type.</p>
<p>You can also use <span class="code">NewType</span> to indicate the desired implementation type for an application-specific type. For instance, the basic US postal zip code is five numeric digits. It is common to see this implemented using <span class="code">int</span>, which becomes problematic with zip codes that have a leading <span class="code">0</span>. To indicate that zip codes should be implemented using <span class="code">str</span>, your code can define this type-checking type:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">ZipCode</code> <code class="o">=</code> <code class="n">typing</code><code class="o">.</code><code class="n">NewType</code><code class="p">(</code><code class="s2">"ZipCode"</code><code class="p">,</code> <code class="nb">str</code><code class="p">)</code></pre>
<p>Annotating variables and function arguments using <span class="code">ZipCode</span> will help flag incorrect uses of <span class="code">int</span> for zip code values.<a contenteditable="false" data-primary="" data-startref="TMcustom05" data-type="indexterm" id="idm44924574635408"/><a contenteditable="false" data-primary="" data-startref="TAmod05" data-type="indexterm" id="idm44924574620512"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Using Type Annotations at Runtime" data-type="sect1"><div class="sect1" id="using_type_annotations_at_runtime">
<h1>Using Type Annotations at Runtime</h1>
<p>Function<a contenteditable="false" data-primary="type annotations" data-secondary="using at runtime" data-type="indexterm" id="idm44924574617568"/><a contenteditable="false" data-primary="__annotations__" data-type="indexterm" id="idm44924574616160"/> and class variable annotations can be introspected by accessing the function or class’s <span class="code">__annotations__</span> attribute (although a <a href="https://oreil.ly/r-YsZ">better practice</a> is to instead call <span class="code">inspect.get_annotations()</span>):</p>
<pre data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><strong><code class="k">def</code></strong><code> </code><code class="nf">f</code><code class="p">(</code><code class="n">a</code><code class="p">:</code><code class="nb">list</code><code class="p">[</code><code class="nb">str</code><code class="p">]</code><code class="p">,</code><code> </code><code class="n">b</code><code class="p">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><code class="nb">int</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><strong><code class="k">pass</code></strong><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">f</code><code class="o">.</code><code class="vm">__annotations__</code></pre>
<pre data-type="programlisting">
<strong>{'a': list[str], 'return': &lt;class 'int'&gt;}</strong></pre>
<pre data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><strong><code class="k">class</code></strong><code> </code><code class="nc">Customer</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="n">name</code><code class="p">:</code><code> </code><code class="nb">str</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="n">reward_points</code><code class="p">:</code><code> </code><code class="nb">int</code><code> </code><code class="o">=</code><code> </code><code class="mi">0</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">Customer</code><code class="o">.</code><code class="vm">__annotations__</code></pre>
<pre data-type="programlisting">
<strong>{'name': &lt;class 'str'&gt;, 'reward_points': &lt;class 'int'&gt;}</strong></pre>
<p>This feature is used by third-party packages such as <span class="code">pydantic</span> and FastAPI to provide extra code generation and validation capabilities.</p>
<p><span class="version">3.8+</span> To define your own custom protocol class that supports runtime checking with <span class="code">issubclass</span> and <span class="code">isinstance</span>, define that class as a subclass of <span class="code">typing.Protocol</span>, with empty method definitions for the required protocol methods, and decorate the class with <span class="code">@runtime_checkable</span> (covered in <a data-type="xref" href="#commonly_used_functions_and_decorators">Table 5-6</a>). If you <em>don’t</em> decorate it with <span class="code">@runtime_checkable</span>, you’re still defining a <span class="code">Protocol</span> that’s quite usable for static type checking, but it won’t be runtime-checkable with <span class="code">issubclass</span> and <span class="code">isinstance</span>.</p>
<p>For example, we could define a protocol that indicates that a class implements the <span class="code">update</span> and <span class="code">undo</span> methods as follows (the Python <span class="code">Ellipsis</span>, <span class="code">...</span>, is a convenient syntax for indicating an empty method definition):</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">T</code><code> </code><code class="o">=</code><code> </code><code class="n">typing</code><code class="o">.</code><code class="n">TypeVar</code><code class="p">(</code><code class="s1">'</code><code class="s1">T</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>
</code><code class="nd">@typing</code><code class="o">.</code><code class="n">runtime_checkable</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">SupportsUpdateUndo</code><code class="p">(</code><code class="n">typing</code><code class="o">.</code><code class="n">Protocol</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">update</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="o">*</code><code class="n">args</code><code class="p">:</code><code> </code><code class="n">T</code><code class="p">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="kc">None</code></strong><code class="p">:</code><code>
</code><code>        </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">undo</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="kc">None</code></strong><code class="p">:</code><code>
</code><code>        </code><code class="o">.</code><code class="o">.</code><code class="o">.</code></pre>
<p>Without making any changes to the inheritance path of <span class="code">Accumulator</span> (defined in <a data-type="xref" href="#generics_and_typevars">“Generics and TypeVars”</a>), it now satisfies runtime type checks with <span class="code">SupportsUpdateUndo</span>:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;&gt;</code> <code class="nb">issubclass</code><code class="p">(</code><code class="n">Accumulator</code><code class="p">,</code> <code class="n">SupportsUpdateUndo</code><code class="p">)</code></pre>
<pre data-type="programlisting">
<strong>True</strong></pre>
<pre class="pagebreak-before" data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;&gt;</code> <code class="nb">isinstance</code><code class="p">(</code><code class="n">acc</code><code class="p">,</code> <code class="n">SupportsUpdateUndo</code><code class="p">)</code></pre>
<pre data-type="programlisting">
<strong>True</strong></pre>
<p>In addition, any other class that implements <span class="code">update</span> and <span class="code">undo</span> methods will now qualify as a <span class="code">SupportsUpdateUndo</span> “subclass.”</p>
</div></section>
<section data-pdf-bookmark="How to Add Type Annotations to Your Code" data-type="sect1"><div class="sect1" id="how_to_add_type_annotations_to_your_cod">
<h1>How to Add Type Annotations to Your Code</h1>
<p>Having<a contenteditable="false" data-primary="type annotations" data-secondary="adding to code" data-type="indexterm" id="TAadd05"/> seen some of the features and capabilities provided by using type annotations, you may be wondering about the best way to get started. This section describes a few scenarios and approaches to adding type annotations.</p>
<section data-pdf-bookmark="Adding Type Annotations to New Code" data-type="sect2"><div class="sect2" id="adding_type_annotations_to_new_code">
<h2>Adding Type Annotations to New Code</h2>
<p>When you start writing a short Python script, adding type annotations may seem like an unnecessary extra burden. As a spinoff of the<a contenteditable="false" data-primary="Two Pizza Rule" data-type="indexterm" id="idm44924574338592"/> <a href="https://oreil.ly/SWLnG">Two Pizza Rule</a>, we suggest the<a contenteditable="false" data-primary="Two Function Rule" data-type="indexterm" id="idm44924574336256"/> Two Function Rule: as soon as your script contains two functions or methods, go back and add type annotations to the<a contenteditable="false" data-primary="function signatures" data-secondary="adding type annotations to new code" data-type="indexterm" id="idm44924574318192"/> method signatures, and any shared variables or types as necessary. Use<a contenteditable="false" data-primary="TypedDict (typing module)" data-type="indexterm" id="idm44924574316720"/> <span class="code">TypedDict</span> to annotate any <span class="code">dict</span> structures that are used in place of classes, so that <span class="code">dict</span> keys get clearly defined up front or get documented as you go; use <span class="code">NamedTuple</span>s (or <span class="code">dataclass</span>es: some of this book’s authors <em>strongly</em> prefer the latter option) to define the specific attributes needed for those data “bundles.”</p>
<p>If you are beginning a major project with many modules and classes, then you should definitely use type annotations from the beginning. They can easily make you more productive, as they help avoid common naming and typing mistakes and ensure you get more fully supported autocompletion while working in your IDE. This is even more important on projects with multiple developers: having documented types helps tell everyone on the team the expectations for types and values to be used across the project. Capturing these types in the code itself makes them immediately accessible and visible during development, much more so than separate documentation or specifications.</p>
<p>If you are developing a library to be shared across projects, then you should also use type annotations from the very start, most likely paralleling the function signatures in your API design. Having type annotations in a library will make life easier for your client developers, as all modern IDEs include type annotation plug-ins to support static type checking and function autocompletion and documentation. They will also help you when writing your unit tests, since you will benefit from the same rich IDE support.</p>
<p>For any of these projects, add a type-checking utility to your pre-commit hooks, so that you stay ahead of any type infractions that might creep into your new codebase. This way you can fix them as they occur, instead of waiting until you do a large commit and finding that you have made some fundamental typing errors in multiple places.</p>
</div></section>
<section data-pdf-bookmark="Adding Type Annotations to Existing Code (Gradual Typing)" data-type="sect2"><div class="sect2" id="adding_type_annotations_to_existing_cod">
<h2>Adding Type Annotations to Existing Code (Gradual Typing)</h2>
<p>Several companies<a contenteditable="false" data-primary="gradual typing" data-type="indexterm" id="idm44924574308592"/> that have run projects to apply type annotations to large existing codebases recommend an incremental approach, referred to as <em>gradual typing</em>. With gradual typing, you can work through your codebase in a stepwise manner, adding and validating type annotations a few classes or modules at a time.</p>
<p>Some utilities, like <span class="code">mypy</span>, will let you add type annotations function by function. <span class="code">mypy</span>, by default, skips functions without typed signatures, so you can methodically go through your codebase a few functions at a time. This incremental process allows you to focus your efforts on individual parts of the code, as opposed to adding type annotations everywhere and then trying to sort out an avalanche of type-checker errors.</p>
<p>Some recommended approaches are:</p>
<ul>
<li>
<p>Identify your most heavily used modules, and begin adding types to them, a method at a time. (These could be core application class modules, or widely shared utility modules.)</p>
</li>
<li>
<p>Annotate a few methods at a time, so that type-checking issues get raised and resolved gradually.</p>
</li>
<li>
<p>Use <span class="code">pytype</span> or <span class="code">pyre</span> inference to generate initial <em>.pyi</em> stub files (discussed in the following section). Then, steadily migrate types from the <em>.pyi</em> files, either manually or using automation such as <span class="code">pytype</span>’s <span class="code">merge_pyi</span> utility.</p>
</li>
<li>
<p>Begin using type checkers in a lenient default mode, so that most code is skipped and you can focus attention on specific files. As work progresses, shift to a stricter mode so that remaining items are made more prominent, and files that have been annotated do not regress by taking on new nonannotated code.</p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Using .pyi Stub Files" data-type="sect2"><div class="sect2" id="using_dotpyi_stub_files">
<h2>Using .pyi Stub Files</h2>
<p>Sometimes<a contenteditable="false" data-primary=".pyi stub files" data-type="indexterm" id="idm44924574294816"/> you don’t have access to Python type annotations. For example, you might be using a library that does not have type annotations, or using a module whose functions are implemented in C.</p>
<p>In these cases, you can use separate <em>.pyi</em> stub files containing just the related type annotations. Several of the type checkers mentioned at the beginning of this chapter can generate these stub files. You can download stub files for popular Python libraries, as well as the Python standard library itself, from the <a href="https://oreil.ly/jKhNR"><span class="code">typeshed</span> repository</a>. You can maintain stub files from the Python source, or, using merging utilities available in some of the type checkers, integrate them back into the original Python source.<a contenteditable="false" data-primary="" data-startref="TAadd05" data-type="indexterm" id="idm44924574291472"/></p>
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="do_type_annotations_get_in_the_way_of_c">
<h5>Do Type Annotations Get in the Way of Coding?</h5>
<p>Type annotations carry some stigma, especially for those who have worked with Python for many years and are used to taking full advantage of Python’s adaptive nature. Flexible method signatures like that of the built-in function <span class="code">max</span>, which can take a single argument containing a sequence of values or multiple arguments containing the values to be maximized, have been cited as being <a href="https://oreil.ly/gE_Kx">especially challenging to type-annotate</a>. Is this the fault of the code? Of typing? Of Python itself? Each of these explanations is possible.</p>
<p>In general, typing fosters a degree of formalism and discipline that can be more confining than the historical Python philosophy of “coding by and for consenting adults.” Moving forward, we may find that the flexibility of style in older Python code is not wholly conducive to long-term use, reuse, and maintenance by those who are not the original code authors. As a recent PyCon presenter <a href="https://oreil.ly/iMCNG">suggested</a>, “Ugly type annotations hint at ugly code.” (However, it may sometimes be the case, like for <span class="code">max</span>, that it’s the typing system that’s not expressive enough.)</p>
<p>You can take the level of typing difficulty as an indicator of your method design. If your methods require multiple <span class="code">Union</span> definitions, or multiple overrides for the same method using different argument types, perhaps your design is too flexible across multiple calling styles. You may be overdoing the flexibility of your API because Python allows it, but that might not always be a good idea in the long run. After all, as the <a href="https://oreil.ly/isBLG">Zen of Python</a> says, “There should be one—and preferably only one—obvious way to do it.” Maybe that should include “only one obvious way” to call your API!</p>
</div></aside>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id00002">
<h1>Summary</h1>
<p>Python has steadily risen to prominence as a powerful language and programming ecosystem, supporting important enterprise applications. What was once a utility language for scripting and task automation has become a platform for significant and complex applications affecting millions of users, used in mission-critical and even extraterrestrial systems.<sup><a data-type="noteref" href="ch05.xhtml#ch01fn76" id="ch01fn76-marker">5</a></sup> Adding type annotations is a significant step in developing and maintaining these systems.</p>
<p>The <a href="https://oreil.ly/Zg_NX">online documentation</a> for type annotations provides up-to-date descriptions, examples, and <a href="https://oreil.ly/xhq5g">best practices</a> as the syntax and practices for annotating types continue to evolve. The authors also recommend <a class="orm:hideurl" href="http://oreilly.com/library/view/fluent-python-2nd/9781492056348"><em>Fluent Python</em>, 2nd edition</a>, by Luciano Ramalho (O’Reilly), especially Chapters 8 and 15, which deal specifically with Python type annotations.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn72"><sup><a href="ch05.xhtml#ch01fn72-marker">1</a></sup> Strong, extensive unit tests will also guard against many business logic problems that no amount of type checking would ever catch for you—so, type hints are not to be used <em>instead of</em> unit tests, but <em>in addition</em> to them.</p><p data-type="footnote" id="ch01fn73"><sup><a href="ch05.xhtml#ch01fn73-marker">2</a></sup> The <em>syntax</em> for type annotation was introduced in Python 3.0, but only later were its <em>semantics</em> specified.</p><p data-type="footnote" id="ch01fn74"><sup><a href="ch05.xhtml#ch01fn74-marker">3</a></sup> This approach was also compatible with Python 2.7 code, still in widespread use at the time.</p><p data-type="footnote" id="ch01fn75"><sup><a href="ch05.xhtml#ch01fn75-marker">4</a></sup> And <span class="code">SupportsInt</span> uses the <span class="code">runtime_checkable</span> decorator.</p><p data-type="footnote" id="ch01fn76"><sup><a href="ch05.xhtml#ch01fn76-marker">5</a></sup> NASA’s Jet Propulsion Lab used Python for the Persistence Mars Rover and the Ingenuity Mars Helicopter; the team responsible for the discovery of gravitational waves used Python both to coordinate the instrumentation and to analyze the resulting hoard of data.</p></div></div></section></div></body></html>