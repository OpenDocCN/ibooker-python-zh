- en: Chapter 12\. Wrangle and Mangle Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。整理和处理数据
- en: If you torture the data enough, nature will always confess.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你折磨数据足够久，自然会招认。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Ronald Coase
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 罗纳德·科斯
- en: Up to this point, we’ve talked mainly about the Python language itself—its data
    types, code structures, syntax, and so on. The rest of this book is about application
    of these to real-world problems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要讨论了Python语言本身——其数据类型、代码结构、语法等等。本书的其余部分是关于将这些应用到现实世界问题的内容。
- en: In this chapter, you’ll learn many practical techniques for taming data. Sometimes,
    this is called *data munging*, or the more businesslike *ETL* (extract/transform/load)
    of the database world. Although programming books usually don’t cover the topic
    explicitly, programmers spend a lot of time trying to mold data into the right
    shape for their purposes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习许多实用的数据处理技术。有时，这被称为*数据清洗*，或者更商业化的*ETL*（提取/转换/加载）在数据库世界中。尽管编程书籍通常不会明确涵盖这个主题，程序员们花费了大量时间来将数据塑造成符合其目的的正确形式。
- en: The specialty called *data science* has become very popular in the past few
    years. A *Harvard Business Review* article called data scientist the “sexiest
    job of the 21st century.” If this meant in demand and well paying, then okay,
    but there’s also more than enough drudgery. Data science goes beyond the ETL requirements
    of databases, often involving *machine learning* to unearth insights that were
    not visible to human eyes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据科学*这一专业在过去几年变得非常流行。《哈佛商业评论》的一篇文章称数据科学家是“21世纪最性感的职业”。如果这意味着需求量大且薪资丰厚，那就好，但也有足够的单调乏味。数据科学超越了数据库的ETL需求，通常涉及*机器学习*，以发掘人眼看不到的洞察力。'
- en: I’ll start with basic data formats and then work up to the most useful new tools
    for data science.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从基本的数据格式开始，然后介绍最有用的新数据科学工具。
- en: 'Data formats fall roughly into two categories: *text* and *binary*. Python
    *strings* are used for text data, and this chapter includes string information
    that we’ve skipped so far:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数据格式大致分为两类：*文本*和*二进制*。Python的*字符串*用于文本数据，本章包含了我们迄今为止跳过的字符串信息：
- en: '*Unicode* characters'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Unicode*字符'
- en: '*Regular expression* pattern matching.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正则表达式*模式匹配。'
- en: 'Then, we jump to binary data, and two more of Python’s built-in types:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向二进制数据，以及Python的另外两种内置类型：
- en: '*Bytes* for immutable eight-bit values'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字节*用于不可变的八位值'
- en: '*Bytearrays* for mutable ones'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字节数组*用于可变的字节'
- en: 'Text Strings: Unicode'
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本字符串：Unicode
- en: You saw the basics of Python strings in [Chapter 5](ch05.html#ch_strings). Now
    it’s time to really dig into Unicode.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第5章](ch05.html#ch_strings)中看到了Python字符串的基础知识。现在是深入了解Unicode的时候了。
- en: Python 3 strings are Unicode character sequences, not byte arrays. This is,
    by far, the single largest language change from Python 2.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3的字符串是Unicode字符序列，而不是字节数组。这是从Python 2最大的语言变化。
- en: All of the text examples in this book thus far have been plain old ASCII (American
    Standard Code for Information Interchange). ASCII was defined in the 1960s, before
    mullets roamed the earth. Computers then were the size of refrigerators, and only
    slightly smarter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中的所有文本示例都是普通的ASCII（美国标准信息交换码）。ASCII是在六十年代定义的，在鲑鱼头发流行之前。当时的计算机大小如冰箱，稍微聪明一点。
- en: 'The basic unit of computer storage is the *byte*, which can store 256 unique
    values in its eight *bits*. For various reasons, ASCII used only seven bits (128
    unique values): 26 uppercase letters, 26 lowercase letters, 10 digits, some punctuation
    symbols, some spacing characters, and some nonprinting control codes.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机存储的基本单元是*字节*，它可以存储256个独特的值在它的八*位*中。出于各种原因，ASCII只使用了七位（128个独特的值）：26个大写字母、26个小写字母、10个数字、一些标点符号、一些间隔字符和一些不可打印的控制码。
- en: 'Unfortunately, the world has more letters than ASCII provides. You could have
    a hot dog at a diner, but never a Gewürztraminer^([1](ch12.html#idm45794991539400))
    at a café. Many attempts have been made to cram more letters and symbols into
    eight bits, and you’ll see them at times. Just a couple of those include:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，世界上的字母比ASCII提供的还要多。你可以在餐馆吃热狗，但在咖啡馆永远也买不到Gewürztraminer^([1](ch12.html#idm45794991539400))。已经尝试过许多方法将更多的字母和符号塞入八位中，有时你会看到它们。其中只有一些包括：
- en: '*Latin-1*, or *ISO 8859-1*'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Latin-1*，或者*ISO 8859-1*'
- en: Windows code page *1252*
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows代码页*1252*
- en: Each of these uses all eight bits, but even that’s not enough, especially when
    you need non-European languages. *Unicode* is an ongoing international standard
    to define the characters of all the world’s languages, plus symbols from mathematics
    and other fields. And emojis!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符都使用了所有的八位，但即使如此也不够，特别是在需要非欧洲语言时。*Unicode* 是一个持续进行的国际标准，用于定义所有世界语言的字符，以及数学和其他领域的符号。还有表情符号！
- en: Unicode provides a unique number for every character, no matter what the platform,
    no matter what the program, no matter what the language.
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Unicode 为每个字符提供了一个唯一的编号，无论是什么平台、什么程序、什么语言。
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Unicode Consortium
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Unicode 联盟
- en: The [Unicode Code Charts page](http://www.unicode.org/charts) has links to all
    the currently defined character sets with images. The latest version (12.0) defines
    more than 137,000 characters, each with a unique name and identification number.
    Python 3.8 handles all of these. The characters are divided into eight-bit sets
    called *planes*. The first 256 planes are the *basic multilingual planes*. See
    the Wikipedia page about [Unicode planes](http://bit.ly/unicode-plane) for details.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[Unicode 代码图表页面](http://www.unicode.org/charts)包含所有当前定义的字符集的链接及其图像。最新版本（12.0）定义了超过137,000个字符，每个字符都有唯一的名称和标识号码。Python
    3.8 可以处理所有这些字符。这些字符被分为称为*平面*的八位集合。前256个平面是*基本多语言平面*。详细信息请参阅关于[Unicode 平面](http://bit.ly/unicode-plane)的维基百科页面。'
- en: Python 3 Unicode Strings
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 3 Unicode 字符串
- en: 'If you know the Unicode ID or name for a character, you can use it in a Python
    string. Here are some examples:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道字符的 Unicode ID 或名称，可以在 Python 字符串中使用它。以下是一些示例：
- en: A `\u` followed by *four* hex numbers^([2](ch12.html#idm45794991521032)) specifies
    a character in one of Unicode’s 256 basic multilingual planes. The first two are
    the plane number (`00` to `FF`), and the next two are the index of the character
    within the plane. Plane `00` is good old ASCII, and the character positions within
    that plane are the same as ASCII.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\u`后跟*四*个十六进制数字^([2](ch12.html#idm45794991521032))指定 Unicode 的256个基本多语言平面中的一个字符。前两个数字是平面编号（`00`到`FF`），后两个数字是平面内字符的索引。平面`00`是老旧的
    ASCII，该平面内的字符位置与 ASCII 相同。'
- en: For characters in the higher planes, we need more bits. The Python escape sequence
    for these is `\U` followed by *eight* hex characters; the leftmost ones need to
    be `0`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于高平面中的字符，我们需要更多的位数。Python 中这些字符的转义序列是`\U`后跟*八*个十六进制字符；最左边的数字需要是`0`。
- en: For all characters, ``\N{*`name`*}`` lets you specify it by its standard *name*.
    The [Unicode Character Name Index page](http://www.unicode.org/charts/charindex.html)
    lists these.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有字符，``\N{*`name`*}`` 允许您通过其标准*名称*指定它。[Unicode 字符名称索引页面](http://www.unicode.org/charts/charindex.html)列出了这些名称。
- en: 'The Python `unicodedata` module has functions that translate in both directions:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `unicodedata` 模块具有双向转换的功能：
- en: '`lookup()`—Takes a case-insensitive name and returns a Unicode character'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lookup()`—接受一个不区分大小写的名称，并返回一个 Unicode 字符。'
- en: '`name()`—Takes a Unicode character and returns an uppercase name'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name()`—接受一个 Unicode 字符并返回其大写名称。'
- en: 'In the following example, we’ll write a test function that takes a Python Unicode
    character, looks up its name, and looks up the character again from the name (it
    should match the original character):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将编写一个测试函数，该函数接受一个 Python Unicode 字符，查找其名称，然后根据名称再次查找字符（应该与原始字符匹配）：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s try some characters, beginning with a plain ASCII letter:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些字符，首先是一个普通的 ASCII 字母：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'ASCII punctuation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII 标点符号：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A Unicode currency character:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 货币字符：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Another Unicode currency character:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 Unicode 货币字符：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The only problem you could potentially run into is limitations in the font
    you’re using to display text. Few fonts have images for all Unicode characters,
    and might display some placeholder character for missing ones. For instance, here’s
    the Unicode symbol for `SNOWMAN`, like symbols in dingbat fonts:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能遇到的唯一问题是字体显示文本的限制。很少有字体包含所有 Unicode 字符的图像，可能会为缺失的字符显示一些占位符字符。例如，这是 `SNOWMAN`
    的 Unicode 符号，类似于装饰符字体中的符号：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Suppose that we want to save the word `café` in a Python string. One way is
    to copy and paste it from a file or website and hope that it works:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要在 Python 字符串中保存单词 `café`。一种方法是从文件或网站复制并粘贴它，然后希望它能正常工作：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This worked because I copied and pasted from a source that used UTF-8 encoding
    (which we look at in a few pages) for its text.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效是因为我从使用 UTF-8 编码的源复制和粘贴了文本。
- en: 'How can we specify that final `é` character? If you look at the character index
    for [E](http://bit.ly/e-index), you see that the name `E WITH ACUTE,` `LATIN SMALL
    LETTER` has the value `00E9`. Let’s check with the `name()` and `lookup()` functions
    that we were just playing with. First give the code to get the name:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如何指定最后的 `é` 字符？如果你查看 [E](http://bit.ly/e-index) 的字符索引，你会看到名称 `E WITH ACUTE,`
    `LATIN SMALL LETTER` 具有值 `00E9`。让我们用刚才玩过的 `name()` 和 `lookup()` 函数来检查。首先给出获取名称的代码：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, give the name to look up the code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，给出查找代码的名称：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The names listed on the Unicode Character Name Index page were reformatted
    to make them sort nicely for display. To convert them to their real Unicode names
    (the ones that Python uses), remove the comma and move the part of the name that
    was after the comma to the beginning. Accordingly, change `E WITH ACUTE, LATIN
    SMALL LETTER` to `LATIN SMALL LETTER E WITH ACUTE`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 字符名称索引页上列出的名称已经重新格式化，使其在显示时可以很好地排序。要将它们转换为真实的 Unicode 名称（Python 使用的名称），去掉逗号并将逗号后面的部分移动到开头。因此，将
    `E WITH ACUTE, LATIN SMALL LETTER` 改为 `LATIN SMALL LETTER E WITH ACUTE`：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we can specify the string `café` by code or by name:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过代码或名称指定字符串 `café`：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding snippet, we inserted the é directly in the string, but we
    can also build a string by appending:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们直接在字符串中插入了 é，但我们也可以通过附加构建字符串：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The string `len()` function counts Unicode *characters*, not bytes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 `len()` 函数计算 Unicode *字符* 数量，而不是字节数：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you know the Unicode numeric ID, you can use the standard `ord()` and `chr()`
    functions to quickly convert between integer IDs and single-character Unicode
    strings:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道 Unicode 的数值 ID，你可以使用标准的 `ord()` 和 `chr()` 函数快速转换整数 ID 和单字符 Unicode 字符串：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: UTF-8
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UTF-8
- en: You don’t need to worry about how Python stores each Unicode character when
    you do normal string processing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的字符串处理中，你不需要担心 Python 如何存储每个 Unicode 字符。
- en: 'However, when you exchange data with the outside world, you need a couple of
    things:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当你与外界交换数据时，你需要一些东西：
- en: A way to *encode* character strings to bytes
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编码* 字符字符串为字节的方法'
- en: A way to *decode* bytes to character strings
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解码* 字节到字符字符串的方法'
- en: If there were fewer than 65,536 characters in Unicode, we could stuff each Unicode
    character ID into two bytes. Unfortunately, there are more. We could encode every
    ID into four bytes, but that would increase the memory and disk storage space
    needs for common text strings by four times.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Unicode 中的字符少于 65,536 个，我们可以将每个 Unicode 字符 ID 塞入两个字节中。不幸的是，字符太多了。我们可以将每个
    ID 编码为四个字节，但这将使常见文本字符串的内存和磁盘存储空间需求增加四倍。
- en: 'Ken Thompson and Rob Pike, whose names will be familiar to Unix developers,
    designed the *UTF-8* dynamic encoding scheme one night on a placemat in a New
    Jersey diner. It uses one to four bytes per Unicode character:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Ken Thompson 和 Rob Pike，Unix 开发者熟悉的名字，设计了一夜之间在新泽西餐馆的餐垫上的 *UTF-8* 动态编码方案。它每个
    Unicode 字符使用一到四个字节：
- en: One byte for ASCII
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASCII 占一个字节
- en: Two bytes for most Latin-derived (but not Cyrillic) languages
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数拉丁衍生（但不包括西里尔语）语言需要两个字节
- en: Three bytes for the rest of the basic multilingual plane
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本多语言平面的其余部分需要三个字节
- en: Four bytes for the rest, including some Asian languages and symbols
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余部分包括一些亚洲语言和符号需要四个字节
- en: UTF-8 is the standard text encoding in Python, Linux, and HTML. It’s fast, complete,
    and works well. If you use UTF-8 encoding throughout your code, life will be much
    easier than trying to hop in and out of various encodings.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 是 Python、Linux 和 HTML 中的标准文本编码。它快速、全面且运行良好。如果你在代码中始终使用 UTF-8 编码，生活将比试图在各种编码之间跳转要容易得多。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you create a Python string by copying and pasting from another source such
    as a web page, be sure the source is encoded in the UTF-8 format. It’s *very*
    common to see text that was encoded as Latin-1 or Windows 1252 copied into a Python
    string, which causes an exception later with an invalid byte sequence.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从网页等其他源复制粘贴创建 Python 字符串，请确保源以 UTF-8 格式编码。经常看到将以 Latin-1 或 Windows 1252 编码的文本复制到
    Python 字符串中，这将导致后来出现无效字节序列的异常。
- en: Encode
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码
- en: You *encode* a *string* to *bytes*. The string `encode()` function’s first argument
    is the encoding name. The choices include those presented in [Table 12-1](#table_12-1).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将字符串 *编码* 为 *字节*。字符串 `encode()` 函数的第一个参数是编码名称。选择包括 [Table 12-1](https://bit.ly/table_12-1)
    中的那些。
- en: Table 12-1\. Encodings
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-1\. 编码
- en: '| Encoding name | Description |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 编码名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `''ascii''` | Good old seven-bit ASCII |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `''ascii''` | 七比特 ASCII 编码 |'
- en: '| `''utf-8''` | Eight-bit variable-length encoding, and what you almost always
    want to use |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `''utf-8''` | 八位变长编码，几乎总是你想要使用的 |'
- en: '| `''latin-1''` | Also known as ISO 8859-1 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `''latin-1''` | 也称为ISO 8859-1 |'
- en: '| `''cp-1252''` | A common Windows encoding |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `''cp-1252''` | 常见的Windows编码 |'
- en: '| `''unicode-escape''` | Python Unicode literal format, `\u`*xxxx* or `\U`*xxxxxxxx*
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `''unicode-escape''` | Python Unicode文本格式，`\u`*xxxx* 或 `\U`*xxxxxxxx* |'
- en: 'You can encode anything as UTF-8. Let’s assign the Unicode string `''\u2603''`
    to the name `snowman`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何东西编码为UTF-8。让我们将Unicode字符串`'\u2603'`赋给名称`snowman`：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`snowman` is a Python Unicode string with a single character, regardless of
    how many bytes might be needed to store it internally:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`snowman`是一个Python Unicode字符串，只有一个字符，无论内部存储它需要多少字节：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, let’s encode this Unicode character to a sequence of bytes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将这个Unicode字符编码为一个字节序列：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As I mentioned earlier, UTF-8 is a variable-length encoding. In this case,
    it used three bytes to encode the single `snowman` Unicode character:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，UTF-8是一种变长编码。在这种情况下，它用三个字节来编码单个`snowman` Unicode字符：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, `len()` returns the number of bytes (3) because `ds` is a `bytes` variable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`len()`返回字节数（3），因为`ds`是一个`bytes`变量。
- en: 'You can use encodings other than UTF-8, but you’ll get errors if the Unicode
    string can’t be handled by the encoding. For example, if you use the `ascii` encoding,
    it will fail unless your Unicode characters happen to be valid ASCII characters,
    as well:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用除UTF-8之外的其他编码，但如果Unicode字符串不能被处理，你会得到错误。例如，如果你使用`ascii`编码，除非你的Unicode字符恰好是有效的ASCII字符，否则会失败：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `encode()` function takes a second argument to help you avoid encoding
    exceptions. Its default value, which you can see in the previous example, is `''strict''`;
    it raises a `UnicodeEncodeError` if it sees a non-ASCII character. There are other
    encodings. Use `''ignore''` to throw away anything that won’t encode:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`encode()`函数接受第二个参数，帮助你避免编码异常。它的默认值，在前面的例子中你可以看到，是`''strict''`；如果遇到非ASCII字符，它会引发一个`UnicodeEncodeError`。还有其他编码方式。使用`''ignore''`来丢弃任何无法编码的内容：'
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Use `''replace''` to substitute `?` for unknown characters:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`'replace'`来用`?`替换未知字符：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Use `''backslashreplace''` to produce a Python Unicode character string, like
    `unicode-escape`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`'backslashreplace'`来生成一个Python Unicode字符字符串，比如`unicode-escape`：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You would use this if you needed a printable version of the Unicode escape sequence.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个Unicode转义序列的可打印版本，你可以使用这个方法。
- en: 'Use `''xmlcharrefreplace''` to make HTML-safe strings:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`'xmlcharrefreplace'`来生成HTML安全字符串：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I provide more details on HTML conversion in [“HTML Entities”](#html_entities).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[“HTML实体”](#html_entities)中提供了更多HTML转换的细节。
- en: Decode
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解码
- en: We *decode* byte strings to Unicode text strings. Whenever we get text from
    some external source (files, databases, websites, network APIs, and so on), it’s
    encoded as byte strings. The tricky part is knowing which encoding was actually
    used, so we can *run it backward* and get Unicode strings.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将字节字符串*解码*为Unicode文本字符串。每当我们从外部来源（文件、数据库、网站、网络API等）获取文本时，它都会被编码为字节字符串。棘手的部分是知道实际使用了哪种编码方式，这样我们才能*逆向操作*并获取Unicode字符串。
- en: The problem is that nothing in the byte string itself says what encoding was
    used. I mentioned the perils of copying and pasting from websites earlier. You’ve
    probably visited websites with odd characters where plain old ASCII characters
    should be.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于字节字符串本身没有说明使用了哪种编码。我之前提到过从网站复制粘贴的危险。你可能访问过一些奇怪字符的网站，本应是普通的ASCII字符。
- en: 'Let’s create a Unicode string called `place` with the value `''café''`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`place`的Unicode字符串，其值为`'café'`：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Encode it in UTF-8 format in a `bytes` variable called `place_bytes`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 用UTF-8格式编码，存入一个名为`place_bytes`的`bytes`变量：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice that `place_bytes` has five bytes. The first three are the same as ASCII
    (a strength of UTF-8), and the final two encode the `''é''`. Now let’s decode
    that byte string back to a Unicode string:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`place_bytes`有五个字节。前三个与ASCII相同（UTF-8的优势），最后两个编码了`'é'`。现在让我们将该字节字符串解码回Unicode字符串：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This worked because we encoded to UTF-8 and decoded from UTF-8. What if we told
    it to decode from some other encoding?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的原因是我们编码为UTF-8并解码为UTF-8。如果我们告诉它从其他编码解码会怎样呢？
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The ASCII decoder threw an exception because the byte value `0xc3` is illegal
    in ASCII. There are some 8-bit character set encodings in which values between
    128 (hex `80`) and 255 (hex `FF`) are legal but not the same as UTF-8:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII解码器因为字节值`0xc3`在ASCII中是非法的而抛出了异常。有些8位字符集编码允许128（十六进制`80`）到255（十六进制`FF`）之间的值合法，但与UTF-8不同。
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Urk.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 唔。
- en: 'The moral of this story: whenever possible, use UTF-8 encoding. It works, is
    supported everywhere, can express every Unicode character, and is quickly decoded
    and encoded.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的教训是：只要可能，请使用UTF-8编码。它适用，被到处支持，可以表示每个Unicode字符，并且快速解码和编码。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Even though you can specify any Unicode character, that doesn’t mean that your
    computer will display all of them. That depends on the *font* that you’re using,
    which may display nothing or some fill-in image for many characters. Apple created
    the [Last Resort Font](https://oreil.ly/q5EZD) for the Unicode Consortium, and
    uses it in its own operating systems. This [Wikipedia page](https://oreil.ly/Zm_uZ)
    has a few more details. Another font with everything between `\u0000` and `\uffff`,
    and a few more, is [Unifont](https://oreil.ly/APKlj).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以指定任何Unicode字符，这并不意味着您的计算机将显示所有这些字符。这取决于您使用的*字体*，该字体可能对许多字符显示空白或填充图像。苹果为Unicode联盟创建了[最后的应急字体](https://oreil.ly/q5EZD)，并在其自己的操作系统中使用它。这个[Wikipedia页面](https://oreil.ly/Zm_uZ)有更多细节。另一种包含从`\u0000`到`\uffff`以及更多字符的字体是[Unifont](https://oreil.ly/APKlj)。
- en: HTML Entities
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML实体
- en: 'Python 3.4 added another way to convert to and from Unicode but using HTML
    *character entities*.^([3](ch12.html#idm45794990473800)) This may be easier to
    use than looking up Unicode names, especially if you’re working on the web:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.4增加了另一种转换Unicode的方法，但是使用HTML *字符实体*。^([3](ch12.html#idm45794990473800))
    这可能比查找Unicode名称更容易，特别是在您在网络上工作时：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This conversion also works with numbered entities, decimal or hex:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换也适用于编号实体，十进制或十六进制：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can even import the named entity translations as a dictionary and do the
    conversion yourself. Drop the initial `''&''` for the dictionary key (you can
    also drop the final `'';''`, but it seems to work either way):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以将命名实体转换导入为字典并自行进行转换。删除字典键的初始`'&'`（您也可以删除最后的`;`，但似乎两种方式都可以工作）：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To go the other direction (from a single Python Unicode character to an HTML
    entity name), first get the decimal value of the character with `ord()`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要从单个Python Unicode字符向HTML实体名称的另一方向转换，请首先使用`ord()`获取字符的十进制值：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For Unicode strings with more than one character, use this two-step conversion:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于超过一个字符的Unicode字符串，请使用这两步转换：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The expression `place.encode('ascii', 'xmlcharrefreplace')` returned ASCII characters
    but as type `bytes` (because it *en*coded). The following `byte_value.decode()`
    is needed to convert `byte_value` to an HTML-compatible string.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`place.encode('ascii', 'xmlcharrefreplace')`返回ASCII字符，但是作为类型`bytes`（因为它是*编码的）。需要以下`byte_value.decode()`来将`byte_value`转换为HTML兼容字符串。
- en: Normalization
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准化
- en: 'Some Unicode characters can be represented by more than one Unicode encoding.
    They’ll look the same, but won’t compare the same because they have different
    internal byte sequences. For example, take the acute accented `''é''` in `''café''`.
    Let’s make a single-character `''é''` in multiple ways:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Unicode字符可以用多种Unicode编码表示。它们看起来一样，但由于具有不同的内部字节序列，它们不能进行比较。例如，在`'café'`中，急性重音`'é'`可以用多种方式制作单个字符`'é'`：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Try a few sanity checks:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试几个健全性检查：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now let’s make an accented `e` by combining a plain `e` with an acute accent:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过将一个普通的`e`与一个重音符号结合来制作一个带重音的`e`：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We built a Unicode character from two characters, and it looks the same as
    the original `''é''`. But as they say on Sesame Street, one of these things is
    not like the other:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用两个字符构建了一个Unicode字符，它看起来与原始的`'é'`相同。但正如他们在芝麻街上所说的那样，其中一个与其他不同：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you had two different Unicode text strings from different sources, one using
    `eacute1` and another `eacute_combined1`, they would appear the same, but would
    mysteriously not act the same.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有来自不同来源的两个不同的Unicode文本字符串，一个使用`eacute1`，另一个使用`eacute_combined1`，它们看起来相同，但是神秘地不起作用。
- en: 'You can fix this with the `normalize()` function in the `unicodedata` module:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`unicodedata`模块中的`normalize()`函数修复这个问题：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: That `'NFC'` means *normal form, composed*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`''NFC''`的意思是*组合的正常形式*。'
- en: For More Information
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'If you would like to learn more about Unicode, these links are particularly
    helpful:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于Unicode的信息，这些链接特别有帮助：
- en: '[Unicode HOWTO](http://bit.ly/unicode-howto)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Unicode HOWTO](http://bit.ly/unicode-howto)'
- en: '[Pragmatic Unicode](http://bit.ly/pragmatic-uni)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实用Unicode](http://bit.ly/pragmatic-uni)'
- en: '[The Absolute Minimum Every Software Developer Absolutely, Positively Must
    Know About Unicode and Character Sets (No Excuses!)](http://bit.ly/jspolsky)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[每个软件开发人员绝对必须了解的绝对最低限度关于Unicode和字符集的知识（无任何借口！）](http://bit.ly/jspolsky)'
- en: 'Text Strings: Regular Expressions'
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本字符串：正则表达式
- en: '[Chapter 5](ch05.html#ch_strings) discussed simple string operations. Armed
    with that introductory information, you’ve probably used simple “wildcard” patterns
    on the command line, such as the UNIX command `ls *.py`, which means *list all
    filenames ending in .py*.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[第五章](ch05.html#ch_strings)讨论了简单的字符串操作。掌握了这些基础知识后，你可能已经在命令行上使用了简单的“通配符”模式，比如
    UNIX 命令 `ls *.py`，意思是*列出所有以 .py 结尾的文件名*。'
- en: 'It’s time to explore more complex pattern matching by using *regular expressions*.
    These are provided in the standard module `re`, which we’ll import. You define
    a string *pattern* that you want to match, and the *source* string to match against.
    For simple matches, usage looks like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候通过使用*正则表达式*来探索更复杂的模式匹配了。这些功能在标准模块 `re` 中提供。你定义一个要匹配的字符串*模式*，以及要匹配的*源*字符串。对于简单的匹配，用法如下：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, `'You'` is the *pattern* we’re looking for, and `'Young Frankenstein'`
    is the *source* (the string we want to search). `match()` checks whether the *source*
    begins with the *pattern*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`'You'` 是我们要查找的*模式*，`'Young Frankenstein'` 是*源*（我们要搜索的字符串）。`match()` 检查*源*是否以*模式*开头。
- en: 'For more complex matches, you can *compile* your pattern first to speed up
    the match later:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的匹配，你可以先*编译*你的模式以加快后续的匹配速度：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, you can perform your match against the compiled pattern:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以对编译后的模式执行匹配：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Because this is a common Python gotcha, I’ll say it again here: `match()` only
    matches a pattern starting at the *beginning* of the source. `search()` matches
    a pattern *anywhere* in the source.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个常见的 Python 陷阱，我在这里再次强调：`match()` 只匹配从*源*的*开头*开始的模式。`search()` 则可以在*源*的*任何位置*匹配模式。
- en: '`match()` is not the only way to compare the pattern and source. Here are several
    other methods you can use (we discuss each in the following sections):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`match()` 不是比较模式和源的唯一方法。以下是你可以使用的几种其他方法（我们在下面的各节中讨论每一种方法）：'
- en: '`search()` returns the first match, if any.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search()` 如果有的话返回第一个匹配项。'
- en: '`findall()` returns a list of all non-overlapping matches, if any.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findall()` 返回所有非重叠匹配项的列表（如果有的话）。'
- en: '`split()` splits *source* at matches with *pattern* and returns a list of the
    string pieces.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`split()` 在*源*中匹配*模式*并返回字符串片段列表。'
- en: '`sub()` takes another *replacement* argument, and changes all parts of *source*
    that are matched by *pattern* to *replacement*.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub()` 还需要另一个*替换*参数，并将*源*中与*模式*匹配的所有部分更改为*替换*。'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Most of the regular expression examples here use ASCII, but Python’s string
    functions, including regular expressions, work with any Python string and any
    Unicode characters.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里大多数正则表达式示例都使用 ASCII，但 Python 的字符串函数，包括正则表达式，可以处理任何 Python 字符串和任何 Unicode 字符。
- en: Find Exact Beginning Match with match()
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `match()` 找到确切的起始匹配
- en: 'Does the string `''Young Frankenstein''` begin with the word `''You''`? Here’s
    some code with comments:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 `'Young Frankenstein'` 是否以 `'You'` 开头？以下是带有注释的代码：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How about `'Frank'`?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`''Frank''` 怎么样？'
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This time, `match()` returned nothing, so the `if` did not run the `print` statement.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`match()` 没有返回任何内容，因此 `if` 语句没有运行 `print` 语句。
- en: 'As I mentioned in [“New: I Am the Walrus”](ch04.html#walrus), in Python 3.8
    you can shorten this example with the so-called *walrus operator*:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在 [“新功能：我是海象”](ch04.html#walrus) 中提到的，在 Python 3.8 中，你可以使用所谓的*海象操作符*简化这个例子：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Okay, now let’s use `search()` to see whether `''Frank''` is anywhere in the
    source string:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 `search()` 来查看 `'Frank'` 是否出现在源字符串中：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s change the pattern and try a beginning match with `match()` again:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变模式，再次尝试使用 `match()` 进行起始匹配：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here’s a brief explanation of how our new `''.*Frank''` pattern works:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里简要解释了我们新的 `'.*Frank'` 模式的工作原理：
- en: '`.` means *any single character*.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.` 表示*任何单个字符*。'
- en: '`*` means *zero or more of the preceding thing*. Together, `.*` mean *any number
    of characters* (even zero).'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 表示*前一个内容的零个或多个*。`.*` 在一起表示*任意数量的字符*（甚至是零个）。'
- en: '`Frank` is the phrase that we wanted to match, somewhere.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Frank` 是我们想要匹配的短语，某个地方。'
- en: '`match()` returned the string that matched `.*Frank`: `''Young Frank''`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`match()` 返回与 `.*Frank` 匹配的字符串：`''Young Frank''`。'
- en: Find First Match with search()
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `search()` 找到第一个匹配项
- en: 'You can use `search()` to find the pattern `''Frank''` anywhere in the source
    string `''Young Frankenstein''`, without the need for the `.*` wildcards:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `search()` 在字符串 `'Young Frankenstein'` 中找到模式 `'Frank'` 的任何位置，而不需要使用 `.*`
    通配符：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Find All Matches with findall()
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `findall()` 查找所有匹配项
- en: The preceding examples looked for one match only. But what if you want to know
    how many instances of the single-letter string `'n'` are in the string?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子只查找了一个匹配。但是如果你想知道字符串中单字母 `'n'` 的实例数量呢？
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How about `'n'` followed by any character?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 后面跟着任何字符的 `'n'` 是怎样的？
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Notice that it did not match that final `''n''`. We need to say that the character
    after `''n''` is optional, with `?`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它没有匹配最后的 `'n'`。我们需要说 `'n'` 后面的字符是可选的，用 `?`：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Split at Matches with split()
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `split()` 在匹配处分割
- en: 'The next example shows you how to split a string into a list by a pattern rather
    than a simple string (as the normal string `split()` method would do):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了如何通过模式而不是简单字符串（正常字符串 `split()` 方法会执行的方式）将字符串分割成列表：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Replace at Matches with sub()
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `sub()` 替换匹配项
- en: 'This is like the string `replace()` method, but for patterns rather than literal
    strings:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于字符串 `replace()` 方法，但用于模式而不是字面字符串：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Patterns: Special Characters'
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式：特殊字符
- en: Many descriptions of regular expressions start with all the details of how to
    define them. I think that’s a mistake. Regular expressions are a not-so-little
    language in their own right, with too many details to fit in your head at once.
    They use so much punctuation that they look like cartoon characters swearing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 许多正则表达式的描述从如何定义它们的所有细节开始。我认为这是一个错误。正则表达式是一个不那么小的语言，有太多细节无法一次掌握。它们使用了很多标点符号，看起来像卡通人物在咒骂。
- en: With these expressions (`match()`, `search()`, `findall()`, and `sub()`) under
    your belt, let’s get into the details of building them. The patterns you make
    apply to any of these functions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这些表达式 (`match()`、`search()`、`findall()` 和 `sub()`）之后，让我们深入了解如何构建它们的细节。你制作的模式适用于这些函数中的任何一个。
- en: 'You’ve seen the basics:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了基础知识：
- en: Literal matches with any nonspecial characters
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配所有非特殊字符的文字
- en: Any single character except `\n` with `.`
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除 `\n` 外的任何单个字符用 `.`
- en: Any number of the preceding character (including zero) with `*`
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意数量的前一个字符（包括零）用 `*`
- en: Optional (zero or one) of the preceding character with `?`
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一个字符的可选（零次或一次）用 `?`
- en: First, special characters are shown in [Table 12-2](#specialchartable).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，特殊字符显示在 [表 12-2](#specialchartable) 中。
- en: Table 12-2\. Special characters
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-2\. 特殊字符
- en: '| Pattern | Matches |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 匹配项 |'
- en: '| --- | --- |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\d` | A single digit |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 单个数字 |'
- en: '| `\D` | A single nondigit |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | 单个非数字字符 |'
- en: '| `\w` | An alphanumeric character |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 字母数字字符 |'
- en: '| `\W` | A non-alphanumeric character |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | 非字母数字字符 |'
- en: '| `\s` | A whitespace character |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 空白字符 |'
- en: '| `\S` | A nonwhitespace character |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | 非空白字符 |'
- en: '| `\b` | A word boundary (between a `\w` and a `\W`, in either order) |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 单词边界（在 `\w` 和 `\W` 之间，顺序不限） |'
- en: '| `\B` | A nonword boundary |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `\B` | 非单词边界 |'
- en: 'The Python `string` module has predefined string constants that we can use
    for testing. Let’s use `printable`, which contains 100 printable ASCII characters,
    including letters in both cases, digits, space characters, and punctuation:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `string` 模块有预定义的字符串常量，我们可以用它们进行测试。让我们使用 `printable`，其中包含 100 个可打印的
    ASCII 字符，包括大小写字母、数字、空格字符和标点符号：
- en: '[PRE52]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Which characters in `printable` are digits?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`printable` 中哪些字符是数字？'
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Which characters are digits, letters, or an underscore?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些字符是数字、字母或下划线？
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Which are spaces?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些是空格？
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In order, those were: plain old space, tab, newline, carriage return, vertical
    tab, and form feed.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序，这些是：普通空格、制表符、换行符、回车符、垂直制表符和换页符。
- en: 'Regular expressions are not confined to ASCII. A `\d` will match whatever Unicode
    calls a digit, not just ASCII characters `''0''` through `''9''`. Let’s add two
    non-ASCII lowercase letters from [FileFormat.info](http://bit.ly/unicode-letter):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式不仅限于 ASCII。`\d` 将匹配任何 Unicode 所谓的数字，而不仅仅是 ASCII 字符 `'0'` 到 `'9'`。让我们从 [FileFormat.info](http://bit.ly/unicode-letter)
    添加两个非 ASCII 小写字母：
- en: 'In this test, we’ll throw in the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们将加入以下内容：
- en: Three ASCII letters
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个 ASCII 字母
- en: Three punctuation symbols that should *not* match a `\w`
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个标点符号不应该与 `\w` 匹配
- en: A Unicode *LATIN SMALL LETTER E WITH CIRCUMFLEX* (\u00ea)
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode *带抑音的拉丁小写字母 E* (\u00ea)
- en: A Unicode *LATIN SMALL LETTER E WITH BREVE* (\u0115)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode *带抑音的拉丁小写字母 E* (\u0115)
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As expected, this pattern found only the letters:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，这个模式仅找到了字母：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Patterns: Using Specifiers'
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式：使用限定符
- en: Now let’s make “punctuation pizza,” using the main pattern specifiers for regular
    expressions, which are presented in [Table 12-3](#table_12-4).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们制作“标点披萨”，使用正则表达式的主要模式限定符，这些限定符在 [表 12-3](#table_12-4) 中介绍。
- en: In the table, *expr* and the other italicized words mean any valid regular expression.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在表中，*expr*和其他斜体字表示任何有效的正则表达式。
- en: Table 12-3\. Pattern specifiers
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 表12-3。模式说明符
- en: '| Pattern | Matches |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 匹配 |'
- en: '| --- | --- |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `abc` | Literal `abc` |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `abc` | 字面`abc` |'
- en: '| `(` *expr* `)` | *expr* |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `(` *expr* `)` | *expr* |'
- en: '| *expr1* `&#124;` *expr2* | *expr1* or *expr2* |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| *expr1* `&#124;` *expr2* | *expr1* 或 *expr2* |'
- en: '| `.` | Any character except `\n` |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 除`\n`外的任意字符 |'
- en: '| `^` | Start of source string |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 源字符串的开头 |'
- en: '| `$` | End of source string |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 源字符串的结尾 |'
- en: '| *prev* `?` | Zero or one *prev* |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| *prev* `?` | 零或一个*prev* |'
- en: '| *prev* `*` | Zero or more *prev*, as many as possible |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| *prev* `*` | 零或多个*prev*，尽可能多地匹配 |'
- en: '| *prev* `*?` | Zero or more *prev*, as few as possible |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| *prev* `*?` | 零或多个*prev*，尽可能少地匹配 |'
- en: '| *prev* `+` | One or more *prev*, as many as possible |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| *prev* `+` | 一个或多个*prev*，尽可能多地匹配 |'
- en: '| *prev* `+?` | One or more *prev*, as few as possible |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| *prev* `+?` | 一个或多个*prev*，尽可能少地匹配 |'
- en: '| *prev* `{` *m* `}` | *m* consecutive *prev* |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| *prev* `{` *m* `}` | *m*个连续的*prev* |'
- en: '| *prev* `{` *m*, *n* `}` | *m* to *n* consecutive *prev*, as many as possible
    |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| *prev* `{` *m*, *n* `}` | *m*到*n*个连续的*prev*，尽可能多地匹配 |'
- en: '| *prev* `{` *m*, *n* `}?` | *m* to *n* consecutive *prev*, as few as possible
    |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| *prev* `{` *m*, *n* `}?` | *m*到*n*个连续的*prev*，尽可能少地匹配 |'
- en: '| `[` *abc* `]` | `a` or `b` or `c` (same as `a&#124;b&#124;c`) |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `[` *abc* `]` | `a`或`b`或`c`（等同于`a&#124;b&#124;c`） |'
- en: '| `[^` *abc* `]` | *not* (`a` or `b` or `c`) |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `[^` *abc* `]` | *非*（`a`或`b`或`c`） |'
- en: '| *prev* `(?=` *next* `)` | *prev* if followed by *next* |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| *prev* `(?=` *next* `)` | 若紧随其后则*prev* |'
- en: '| *prev* `(?!` *next* `)` | *prev* if *not* followed by *next* |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| *prev* `(?!` *next* `)` | 若不紧随其后则*prev* |'
- en: '| `(?<=` *prev* `)` *next* | *next* if preceded by *prev* |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `(?<=` *prev* `)` *next* | 若之前有*prev*则*next* |'
- en: '| `(?<!` *prev* `)` *next* | *next* if *not* preceded by *prev* |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `(?<!` *prev* `)` *next* | 若不紧随其前则*next* |'
- en: 'Your eyes might cross permanently when trying to read these examples. First,
    let’s define our source string:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当试图阅读这些示例时，你的眼睛可能永久地交叉了。首先，让我们定义我们的源字符串：
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now we apply different regular expression pattern strings to try to match something
    in the `source` string.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应用不同的正则表达式模式字符串来尝试在`source`字符串中匹配某些内容。
- en: Note
  id: totrans-276
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the following examples, I use plain quoted strings for the patterns. A little
    later in this section I show how a raw pattern string (`r` before the initial
    quote) helps avoid some conflicts between Python’s normal string escapes and regular
    expression ones. So, to be safest, the first argument in all the following examples
    should actually be a raw string.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我使用普通的引号字符串表示模式。在本节稍后，我将展示如何使用原始模式字符串（在初始引号前加上`r`）来避免Python正常字符串转义与正则表达式转义之间的冲突。因此，为了更安全，所有以下示例中的第一个参数实际上应该是原始字符串。
- en: 'First, find `wish` anywhere:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在任意位置找到`wish`：
- en: '[PRE59]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, find `wish` or `fish` anywhere:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在任意位置找到`wish`或`fish`：
- en: '[PRE60]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Find `wish` at the beginning:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 查找开头的`wish`：
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Find `I wish` at the beginning:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 查找开头的`I wish`：
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Find `fish` at the end:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 查找结尾的`fish`：
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, find `fish tonight.` at the end:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在结尾找到`fish tonight.`：
- en: '[PRE64]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The characters `^` and `$` are called *anchors*: `^` anchors the search to
    the beginning of the search string, and `$` anchors it to the end. `.$` matches
    any character at the end of the line, including a period, so that worked. To be
    more precise, we should escape the dot to match it literally:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 字符`^`和`$`称为*锚点*：`^`锚定搜索到搜索字符串的开始，而`$`锚定到结尾。`. $`匹配行尾的任意字符，包括句号，所以它起作用了。为了更精确，我们应该转义句点以确实匹配它：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Begin by finding `w` or `f` followed by `ish`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从找到`w`或`f`后面跟着`ish`开始：
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Find one or more runs of `w`, `s`, or `h`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 查找一个或多个`w`、`s`或`h`的连续序列：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Find `ght` followed by a non-alphanumeric:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 找到以非字母数字字符跟随的`ght`：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Find `I` followed by `wish`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 找到以`I`开头的`wish`：
- en: '[PRE69]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And last, `wish` preceded by `I`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`wish`之前有`I`：
- en: '[PRE70]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'I mentioned earlier that there are a few cases in which the regular expression
    pattern rules conflict with the Python string rules. The following pattern should
    match any word that begins with `fish`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，有几种情况下正则表达式模式规则与Python字符串规则相冲突。以下模式应匹配以`fish`开头的任何单词：
- en: '[PRE71]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Why doesn’t it? As is discussed in [Chapter 5](ch05.html#ch_strings), Python
    employs a few special *escape characters* for strings. For example, `\b` means
    backspace in strings, but in the mini-language of regular expressions it means
    the beginning of a word. Avoid the accidental use of escape characters by using
    Python’s *raw strings* when you define your regular expression string. Always
    put an `r` character before your regular expression pattern string, and Python
    escape characters will be disabled, as demonstrated here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不这样做呢？如[第5章](ch05.html#ch_strings)中所述，Python 为字符串使用了一些特殊的转义字符。例如，`\b` 在字符串中表示退格，但在正则表达式的迷你语言中表示单词的开头。通过在定义正则表达式字符串时始终在其前加上
    `r` 字符，可以避免意外使用转义字符，这样将禁用 Python 转义字符，如下所示：
- en: '[PRE72]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Patterns: Specifying match() Output'
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式：指定 `match()` 输出
- en: 'When using `match()` or `search()`, all matches are returned from the result
    object `m` as `m.group()`. If you enclose a pattern in parentheses, the match
    will be saved to its own group, and a tuple of them will be available as `m.groups()`,
    as shown here:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `match()` 或 `search()` 时，所有匹配项都作为结果对象 `m` 的 `m.group()` 返回。如果将模式括在括号中，则匹配将保存到自己的组中，并作为
    `m.groups()` 的元组可用，如下所示：
- en: '[PRE73]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If you use this pattern `(?P<` *`name`* `>` *`expr`* `)`, it will match *`expr`*,
    saving the match in group *`name`*:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用此模式 `(?P<` *`name`* `>` *`expr`* `)`，它将匹配 *`expr`*，并将匹配保存在组 *`name`* 中：
- en: '[PRE74]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Binary Data
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制数据
- en: Text data can be challenging, but binary data can be, well, interesting. You
    need to know about concepts such as *endianness* (how your computer’s processor
    breaks data into bytes) and *sign bits* for integers. You might need to delve
    into binary file formats or network packets to extract or even change data. This
    section shows you the basics of binary data wrangling in Python.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 文本数据可能会有挑战，但二进制数据可能会更加有趣。您需要了解诸如字节顺序（计算机处理器如何将数据分解为字节）和整数的符号位等概念。您可能需要深入了解二进制文件格式或网络数据包，以提取甚至更改数据。本节向您展示了在
    Python 中进行二进制数据处理的基础知识。
- en: bytes and bytearray
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: bytes 和 bytearray
- en: 'Python 3 introduced the following sequences of eight-bit integers, with possible
    values from 0 to 255, in two types:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3 引入了以下八位整数序列，可能值为 0 到 255，有两种类型：
- en: '*bytes* is immutable, like a tuple of bytes'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*bytes* 不可变，类似于字节元组'
- en: '*bytearray* is mutable, like a list of bytes'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*bytearray* 可变，类似于字节列表'
- en: 'Beginning with a list called `blist`, this next example creates a `bytes` variable
    called `the_bytes` and a `bytearray` variable called `the_byte_array`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以名为 `blist` 的列表开始，下一个示例创建了名为 `the_bytes` 的 `bytes` 变量和名为 `the_byte_array` 的
    `bytearray` 变量：
- en: '[PRE75]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-319
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The representation of a `bytes` value begins with a `b` and a quote character,
    followed by hex sequences such as `\x02` or ASCII characters, and ends with a
    matching quote character. Python converts the hex sequences or ASCII characters
    to little integers, but shows byte values that are also valid ASCII encodings
    as ASCII characters:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes` 值的表示以 `b` 和引号字符开头，后跟诸如 `\x02` 或 ASCII 字符的十六进制序列，并以匹配的引号字符结束。Python
    将十六进制序列或 ASCII 字符转换为小整数，但显示也有效的 ASCII 编码的字节值作为 ASCII 字符：'
- en: '[PRE76]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This next example demonstrates that you can’t change a `bytes` variable:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例演示了您不能更改 `bytes` 变量：
- en: '[PRE78]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'But a `bytearray` variable is mellow and mutable:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `bytearray` 变量温和且可变：
- en: '[PRE79]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Each of these would create a 256-element result, with values from 0 to 255:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作会生成一个包含 0 到 255 的 256 元素结果：
- en: '[PRE80]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'When printing `bytes` or `bytearray` data, Python uses `\x`*`xx`* for nonprintable
    bytes and their ASCII equivalents for printable ones (plus some common escape
    characters, such as `\n` instead of `\x0a`). Here’s the printed representation
    of `the_bytes` (manually reformatted to show 16 bytes per line):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印 `bytes` 或 `bytearray` 数据时，Python 使用 `\x`*`xx`* 表示不可打印字节及其 ASCII 等效字符，对于可打印字符则显示其
    ASCII 值（以及一些常见的转义字符，例如 `\n` 而非 `\x0a`）。以下是手动重新格式化以显示每行 16 个字节的 `the_bytes` 的打印表示：
- en: '[PRE81]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This can be confusing, because they’re bytes (teeny integers), not characters.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会令人困惑，因为它们是字节（小整数），而不是字符。
- en: Convert Binary Data with struct
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 struct 转换二进制数据
- en: As you’ve seen, Python has many tools for manipulating text. Tools for binary
    data are much less prevalent. The standard library contains the `struct` module,
    which handles data similar to *structs* in C and C++. Using `struct`, you can
    convert binary data to and from Python data structures.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，Python 有许多用于操作文本的工具。用于二进制数据的工具则较少。标准库包含了处理类似于 C 和 C++ 中结构体的数据的 `struct`
    模块。使用 `struct`，您可以将二进制数据转换为 Python 数据结构，反之亦然。
- en: Let’s see how this works with data from a PNG file—a common image format that
    you’ll see along with GIF and JPEG files. We’ll write a small program that extracts
    the width and height of an image from some PNG data.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看看如何处理来自 PNG 文件的数据——一种常见的图像格式，通常与 GIF 和 JPEG 文件一起出现。我们将编写一个小程序，从一些 PNG 数据中提取图像的宽度和高度。
- en: We’ll use the O’Reilly logo—the little bug-eyed tarsier shown in [Figure 12-1](#fig_12-1).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用奥莱利的商标——在 [图 12-1](#fig_12-1) 中展示的小眼睛猫熊。
- en: '![inp2 1201](assets/inp2_1201.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![inp2 1201](assets/inp2_1201.png)'
- en: Figure 12-1\. The O’Reilly tarsier
  id: totrans-337
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-1\. 奥莱利猫熊
- en: The PNG file for this image is available on [Wikipedia](http://bit.ly/orm-logo).
    I don’t show how to read files until [Chapter 14](ch14.html#ch_files), so I downloaded
    this file, wrote a little program to print its values as bytes, and just typed
    the values of the first 30 bytes into a Python `bytes` variable called `data`
    for the example that follows. (The PNG format specification says that the width
    and height are stored within the first 24 bytes, so we don’t need more than that
    for now.)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 此图像的 PNG 文件可在 [维基百科](http://bit.ly/orm-logo) 上找到。在 [第 14 章](ch14.html#ch_files)
    我才会介绍如何读取文件，因此我下载了这个文件，编写了一个小程序将其值作为字节打印出来，并只在一个名为 `data` 的 Python `bytes` 变量中键入了前
    30 个字节的值，用于接下来的示例中。（PNG 格式规范指出宽度和高度存储在前 24 字节中，因此我们现在不需要更多。）
- en: '[PRE82]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here’s what this code does:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此代码的功能：
- en: '`data` contains the first 30 bytes from the PNG file. To fit on the page, I
    joined two byte strings with `+` and the continuation character (`\`).'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data` 包含来自 PNG 文件的前 30 个字节。为了适应页面，我用 `+` 和续行符（`\`）连接了两个字节字符串。'
- en: '`valid_png_header` contains the eight-byte sequence that marks the start of
    a valid PNG file.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valid_png_header` 包含标记有效 PNG 文件起始的八字节序列。'
- en: '`width` is extracted from bytes 16–19, and `height` from bytes 20–23.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width` 从第 16 至 19 字节提取，`height` 从第 20 至 23 字节提取。'
- en: 'The `>LL` is the format string that instructs `unpack()` how to interpret its
    input byte sequences and assemble them into Python data types. Here’s the breakdown:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`>LL` 是格式字符串，指示 `unpack()` 如何解释其输入字节序列并将其组装成 Python 数据类型。以下是详细说明：'
- en: The `>` means that integers are stored in *big-endian* format.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` 表示整数以 *大端* 格式存储。'
- en: Each `L` specifies a four-byte unsigned long integer.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 `L` 指定一个四字节无符号长整数。
- en: 'You can examine each four-byte value directly:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接检查每个四字节值：
- en: '[PRE83]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Big-endian integers have the most significant bytes to the left. Because the
    width and height are each less than 255, they fit into the last byte of each sequence.
    You can verify that these hex values match the expected decimal values:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 大端整数将最重要的字节放在左边。因为宽度和高度都小于 255，它们适合每个序列的最后一个字节。你可以验证这些十六进制值是否与预期的十进制值匹配：
- en: '[PRE84]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'When you want to go in the other direction and convert Python data to bytes,
    use the `struct` `pack()` function:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想反向操作并将 Python 数据转换为字节时，请使用 `struct` `pack()` 函数：
- en: '[PRE85]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Tables [12-4](#struct_endian_table) and [12-5](#struct_specifier_table) show
    the format specifiers for `pack()` and `unpack()`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 表 [12-4](#struct_endian_table) 和 [12-5](#struct_specifier_table) 显示了 `pack()`
    和 `unpack()` 的格式说明符。
- en: The endian specifiers go first in the format string.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 字节顺序说明符在格式字符串中优先。
- en: Table 12-4\. Endian specifiers
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-4\. 字节顺序说明符
- en: '| Specifier | Byte order |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 格式说明符 | 字节顺序 |'
- en: '| --- | --- |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<` | Little endian |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 小端 |'
- en: '| `>` | Big endian |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 大端 |'
- en: Table 12-5\. Format specifiers
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-5\. 格式说明符
- en: '| Specifier | Description | Bytes |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| 格式说明符 | 描述 | 字节 |'
- en: '| --- | --- | --- |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `x` | Skip a byte | 1 |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 跳过一个字节 | 1 |'
- en: '| `b` | Signed byte | 1 |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 有符号字节 | 1 |'
- en: '| `B` | Unsigned byte | 1 |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| `B` | 无符号字节 | 1 |'
- en: '| `h` | Signed short integer | 2 |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `h` | 有符号短整数 | 2 |'
- en: '| `H` | Unsigned short integer | 2 |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `H` | 无符号短整数 | 2 |'
- en: '| `i` | Signed integer | 4 |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `i` | 有符号整数 | 4 |'
- en: '| `I` | Unsigned integer | 4 |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `I` | 无符号整数 | 4 |'
- en: '| `l` | Signed long integer | 4 |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `l` | 有符号长整数 | 4 |'
- en: '| `L` | Unsigned long integer | 4 |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `L` | 无符号长整数 | 4 |'
- en: '| `Q` | Unsigned long long integer | 8 |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `Q` | 无符号长长整数 | 8 |'
- en: '| `f` | Single-precision float | 4 |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `f` | 单精度浮点数 | 4 |'
- en: '| `d` | Double-precision float | 8 |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 双精度浮点数 | 8 |'
- en: '| `p` | *count* and characters | 1 + *count* |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `p` | *count* 和字符 | 1 + *count* |'
- en: '| `s` | Characters | *count* |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 字符 | *count* |'
- en: The type specifiers follow the endian character. Any specifier may be preceded
    by a number that indicates the *`count`*; `5B` is the same as `BBBBB`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 类型说明符跟在字节顺序字符之后。任何说明符前都可以加一个数字，表示 *`count`*；`5B` 等同于 `BBBBB`。
- en: 'You can use a *`count`* prefix instead of `>LL`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 *`count`* 前缀代替 `>LL`：
- en: '[PRE86]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We used the slice `data[16:24]` to grab the interesting bytes directly. We
    could also use the `x` specifier to skip the uninteresting parts:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用切片 `data[16:24]` 直接抓取感兴趣的字节。我们也可以使用 `x` 标识符来跳过不感兴趣的部分：
- en: '[PRE87]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This means:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：
- en: Use big-endian integer format (`>`)
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用大端整数格式 (`>`)
- en: Skip 16 bytes (`16x`)
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳过 16 个字节 (`16x`)
- en: Read eight bytes—two unsigned long integers (`2L`)
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取八个字节——两个无符号长整数 (`2L`)
- en: Skip the final six bytes (`6x`)
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳过最后六个字节 (`6x`)
- en: Other Binary Data Tools
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他二进制数据工具
- en: 'Some third-party open source packages offer the following, more-declarative
    ways of defining and extracting binary data:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 一些第三方开源软件包提供了以下更具声明性的方法来定义和提取二进制数据：
- en: '[bitstring](http://bit.ly/py-bitstring)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[bitstring](http://bit.ly/py-bitstring)'
- en: '[construct](http://bit.ly/py-construct)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[construct](http://bit.ly/py-construct)'
- en: '[hachoir](https://pypi.org/project/hachoir)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[hachoir](https://pypi.org/project/hachoir)'
- en: '[binio](http://spika.net/py/binio)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[binio](http://spika.net/py/binio)'
- en: '[kaitai struct](http://kaitai.io)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[kaitai struct](http://kaitai.io)'
- en: '[Appendix B](app02.html#app_install) has details on how to download and install
    external packages such as these. For the next example, you need to install `construct`.
    Here’s all you need to do:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[附录 B](app02.html#app_install) 中详细介绍了如何下载和安装外部包，例如这些。在下一个示例中，您需要安装 `construct`。这是您需要做的全部工作：'
- en: '[PRE88]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Here’s how to extract the PNG dimensions from our `data` bytestring by using
    `construct`:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何通过使用 `construct` 从我们的 `data` 字节串中提取 PNG 尺寸的方法：
- en: '[PRE89]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Convert Bytes/Strings with binascii()
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `binascii()` 转换字节/字符串
- en: 'The standard `binascii` module has functions to convert between binary data
    and various string representations: hex (base 16), base 64, uuencoded, and others.
    For example, in the next snippet, let’s print that eight-byte PNG header as a
    sequence of hex values, instead of the mixture of ASCII and `\x` *xx* escapes
    that Python uses to display *bytes* variables:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 `binascii` 模块具有将二进制数据与各种字符串表示形式（十六进制（基数 16）、Base64、uuencoded 等）之间转换的函数。例如，在下一段代码中，让我们将那八字节的
    PNG 头部打印为一系列十六进制值，而不是 Python 用来显示 *bytes* 变量的混合 ASCII 和 `\x` *xx* 转义的方式：
- en: '[PRE90]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Hey, this thing works backward, too:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，这个东西也可以反向操作：
- en: '[PRE91]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Bit Operators
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位运算符
- en: Python provides bit-level integer operators, similar to those in the C language.
    [Table 12-6](#bit_operator_table) summarizes them and includes examples with the
    integer variables `x` (decimal `5`, binary `0b0101`) and `y` (decimal `1`, binary
    `0b0001`).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了类似 C 语言的位级整数操作符。[表 12-6](#bit_operator_table) 总结了这些操作符，并包括对整数变量 `x`（十进制
    `5`，二进制 `0b0101`）和 `y`（十进制 `1`，二进制 `0b0001`）的示例。
- en: Table 12-6\. Bit-level integer operators
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-6\. 位级整数运算符
- en: '| Operator | Description | Example | Decimal result | Binary result |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 描述 | 示例 | 十进制结果 | 二进制结果 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `&` | And | `x & y` | `1` | `0b0001` |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 与 | `x & y` | `1` | `0b0001` |'
- en: '| `&#124;` | Or | `x &#124; y` | `5` | `0b0101` |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 或 | `x &#124; y` | `5` | `0b0101` |'
- en: '| `^` | Exclusive or | `x ^ y` | `4` | `0b0100` |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 异或 | `x ^ y` | `4` | `0b0100` |'
- en: '| `~` | Flip bits | `~x` | `-6` | *binary representation depends on int size*
    |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 反转位 | `~x` | `-6` | *二进制表示取决于整数大小* |'
- en: '| `<<` | Left shift | `x << 1` | `10` | `0b1010` |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| `<<` | 左移 | `x << 1` | `10` | `0b1010` |'
- en: '| `>>` | Right shift | `x >> 1` | `2` | `0b0010` |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | 右移 | `x >> 1` | `2` | `0b0010` |'
- en: These operators work something like the set operators in [Chapter 8](ch08.html#ch_dicts).
    The `&` operator returns bits that are the same in both arguments, and `|` returns
    bits that are set in either of them. The `^` operator returns bits that are in
    one or the other, but not both. The `~` operator reverses all the bits in its
    single argument; this also reverses the sign because an integer’s highest bit
    indicates its sign (`1` = negative) in *two’s complement* arithmetic, used in
    all modern computers. The `<<` and `>>` operators just move bits to the left or
    right. A left shift of one bit is the same as multiplying by two, and a right
    shift is the same as dividing by two.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符的工作方式类似于 [第 8 章](ch08.html#ch_dicts) 中的集合操作符。`&` 操作符返回两个参数中相同的位，`|` 返回两个参数中设置的位。`^`
    操作符返回一个参数中的位，而不是两者都有的位。`~` 操作符反转其单个参数中的所有位；这也反转了符号，因为整数的最高位在 *二进制补码* 算术中表示其符号（`1`
    = 负数），这种算法在所有现代计算机中使用。`<<` 和 `>>` 操作符只是将位向左或向右移动。向左移动一位与乘以二相同，向右移动相当于除以二。
- en: A Jewelry Analogy
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个珠宝类比
- en: Unicode strings are like charm bracelets, and bytes are like strands of beads.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 字符串就像魅力手链，而字节则像串珠。
- en: Coming Up
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将到来
- en: 'Next is another practical chapter: how to handle dates and times.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是另一个实用章节：如何处理日期和时间。
- en: Things to Do
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项
- en: 12.1 Create a Unicode string called `mystery` and assign it the value `'\U0001f984'`.
    Print `mystery` and its Unicode name.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 12.1 创建一个名为`mystery`的Unicode字符串，并将其赋值为`'\U0001f984'`。打印`mystery`及其Unicode名称。
- en: 12.2 Encode `mystery`, this time using UTF-8, into the `bytes` variable `pop_bytes`.
    Print `pop_bytes`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 12.2 使用UTF-8对`mystery`进行编码，并将结果存入名为`pop_bytes`的`bytes`变量中。打印`pop_bytes`。
- en: 12.3 Using UTF-8, decode `pop_bytes` into the string variable `pop_string`.
    Print `pop_string`. Is `pop_string` equal to `mystery`?
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 12.3 使用UTF-8将`pop_bytes`解码为字符串变量`pop_string`。打印`pop_string`。`pop_string`等于`mystery`吗？
- en: 12.4 When you’re working with text, regular expressions come in very handy.
    We’ll apply them in a number of ways to our featured text sample. It’s a poem
    titled “Ode on the Mammoth Cheese,” written by James McIntyre in 1866 in homage
    to a seven-thousand-pound cheese that was crafted in Ontario and sent on an international
    tour. If you’d rather not type all of it, use your favorite search engine and
    cut and paste the words into your Python program, or just grab it from [Project
    Gutenberg](http://bit.ly/mcintyre-poetry). Call the text string `mammoth`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 12.4 当您处理文本时，正则表达式非常方便。我们将以多种方式应用它们到我们特色的文本样本中。这是一首名为“Ode on the Mammoth Cheese”的诗，由詹姆斯·麦金泰尔于1866年写作，致敬于一个重七千磅的奶酪，在安大略省制作并发送国际巡回展。如果您不想全部输入，请使用您喜爱的搜索引擎并将单词剪切并粘贴到Python程序中，或者直接从[Project
    Gutenberg](http://bit.ly/mcintyre-poetry)获取。将文本字符串命名为`mammoth`。
- en: Example 12-1\. mammoth.txt
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子12-1\. mammoth.txt
- en: '[PRE92]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 12.5 Import the `re` module to use Python’s regular expression functions. Use
    the `re.findall()` to print all the words that begin with `c`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 12.5 导入`re`模块以使用Python的正则表达式函数。使用`re.findall()`打印所有以`c`开头的单词。
- en: 12.6 Find all four-letter words that begin with `c`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 12.6 找出所有以`c`开头的四字单词。
- en: 12.7 Find all the words that end with `r`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 12.7 找出所有以`r`结尾的单词。
- en: 12.8 Find all words that contain exactly three vowels in a row.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 12.8 找出所有包含恰好三个连续元音字母的单词。
- en: '12.9 Use `unhexlify` to convert this hex string (combined from two strings
    to fit on a page) to a `bytes` variable called `gif`:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 12.9 使用`unhexlify`将这个十六进制字符串（从两个字符串组合成一个以适应页面）转换为名为`gif`的`bytes`变量：
- en: '[PRE93]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 12.10 The bytes in `gif` define a one-pixel transparent GIF file, one of the
    most common graphics file formats. A legal GIF starts with the ASCII characters
    *GIF89a*. Does `gif` match this?
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 12.10 `gif`中的字节定义了一个像素的透明GIF文件，这是最常见的图形文件格式之一。合法的GIF以ASCII字符*GIF89a*开头。`gif`是否符合这个规范？
- en: 12.11 The pixel width of a GIF is a 16-bit little-endian integer beginning at
    byte offset 6, and the height is the same size, starting at offset 8. Extract
    and print these values for `gif`. Are they both `1`?
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 12.11 GIF的像素宽度是从字节偏移量6开始的16位小端整数，高度也是相同大小，从偏移量8开始。提取并打印这些值以供`gif`使用。它们都是`1`吗？
- en: ^([1](ch12.html#idm45794991539400-marker)) This wine has an umlaut in Germany,
    but loses it in Alsace on the way to France.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch12.html#idm45794991539400-marker)) 这种酒在德国有一个分音符号，但在去法国的途中在阿尔萨斯地区失去了它。
- en: ^([2](ch12.html#idm45794991521032-marker)) Base 16, specified with characters
    `0`-`9` and `A`-`F`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch12.html#idm45794991521032-marker)) 基数16，由字符`0`-`9`和`A`-`F`指定。
- en: ^([3](ch12.html#idm45794990473800-marker)) See the HTML5 named-character reference
    [chart](https://oreil.ly/pmBWO).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch12.html#idm45794990473800-marker)) 参见HTML5命名字符引用[图表](https://oreil.ly/pmBWO)。
