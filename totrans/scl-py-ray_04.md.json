["```py\n@ray.remote\ndef remote_task(x):\n    time.sleep(x)\n    return x\n```", "```py\n# Process in order\ndef in_order():\n    # Make the futures\n    futures = list(map(lambda x: remote_task.remote(x), things))\n    values = ray.get(futures)\n    for v in values:\n        print(f\" Completed {v}\")\n        time.sleep(1) # Business logic goes here\n```", "```py\n# Process as results become available\ndef as_available():\n    # Make the futures\n    futures = list(map(lambda x: remote_task.remote(x), things))\n    # While we still have pending futures\n    while len(futures) > 0:\n        ready_futures, rest_futures = ray.wait(futures)\n        print(f\"Ready {len(ready_futures)} rest {len(rest_futures)}\")\n        for id in ready_futures:\n            print(f'completed value {id}, result {ray.get(id)}')\n            time.sleep(1) # Business logic goes here\n        # We just need to wait on the ones that are not yet available\n        futures = rest_futures\n```", "```py\nfutures = list(map(lambda x: remote_task.remote(x), [1, threading.TIMEOUT_MAX]))\n# While we still have pending futures\nwhile len(futures) > 0:\n    # In practice, 10 seconds is too short for most cases\n    ready_futures, rest_futures = ray.wait(futures, timeout=10, num_returns=1)\n    # If we get back anything less than num_returns \n    if len(ready_futures) < 1:\n        print(f\"Timed out on {rest_futures}\")\n        # Canceling is a good idea for long-running, unneeded tasks\n        ray.cancel(*rest_futures)\n        # You should break since you exceeded your timeout\n        break\n    for id in ready_futures:\n        print(f'completed value {id}, result {ray.get(id)}')\n        futures = rest_futures\n```", "```py\n@ray.remote\ndef generate_number(s: int, limit: int, sl: float) -> int :\n   random.seed(s)\n   time.sleep(sl)\n   return random.randint(0, limit)\n\n@ray.remote\ndef sum_values(v1: int, v2: int, v3: int) -> int :\n   return v1+v2+v3\n\n# Get result\nprint(ray.get(sum_values.remote(generate_number.remote(1, 10, .1),\n       generate_number.remote(5, 20, .2), generate_number.remote(7, 15, .3))))\n```", "```py\n@ray.remote\ndef generate_number(s: int, limit: int, sl: float) -> int :\n   random.seed(s)\n   time.sleep(sl)\n   return random.randint(0, limit)\n\n@ray.remote\ndef sum_values(values: []) -> int :\n   return sum(values)\n\n# Get result\nprint(ray.get(sum_values.remote([generate_number.remote(1, 10, .1),\n       generate_number.remote(5, 20, .2), generate_number.remote(7, 15, .3)])))\n```", "```py\n@ray.remote\ndef generate_number(s: int, limit: int) -> int :\n   random.seed(s)\n   time.sleep(.1)\n   return randint(0, limit)\n\n@ray.remote\ndef remote_objrefs():\n   results = []\n   for n in range(4):\n       results.append(generate_number.remote(n, 4*n))\n   return results\n\n@ray.remote\ndef remote_values():\n   results = []\n   for n in range(4):\n       results.append(generate_number.remote(n, 4*n))\n   return ray.get(results)\n\nprint(ray.get(remote_values.remote()))\nfutures = ray.get(remote_objrefs.remote())\nwhile len(futures) > 0:\n    ready_futures, rest_futures = ray.wait(futures, timeout=600, num_returns=1)\n    # If we get back anything less than num_returns, there was a timeout\n    if len(ready_futures) < 1:\n        ray.cancel(*rest_futures)\n        break\n    for id in ready_futures:\n        print(f'completed result {ray.get(id)}')\n        futures = rest_futures\n```", "```py\nimport random\n\n@ray.remote\ndef fetch(url: str) -> Tuple[str, str]:\n    import urllib.request\n    with urllib.request.urlopen(url) as response:\n       return (url, response.read())\n\n@ray.remote\ndef has_spam(site_text: Tuple[str, str]) -> bool:\n    # Open the list of spammers or download it\n    spammers_url = (\n        \"https://raw.githubusercontent.com/matomo-org/\" + \n        \"referrer-spam-list/master/spammers.txt\"\n    )\n    import urllib.request\n    with urllib.request.urlopen(spammers_url) as response:\n            spammers = response.readlines()\n            for spammer in spammers:\n                if spammer in site_text[1]:\n                    return True\n    return False\n\n@ray.remote\ndef fake_spam1(us: Tuple[str, str]) -> bool:\n    # You should do something fancy here with TF or even just NLTK\n    time.sleep(10)\n    if random.randrange(10) == 1:\n        return True\n    else:\n        return False\n\n@ray.remote\ndef fake_spam2(us: Tuple[str, str]) -> bool:\n    # You should do something fancy here with TF or even just NLTK\n    time.sleep(5)\n    if random.randrange(10) > 4:\n        return True\n    else:\n        return False\n\n@ray.remote\ndef combine_is_spam(us: Tuple[str, str], model1: bool, model2: bool, model3: bool) -> \nTuple[str, str, bool]:\n    # Questionable fake ensemble\n    score = model1 * 0.2 + model2 * 0.4 + model3 * 0.4\n    if score > 0.2:\n        return True\n    else:\n        return False\n```"]