- en: 10\. Dictionaries#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10\. 字典#
- en: 原文：[https://allendowney.github.io/ThinkPython/chap10.html](https://allendowney.github.io/ThinkPython/chap10.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://allendowney.github.io/ThinkPython/chap10.html](https://allendowney.github.io/ThinkPython/chap10.html)
- en: This chapter presents a built-in type called a dictionary. It is one of Python’s
    best features – and the building block of many efficient and elegant algorithms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一种内置类型——字典。它是 Python 最棒的特性之一，也是许多高效优雅算法的构建模块。
- en: We’ll use dictionaries to compute the number of unique words in a book and the
    number of times each one appears. And in the exercises, we’ll use dictionaries
    to solve word puzzles.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用字典来计算书中独特单词的数量以及每个单词出现的次数。在练习中，我们还将使用字典来解决单词谜题。
- en: 10.1\. A dictionary is a mapping[#](#a-dictionary-is-a-mapping "Link to this
    heading")
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1\. 字典是一个映射[#](#a-dictionary-is-a-mapping "Link to this heading")
- en: A **dictionary** is like a list, but more general. In a list, the indices have
    to be integers; in a dictionary they can be (almost) any type. For example, suppose
    we make a list of number words, like this.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**字典**像列表，但更为通用。在列表中，索引必须是整数；在字典中，索引可以是（几乎）任何类型。例如，假设我们创建一个数字单词的列表，如下所示。'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can use an integer as an index to get the corresponding word.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用整数作为索引来获取对应的单词。
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But suppose we want to go in the other direction, and look up a word to get
    the corresponding integer. We can’t do that with a list, but we can with a dictionary.
    We’ll start by creating an empty dictionary and assigning it to `numbers`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设我们想反过来查找一个单词，以得到对应的整数。我们不能用列表做到这一点，但可以用字典。我们首先创建一个空字典，并将其赋值给 `numbers`。
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The curly braces, `{}`, represent an empty dictionary. To add items to the dictionary,
    we’ll use square brackets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号 `{}` 表示一个空字典。要向字典中添加项目，我们将使用方括号。
- en: '[PRE5]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This assignment adds to the dictionary an **item**, which represents the association
    of a **key** and a **value**. In this example, the key is the string `'zero'`
    and the value is the integer `0`. If we display the dictionary, we see that it
    contains one item, which contains a key and a value separated by a colon, `:`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本作业向字典添加了一个**项目**，表示**键**与**值**的关联。在这个例子中，键是字符串 `'zero'`，值是整数 `0`。如果我们显示字典，会看到它包含一个项目，项目中的键和值由冒号
    `:` 分隔。
- en: '[PRE6]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can add more items like this.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样添加更多项目。
- en: '[PRE8]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now the dictionary contains three items.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在字典包含了三个项目。
- en: To look up a key and get the corresponding value, we use the bracket operator.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找键并获取对应的值，我们使用括号运算符。
- en: '[PRE10]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the key isn’t in the dictionary, we get a `KeyError`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键不在字典中，我们会得到一个 `KeyError`。
- en: '[PRE12]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `len` function works on dictionaries; it returns the number of items.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`len` 函数适用于字典；它返回项目的数量。'
- en: '[PRE14]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In mathematical language, a dictionary represents a **mapping** from keys to
    values, so you can also say that each key “maps to” a value. In this example,
    each number word maps to the corresponding integer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 用数学语言来说，字典表示从键到值的**映射**，因此你也可以说每个键“映射到”一个值。在这个例子中，每个数字单词映射到对应的整数。
- en: The following figure shows the state diagram for `numbers`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 `numbers` 的状态图。
- en: '![_images/b4f6ce142833c443434f72ebc060ad7736df776d1330d5455522f6c53397a0d0.png](../Images/8084970e2e60b78c27070840c99e88f3.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![_images/b4f6ce142833c443434f72ebc060ad7736df776d1330d5455522f6c53397a0d0.png](../Images/8084970e2e60b78c27070840c99e88f3.png)'
- en: A dictionary is represented by a box with the word “dict” outside and the items
    inside. Each item is represented by a key and an arrow pointing to a value. The
    quotation marks indicate that the keys here are strings, not variable names.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 字典通过一个框表示，框外有“dict”字样，框内是各项内容。每个项目由一个键和指向值的箭头表示。引号表明这里的键是字符串，而不是变量名。
- en: 10.2\. Creating dictionaries[#](#creating-dictionaries "Link to this heading")
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2\. 创建字典[#](#creating-dictionaries "Link to this heading")
- en: In the previous section we created an empty dictionary and added items one at
    a time using the bracket operator. Instead, we could have created the dictionary
    all at once like this.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们创建了一个空字典，并使用括号运算符一次添加一个项目。相反，我们也可以像这样一次性创建字典。
- en: '[PRE16]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each item consists of a key and a value separated by a colon. The items are
    separated by commas and enclosed in curly braces.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目由键和值组成，键和值之间用冒号分隔。项目之间用逗号分隔，并被花括号括起来。
- en: Another way to create a dictionary is to use the `dict` function. We can make
    an empty dictionary like this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建字典的方法是使用 `dict` 函数。我们可以像这样创建一个空字典。
- en: '[PRE17]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And we can make a copy of a dictionary like this.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以像这样复制一个字典。
- en: '[PRE19]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is often useful to make a copy before performing operations that modify dictionaries.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行修改字典的操作之前，通常建议先创建一个字典的副本。
- en: '## 10.3\. The in operator[#](#the-in-operator "Link to this heading")'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '## 10.3\. `in`操作符[#](#the-in-operator "跳转到此标题")'
- en: The `in` operator works on dictionaries, too; it tells you whether something
    appears as a *key* in the dictionary.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`操作符也适用于字典；它会告诉你某个元素是否作为*键*出现在字典中。'
- en: '[PRE21]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `in` operator does *not* check whether something appears as a value.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`操作符*不会*检查某个元素是否作为值出现。'
- en: '[PRE23]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To see whether something appears as a value in a dictionary, you can use the
    method `values`, which returns a sequence of values, and then use the `in` operator.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看某个元素是否作为字典中的值出现，你可以使用`values`方法，它返回一个值序列，然后使用`in`操作符。
- en: '[PRE25]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The items in a Python dictionary are stored in a **hash table**, which is a
    way of organizing data that has a remarkable property: the `in` operator takes
    about the same amount of time no matter how many items are in the dictionary.
    That makes it possible to write some remarkably efficient algorithms.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python字典中的项存储在一个**哈希表**中，哈希表是一种组织数据的方式，具有一个显著的特性：无论字典中有多少项，`in`操作符所需的时间大致相同。这使得编写一些高效的算法成为可能。
- en: To demonstrate, we’ll compare two algorithms for finding pairs of words where
    one is the reverse of another – like `stressed` and `desserts`. We’ll start by
    reading the word list.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将比较两种算法，用于寻找一对单词，其中一个是另一个的反转——比如`stressed`和`desserts`。我们将从读取单词列表开始。
- en: '[PRE27]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And here’s `reverse_word` from the previous chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上一章中的`reverse_word`函数。
- en: '[PRE29]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The following function loops through the words in the list. For each one, it
    reverses the letters and then checks whether the reversed word is in the word
    list.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数遍历列表中的单词。对于每个单词，它会反转字母，然后检查反转后的单词是否在单词列表中。
- en: '[PRE30]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function takes more than a minute to run. The problem is that the `in`
    operator checks the words in the list one at a time, starting at the beginning.
    If it doesn’t find what it’s looking for – which happens most of the time – it
    has to search all the way to the end.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数运行需要超过一分钟。问题在于，`in`操作符会逐个检查列表中的单词，从头开始。如果它没有找到需要的内容——大多数情况下是这样——它就必须一直搜索到末尾。
- en: And the `in` operator is inside the loop, so it runs once for each word. Since
    there are more than 100,000 words in the list, and for each one we check more
    than 100,000 words, the total number of comparisons is the number of words squared
    – roughly – which is almost 13 billion.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 并且`in`操作符位于循环内部，因此它会为每个单词执行一次。由于列表中有超过10万个单词，而对于每个单词我们检查超过10万个单词，总的比较次数是单词数的平方——大约是130亿次。
- en: '[PRE31]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can make this function much faster with a dictionary. The following loop
    creates a dictionary that contains the words as keys.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过字典使这个函数变得更快。以下循环创建一个字典，将单词作为键存储。
- en: '[PRE33]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The values in `word_dict` are all `1`, but they could be anything, because we
    won’t ever look them up – we will only use this dictionary to check whether a
    key exists.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`word_dict`中的值都是`1`，但它们可以是任何值，因为我们永远不会查找它们——我们仅仅使用这个字典来检查键是否存在。'
- en: Now here’s a version of the previous function that replaces `word_list` with
    `word_dict`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这里有一个版本的函数，它将`word_list`替换为`word_dict`。
- en: '[PRE34]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This function takes less than one hundredth of a second, so it’s about 10,000
    times faster than the previous version.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数运行时间不到一秒钟，因此比之前的版本快大约10,000倍。
- en: In general, the time it takes to find an element in a list is proportional to
    the length of the list. The time it takes to find a key in a dictionary is almost
    constant – regardless of the number of items.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在列表中查找元素所需的时间与列表的长度成正比。而在字典中查找一个键的时间几乎是恒定的——无论项目的数量是多少。
- en: 10.4\. A collection of counters[#](#a-collection-of-counters "Link to this heading")
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4\. 计数器集合[#](#a-collection-of-counters "跳转到此标题")
- en: Suppose you are given a string and you want to count how many times each letter
    appears. A dictionary is a good tool for this job. We’ll start with an empty dictionary.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个字符串，并且想要统计每个字母出现的次数。字典是做这件事的一个好工具。我们从一个空字典开始。
- en: '[PRE35]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As we loop through the letters in the string, suppose we see the letter `'a'`
    for the first time. We can add it to the dictionary like this.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历字符串中的字母时，假设我们第一次看到字母`'a'`。我们可以像这样将它添加到字典中。
- en: '[PRE36]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The value `1` indicates that we have seen the letter once. Later, if we see
    the same letter again, we can increment the counter like this.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 值 `1` 表示我们已看到该字母一次。稍后，如果我们再次看到相同的字母，可以像这样增加计数器。
- en: '[PRE37]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now the value associated with `'a'` is `2`, because we’ve seen the letter twice.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在与 `'a'` 相关联的值是 `2`，因为我们已经看到了两次该字母。
- en: '[PRE38]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The following function uses these features to count the number of times each
    letter appears in a string.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数使用这些功能来计算每个字母在字符串中出现的次数。
- en: '[PRE40]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Each time through the loop, if `letter` is not in the dictionary, we create
    a new item with key `letter` and value `1`. If `letter` is already in the dictionary
    we increment the value associated with `letter`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环时，如果 `letter` 不在字典中，我们就创建一个键为 `letter`、值为 `1` 的新项。如果 `letter` 已经在字典中，我们就增加与
    `letter` 相关联的值。
- en: Here’s an example.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子。
- en: '[PRE41]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The items in `counter` show that the letter `'b'` appears once, `'r'` appears
    twice, and so on.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`counter` 中的项目显示字母 `''b''` 出现一次，字母 `''r''` 出现两次，以此类推。'
- en: 10.5\. Looping and dictionaries[#](#looping-and-dictionaries "Link to this heading")
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5\. 循环和字典[#](#looping-and-dictionaries "链接到该标题")
- en: If you use a dictionary in a `for` statement, it traverses the keys of the dictionary.
    To demonstrate, let’s make a dictionary that counts the letters in `'banana'`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 `for` 语句中使用字典，它会遍历字典的键。为了演示，让我们创建一个字典来统计 `'banana'` 中字母的出现次数。
- en: '[PRE43]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The following loop prints the keys, which are the letters.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下循环打印的是键，它们是字母。
- en: '[PRE45]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To print the values, we can use the `values` method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印值，我们可以使用 `values` 方法。
- en: '[PRE47]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To print the keys and values, we can loop through the keys and look up the corresponding
    values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印键和值，我们可以遍历键并查找相应的值。
- en: '[PRE49]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the next chapter, we’ll see a more concise way to do the same thing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将看到一种更简洁的方法来完成相同的事情。
- en: 10.6\. Lists and dictionaries[#](#lists-and-dictionaries "Link to this heading")
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6\. 列表和字典[#](#lists-and-dictionaries "链接到该标题")
- en: You can put a list in a dictionary as a value. For example, here’s a dictionary
    that maps from the number `4` to a list of four letters.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将列表作为字典的值。例如，下面是一个字典，它将数字 `4` 映射到一个包含四个字母的列表。
- en: '[PRE51]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: But you can’t put a list in a dictionary as a key. Here’s what happens if we
    try.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但你不能将列表作为字典的键。以下是我们尝试时发生的情况。
- en: '[PRE53]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: I mentioned earlier that dictionaries use hash tables, and that means that the
    keys have to be **hashable**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，字典使用哈希表，这意味着键必须是**可哈希的**。
- en: A **hash** is a function that takes a value (of any kind) and returns an integer.
    Dictionaries use these integers, called hash values, to store and look up keys.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希**是一个函数，它接受一个值（任何类型）并返回一个整数。字典使用这些整数，称为哈希值，用来存储和查找键。'
- en: This system only works if a key is immutable, so its hash value is always the
    same. But if a key is mutable, its hash value could change, and the dictionary
    would not work. That’s why keys have to be hashable, and why mutable types like
    lists aren’t.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统只有在键是不可变的情况下才有效，因此它的哈希值始终相同。但如果键是可变的，它的哈希值可能会改变，字典将无法工作。这就是为什么键必须是可哈希的，以及为什么像列表这样的可变类型不能作为键的原因。
- en: Since dictionaries are mutable, they can’t be used as keys, either. But they
    *can* be used as values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字典是可变的，它们也不能作为键使用。不过，它们*可以*作为值使用。
- en: '## 10.7\. Accumulating a list[#](#accumulating-a-list "Link to this heading")'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '## 10.7\. 累积列表[#](#accumulating-a-list "链接到该标题")'
- en: For many programming tasks, it is useful to loop through one list or dictionary
    while building another. As an example, we’ll loop through the words in `word_dict`
    and make a list of palindromes – that is, words that are spelled the same backward
    and forward, like “noon” and “rotator”.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多编程任务，遍历一个列表或字典同时构建另一个是非常有用的。例如，我们将遍历 `word_dict` 中的单词，生成一个回文列表——即那些正反拼写相同的单词，如“noon”和“rotator”。
- en: In the previous chapter, one of the exercises asked you to write a function
    that checks whether a word is a palindrome. Here’s a solution that uses `reverse_word`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章，其中一个练习要求你编写一个函数，检查一个单词是否是回文。这里是一个使用 `reverse_word` 的解决方案。
- en: '[PRE55]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If we loop through the words in `word_dict`, we can count the number of palindromes
    like this.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遍历 `word_dict` 中的单词，就可以像这样计算回文的数量。
- en: '[PRE56]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: By now, this pattern is familiar.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这个模式已经很熟悉了。
- en: Before the loop, `count` is initialized to `0`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环之前，`count` 被初始化为 `0`。
- en: Inside the loop, if `word` is a palindrome, we increment `count`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环内，如果 `word` 是回文，我们就增加 `count`。
- en: When the loop ends, `count` contains the total number of palindromes.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当循环结束时，`count` 包含回文的总数。
- en: We can use a similar pattern to make a list of palindromes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的模式来列出回文。
- en: '[PRE58]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here’s how it works:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它的工作原理：
- en: Before the loop, `palindromes` is initialized with an empty list.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环之前，`palindromes` 被初始化为空列表。
- en: Inside the loop, if `word` is a palindrome, we append it to the end of `palindromes`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环中，如果 `word` 是回文，我们将它添加到 `palindromes` 的末尾。
- en: When the loop ends, `palindromes` is a list of palindromes.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当循环结束时，`palindromes` 是一个回文列表。
- en: In this loop, `palindromes` is used as an **accumulator**, which is a variable
    that collects or accumulates data during a computation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环中，`palindromes` 被用作 **累加器**，即一个在计算过程中收集或累积数据的变量。
- en: Now suppose we want to select only palindromes with seven or more letters. We
    can loop through `palindromes` and make a new list that contains only long palindromes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们只想选择具有七个或更多字母的回文。我们可以遍历 `palindromes`，并生成一个新列表，其中只包含长回文。
- en: '[PRE60]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Looping through a list like this, selecting some elements and omitting others,
    is called **filtering**.  ## 10.8\. Memos[#](#memos "Link to this heading")'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '遍历列表，选择一些元素并忽略其他元素，这个过程称为 **过滤**。 ## 10.8\. 备忘录[#](#memos "链接到此标题")'
- en: If you ran the `fibonacci` function from [Chapter 6](chap06.html#section-fibonacci),
    maybe you noticed that the bigger the argument you provide, the longer the function
    takes to run.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了来自 [第6章](chap06.html#section-fibonacci) 的 `fibonacci` 函数，也许你注意到，提供的参数越大，函数运行的时间就越长。
- en: '[PRE62]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Furthermore, the run time increases quickly. To understand why, consider the
    following figure, which shows the **call graph** for `fibonacci` with `n=4`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，运行时间会迅速增加。为了理解原因，请考虑以下图示，它展示了 `fibonacci` 的 **调用图**，其中 `n=4`：
- en: '![_images/80cfcd12d7c8cde149103a1fe25d2b12bfce1b7cc33163b9e5582f9e32789f5d.png](../Images/698ff08186ba3a8f135d7c7b88b97009.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![_images/80cfcd12d7c8cde149103a1fe25d2b12bfce1b7cc33163b9e5582f9e32789f5d.png](../Images/698ff08186ba3a8f135d7c7b88b97009.png)'
- en: A call graph shows a set of function frames, with lines connecting each frame
    to the frames of the functions it calls. At the top of the graph, `fibonacci`
    with `n=4` calls `fibonacci` with `n=3` and `n=2`. In turn, `fibonacci` with `n=3`
    calls `fibonacci` with `n=2` and `n=1`. And so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 调用图展示了一组函数框架，框架之间通过连接线显示每个框架与其调用的函数框架之间的关系。在图的顶部，`fibonacci` 的 `n=4` 调用 `fibonacci`
    的 `n=3` 和 `n=2`。接下来，`fibonacci` 的 `n=3` 调用 `fibonacci` 的 `n=2` 和 `n=1`，依此类推。
- en: Count how many times `fibonacci(0)` and `fibonacci(1)` are called. This is an
    inefficient solution to the problem, and it gets worse as the argument gets bigger.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 `fibonacci(0)` 和 `fibonacci(1)` 被调用的次数。这是一个低效的解决方案，且随着参数的增大，效率会更差。
- en: 'One solution is to keep track of values that have already been computed by
    storing them in a dictionary. A previously computed value that is stored for later
    use is called a **memo**. Here is a “memoized” version of `fibonacci`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是通过将已经计算的值存储在字典中来跟踪这些值。一个先前计算过并为以后使用而存储的值被称为 **备忘录**。这是一个“备忘录化”版本的 `fibonacci`：
- en: '[PRE63]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`known` is a dictionary that keeps track of the Fibonacci numbers we already
    know It starts with two items: `0` maps to `0` and `1` maps to `1`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`known` 是一个字典，用来追踪我们已经知道的斐波那契数。它一开始有两个条目：`0` 映射到 `0`，`1` 映射到 `1`。'
- en: Whenever `fibonacci_memo` is called, it checks `known`. If the result is already
    there, it can return immediately. Otherwise it has to compute the new value, add
    it to the dictionary, and return it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用 `fibonacci_memo` 时，它都会检查 `known`。如果结果已经存在，它可以立即返回。否则，它必须计算新的值，将其添加到字典中，并返回该值。
- en: Comparing the two functions, `fibonacci(40)` takes about 30 seconds to run.
    `fibonacci_memo(40)` takes about 30 microseconds, so it’s a million times faster.
    In the notebook for this chapter, you’ll see where these measurements come from.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两个函数，`fibonacci(40)` 运行大约需要 30 秒，而 `fibonacci_memo(40)` 只需大约 30 微秒，因此速度快了约一百万倍。在本章的笔记本中，你会看到这些测量的来源。
- en: 10.9\. Debugging[#](#debugging "Link to this heading")
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.9\. 调试[#](#debugging "链接到此标题")
- en: 'As you work with bigger datasets it can become unwieldy to debug by printing
    and checking the output by hand. Here are some suggestions for debugging large
    datasets:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理更大的数据集时，通过打印输出并手动检查调试可能变得非常繁琐。以下是一些调试大数据集的建议：
- en: 'Scale down the input: If possible, reduce the size of the dataset. For example
    if the program reads a text file, start with just the first 10 lines, or with
    the smallest example you can find. You can either edit the files themselves, or
    (better) modify the program so it reads only the first `n` lines.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩小输入数据：如果可能，减小数据集的大小。例如，如果程序读取一个文本文件，可以从前 10 行开始，或者从你能找到的最小示例开始。你可以编辑文件本身，或者（更好）修改程序，使其只读取前
    `n` 行。
- en: If there is an error, you can reduce `n` to the smallest value where the error
    occurs. As you find and correct errors, you can increase `n` gradually.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果发生错误，可以将`n`减小到发生错误的最小值。当你找到并修正错误后，可以逐渐增加`n`。
- en: 'Check summaries and types: Instead of printing and checking the entire dataset,
    consider printing summaries of the data – for example, the number of items in
    a dictionary or the total of a list of numbers.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查摘要和类型：与其打印并检查整个数据集，不如考虑打印数据的摘要，例如字典中的项数或数字列表的总和。
- en: A common cause of runtime errors is a value that is not the right type. For
    debugging this kind of error, it is often enough to print the type of a value.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行时错误的一个常见原因是值的类型不正确。调试此类错误时，通常只需打印出值的类型即可。
- en: 'Write self-checks: Sometimes you can write code to check for errors automatically.
    For example, if you are computing the average of a list of numbers, you could
    check that the result is not greater than the largest element in the list or less
    than the smallest. This is called a “sanity check” because it detects results
    that are “insane”.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写自检代码：有时你可以编写代码来自动检查错误。例如，如果你正在计算一个数字列表的平均值，你可以检查结果是否不大于列表中的最大值，或不小于最小值。这被称为“合理性检查”，因为它能够检测出“不合理”的结果。
- en: Another kind of check compares the results of two different computations to
    see if they are consistent. This is called a “consistency check”.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种检查方法是比较两个不同计算结果的差异，以查看它们是否一致。这叫做“一致性检查”。
- en: 'Format the output: Formatting debugging output can make it easier to spot an
    error. We saw an example in [Chapter 6](chap06.html#section-debugging-factorial).
    Another tool you might find useful is the `pprint` module, which provides a `pprint`
    function that displays built-in types in a more human-readable format (`pprint`
    stands for “pretty print”).'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式化输出：格式化调试输出可以让错误更容易被发现。在[第6章](chap06.html#section-debugging-factorial)中，我们看到过一个例子。你可能会觉得有用的另一个工具是`pprint`模块，它提供了一个`pprint`函数，以更人性化的格式显示内建类型（`pprint`代表“漂亮打印”）。
- en: Again, time you spend building scaffolding can reduce the time you spend debugging.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次强调，花时间构建框架可以减少调试时所花费的时间。
- en: 10.10\. Glossary[#](#glossary "Link to this heading")
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.10\. 词汇表[#](#glossary "链接到此标题")
- en: '**dictionary:** An object that contains key-value pairs, also called items.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**字典：** 包含键值对的对象，也叫做项。'
- en: '**item:** In a dictionary, another name for a key-value pair.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**项：** 在字典中，键值对的另一种说法。'
- en: '**key:** An object that appears in a dictionary as the first part of a key-value
    pair.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**键：** 在字典中，作为键值对的第一部分出现的对象。'
- en: '**value:** An object that appears in a dictionary as the second part of a key-value
    pair. This is more specific than our previous use of the word “value”.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**值：** 在字典中，作为键值对的第二部分出现的对象。这个概念比我们之前使用的“值”更为具体。'
- en: '**mapping:** A relationship in which each element of one set corresponds to
    an element of another set.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射：** 一种关系，其中一个集合的每个元素与另一个集合的元素相对应。'
- en: '**hash table:** A collection of key-value pairs organized so that we can look
    up a key and find its value efficiently.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希表：** 一种由键值对组成的集合，组织方式使得我们可以高效地查找键并找到其对应的值。'
- en: '**hashable:** Immutable types like integers, floats and strings are hashable.
    Mutable types like lists and dictionaries are not.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**可哈希：** 像整数、浮点数和字符串这样的不可变类型是可哈希的。像列表和字典这样的可变类型则不是。'
- en: '**hash function:** A function that takes an object and computes an integer
    that is used to locate a key in a hash table.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希函数：** 一个接受对象并计算出一个整数，用来在哈希表中定位键的函数。'
- en: '**accumulator:** A variable used in a loop to add up or accumulate a result.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**累加器：** 在循环中用于累加结果的变量。'
- en: '**filtering:** Looping through a sequence and selecting or omitting elements.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**过滤：** 遍历一个序列并选择或省略元素。'
- en: '**call graph:** A diagram that shows every frame created during the execution
    of a program, with an arrow from each caller to each callee.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用图：** 显示程序执行过程中每个帧的图示，图中从每个调用者指向每个被调用者。'
- en: '**memo:** A computed value stored to avoid unnecessary future computation.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**备忘录：** 为了避免不必要的未来计算，存储的计算结果。'
- en: 10.11\. Exercises[#](#exercises "Link to this heading")
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.11\. 练习[#](#exercises "链接到此标题")
- en: '[PRE64]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 10.11.1\. Ask an assistant[#](#ask-an-assistant "Link to this heading")
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.11.1\. 请求助手[#](#ask-an-assistant "链接到此标题")
- en: In this chapter, I said the keys in a dictionary have to be hashable and I gave
    a short explanation. If you would like more details, ask a virtual assistant,
    “Why do keys in Python dictionaries have to be hashable?”
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我提到字典中的键必须是可哈希的，并给出了简短的解释。如果你想了解更多细节，可以问虚拟助手：“为什么Python字典中的键必须是可哈希的？”
- en: In [a previous section](#section-dictionary-in-operator), we stored a list of
    words as keys in a dictionary so that we could use an efficient version of the
    `in` operator. We could have done the same thing using a `set`, which is another
    built-in data type. Ask a virtual assistant, “How do I make a Python set from
    a list of strings and check whether a string is an element of the set?”
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在[前一节](#section-dictionary-in-operator)中，我们将一组单词存储为字典的键，以便能够使用更高效的`in`运算符版本。我们也可以使用`set`，这是另一种内建的数据类型，来完成同样的操作。你可以问虚拟助手：“如何从字符串列表创建一个Python集合，并检查一个字符串是否是集合的元素？”
- en: 10.11.2\. Exercise[#](#exercise "Link to this heading")
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.11.2\. 练习[#](#exercise "链接到这个标题")
- en: Dictionaries have a method called `get` that takes a key and a default value.
    If the key appears in the dictionary, `get` returns the corresponding value; otherwise
    it returns the default value. For example, here’s a dictionary that maps from
    the letters in a string to the number of times they appear.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 字典有一个名为`get`的方法，它接受一个键和一个默认值。如果键出现在字典中，`get`返回对应的值；否则，它返回默认值。例如，这里有一个字典，将字符串中的字母映射到它们出现的次数。
- en: '[PRE65]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If we look up a letter that appears in the word, `get` returns the number of
    times it appears.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查找一个出现在单词中的字母，`get`方法会返回它出现的次数。
- en: '[PRE66]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If we look up a letter that doesn’t appear, we get the default value, `0`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查找一个没有出现的字母，我们会得到默认值`0`。
- en: '[PRE68]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Use `get` to write a more concise version of `value_counts`. You should be able
    to eliminate the `if` statement.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`get`编写`value_counts`的简洁版。你应该能够消除`if`语句。
- en: 10.11.3\. Exercise[#](#id1 "Link to this heading")
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.11.3\. 练习[#](#id1 "链接到这个标题")
- en: What is the longest word you can think of where each letter appears only once?
    Let’s see if we can find one longer than `unpredictably`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到的最长的单词是什么？其中每个字母只出现一次。让我们看看能否找到一个比`unpredictably`更长的单词。
- en: Write a function named `has_duplicates` that takes a sequence – like a list
    or string – as a parameter and returns `True` if there is any element that appears
    in the sequence more than once.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`has_duplicates`的函数，该函数接受一个序列（如列表或字符串）作为参数，并返回`True`，如果序列中有任何元素出现超过一次。
- en: 10.11.4\. Exercise[#](#id2 "Link to this heading")
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.11.4\. 练习[#](#id2 "链接到这个标题")
- en: Write function called `find_repeats` that takes a dictionary that maps from
    each key to a counter, like the result from `value_counts`. It should loop through
    the dictionary and return a list of keys that have counts greater than `1`. You
    can use the following outline to get started.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`find_repeats`的函数，它接受一个字典，该字典将每个键映射到一个计数器（类似`value_counts`的结果）。该函数应遍历字典并返回一个包含计数大于`1`的键的列表。你可以使用以下框架开始编写代码。
- en: '[PRE70]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 10.11.5\. Exercise[#](#id3 "Link to this heading")
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.11.5\. 练习[#](#id3 "链接到这个标题")
- en: Suppose you run `value_counts` with two different words and save the results
    in two dictionaries.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你用两个不同的单词运行`value_counts`并将结果保存在两个字典中。
- en: '[PRE71]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Each dictionary maps from a set of letters to the number of times they appear.
    Write a function called `add_counters` that takes two dictionaries like this and
    returns a new dictionary that contains all of the letters and the total number
    of times they appear in either word.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字典都将一组字母映射到它们出现的次数。编写一个名为`add_counters`的函数，该函数接受两个这样的字典，并返回一个新的字典，包含所有字母以及它们在两个单词中出现的总次数。
- en: There are many ways to solve this problem. Once you have a working solution,
    consider asking a virtual assistant for different solutions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以解决这个问题。解决后，你可以考虑问虚拟助手提供其他不同的解决方案。
- en: 10.11.6\. Exercise[#](#id4 "Link to this heading")
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.11.6\. 练习[#](#id4 "链接到这个标题")
- en: A word is “interlocking” if we can split it into two words by taking alternating
    letters. For example, “schooled” is an interlocking word because it can be split
    into “shoe” and “cold”.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个单词是“交错的”，那么我们可以通过交替取字母将其拆分为两个单词。例如，“schooled”是一个交错词，因为它可以拆分为“shoe”和“cold”。
- en: To select alternating letters from a string, you can use a slice operator with
    three components that indicate where to start, where to stop, and the “step size”
    between the letters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个字符串中选择交替字母，你可以使用切片操作符，它有三个组成部分：起始位置、结束位置和字母之间的“步长”。
- en: In the following slice, the first component is `0`, so we start with the first
    letter. The second component is `None`, which means we should go all the way to
    the end of the string. And the third component is `2`, so there are two steps
    between the letters we select.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下切片中，第一个组件是`0`，所以我们从第一个字母开始。第二个组件是`None`，这意味着我们应该一直选择到字符串的末尾。第三个组件是`2`，因此我们选择的字母之间有两个步长。
- en: '[PRE72]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Instead of providing `None` as the second component, we can get the same effect
    by leaving it out altogether. For example, the following slice selects alternating
    letters, starting with the second letter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过完全省略第二个组件，而不是提供`None`，来达到相同的效果。例如，下面的切片选择交替的字母，从第二个字母开始。
- en: '[PRE74]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Write a function called `is_interlocking` that takes a word as an argument and
    returns `True` if it can be split into two interlocking words.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`is_interlocking`的函数，它接受一个单词作为参数，如果该单词可以被拆分为两个交织的单词，则返回`True`。
- en: '[PRE76]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[Think Python: 第3版](https://allendowney.github.io/ThinkPython/index.html)'
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 版权 2024 [Allen B. Downey](https://allendowney.com)
- en: 'Code license: [MIT License](https://mit-license.org/)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '代码许可证: [MIT 许可证](https://mit-license.org/)'
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '文本许可证: [创意共享署名-非商业性使用-相同方式共享 4.0 国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
