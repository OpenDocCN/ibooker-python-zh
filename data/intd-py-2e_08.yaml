- en: Chapter 7\. Tuples and Lists
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。元组和列表
- en: The human animal differs from the lesser primates in his passion for lists.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 人类与低等灵长类动物的区别在于他对列表的热爱。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: H. Allen Smith
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: H. Allen Smith
- en: 'In the previous chapters, we started with some of Python’s basic data types:
    booleans, integers, floats, and strings. If you think of those as atoms, the data
    structures in this chapter are like molecules. That is, we combine those basic
    types in more complex ways. You will use these every day. Much of programming
    consists of chopping and gluing data into specific forms, and these are your hacksaws
    and glue guns.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们从Python的一些基本数据类型开始：布尔值，整数，浮点数和字符串。如果你把它们看作是原子，那么本章中的数据结构就像分子一样。也就是说，我们将这些基本类型以更复杂的方式组合在一起。你将每天都用到它们。编程的很大一部分就是将数据切割和粘贴成特定形式，而这些就是你的金刚钻和胶枪。
- en: 'Most computer languages can represent a sequence of items indexed by their
    integer position: first, second, and so on down to the last. You’ve already seen
    Python *strings*, which are sequences of characters.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机语言可以表示按其整数位置索引的项目序列：第一个，第二个，依此类推直到最后一个。你已经见过Python的*字符串*，它们是字符序列。
- en: 'Python has two other sequence structures: *tuples* and *lists*. These contain
    zero or more elements. Unlike strings, the elements can be of different types.
    In fact, each element can be *any* Python object. This lets you create structures
    as deep and complex as you like.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有另外两种序列结构：*元组*和*列表*。它们包含零个或多个元素。与字符串不同，元素可以是不同的类型。事实上，每个元素都可以是*任何*Python对象。这使你可以创建像你喜欢的那样深度和复杂的结构。
- en: Why does Python contain both lists and tuples? Tuples are *immutable*; when
    you assign elements (only once) to a tuple, they’re baked in the cake and can’t
    be changed. Lists are *mutable*, meaning you can insert and delete elements with
    great enthusiasm. I’ll show many examples of each, with an emphasis on lists.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Python同时包含列表和元组？元组是*不可变*的；当你将元素（仅一次）分配给元组时，它们就成为了固定的部分，不能更改。列表是*可变*的，这意味着你可以兴致勃勃地插入和删除元素。我将展示每种的许多例子，并着重于列表。
- en: Tuples
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'Let’s get one thing out of the way first. You may hear two different pronunciations
    for *tuple*. Which is right? If you guess wrong, do you risk being considered
    a Python poseur? No worries. Guido van Rossum, the creator of Python, said [via
    Twitter](http://bit.ly/tupletweet):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先把一件事搞清楚。你可能会听到两种不同的*tuple*发音。哪个是正确的？如果你猜错了，是否会被认为是Python的冒牌货？别担心。Python的创造者Guido
    van Rossum在[Twitter上](http://bit.ly/tupletweet)说过：
- en: I pronounce tuple too-pull on Mon/Wed/Fri and tub-pull on Tue/Thu/Sat. On Sunday
    I don’t talk about them. :)
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我在周一/三/五会念作too-pull，周二/四/六会念作tub-pull。周日我不谈它们。 :)
- en: Create with Commas and ()
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用逗号和()创建
- en: 'The syntax to make tuples is a little inconsistent, as the following examples
    demonstrate. Let’s begin by making an empty tuple using `()`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建元组的语法有点不一致，如下面的例子所示。让我们从使用`()`创建一个空元组开始：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To make a tuple with one or more elements, follow each element with a comma.
    This works for one-element tuples:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个或多个元素的元组，请在每个元素后面都跟一个逗号。这适用于单元素元组：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You could enclose them in parentheses and still get the same tuple:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将它们括在括号中，仍然得到相同的元组：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s a little gotcha: if you have a single thing in parentheses and omit
    that comma, you would not get a tuple, but just the thing (in this example, the
    string `''Groucho''`):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小陷阱：如果括号中只有一个东西而省略了逗号，你将得不到一个元组，而只是那个东西（在这个例子中是字符串`'Groucho'`）：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you have more than one element, follow all but the last one with a comma:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个元素，请除了最后一个元素外，每个元素后面都跟一个逗号：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Python includes parentheses when echoing a tuple. You often don’t need them
    when you define a tuple, but using parentheses is a little safer, and it helps
    to make the tuple more visible:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python在回显元组时包括括号。当你定义一个元组时通常不需要它们，但使用括号会更安全，并且有助于使元组更可见：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You do need the parentheses for cases in which commas might also have another
    use. In this example, you can create and assign a single-element tuple with just
    a trailing comma, but you can’t pass it as an argument to a function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，如果逗号可能具有其他用途，则确实需要括号。例如，在这个例子中，你可以只用一个尾随逗号创建并分配一个单元素元组，但你不能将其作为函数的参数传递。
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Tuples let you assign multiple variables at once:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 元组让你一次性赋值多个变量：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is sometimes called *tuple unpacking*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时被称为*元组解包*。
- en: 'You can use tuples to exchange values in one statement without using a temporary
    variable:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用元组在一条语句中交换值，而不使用临时变量：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create with tuple()
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用tuple()创建
- en: 'The `tuple()` conversion function makes tuples from other things:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple()`转换函数从其他内容制作元组：'
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Combine Tuples by Using `+`
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`+`组合元组
- en: 'This is similar to combining strings:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于组合字符串：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Duplicate Items with *
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用*复制*项
- en: 'This is like repeated use of `+`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像重复使用`+`一样：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Compare Tuples
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较元组
- en: 'This works much like list comparisons:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这与列表比较类似：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Iterate with for and in
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用for和in进行迭代
- en: 'Tuple iteration is like iteration of other types:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 元组迭代类似于其他类型的迭代：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Modify a Tuple
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改元组
- en: 'You can’t! Like strings, tuples are immutable, so you can’t change an existing
    one. As you saw just before, you can *concatenate* (combine) tuples to make a
    new one, as you can with strings:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能！与字符串一样，元组是不可变的，因此您不能更改现有元组。就像您之前看到的那样，您可以*连接*（组合）元组以制作新元组，就像您可以连接字符串一样：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This means that you can appear to modify a tuple like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以看起来修改元组，就像这样：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But it isn’t the same `t1`. Python made a new tuple from the original tuples
    pointed to by `t1` and `t2`, and assigned the name `t1` to this new tuple. You
    can see with `id()` when a variable name is pointing to a new value:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但它不是相同的`t1`。Python从由`t1`和`t2`指向的原始元组制作了一个新元组，并将名称`t1`指向了这个新元组。您可以使用`id()`查看变量名称何时指向新值：
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Lists
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are good for keeping track of things by their order, especially when the
    order and contents might change. Unlike strings, lists are mutable. You can change
    a list in place, add new elements, and delete or replace existing elements. The
    same value can occur more than once in a list.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表适合按其顺序跟踪事物，特别是当顺序和内容可能会变化时。与字符串不同，列表是可变的。您可以就地更改列表，添加新元素，并删除或替换现有元素。相同的值可以在列表中出现多次。
- en: Create with []
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用[]创建
- en: 'A list is made from zero or more elements, separated by commas and surrounded
    by square brackets:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表由零个或多个元素组成，用逗号分隔，并用方括号括起来：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `first_names` list shows that values do not need to be unique.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`first_names`列表显示值不需要是唯一的。'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to keep track of only unique values and don’t care about order,
    a Python *set* might be a better choice than a list. In the previous example,
    `big_birds` could have been a set. We explore sets in [Chapter 8](ch08.html#ch_dicts).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想跟踪唯一值并且不关心顺序，则Python *set*可能比列表更好。在前面的示例中，`big_birds`可以是一个集合。我们在[第8章](ch08.html#ch_dicts)中探讨了集合。
- en: Create or Convert with list()
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用list()创建或转换
- en: 'You can also make an empty list with the `list()` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`list()`函数创建一个空列表：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Python’s `list()` function also converts other *iterable* data types (such
    as tuples, strings, sets, and dictionaries) to lists. The following example converts
    a string to a list of one-character strings:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`list()`函数还将其他*可迭代*数据类型（如元组、字符串、集合和字典）转换为列表。以下示例将字符串转换为一个字符的字符串列表：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This example converts a tuple to a list:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例将元组转换为列表：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Create from a String with split()
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用split()从字符串创建
- en: 'As I mentioned earlier in [“Split with split()”](ch05.html#string_split), use
    `split()` to chop a string into a list by some separator:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前在[“使用split()拆分”](ch05.html#string_split)中提到的，使用`split()`通过某个分隔符将字符串切割为列表：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What if you have more than one separator string in a row in your original string?
    Well, you get an empty string as a list item:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的原始字符串中有多个连续的分隔符字符串怎么办？好吧，你会得到一个空字符串作为列表项：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you had used the two-character separator string `//`, instead, you would
    get this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用两个字符的分隔符字符串`//`，则会得到这个结果：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Get an Item by [ *offset* ]
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过[ *偏移量* ]获取项
- en: 'As with strings, you can extract a single value from a list by specifying its
    offset:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串类似，您可以通过指定其偏移量从列表中提取单个值：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Again, as with strings, negative indexes count backward from the end:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，与字符串类似，负索引从末尾向后计数：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The offset has to be a valid one for this list—a position you have assigned
    a value previously. If you specify an offset before the beginning or after the
    end, you’ll get an exception (error). Here’s what happens if we try to get the
    sixth Marx brother (offset `5` counting from `0`), or the fifth before the end:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量必须是此列表的有效偏移量，即您先前分配了一个值的位置。如果指定了开始之前或结束之后的偏移量，您将收到一个异常（错误）。这是如果我们尝试获取第六个马克思兄弟（偏移量`5`从`0`开始计数），或倒数第五个会发生的情况：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Get Items with a Slice
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用切片获取项目
- en: 'You can extract a subsequence of a list by using a *slice*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用*切片*提取列表的子序列：
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A slice of a list is also a list.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的切片也是一个列表。
- en: 'As with strings, slices can step by values other than one. The next example
    starts at the beginning and goes right by 2:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串类似，切片可以步进除了一之外的其他值。下一个示例从开始处开始，每次向右移动2个位置：
- en: '[PRE29]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we start at the end and go left by 2:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从末尾开始，左移2个位置：
- en: '[PRE30]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And finally, the trick to reverse a list:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，反转列表的窍门：
- en: '[PRE31]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'None of these slices changed the `marxes` list itself, because we didn’t assign
    them to `marxes`. To reverse a list in place, use `*list*.reverse()`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些切片都没有改变`marxes`列表本身，因为我们没有把它们赋给`marxes`。要就地反转列表，请使用`*列表*.reverse()`：
- en: '[PRE32]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `reverse()` function changes the list but doesn’t return its value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse()`函数改变了列表但不返回其值。'
- en: 'As you saw with strings, a slice can specify an invalid index, but will not
    cause an exception. It will “snap” to the closest valid index or return nothing:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在字符串中看到的，切片可以指定一个无效的索引，但不会导致异常。它会“捕捉”到最接近的有效索引或者返回空：
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Add an Item to the End with append()
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过append()在末尾添加项目
- en: 'The traditional way of adding items to a list is to `append()` them one by
    one to the end. In the previous examples, we forgot Zeppo, but that’s alright
    because the list is mutable, so we can add him now:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 添加项目到列表的传统方法是一个接一个地用`append()`将它们添加到末尾。在前面的例子中，我们忘记了Zeppo，但这没关系，因为列表是可变的，所以我们现在可以添加他：
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Add an Item by Offset with insert()
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过insert()在偏移处添加项目
- en: 'The `append()` function adds items only to the end of the list. When you want
    to add an item before any offset in the list, use `insert()`. Offset `0` inserts
    at the beginning. An offset beyond the end of the list inserts at the end, like
    `append()`, so you don’t need to worry about Python throwing an exception:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`append()`函数只在列表末尾添加项目。当你想在列表的任何偏移之前添加项目时，请使用`insert()`。偏移`0`在开头插入。超出列表末尾的偏移会像`append()`一样在末尾插入，所以你不需要担心Python抛出异常：'
- en: '[PRE35]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Duplicate All Items with *
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用*复制所有项目
- en: 'In [Chapter 5](ch05.html#ch_strings), you saw that you can duplicate a string’s
    characters with `*`. The same works for a list:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html#ch_strings)中，你看到你可以用`*`来复制字符串的字符。对列表也同样适用：
- en: '[PRE36]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Combine Lists by Using extend() or `+`
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过extend()或者`+`合并列表
- en: 'You can merge one list into another by using `extend()`. Suppose that a well-meaning
    person gave us a new list of Marxes called `others`, and we’d like to merge them
    into the main `marxes` list:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`extend()`将一个列表合并到另一个列表中。假设一个好心的人给了我们一个名为`others`的新马克思斯列表，并且我们想要将它们合并到主要的`marxes`列表中：
- en: '[PRE37]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Alternatively, you can use `+` or `+=`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用`+`或者`+=`：
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we had used `append()`, `others` would have been added as a *single* list
    item rather than merging its items:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用了`append()`，`others`会被添加为*单个*列表项，而不是合并其项目：
- en: '[PRE39]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This again demonstrates that a list can contain elements of different types.
    In this case, four strings, and a list of two strings.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次证明了列表可以包含不同类型的元素。在这种情况下，四个字符串和一个包含两个字符串的列表。
- en: Change an Item by [ *offset* ]
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过[offset]更改项目
- en: 'Just as you can get the value of a list item by its offset, you can change
    it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以通过偏移获取列表项的值一样，你也可以修改它：
- en: '[PRE40]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Again, the list offset needs to be a valid one for this list.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，列表偏移需要是这个列表的有效偏移之一。
- en: You can’t change a character in a string in this way, because strings are immutable.
    Lists are mutable. You can change how many items a list contains as well as the
    items themselves.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能用这种方式改变字符串中的字符，因为字符串是不可变的。列表是可变的。你可以改变列表包含的项目数量以及项目本身。
- en: Change Items with a Slice
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用切片更改项目
- en: 'The previous section showed how to get a sublist with a slice. You can also
    assign values to a sublist with a slice:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节展示了如何使用切片获取子列表。你也可以使用切片为子列表赋值：
- en: '[PRE41]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The righthand thing that you’re assigning to the list doesn’t even need to
    have the same number of elements as the slice on the left:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您分配给列表的右侧对象甚至不需要与左侧切片具有相同数量的元素：
- en: '[PRE42]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Actually, the righthand thing doesn’t even need to be a list. Any Python *iterable*
    will do, separating its items and assigning them to list elements:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，右边的东西甚至不需要是一个列表。任何Python*可迭代对象*都可以，分离其项目并将其分配给列表元素：
- en: '[PRE44]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Delete an Item by Offset with del
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过del按偏移删除项目
- en: 'Our fact checkers have just informed us that Gummo was indeed one of the Marx
    Brothers, but Karl wasn’t, and that whoever inserted him earlier was very rude.
    Let’s fix that:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的事实核查员刚刚告诉我们，Gummo确实是马克思兄弟之一，但卡尔不是，并且早先插入他的人非常无礼。让我们来修复一下：
- en: '[PRE46]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When you delete an item by its position in the list, the items that follow
    it move back to take the deleted item’s space, and the list’s length decreases
    by one. If we deleted `''Chico''` from the last version of the `marxes` list,
    we get this as a result:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按列表中的位置删除一个项目时，随后的项目会向后移动以填补删除项目的空间，并且列表的长度会减少一个。如果我们从`marxes`列表的最后一个版本中删除了`'Chico'`，我们会得到这样的结果：
- en: '[PRE47]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`del` is a Python *statement*, not a list method—you don’t say `marxes[-1].del()`.
    It’s sort of the reverse of assignment (`=`): it detaches a name from a Python
    object and can free up the object’s memory if that name were the last reference
    to it.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`del` 是一个Python *语句*，不是列表的方法 —— 你不会说 `marxes[-1].del()`。这与赋值 (`=`) 的相反：它会将一个名称从Python对象中分离出来，如果该名称是对该对象的最后一个引用，则可以释放该对象的内存。'
- en: Delete an Item by Value with remove()
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`remove()`按值删除项目
- en: 'If you’re not sure or don’t care where the item is in the list, use `remove()`
    to delete it by value. Goodbye, Groucho:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不确定或不关心项目在列表中的位置，请使用`remove()`按值删除它。再见，Groucho：
- en: '[PRE48]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you had duplicate list items with the same value, `remove()` deletes only
    the first one it finds.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表中有相同值的重复项目，`remove()`仅删除找到的第一个。
- en: Get an Item by Offset and Delete It with pop()
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用偏移获取项目并使用`pop()`删除它
- en: 'You can get an item from a list and delete it from the list at the same time
    by using `pop()`. If you call `pop()` with an offset, it will return the item
    at that offset; with no argument, it uses `-1`. So, `pop(0)` returns the head
    (start) of the list, and `pop()` or `pop(-1)` returns the tail (end), as shown
    here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`pop()`从列表中获取项目并同时删除它。如果使用偏移调用`pop()`，它将返回该偏移量处的项目；如果没有参数，则使用`-1`。因此，`pop(0)`返回列表的头部（起始处），而`pop()`或`pop(-1)`返回尾部（结束处），如下所示：
- en: '[PRE49]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It’s computing jargon time! Don’t worry, these won’t be on the final exam. If
    you use `append()` to add new items to the end and `pop()` to remove them from
    the same end, you’ve implemented a data structure known as a *LIFO* (last in,
    first out) queue. This is more commonly known as a *stack*. `pop(0)` would create
    a *FIFO* (first in, first out) queue. These are useful when you want to collect
    data as they arrive and work with either the oldest first (FIFO) or the newest
    first (LIFO).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是计算机术语时间！别担心，这些不会出现在期末考试中。如果你使用`append()`在末尾添加新项目，并使用`pop()`从同一端移除它们，你就实现了一种称为
    *LIFO*（后进先出）队列的数据结构。这更常被称为 *栈*。`pop(0)`将创建一个 *FIFO*（先进先出）队列。当你希望按到达顺序收集数据并首先使用最旧的数据（FIFO），或者首先使用最新的数据（LIFO）时，这些非常有用。
- en: Delete All Items with clear()
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`clear()`删除所有项目
- en: 'Python 3.3 introduced a method to clear a list of all its elements:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.3引入了清空列表所有元素的方法：
- en: '[PRE50]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Find an Item’s Offset by Value with index()
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`index()`按值查找项目的偏移量
- en: 'If you want to know the offset of an item in a list by its value, use `index()`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想知道列表中项目按其值的偏移量，使用`index()`：
- en: '[PRE51]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If the value is in the list more than once, only the offset of the first one
    is returned:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该值在列表中出现多次，只返回第一个的偏移量：
- en: '[PRE52]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Test for a Value with in
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`in`测试值是否存在
- en: 'The Pythonic way to check for the existence of a value in a list is using `in`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中检查值是否存在的Python方式是使用`in`：
- en: '[PRE53]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The same value may be in more than one position in the list. As long as it’s
    in there at least once, `in` will return `True`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个值可能在列表中出现多次。只要至少出现一次，`in` 就会返回 `True`：
- en: '[PRE54]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you check for the existence of some value in a list often and don’t care
    about the order of items, a Python *set* is a more appropriate way to store and
    look up unique values. We talk about sets in [Chapter 8](ch08.html#ch_dicts).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果经常检查列表中某个值的存在性，并且不关心项目的顺序，Python *set* 是存储和查找唯一值的更合适方式。我们在[第8章](ch08.html#ch_dicts)中讨论了集合。
- en: Count Occurrences of a Value with count()
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`count()`计算值的出现次数
- en: 'To count how many times a particular value occurs in a list, use `count()`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要统计列表中特定值出现的次数，请使用`count()`：
- en: '[PRE55]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Convert a List to a String with join()
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`join()`将列表转换为字符串
- en: '[“Combine by Using join()”](ch05.html#join) discussed `join()` in greater detail,
    but here’s another example of what you can do with it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[“使用join()组合”](ch05.html#join) 更详细地讨论了`join()`，这里是另一个示例：'
- en: '[PRE57]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You might be thinking that this seems a little backward. `join()` is a string
    method, not a list method. You can’t say `marxes.join('', '')`, even though it
    seems more intuitive. The argument to `join()` is a string or any iterable sequence
    of strings (including a list), and its output is a string. If `join()` were just
    a list method, you couldn’t use it with other iterable objects such as tuples
    or strings. If you did want it to work with any iterable type, you’d need special
    code for each type to handle the actual joining. It might help to remember—`join()`
    *is the opposite of* `split()`, as shown here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这似乎有点反向。`join()`是一个字符串方法，而不是一个列表方法。你不能说`marxes.join(', ')`，即使它看起来更直观。`join()`的参数是一个字符串或任何可迭代的字符串序列（包括列表），其输出是一个字符串。如果`join()`只是一个列表方法，你不能将其与其他可迭代对象如元组或字符串一起使用。如果你确实希望它能处理任何可迭代类型，你需要为每种类型编写特殊的代码来处理实际的连接。记住——`join()`
    *与* `split()`*是相反的*，如下所示：
- en: '[PRE58]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Reorder Items with sort() or sorted()
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`sort()`或`sorted()`重新排序项目
- en: 'You’ll often need to sort the items in a list by their values rather than their
    offsets. Python provides two functions:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要按值而不是偏移量对列表中的项目进行排序。Python提供了两个函数：
- en: The list method `sort()` sorts the list itself, *in place*.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表方法`sort()`会*原地*对列表进行排序。
- en: The general function `sorted()` returns a sorted *copy* of the list.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用函数`sorted()`返回列表的已排序*副本*。
- en: 'If the items in the list are numeric, they’re sorted by default in ascending
    numeric order. If they’re strings, they’re sorted in alphabetical order:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表中的项是数字，则默认按升序数字顺序排序。如果它们是字符串，则按字母顺序排序：
- en: '[PRE59]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`sorted_marxes` is a new list, and creating it did not change the original
    list:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted_marxes`是一个新列表，创建它并未改变原始列表：'
- en: '[PRE60]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'But calling the list function `sort()` on the `marxes` list does change `marxes`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但在`marxes`列表上调用列表函数`sort()`确实会改变`marxes`：
- en: '[PRE61]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If the elements of your list are all of the same type (such as strings in `marxes`),
    `sort()` will work correctly. You can sometimes even mix types—for example, integers
    and floats—because they are automatically converted to one another by Python in
    expressions:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表的元素都是相同类型的（例如在`marxes`中的字符串），`sort()`将正常工作。有时甚至可以混合类型——例如整数和浮点数——因为Python在表达式中会自动转换它们：
- en: '[PRE62]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The default sort order is ascending, but you can add the argument `reverse=True`
    to set it to descending:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 默认排序顺序是升序，但可以添加参数`reverse=True`将其设置为降序：
- en: '[PRE63]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Get Length with len()
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`len()`获取长度
- en: '`len()` returns the number of items in a list:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`len()`返回列表中的项数：'
- en: '[PRE64]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Assign with =
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`=`分配
- en: 'When you assign one list to more than one variable, changing the list in one
    place also changes it in the other, as illustrated here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个列表分配给多个变量时，在一个地方改变列表也会在另一个地方改变，如下所示：
- en: '[PRE65]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'So what’s in `b` now? Is it still `[1, 2, 3]`, or `[''surprise'', 2, 3]`? Let’s
    see:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 那么现在`b`里面是什么？它还是`[1, 2, 3]`，还是`['surprise', 2, 3]`？让我们看看：
- en: '[PRE66]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Remember the box (object) and string with note (variable name) analogy in [Chapter 2](ch02.html#ch_names)?
    `b` just refers to the same list object as `a` (both name strings lead to the
    same object box). Whether we change the list contents by using the name `a` or
    `b`, it’s reflected in both:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 记住[第2章](ch02.html#ch_names)中的盒子（对象）和带有注释的字符串（变量名）类比？`b`只是引用与`a`相同的列表对象（两个名称字符串引导到同一个对象盒子）。无论我们使用名称`a`还是`b`改变列表内容，都会反映在两者上：
- en: '[PRE67]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Copy with copy(), list(), or a Slice
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`copy()`、`list()`或切片复制
- en: 'You can *copy* the values of a list to an independent, fresh list by using
    any of these methods:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下任一方法将列表的值复制到独立的新列表中：
- en: The list `copy()` method
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表`copy()`方法
- en: The `list()` conversion function
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list()`转换函数'
- en: The list slice `[:]`
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表切片`[:]`
- en: 'Our original list will be `a` again. We make `b` with the list `copy()` function,
    `c` with the `list()` conversion function, and `d` with a list slice:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的原始列表将再次是`a`。我们用列表`copy()`函数制作`b`，用`list()`转换函数制作`c`，用列表切片制作`d`：
- en: '[PRE68]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Again, `b`, `c`, and `d` are *copies* of `a`: they are new objects with their
    own values and no connection to the original list object `[1, 2, 3]` to which
    `a` refers. Changing `a` does *not* affect the copies `b`, `c`, and `d`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`b`、`c`和`d`是`a`的*副本*：它们是具有自己值且与原始列表对象`[1, 2, 3]`没有连接的新对象。改变`a`不会影响副本`b`、`c`和`d`：
- en: '[PRE69]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Copy Everything with deepcopy()
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`deepcopy()`复制所有内容
- en: The `copy()` function works well if the list values are all immutable. As you’ve
    seen before, mutable values (like lists, tuples, or dicts) are references. A change
    in the original or the copy would be reflected in both.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表的值全部是不可变的，`copy()` 函数可以很好地工作。正如之前所见，可变值（如列表、元组或字典）是引用。对原始对象或副本的更改将反映在两者中。
- en: 'Let’s use the previous example but make the last element in list `a` the list
    `[8, 9]` instead of the integer `3`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用前面的例子，但将列表 `a` 中的最后一个元素更改为列表 `[8, 9]` 而不是整数 `3`：
- en: '[PRE70]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'So far, so good. Now change an element in that sublist in `a`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止一切顺利。现在更改 `a` 中的子列表中的一个元素：
- en: '[PRE71]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The value of `a[2]` is now a list, and its elements can be changed. All the
    list-copying methods we used were *shallow* (not a value judgment, just a depth
    one).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`a[2]` 的值是一个列表，它的元素可以被改变。我们使用的所有列表复制方法都是 *浅复制*（不是价值判断，而是深度判断）。
- en: 'To fix this, we need to use the `deepcopy()` function:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复这个问题，我们需要使用 `deepcopy()` 函数：
- en: '[PRE72]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`deepcopy()` can handle deeply nested lists, dictionaries, and other objects.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`deepcopy()` 可以处理深度嵌套的列表、字典和其他对象。'
- en: You’ll read more about `import` in [Chapter 9](ch09.html#ch_functions).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第 9 章](ch09.html#ch_functions)更多地了解 `import`。
- en: Compare Lists
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较列表
- en: 'You can directly compare lists with the comparison operators like `==`, `<`,
    and so on. The operators walk through both lists, comparing elements at the same
    offsets. If list `a` is shorter than list `b`, and all of its elements are equal,
    `a` is less than `b`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接使用比较运算符如 `==`、`<` 等来比较列表。这些运算符遍历两个列表，比较相同偏移量的元素。如果列表 `a` 比列表 `b` 短，并且所有元素都相等，则
    `a` 小于 `b`：
- en: '[PRE73]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Iterate with for and in
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 for 和 in 迭代
- en: 'In [Chapter 6](ch06.html#ch_for), you saw how to iterate over a string with
    `for`, but it’s much more common to iterate over lists:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 6 章](ch06.html#ch_for)中，你看到了如何使用 `for` 迭代字符串，但更常见的是迭代列表：
- en: '[PRE74]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As before, `break` ends the `for` loop and `continue` steps to the next iteration:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，`break` 结束 `for` 循环，`continue` 跳到下一个迭代：
- en: '[PRE75]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You can still use the optional `else` if the `for` completed without a `break`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `for` 循环完成而没有 `break`，你仍然可以使用可选的 `else`：
- en: '[PRE76]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If the initial `for` never ran, control goes to the `else` also:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始的 `for` 从未运行，则控制也转到 `else`：
- en: '[PRE77]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Because the `cheeses` list was empty in this example, `for cheese in cheeses`
    never completed a single loop and its `break` statement was never executed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在这个例子中 `cheeses` 列表为空，所以 `for cheese in cheeses` 从未完成过单个循环，它的 `break` 语句从未执行过。
- en: Iterate Multiple Sequences with zip()
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `zip()` 迭代多个序列
- en: 'There’s one more nice iteration trick: iterating over multiple sequences in
    parallel by using the `zip()` function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个很好的迭代技巧：通过使用 `zip()` 函数并行迭代多个序列：
- en: '[PRE78]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`zip()` stops when the shortest sequence is done. One of the lists (`desserts`)
    was longer than the others, so no one gets any pudding unless we extend the other
    lists.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()` 在最短的序列结束时停止。 其中一个列表（`desserts`）比其他列表长，因此除非我们扩展其他列表，否则没有人会得到任何布丁。'
- en: '[Chapter 8](ch08.html#ch_dicts) shows you how the `dict()` function can create
    dictionaries from two-item sequences like tuples, lists, or strings. You can use
    `zip()` to walk through multiple sequences and make tuples from items at the same
    offsets. Let’s make two tuples of corresponding English and French words:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 8 章](ch08.html#ch_dicts) 展示了 `dict()` 函数如何从包含两个元素的序列（如元组、列表或字符串）创建字典。你可以使用
    `zip()` 遍历多个序列，并从相同偏移量的项目创建元组。让我们创建两个对应的英文和法文单词的元组：'
- en: '[PRE79]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, use `zip()` to pair these tuples. The value returned by `zip()` is itself
    not a tuple or list, but an iterable value that can be turned into one:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `zip()` 将这些元组配对。`zip()` 返回的值本身不是元组或列表，而是一个可迭代的值，可以转换为元组：
- en: '[PRE80]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Feed the result of `zip()` directly to `dict()` and voilà: a tiny English-French
    dictionary!'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `zip()` 的结果直接提供给 `dict()`，完成：一个微小的英法词典！
- en: '[PRE81]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Create a List with a Comprehension
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用列表推导式创建列表
- en: You saw how to create a list with square brackets or the `list()` function.
    Here, we look at how to create a list with a *list comprehension*, which incorporates
    the `for`/`in` iteration that you just saw.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解如何使用方括号或 `list()` 函数创建列表。这里，我们将看看如何使用 *列表推导式* 创建列表，它包含了你刚刚看到的 `for`/`in`
    迭代。
- en: 'You could build a list of integers from `1` to `5`, one item at a time, like
    this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样逐个项地构建从 `1` 到 `5` 的整数列表：
- en: '[PRE82]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Or, you could also use an iterator and the `range()` function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用迭代器和 `range()` 函数：
- en: '[PRE83]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Or, you could just turn the output of `range()` into a list directly:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以直接将 `range()` 的输出转换为列表：
- en: '[PRE84]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'All of these approaches are valid Python code and will produce the same result.
    However, a more Pythonic (and often faster) way to build a list is by using a
    *list comprehension*. The simplest form of list comprehension looks like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都是有效的Python代码，并且会产生相同的结果。然而，更Pythonic（而且通常更快）的构建列表的方式是使用*列表推导式*。列表推导式的最简单形式看起来像这样：
- en: '[PRE85]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Here’s how a list comprehension would build the integer list:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个列表推导式如何构建整数列表：
- en: '[PRE86]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the first line, you need the first `number` variable to produce values for
    the list: that is, to put a result of the loop into `number_list`. The second
    `number` is part of the `for` loop. To show that the first `number` is an expression,
    try this variant:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，你需要第一个`number`变量为列表生成值：也就是说，将循环的结果放入`number_list`中。第二个`number`是循环的一部分。为了显示第一个`number`是一个表达式，请尝试这个变体：
- en: '[PRE87]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The list comprehension moves the loop inside the square brackets. This comprehension
    example really wasn’t simpler than the previous example, but there’s more that
    you can do. A list comprehension can include a conditional expression, looking
    something like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式将循环移到方括号内部。这个推导式示例并不比之前的示例更简单，但你可以做更多。列表推导式可以包含条件表达式，看起来像这样：
- en: '[PRE88]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Let’s make a new comprehension that builds a list of only the odd numbers between
    `1` and `5` (remember that `number % 2` is `True` for odd numbers and `False`
    for even numbers):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的推导式，构建一个仅包含`1`到`5`之间奇数的列表（记住`number % 2`对于奇数为`True`，对于偶数为`False`）：
- en: '[PRE89]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, the comprehension is a little more compact than its traditional counterpart:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，推导式比其传统的对应部分更紧凑了一点：
- en: '[PRE90]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Finally, just as there can be nested loops, there can be more than one set
    of `for ...` clauses in the corresponding comprehension. To show this, let’s first
    try a plain old nested loop and print the results:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像可以有嵌套循环一样，对应的推导式中还可以有超过一个`for ...`子句集。为了展示这一点，让我们首先尝试一个简单的嵌套循环并打印结果：
- en: '[PRE91]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, let’s use a comprehension and assign it to the variable `cells`, making
    it a list of `(row, col)` tuples:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用一个推导式，并将其分配给变量`cells`，使其成为一个`(row, col)`元组的列表：
- en: '[PRE92]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'By the way, you can also use *tuple unpacking* to get the `row` and `col` values
    from each tuple as you iterate over the `cells` list:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你也可以使用*元组解包*从每个元组中获取`row`和`col`值，当你迭代`cells`列表时：
- en: '[PRE93]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `for row ...` and `for col ...` fragments in the list comprehension could
    also have had their own `if` tests.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式中的`for row ...`和`for col ...`片段也可以有它们自己的`if`测试。
- en: Lists of Lists
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表的列表
- en: 'Lists can contain elements of different types, including other lists, as illustrated
    here:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以包含不同类型的元素，包括其他列表，如下所示：
- en: '[PRE94]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: So what does `all_birds`, a list of lists, look like?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，作为列表的列表的`all_birds`看起来是什么样子？
- en: '[PRE95]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Let’s look at the first item in it:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其中的第一个项目：
- en: '[PRE96]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The first item is a list: in fact, it’s `small_birds`, the first item we specified
    when creating `all_birds`. You should be able to guess what the second item is:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项是一个列表：实际上，它是我们创建`all_birds`时指定的`small_birds`的第一项。你应该能够猜到第二项是什么：
- en: '[PRE97]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'It’s the second item we specified, `extinct_birds`. If we want the first item
    of `extinct_birds`, we can extract it from `all_birds` by specifying two indexes:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 它是我们指定的第二项，`extinct_birds`。如果我们想要`extinct_birds`的第一项，我们可以通过指定两个索引从`all_birds`中提取它：
- en: '[PRE98]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `[1]` refers to the list that’s the second item in `all_birds`, and the
    `[0]` refers to the first item in that inner list.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`[1]`指的是`all_birds`中第二个项目的列表，而`[0]`指的是该内部列表中的第一个项目。'
- en: Tuples Versus Lists
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组与列表
- en: You can often use tuples in place of lists, but they have many fewer functions—there
    is no `append()`, `insert()`, and so on—because they can’t be modified after creation.
    Why not just use lists instead of tuples everywhere?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常可以在列表的地方使用元组，但它们的功能要少得多——没有`append()`、`insert()`等方法——因为它们创建后无法修改。为什么不在任何地方都使用列表呢？
- en: Tuples use less space.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组使用更少的空间。
- en: You can’t clobber tuple items by mistake.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会因为错误而破坏元组项。
- en: You can use tuples as dictionary keys (see [Chapter 8](ch08.html#ch_dicts)).
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用元组作为字典的键（参见[第8章](ch08.html#ch_dicts)）。
- en: '*Named tuples* (see [“Named Tuples”](ch10.html#named_tuples)) can be a simple
    alternative to objects.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命名元组*（参见[“命名元组”](ch10.html#named_tuples)）可以作为对象的简单替代。'
- en: I won’t go into much more detail about tuples here. In everyday programming,
    you’ll use lists and dictionaries more.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里详细讨论元组。在日常编程中，你将更多地使用列表和字典。
- en: There Are No Tuple Comprehensions
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有元组推导式
- en: Mutable types (lists, dictionaries, and sets) have comprehensions. Immutable
    types like strings and tuples need to be created with the other methods listed
    in their sections.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 可变类型（列表、字典和集合）有理解式。不可变类型如字符串和元组需要使用其各自章节中列出的其他方法创建。
- en: 'You might have thought that changing the square brackets of a list comprehension
    to parentheses would create a tuple comprehension. And it would appear to work
    because there’s no exception if you type this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能认为将列表推导的方括号更改为圆括号将创建元组推导。它似乎确实有效，因为如果您键入以下内容，将不会出现异常：
- en: '[PRE99]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The thing between the parentheses is something else entirely: a *generator
    comprehension*, and it returns a *generator object*:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的东西完全不同：*生成器推导*，它返回一个 *生成器对象*：
- en: '[PRE100]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: I’ll get into generators in more detail in [“Generators”](ch09.html#generators).
    A generator is one way to provide data to an iterator.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[“生成器”](ch09.html#generators)一章中详细讨论生成器。生成器是向迭代器提供数据的一种方式。
- en: Coming Up
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将到来
- en: 'They’re so swell, they get their own chapter: *dictionaries* and *sets*.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 它们如此出色，它们有自己的章节：*字典* 和 *集合*。
- en: Things to Do
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要做的事情
- en: Use lists and tuples with numbers ([Chapter 3](ch03.html#ch_numbers)) and strings
    ([Chapter 5](ch05.html#ch_strings)) to represent elements in the real world with
    great variety.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表和元组与数字（[第三章](ch03.html#ch_numbers)）和字符串（[第五章](ch05.html#ch_strings)）来表示具有丰富多样性的现实世界元素。
- en: 7.1 Create a list called `years_list`, starting with the year of your birth,
    and each year thereafter until the year of your fifth birthday. For example, if
    you were born in 1980, the list would be `years_list = [1980, 1981, 1982, 1983,
    1984, 1985]`. If you’re less than five years old and reading this book, I don’t
    know what to tell you.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 7.1 创建一个名为`years_list`的列表，从您的出生年份开始，直到您五岁生日的年份。例如，如果您出生于1980年，则列表将是`years_list
    = [1980, 1981, 1982, 1983, 1984, 1985]`。如果您不到五岁正在阅读本书，那我也不知道该怎么办。
- en: 7.2 In which year in `years_list` was your third birthday? Remember, you were
    0 years of age for your first year.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 7.2 `years_list`中哪一年是你三岁生日的那一年？记住，你的第一年是0岁。
- en: 7.3 In which year in `years_list` were you the oldest?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 7.3 `years_list`中哪一年你最大？
- en: '7.4 Make a list called `things` with these three strings as elements: `"mozzarella"`,
    `"cinderella"`, `"salmonella"`.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4 使用这三个字符串作为元素创建名为`things`的列表：`"mozzarella"`、`"cinderella"`、`"salmonella"`。
- en: 7.5 Capitalize the element in `things` that refers to a person and then print
    the list. Did it change the element in the list?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 7.5 将`things`中指向人的元素大写，然后打印列表。它改变了列表中的元素吗？
- en: 7.6 Make the cheesy element of `things` all uppercase and then print the list.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 7.6 将`things`中“cheesy”的元素全部大写，然后打印列表。
- en: 7.7 Delete the disease element from `things`, collect your Nobel Prize, and
    print the list.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 7.7 删除`things`中的"disease"元素，收集您的诺贝尔奖，并打印列表。
- en: 7.8 Create a list called `surprise` with the elements `"Groucho"`, `"Chico"`,
    and `"Harpo"`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 7.8 创建一个名为`surprise`的列表，其中包含元素`"Groucho"`、`"Chico"`和`"Harpo"`。
- en: 7.9 Lowercase the last element of the `surprise` list, reverse it, and then
    capitalize it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 7.9 将`surprise`列表的最后一个元素转为小写，反转它，然后大写化。
- en: 7.10 Use a list comprehension to make a list called `even` of the even numbers
    in `range(10)`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 7.10 使用列表推导创建一个名为`even`的列表，其中包含`range(10)`中的偶数。
- en: '7.11 Let’s create a jump rope rhyme maker. You’ll print a series of two-line
    rhymes. Start with this program fragment:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 7.11 让我们创建一个跳绳打油诗生成器。您将打印一系列两行打油诗。从以下程序片段开始：
- en: '[PRE101]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'For each tuple (`first`, `second`) in `rhymes`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`rhymes`中的每个元组（`first`，`second`）：
- en: 'For the first line:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一行：
- en: Print each string in `start1`, capitalized and followed by an exclamation point
    and a space.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印`start1`中的每个字符串，大写化，并跟一个感叹号和一个空格。
- en: Print `first`, also capitalized and followed by an exclamation point.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印`first`，并将其大写化，然后跟一个感叹号。
- en: 'For the second line:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二行：
- en: Print `start2` and a space.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印`start2`和一个空格。
- en: Print `second` and a period.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印`second`和一个句点。
