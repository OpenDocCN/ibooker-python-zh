- en: Chapter 22\. Py Sci
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In her reign the power of steam
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On land and sea became supreme,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And all now have strong reliance
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In fresh victories of science.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: James McIntyre, Queen’s Jubilee Ode 1887
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the past few years, largely because of the software you’ll see in this chapter,
    Python has become extremely popular with scientists. If you’re a scientist or
    student yourself, you might have used tools like MATLAB and R, or traditional
    languages such as Java, C, or C++. Now you’ll see how Python makes an excellent
    platform for scientific analysis and publishing.
  prefs: []
  type: TYPE_NORMAL
- en: Math and Statistics in the Standard Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let’s take a little trip back to the standard library and visit some
    features and modules that we’ve ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Math Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has a menagerie of math functions in the standard [math](https://oreil.ly/01SHP)
    library. Just type **`import math`** to access them from your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has a few constants such as `pi` and `e`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Most of it consists of functions, so let’s look at the most useful ones.
  prefs: []
  type: TYPE_NORMAL
- en: '`fabs()` returns the absolute value of its argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the integer below (`floor()`) and above (`ceil()`) some number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculate the factorial (in math, *n* `!`) by using `factorial()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the logarithm of the argument in base `e` with `log()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want a different base for the log, provide it as a second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `pow()` does the opposite, raising a number to a power:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Python also has the built-in exponentiation operator `**` to do the same, but
    it doesn’t automatically convert the result to a float if the base and power are
    both integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Get a square root with `sqrt()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t try to trick this function; it’s seen it all before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The usual trigonometric functions are all there, and I’ll just list their names
    here: `sin()`, `cos()`, `tan()`, `asin()`, `acos()`, `atan()`, and `atan2()`.
    If you remember the Pythagorean theorem (or can say it fast three times without
    spitting), the math library also has a `hypot()` function to calculate the hypotenuse
    from two sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t trust all these fancy functions, you can work it out yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A last set of functions converts angular coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Working with Complex Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Complex numbers are fully supported in the base Python language, with their
    familiar notation of *real* and *imaginary* parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the imaginary number `i` (`1j` in Python) is defined as the square
    root of –1, we can execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Some complex math functions are in the standard [`cmath`](https://oreil.ly/1EZQ0)
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Calculate Accurate Floating Point with decimal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Floating-point numbers in computers are not quite like the real numbers we
    learned in school:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Hey, what’s that `5` at the end? It should be `3` all the way down. This happens
    because there are only so many bits in computer CPU registers, and numbers that
    aren’t exact powers of two can’t be represented exactly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Python’s [`decimal`](https://oreil.ly/o-bmR) module, you can represent
    numbers to your desired level of significance. This is especially important for
    calculations involving money. US currency doesn’t go lower than a cent (a hundredth
    of a dollar), so if we’re calculating money amounts as dollars and cents, we want
    to be accurate to the penny. If we try to represent dollars and cents through
    floating-point values such as 19.99 and 0.06, we’ll lose some significance way
    down in the end bits before we even begin calculating with them. How do we handle
    this? Easy. We use the `decimal` module, instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We created the price and tax with string values to preserve their significance.
    The `total` calculation maintained all the significant fractions of a cent, but
    we want to get the nearest cent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You might get the same results with plain old floats and rounding, but not always.
    You could also multiply everything by 100 and use integer cents in your calculations,
    but that will bite you eventually, too.
  prefs: []
  type: TYPE_NORMAL
- en: Perform Rational Arithmetic with fractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can represent numbers as a numerator divided by a denominator through the
    standard Python [`fractions`](https://oreil.ly/l286g) module. Here is a simple
    operation multiplying one-third by two-thirds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Floating-point arguments can be inexact, so you can use `Decimal` within `Fraction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the greatest common divisor of two numbers with the `gcd` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Use Packed Sequences with array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Python list is more like a linked list than an array. If you want a one-dimensional
    sequence of the same type, use the [`array`](https://oreil.ly/VejPU) type. It
    uses less space than a list and supports many list methods. Create one with `array(`
    *`typecode`* , *`initializer`* `)`. The *typecode* specifies the data type (like
    `int` or `float`) and the optional *`initializer`* contains initial values, which
    you can specify as a list, string, or iterable.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve never used this package for real work. It’s a low-level data structure,
    useful for things such as image data. If you actually need an array—especially
    with more then one dimension—to do numeric calculations, you’re much better off
    with NumPy, which we discuss momentarily.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Simple Stats with statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beginning with Python 3.4, [`statistics`](https://oreil.ly/DELnM) is a standard
    module. It has the usual functions: mean, media, mode, standard deviation, variance,
    and so on. Input arguments are sequences (lists or tuples) or iterators of various
    numeric data types: int, float, decimal, and fraction. One function, `mode`, also
    accepts strings. Many more statistical functions are available in packages such
    as SciPy and Pandas, featured later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix Multiplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting with Python 3.5, you’ll see the `@` character doing something out of
    character. It will still be used for decorators, but it will also have a new use
    for [*matrix multiplication*](https://oreil.ly/fakoD). If you’re using an older
    version of Python, NumPy (coming right up) is your best bet.
  prefs: []
  type: TYPE_NORMAL
- en: Scientific Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rest of this chapter covers third-party Python packages for science and
    math. Although you can install them individually, you should consider downloading
    all of them at once as part of a scientific Python distribution. Here are your
    main choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Anaconda](https://www.anaconda.com)'
  prefs: []
  type: TYPE_NORMAL
- en: Free, extensive, up-to-the-minute, supports Python 2 and 3, and won’t clobber
    your existing system Python
  prefs: []
  type: TYPE_NORMAL
- en: '[Enthought Canopy](https://assets.enthought.com/downloads)'
  prefs: []
  type: TYPE_NORMAL
- en: Available in both free and commercial versions
  prefs: []
  type: TYPE_NORMAL
- en: '[Python(x,y)](https://python-xy.github.io)'
  prefs: []
  type: TYPE_NORMAL
- en: A Windows-only release
  prefs: []
  type: TYPE_NORMAL
- en: '[Pyzo](http://www.pyzo.org)'
  prefs: []
  type: TYPE_NORMAL
- en: Based on some tools from Anaconda, plus a few others
  prefs: []
  type: TYPE_NORMAL
- en: I recommend installing Anaconda. It’s big, but everything in this chapter is
    in there. The examples in the rest of this chapter will assume that you’ve installed
    the required packages, either individually or as part of Anaconda.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[NumPy](http://www.numpy.org) is one of the main reasons for Python’s popularity
    among scientists. You’ve heard that dynamic languages such as Python are often
    slower than compiled languages like C, or even other interpreted languages such
    as Java. NumPy was written to provide fast multidimensional numeric arrays, similar
    to scientific languages like FORTRAN. You get the speed of C with the developer-friendly
    nature of Python.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve downloaded one of the scientific Python distributions, you already
    have NumPy. If not, follow the instructions on the NumPy [download page](https://oreil.ly/HcZZi).
  prefs: []
  type: TYPE_NORMAL
- en: To begin with NumPy, you should understand a core data structure, a multidimensional
    array called an `ndarray` (for *N-dimensional array*) or just an `array`. Unlike
    Python’s lists and tuples, each element needs to be of the same type. NumPy refers
    to an array’s number of dimensions as its *rank*. A one-dimensional array is like
    a row of values, a two-dimensional array is like a table of rows and columns,
    and a three-dimensional array is like a Rubik’s Cube. The lengths of the dimensions
    need not be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The NumPy `array` and the standard Python `array` are not the same thing. For
    the rest of this chapter, when I say *array*, I’m referring to a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: But why do you need an array?
  prefs: []
  type: TYPE_NORMAL
- en: Scientific data often consists of large sequences of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scientific calculations on this data often use matrix math, regression, simulation,
    and other techniques that process many data points at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy handles arrays *much* faster than standard Python lists or tuples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many ways to make a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: Make an Array with array()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can make an array from a normal list or tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The attribute `ndim` returns the rank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The total number of values in the array are given by `size`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of values in each rank are returned by `shape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Make an Array with arange()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NumPy’s `arange()` method is similar to Python’s standard `range()`. If you
    call `arange()` with a single integer argument `num`, it returns an `ndarray`
    from `0` to `num-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With two values, it creates an array from the first to the last, minus one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can provide a step size to use instead of one as a third argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, our examples have used integers, but floats work just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And one last trick: the `dtype` argument tells `arange` what type of values
    to produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Make an Array with zeros(), ones(), or random()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `zeros()` method returns an array in which all the values are zero. The
    argument you provide is a tuple with the shape that you want. Here’s a one-dimensional
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This one is of rank two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The other special function that fills an array with the same value is `ones()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'One last initializer creates an array with random values between 0.0 and 1.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Change an Array’s Shape with reshape()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, an array doesn’t seem that different from a list or tuple. One difference
    is that you can get it to do tricks such as change its shape by using `reshape()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can reshape the same array in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning a shapely tuple to `shape` does the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The only restriction on a shape is that the product of the rank sizes needs
    to equal the total number of values (in this case, 10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Get an Element with []
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A one-dimensional array works like a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the array has a different shape, use comma-separated indices within
    the square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s different from a two-dimensional Python list, which has its indexes
    in separate square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'One last thing: slices work, but again, only within one set of square brackets.
    Let’s make our familiar test array again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a slice to get the first row, elements from offset `2` to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, get the last row, elements up to the third from the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also assign a value to more than one element with a slice. The following
    statement assigns the value `1000` to columns (offsets) `2` and `3` of all rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Array Math
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Making and reshaping arrays was so much fun that we almost forgot to actually
    *do* something with them. For our first trick, we use NumPy’s redefined multiplication
    (`*`) operator to multiply all the values in a NumPy array at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you tried to multiply each element in a normal Python list by a number,
    you’d need a loop or a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This all-at-once behavior also applies to addition, subtraction, division,
    and other functions in the NumPy library. For example, you can initialize all
    members of an array to any value by using `zeros()` and `+`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Linear Algebra
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NumPy includes many functions for linear algebra. For example, let’s define
    this system of linear equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we solve for `x` and `y`? We build two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: The *coefficients* (multipliers for `x` and `y`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *dependent* variables (right side of the equation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use the `solve()` function in the `linalg` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The result says that `x` is about –8.3 and `y` is about 10.6. Did these numbers
    solve the equation?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'How about that. To avoid all that typing, you can also ask NumPy to get the
    *dot product* of the arrays for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The values in the `product` array should be close to the values in `dependents`
    if this solution is correct. You can use the `allclose()` function to check whether
    the arrays are approximately equal (they might not be exactly equal because of
    floating-point rounding):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: NumPy also has modules for polynomials, Fourier transforms, statistics, and
    some probability distributions.
  prefs: []
  type: TYPE_NORMAL
- en: SciPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There’s even more in a library of mathematical and statistical functions built
    on top of NumPy: [SciPy](http://www.scipy.org). The SciPy [release](https://oreil.ly/Yv7G-)
    includes NumPy, SciPy, Pandas (coming later in this chapter), and other libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SciPy includes many modules, including some for the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear regression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’ve worked with other scientific computing tools, you’ll find that Python,
    NumPy, and SciPy cover some of the same ground as the commercial [MATLAB](https://oreil.ly/jOPMO)
    or open source [R](http://www.r-project.org).
  prefs: []
  type: TYPE_NORMAL
- en: SciKit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the same pattern of building on earlier software, [SciKit](https://scikits.appspot.com)
    is a group of scientific packages built on SciPy. [SciKit-Learn](https://scikit-learn.org)
    is a prominent *machine learning* package: it supports modeling, classification,
    clustering, and various algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: Pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recently, the phrase *data science* has become common. Some definitions that
    I’ve seen include “statistics done on a Mac,” or “statistics done in San Francisco.”
    However you define it, the tools we’ve talked about in this chapter—NumPy, SciPy,
    and the subject of this section, Pandas—are components of a growing popular data-science
    toolkit. (Mac and San Francisco are optional.)
  prefs: []
  type: TYPE_NORMAL
- en: '[Pandas](http://pandas.pydata.org) is a new package for interactive data analysis.
    It’s especially useful for real-world data manipulation, combining the matrix
    math of NumPy with the processing ability of spreadsheets and relational databases.
    The book [*Python for Data Analysis: Data Wrangling with Pandas, NumPy, and IPython*](http://bit.ly/python_for_data_analysis)
    by Wes McKinney (O’Reilly) covers data wrangling with NumPy, IPython, and Pandas.'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy is oriented toward traditional scientific computing, which tends to manipulate
    multidimensional data sets of a single type, usually floating point. Pandas is
    more like a database editor, handling multiple data types in groups. In some languages,
    such groups are called *records* or *structures*. Pandas defines a base data structure
    called a `DataFrame`. This is an ordered collection of columns with names and
    types. It has some resemblance to a database table, a Python named tuple, and
    a Python nested dictionary. Its purpose is to simplify the handling of the kind
    of data you’re likely to encounter not just in science, but also in business.
    In fact, Pandas was originally designed to manipulate financial data, for which
    the most common alternative is a spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: Pandas is an ETL tool for real-world, messy data—missing values, oddball formats,
    scattered measurements—of all data types. You can split, join, extend, fill in,
    convert, reshape, slice, and load and save files. It integrates with the tools
    we’ve just discussed—NumPy, SciPy, iPython—to calculate statistics, fit data to
    models, draw plots, publish, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Most scientists just want to get their work done, without spending months to
    become experts in esoteric computer languages or applications. With Python, they
    can become productive more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Python and Scientific Areas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve been looking at Python tools that could be used in almost any area of
    science. What about software and documentation targeted to specific scientific
    domains? Here’s a small sample of Python’s use for specific problems, and some
    special-purpose libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: General
  prefs: []
  type: TYPE_NORMAL
- en: '[Python computations in science and engineering](http://bit.ly/py-comp-sci)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A crash course in Python for scientists](http://bit.ly/pyforsci)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics
  prefs: []
  type: TYPE_NORMAL
- en: '[Computational physics](http://bit.ly/comp-phys-py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Astropy](https://www.astropy.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SunPy](https://sunpy.org) (solar data analysis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MetPy](https://unidata.github.io/MetPy) (meteorological data analysis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Py-ART](https://arm-doe.github.io/pyart) (weather radar)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Community Intercomparison Suite](http://www.cistools.net) (atmospheric sciences)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Freud](https://freud.readthedocs.io) (trajectory analysis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Platon](https://platon.readthedocs.io) (exoplanet atmospheres)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PSI4](http://psicode.org) (quantum chemistry)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenQuake Engine](https://github.com/gem/oq-engine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[yt](https://yt-project.org) (volumetric data analysis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Biology and medicine
  prefs: []
  type: TYPE_NORMAL
- en: '[Biopython](https://biopython.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python for biologists](http://pythonforbiologists.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introduction to Applied Bioinformatics](http://readiab.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Neuroimaging in Python](http://nipy.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MNE](https://www.martinos.org/mne) (neurophysiological data visualization)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PyMedPhys](https://pymedphys.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Nengo](https://www.nengo.ai) (neural simulator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'International conferences on Python and scientific data include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PyData](http://pydata.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SciPy](http://conference.scipy.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[EuroSciPy](https://www.euroscipy.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve reached the end of our observable Python universe, except for the multiverse
    appendices.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 22.1 Install Pandas. Get the CSV file in [Example 16-1](ch16.html#villains_csv).
    Run the program in [Example 16-2](ch16.html#pandas_csv_example). Experiment with
    some of the Pandas commands.
  prefs: []
  type: TYPE_NORMAL
