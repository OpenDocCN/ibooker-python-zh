# 第一章。介绍 Asyncio

> 我的故事和你的很相似，只是更有趣，因为它涉及到了机器人。
> 
> Bender，《飞出个未来》第三季第十集“30% 铁匠”

Python 3 中关于 Asyncio 的最常见问题是：“它是什么，我该怎么用？”你最常听到的答案可能是关于能够在单个程序中执行多个并发的 HTTP 请求。但事实上它不仅仅是这样—远不止如此。Asyncio 要求改变你思考程序结构的方式。

以下故事提供了获得这种理解的背景。Asyncio 的核心焦点是如何最好地同时执行多个任务—不仅仅是任何任务，而是特别涉及等待周期的任务。这种编程风格所需的关键见解是，当你等待 *这个* 任务完成时，可以执行 *其他* 任务。

# ThreadBots 餐厅

现在是 2051 年，你发现自己在餐饮业务中。大部分经济都是由机器人工人主导的自动化推动的，但事实证明，人类偶尔还是喜欢出去吃饭。在你的餐厅里，所有的员工都是机器人—当然是 humanoid 的，但毫无疑问是机器人。最成功的机器人制造商是 Threading Inc.，这家公司的机器人工人被称为“ThreadBots”。

除了这个小小的机器人细节，你的餐厅看起来和运作起来就像是从 2020 年左右的那些古老的餐厅一样。你的客人会寻找那种老式的体验。他们想要新鲜的食物，从头开始准备。他们想要坐在桌子旁。他们愿意等待他们的餐点——但只是一点点。他们想要在最后付款，有时甚至想要留小费，怀旧一下。

作为机器人餐厅业务的新手，你像其他所有餐饮业者一样，雇佣了一小群机器人：一个在前台迎接客人（GreetBot），一个招待客人和接受订单（WaitBot），一个负责烹饪（ChefBot），一个管理酒吧（WineBot）。

饥饿的客人来到前台，被前台 ThreadBot 的 GreetBot 欢迎。然后他们被引导到一张桌子旁坐下，一旦坐定，WaitBot 接受他们的订单。然后 WaitBot 将订单用一张纸条带到厨房（因为你想保留那种古老的体验，记得吗？）。ChefBot 看着纸条上的订单开始准备食物。WaitBot 将定期检查食物是否准备好，一旦准备好，将立即把菜品送到客人的桌子上。当客人准备离开时，他们回到 GreetBot 那里，GreetBot 计算账单，收取款项，并亲切地祝他们晚上愉快。

你的餐厅很受欢迎，很快就有了大量的客户群。你的机器人员工完全按照你的要求做事，他们在分配给他们的任务上非常出色。一切都进展得很顺利，你再开心不过了。

随着时间的推移，您开始注意到一些问题。哦，这并不是真的很严重；只是有些事情似乎出了些问题。每个其他机器人餐厅老板似乎都遇到类似的小故障。让人有点担心的是，这些问题似乎随着您的成功而变得更糟。

尽管罕见，偶尔会发生非常令人不安的碰撞：有时候，食物盘在厨房准备好之前，WaitBot 甚至在 ChefBot 放开盘子之前就抓住了它。这通常导致盘子碎裂，留下一团糟。当然，ChefBot 会清理干净，但仍然，您会认为这些一流的机器人应该知道如何更加协调一些。这也会发生在酒吧：有时候 WineBot 会在酒吧上放置一个饮料订单，WaitBot 在 WineBot 松手之前就抓住了它，导致玻璃碎裂和 Nederburg Cabernet Sauvignon 洒落一地。

此外，有时候 GreetBot 会在 WaitBot 决定清理它认为是空桌子的同时正好安排新的用餐者。这对用餐者来说相当尴尬。您尝试为 WaitBot 的清洁功能添加延迟逻辑，或者为 GreetBot 的入座功能添加延迟，但这些并没有真正帮助，碰撞仍然发生。不过至少这些事件很少见。

事实上，它们曾经是。您的餐厅变得如此受欢迎，以至于您不得不雇用更多的 ThreadBots。在非常忙碌的星期五和星期六晚上，您不得不再增加一个 GreetBot 和两个额外的 WaitBot。不幸的是，ThreadBots 的雇佣合同意味着您必须全周都雇佣它们，这实际上意味着在大部分安静的周日，您会多余三个您实际上不需要的 ThreadBots。

除了额外的成本，另一个资源问题是，您需要处理这些额外的 ThreadBots 会增加您的工作量。跟踪只有四个机器人的情况是可以的，但现在您增加到了七个。跟踪七个 ThreadBots 会增加很多工作量，并且因为您的餐厅越来越有名，您开始担心再雇佣更多 ThreadBots。要花费全职工作时间来追踪每个 ThreadBot 在做什么。还有一件事：这些额外的 ThreadBots 正在占用您餐厅内的大量空间。随着这些机器人在四处快速移动，顾客们开始感到挤。您担心如果需要再增加更多机器人，空间问题会变得更加严重。您想要将餐厅的空间留给顾客，而不是 ThreadBots。

自从你增加了更多的 ThreadBots 之后，碰撞问题也变得更加严重。现在，有时两个 WaitBot 会同时从同一张桌子上接受完全相同的订单。就好像它们都注意到桌子准备好点菜了，然后同时前去接单，却没有注意到另一个 WaitBot 也在做同样的事情。可以想象，这会导致重复的食品订单，增加厨房的负担，并在取走准备好的盘子时增加碰撞的机会。你担心如果再增加更多 WaitBots，这个问题可能会变得更糟。

时间流逝。

然后，在一个非常非常繁忙的星期五晚上的服务中，你有了一个独特的清晰时刻：时间仿佛放慢了，清晰感淹没了你，你看到你的餐厅在时间中被冻结的一个快照。“我的 ThreadBots 什么也没做！” 事实上，并不是什么都没做，公平地说，但它们只是在等待。

你的三个 WaitBot 各在不同的桌子旁等待他们的一位顾客点餐。WineBot 已经准备了 17 杯饮料，现在它们等待被取走（只花了几秒钟），并等待新的饮料订单。一个 GreetBot 已经迎接了一组新的客人，并告诉他们需要等一分钟才能入座，现在它在等待客人的回应。另一个 GreetBot 正在处理一位即将离开的客人的信用卡支付，它在等待支付网关设备的确认。即使是 ChefBot，它现在正在烹饪 35 道菜，但在这个时刻实际上什么也没做，只是在等待其中一道菜完成烹饪，以便能够装盘并交给 WaitBot。

你意识到，尽管你的餐厅现在到处都是 ThreadBots，甚至考虑再增加更多（带来所有相关问题），但你现在拥有的 ThreadBots 并没有得到充分利用。

时间流逝，但认知不会消失。在星期天，你为你的 ThreadBots 添加了一个数据收集模块。对于每个 ThreadBot，你都在测量等待时间和实际工作时间的比例。在接下来的一周里，数据被收集起来。然后在星期天晚上，你开始分析结果。结果显示，即使你的餐厅客流量达到最大值，最勤奋的 ThreadBot 也有约 98%的时间处于空闲状态。这些 ThreadBots 效率极高，能在几秒钟内完成任何任务。

作为一名企业家，这种低效真的让你很烦恼。你知道，每个其他的机器人餐厅所有者都和你一样经营着他们的生意，面对着许多相同的问题。但是，你想着，砰地一声捶了一下桌子，“一定有更好的方法！”

因此，接下来的一天，也就是安静的星期一，你尝试了一些大胆的事情：你编程一个单个 ThreadBot 来完成所有任务。每当它开始等待，即使只有一秒钟，ThreadBot 也会切换到餐厅中下一个要做的任务，无论是什么。听起来不可思议——只有一个 ThreadBot 完成所有其他人的工作——但你对自己的计算有信心。而且，星期一是一个安静的日子；即使出现问题，影响也将很小。对于这个新项目，你称其为“LoopBot”，因为它将循环执行餐厅中的所有工作。

编程比平常更加困难。问题不仅在于你必须为一个 ThreadBot 编程完成所有不同的任务；你还必须编写一些逻辑，告诉它何时切换任务。但到了这个阶段，你已经有了很多 ThreadBot 编程的经验，所以你设法完成了。

你像鹰一样盯着你的**LoopBot**。它在几秒钟内在各个站点之间移动，检查是否有工作要做。开业不久后，第一位客人到达前台。LoopBot 几乎立即出现，并询问客人是否想要靠近窗户或靠近酒吧的桌子。但是，随着 LoopBot 开始等待，它的编程告诉它切换到下一个任务，然后它飞奔而去。这似乎是一个可怕的错误，但随后你看到，当客人开始说“请靠窗户”的时候，LoopBot 又回来了。它接收到答案并引导客人到 42 号桌。然后它再次忙碌起来，一遍又一遍地检查饮料订单、食物订单、桌子清理以及到达的客人。

晚些时候的星期一晚上，你为自己取得了显著的成功而感到自豪。你检查了**LoopBot**上的数据收集模块，它证实即使只有一个 ThreadBot 完成七个人的工作，空闲时间仍然达到了 97%。这个结果让你有信心继续进行整个星期的实验。

随着繁忙的星期五服务的临近，你回顾了你的实验取得的巨大成功。在正常工作周的服务中，你可以轻松地管理只有一个 LoopBot 的工作负载。你还注意到了另一件事：再也没有看到碰撞了。这很合理；因为只有一个 LoopBot，它不会和自己混淆。不再有重复订单进入厨房，也不再困惑何时拿盘子或饮料了。

周五晚上的服务开始了，正如你所希望的那样，单个**ThreadBot**可以跟上所有顾客和任务，服务甚至比以前进行得更顺利。你可以想象现在可以接待更多顾客，而不必担心需要增加更多 ThreadBot。你想到了你将要省下的所有钱。

不幸的是，事情出了问题：其中一份餐点，一道复杂的舒芙蕾，失败了。在你的餐厅从未发生过这种情况。你开始更仔细地研究 LoopBot。原来，在你的一张桌子上，有一位非常健谈的客人。这位客人独自来到你的餐厅，并不时试图与 LoopBot 交谈，甚至有时拉着你的 LoopBot 的手。每当这种情况发生时，你的 LoopBot 无法快速跑开去处理餐厅其他地方不断增长的任务列表。这就是为什么厨房第一次做出失败的舒芙蕾：你的 LoopBot 被客人耽搁了。

周五的服务结束了，你回家反思所学到的东西。LoopBot 确实能够在繁忙的周五服务中完成所有必要的工作；但另一方面，你的厨房却做出了它从未发生过的第一份糟糕的餐点。健谈的客人过去一直让 WaitBots 忙碌，但这从未对厨房服务产生影响。

综上所述，你决定继续使用单个 LoopBot 仍然是更好的选择。那些令人担忧的冲突不再发生，而且你的餐厅里有更多的空间——可以为更多的客人使用。但是你意识到关于 LoopBot 的一些深刻的东西：只有每个任务都很短暂，或者至少可以在短时间内完成，它才能有效。如果任何活动让 LoopBot 忙碌了太久，其他任务将开始受到忽视。

预先知道哪些任务可能花费太多时间是困难的。如果客人点了一种需要精细制作的鸡尾酒，比通常需要更多时间呢？如果客人想在前台投诉餐点，拒绝付款，并抓住 LoopBot 的手臂，阻止其进行任务切换呢？你决定，与其提前弄清所有这些问题，不如继续使用 LoopBot，尽可能记录更多信息，并在问题出现时及时处理。

时间过去了更多。

渐渐地，其他餐厅老板们注意到了你的运作方式，最终他们也发现他们也可以仅靠一个 ThreadBot 就能够生存甚至繁荣。消息传播开来。很快，每家餐厅都以这种方式运作，让人几乎难以记得，机器人餐厅曾经使用多个 ThreadBot。

# 结语

在我们的故事中，餐厅里的每个机器人工作员工都是一个单独的线程。故事的关键观察是，餐厅工作的性质涉及大量的等待，就像`requests.get()`在等待服务器响应一样。

在餐厅中，工人等待的时间并不是很长，当慢人在做手工工作时，但当超高效和快速的机器人在工作时，几乎所有的时间都花在等待上。在计算机编程中，当涉及网络编程时也是如此。CPU 进行工作并等待网络 I/O。现代计算机中的 CPU 速度非常快——比网络流量快几十万倍。因此，运行网络程序的 CPU 花费了大量的时间在等待上。

故事中的洞察力在于可以编写程序来明确地指示 CPU 根据需要在工作任务之间移动。虽然在经济上有所改善（使用较少的 CPU 完成相同的工作），但与线程（多 CPU）方法相比的真正优势在于消除了竞态条件。

然而，并非一切都是完美的：正如我们在故事中发现的那样，大多数技术解决方案都有利有弊。引入 LoopBot 解决了某一类问题，但也引入了新问题——其中最重要的问题之一是餐厅老板必须学会一种略有不同的编程方式。

# Asyncio 试图解决什么问题？

对于 I/O 密集型工作负载，只有（仅仅！）两个原因可以使用基于异步的并发而不是基于线程的并发：

+   Asyncio 提供了一种更安全的替代方案，用于抢占式多任务（即使用线程），从而避免了在非平凡的线程应用程序中经常发生的错误、竞态条件和其他非确定性危险。

+   Asyncio 提供了一种简单的方式来支持成千上万个*同时的*套接字连接，包括能够处理许多长期存在的连接，用于较新的技术，如 WebSockets，或用于物联网（IoT）应用的 MQTT。

就是这样。

作为一种编程模型，线程最适合于某些最佳使用多个 CPU 和共享内存进行线程之间高效通信的计算任务。在这种任务中，使用具有共享内存的多核处理是一种必要的恶因为问题领域要求这样做。

网络编程*不*是那些领域之一。关键的洞察力在于网络编程涉及大量的“等待事情发生”，正因为如此，我们不需要操作系统有效地在多个 CPU 上分发我们的任务。此外，我们也不需要抢占式多任务带来的风险，比如在使用共享内存时出现竞态条件。

然而，关于基于事件的编程模型的其他所谓好处有许多错误信息。以下是一些并非事实的事情：

*Asyncio 将使我的代码运行速度飞快*。

不幸的是，不是这样。事实上，大多数基准测试似乎显示，线程解决方案比其相应的 Asyncio 解决方案稍快。如果将并发程度本身视为性能指标，Asyncio 确实使得创建非常大量的并发套接字连接变得更加容易。操作系统通常对可以创建的线程数量有限制，这个数量显著低于可以建立的套接字连接数量。操作系统的限制可以更改，但使用 Asyncio 则更容易实现。而且虽然我们期望拥有许多数千个线程应该会产生额外的*上下文切换*成本，但事实证明在实践中很难对此进行基准测试。¹ 不，速度不是 Python 中 Asyncio 的好处；如果你追求的是这个，那么试试*Cython*吧！

*Asyncio 使得线程变得多余*。

绝对不是！线程的真正价值在于能够编写多 CPU 程序，其中不同的计算任务可以共享内存。例如，数值库`numpy`已经利用这一点，通过使用多个 CPU 加速某些矩阵计算，即使所有内存都是共享的。就性能而言，对于 CPU 密集型计算，这种编程模型无与伦比。

*Asyncio 消除了 GIL 带来的问题*。

再次强调，不是这样。确实，Asyncio 不受 GIL 的影响，² 但这仅因为 GIL 影响多线程程序。人们所指的 GIL“问题”之所以发生，是因为它在使用线程时阻止了真正的多核并行性。由于 Asyncio 几乎是单线程的（几乎可以说是这样），它不受 GIL 的影响，但也不能从多 CPU 核心中受益。³ 还值得指出的是，在多线程代码中，Python 的 GIL 可能会引起其他性能问题，超出了在其他点已经提到的范围：Dave Beazley 在 PyCon 2010 上做了一次关于此的演讲，标题为[“理解 Python GIL”](https://oreil.ly/n_D3N)，其中讨论的大部分内容今天仍然适用。

*Asyncio 可以防止所有竞态条件*。

错误。竞争条件的可能性始终存在于任何并发编程中，无论是使用线程还是基于事件的编程。确实，Asyncio 可以几乎消除某些多线程程序中常见的竞争条件类别，例如进程内共享内存访问。然而，它并没有消除其他类型的竞争条件的可能性，例如在分布式微服务架构中常见的共享资源之间的进程间竞争。您仍然需要注意共享资源的使用方式。与线程化代码相比，Asyncio 的主要优势在于协程之间的执行控制点是*可见的*（因为存在`await`关键字），因此更容易推理共享资源的访问方式。

*Asyncio makes concurrent programming easy*.

哎呀，我该从哪里开始呢？

最后一个神话是最危险的一个。处理并发总是*非常*复杂的，无论您是使用线程还是 Asyncio。当专家们说“Asyncio 使并发编程更容易”时，他们真正的意思是，Asyncio 使得避免某些真正令人噩梦般的竞争条件 bug 更加容易——那种让您彻夜难眠的 bug，在篝火旁，狼嚎声中，您会轻声告诉其他程序员。

即使使用 Asyncio，仍然存在大量复杂性需要处理。您的应用程序将如何支持健康检查？您如何与只允许少数连接的数据库进行通信——比您的五千个客户端套接字连接少得多？当接收到关闭信号时，您的程序如何优雅地终止连接？您将如何处理（阻塞！）磁盘访问和日志记录？这些只是您必须回答的许多复杂设计决策中的一小部分。

当然，应用程序设计依然很困难，但希望在处理仅有一个线程时，您会在推理应用逻辑方面更加轻松。

¹ 在这个领域的研究似乎难以找到，但数字看起来大约是在现代硬件上 Linux 上每个线程上下文切换约为 50 微秒。大致来说：一千个线程意味着总成本为 50 毫秒，仅仅用于上下文切换。虽然这些会累积，但它不会毁掉您的应用程序。

² *全局解释器锁*（GIL）通过锁定每个操作码的处理来保证 Python 解释器代码（而不是*您的*代码！）的线程安全性；它不幸地产生了将解释器执行有效地限制在单个 CPU 上的副作用，并因此阻止了多核并行处理。

³ 这与 JavaScript 为何缺乏 GIL “问题”类似：因为它只有一个线程。
