<html><head></head><body>
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 21. Testing Strategy" class="preface"><div class="preface" id="testing_strategy">
<h1 class="calibre10" id="calibre_pb_0"><span class="calibre">Chapter 21. </span>Testing Strategy</h1>


<p class="author1">Tests are one of most important safety nets <a data-type="indexterm" data-primary="testing" id="ix_tstst" class="calibre5"/>you can build around your codebase. It is incredibly comforting to make a change and see that all tests pass afterwards. However, it is challenging to gauge the best use of your time regarding testing. Too many tests and they become a burden; you spend more time maintaining tests than delivering features. Too few tests and you are letting potential catastrophes make it into <span class="calibre">production</span>.</p>

<p class="author1">In this chapter, I will ask you to focus on your testing strategy. I’ll break down the different types of tests and how to choose which tests to write. I’ll focus on Python best practices around test construction, and then I’ll end with some common testing strategies specific to Python.</p>






</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 21. Testing Strategy" class="preface">
<div class="preface" id="testing_strategy">
<section data-type="sect1" data-pdf-bookmark="Defining Your Test Strategy" class="preface"><div class="preface" id="idm45644727468456">
<h1 class="calibre12" id="calibre_pb_1">Defining Your Test Strategy</h1>

<p class="author1">Before you write tests, you should decide what your <em class="calibre6">test strategy</em> will be.<a data-type="indexterm" data-primary="testing" data-secondary="defining your test strategy" id="ix_tststdef" class="calibre5"/> A test strategy is a plan for spending time and effort to test your software in order to mitigate risk. This strategy will influence what types of tests you write, how you write them, and how much time you spend writing (and maintaining) them. Everybody’s test strategy will be different, but they will all be in a similar form: a list of questions about your system and how you plan on answering them. For example, if I were writing a calorie-counting app, here would be a part of my test strategy:</p>

<pre data-type="programlisting" class="calibre35">Does my system function as expected?
Tests to write (automated - run daily):
    Acceptance tests: Adding calories to the daily count
    Acceptance tests: Resetting calories on daily boundaries
    Acceptance tests: Aggregating calories over a time period
    Unit tests: Corner Cases
    Unit tests: Happy Path

Will this application be usable by a large user base?
Tests to write (automated - run weekly):
    Interoperability tests: Phones (Apple, Android, etc.)
    Interoperability tests: Tablets
    Interoperability tests: Smart Fridge

Is it hard to use maliciously?
Tests to write: (ongoing audit by security engineer)
    Security tests: Device Interactions
    Security tests: Network Interactions
    Security tests: Backend Vulnerability Scanning (automated)

... etc. ...</pre>
<div data-type="tip" class="calibre21"><h6 class="calibre22">Tip</h6>
<p class="author1">Do not treat your test strategy as a static document that is created once and never modified. As you develop your software, continue to ask questions as they come to mind, and discuss whether your strategy needs to evolve as you learn more.</p>
</div>

<p class="author1">This test strategy will govern where you put your focus for writing tests. As you start to fill it out, the first thing you need to do is understand what a test is and why you write them.</p>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 21. Testing Strategy" class="preface">
<div class="preface" id="testing_strategy">
<section data-type="sect1" data-pdf-bookmark="Defining Your Test Strategy" class="preface">
<div class="preface" id="idm45644727468456">
<section data-type="sect2" data-pdf-bookmark="What Is a Test?" class="preface"><div class="preface" id="idm45644727461016">
<h2 class="calibre34" id="calibre_pb_2">What Is a Test?</h2>

<p class="author1">You should understand the <em class="calibre6">what</em> and the <em class="calibre6">why</em> you are writing the software. Answering these questions will frame your goals for writing tests.<a data-type="indexterm" data-primary="testing" data-secondary="defining your test strategy" data-tertiary="understanding tests" id="idm45644727458088" class="calibre5"/><a data-type="indexterm" data-primary="tests" id="ix_testsund" class="calibre5"/> Tests serve as a way of verifying <em class="calibre6">what</em> the code is doing, and you write tests so that you don’t negatively impact the <em class="calibre6">why</em>. <a data-type="indexterm" data-primary="what and why (for software)" id="idm45644727455000" class="calibre5"/>Software produces value. That’s it. Every piece of software has some value attached to it. Web apps provide important services for the general population. Data science pipelines may create prediction models that help us better understand the patterns in our world. Even malicious software has value; the people who are performing the exploit are using the software to achieve a goal (even if there is negative value to anyone affected).</p>

<p class="author1">That’s <em class="calibre6">what</em> software provides, but <em class="calibre6">why</em> does anyone write software? Most people answer “money,” and I don’t want to knock that, but there are other reasons too. Sometimes software is written for money, sometimes it’s written for self-fulfilment, and sometimes it’s written for advertising (such as contributing to an open source project to bolster a resume). Tests serve as validation for these systems. They go so much deeper than just catching errors or giving you confidence in shipping a <span class="calibre">product</span>.</p>

<p class="author1">If I’m writing some code for learning purposes, my <em class="calibre6">why</em> is purely for self-fulfilment, and the value is derived from how much I learn. If I do things wrong, that is still a learning opportunity; I can get by if all my tests are just manual spot checks at the end of the project. However, a company that markets tools to other developers might have a completely different strategy. Developers at that company may choose to write tests to make sure they are not regressing any functionality so that the company does not lose customers (which would translate to a loss of profit). Each of these projects needs a different level of testing.</p>

<p class="author1">So, what is a test? Is it something that catches errors? Is it something that gives you confidence to ship your product? Yes, but the true answer goes a little deeper. Tests answer questions about your system. I want you to think about the software you write. What is its purpose? What do you want to always know about the things you build? The things that are important to you form your test strategy.</p>

<p class="author1">When you ask yourself questions, you really are asking yourself what tests you find valuable:</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">Will my application handle a predicted load?</p>
</li>
<li class="calibre9">
<p class="author1">Does my code meet the customer’s needs?</p>
</li>
<li class="calibre9">
<p class="author1">Is my application secure?</p>
</li>
<li class="calibre9">
<p class="author1">What happens when a customer inputs bad data into my system?</p>
</li>
</ul>

<p class="author1">Each one of these questions points to a different type of test that you might need to write. Check out <a data-type="xref" href="part0027_split_002.html#testing_questions" class="calibre5">Table 21-1</a> for a list of common questions and the appropriate tests that answer those questions.<a data-type="indexterm" data-primary="unit tests" id="idm45644727442856" class="calibre5"/><a data-type="indexterm" data-primary="integration tests" id="idm45644727442184" class="calibre5"/><a data-type="indexterm" data-primary="acceptance tests" data-secondary="questions they answer" id="idm45644727441512" class="calibre5"/><a data-type="indexterm" data-primary="load tests, questions they answer" id="idm45644727440568" class="calibre5"/><a data-type="indexterm" data-primary="security" data-secondary="security tests, questions answered by" id="idm45644727439832" class="calibre5"/><a data-type="indexterm" data-primary="usability testing" id="idm45644727438872" class="calibre5"/></p>
<table id="testing_questions" class="calibre45">
<caption class="calibre46"><span class="calibre">Table 21-1. </span>Types of tests and the questions they answer</caption>
<thead class="calibre47">
<tr class="calibre48">
<th class="calibre49">Test type</th>
<th class="calibre49">Question the test answers</th>
</tr>
</thead>
<tbody class="calibre50">
<tr class="calibre48">
<td class="calibre51"><p class="author1">Unit</p></td>
<td class="calibre51"><p class="author1">Do units (functions and classes) act as developers expect?</p></td>
</tr>
<tr class="calibre53">
<td class="calibre51"><p class="author1">Integration</p></td>
<td class="calibre51"><p class="author1">Are separate parts of the system stitched together properly?</p></td>
</tr>
<tr class="calibre48">
<td class="calibre51"><p class="author1">Acceptance</p></td>
<td class="calibre51"><p class="author1">Does the system do what the end user expects?</p></td>
</tr>
<tr class="calibre53">
<td class="calibre51"><p class="author1">Load</p></td>
<td class="calibre51"><p class="author1">Does the system stay operational under heavy duress?</p></td>
</tr>
<tr class="calibre48">
<td class="calibre51"><p class="author1">Security</p></td>
<td class="calibre51"><p class="author1">Does the system resist specific attacks and exploits?</p></td>
</tr>
<tr class="calibre53">
<td class="calibre51"><p class="author1">Usability</p></td>
<td class="calibre51"><p class="author1">Is the system intuitive to use?</p></td>
</tr>
</tbody>
</table>
<aside data-type="sidebar" epub:type="sidebar" class="calibre32"><div class="sidebar" id="idm45644727281896">
<h5 class="calibre33">A Note About Manual Testing</h5>
<p class="author1">Since this is a book about robust Python, I am focusing mostly on your codebase and the tools that support it.<a data-type="indexterm" data-primary="manual testing" id="idm45644727280024" class="calibre5"/><a data-type="indexterm" data-primary="testing" data-secondary="defining your test strategy" data-tertiary="manual testing" id="idm45644727279320" class="calibre5"/> This means there is a heavy bias toward automated testing in Python. However, do not take this to mean that manual testing should be tossed to the wayside.</p>

<p class="author1"><em class="calibre6">Manual testing</em>, which is having a person execute testing steps instead of the computer, has its place. It is fantastic for things such as exploring your codebase in ways that are not easy for a computer, such as validating how a user will interact with your system, checking for security vulnerabilities, or running any other type of test that relies on subjective analysis.</p>

<p class="author1">In cases where it is cheaper to run manual tests than automated tests (say for expensive test equipment or other constraints), it may also be appropriate to keep a human in the loop. Before you jump to this conclusion, though, factor in the cost of repetition: think through how often you will run the test. In some cases, the cost of manual testing will overtake the cost of automated testing after just a few test runs.</p>
</div></aside>

<p class="author1">Notice that <a data-type="xref" href="part0027_split_002.html#testing_questions" class="calibre5">Table 21-1</a> did not say anything about making sure your software is bug free. As Edsger Djikstra wrote, “Program testing can be used to show the presence of bugs, but never to show their absence!”<sup class="calibre11"><a data-type="noteref" id="idm45644727274344-marker" href="part0027_split_007.html#idm45644727274344" class="calibre5">1</a></sup> Tests answer questions regarding the  <em class="calibre6">quality</em> of your software.<a data-type="indexterm" data-primary="testing" data-secondary="defining your test strategy" data-tertiary="tests answering questions about quality of software" id="idm45644727272024" class="calibre5"/></p>

<p class="author1"><em class="calibre6">Quality</em> is this nebulous, ill-defined <a data-type="indexterm" data-primary="quality of software" id="idm45644727269960" class="calibre5"/>term that gets tossed around quite a bit. It’s a tough thing to pin down, but I prefer this quote from Gerald Weinberg: “Quality is value to some person.”<sup class="calibre11"><a data-type="noteref" id="idm45644727268952-marker" href="part0027_split_007.html#idm45644727268952" class="calibre5">2</a></sup> I love how open-ended this quote is; you need to think of anyone who may receive some value from your system. It’s not just your direct customers, but your customers’ customers, your operations team, your sales, your <span class="calibre">coworkers</span>, and so on.</p>

<p class="author1">Once you’ve identified who receives the value of your system, you need to measure the impact when something goes wrong. For every test that is not run, you lose a chance to learn whether you are delivering value. What is the impact if that value is not delivered? For core business needs, the impact is pretty high. For features that lie outside of an end user’s critical path, the impact may be low. Know your impact, and weigh that against the cost of testing. If the impact’s cost is higher than the test, write the test. If it’s lower, skip writing the test and spend your time doing something more impactful.<a data-type="indexterm" data-primary="tests" data-startref="ix_testsund" id="idm45644727265400" class="calibre5"/></p>










<section data-type="sect3" data-pdf-bookmark="The testing pyramid" class="preface"><div class="preface" id="idm45644727264296">
<h3 class="calibre44">The testing pyramid</h3>

<p class="author1">In just about any testing book, you are<a data-type="indexterm" data-primary="testing" data-secondary="defining your test strategy" data-tertiary="testing triangle" id="idm45644727262616" class="calibre5"/> bound to come across a figure similar to <a data-type="xref" href="part0027_split_002.html#testing_pyramid" class="calibre5">Figure 21-1</a>: a “testing pyramid.”<sup class="calibre11"><a data-type="noteref" id="idm45644727260312-marker" href="part0027_split_007.html#idm45644727260312" class="calibre5">3</a></sup></p>

<figure class="calibre36"><div id="testing_pyramid" class="figure">
<img src="../images/00039.gif" alt="ropy 2101" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 21-1. </span>The testing pyramid</h6>
</div></figure>

<p class="author1">The idea is that you want to write a lot of small, isolated unit tests. These are theoretically cheaper and should make up the bulk of your testing, hence they’re at the bottom. You have fewer integration tests, which are costly, and even fewer UI tests, which are very costly. Now, ever since its inception, developers have argued about the testing pyramid in a multitude of ways, including where the lines get drawn, the usefulness of unit tests, and even the shape of the triangle (I’ve even seen the triangle inverted).</p>

<p class="author1">The truth is, it doesn’t matter what the labels are or how you separate your tests. What you want is your triangle to look like <a data-type="xref" href="part0027_split_002.html#pat_testing_pyramid" class="calibre5">Figure 21-2</a>, which focuses on the ratio of value to cost.</p>

<figure class="calibre36"><div id="pat_testing_pyramid" class="figure">
<img src="../images/00040.gif" alt="ropy 2102" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 21-2. </span>The testing pyramid focused on value-to-cost</h6>
</div></figure>

<p class="author1">Write lots of tests that have a high value-to-cost ratio. It doesn’t matter if they are unit tests or acceptance tests. Find ways to run them often. Make tests fast so that developers run them multiple times between commits to verify that things are still working. Keep your less valuable, slower, or more costly tests for testing on each commit (or at least periodically).</p>

<p class="author1">The more tests you have, the fewer unknowns you have. The fewer unknowns you have, the more robust your codebase will be. With every change you make, you have a bigger safety net to check for any regression. But what if the tests are becoming too costly, far outweighing the cost of any impact? If you feel these tests are still worthwhile, you need to find a way to reduce their cost.<a data-type="indexterm" data-primary="costs" data-secondary="for tests" id="ix_tests" class="calibre5"/></p>

<p class="author1">The cost of a test is threefold: the initial cost of writing, the cost of running, and the cost for maintenance. Tests, at a minimum, will have to run for some amount of time, and that does cost money. However, reducing that cost often becomes an optimization exercise, where you look for ways of parallelizing your tests or running them more frequently on developer machines. You still need to reduce the initial cost of writing and ongoing cost of maintaining your tests. Fortunately, everything you’ve read in this book so far directly applies to reducing those costs. Your test code is just as much a part of your codebase as the rest of your code, and you need to make sure it is robust as well. Choose the right tools, organize your test cases properly, and make your tests clear to read and maintain.</p>
</div></section>



</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 21. Testing Strategy" class="preface">
<div class="preface" id="testing_strategy">
<section data-type="sect1" data-pdf-bookmark="Defining Your Test Strategy" class="preface">
<div class="preface" id="idm45644727468456">
<section data-type="sect2" data-pdf-bookmark="What Is a Test?" class="preface">
<div class="preface" id="idm45644727461016">
<section data-type="sect3" data-pdf-bookmark="The testing pyramid" class="preface">
<div class="preface" id="idm45644727264296">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_3">Discussion Topic</h1>
<p class="author1">Measure the costs of tests in your system. Does time to write, time to run, or time spent maintaining dominate your costs? What can you do to reduce those costs?<a data-type="indexterm" data-primary="testing" data-secondary="defining your test strategy" data-startref="ix_tststdef" id="idm45644727247144" class="calibre5"/></p>
</div>
</div></section>



</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 21. Testing Strategy" class="preface">
<div class="preface" id="testing_strategy">
<section data-type="sect1" data-pdf-bookmark="Reducing Test Cost" class="preface"><div class="preface" id="idm45644727460520">
<h1 class="calibre12" id="calibre_pb_4">Reducing Test Cost</h1>

<p class="author1">When you examine the value against the cost of a test, you are gathering information that will help you prioritize your testing strategy.<a data-type="indexterm" data-primary="testing" data-secondary="reducing test cost" id="ix_tststred" class="calibre5"/> Some tests may not be worth running, and some will stand out as the first tests you want to write to maximize value. However, sometimes you run into the case where there is a really important test that you want to write, but it is incredibly costly to write and/or maintain. In these cases, find a way to reduce the costs of that test. The way you write and organize your tests is paramount to making a test cheaper to write and understand.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre32"><div class="sidebar" id="idm45644727242552">
<h5 class="calibre33">Using pytest</h5>
<p class="author1">For the examples in this chapter, I will use the popular testing<a data-type="indexterm" data-primary="pytest" id="idm45644727241080" class="calibre5"/> library <a href="https://docs.pytest.org/en/stable" class="calibre5"><code class="calibre17">pytest</code></a>. There are fantastic resources for learning <code class="calibre17">pytest</code>, such as <em class="calibre6">Python Testing with pytest: Simple, Rapid, Effective, and Scalable</em> by Brian Okken (Pragmatic Bookshelf). Here, I’ll cover the basics to give you context for this chapter.</p>

<p class="author1">A test in <code class="calibre17">pytest</code> is any function that is prefixed with <code class="calibre17">test_</code> in a file that is also prefixed by <em class="calibre6">test_</em>. Here’s a file named <em class="calibre6">test_calorie_count.py</em> with a single test:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">nutrition</code> <code class="k">import</code> <code class="n">get_calorie_count</code>

<code class="k">def</code> <code class="nf">test_get_calorie_count</code><code class="o">():</code>
    <code class="k">assert</code> <code class="n">get_calorie_count</code><code class="o">(</code><code class="s">"Bacon Cheeseburger w/ Fries"</code><code class="o">)</code> <code class="o">==</code> <code class="mi">1200</code></pre>

<p class="author1">Tests contain assertions, or things that should be true. <code class="calibre17">pytest</code> uses the built-in <code class="calibre17">assert</code> statement for assertions.<a data-type="indexterm" data-primary="assertions" id="idm45644727216568" class="calibre5"/> If a test’s assertion is false, an <code class="calibre17">AssertionError</code> is raised and the test fails. If the assertion is true, the test continues executing.</p>

<p class="author1">If you are hesitant to introduce a dependency on a library, there is a built-in unit testing framework with the <code class="calibre17">unittest</code> module in Python. I prefer <code class="calibre17">pytest</code> because of some advanced features (fixtures, plug-ins, etc.), but all of the principles in this chapter apply to other testing frameworks as well.</p>
</div></aside>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 21. Testing Strategy" class="preface">
<div class="preface" id="testing_strategy">
<section data-type="sect1" data-pdf-bookmark="Reducing Test Cost" class="preface">
<div class="preface" id="idm45644727460520">
<section data-type="sect2" data-pdf-bookmark="AAA Testing" class="preface"><div class="preface" id="idm45644727213864">
<h2 class="calibre34" id="calibre_pb_5">AAA Testing</h2>

<p class="author1">As with production code, focus on readability and maintainability in your test code.<a data-type="indexterm" data-primary="AAA testing" id="ix_AAA" class="calibre5"/> Communicate your intent as clearly as possible. Future test readers will thank you if they can see exactly what you are trying to test. When writing a test, it helps for each test to follow the same basic pattern.</p>

<p class="author1">One of the most common patterns you’ll find in tests is the 3A, or AAA, test pattern.<sup class="calibre11"><a data-type="noteref" id="idm45644727210584-marker" href="part0027_split_007.html#idm45644727210584" class="calibre5">4</a></sup> AAA stands for <em class="calibre6">Arrange-Act-Assert</em>. You break up each test into three separate blocks of code, one for setting up your preconditions (arrange), one for performing the operations that are being tested (act), and then one for checking for any post-conditions (assert). You may also hear about a fourth A, for <em class="calibre6">annihilate</em>, or your clean-up code. I’ll cover each of these steps in detail to discuss how to make your tests easier to read and maintain.</p>










<section data-type="sect3" data-pdf-bookmark="Arrange" class="preface"><div class="preface" id="idm45644727207784">
<h3 class="calibre44">Arrange</h3>

<p class="author1">The <em class="calibre6">arrange</em> step is all about setting up the system in a state that is ready to test.<a data-type="indexterm" data-primary="arrange step (AAA testing)" id="ix_arra" class="calibre5"/><a data-type="indexterm" data-primary="AAA testing" data-secondary="arrange" id="ix_AAAarr" class="calibre5"/><a data-type="indexterm" data-primary="preconditions" data-secondary="of a test" data-secondary-sortas="test" id="idm45644727203400" class="calibre5"/> These are called the <em class="calibre6">preconditions</em> of the test. You set up any dependencies or test data that are needed for the test to operate correctly.</p>

<p class="author1">Consider the following test:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">test_calorie_calculation</code><code class="calibre17">():</code>

    <code class="c"># arrange (set up everything the test needs to run)</code>
    <code class="n">add_ingredient_to_database</code><code class="calibre17">(</code><code class="s">"Ground Beef"</code><code class="calibre17">,</code> <code class="n">calories_per_pound</code><code class="calibre17">=</code><code class="mi">1500</code><code class="calibre17">)</code>
    <code class="n">add_ingredient_to_database</code><code class="calibre17">(</code><code class="s">"Bacon"</code><code class="calibre17">,</code> <code class="n">calories_per_pound</code><code class="calibre17">=</code><code class="mi">2400</code><code class="calibre17">)</code>
    <code class="n">add_ingredient_to_database</code><code class="calibre17">(</code><code class="s">"Cheese"</code><code class="calibre17">,</code> <code class="n">calories_per_pound</code><code class="calibre17">=</code><code class="mi">1800</code><code class="calibre17">)</code>
    <code class="c"># ... snip 13 more ingredients</code>

    <code class="n">set_ingredients</code><code class="calibre17">(</code><code class="s">"Bacon Cheeseburger w/ Fries"</code><code class="calibre17">,</code>
                    <code class="n">ingredients</code><code class="calibre17">=</code><code class="calibre17">[</code><code class="s">"Ground Beef"</code><code class="calibre17">,</code> <code class="s">"Bacon"</code> <code class="calibre17">...</code> <code class="calibre17">])</code>

    <code class="c"># act (the thing getting tested)</code>
    <code class="n">calories</code> <code class="calibre17">=</code> <code class="n">get_calories</code><code class="calibre17">(</code><code class="s">"Bacon Cheeseburger w/ Fries"</code><code class="calibre17">)</code>

    <code class="c"># assert (verify some property about the program)</code>
    <code class="k">assert</code> <code class="n">calories</code> <code class="calibre17">==</code> <code class="mi">1200</code>

    <code class="c">#annihilate (cleanup any resources that were allocated)</code>
    <code class="n">cleanup_database</code><code class="calibre17">()</code></pre>

<p class="author1">First, I add ingredients to a database and associate a list of ingredients with a dish called “Bacon Cheeseburger w/ Fries.” Then I find out how many calories are in the burger, check this against a known value, and clean up the database.</p>

<p class="author1">Look how much code there is before I actually get to the test itself (the <code class="calibre17">get_calories</code> invocation).<a data-type="indexterm" data-primary="arrange step (AAA testing)" data-secondary="large arrange blocks" id="idm45644727121640" class="calibre5"/> Large <em class="calibre6">arrange</em> blocks are a red flag. You will have many tests that look very similar, and you want readers to be able to know how they differ at a glance.</p>
<div data-type="warning" epub:type="warning" class="calibre23"><h6 class="calibre24">Warning</h6>
<p class="author1">Large <em class="calibre6">arrange</em> blocks may indicate a complicated setup of dependencies.<a data-type="indexterm" data-primary="dependencies" data-secondary="large arrange blocks and" id="idm45644727118616" class="calibre5"/> Any user of this code will presumably have to set up the dependencies in a similar way. Take a step back and ask if there are simpler ways to handle dependencies, such as using the strategies described in <a data-type="xref" href="part0019.html#part_3" class="calibre5">Part III</a>.</p>
</div>

<p class="author1">In the preceding example, if I have to add 15 ingredients in two separate tests but set an ingredient slightly differently to simulate substitutions, it will be difficult to eyeball how the tests differ. Giving the tests verbose names indicating their differences is a good step to make, but that only goes so far. Find a balance between keeping the test informative and making it easy to read at a glance.</p>












<section data-type="sect4" data-pdf-bookmark="Consistent preconditions versus changing preconditions" class="preface"><div class="preface" id="idm45644727115384">
<h4 class="calibre56">Consistent preconditions versus changing preconditions</h4>

<p class="author1">Look through your tests and ask yourself what preconditions are the same across sets of tests.<a data-type="indexterm" data-primary="arrange step (AAA testing)" data-secondary="consistent versus changing preconditions" id="idm45644727113912" class="calibre5"/><a data-type="indexterm" data-primary="preconditions" data-secondary="of a test" data-tertiary="consistent versus changing" data-secondary-sortas="test" id="idm45644727112824" class="calibre5"/> Extract these through a function and reuse that function across each test. Look how much easier it is to compare the following two tests:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">test_calorie_calculation_bacon_cheeseburger</code><code class="calibre17">():</code>
    <code class="n">add_base_ingredients_to_database</code><code class="calibre17">()</code>
    <code class="n">add_ingredient_to_database</code><code class="calibre17">(</code><code class="s">"Bacon"</code><code class="calibre17">,</code> <code class="n">calories_per_pound</code><code class="calibre17">=</code><code class="mi">2400</code><code class="calibre17">)</code>

    <code class="n">st</code> <code class="calibre17">/</code><code class="n">etup_bacon_cheeseburger</code><code class="calibre17">(</code><code class="n">bacon</code><code class="calibre17">=</code><code class="s">"Bacon"</code><code class="calibre17">)</code>
    <code class="n">calories</code> <code class="calibre17">=</code> <code class="n">get_calories</code><code class="calibre17">(</code><code class="s">"Bacon Cheeseburger w/ Fries"</code><code class="calibre17">)</code>

    <code class="k">assert</code> <code class="n">calories</code> <code class="calibre17">==</code> <code class="mi">1200</code>

    <code class="n">cleanup_database</code><code class="calibre17">()</code>

<code class="k">def</code> <code class="nf">test_calorie_calculation_bacon_cheeseburger_with_substitution</code><code class="calibre17">():</code>
    <code class="n">add_base_ingredients_to_database</code><code class="calibre17">()</code>
    <code class="n">add_ingredient_to_database</code><code class="calibre17">(</code><code class="s">"Turkey Bacon"</code><code class="calibre17">,</code> <code class="n">calories_per_pound</code><code class="calibre17">=</code><code class="mi">1700</code><code class="calibre17">)</code>

    <code class="n">setup_bacon_cheeseburger</code><code class="calibre17">(</code><code class="n">bacon</code><code class="calibre17">=</code><code class="s">"Turkey Bacon"</code><code class="calibre17">)</code>
    <code class="n">calories</code> <code class="calibre17">=</code> <code class="n">get_calories</code><code class="calibre17">(</code><code class="s">"Bacon Cheeseburger w/ Fries"</code><code class="calibre17">)</code>

    <code class="k">assert</code> <code class="n">calories</code> <code class="calibre17">==</code> <code class="mi">1100</code>

    <code class="n">cleanup_database</code><code class="calibre17">()</code></pre>

<p class="author1">By creating helper functions (in this case, <code class="calibre17">add_base_ingredients_to_database</code> and <code class="calibre17">setup_bacon_cheeseburger</code>), you take all the unimportant boilerplate of the tests and reduce it, allowing developers to hone in on differences between tests.</p>
</div></section>













<section data-type="sect4" data-pdf-bookmark="Use test framework features for boilerplate code" class="preface"><div class="preface" id="idm45644727000136">
<h4 class="calibre56">Use test framework features for boilerplate code</h4>

<p class="author1">Most test frameworks provide a way to run code automatically before tests. In the built-in <code class="calibre17">unittest</code> module, you can write a <code class="calibre17">setUp</code> function to run before every test.<a data-type="indexterm" data-primary="arrange step (AAA testing)" data-secondary="using test framework features for boilerplate code" id="idm45644726997624" class="calibre5"/><a data-type="indexterm" data-primary="fixtures" id="idm45644726996488" class="calibre5"/><a data-type="indexterm" data-primary="pytest" data-secondary="fixtures" id="idm45644726995816" class="calibre5"/> In <code class="calibre17">pytest</code>, you accomplish something similar with fixtures.</p>

<p class="author1">A <em class="calibre6">fixture</em> in <code class="calibre17">pytest</code> is a way of specifying initialization and teardown code for tests. Fixtures offer a ton of useful features, like defining dependencies on other fixtures (letting <code class="calibre17">pytest</code> control initialization order) and controlling initialization so that a fixture is only initialized once per module. In the previous example, we could have used a fixture for the <code class="calibre17">test_database</code>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">import</code> <code class="nn">pytest</code>

<code class="nd">@pytest.fixture</code>
<code class="k">def</code> <code class="nf">db_creation</code><code class="calibre17">():</code>
    <code class="c"># ... snip  set up local sqlite database</code>
    <code class="k">return</code> <code class="n">database</code>

<code class="nd">@pytest.fixture</code>
<code class="k">def</code> <code class="nf">test_database</code><code class="calibre17">(</code><code class="n">db_creation</code><code class="calibre17">):</code>
    <code class="c"># ... snip adding all ingredients and meals</code>
    <code class="k">return</code> <code class="n">database</code>

<code class="k">def</code> <code class="nf">test_calorie_calculation_bacon_cheeseburger</code><code class="calibre17">(</code><code class="n">test_database</code><code class="calibre17">):</code>
    <code class="n">test_database</code><code class="calibre17">.</code><code class="n">add_ingredient</code><code class="calibre17">(</code><code class="s">"Bacon"</code><code class="calibre17">,</code> <code class="n">calories_per_pound</code><code class="calibre17">=</code><code class="mi">2400</code><code class="calibre17">)</code>
    <code class="n">setup_bacon_cheeseburger</code><code class="calibre17">(</code><code class="n">bacon</code><code class="calibre17">=</code><code class="s">"Bacon"</code><code class="calibre17">)</code>

    <code class="n">calories</code> <code class="calibre17">=</code> <code class="n">get_calories</code><code class="calibre17">(</code><code class="s">"Bacon Cheeseburger w/ Fries"</code><code class="calibre17">)</code>

    <code class="k">assert</code> <code class="n">calories</code> <code class="calibre17">==</code> <code class="mi">1200</code>

    <code class="n">test_database</code><code class="calibre17">.</code><code class="n">cleanup</code><code class="calibre17">()()</code></pre>

<p class="author1">Notice how the test has an argument for <code class="calibre17">test_database</code> now. This is the fixture at work; the function <code class="calibre17">test_database</code> (as well as <code class="calibre17">db_creation</code>) will get called before the test. Fixtures only become more useful as the number of tests grows. They are composable, allowing you to mix them together and reduce code duplication. I won’t generally use them to abstract code in a single file, but as soon as that initialization needs to be used in multiple files, fixtures are the way to go.</p>
</div></section>













<section data-type="sect4" data-pdf-bookmark="Mocking" class="preface"><div class="preface" id="idm45644726939144">
<h4 class="calibre56">Mocking</h4>

<p class="author1">Python offers <a data-type="indexterm" data-primary="arrange step (AAA testing)" data-secondary="mocking" id="idm45644726937608" class="calibre5"/><a data-type="indexterm" data-primary="mocking" id="idm45644726936632" class="calibre5"/>duck typing (first mentioned in <a data-type="xref" href="part0005_split_000.html#types" class="calibre5">Chapter 2</a>) as part of its type system, which means that you can easily substitute types for one another as long as they uphold the same contract (as discussed in <a data-type="xref" href="part0016_split_000.html#subtyping" class="calibre5">Chapter 12</a>). This means that you can tackle complex dependencies in a completely different way: use a simple mocked object instead. A <em class="calibre6">mocked</em> object is something that looks identical to a production object as far as methods and fields go, but offers simplified data.</p>
<div data-type="tip" class="calibre21"><h6 class="calibre22">Tip</h6>
<p class="author1">Mocks are used a lot in unit tests, but you will see their usage decline the less granular the tests become. This is because you try to test more of the system at a higher level; the services you are mocking are often part of the tests.</p>
</div>

<p class="author1">For instance, if the database in the previous example was quite complex to set up with multiple tables and schemas, it might not be worth setting up for every test, especially if tests share a database; you want to keep tests isolated from one another. (I’ll cover this more in a moment.) The class handling the database might look like this:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">DatabaseHandler</code><code class="calibre17">:</code>

    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">):</code>
        <code class="c"># ... snip complex setup</code>

    <code class="k">def</code> <code class="nf">add_ingredient</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">ingredient</code><code class="calibre17">):</code>
        <code class="c"># ... snip complex queries</code>

    <code class="k">def</code> <code class="nf">get_calories_for_ingredient</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">ingredient</code><code class="calibre17">):</code>
        <code class="c"># ... snip complex queries</code></pre>

<p class="author1">Instead of using this class verbatim, create a mock class that just looks like a database handler:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">MockDatabaseHandler</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">data</code> <code class="calibre17">=</code> <code class="calibre17">{</code>
            <code class="s">"Ground Beef"</code><code class="calibre17">:</code> <code class="mi">1500</code><code class="calibre17">,</code>
            <code class="s">"Bacon"</code><code class="calibre17">:</code> <code class="mi">2400</code><code class="calibre17">,</code>
            <code class="c"># ... snip ...</code>
        <code class="calibre17">}</code>

    <code class="k">def</code> <code class="nf">add_ingredient</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">ingredient</code><code class="calibre17">):</code>
        <code class="n">name</code><code class="calibre17">,</code> <code class="n">calories</code> <code class="calibre17">=</code> <code class="n">ingredient</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">data</code><code class="calibre17">[</code><code class="n">name</code><code class="calibre17">]</code> <code class="calibre17">=</code> <code class="n">calories</code>

    <code class="k">def</code> <code class="nf">get_calories_for_ingredient</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">ingredient</code><code class="calibre17">):</code>
        <code class="k">return</code> <code class="nb">self</code><code class="calibre17">.</code><code class="n">data</code><code class="calibre17">[</code><code class="n">ingredient</code><code class="calibre17">]</code></pre>

<p class="author1">With the mock, I’m just using a simple dictionary to store my data. How you mock your data will be different for each scenario, but if you can find a way to substitute the real object with a mock object, you can dramatically reduce the complexity of your setup.</p>
<div data-type="warning" epub:type="warning" class="calibre23"><h6 class="calibre24">Warning</h6>
<p class="author1">Some people use <a href="https://oreil.ly/xBFHl" class="calibre5"><em class="calibre6">monkeypatching</em></a>, or swapping out methods at runtime to inject mocks.<a data-type="indexterm" data-primary="monkeypatching" id="idm45644726735832" class="calibre5"/> This is OK in moderation, but if you find your tests littered with monkeypatching, this is an antipattern. It means that you have far too rigid a physical dependency between different modules and should look at finding ways to make your system more modular. (Consult <a data-type="xref" href="part0019.html#part_3" class="calibre5">Part III</a> for more ideas on making code extensible.)</p>
</div>
</div></section>

</div></section>













<section data-type="sect3" data-pdf-bookmark="Annihilate" class="preface"><div class="preface" id="idm45644727207160">
<h3 class="calibre44">Annihilate</h3>

<p class="author1">Technically, the <em class="calibre6">annihilate</em> stage is the last thing you do in a test, but I’m covering it second.<a data-type="indexterm" data-primary="arrange step (AAA testing)" data-startref="ix_arra" id="idm45644726731608" class="calibre5"/><a data-type="indexterm" data-primary="AAA testing" data-secondary="arrange" data-startref="ix_AAAarr" id="idm45644726730664" class="calibre5"/> Why? Because it’s inherently tied to your <em class="calibre6">arrange</em> step. Whatever you set up in <em class="calibre6">arrange</em> needs to be torn down if it could influence other tests.<a data-type="indexterm" data-primary="annihilate stage (AAA testing)" id="ix_anni" class="calibre5"/><a data-type="indexterm" data-primary="AAA testing" data-secondary="annihilate stage" id="ix_AAAann" class="calibre5"/></p>

<p class="author1">You want your tests to be isolated from one another; it will make them easier to maintain. One of the biggest nightmares for a test automation writer is having tests fail depending on what order they run in (especially if you have thousands). This is a sure sign of tests having subtle dependencies on one another. Clean up your tests before you leave them and reduce the chances of tests interacting with one another. Here are some strategies for dealing with test cleanup.</p>












<section data-type="sect4" data-pdf-bookmark="Don’t use shared resources" class="preface"><div class="preface" id="idm45644726725480">
<h4 class="calibre56">Don’t use shared resources</h4>

<p class="author1">If you can get away with it, share nothing between tests.<a data-type="indexterm" data-primary="annihilate stage (AAA testing)" data-secondary="avoiding use of shared resources" id="idm45644726724184" class="calibre5"/><a data-type="indexterm" data-primary="shared resources, not using in tests" id="idm45644726723128" class="calibre5"/> This isn’t always feasible, but it should be your goal. If no tests share any resources, then you don’t need to clean anything up. A shared resource can be in Python (global variable, class variables) or in the environment (database, file access, socket pools).</p>
</div></section>













<section data-type="sect4" data-pdf-bookmark="Use context managers" class="preface"><div class="preface" id="idm45644726721768">
<h4 class="calibre56">Use context managers</h4>

<p class="author1">Use a context manager (discussed in <a data-type="xref" href="part0015_split_000.html#api" class="calibre5">Chapter 11</a>) to ensure that resources are always cleaned up. <a data-type="indexterm" data-primary="context managers" data-secondary="using in annihilate stage of AAA testing" id="idm45644726719400" class="calibre5"/><a data-type="indexterm" data-primary="annihilate stage (AAA testing)" data-secondary="using context managers" id="idm45644726718360" class="calibre5"/>In my previous example, eagle-eyed readers may have noticed a bug:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">test_calorie_calculation_bacon_cheeseburger</code><code class="calibre17">():</code>
    <code class="n">add_base_ingredients_to_database</code><code class="calibre17">()</code>
    <code class="n">add_ingredient_to_database</code><code class="calibre17">(</code><code class="s">"Bacon"</code><code class="calibre17">,</code> <code class="n">calories_per_pound</code><code class="calibre17">=</code><code class="mi">2400</code><code class="calibre17">)</code>
    <code class="n">setup_bacon_cheeseburger</code><code class="calibre17">(</code><code class="n">bacon</code><code class="calibre17">=</code><code class="s">"Bacon"</code><code class="calibre17">)</code>

    <code class="n">calories</code> <code class="calibre17">=</code> <code class="n">get_calories</code><code class="calibre17">(</code><code class="s">"Bacon Cheeseburger w/ Fries"</code><code class="calibre17">)</code>

    <code class="k">assert</code> <code class="n">calories</code> <code class="calibre17">==</code> <code class="mi">1200</code>

    <code class="n">cleanup_database</code><code class="calibre17">()</code></pre>

<p class="author1">If the assertion fails, an exception is raised and <code class="calibre17">cleanup_database</code> never executes. It would be much better to force usage through a context manager:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">test_calorie_calculation_bacon_cheeseburger</code><code class="calibre17">():</code>
    <code class="k">with</code> <code class="n">construct_test_database</code><code class="calibre17">()</code> <code class="k">as</code> <code class="n">db</code><code class="calibre17">:</code>
        <code class="n">db</code><code class="calibre17">.</code><code class="n">add_ingredient</code><code class="calibre17">(</code><code class="s">"Bacon"</code><code class="calibre17">,</code> <code class="n">calories_per_pound</code><code class="calibre17">=</code><code class="mi">2400</code><code class="calibre17">)</code>
        <code class="n">setup_bacon_cheeseburger</code><code class="calibre17">(</code><code class="n">bacon</code><code class="calibre17">=</code><code class="s">"Bacon"</code><code class="calibre17">)</code>

        <code class="n">calories</code> <code class="calibre17">=</code> <code class="n">get_calories</code><code class="calibre17">(</code><code class="s">"Bacon Cheeseburger w/ Fries"</code><code class="calibre17">)</code>

        <code class="k">assert</code> <code class="n">calories</code> <code class="calibre17">==</code> <code class="mi">1200</code></pre>

<p class="author1">Put your cleanup code in the context manager so that your test writers never have to actively think about it; it’s just done for them.</p>
</div></section>













<section data-type="sect4" data-pdf-bookmark="Use fixtures" class="preface"><div class="preface" id="idm45644726596200">
<h4 class="calibre56">Use fixtures</h4>

<p class="author1">If you are using <code class="calibre17">pytest</code> fixtures, you can use them much like you could a context manager.<a data-type="indexterm" data-primary="annihilate stage (AAA testing)" data-secondary="using fixtures" id="idm45644726594696" class="calibre5"/><a data-type="indexterm" data-primary="pytest" data-secondary="fixtures" id="idm45644726593752" class="calibre5"/><a data-type="indexterm" data-primary="fixtures" id="idm45644726592808" class="calibre5"/> You can <em class="calibre6">yield</em> values from a fixture, allowing you to return to the fixture’s execution after the test finishes. Observe:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">import</code> <code class="nn">pytest</code>

<code class="nd">@pytest.fixture</code>
<code class="k">def</code> <code class="nf">db_creation</code><code class="calibre17">():</code>
    <code class="c"># ... snip  set up local sqlite database</code>
    <code class="k">return</code> <code class="n">database</code>

<code class="nd">@pytest.fixture</code>
<code class="k">def</code> <code class="nf">test_database</code><code class="calibre17">(</code><code class="n">db_creation</code><code class="calibre17">):</code>
    <code class="c"># ... snip adding all ingredients and meals</code>
    <code class="k">try</code><code class="calibre17">:</code>
        <code class="k">yield</code> <code class="n">database</code>
    <code class="k">finally</code><code class="calibre17">:</code>
        <code class="n">database</code><code class="calibre17">.</code><code class="n">cleanup</code><code class="calibre17">()</code>

<code class="k">def</code> <code class="nf">test_calorie_calculation_bacon_cheeseburger</code><code class="calibre17">(</code><code class="n">test_database</code><code class="calibre17">):</code>
    <code class="n">test_database</code><code class="calibre17">.</code><code class="n">add_ingredient</code><code class="calibre17">(</code><code class="s">"Bacon"</code><code class="calibre17">,</code> <code class="n">calories_per_pound</code><code class="calibre17">=</code><code class="mi">2400</code><code class="calibre17">)</code>
    <code class="n">setup_bacon_cheeseburger</code><code class="calibre17">(</code><code class="n">bacon</code><code class="calibre17">=</code><code class="s">"Bacon"</code><code class="calibre17">)</code>

    <code class="n">calories</code> <code class="calibre17">=</code> <code class="n">get_calories</code><code class="calibre17">(</code><code class="s">"Bacon Cheeseburger w/ Fries"</code><code class="calibre17">)</code>

    <code class="k">assert</code> <code class="n">calories</code> <code class="calibre17">==</code> <code class="mi">1200</code></pre>

<p class="author1">Notice how the <code class="calibre17">test_database</code> fixture now yields the database. When any test using this function finishes (whether it passes or fails), the database cleanup function will always execute.<a data-type="indexterm" data-primary="annihilate stage (AAA testing)" data-startref="ix_anni" id="idm45644726588824" class="calibre5"/><a data-type="indexterm" data-primary="AAA testing" data-secondary="annihilate stage" data-startref="ix_AAAann" id="idm45644726522248" class="calibre5"/></p>
</div></section>

</div></section>













<section data-type="sect3" data-pdf-bookmark="Act" class="preface"><div class="preface" id="idm45644726520776">
<h3 class="calibre44">Act</h3>

<p class="author1">The <em class="calibre6">act</em> stage is the most important part of the test.<a data-type="indexterm" data-primary="act stage (AAA testing)" id="ix_act" class="calibre5"/><a data-type="indexterm" data-primary="AAA testing" data-secondary="act stage" id="ix_AAAact" class="calibre5"/> It embodies the actual operation that you are testing. In the preceding examples, the <em class="calibre6">act</em> stage was getting the calories for a specific dish. You do not want an <em class="calibre6">act</em> stage to be much longer than one or two lines of code. Less is more; by keeping this stage small, you reduce the time it takes  readers to understand the meat of the test.</p>

<p class="author1">Sometimes, you want to reuse the same <em class="calibre6">act</em> stage across multiple tests. If you find yourself wanting to write the same test on the same action, but with slightly different input data and assertions, consider <em class="calibre6">parameterizing</em> your tests.<a data-type="indexterm" data-primary="parameterizing tests" id="idm45644726513832" class="calibre5"/> Test <em class="calibre6">parameterization</em> is a way of running the same test on different parameters.<a data-type="indexterm" data-primary="table-driven tests" id="idm45644726512552" class="calibre5"/> This allows you to write <em class="calibre6">table-driven</em> tests, or a way of organizing your test data in a tabular form.</p>

<p class="author1">Here is the <code class="calibre17">get_calories</code> test with parameterization:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="nd">@pytest.mark.parametrize</code><code class="calibre17">(</code>
    <code class="s">"extra_ingredients,dish_name,expected_calories"</code><code class="calibre17">,</code>
    <code class="calibre17">[</code>
        <code class="calibre17">([</code><code class="s">"Bacon"</code><code class="calibre17">,</code> <code class="mi">2400</code><code class="calibre17">],</code> <code class="s">"Bacon Cheeseburger"</code><code class="calibre17">,</code> <code class="mi">900</code><code class="calibre17">),</code>
        <code class="calibre17">([],</code>  <code class="s">"Cobb Salad"</code><code class="calibre17">,</code> <code class="mi">1000</code><code class="calibre17">),</code>
        <code class="calibre17">([],</code>  <code class="s">"Buffalo Wings"</code><code class="calibre17">,</code> <code class="mi">800</code><code class="calibre17">),</code>
        <code class="calibre17">([],</code>  <code class="s">"Garlicky Brussels Sprouts"</code><code class="calibre17">,</code> <code class="mi">200</code><code class="calibre17">),</code>
        <code class="calibre17">([],</code>  <code class="s">"Mashed Potatoes"</code><code class="calibre17">,</code> <code class="mi">400</code><code class="calibre17">)</code>
    <code class="calibre17">]</code>
<code class="calibre17">)</code>
<code class="k">def</code> <code class="nf">test_calorie_calculation_bacon_cheeseburger</code><code class="calibre17">(</code><code class="n">extra_ingredients</code><code class="calibre17">,</code>
                                                <code class="n">dish_name</code><code class="calibre17">,</code>
                                                <code class="n">expected_calories</code><code class="calibre17">,</code>
                                                <code class="n">test_database</code><code class="calibre17">):</code>
    <code class="k">for</code> <code class="n">ingredient</code> <code class="calibre19">in</code> <code class="n">extra_ingredients</code><code class="calibre17">:</code>
        <code class="n">test_database</code><code class="calibre17">.</code><code class="n">add_ingredient</code><code class="calibre17">(</code><code class="n">ingredient</code><code class="calibre17">)</code>

    <code class="c"># assume this function can set up any dish</code>
    <code class="c"># alternatively, dish ingredients could be passed in as a test parameter</code>
    <code class="n">setup_dish_ingredients</code><code class="calibre17">(</code><code class="n">dish_name</code><code class="calibre17">)</code>

    <code class="n">calories</code> <code class="calibre17">=</code> <code class="n">get_calories</code><code class="calibre17">(</code><code class="n">dish_name</code><code class="calibre17">)</code>

    <code class="k">assert</code> <code class="n">calories</code> <code class="calibre17">==</code> <code class="n">expected_calories</code></pre>

<p class="author1">You define your parameters as a list of tuples, one per test case. Each parameter is passed to the test case as an argument. <code class="calibre17">pytest</code> automatically will run this test, once per parameter set.</p>

<p class="author1">Parameterized tests have the benefit of condensing a lot of test cases into one function. Readers of the test can just go down through the table listed in the parameterization to understand what expected input and output is (Cobb salad should have 1,000 calories, mashed potatoes should have 400 calories, and so on).</p>
<div data-type="warning" epub:type="warning" class="calibre23"><h6 class="calibre24">Warning</h6>
<p class="author1">Parameterization is a great way to separate the test data from the actual test (similar to separating policy and mechanisms, as discussed in <a data-type="xref" href="part0022_split_000.html#composability" class="calibre5">Chapter 17</a>). However, be careful. If you make your tests too generic, it will be harder to ascertain what they are testing. Avoid using more than three or four parameters if you can.<a data-type="indexterm" data-primary="act stage (AAA testing)" data-startref="ix_act" id="idm45644726378696" class="calibre5"/><a data-type="indexterm" data-primary="AAA testing" data-secondary="act stage" data-startref="ix_AAAact" id="idm45644726377752" class="calibre5"/></p>
</div>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Assert" class="preface"><div class="preface" id="idm45644726376280">
<h3 class="calibre44">Assert</h3>

<p class="author1">The last step to do before cleaning up is <em class="calibre6">asserting</em> some property is true about the system.<a data-type="indexterm" data-primary="assert step (AAA testing)" id="ix_assrt" class="calibre5"/><a data-type="indexterm" data-primary="AAA testing" data-secondary="assert step" id="ix_AAAass" class="calibre5"/> Preferably, there should be one logical assertion near the end of your test. If you find yourself jamming too many assertions into a test, you either have too many actions in your test or too many tests matched into one. When a test has too many responsibilities, it makes it harder for maintainers to debug software. If they make a change that produces a failed test, you want them to be able to quickly find out what the problem is. Ideally, they can figure out what’s wrong based on the test name, but at the very least, they should be able to open up the test, look for about 20 or 30 <span class="calibre">seconds</span>, and realize what went wrong. If you have multiple assertions, you have multiple reasons a test can go wrong, and it will take maintainers time to sort through them.</p>

<p class="author1">This doesn’t mean that you should only have one <em class="calibre6">assert</em> statement; it is OK to have a few <em class="calibre6">assert</em> statements as long as they are all involved in testing the same property. Make your assertions verbose as well, so that developers get an informative message when things go wrong. In Python, you can supply a text message that gets passed along with the <code class="calibre17">AssertionError</code> to help with debugging.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">test_calorie_calculation_bacon_cheeseburger</code><code class="calibre17">(</code><code class="n">test_database</code><code class="calibre17">):</code>
    <code class="n">test_database</code><code class="calibre17">.</code><code class="n">add_ingredient</code><code class="calibre17">(</code><code class="s">"Bacon"</code><code class="calibre17">,</code> <code class="n">calories_per_pound</code><code class="calibre17">=</code><code class="mi">2400</code><code class="calibre17">)</code>
    <code class="n">setup_bacon_cheeseburger</code><code class="calibre17">(</code><code class="n">bacon</code><code class="calibre17">=</code><code class="s">"Bacon"</code><code class="calibre17">)</code>

    <code class="n">calories</code> <code class="calibre17">=</code> <code class="n">get_calories</code><code class="calibre17">(</code><code class="s">"Bacon Cheeseburger w/ Fries"</code><code class="calibre17">)</code>

    <code class="k">assert</code> <code class="n">calories</code> <code class="calibre17">==</code> <code class="mi">1200</code><code class="calibre17">,</code> <code class="s">"Incorrect calories for Bacon Cheeseburger w/ Fries"</code></pre>

<p class="author1"><code class="calibre17">pytest</code> rewrites assertion statements, which also provides an extra level of debug messages. If the above test were to fail, the message returned to the test writer would be:</p>

<pre data-type="programlisting" class="calibre35">E       AssertionError: Incorrect calories for Bacon Cheeseburger w/ Fries
E       assert 1100 == 1200</pre>

<p class="author1">For more complex assertions, build up an assertion library that makes it incredibly easy to define new tests. This is like building a vocabulary in your codebase; you want a diverse set of concepts to share in your test code as well.<a data-type="indexterm" data-primary="Hamcrest matchers" id="idm45644726343112" class="calibre5"/> For this, I recommend using <a href="http://hamcrest.org" class="calibre5">Hamcrest matchers</a>.<sup class="calibre11"><a data-type="noteref" id="idm45644726341656-marker" href="part0027_split_007.html#idm45644726341656" class="calibre5">5</a></sup></p>

<p class="author1"><em class="calibre6">Hamcrest matchers</em> are a way of writing assertions to read similarly to natural language. The <a href="https://github.com/hamcrest/PyHamcrest" class="calibre5"><code class="calibre17">PyHamcrest</code></a> library supplies common matchers to help you write your asserts.<a data-type="indexterm" data-primary="PyHamcrest" id="idm45644726263736" class="calibre5"/> Take a look at how it uses custom assertion matchers to make tests more clear:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">hamcrest</code> <code class="k">import</code> <code class="n">assert_that</code><code class="calibre17">,</code> <code class="n">matches_regexp</code><code class="calibre17">,</code> <code class="n">is_</code><code class="calibre17">,</code> <code class="n">empty</code><code class="calibre17">,</code> <code class="n">equal_to</code>
<code class="k">def</code> <code class="nf">test_all_menu_items_are_alphanumeric</code><code class="calibre17">():</code>
    <code class="n">menu</code> <code class="calibre17">=</code> <code class="n">create_menu</code><code class="calibre17">()</code>
    <code class="k">for</code> <code class="n">item</code> <code class="calibre19">in</code> <code class="n">menu</code><code class="calibre17">:</code>
        <code class="n">assert_that</code><code class="calibre17">(</code><code class="n">item</code><code class="calibre17">,</code> <code class="n">matches_regexp</code><code class="calibre17">(</code><code class="calibre17">r</code><code class="s">'[a-zA-Z0-9 ]'</code><code class="calibre17">))</code>

<code class="k">def</code> <code class="nf">test_getting_calories</code><code class="calibre17">():</code>
    <code class="n">dish</code> <code class="calibre17">=</code> <code class="s">"Bacon Cheeseburger w/ Fries"</code>
    <code class="n">calories</code> <code class="calibre17">=</code> <code class="n">get_calories</code><code class="calibre17">(</code><code class="n">dish</code><code class="calibre17">)</code>
    <code class="n">assert_that</code><code class="calibre17">(</code><code class="n">calories</code><code class="calibre17">,</code> <code class="n">is_</code><code class="calibre17">(</code><code class="n">equal_to</code><code class="calibre17">(</code><code class="mi">1200</code><code class="calibre17">)))</code>

<code class="k">def</code> <code class="nf">test_no_restaurant_found_in_non_matching_areas</code><code class="calibre17">():</code>
    <code class="n">city</code> <code class="calibre17">=</code> <code class="s">"Huntsville, AL"</code>
    <code class="n">restaurants</code> <code class="calibre17">=</code> <code class="n">find_owned_restaurants_in</code><code class="calibre17">(</code><code class="n">city</code><code class="calibre17">)</code>
    <code class="n">assert_that</code><code class="calibre17">(</code><code class="n">restaurants</code><code class="calibre17">,</code> <code class="n">is_</code><code class="calibre17">(</code><code class="n">empty</code><code class="calibre17">()))</code></pre>

<p class="author1">The real strength of <code class="calibre17">PyHamcrest</code> is that you can define your own matchers.<sup class="calibre11"><a data-type="noteref" id="idm45644726260312-marker" href="part0027_split_007.html#idm45644726260312" class="calibre5">6</a></sup> Here’s an<a data-type="indexterm" data-primary="PyHamcrest" data-secondary="matcher for checking if dish is vegan" id="idm45644726162856" class="calibre5"/> example of a matcher for checking if a dish is vegan:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">hamcrest.core.base_matcher</code> <code class="k">import</code> <code class="n">BaseMatcher</code>
<code class="k">from</code> <code class="nn">hamcrest.core.helpers.hasmethod</code> <code class="k">import</code> <code class="n">hasmethod</code>

<code class="k">def</code> <code class="nf">is_vegan</code><code class="calibre17">(</code><code class="n">ingredient</code><code class="calibre17">:</code> <code class="nb">str</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">bool</code><code class="calibre17">:</code>
    <code class="k">return</code> <code class="n">ingredient</code> <code class="calibre19">not</code> <code class="calibre19">in</code> <code class="calibre17">[</code><code class="s">"Beef Burger"</code><code class="calibre17">]</code>

<code class="k">class</code> <code class="nc">IsVegan</code><code class="calibre17">(</code><code class="n">BaseMatcher</code><code class="calibre17">):</code>

    <code class="k">def</code> <code class="nf">_matches</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">dish</code><code class="calibre17">):</code>
        <code class="k">if</code> <code class="calibre19">not</code> <code class="n">hasmethod</code><code class="calibre17">(</code><code class="n">dish</code><code class="calibre17">,</code> <code class="s">"ingredients"</code><code class="calibre17">):</code>
            <code class="k">return</code> <code class="nb">False</code>
        <code class="k">return</code> <code class="nb">all</code><code class="calibre17">(</code><code class="n">is_vegan</code><code class="calibre17">(</code><code class="n">ingredient</code><code class="calibre17">)</code> <code class="k">for</code> <code class="n">ingredient</code> <code class="calibre19">in</code> <code class="n">dish</code><code class="calibre17">.</code><code class="n">ingredients</code><code class="calibre17">())</code>

    <code class="k">def</code> <code class="nf">describe_to</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">description</code><code class="calibre17">):</code>
        <code class="n">description</code><code class="calibre17">.</code><code class="n">append_text</code><code class="calibre17">(</code><code class="s">"Expected dish to be vegan"</code><code class="calibre17">)</code>

    <code class="k">def</code> <code class="nf">describe_mismatch</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">dish</code><code class="calibre17">,</code> <code class="n">description</code><code class="calibre17">):</code>
        <code class="n">message</code> <code class="calibre17">=</code> <code class="n">f</code><code class="s">"the following ingredients are not vegan: "</code>
        <code class="n">message</code> <code class="calibre17">+=</code> <code class="s">", "</code><code class="calibre17">.</code><code class="n">join</code><code class="calibre17">(</code><code class="n">ing</code> <code class="k">for</code> <code class="n">ing</code> <code class="calibre19">in</code> <code class="n">dish</code><code class="calibre17">.</code><code class="n">ingredients</code><code class="calibre17">()</code>
                             <code class="k">if</code> <code class="calibre19">not</code> <code class="n">is_vegan</code><code class="calibre17">(</code><code class="n">ing</code><code class="calibre17">))</code>
        <code class="n">description</code><code class="calibre17">.</code><code class="n">append_text</code><code class="calibre17">(</code><code class="n">message</code><code class="calibre17">)</code>


<code class="k">def</code> <code class="nf">vegan</code><code class="calibre17">():</code>
    <code class="k">return</code> <code class="n">IsVegan</code><code class="calibre17">()</code>


<code class="k">from</code> <code class="nn">hamcrest</code> <code class="k">import</code> <code class="n">assert_that</code><code class="calibre17">,</code> <code class="n">is_</code>
<code class="k">def</code> <code class="nf">test_vegan_substitution</code><code class="calibre17">():</code>
    <code class="n">dish</code> <code class="calibre17">=</code> <code class="n">create_dish</code><code class="calibre17">(</code><code class="s">"Hamburger and Fries"</code><code class="calibre17">)</code>
    <code class="n">dish</code><code class="calibre17">.</code><code class="n">make_vegan</code><code class="calibre17">()</code>
    <code class="n">assert_that</code><code class="calibre17">(</code><code class="n">dish</code><code class="calibre17">,</code> <code class="n">is_</code><code class="calibre17">(</code><code class="n">vegan</code><code class="calibre17">()))</code></pre>

<p class="author1">If the test fails, you get the following error:</p>

<pre data-type="programlisting" class="calibre35">    def test_vegan_substitution():
        dish = create_dish("Hamburger and Fries")
        dish.make_vegan()
&gt;       assert_that(dish, is_(vegan()))
E       AssertionError:
E       Expected: Expected dish to be vegan
E            but: the following ingredients are not vegan: Beef Burger</pre>
</div></section>



</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 21. Testing Strategy" class="preface">
<div class="preface" id="testing_strategy">
<section data-type="sect1" data-pdf-bookmark="Reducing Test Cost" class="preface">
<div class="preface" id="idm45644727460520">
<section data-type="sect2" data-pdf-bookmark="AAA Testing" class="preface">
<div class="preface" id="idm45644727213864">
<section data-type="sect3" data-pdf-bookmark="Assert" class="preface">
<div class="preface" id="idm45644726376280">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_6">Discussion Topic</h1>
<p class="author1">Where in your tests can you use custom matchers? Discuss what a shared testing vocabulary would be in your tests and how custom matchers would improve readability.<a data-type="indexterm" data-primary="assert step (AAA testing)" data-startref="ix_assrt" id="idm45644725984536" class="calibre5"/><a data-type="indexterm" data-primary="AAA testing" data-secondary="assert step" data-startref="ix_AAAass" id="idm45644725983544" class="calibre5"/><a data-type="indexterm" data-primary="AAA testing" data-startref="ix_AAA" id="idm45644725982328" class="calibre5"/></p>
</div>
</div></section>



</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 21. Testing Strategy" class="preface">
<div class="preface" id="testing_strategy">
<section data-type="sect1" data-pdf-bookmark="Closing Thoughts" class="preface"><div class="preface" id="idm45644725981128">
<h1 class="calibre12" id="calibre_pb_7">Closing Thoughts</h1>

<p class="author1">Just like a tightrope walker’s safety net, tests give you comfort and confidence as you work. <a data-type="indexterm" data-primary="testing" data-secondary="reducing test cost" data-startref="ix_tststred" id="idm45644725979448" class="calibre5"/>It’s not just about finding bugs. Tests verify that what you build is performing as you expect. They give future collaborators leeway to make more risky changes; they know that if they fall, the tests will catch them. You will find that regressions become more rare, and your codebase becomes easier to work in.</p>

<p class="author1">However, tests are not free. There is a cost to writing, running, and maintaining them. You need to be careful how you spend your time and effort. Use well-known patterns in constructing tests to minimize the cost: follow the AAA pattern, keep each stage small, and make your tests clear and readable. Your tests are just as important as your codebase. Treat them with just as much respect and make them robust.</p>

<p class="author1">In the next chapter, I will focus on acceptance tests. Acceptance tests have a different purpose than unit or integration tests, and some of the patterns you use will differ.</p>

<p class="author1">You will learn about how acceptance tests create conversations, as well as how they make sure your codebase is doing the right thing for your customers. They are an invaluable tool for your codebase in delivering value.<a data-type="indexterm" data-primary="testing" data-startref="ix_tstst" id="idm45644725975656" class="calibre5"/></p>
</div></section>







<div data-type="footnotes" class="calibre25"><p data-type="footnote" id="idm45644727274344" class="calibre26"><sup class="calibre27"><a href="part0027_split_002.html#idm45644727274344-marker" class="calibre5">1</a></sup> Edsger W. Dijkstra. “Notes on Structured Programming.” Technological University Eindhoven, The Netherlands, Department of Mathematics, 1970. <a href="https://oreil.ly/NAhWf" class="calibre5"><em class="calibre6">https://oreil.ly/NAhWf</em></a>.</p><p data-type="footnote" id="idm45644727268952" class="calibre26"><sup class="calibre27"><a href="part0027_split_002.html#idm45644727268952-marker" class="calibre5">2</a></sup> Gerald M. Weinberg. <em class="calibre6">Quality Software Management</em>. Vol. 1: <em class="calibre6">Systems Thinking</em>. New York, NY: Dorset House Publishing, 1992.</p><p data-type="footnote" id="idm45644727260312" class="calibre26"><sup class="calibre27"><a href="part0027_split_002.html#idm45644727260312-marker" class="calibre5">3</a></sup> This is known as the testing pyramid, introduced in <em class="calibre6">Succeeding with Agile</em> by Mike Cohn (Addison-Wesley Professional). Cohn originally has “Service” level tests in place of integration tests, but I’ve seen more iterations with “integration” tests as the middle layer.</p><p data-type="footnote" id="idm45644727210584" class="calibre26"><sup class="calibre27"><a href="part0027_split_005.html#idm45644727210584-marker" class="calibre5">4</a></sup> The AAA pattern was first named by Bill Wake in 2001. Check out <a href="https://oreil.ly/gdU4T" class="calibre5">this blog post</a> for more information.</p><p data-type="footnote" id="idm45644726341656" class="calibre26"><sup class="calibre27"><a href="part0027_split_005.html#idm45644726341656-marker" class="calibre5">5</a></sup> Hamcrest is an anagram of “matchers.”</p><p data-type="footnote" id="idm45644726260312" class="calibre26"><sup class="calibre27"><a href="part0027_split_005.html#idm45644726260312-marker" class="calibre5">6</a></sup> Check out the <a href="https://oreil.ly/XWjOd" class="calibre5">PyHamcrest documentation</a> for more information, such as additional matchers or integrating with test frameworks.</p></div></div></section></body></html>