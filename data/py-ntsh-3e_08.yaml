- en: Chapter 8\. Core Built-ins and Standard Library Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章\. 核心内置和标准库模块
- en: The term *built-in* has more than one meaning in Python. In many contexts, *built-in*
    means an object directly accessible to Python code without an **import** statement.
    The section [“Python built-ins”](ch07.xhtml#python_built_ins) shows Python’s mechanism
    to allow this direct access. Built-in types in Python include numbers, sequences,
    dictionaries, sets, functions (all covered in [Chapter 3](ch03.xhtml#the_python_language)),
    classes (covered in [“Python Classes”](ch04.xhtml#python_classes)), standard exception
    classes (covered in [“Exception Objects”](ch06.xhtml#exception_objects)), and
    modules (covered in [“Module Objects”](ch07.xhtml#module_objects)). [“The io Module”](ch11.xhtml#the_io_module)
    covers the file type, and [“Internal Types”](ch14.xhtml#internal_types) some other
    built-in types intrinsic to Python’s internal operation. This chapter provides
    additional coverage of built-in core types in the opening section and covers built-in
    functions available in the module builtins in [“Built-in Functions”](#built_in_functions).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*内置*在 Python 中有多个含义。在许多上下文中，*内置*意味着一个对象可以直接在 Python 代码中访问，而无需**import**语句。[“Python
    内置对象”](ch07.xhtml#python_built_ins)节展示了 Python 允许这种直接访问的机制。Python 中的内置类型包括数字、序列、字典、集合、函数（所有在[第 3
    章](ch03.xhtml#the_python_language)中讨论）、类（在[“Python 类”](ch04.xhtml#python_classes)中讨论）、标准异常类（在[“异常对象”](ch06.xhtml#exception_objects)中讨论）和模块（在[“模块对象”](ch07.xhtml#module_objects)中讨论）。[“io
    模块”](ch11.xhtml#the_io_module)涵盖了文件类型，而[“内部类型”](ch14.xhtml#internal_types)涵盖了
    Python 内部操作的一些其他内置类型。本章在开篇部分提供了内置核心类型的额外覆盖，并在[“内置函数”](#built_in_functions)中介绍了模块
    builtins 中可用的内置函数。
- en: Some modules are called “built-in” because they’re in the Python standard library
    (though it takes an **import** statement to use them), as opposed to add-on modules,
    also known as Python *extensions*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模块被称为“内置”，因为它们位于 Python 标准库中（尽管需要**import**语句才能使用），而不是附加模块，也称为 Python *扩展*。
- en: 'This chapter covers several built-in core modules: namely, the standard library
    modules sys, copy, collections, functools, heapq, argparse, and itertools. You’ll
    find a discussion of each module *x* in the respective section “The *x* Module.”'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了几个内置核心模块：即标准库模块 sys、copy、collections、functools、heapq、argparse 和 itertools。您将在各自部分“*x*
    模块”中找到对每个模块 *x* 的讨论。
- en: '[Chapter 9](ch09.xhtml#strings_and_things) covers some string-related built-in
    core modules (string, codecs, and unicodedata) with the same section-name convention.
    [Chapter 10](ch10.xhtml#regular_expressions) covers re in [“Regular Expressions
    and the re Module”](ch10.xhtml#regular_expressions_and_the_re_module).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 9 章](ch09.xhtml#strings_and_things)涵盖了一些与字符串相关的内置核心模块（string、codecs 和 unicodedata），采用相同的部分名称约定。[第 10
    章](ch10.xhtml#regular_expressions)介绍了 re 模块在[“正则表达式和 re 模块”](ch10.xhtml#regular_expressions_and_the_re_module)中的使用。'
- en: Built-in Types
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置类型
- en: '[Table 8-1](#pythonapostrophes_core_built_in_types) provides a brief overview
    of Python’s core built-in types. More details about many of these types, and about
    operations on their instances, are found throughout [Chapter 3](ch03.xhtml#the_python_language).
    In this section, by “any number” we mean, specifically, “any noncomplex number.”
    Also, many built-ins accept at least some of their parameters in a positional-only
    way; we use the 3.8+ positional-only marker /, covered in [“Positional-only marker”](ch03.xhtml#positional_only_marker),
    to indicate this.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-1](#pythonapostrophes_core_built_in_types)提供了 Python 核心内置类型的简要概述。关于这些类型的许多细节以及关于其实例操作的详细信息可以在整个[第 3
    章](ch03.xhtml#the_python_language)中找到。在本节中，“任意数字”特指“任意非复数数字”。此外，许多内置函数至少以某些参数的位置方式接受参数；我们使用
    3.8+ 的位置限定符 /，在[“位置限定符”](ch03.xhtml#positional_only_marker)中进行了介绍。'
- en: Table 8-1\. Python’s core built-in types
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1\. Python 核心内置类型
- en: '| bool | bool(*x*=**False**, /) Returns **False** when *x* evaluates as falsy;
    returns **True** when *x* evaluates as truthy (see [“Boolean Values”](ch03.xhtml#boolean_values)).
    bool extends int: the built-in names **False** and **True** refer to the only
    two instances of bool. These instances are also ints equal to 0 and 1, respectively,
    but str(**True**) is ''True'' and str(**False**) is ''False''. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| bool | bool(*x*=**False**, /) 当 *x* 评估为假时返回**False**；当 *x* 评估为真时返回**True**（参见[“布尔值”](ch03.xhtml#boolean_values)）。bool
    扩展自 int：内置名称**False**和**True**分别指 bool 的唯一两个实例。这些实例也是等于 0 和 1 的 int，但 str(**True**)
    是 ''True''，str(**False**) 是 ''False''。 |'
- en: '| bytearray | bytearray(*x*=b'''', /[, codec[, errors]]) Returns a mutable
    sequence of bytes (ints with values from 0 to 255), supporting the usual methods
    of mutable sequences, plus the methods of str. When *x* is a str, you must also
    pass codec and may pass errors; the result is just like calling bytearray(*x*.encode(codec,
    errors)). When *x* is an int, it must be >=0: the resulting instance has a length
    of *x*, and each item is initialized to 0. When *x* conforms to the [buffer protocol](https://oreil.ly/HlOmv),
    the read-only buffer of bytes from *x* initializes the instance. Otherwise, *x*
    must be an iterable yielding ints >=0 and <256; e.g., bytearray([1,2,3,4]) ==
    bytearray(b''\x01\x02\x03\x04''). |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| bytearray | bytearray(*x*=b'''', /[, codec[, errors]]) 返回一个可变的字节序列（值为0到255的int），支持可变序列的通常方法，以及str的方法。当*x*是一个str时，您还必须传递codec并可能传递errors；结果就像调用bytearray(*x*.encode(codec,
    errors))一样。当*x*是一个int时，它必须>=0：生成的实例的长度为*x*，并且每个项目都初始化为0。当*x*符合[缓冲区协议](https://oreil.ly/HlOmv)时，从*x*读取的只读字节缓冲区初始化实例。否则，*x*必须是一个产生int
    >=0且<256的可迭代对象；例如，bytearray([1,2,3,4]) == bytearray(b''\x01\x02\x03\x04'')。 |'
- en: '| bytes | bytes(*x*=b'''', /[, codec[, errors]]) Returns an immutable sequence
    of bytes, with the same nonmutating methods and the same initialization behavior
    as bytearray. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| bytes | bytes(*x*=b'''', /[, codec[, errors]]) 返回一个不可变的字节序列，具有与bytearray相同的非变异方法和相同的初始化行为。
    |'
- en: '| complex | complex(real=0, imag=0) Converts any number, or a suitable string,
    to a complex number. imag may be present only when real is a number, and in that
    case imag is also a number: the imaginary part of the resulting complex number.
    See also [“Complex numbers”](ch03.xhtml#complex_numbers). |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| complex | complex(*real*=0, *imag*=0) 将任何数字或适当的字符串转换为复数。当*real*是一个数字时，*imag*可以存在，并且在这种情况下*imag*也是一个数字：生成的复数的虚部。另请参阅[“复数”](ch03.xhtml#complex_numbers)。
    |'
- en: '| dict | dict(*x*={}, /) Returns a new dictionary with the same items as *x*.
    (We cover dictionaries in [“Dictionaries”](ch03.xhtml#dictionaries).) When *x*
    is a dict, dict(*x*) returns a shallow copy of *x*, like *x*.copy(). Alternatively,
    *x* can be an iterable whose items are pairs (iterables with two items each).
    In this case, dict(*x*) returns a dictionary whose keys are the first items of
    each pair in *x*, and whose values are the corresponding second items. When a
    key appears more than once in *x*, Python uses the value corresponding to the
    last occurrence of the key. In other words, when *x* is any iterable yielding
    pairs, *c* = dict(*x*) is exactly equivalent to:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '| dict | dict(*x*={}, /) 返回一个具有与*x*相同项目的新字典。（我们在[“字典”](ch03.xhtml#dictionaries)中介绍字典。）当*x*是一个字典时，dict(*x*)返回*x*的浅拷贝，就像*x*.copy()一样。另外，*x*可以是一个其项目为成对项（每个项为两个项目的可迭代对象）的可迭代对象。在这种情况下，dict(*x*)返回一个字典，其键是*x*中每对的第一个项目，其值是对应的第二个项目。当*x*中的键出现多次时，Python使用与键的最后一次出现对应的值。换句话说，当*x*是任何产生成对项的可迭代对象时，*c*
    = dict(*x*)与以下等效：'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also call dict with named arguments, in addition to, or instead of,
    positional argument *x*. Each named argument becomes an item in the dictionary,
    with the name as the key: each such extra item might “overwrite” an item from
    *x*. |'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用命名参数调用dict，除了或代替位置参数*x*。每个命名参数都成为字典中的一项，名称作为键：这样的额外项可能会“覆盖”*x*中的一项。
- en: '| float | float(*x*=0.0, /) Converts any number, or a suitable string, to a
    floating-point number. See [“Floating-point numbers”](ch03.xhtml#floating_point_numbers).
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| float | float(*x*=0.0, /) 将任何数字或适当的字符串转换为浮点数。参见[“浮点数”](ch03.xhtml#floating_point_numbers)。
    |'
- en: '| frozenset | frozenset(*seq*=(), /) Returns a new frozen (i.e., immutable)
    set object with the same items as iterable *seq*. When *seq* is a frozenset, frozenset(*seq*)
    returns *seq* itself, just like *seq*.copy() does. See [“Set Operations”](ch03.xhtml#set_operation).
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| frozenset | frozenset(*seq*=(), /) 返回一个新的冻结（即不可变）集合对象，其包含与可迭代对象*seq*相同的项目。当*seq*是一个frozenset时，frozenset(*seq*)返回*seq*本身，就像*seq*.copy()一样。另请参阅[“集合操作”](ch03.xhtml#set_operation)。
    |'
- en: '| int | int(*x*=0, /, base=10) Converts any number, or a suitable string, to
    an int. When *x* is a number, int truncates toward 0, “dropping” any fractional
    part. base may be present only when *x* is a string: then, base is the conversion
    base, between 2 and 36, with 10 as the default. You can explicitly pass base as
    0: the base is then 2, 8, 10, or 16, depending on the form of string *x*, just
    like for integer literals, as covered in [“Integer numbers”](ch03.xhtml#integer_numbers).
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| int | int(*x*=0, /, base=10) 将任何数字或适当的字符串转换为整数。当 *x* 是一个数字时，int 朝向 0 截断，“舍弃”任何小数部分。当
    *x* 是一个字符串时，base 可能存在：然后，base 是转换基数，介于 2 和 36 之间，其中 10 是默认值。你可以显式地将 base 传递为 0：然后，基数为
    2、8、10 或 16，具体取决于字符串 *x* 的形式，就像对整数字面值一样，如[“整数”](ch03.xhtml#integer_numbers)中所述。'
- en: '| list | list(*seq*=(), /) Returns a new list object with the same items as
    iterable *seq*, in the same order. When *seq* is a list, list(*seq*) returns a
    shallow copy of *seq*, like *seq*[:]. See [“Lists”](ch03.xhtml#list). |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| list | list(*seq*=(), /) 返回一个具有与可迭代对象 *seq* 相同项、相同顺序的新列表对象。当 *seq* 是一个列表时，list(*seq*)
    返回 *seq* 的一个浅拷贝，就像 *seq*[:] 一样。请参见[“列表”](ch03.xhtml#list)。'
- en: '| memoryview | memoryview(*x*, /) Returns an object *m* “viewing” exactly the
    same underlying memory as *x*, which must be an object supporting the [buffer
    protocol](https://oreil.ly/HlOmv) (for example, an instance of bytes, bytearray,
    or array.array), with items of *m*.itemsize bytes each. In the normal case in
    which *m* is “one-dimensional” (we don’t cover the complicated case of “multidimensional”
    memoryview instances in this book), len(*m*) is the number of items. You can index
    *m* (returning int) or slice it (returning an instance of memoryview “viewing”
    the appropriate subset of the same underlying memory). *m* is mutable when *x*
    is (but you can’t change *m*’s size, so, when you assign to a slice, it must be
    from an iterable of the same length as the slice). *m* is a sequence, thus iterable,
    and is hashable when *x* is hashable and when *m*.itemsize is one byte.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '| memoryview | memoryview(*x*, /) 返回一个对象 *m*，“查看”与 *x* 完全相同的底层内存，*x* 必须是支持[缓冲区协议](https://oreil.ly/HlOmv)的对象（例如
    bytes、bytearray 或 array.array 的实例），每个 *m*.itemsize 字节的项目。在 *m* 是“一维”的普通情况下（本书不涵盖“多维”memoryview
    实例的复杂情况），len(*m*) 是项目数。你可以对 *m* 进行索引（返回 int）或对其进行切片（返回“查看”相同底层内存的适当子集的 memoryview
    实例）。当 *x* 是可变的时，*m* 也是可变的（但你不能改变 *m* 的大小，所以，当你对一个切片赋值时，它必须来自与切片相同长度的可迭代对象）。*m*
    是一个序列，因此可迭代，并且在 *x* 是可散列且 *m*.itemsize 是一个字节时是可散列的。'
- en: '*m* supplies several read-only attributes and methods; see the [online docs](https://oreil.ly/SIsvF)
    for details. Two particularly useful methods are *m*.tobytes (returns *m*’s data
    as an instance of bytes) and *m*.tolist (returns *m*’s data as a list of ints).
    |'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*m* 提供了几个只读属性和方法；详细信息请参见[在线文档](https://oreil.ly/SIsvF)。两个特别有用的方法是 *m*.tobytes（将
    *m* 的数据作为 bytes 实例返回）和 *m*.tolist（将 *m* 的数据作为整数列表返回）。'
- en: '| object | object() Returns a new instance of object, the most fundamental
    type in Python. Instances of type object have no functionality: the only use of
    such instances is as “sentinels”—i.e., objects not equal to any distinct object.
    For instance, when a function takes an optional argument where **None** is a legitimate
    value, you can use a sentinel for the argument’s default value to indicate that
    the argument was omitted:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '| object | object() 返回一个新的 object 实例，Python 中最基本的类型。类型为 object 的实例没有功能：这些实例的唯一用途是作为“哨兵”——即不等于任何不同对象的对象。例如，当函数接受一个可选参数，其中
    **None** 是一个合法值时，你可以使用哨兵作为参数的默认值来指示参数被省略了：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| set | set(*seq*=(), /) Returns a new mutable set object with the same items
    as iterable *seq*. When *seq* is a set, set(*seq*) returns a shallow copy of *seq*,
    like *seq*.copy(). See [“Sets”](ch03.xhtml#sets). |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| set | set(*seq*=(), /) 返回一个具有与可迭代对象 *seq* 相同项的新的可变集合对象。当 *seq* 是一个集合时，set(*seq*)
    返回 *seq* 的一个浅拷贝，就像 *seq*.copy() 一样。请参见[“集合”](ch03.xhtml#sets)。'
- en: '| slice | slice([start, ]stop[, step], /) Returns a slice object with the read-only
    attributes start, stop, and step bound to the respective argument values, each
    defaulting to **None** when missing. For positive indices, such a slice signifies
    the same indices as range(start, stop, step). Slicing syntax, *obj*[start:stop:step],
    passes a slice object as the argument to the __getitem__, __setitem__, or __delitem__
    method of object *obj*. It is up to *obj*’s class to interpret the slices that
    its methods receive. See also [“Container slicing”](ch04.xhtml#container_slicing).
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| slice | slice([start, ]stop[, step], /) 返回具有只读属性start、stop和step绑定到相应参数值的切片对象，当缺少时，默认为**None**。对于正索引，这样的切片表示与range(start,
    stop, step)相同的索引。切片语法，*obj*[start:stop:step]，将切片对象作为参数传递给对象*obj*的__getitem__、__setitem__或__delitem__方法。由*obj*的类来解释其方法接收的切片。还请参见“容器切片”。
    |'
- en: '| str | str(*obj*='''', /) Returns a concise, readable string representation
    of *obj*. If *obj* is a string, str returns *obj*. See also repr in [Table 8-2](#pythonapostrophes_core_built_in_functio)
    and __str__ in [Table 4-1](ch04.xhtml#general_purpose_special_methods). |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| str | str(*obj*='''', /) 返回*obj*的简明可读字符串表示。如果*obj*是字符串，则str返回*obj*。还请参见表8-2中的repr和表4-1中的__str__。
    |'
- en: '| super | super(), super(*cls*, *obj*, /) Returns a superobject of object *obj*
    (which must be an instance of class *cls* or of any subclass of *cls*), suitable
    for calling superclass methods. Instantiate this built-in type only within a method’s
    code. The super(*cls*, *obj*) syntax is a legacy form from Python 2 that has been
    retained for compatibility. In new code, you usually call super() without arguments,
    within a method, and Python determines the *cls* and *obj* by introspection (as
    type(self) and self, respectively). See [“Cooperative superclass method calling”](ch04.xhtml#cooperative_superclass_method_calling).
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| super | super(), super(*cls*, *obj*, /) 返回对象*obj*的超级对象（*obj*必须是类*cls*或任何*cls*子类的实例），适合调用超类方法。只在方法代码内实例化此内建类型。super(*cls*,
    *obj*)语法是Python 2中保留的遗留形式，用于兼容性。在新代码中，通常在方法内部调用super()而不带参数，Python通过内省（如type(self)和self分别确定*cls*和*obj*）。参见“协作超类方法调用”。
    |'
- en: '| tuple | tuple(*seq*=(), /) Returns a tuple with the same items as iterable
    *seq*, in order. When *seq* is a tuple, tuple returns *seq* itself, like *seq*[:].
    See [“Tuples”](ch03.xhtml#tuple). |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| tuple | tuple(*seq*=(), /) 返回具有与可迭代对象*seq*中相同项目的元组，顺序相同。当*seq*是元组时，tuple返回*seq*本身，类似于*seq*[:]。参见“元组”。
    |'
- en: '| type | type(*obj*, /) Returns the type object that is the type of *obj* (i.e.,
    the most-derived, aka *leafmost*, type of which *obj* is an instance). type(*x*)
    is the same as *x*.__class__ for any *x*. Avoid checking equality or identity
    of types (see the following warning for details). This function is commonly used
    for debugging; for example, when value *x* does not behave as expected, inserting
    print(type(*x*), *x*). It can also be used to dynamically create classes at runtime,
    as described in [Chapter 4](ch04.xhtml#object_oriented_python). |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| type | type(*obj*, /) 返回类型对象，即*obj*的类型（即*obj*是实例的最终类型，也称为*leafmost*类型）。对于任何*x*，type(*x*)与*x*.__class__相同。避免检查类型的相等性或身份（详情请参阅下面的警告）。这个函数通常用于调试；例如，当值*x*的行为不如预期时，插入print(type(*x*),
    *x*)。它还可以用于在运行时动态创建类，如第4章中所述。 |'
- en: Built-in Functions
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内建函数
- en: '[Table 8-2](#pythonapostrophes_core_built_in_functio) covers Python functions
    (and some types that, in practice, are only used *as if* they were functions)
    in the module builtins, in alphabetical order. Built-ins’ names are *not* keywords.
    This means you *can* bind, in local or global scope, an identifier that’s a built-in
    name, although we recommend avoiding it (see the following warning!). Names bound
    in local or global scope override names bound in built-in scope, so local and
    global names *hide* built-in ones. You can also rebind names in built-in scope,
    as covered in [“Python built-ins”](ch07.xhtml#python_built_ins).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-2涵盖了Python内建函数（实际上，有些类型仅在*似乎*它们被作为函数使用时）在模块builtins中按字母顺序排列。内建函数的名称*不*是关键字。这意味着您可以在本地或全局作用域中绑定一个标识符作为内建名称，尽管我们建议避免这样做（请参见下面的警告！）。在本地或全局作用域中绑定的名称会覆盖内建作用域中绑定的名称，因此本地和全局名称*隐藏*内建名称。您还可以重新绑定内建作用域中的名称，如“Python内建”中所述。
    |
- en: Don’t Hide Built-ins
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要隐藏内建函数
- en: 'Avoid accidentally hiding built-ins: your code might need them later. It’s
    often tempting to use natural names such as input, list, or filter for your own
    variables, but *don’t do it*: these are names of built-in Python types or functions,
    and reusing them for your own purposes makes those built-in types and functions
    inaccessible. Unless you get into the habit of *never* hiding built-ins’ names
    with your own, sooner or later you’ll get mysterious bugs in your code caused
    by just such hiding occurring accidentally.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 避免意外隐藏内置函数：你的代码可能后面会用到它们。常常会诱人地使用像input、list或filter这样的自然命名作为你自己变量的名称，但是*不要这样做*：这些都是Python内置类型或函数的名称，如果重复使用它们作为你自己的变量名，会导致这些内置类型和函数无法访问。除非你养成*永远*不用自己的名字隐藏内置函数名的习惯，否则迟早会因为意外隐藏而在代码中遇到神秘的错误。
- en: Many built-in functions cannot be called with named arguments, only with positional
    ones. In [Table 8-2](#pythonapostrophes_core_built_in_functio), we mention cases
    in which this limitation does not hold; when it does, we also use the 3.8+ positional-only
    marker /, covered in [“Positional-only marker”](ch03.xhtml#positional_only_marker).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 许多内置函数只能使用位置参数调用，不能使用命名参数。在[表 8-2](#pythonapostrophes_core_built_in_functio)中，我们提到了这种限制不适用的情况；当适用时，我们还使用了3.8+的位置参数专用标记
    /，详见[“位置参数专用标记”](ch03.xhtml#positional_only_marker)。
- en: Table 8-2\. Python’s core built-in functions
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2\. Python的核心内置函数
- en: '| __import__ | __import__(*module_name*[, *globals*[, *locals*[, *fromlist*]]],
    /) Deprecated in modern Python; use importlib.import_module, covered in [“Module
    Loading”](ch07.xhtml#module_loading). |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| __import__ | __import__(*module_name*[, *globals*[, *locals*[, *fromlist*]]],
    /) 在现代Python中已弃用；请使用importlib.import_module，详见[“模块加载”](ch07.xhtml#module_loading)。
    |'
- en: '| abs | abs(*x*, /) Returns the absolute value of number *x*. When *x* is complex,
    abs returns the square root of *x*.imag ** 2 + *x*.real ** 2 (also known as the
    magnitude of the complex number). Otherwise, abs returns *-x* when *x* < 0, or
    *x* when *x* >= 0. See also __abs__, __invert__, __neg__, and __pos__ in [Table 4-4](ch04.xhtml#abcs_with_additional_methods).
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| abs | abs(*x*, /) 返回数*x*的绝对值。当*x*为复数时，abs返回*x*.imag ** 2 + *x*.real ** 2的平方根（也称为复数的模）。否则，当*x*
    < 0时，abs返回*-x*；当*x* >= 0时，abs返回*x*。详见[表 4-4](ch04.xhtml#abcs_with_additional_methods)中的__abs__、__invert__、__neg__和__pos__。
    |'
- en: '| all | all(*seq*, /) *seq* is an iterable. all returns **False** when any
    item of *seq* is falsy; otherwise, all returns **True**. Like the operators **and**
    and **or**, covered in [“Short-Circuiting Operators”](ch03.xhtml#short_circuiting_operators),
    all stops evaluating and returns a result as soon as it knows the answer; in the
    case of all, this means it stops as soon as a falsy item is reached, but proceeds
    throughout *seq* if all of *seq*’s items are truthy. Here is a typical toy example
    of the use of all:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '| all | all(*seq*, /) *seq*是一个可迭代对象。当*seq*的任何项为假时，all返回**False**；否则，all返回**True**。类似于操作符**and**和**or**，详见[“短路运算符”](ch03.xhtml#short_circuiting_operators)，all在知道答案后立即停止评估并返回结果；对于all来说，这意味着当遇到假值项时停止，但如果*seq*的所有项都为真，则会遍历整个*seq*。下面是all的典型玩具示例：'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When *seq* is empty, all returns **True**. |
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当*seq*为空时，all返回**True**。 |
- en: '| any | any(*seq*, /) *seq* is an iterable. any returns **True** if any item
    of *seq* is truthy; otherwise, any returns **False**. Like the operators **and**
    and **or**, covered in [“Short-Circuiting Operators”](ch03.xhtml#short_circuiting_operators),
    any stops evaluating and returns a result as soon as it knows the answer; in the
    case of any, this means it stops as soon as a truthy item is reached, but proceeds
    throughout *seq* if all of *seq*’s items are falsy. Here is a typical toy example
    of the use of any:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '| any | any(*seq*, /) *seq*是一个可迭代对象。如果*seq*的任何项为真，则any返回**True**；否则，any返回**False**。类似于操作符**and**和**or**，详见[“短路运算符”](ch03.xhtml#short_circuiting_operators)，any在知道答案后立即停止评估并返回结果；对于any来说，这意味着当遇到真值项时停止，但如果*seq*的所有项都为假，则会遍历整个*seq*。下面是any的典型玩具示例：'
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When *seq* is empty, any returns **False**. |
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当*seq*为空时，any返回**False**。 |
- en: '| ascii | ascii(*x*, /) Like repr, but escapes non-ASCII characters in the
    string it returns; the result is usually similar to that of repr. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| ascii | ascii(*x*, /) 类似于repr，但在返回的字符串中转义非ASCII字符；结果通常与repr的结果相似。 |'
- en: '| bin | bin(*x*, /) Returns a binary string representation of integer *x*.
    E.g., bin(23)==''0b10111‘. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| bin | bin(*x*, /) 返回整数*x*的二进制字符串表示。例如，bin(23)==''0b10111‘。 |'
- en: '| breakpoint | breakpoint() Invokes the pdb Python debugger. Set sys.breakpointhook
    to a callable function if you want breakpoint to invoke an alternate debugger.
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| breakpoint | breakpoint() 调用pdb Python调试器。如果要breakpoint调用替代调试器，请将sys.breakpointhook设置为可调用函数。
    |'
- en: '| callable | callable(*obj*, /) Returns **True** when *obj* can be called;
    otherwise, returns **False**. An object can be called if it is a function, method,
    class, or type, or an instance of a class with a __call__ method. See also __call__
    in [Table 4-1](ch04.xhtml#general_purpose_special_methods). |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| callable | callable(*obj*, /) 当*obj*可调用时返回**True**；否则返回**False**。如果对象是函数、方法、类或类型，或者是具有__call__方法的类的实例，则可以调用对象。另请参见[表4-1](ch04.xhtml#general_purpose_special_methods)中的__call__。
    |'
- en: '| chr | chr(*code*, /) Returns a string of length 1, a single character corresponding
    to the integer *code* in Unicode. See also ord later in this table. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| chr | chr(*code*, /) 返回长度为1的字符串，一个与Unicode中整数*code*对应的单个字符。另请参见本表中稍后的ord。
    |'
- en: '| compile | compile(*source*, *filename*, *mode*) Compiles a string and returns
    a code object usable by exec or eval. compile raises SyntaxError when *source*
    is not syntactically valid Python. When *source* is a multiline compound statement,
    the last character must be ''\n''. *mode* must be ''eval'' when *source* is an
    expression and the result is meant for eval; otherwise, *mode* must be ''exec''
    (for a single or multiple-statement string) or ''single'' (for a string containing
    a single statement) when the string is meant for exec. *filename* must be a string,
    used only in error messages (if an error occurs). See also eval later in this
    table, and [“compile and Code Objects”](ch14.xhtml#compile_and_code_objects).
    (compile also takes the optional arguments flags, dont_inherit, optimize, and
    **3.11+** _feature_version, though these are rarely used; see the [online documentation](https://oreil.ly/oYj2U)
    for more information on these arguments.) |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| compile | compile(*source*, *filename*, *mode*) 编译字符串并返回可供exec或eval使用的代码对象。当*source*不是Python语法上有效时，compile会引发SyntaxError。当*source*是多行复合语句时，最后一个字符必须为''\n''。当*source*是表达式且结果用于eval时，*mode*必须为''eval''；否则，当字符串用于exec时，*mode*必须为''exec''（对于单个或多个语句字符串）或''single''（对于包含单个语句的字符串）。*filename*必须是一个字符串，仅在出现错误消息时使用（如果发生错误）。另请参见本表中稍后的eval，以及[“编译和代码对象”](ch14.xhtml#compile_and_code_objects)。
    （compile还接受可选参数flags、dont_inherit、optimize和**3.11+** _feature_version，尽管这些很少使用；有关这些参数的更多信息，请参见[在线文档](https://oreil.ly/oYj2U)。）
    |'
- en: '| delattr | delattr(*obj*, *name*, /) Removes the attribute *name* from *obj*.
    delattr(*obj*, ''*ident*'') is like del *obj.ident**.* If *obj* has an attribute
    named *name* just because its class has it (as is normally the case, for example,
    for *methods* of *obj*), you cannot delete that attribute from *obj* itself. You
    may be able to delete that attribute from the *class*, if the metaclass lets you.
    If you can delete the class attribute, *obj* ceases to have the attribute, and
    so does every other instance of that class. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| delattr | delattr(*obj*, *name*, /) 从*obj*中移除属性*name*。delattr(*obj*, ''*ident*'')类似于del
    *obj.ident**。如果*obj*具有名为*name*的属性，仅因为其类具有该属性（通常情况下，例如，对于*obj*的*方法*），则无法从*obj*本身删除该属性。如果元类允许，您可以从*类*中删除该属性。如果您可以删除类属性，则*obj*将不再具有该属性，该类的每个其他实例也是如此。
    |'
- en: '| dir | dir([*obj*, ]/) Called without arguments, dir returns a sorted list
    of all variable names that are bound in the current scope. dir(*obj*) returns
    a sorted list of names of attributes of *obj*, including ones coming from *obj*’s
    type or by inheritance. See also vars later in this table. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| dir | dir([*obj*, ]/) 不带参数调用时，dir返回当前作用域中绑定的所有变量名的排序列表。dir(*obj*)返回一个排序后的*obj*属性名称列表，其中包括来自*obj*类型或通过继承的属性。另请参见本表中稍后的vars。
    |'
- en: '| divmod | divmod(*dividend*, *divisor*, /) Divides two numbers and returns
    a pair whose items are the quotient and remainder. See also __divmod__ in [Table 4-4](ch04.xhtml#abcs_with_additional_methods).
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| divmod | divmod(*dividend*, *divisor*, /) 计算两个数的商和余数，并返回一对。另请参见[表4-4](ch04.xhtml#abcs_with_additional_methods)中的__divmod__。
    |'
- en: '| enumerate | enumerate(iterable, start=0) Returns a new iterator whose items
    are pairs. For each such pair, the second item is the corresponding item in iterable,
    while the first item is an integer: start, start+1, start+2.... For example, the
    following snippet loops on a list L of integers, changing L in place by halving
    every even value:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '| enumerate | enumerate(iterable, start=0) 返回一个新的迭代器，其项为对。对于每对，第二项是iterable中的对应项，而第一项是一个整数：start，start+1，start+2....
    例如，以下代码段在整数列表L上循环，通过对每个偶数值除以二来就地更改L： |'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: enumerate is one of the few built-ins callable with named arguments. |
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: enumerate 是少数几个支持命名参数的内置函数之一。 |
- en: '| eval | eval(*expr*[, *globals*[, *locals*]]*,* /) Returns the result of an
    expression. *expr* may be a code object ready for evaluation, or a string; if
    a string, eval gets a code object by internally calling compile(*expr*, ''<string>'',
    ''eval''). eval evaluates the code object as an expression, using the *globals*
    and *locals* dictionaries as namespaces (when they’re missing, eval uses the current
    namespace). eval doesn’t execute statements: it only evaluates expressions. Nevertheless,
    eval is dangerous; avoid it unless you know and trust that *expr* comes from a
    source that you are certain is safe. See also ast.literal_eval (covered in [“Standard
    Input”](ch11.xhtml#standard_input)), and [“Dynamic Execution and exec”](ch14.xhtml#dynamic_execution_and_exec).
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| eval | eval(*expr*[, *globals*[, *locals*]]*,* /) 返回表达式的结果。*expr* 可以是准备好进行评估的代码对象，或者是一个字符串；如果是字符串，eval
    通过内部调用 compile(*expr*, ''<string>'', ''eval'') 来获取一个代码对象。eval 将代码对象作为表达式进行评估，使用
    *globals* 和 *locals* 字典作为命名空间（当它们缺失时，eval 使用当前命名空间）。eval 不执行语句，它只评估表达式。尽管如此，eval
    是危险的；除非你知道并信任 *expr* 来自于一个你确定是安全的源，否则应避免使用。另请参见 ast.literal_eval（在 [“标准输入”](ch11.xhtml#standard_input)
    中介绍）和 [“动态执行和 exec”](ch14.xhtml#dynamic_execution_and_exec)。 |'
- en: '| exec | exec(*statement*[, *globals*[, *locals*]]*, /*) Like eval, but applies
    to any statement and returns **None**. exec is very dangerous, unless you know
    and trust that *statement* comes from a source that you are certain is safe. See
    also [“Statements”](ch03.xhtml#statements) and [“Dynamic Execution and exec”](ch14.xhtml#dynamic_execution_and_exec).
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| exec | exec(*statement*[, *globals*[, *locals*]]*, /*) 类似于 eval，但适用于任何语句并返回
    **None**。exec 非常危险，除非你知道并信任 *statement* 来自于一个你确定是安全的源。另请参见 [“语句”](ch03.xhtml#statements)
    和 [“动态执行和 exec”](ch14.xhtml#dynamic_execution_and_exec)。 |'
- en: '| filter | filter(*func*, *seq*, /) Returns an iterator of those items of *seq*
    for which *func* is true. *func* can be any callable object accepting a single
    argument, or **None**. *seq* can be any iterable. When *func* is callable, filter
    calls *func* on each item of *seq*, just like the following generator expression:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '| filter | filter(*func*, *seq*, /) 返回 *seq* 中使得 *func* 为真的项的迭代器。*func* 可以是接受单个参数的任何可调用对象，或者
    **None**。*seq* 可以是任何可迭代对象。当 *func* 是可调用对象时，filter 对 *seq* 中的每个项调用 *func*，类似于以下的生成器表达式：'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When *func* is **None**, filter tests for truthy items, just like:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *func* 是 **None** 时，filter 测试真值项，就像：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| format | format(*x*, *format_spec*='''', /) Returns *x*.__format__(*format_spec*).
    See [Table 4-1](ch04.xhtml#general_purpose_special_methods). |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| format | format(*x*, *format_spec*='''', /) 返回 *x*.__format__(*format_spec*)。参见
    [表 4-1](ch04.xhtml#general_purpose_special_methods)。 |'
- en: '| getattr | getattr(*obj*, *name*[, *default*], /) Returns *obj*’s attribute
    named by string *name**.* getattr(*obj*, ''*ident*'') is like *obj.ident*. When
    *default* is present and *name* is not found in *obj*, getattr returns *default*
    instead of raising AttributeError. See also [“Object attributes and items”](ch03.xhtml#object_attributes_and_items)
    and [“Attribute Reference Basics”](ch04.xhtml#attribute_reference_basics). |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| getattr | getattr(*obj*, *name*[, *default*], /) 返回 *obj* 的名为 *name* 的属性。getattr(*obj*,
    ''*ident*'') 就像 *obj.ident*。当 *default* 存在且在 *obj* 中找不到 *name* 时，getattr 返回 *default*
    而不是引发 AttributeError。另请参见 [“对象属性和项目”](ch03.xhtml#object_attributes_and_items)
    和 [“属性引用基础”](ch04.xhtml#attribute_reference_basics)。 |'
- en: '| globals | globals() Returns the __dict__ of the calling module (i.e., the
    dictionary used as the global namespace at the point of call). See also locals
    later in this table. (Unlike locals(), the dict returned by globals() is read/write,
    and updates to that dict are equivalent to ordinary name definitions.) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| globals | globals() 返回调用模块的 __dict__（即，在调用点用作全局命名空间的字典）。另请参见本表后面的 locals。
    （与 locals() 不同，globals() 返回的字典是可读/写的，并且对该字典的更新等效于普通的名称定义。） |'
- en: '| hasattr | hasattr(*obj*, *name*, /) Returns **False** when *obj* has no attribute
    *name* (i.e., when getattr(*obj, name*) would raise AttributeError); otherwise,
    returns True. See also [“Attribute Reference Basics”](ch04.xhtml#attribute_reference_basics).
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| hasattr | hasattr(*obj*, *name*, /) 当 *obj* 没有属性 *name* 时返回 **False**（即，当
    getattr(*obj, name*) 会引发 AttributeError 时）；否则，返回 True。另请参见 [“属性引用基础”](ch04.xhtml#attribute_reference_basics)。
    |'
- en: '| hash | hash(*obj,* /) Returns the hash value for *obj**.* *obj* can be a
    dictionary key, or an item in a set, only if *obj* can be hashed. All objects
    that compare equal must have the same hash value, even if they are of different
    types. If the type of *obj* does not define equality comparison, hash(*obj*) normally
    returns id(*obj*) (see id in this table and __hash__ in [Table 4-1](ch04.xhtml#general_purpose_special_methods)).
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 哈希 | hash(*obj,* /) 返回 *obj* 的哈希值。*obj* 可以是字典键，或集合中的项，前提是 *obj* 可以被哈希。所有相等的对象必须具有相同的哈希值，即使它们的类型不同也是如此。如果
    *obj* 的类型没有定义相等比较，hash(*obj*) 通常返回 id(*obj*)（参见本表中的 id 和 [Table 4-1](ch04.xhtml#general_purpose_special_methods)
    中的 __hash__）。 |'
- en: '| help | help([*obj*, /]) When called without an *obj* argument, begins an
    interactive help session, which you exit by entering **quit**. When *obj* is given,
    help prints the documentation for *obj* and its attributes, and returns **None**.
    help is useful in interactive Python sessions to get a quick reference to an object’s
    functionality. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 帮助 | help([*obj*, /]) 调用时如果没有 *obj* 参数，会开始一个交互式帮助会话，输入 **quit** 退出。如果给定了
    *obj*，help 会打印 *obj* 及其属性的文档，并返回 **None**。在交互式 Python 会话中使用 help 可以快速查看对象功能的参考资料。
    |'
- en: '| hex | hex(*x*, /) Returns a hex string representation of int *x*. See also
    __hex__ in [Table 4-4](ch04.xhtml#abcs_with_additional_methods). |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 十六进制 | hex(*x*, /) 返回 int *x* 的十六进制字符串表示。参见 [Table 4-4](ch04.xhtml#abcs_with_additional_methods)
    中的 __hex__。 |'
- en: '| id | id(*obj*, /) Returns the integer value that is the identity of *obj*.
    The id of *obj* is unique and constant during *obj*’s lifetime^([a](ch08.xhtml#ch01fn85))
    (but may be reused at any later time after *obj* is garbage-collected, so don’t
    rely on storing or checking id values). When a type or class does not define equality
    comparison, Python uses id to compare and hash instances. For any objects *x*
    and *y*, identity check *x* **is** *y* is the same as id(*x*)==id(*y*), but more
    readable and better performing. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| id | id(*obj*, /) 返回 *obj* 的标识整数值。*obj* 的 id 在 *obj* 的生命周期内是唯一且恒定的^([a](ch08.xhtml#ch01fn85))（但在
    *obj* 被垃圾回收后的任何时间后可能被重用，因此不要依赖存储或检查 id 值）。当一个类型或类没有定义相等比较时，Python 使用 id 来比较和哈希实例。对于任何对象
    *x* 和 *y*，身份检查 *x* **is** *y* 等同于 id(*x*)==id(*y*)，但更可读且性能更佳。 |'
- en: '| input | input(*prompt*='''', /) Writes *prompt* to standard output, reads
    a line from standard input, and returns the line (without \n) as a str. At end-of-file,
    input raises EOFError. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | input(*prompt*='''', /) 将 *prompt* 写入标准输出，从标准输入读取一行，并将该行（不带 \n）作为 str
    返回。在文件结尾处，input 会引发 EOFError。 |'
- en: '| isinstance | isinstance(*obj, cls*, /) Returns **True** when *obj* is an
    instance of class *cls* (or any subclass of *cls*, or implements protocol or ABC
    *cls*); otherwise, returns **False**. *cls* can be a tuple whose items are classes
    (or 3.10+ multiple types joined using the &#124; operator): in this case, isinstance
    returns **True** when *obj* is an instance of any of the items of *cls*; otherwise,
    it returns **False**. See also [“Abstract Base Classes”](ch04.xhtml#abstract_base_classe)
    and [“Protocols”](ch05.xhtml#protocols). |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| isinstance | isinstance(*obj, cls*, /) 当 *obj* 是类 *cls* 的实例（或 *cls* 的任何子类，或者实现了协议或
    ABC *cls*）时，返回 **True**；否则返回 **False**。*cls* 可以是一个包含类的元组（或 3.10+ 使用 &#124; 运算符连接的多个类型）：在这种情况下，如果
    *obj* 是 *cls* 的任何项的实例，则 isinstance 返回 **True**；否则返回 **False**。参见 [“抽象基类”](ch04.xhtml#abstract_base_classe)
    和 [“协议”](ch05.xhtml#protocols)。 |'
- en: '| issubclass | issubclass(*cls1*, *cls2*, /) Returns **True** when *cls1* is
    a direct or indirect subclass of *cls2*, or defines all the elements of protocol
    or ABC *cls2*; otherwise, returns **False**. *cls1* and *cls2* must be classes.
    *cls2* can also be a tuple whose items are classes. In this case, issubclass returns
    **True** when *cls1* is a direct or indirect subclass of any of the items of *cls2*;
    otherwise, it returns **False**. For any class *C*, issubclass(*C*, *C*) returns
    **True**. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 是否为子类 | issubclass(*cls1*, *cls2*, /) 当 *cls1* 是 *cls2* 的直接或间接子类，或者定义了协议或
    ABC *cls2* 的所有元素时，返回 **True**；否则返回 **False**。*cls1* 和 *cls2* 必须是类。*cls2* 也可以是一个包含类的元组。在这种情况下，如果
    *cls1* 是 *cls2* 的任何项的直接或间接子类，则 issubclass 返回 **True**；否则返回 **False**。对于任何类 *C*，issubclass(*C*,
    *C*) 返回 **True**。 |'
- en: '| iter | iter(*obj*, /), iter(*func*, *sentinel, /*)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '| 迭代器 | iter(*obj*, /), iter(*func*, *sentinel, /*)'
- en: 'Creates and returns an iterator (an object that you can repeatedly pass to
    the next built-in function to get one item at a time; see [“Iterators”](ch03.xhtml#iterators)).
    When called with one argument, iter(*obj*) normally returns *obj*.__iter__().
    When *obj* is a sequence without a special method __iter__, iter(*obj*) is equivalent
    to the generator:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并返回一个迭代器（一个你可以重复传递给 next 内置函数以逐个获取项的对象；参见 [“迭代器”](ch03.xhtml#iterators)）。当带有一个参数调用时，iter(*obj*)
    通常返回 *obj*.__iter__()。当 *obj* 是没有特殊方法 __iter__ 的序列时，iter(*obj*) 等同于生成器：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also [“Sequences”](ch03.xhtml#sequence) and __iter__ in [Table 4-2](ch04.xhtml#container_methods).
    |
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见 [“序列”](ch03.xhtml#sequence) 和 [Table 4-2](ch04.xhtml#container_methods)
    中的 __iter__。
- en: '| iter *(cont.)* | When called with two arguments, the first argument must
    be callable without arguments, and iter(*func*, *sentinel*) is equivalent to the
    generator:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '| iter *(cont.)* | 当调用时带有两个参数时，第一个参数必须是可无参数调用的可调用对象，而 iter(*func*, *sentinel*)
    相当于生成器：'
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Don’t Call iter in a for Clause
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要在 for 语句中调用 iter
- en: As discussed in [“The for Statement”](ch03.xhtml#the_for_statement), the statement
    **for** *x* **in** *obj* is exactly equivalent to **for** *x* **in** iter(*obj*);
    therefore, do *not* explicitly call iter in such a **for** statement. That would
    be redundant and, therefore, bad Python style, slower, and less readable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [“for语句”](ch03.xhtml#the_for_statement) 中所讨论的，语句 **for** *x* **in** *obj*
    等同于 **for** *x* **in** iter(*obj*)；因此，在这样的 **for** 语句中不要显式调用 iter。那会是多余的，因此不符合良好的Python风格，还会更慢且不易读。
- en: iter is *idempotent*. In other words, when *x* is an iterator, iter(*x*) is
    *x*, as long as *x*’s class supplies an __iter__ method whose body is just **return**
    self, as an iterator’s class should. |
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: iter 是幂等的。换句话说，当 *x* 是一个迭代器时，iter(*x*) 就是 *x*，只要 *x* 的类提供了一个体现为 **return** self
    的 __iter__ 方法，就像迭代器类应该的那样。
- en: '| len | len(*container*, /) Returns the number of items in *container*, which
    may be a sequence, a mapping, or a set. See also __len__ in [“Container methods”](ch04.xhtml#container_method).
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| len | len(*container*, /) 返回 *container* 中的项数，*container* 可能是序列、映射或集合。另请参见
    [“容器方法”](ch04.xhtml#container_method) 中的 __len__。'
- en: '| locals | locals() Returns a dictionary that represents the current local
    namespace. Treat the returned dictionary as read-only; trying to modify it may
    or may not affect the values of local variables, and might raise an exception.
    See also globals and vars in this table. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| locals | locals() 返回表示当前局部命名空间的字典。将返回的字典视为只读；试图修改它可能会影响局部变量的值，也可能会引发异常。另请参见本表中的
    globals 和 vars。'
- en: '| map | map(*func, seq*, /), map(*func*, /, **seqs*)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '| map | map(*func, seq*, /), map(*func*, /, **seqs*)'
- en: map calls *func* on every item of iterable *seq* and returns an iterator of
    the results. When you call map with multiple *seqs* iterables, *func* must be
    a callable object that accepts *n* arguments (where *n* is the number of *seqs*
    arguments,). map repeatedly calls *func* with *n* arguments, one corresponding
    item from each iterable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: map 在可迭代的 *seq* 的每个项上调用 *func* 并返回结果的迭代器。当你使用多个 *seqs* 可迭代对象调用 map 时，*func*
    必须是一个接受 *n* 个参数的可调用对象（其中 *n* 是 *seqs* 参数的数量）。map 将重复调用 *func*，每个可迭代对象中的相应项作为参数。
- en: 'For example, map(*func*, *seq*) is just like the generator expression:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，map(*func*, *seq*) 就像生成器表达式一样：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'is just like the generator expression:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就像生成器表达式一样：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When map’s iterable arguments have different lengths, map acts as if the longer
    ones were truncated (just as zip itself does). |
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当 map 的可迭代参数长度不同时，map 行为就像将较长的那些截断一样（就像 zip 本身一样）。
- en: '| max | max(*seq*, /, *, key=**None**[, default=...]), max(**args*, key=**None**[,
    default=...])'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '| max | max(*seq*, /, *, key=**None**[, default=...]), max(**args*, key=**None**[,
    default=...])'
- en: Returns the largest item in the iterable argument *seq*, or the largest one
    of multiple positional arguments *args*. You can pass a key argument, with the
    same semantics covered in [“Sorting a list”](ch03.xhtml#sorting_a_list). You can
    also pass a default argument, the value to return if *seq* is empty; when you
    don’t pass default, and *seq* is empty, max raises ValueError. (When you pass
    key and/or default, you must pass either or both as named arguments.) |
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 返回可迭代参数 *seq* 中的最大项，或多个位置参数 *args* 中的最大项。你可以传递一个 key 参数，具有与 [“排序列表”](ch03.xhtml#sorting_a_list)
    中介绍的相同语义。你还可以传递一个默认参数，即当 *seq* 为空时返回的值；当你不传递默认参数且 *seq* 为空时，max 将引发 ValueError。（当你传递
    key 和/或 default 时，必须将其中一个或两个作为命名参数传递。）
- en: '| min | min(*seq,* /, *, key*=***None**[, default=...]), min(**args*, key*=***None**[,
    default=...])'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '| min | min(*seq,* /, *, key*=***None**[, default=...]), min(**args*, key*=***None**[,
    default=...])'
- en: Returns the smallest item in the iterable argument *seq*, or the smallest one
    of multiple positional arguments *args*. You can pass a key argument, with the
    same semantics covered in [“Sorting a list”](ch03.xhtml#sorting_a_list). You can
    also pass a default argument, the value to return if *seq* is empty; when you
    don’t pass default, and *seq* is empty, min raises ValueError. (When you pass
    key and/or default, you must pass either or both as named arguments.) |
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 返回可迭代参数 *seq* 中的最小项，或多个位置参数 *args* 中的最小项之一。您可以传递一个 key 参数，其语义与 [“排序列表”](ch03.xhtml#sorting_a_list)
    中介绍的相同。您还可以传递一个 default 参数，如果 *seq* 为空则返回该值；当不传递 default 且 *seq* 为空时，min 将引发 ValueError
    异常。（当您传递 key 和/或 default 时，必须将其中一个或两者作为命名参数传递。） |
- en: '| next | next(*it*[, *default*], /) Returns the next item from iterator *it*,
    which advances to the next item. When *it* has no more items, next returns *default*,
    or, when you don’t pass *default*, raises StopIteration. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| next | next(*it*[, *default*], /) 从迭代器 *it* 中返回下一个项目，并使其前进到下一个项目。当 *it* 没有更多项目时，next
    返回 *default*；当没有传递 *default* 时，next 抛出 StopIteration 异常。 |'
- en: '| oct | oct(*x*, /) Converts int *x* to an octal string. See also __oct__ in
    [Table 4-4](ch04.xhtml#abcs_with_additional_methods). |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| oct | oct(*x*, /) 将整数 *x* 转换为八进制字符串。另见 [表 4-4](ch04.xhtml#abcs_with_additional_methods)
    中的 __oct__。 |'
- en: '| open | open(file, mode=''r'', buffering=-1) Opens or creates a file and returns
    a new file object. open accepts many, many more optional parameters; see [“The
    io Module”](ch11.xhtml#the_io_module) for details.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '| open | open(file, mode=''r'', buffering=-1) 打开或创建文件并返回新的文件对象。open 还接受许多更多的可选参数；详情请参见
    [“io 模块”](ch11.xhtml#the_io_module)。 |'
- en: open is one of the few built-ins callable with named arguments. |
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: open 是少数几个可以使用命名参数调用的内置函数。 |
- en: '| ord | ord(*ch*, /) Returns an int between 0 and sys.maxunicode (inclusive),
    corresponding to the single-character str argument *ch*. See also chr earlier
    in this table. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| ord | ord(*ch*, /) 返回一个介于 0 和 sys.maxunicode（包括）之间的整数，对应于单字符 str 参数 *ch*。另见本表中较早的
    chr。 |'
- en: '| pow | pow(*x*, *y*[, *z*], /) When *z* is present, pow(*x*, *y*, *z*) returns
    (*x* ** *y*) % *z*. When *z* is missing, pow(*x*, *y*) returns *x* ** *y*. See
    also __pow__ in [Table 4-4](ch04.xhtml#abcs_with_additional_methods). When *x*
    is an int and *y* is a nonnegative int, pow returns an int and uses Python’s full
    value range for int (though evaluating pow for large *x* and *y* integer values
    may take some time). When either *x* or *y* is a float, or *y* is < 0, pow returns
    a float (or a complex, when x < 0 and y != int(y)); in this case, pow raises OverflowError
    if *x* or *y* is too large. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| pow | pow(*x*, *y*[, *z*], /) 当 *z* 存在时，pow(*x*, *y*, *z*) 返回 (*x* ** *y*)
    % *z*。当 *z* 不存在时，pow(*x*, *y*) 返回 *x* ** *y*。另见 [表 4-4](ch04.xhtml#abcs_with_additional_methods)
    中的 __pow__。当 *x* 是整数且 *y* 是非负整数时，pow 返回一个整数，并使用 Python 的整数全值范围（尽管对于大的整数 *x* 和
    *y* 的值，计算 pow 可能需要一些时间）。当 *x* 或 *y* 是浮点数，或 *y* < 0 时，pow 返回一个浮点数（或复数，当 *x* < 0
    且 *y* 不等于 int(y) 时）；在这种情况下，如果 *x* 或 *y* 太大，pow 将引发 OverflowError。 |'
- en: '| print | print(/, **args*, sep='' '', end=''\n'', file=sys.stdout, flush=**False**)
    Formats with str, and emits to stream file, each item of *args* (if any), separated
    by sep, with end after all of them; then, print flushes the stream if flush is
    truthy. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| print | print(/, **args*, sep='' '', end=''\n'', file=sys.stdout, flush=**False**)
    使用 str 格式化并发送到文件流，对于 *args* 的每个项（如果有的话），以 sep 分隔，所有项打印完毕后，根据 flush 的真假决定是否刷新流。
    |'
- en: '| range | range([start=0, ]stop[, step=1], /) Returns an iterator of ints in
    arithmetic progression:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '| range | range([start=0, ]stop[, step=1], /) 返回一个整数迭代器，表示算术级数：'
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When start is missing, it defaults to 0. When step is missing, it defaults to
    1. When step is 0, range raises ValueError. When step is > 0, the last item is
    the largest start+(*i**step) strictly less than stop. When step is < 0, the last
    item is the smallest start+(*i**step*)* strictly greater than stop. The iterator
    is empty when start is greater than or equal to stop and step is greater than
    0, or when start is less than or equal to stop and step is less than 0. Otherwise,
    the first item of the iterator is always start.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当缺少 start 参数时，默认为 0。当缺少 step 参数时，默认为 1。当 step 为 0 时，range 抛出 ValueError。当 step
    > 0 时，最后一个项是最大的 start+(*i*step) 严格小于 stop。当 step < 0 时，最后一个项是最小的 start+(*i*step)
    严格大于 stop。当 start 大于或等于 stop 且 step 大于 0，或当 start 小于或等于 stop 且 step 小于 0 时，迭代器为空。否则，迭代器的第一个项总是
    start。
- en: When what you need is a list of ints in arithmetic progression, call list(range(...)).
    |
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要一个算术级数的整数列表时，请调用 list(range(...))。 |
- en: '| repr | repr(*obj*, /) Returns a complete and unambiguous string representation
    of *obj*. When feasible, repr returns a string that you could pass to eval in
    order to create a new object with the same value as *obj*. See also str in [Table 8-1](#pythonapostrophes_core_built_in_types)
    and __repr__ in [Table 4-1](ch04.xhtml#general_purpose_special_methods). |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| repr | repr(*obj*, /) 返回*obj*的完整且明确的字符串表示形式。在可行的情况下，repr 返回一个字符串，您可以将其传递给
    eval 以创建一个与*obj*具有相同值的新对象。还请参阅[表 8-1](#pythonapostrophes_core_built_in_types)中的str和[表 4-1](ch04.xhtml#general_purpose_special_methods)中的__repr__。'
- en: '| reversed | reversed(*seq*, /) Returns a new iterator object that yields the
    items of *seq* (which must be specifically a sequence, not just any iterable)
    in reverse order. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| reversed | reversed(*seq*, /) 返回一个新的迭代器对象，该对象按逆序产生*seq*（*seq*必须明确地是一个序列，而不仅仅是任何可迭代对象）的项目。'
- en: '| round | round(number, ndigits=0) Returns a float whose value is int or float
    number rounded to ndigits digits after the decimal point (i.e., the multiple of
    10**-ndigits that is closest to number). When two such multiples are equally close
    to number, round returns the *even* multiple. Since today’s computers represent
    floating-point numbers in binary, not in decimal, most of round’s results are
    not exact, as the [tutorial](https://oreil.ly/qHMNz) in the docs explains in detail.
    See also [“The decimal Module”](ch16.xhtml#the_decimal_module) and David Goldberg’s
    famous language-independent [article](https://oreil.ly/TVFMb) on floating-point
    arithmetic. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| round | round(number, ndigits=0) 返回一个浮点数，其值为 int 或浮点数 number 四舍五入到小数点后 ndigits
    位（即，最接近 number 的 10**-ndigits 的倍数）。当两个这样的倍数与 number 等距时，round 返回*偶数*倍数。由于当今的计算机以二进制而不是十进制表示浮点数，大多数
    round 的结果都不精确，正如文档中的[教程](https://oreil.ly/qHMNz)详细解释的那样。还请参阅[“decimal 模块”](ch16.xhtml#the_decimal_module)和大卫·戈德伯格（David
    Goldberg）关于浮点算术的著名的与语言无关的[文章](https://oreil.ly/TVFMb)。'
- en: '| setattr | setattr(*obj*, *name*, *value*, /) Binds *obj*’s attribute *name*
    to *value*. setattr(*obj*, ''*ident*'', *val*) is like *obj*.*ident*=*val*. See
    also getattr earlier in this table, [“Object attributes and items”](ch03.xhtml#object_attributes_and_items),
    and [“Setting an attribute”](ch04.xhtml#setting_an_attribute). |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| setattr | setattr(*obj*, *name*, *value*, /) 将*obj*的属性*name*绑定到*value*。setattr(*obj*,
    ''*ident*'', *val*) 类似于*obj*.*ident*=*val*。还请参阅此表中早期的getattr，[“对象属性和项目”](ch03.xhtml#object_attributes_and_items)以及[“设置属性”](ch04.xhtml#setting_an_attribute)。'
- en: '| sorted | sorted(*seq*, /, *, key=**None**, reverse=**False**) Returns a list
    with the same items as iterable *seq*, in sorted order. Same as:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '| sorted | sorted(*seq*, /, *, key=**None**, reverse=**False**) 返回一个与可迭代*seq*中的相同项目以排序顺序排列的列表。与下面相同：'
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See [“Sorting a list”](ch03.xhtml#sorting_a_list) for the meaning of the arguments.
    If you want to pass key and/or reverse, you *must* pass them by name. |
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[“列表排序”](ch03.xhtml#sorting_a_list)以了解参数的含义。如果要传递键（key）和/或反转（reverse），*必须*按名称传递。
- en: '| sum | sum(*seq*, /, start=0) Returns the sum of the items of iterable *seq*
    (which should be numbers, and, in particular, cannot be strings) plus the value
    of start. When *seq* is empty, returns start. To “sum” (concatenate) an iterable
    of strings, in order, use ''''.join(*iterofstrs*), as covered in [Table 8-1](#pythonapostrophes_core_built_in_types)
    and [“Building up a string from pieces”](ch17.xhtml#building_up_a_string_from_pieces).
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| sum | sum(*seq*, /, start=0) 返回可迭代*seq*（应为数字，并且特别是不能为字符串）的项目的总和，加上 start
    的值。当*seq*为空时，返回 start。要对字符串可迭代对象进行“求和”（连接），请使用''''.join(*iterofstrs*），如[表 8-1](#pythonapostrophes_core_built_in_types)和[“从片段构建字符串”](ch17.xhtml#building_up_a_string_from_pieces)中所述。'
- en: '| vars | vars([*obj*, ]*/*) When called with no argument, vars returns a dictionary
    with all variables that are bound in the current scope (like locals, covered earlier
    in this table). Treat this dictionary as read-only. vars(*obj*) returns a dictionary
    with all attributes currently bound in *obj*, similar to dir, covered earlier
    in this table. This dictionary may be modifiable or not, depending on the type
    of *obj*. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| vars | vars([*obj*, ]*/*) 调用时不带参数时，vars 返回一个字典，其中包含在当前范围（如此表中较早涵盖的局部变量）中绑定的所有变量。请将此字典视为只读。vars(*obj*)
    返回一个字典，其中包含当前在*obj*中绑定的所有属性，类似于dir，此表中较早涵盖的内容。此字典可以是可修改的也可以是不可修改的，具体取决于*obj*的类型。'
- en: '| zip | zip(*seq*, /, **seqs*, strict*=***False**) Returns an iterator of tuples,
    where the *n*th tuple contains the *n*th item from each of the argument iterables.
    You must call zip with at least one (positional) argument, and all positional
    arguments must be iterable. zip returns an iterator with as many items as the
    shortest iterable, ignoring trailing items in the other iterable objects. **3.10+**
    When the iterables have different lengths and strict is **True**, zip raises ValueError
    once it reaches the end of the shortest iterable. See also map earlier in this
    table and zip_longest in [Table 8-10](#functions_and_attributes_of_the_itertoo).
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| zip | zip(*seq*, /, **seqs*, strict*=***False**) Returns an iterator of tuples,
    where the *n*th tuple contains the *n*th item from each of the argument iterables.
    You must call zip with at least one (positional) argument, and all positional
    arguments must be iterable. zip returns an iterator with as many items as the
    shortest iterable, ignoring trailing items in the other iterable objects. **3.10+**
    When the iterables have different lengths and strict is **True**, zip raises ValueError
    once it reaches the end of the shortest iterable. See also map earlier in this
    table and zip_longest in [Table 8-10](#functions_and_attributes_of_the_itertoo).
    |'
- en: '| ^([a](ch08.xhtml#ch01fn85-marker)) Otherwise arbitrary; often, an implementation
    detail, *obj*’s address in memory. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch08.xhtml#ch01fn85-marker)) Otherwise arbitrary; often, an implementation
    detail, *obj*’s address in memory. |'
- en: The sys Module
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sys 模块
- en: The attributes of the sys module are bound to data and functions that provide
    information on the state of the Python interpreter or affect the interpreter directly.
    [Table 8-3](#functions_and_attributes_of_the_sys_mod) covers the most frequently
    used attributes of sys. Most sys attributes we don’t cover are meant specifically
    for use in debuggers, profilers, and integrated development environments; see
    the [online docs](https://oreil.ly/2KBRg) for more information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: sys 模块的属性绑定到提供关于 Python 解释器状态或直接影响解释器的数据和函数。 [Table 8-3](#functions_and_attributes_of_the_sys_mod)
    涵盖了 sys 的最常用属性。大多数 sys 属性专为调试器、分析器和集成开发环境使用；详细信息请参阅 [online docs](https://oreil.ly/2KBRg)。
- en: Platform-specific information is best accessed using the platform module, which
    we do not cover in this book; see the [online docs](https://oreil.ly/YJKQD) for
    details on this module.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 平台特定的信息最好使用 platform 模块访问，本书不涵盖此模块；详细信息请参阅 [online docs](https://oreil.ly/YJKQD)。
- en: Table 8-3\. Functions and attributes of the sys module
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Table 8-3\. Functions and attributes of the sys module
- en: '| argv | The list of command-line arguments passed to the main script. argv[0]
    is the name of the main script,^([a](ch08.xhtml#ch01fn86)) or ''-c'' if the command
    line used the **-c** option. See [“The argparse Module”](#the_argparse_module)
    for one good way to use sys.argv. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| argv | The list of command-line arguments passed to the main script. argv[0]
    is the name of the main script,^([a](ch08.xhtml#ch01fn86)) or ''-c'' if the command
    line used the **-c** option. See [“The argparse Module”](#the_argparse_module)
    for one good way to use sys.argv. |'
- en: '| audit | audit(*event*, /, **args*) Raises an *audit event* whose name is
    str *event* and whose arguments are *args*. The rationale for Python’s audit system
    is laid out in exhaustive detail in [PEP 578](https://oreil.ly/pMcEY); Python
    itself raises the large variety of events listed in the [online docs](https://oreil.ly/SjLW1).
    To *listen* for events, call sys.addaudithook(*hook*), where *hook* is a callable
    whose arguments are a str, the event’s name, followed by arbitrary positional
    arguments. For more details, see the [docs](https://oreil.ly/4os3i). |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| audit | audit(*event*, /, **args*) Raises an *audit event* whose name is
    str *event* and whose arguments are *args*. The rationale for Python’s audit system
    is laid out in exhaustive detail in [PEP 578](https://oreil.ly/pMcEY); Python
    itself raises the large variety of events listed in the [online docs](https://oreil.ly/SjLW1).
    To *listen* for events, call sys.addaudithook(*hook*), where *hook* is a callable
    whose arguments are a str, the event’s name, followed by arbitrary positional
    arguments. For more details, see the [docs](https://oreil.ly/4os3i). |'
- en: '| buil⁠t⁠i⁠n⁠_​m⁠o⁠d⁠ule_names | A tuple of strs: the names of all the modules
    compiled into this Python interpreter. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| buil⁠t⁠i⁠n⁠_​m⁠o⁠d⁠ule_names | A tuple of strs: the names of all the modules
    compiled into this Python interpreter. |'
- en: '| displayhook | displayhook(*value*, /) In interactive sessions, the Python
    interpreter calls displayhook, passing it the result of each expression statement
    you enter. The default displayhook does nothing when *value* is **None**; otherwise,
    it saves *value* in the built-in variable whose name is _ (an underscore) and
    displays it via repr:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '| displayhook | displayhook(*value*, /) In interactive sessions, the Python
    interpreter calls displayhook, passing it the result of each expression statement
    you enter. The default displayhook does nothing when *value* is **None**; otherwise,
    it saves *value* in the built-in variable whose name is _ (an underscore) and
    displays it via repr:'
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can rebind sys.displayhook in order to change interactive behavior. The
    original value is available as sys.__displayhook__. |
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重新绑定 sys.displayhook 以更改交互行为。原始值可通过 sys.__displayhook__ 获取。
- en: '| dont_wri⁠t⁠e⁠_​b⁠y⁠t⁠ecode | When **True**, Python does not write a bytecode
    file (with extension *.pyc*) to disk when it imports a source file (with extension
    *.py*). |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| dont_wri⁠t⁠e⁠_​b⁠y⁠t⁠ecode | 当为 **True** 时，Python 在导入源文件（扩展名为 *.py*）时不将字节码文件（扩展名为
    *.pyc*）写入磁盘。 |'
- en: '| excepthook | excepthook(*type*, *value*, *traceback*, /) When an exception
    is not caught by any handler, propagating all the way up the call stack, Python
    calls excepthook, passing it the exception class, object, and traceback, as covered
    in [“Exception Propagation”](ch06.xhtml#exception_propagation). The default excepthook
    displays the error and traceback. You can rebind sys.excepthook to change how
    uncaught exceptions (just before Python returns to the interactive loop or terminates)
    get displayed and/or logged. The original value is available as sys.__excepthook__.
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| excepthook | excepthook(*type*, *value*, *traceback*, /) 当异常没有被任何处理程序捕获并传播到调用堆栈的最顶层时，Python
    调用 excepthook，传递给它异常类、对象和回溯，如 [“异常传播”](ch06.xhtml#exception_propagation) 中所述。默认的
    excepthook 显示错误和回溯。您可以重新绑定 sys.excepthook 来更改未捕获异常（在 Python 返回交互循环或终止之前）的显示和/或记录方式。原始值可通过
    sys.__excepthook__ 获取。 |'
- en: '| exception | exception() 3.11+ When called within an **except** clause, returns
    the current exception instance (equivalent to sys.exc_info()[1]). |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| exception | exception() 3.11+ 在 **except** 子句中调用时，返回当前异常实例（等效于 sys.exc_info()[1]）。
    |'
- en: '| exc_info | exc_info() When the current thread is handling an exception, exc_info
    returns a tuple with three items: the class, object, and traceback for the exception.
    When the thread is not handling an exception, exc_info returns (**None**, **None**,
    **None**). To display information from a traceback, see [“The traceback Module”](ch17.xhtml#the_traceback_module).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '| exc_info | exc_info() 当前线程正在处理异常时，exc_info 返回一个包含三个元素的元组：异常的类、对象和回溯（traceback）。当线程没有处理异常时，exc_info
    返回 (**None**, **None**, **None**)。要显示来自回溯的信息，请参阅 [“回溯模块”](ch17.xhtml#the_traceback_module)。'
- en: Holding On to a Traceback Object Can Make Some Garbage Uncollectable
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持有回溯对象可能使一些垃圾成为不可回收
- en: 'A traceback object indirectly holds references to all variables on the call
    stack; if you hold a reference to the traceback (e.g., indirectly, by binding
    a variable to the tuple that exc_info returns), Python must keep in memory data
    that might otherwise be garbage-collected. Make sure that any binding to the traceback
    object is of short duration, for example with a **try**/**finally** statement
    (discussed in [“try/finally”](ch06.xhtml#trysolidusfinally)). If you must hold
    a reference to an exception *e*, clear *e*’s traceback: *e*.__traceback__=**None**.^([b](ch08.xhtml#ch01fn87))'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: traceback 对象间接地持有对调用堆栈上所有变量的引用；如果您持有回溯的引用（例如通过将变量绑定到 exc_info 返回的元组间接地持有），Python
    必须保留可能被垃圾回收的数据。确保对回溯对象的任何绑定持续时间很短，例如使用 **try**/**finally** 语句（在 [“try/finally”](ch06.xhtml#trysolidusfinally)
    中讨论）。如果必须持有异常 *e* 的引用，请清除 *e* 的回溯：*e*.__traceback__=**None**。^([b](ch08.xhtml#ch01fn87))
    |
- en: '|'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| exit | exit(*arg*=0, /) Raises a SystemExit exception, which normally terminates
    execution after executing cleanup handlers installed by **try**/**finally** statements,
    **with** statements, and the atexit module. When *arg* is an int, Python uses
    *arg* as the program’s exit code: 0 indicates successful termination; any other
    value indicates unsuccessful termination of the program. Most platforms require
    exit codes to be between 0 and 127. When *arg* is not an int, Python prints *arg*
    to sys.stderr, and the exit code of the program is 1 (a generic “unsuccessful
    termination” code). |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| exit | exit(*arg*=0, /) 触发一个 SystemExit 异常，通常在执行**try**/**finally**语句、**with**语句以及
    atexit 模块安装的清理处理程序后终止执行。当 *arg* 是一个整数时，Python 使用 *arg* 作为程序的退出代码：0 表示成功终止；任何其他值表示程序未成功终止。大多数平台要求退出代码在
    0 到 127 之间。当 *arg* 不是整数时，Python 将 *arg* 打印到 sys.stderr，并且程序的退出代码为 1（通用的“未成功终止”代码）。
    |'
- en: '| float_info | A read-only object whose attributes hold low-level details about
    the implementation of the float type in this Python interpreter. See the [online
    docs](https://oreil.ly/9vMpw) for details. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| float_info | 一个只读对象，其属性保存了该 Python 解释器中浮点类型的底层实现细节。详细信息请参阅 [在线文档](https://oreil.ly/9vMpw)。
    |'
- en: '| g⁠e⁠t⁠r⁠e⁠c⁠u⁠r⁠s⁠i⁠o⁠n​l⁠i⁠m⁠i⁠t | getrecursionlimit() Returns the current
    limit on the depth of Python’s call stack. See also [“Recursion”](ch03.xhtml#recursion)
    and setrecursionlimit later in this table. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| g⁠e⁠t⁠r⁠e⁠c⁠u⁠r⁠s⁠i⁠o⁠n​l⁠i⁠m⁠i⁠t | getrecursionlimit() 返回 Python 调用堆栈深度的当前限制。也请参阅
    [“递归”](ch03.xhtml#recursion) 和本表后面的 setrecursionlimit。 |'
- en: '| getrefcount | getrefcount(*obj*, /) Returns the reference count of *obj*.
    Reference counts are covered in [“Garbage Collection”](ch14.xhtml#garbage_collection).
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| getrefcount | getrefcount(*obj*, /) 返回*obj*的引用计数。引用计数在[“垃圾回收”](ch14.xhtml#garbage_collection)中有介绍。
    |'
- en: '| getsizeof | getsizeof(*obj*[, *default*], /) Returns the size, in bytes,
    of *obj* (not counting any items or attributes *obj* may refer to), or *default*
    when *obj* does not provide a way to retrieve its size (in the latter case, when
    *default* is absent, getsizeof raises TypeError). |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| getsizeof | getsizeof(*obj*[, *default*], /) 返回*obj*的大小，以字节为单位（不包括*obj*可能引用的任何项或属性），或在*obj*无法提供其大小的情况下返回*default*（在后一种情况下，如果*default*不存在，则getsizeof引发TypeError）。
    |'
- en: '| maxsize | The maximum number of bytes in an object in this version of Python
    (at least 2 ** 31 - 1, that is, 2147483647). |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| maxsize | 在此Python版本中对象的最大字节数（至少为2 ** 31 - 1，即2147483647）。 |'
- en: '| maxunicode | The largest codepoint for a Unicode character in this version
    of Python; currently, always 1114111 (0x10FFFF). The version of the Unicode database
    used by Python is in unicodedata.unidata_version. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| maxunicode | 在此Python版本中Unicode字符的最大代码点；当前始终为1114111（0x10FFFF）。Python使用的Unicode数据库版本在unicodedata.unidata_version中。
    |'
- en: '| modules | A dictionary whose items are the names and module objects for all
    loaded modules. See [“Module Loading”](ch07.xhtml#module_loading) for more information
    on sys.modules. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| modules | 一个字典，其项为所有已加载模块的名称和模块对象。有关sys.modules的更多信息，请参见[“模块加载”](ch07.xhtml#module_loading)。
    |'
- en: '| path | A list of strings that specifies the directories and ZIP files that
    Python searches when looking for a module to load. See [“Searching the Filesystem
    for a Module”](ch07.xhtml#searching_the_filesystem_for_a_module) for more information
    on sys.path. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| path | 一个字符串列表，指定Python在查找要加载的模块时搜索的目录和ZIP文件。有关sys.path的更多信息，请参见[“在文件系统中搜索模块”](ch07.xhtml#searching_the_filesystem_for_a_module)。
    |'
- en: '| platform | A string that names the platform on which this program is running.
    Typical values are brief operating system names, such as ''darwin'', ''linux2'',
    and ''win32''. For Linux, check sys.platform.startswith(''linux''), for portability
    among Linux versions. See also the online docs for the module [platform](https://oreil.ly/LH4IP),
    which we don’t cover in this book. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| platform | 一个字符串，指定运行此程序的平台名称。典型的值是简短的操作系统名称，如''darwin''、''linux2''和''win32''。对于Linux，检查sys.platform.startswith(''linux'')以实现在不同Linux版本间的可移植性。还请参阅模块[platform](https://oreil.ly/LH4IP)的在线文档，本书不涵盖该部分。
    |'
- en: '| ps1, ps2 | ps1 and ps2 specify the primary and secondary interpreter prompt
    strings, initially >>> and ..., respectively. These sys attributes exist only
    in interactive interpreter sessions. If you bind either attribute to a non-str
    object *x*, Python prompts by calling str(*x*) on the object each time a prompt
    is output. This feature allows dynamic prompting: code a class that defines __str__,
    then assign an instance of that class to sys.ps1 and/or sys.ps2. For example,
    to get numbered prompts:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '| ps1, ps2 | ps1和ps2分别指定主提示符和次要提示符字符串，初始值分别为 >>> 和 ...。这些sys属性仅存在于交互式解释器会话中。如果将任何属性绑定到非字符串对象*x*，Python将在每次输出提示时调用该对象的str(*x*)方法来生成提示符。此功能允许动态提示：编写一个定义了__str__方法的类，然后将该类的实例分配给sys.ps1和/或sys.ps2。例如，要获取编号提示符：'
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| s⁠e⁠t⁠r⁠e⁠c⁠u⁠r⁠s⁠i⁠o⁠n​l⁠i⁠m⁠i⁠t | setrecursionlimit(*limit*, /) Sets the
    limit on the depth of Python’s call stack (the default is 1000). The limit prevents
    runaway recursion from crashing Python. Raising the limit may be necessary for
    programs that rely on deep recursion, but most platforms cannot support very large
    limits on call stack depth. More usefully, *lowering* the limit helps you check,
    during testing and debugging, that your program degrades gracefully, rather than
    abruptly crashing with a RecursionError, under situations of almost runaway recursion.
    See also [“Recursion”](ch03.xhtml#recursion) and getrecursionlimit earlier in
    this table. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| s⁠e⁠t⁠r⁠e⁠c⁠u⁠r⁠s⁠i⁠o⁠n​l⁠i⁠m⁠i⁠t | setrecursionlimit(*limit*, /) 设置Python调用栈深度限制（默认为1000）。该限制可防止递归无限扩展导致Python崩溃。对于依赖深度递归的程序，可能需要提高此限制，但大多数平台无法支持非常大的调用栈深度限制。更有用的是，*降低*此限制可以帮助您在测试和调试过程中检查程序是否能够优雅地降级，而不是在几乎无限递归的情况下突然崩溃并引发RecursionError。还请参见[“递归”](ch03.xhtml#recursion)和本表中getrecursionlimit的前文。
    |'
- en: '| stdin, stdout,'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '| stdin, stdout, | '
- en: stderr | stdin, stdout, and stderr are predefined file-like objects that correspond
    to Python’s standard input, output, and error streams. You can rebind stdout and
    stderr to file-like objects open for writing (objects that supply a write method
    accepting a string argument) to redirect the destination of output and error messages.
    You can rebind stdin to a file-like object open for reading (one that supplies
    a readline method returning a string) to redirect the source from which built-in
    function input reads. The original values are available as __stdin__, __stdout__,
    and __stderr__. We cover file objects in [“The io Module”](ch11.xhtml#the_io_module).
    |
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: stderr | stdin、stdout 和 stderr 是预定义的类似文件的对象，分别对应于 Python 的标准输入、输出和错误流。您可以将 stdout
    和 stderr 重新绑定到打开以供写入的类似文件的对象（提供接受字符串参数的 write 方法的对象），以重定向输出和错误消息的目标。您可以将 stdin
    重新绑定到打开以供读取的类似文件的对象（提供返回字符串的 readline 方法的对象），以重定向内置函数 input 读取的源。原始值可用作 __stdin__、__stdout__
    和 __stderr__。我们在 [“io 模块”](ch11.xhtml#the_io_module) 中讨论文件对象。 |
- en: '| tracebacklimit | The maximum number of levels of traceback displayed for
    unhandled exceptions. By default, this attribute is not defined (i.e., there is
    no limit). When sys.tracebacklimit is <= 0, Python prints only the exception type
    and value, without a traceback. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| tracebacklimit | 未处理异常的回溯显示的最大级数。默认情况下，此属性未定义（即没有限制）。当 sys.tracebacklimit
    <= 0 时，Python 仅打印异常类型和值，而不打印回溯。 |'
- en: '| version | A string that describes the Python version, build number and date,
    and C compiler used. Use sys.version only for logging or interactive output; to
    perform version comparisons, use sys.version_info. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| version | 描述 Python 版本、构建号和日期以及所使用的 C 编译器的字符串。仅在日志记录或交互式输出时使用 sys.version；要执行版本比较，请使用
    sys.version_info。 |'
- en: '| version_info | A namedtuple of the major, minor, micro, releaselevel, and
    serial fields of the running Python version. For example, in the first post-beta
    release of Python 3.10, sys.version_info was sys.version_info(major=3, minor=10,
    micro=0, releaselevel=''final'', serial=0), equivalent to the tuple (3, 10, 0,
    ''final'', 0). This form is defined to be directly comparable between versions;
    to see if the current version running is greater than or equal to, say, 3.8, you
    can test sys.version_info[:3] >= (3, 8, 0). (Do *not* do string comparisons of
    the *string* sys.version, since the string "3.10" would compare as less than "3.9"!)
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| version_info | 运行中的 Python 版本的主要、次要、微版本、发布级别和序列号字段的命名元组。例如，在 Python 3.10
    的第一个正式版之后，sys.version_info 是 sys.version_info(major=3, minor=10, micro=0, releaselevel=''final'',
    serial=0)，相当于元组 (3, 10, 0, ''final'', 0)。此形式被定义为版本间直接可比较；若要检查当前运行版本是否大于或等于 3.8，可以测试
    sys.version_info[:3] >= (3, 8, 0)。（不要对 *string* sys.version 进行字符串比较，因为字符串 "3.10"
    会被认为小于 "3.9"！） |'
- en: '| ^([a](ch08.xhtml#ch01fn86-marker)) It could, of course, also be a path to
    the script, and/or a symbolic link to it, if that’s what you gave Python.^([b](ch08.xhtml#ch01fn87-marker))
    One of the book’s authors had this very problem when memoizing return values and
    exceptions raised in pyparsing: the cached exception tracebacks held many object
    references and interfered with garbage collection. The solution was to clear the
    tracebacks of the exceptions before putting them in the cache. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch08.xhtml#ch01fn86-marker)) 当然，它也可以是脚本的路径，如果是这样，它也可以是对它的符号链接，如果是这样，它就是你给
    Python 的^([b](ch08.xhtml#ch01fn87-marker))。本书的一位作者在 pyparsing 中记住了返回值和引发的异常时，遇到了这个问题：缓存的异常回溯包含了许多对象引用，并且干扰了垃圾收集。解决方案是在将异常放入缓存之前清除异常的回溯。
    |'
- en: The copy Module
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**copy 模块**'
- en: As discussed in [“Assignment Statements”](ch03.xhtml#assignment_statements),
    assignments in Python do not *copy* the righthand-side object being assigned.
    Rather, assignments *add references* to the RHS object. When you want a *copy*
    of object *x*, ask *x* for a copy of itself, or ask *x*’s type to make a new instance
    copied from *x*. If *x* is a list, list(*x*) returns a copy of *x*, as does *x*[:].
    If *x* is a dictionary, dict(*x*) and *x*.copy() return a copy of *x*. If *x*
    is a set, set(*x*) and *x*.copy() return a copy of *x*. In each case, this book’s
    authors prefer the uniform and readable idiom of calling the type, but there is
    no consensus on this style issue in the Python community.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [“赋值语句”](ch03.xhtml#assignment_statements) 中所讨论的，Python 中的赋值不会 *复制* 被分配的右侧对象。相反，赋值
    *添加引用* 到 RHS 对象。当您想要对象 *x* 的 *副本* 时，请求 *x* 自身的副本，或者请求 *x* 的类型创建从 *x* 复制的新实例。如果
    *x* 是列表，则 list(*x*) 返回 *x* 的副本，*x*[:] 也是如此。如果 *x* 是字典，则 dict(*x*) 和 *x*.copy()
    返回 *x* 的副本。如果 *x* 是集合，则 set(*x*) 和 *x*.copy() 返回 *x* 的副本。在每种情况下，本书的作者更倾向于使用统一和可读的惯用法来调用类型，但在
    Python 社区中对此风格问题没有共识。
- en: 'The copy module supplies a copy function to create and return a copy of many
    types of objects. Normal copies, such as those returned by list(*x*) for a list
    *x* and copy.copy(*x*) for any *x*, are known as *shallow* copies: when *x* has
    references to other objects (either as items or as attributes), a normal (shallow)
    copy of *x* has distinct references to the *same* objects. Sometimes, however,
    you need a *deep* copy, where referenced objects are deep-copied recursively (fortunately,
    this need is rare, since a deep copy can take a lot of memory and time); for these
    cases, the copy module also supplies a deepcopy function. These functions are
    discussed further in [Table 8-4](#copy_module_functions).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 复制模块提供了一个复制函数用于创建和返回多种类型对象的副本。正常副本，例如对于列表 *x* 返回的 list(*x*) 和对于任何 *x* 返回的 copy.copy(*x*)，称为
    *浅层* 副本：当 *x* 引用其他对象（作为项或属性时），*x* 的普通（浅层）副本具有对相同对象的不同引用。然而，有时您需要一个 *深层* 副本，在这种副本中，引用的对象被递归地进行深层复制（幸运的是，这种需求很少，因为深层复制可能需要大量内存和时间）；对于这些情况，复制模块还提供了一个
    deepcopy 函数。这些函数在 [表 8-4](#copy_module_functions) 中进一步讨论。
- en: Table 8-4\. copy module functions
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-4\. 复制模块函数
- en: '| copy | copy(*x*) Creates and returns a shallow copy of *x*, for *x* of many
    types (modules, files, frames, and other internal types, however, are not supported).
    When *x* is immutable, copy.copy(*x*) may return *x* itself as an optimization.
    A class can customize the way copy.copy copies its instances by having a special
    method __copy__(self) that returns a new object, a shallow copy of self. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| copy | copy(*x*) 创建并返回 *x* 的浅层副本，适用于多种类型的 *x*（模块、文件、帧以及其他内部类型，但不支持）。当 *x*
    是不可变的时候，作为优化，copy.copy(*x*) 可能返回 *x* 本身。一个类可以通过拥有特殊方法 __copy__(self)，返回一个新对象，即
    self 的浅层副本，来自定义 copy.copy 复制其实例的方式。 |'
- en: '| deepcopy | deepcopy(*x*,[memo]) Makes a deep copy of *x* and returns it.
    Deep copying implies a [recursive walk](https://oreil.ly/8Sf4q) over a directed
    (but not necessarily [acyclic](https://oreil.ly/RivIZ)) graph of references. Be
    aware that to reproduce the graph’s exact shape, when references to the same object
    are met more than once during the walk, you must *not* make distinct copies; rather,
    you must use *references* to the same copied object. Consider the following simple
    example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '| deepcopy | deepcopy(*x*,[memo]) 对 *x* 进行深层复制并返回。深层复制意味着对引用图进行递归遍历。请注意，为了重现图形的确切形状，当在遍历过程中多次遇到对同一对象的引用时，您不能制作不同的副本；相反，必须使用对同一复制对象的
    *引用*。考虑以下简单示例：'
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'original[0] **is** original[1] is **True** (i.e., the two items of original
    refer to the same object). This is an important property of original, and anything
    claiming to be “a copy” must preserve it. The semantics of copy.deepcopy ensure
    that thecopy[0] **is** thecopy[1] is also **True**: the graphs of references of
    original and thecopy have the same shape. Avoiding repeated copying has an important
    beneficial side effect: it prevents infinite loops that would otherwise occur
    when the graph of references has cycles.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: original[0] **is** original[1] is **True**（即，original 的两个项引用同一对象）。这是 original
    的一个重要属性，任何宣称“一个副本”的东西都必须保留它。copy.deepcopy 的语义确保 thecopy[0] **is** thecopy[1] 也是
    **True**：original 和 thecopy 的引用图具有相同的形状。避免重复复制具有一个重要的有益副作用：它防止引用图中存在循环时会发生的无限循环。
- en: 'copy.deepcopy accepts a second, optional argument: memo, a dict that maps the
    id of each object already copied to the new object that is its copy. memo is passed
    by all recursive calls of deepcopy to itself; you may also explicitly pass it
    (normally as an originally empty dict) if you also need to obtain a correspondence
    map between the identities of originals and copies (the final state of memo will
    then be just such a mapping).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: copy.deepcopy 接受第二个可选参数：memo，一个将每个已复制对象的 id 映射到其副本的字典。memo 被 deepcopy 的所有递归调用传递给自己；如果您需要获取原始对象和副本之间的对应映射（通常作为一个最初为空的字典），您也可以显式地传递它（memo
    的最终状态将是这样一个映射）。
- en: A class can customize the way copy.deepcopy copies its instances by having a
    special method __deepcopy__(self, memo) that returns a new object, a deep copy
    of self. When __deepcopy__ needs to deep-copy some referenced object *subobject*,
    it must do so by calling copy.deepcopy(*subobject*, memo). When a class has no
    special method __deepcopy__, copy.deepcopy on an instance of that class also tries
    calling the special methods __getinitargs__, __getnewargs__, __getstate__, and
    __setstate__, covered in [“Pickling instances”](ch12.xhtml#pickling_instances).
    |
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以通过拥有特殊方法 __deepcopy__(self, memo) 来定制 copy.deepcopy 复制其实例的方式，该方法返回一个新对象，即
    self 的深层副本。当 __deepcopy__ 需要深层复制一些引用对象 *subobject* 时，必须通过调用 copy.deepcopy(*subobject*,
    memo) 来实现。当一个类没有特殊方法 __deepcopy__ 时，对该类的实例使用 copy.deepcopy 也会尝试调用特殊方法 __getinitargs__、__getnewargs__、__getstate__
    和 __setstate__，详见 [“实例的序列化”](ch12.xhtml#pickling_instances)。
- en: The collections Module
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: collections 模块
- en: The collections module supplies useful types that are collections (i.e., containers),
    as well as the ABCs covered in [“Abstract Base Classes”](ch04.xhtml#abstract_base_classe).
    Since Python 3.4, the ABCs have been in collections.abc; for backward compatibility
    they could still be accessed directly in collections itself until Python 3.9,
    but this functionality was removed in 3.10.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: collections 模块提供了有用的类型，这些类型是集合（即，容器），以及 [“抽象基类”](ch04.xhtml#abstract_base_classe)
    中涵盖的 ABC。自 Python 3.4 起，ABC 在 collections.abc 中提供；为了向后兼容，直到 Python 3.9 仍然可以直接在
    collections 中访问，但此功能在 3.10 中已移除。
- en: ChainMap
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ChainMap
- en: 'ChainMap “chains” multiple mappings together; given a ChainMap instance *c*,
    accessing *c*[*key*] returns the value in the first of the mappings that has that
    key, while *all* changes to *c* affect only the very first mapping in *c*. To
    further explain, you could approximate this as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ChainMap 将多个映射“链接”在一起；给定 ChainMap 实例 *c*，访问 *c*[*key*] 返回具有该键的第一个映射中的值，而对 *c*
    的所有更改仅影响 *c* 中的第一个映射。为了进一步解释，您可以如下近似：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Other methods could be defined for efficiency, but this is the minimum set that
    a MutableMapping requires. See the [online docs](https://oreil.ly/WgfFo) for more
    details and a collection of recipes on how to use ChainMap.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法可以为了效率而定义，但这是 MutableMapping 要求的最小集合。更多详情和一组关于如何使用 ChainMap 的示例，请参阅 [在线文档](https://oreil.ly/WgfFo)。
- en: Counter
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数器
- en: 'Counter is a subclass of dict with int values that are meant to *count* how
    many times a key has been seen (although values are allowed to be <= 0); it’s
    roughly equivalent to types that other languages call “bag” or “multiset” types.
    A Counter instance is normally built from an iterable whose items are hashable:
    *c* = collections.Counter(*iterable*). Then, you can index *c* with any of *iterable*’s
    items to get the number of times that item appeared. When you index *c* with any
    missing key, the result is 0 (to *remove* an entry in *c*, use **del** *c*[*entry*];
    setting *c*[*entry*]=0 leaves *entry* in *c*, with a value of 0).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器是 int 值的 dict 的子类，用于*计数*键已经被看到多少次（尽管允许值 <= 0）；它大致相当于其他语言中称为“bag”或“multiset”类型的类型。通常，Counter
    实例是从其项是可散列的可迭代对象构建的：*c* = collections.Counter(*iterable*)。然后，您可以使用 *iterable*
    的任何项对 *c* 进行索引以获取该项出现的次数。当您使用任何缺失的键对 *c* 进行索引时，结果为 0（要 *移除* *c* 中的条目，请使用 **del**
    *c*[*entry*]；将 *c*[*entry*]=0 留下 *c* 中的 *entry*，其值为 0）。
- en: '*c* supports all methods of dict; in particular, *c*.update(*otheriterable*)
    updates all the counts, incrementing them according to occurrences in *otheriterable*.
    So, for example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*c* 支持字典的所有方法；特别是，*c*.update(*otheriterable*) 更新所有计数，根据 *otheriterable* 中的出现次数递增它们。例如：'
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'leaves *c*[''o''] giving 4, and *c*[''f''] and *c*[''m''] each giving 1. Note
    that removing an entry from *c* (with **del**) may *not* decrement the counter,
    but subtract (described in the following table) does:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 离开 *c*['o'] 得到 4，*c*['f'] 和 *c*['m'] 分别得到 1。注意，从 *c* 中移除条目（用 **del**）可能 *不会*
    减少计数器，但是减去（在下表中描述）会：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In addition to dict methods, *c* supports the extra methods detailed in [Table 8-5](#methods_of_a_counter_instance_c).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字典方法外，*c* 还支持详细说明的额外方法，见 [表 8-5](#methods_of_a_counter_instance_c)。
- en: Table 8-5\. Methods of a Counter instance c
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-5\. 计数器实例 c 的方法
- en: '| elements | *c*.elements() Yields, in arbitrary order, keys in *c* with *c*[*key*]>0,
    yielding each key as many times as its count. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| elements | *c*.elements() 以任意顺序产生 *c* 中 *c*[*key*]>0 的键，每个键产生的次数与其计数相同。 |'
- en: '| mo⁠s⁠t⁠_​c⁠o⁠m⁠mon | *c*.most_common([*n*, /]) Returns a list of pairs for
    the *n* keys in *c* with the highest counts (all of them, if you omit *n*), in
    order of decreasing count (“ties” between keys with the same count are resolved
    arbitrarily); each pair is of the form (*k*, *c*[*k*]), where *k* is one of the
    *n* most common keys in *c*. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| mo⁠s⁠t⁠_​c⁠o⁠m⁠mon | *c*.most_common([*n*, /]) 返回 *c* 中计数最高的前 *n* 个键的列表（如果省略
    *n*，则为所有键），按计数降序排序（具有相同计数的键之间的“平局”将任意解决）；每对形式为 (*k*, *c*[*k*])，其中 *k* 是 *c* 中前
    *n* 个最常见的键之一。'
- en: '| subtract | *c*.subtract(*iterable=***None**, /, ***kwds*) Like *c*.update(*iterable*)
    “in reverse”—that is, *subtracting* counts rather than *adding* them. Resulting
    counts in *c* can be <= 0. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| subtract | *c*.subtract(*iterable=***None**, /, ***kwds*) 类似于 *c*.update(*iterable*)
    的“反向操作”——即减去计数而不是增加它们。*c* 中的结果计数可以 <= 0。'
- en: '| total | *c.*total() **3.10+** Returns the sum of all the individual counts.
    Equivalent to sum(*c*.values()). |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| total | *c.*total() **3.10+** 返回所有个体计数的总和。等同于 sum(*c*.values())。'
- en: Counter objects support common arithmetic operators, such as +, -, &, and |
    for addition, subtraction, union, and intersection. See the [online docs](https://oreil.ly/MylAp)
    for more details and a collection of useful recipes on how to use Counter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Counter 对象支持常见的算术运算符，如 +、-、& 和 |，用于加法、减法、并集和交集。详见 [在线文档](https://oreil.ly/MylAp)
    获取更多详情和一系列关于如何使用 Counter 的实用示例。
- en: OrderedDict
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OrderedDict
- en: 'OrderedDict is a subclass of dict with additional methods to access and manipulate
    items with respect to their insertion order. *o*.popitem() removes and returns
    the item at the most recently inserted key; *o*.move_to_end(*key*, last=**True**)
    moves the item with key *key* to the end (when last is **True**, the default)
    or to the start (when last is **False**). Equality tests between two instances
    of OrderedDict are order sensitive; equality tests between an instance of OrderedDict
    and a dict or other mapping are not. Since Python 3.7, dict insertion order is
    guaranteed to be maintained: many uses that previously required OrderedDict can
    now just use ordinary Python dicts. A significant difference remaining between
    the two is that OrderedDict’s test for equality with other OrderedDicts is order
    sensitive, while dict’s equality test is not. See the [online docs](https://oreil.ly/JSvPS)
    for more details and a collection of recipes on how to use OrderedDict.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: OrderedDict 是 dict 的子类，具有额外的方法来按插入顺序访问和操作条目。*o*.popitem() 删除并返回最近插入的键的条目；*o*.move_to_end(*key*,
    last=**True**) 将具有键 *key* 的条目移动到末尾（当 last 为 **True** 时，默认为末尾）或开头（当 last 为 **False**
    时）。两个 OrderedDict 实例之间的相等性测试是顺序敏感的； OrderedDict 实例与 dict 或其他映射的相等性测试则不是。自 Python
    3.7 起，dict 插入顺序已保证保持不变：许多以前需要 OrderedDict 的用法现在可以直接使用普通的 Python dict。两者之间仍存在一个显著的差异，即
    OrderedDict 与其他 OrderedDict 的相等性测试是顺序敏感的，而 dict 的相等性测试则不是。详见 [在线文档](https://oreil.ly/JSvPS)
    获取更多详情和一系列关于如何使用 OrderedDict 的示例。
- en: defaultdict
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: defaultdict
- en: 'defaultdict extends dict and adds one per instance attribute, named default_factory.
    When an instance *d* of defaultdict has **None** as the value of *d*.default_factory,
    *d* behaves exactly like a dict. Otherwise, *d*.default_factory must be callable
    without arguments, and *d* behaves just like a dict except when you access *d*
    with a key *k* that is not in *d*. In this specific case, the indexing *d*[*k*]
    calls *d*.default_factory(), assigns the result as the value of *d*[*k*], and
    returns the result. In other words, the type defaultdict behaves much like the
    following Python-coded class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: defaultdict 是 dict 的扩展，每个实例都添加了一个名为 default_factory 的属性。当 defaultdict 实例 *d*
    的 *d*.default_factory 值为 **None** 时，*d* 表现得和 dict 完全一样。否则，*d*.default_factory
    必须是一个可调用的无参数函数，*d* 的行为和 dict 类似，除非你使用一个不存在于 *d* 中的键 *k* 访问 *d*。在这种情况下，索引 *d*[*k*]
    调用 *d*.default_factory()，将结果分配为 *d*[*k*] 的值，并返回结果。换句话说，defaultdict 类型的行为很像下面这样用
    Python 编写的类：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As this Python equivalent implies, to instantiate defaultdict you usually pass
    it an extra first argument (before any other arguments, positional and/or named,
    if any, to pass on to plain dict). The extra first argument becomes the initial
    value of default_factory; you can also access and rebind default_factory later,
    though doing so is infrequent in normal Python code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个 Python 等效物所暗示的，要实例化 defaultdict，通常需要将额外的第一个参数传递给它（在任何其他参数之前，位置和/或命名，如果有的话，传递给普通
    dict）。额外的第一个参数将成为 default_factory 的初始值；你也可以稍后访问和重新绑定 default_factory，尽管在正常的 Python
    代码中这样做是不常见的。
- en: All behavior of defaultdict is essentially as implied by this Python equivalent
    (except str and repr, which return strings different from those they would return
    for a dict). Named methods, such as get and pop, are not affected. All behavior
    related to keys (method keys, iteration, membership test via operator in, etc.)
    reflects exactly the keys that are currently in the container (whether you put
    them there explicitly, or implicitly via an indexing that called default_factory).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: defaultdict 的所有行为基本上与此 Python 等效内容暗示的行为相同（除了 str 和 repr，它们返回的字符串与 dict 返回的字符串不同）。命名方法，如
    get 和 pop，并不受影响。与键相关的所有行为（方法 keys、迭代、通过运算符 in 进行成员测试等）完全反映了当前容器中的键（无论是显式放置还是通过调用
    default_factory 隐式放置）。
- en: 'A typical use of defaultdict is, for example, to set default_factory to list,
    to make a mapping from keys to lists of values:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: defaultdict 的典型用途是，例如将 default_factory 设置为 list，以创建从键到值列表的映射：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Called with any iterable whose items are pairs of the form (*key*, *value*),
    with all keys being hashable, this make_multi_dict function returns a mapping
    that associates each key to the lists of one or more values that accompanied it
    in the iterable (if you want a pure dict result, change the last statement into
    return dict(d)—this is rarely necessary).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何元素为形式为 (*key*, *value*) 对的可迭代对象调用 make_multi_dict 函数时，此函数返回一个映射，将每个键关联到伴随其出现的一个或多个值列表（如果要得到纯字典结果，请将最后一条语句更改为
    return dict(d)——这很少是必要的）。
- en: If you don’t want duplicates in the result, and every *value* is hashable, use
    a collections.defaultdict(set), and add rather than append in the loop.^([2](ch08.xhtml#ch01fn88))
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不希望结果中有重复项，并且每个 *value* 都是可哈希的，请使用 collections.defaultdict(set)，并在循环中添加而不是追加。^([2](ch08.xhtml#ch01fn88))
- en: deque
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: deque
- en: deque is a sequence type whose instances are “double-ended queues” (additions
    and removals at either end are fast and thread-safe). A deque instance *d* is
    a mutable sequence, with an optional maximum length, and can be indexed and iterated
    on (however, *d* cannot be sliced; it can only be indexed one item at a time,
    whether for access, rebinding, or deletion). If a deque instance *d* has a maximum
    length, when items are added to either side of *d* so that *d*’s length exceeds
    that maximum, items are silently dropped from the other side.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: deque 是一种序列类型，其实例为“双端队列”（在任一端的添加和移除都很快且线程安全）。deque 实例 *d* 是可变序列，可选择具有最大长度，并且可以进行索引和迭代（但是，*d*
    不能进行切片；它只能一次索引一个项目，无论是用于访问、重新绑定还是删除）。如果 deque 实例 *d* 具有最大长度，当向 *d* 的任一侧添加项目以使
    *d* 的长度超过该最大长度时，将从另一侧静默删除项目。
- en: deque is especially useful for implementing first-in, first-out (FIFO) queues.^([3](ch08.xhtml#ch01fn89))
    deque is also good for maintaining “the latest *N* things seen,” also known in
    some other languages as a *ring buffer*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: deque 特别适用于实现先进先出（FIFO）队列。^([3](ch08.xhtml#ch01fn89)) deque 也很适合维护“最新 *N* 个看到的事物”，在其他一些语言中也称为环形缓冲区。
- en: '[Table 8-6](#deque_methods) lists the methods the deque type supplies.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-6](#deque_methods) 列出了 deque 类型提供的方法。'
- en: Table 8-6\. deque methods
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-6\. deque 方法
- en: '| deque | deque(*seq*=(), /, maxlen=**None**) The initial items of *d* are
    those of *seq*, in the same order. *d*.maxlen is a read-only attribute: when its
    value is **None**, *d* has no maximum length; when an int, it must be >=0. *d*’s
    maximum length is *d*.maxlen. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| deque | deque(*seq*=(), /, maxlen=**None**) *d* 的初始项目是 *seq* 的项目，顺序相同。 *d*.maxlen
    是只读属性：当其值为 **None** 时，*d* 没有最大长度；当为整数时，必须 >=0。 *d* 的最大长度是 *d*.maxlen。 |'
- en: '| append | *d*.append(*item*, /) Appends *item* at the right (end) of *d*.
    |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| append | *d*.append(*item*, /) 将 *item* 追加到 *d* 的右侧（末尾）。 |'
- en: '| appendleft | *d*.appendleft(*item*, /) Appends *item* at the left (start)
    of *d*. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| appendleft | *d*.appendleft(*item*, /) 将 *item* 追加到 *d* 的左侧（开头）。 |'
- en: '| clear | *d*.clear() Removes all items from *d*, leaving it empty. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| clear | *d*.clear() 从 *d* 中移除所有项目，使其为空。 |'
- en: '| extend | *d*.extend(*iterable*, /) Appends all items of *iterable* at the
    right (end) of *d*. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| extend | *d*.extend(*iterable*, /) 将 *iterable* 中的所有项目追加到 *d* 的右侧（末尾）。 |'
- en: '| extendleft | *d*.extendleft(*iterable*, /) Appends all items of *iterable*
    at the left (start) of *d*, in reverse order. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| extendleft | *d*.extendleft(*iterable*, /) 将 *iterable* 中的所有项目以相反的顺序追加到 *d*
    的左侧（开头）。 |'
- en: '| pop | *d*.pop() Removes and returns the last (rightmost) item from *d*. If
    *d* is empty, raises IndexError. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| pop | *d*.pop() 从 *d* 中移除并返回最后一个（最右边的）项目。如果 *d* 是空的，则引发 IndexError 异常。 |'
- en: '| popleft | *d*.popleft() Removes and returns the first (leftmost) item from
    *d*. If *d* is empty, raises IndexError. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| popleft | *d*.popleft() 从 *d* 中移除并返回第一个（最左边的）项目。如果 *d* 是空的，则引发 IndexError
    异常。 |'
- en: '| rotate | *d*.rotate(*n*=1, /) Rotates *d n* steps to the right (if *n*<0,
    rotates left). |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| rotate | *d*.rotate(*n*=1, /) 将 *d* 向右旋转 *n* 步（如果 *n* < 0，则向左旋转）。 |'
- en: Avoid Indexing or Slicing a deque
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免对 deque 进行索引或切片
- en: deque is primarily intended for cases that access, add, and remove items from
    either the deque’s start or end. While indexing or slicing into a deque is possible,
    it may only have O(n) performance (vs O(1) for list) when accessing an inner value
    using deque[i] form. If you must access inner values, consider using a list instead.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: deque 主要用于从 deque 的开头或结尾访问、添加和删除项目的情况。虽然可以对 deque 进行索引或切片，但当使用 deque[i] 形式访问内部值时，性能可能为
    O(n)（而列表为 O(1)）。如果必须访问内部值，请考虑使用列表。
- en: The functools Module
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: functools 模块
- en: The functools module supplies functions and types supporting functional programming
    in Python, listed in [Table 8-7](#functions_and_attributes_of_the_functoo).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: functools 模块提供支持 Python 函数式编程的函数和类型，列在 [表 8-7](#functions_and_attributes_of_the_functoo)
    中。
- en: Table 8-7\. Functions and attributes of the functools module
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-7\. functools 模块的函数和属性
- en: '| cach⁠e⁠d⁠_​p⁠r⁠o⁠perty | cached_property(func) 3.8+ A caching version of
    the property decorator. Evaluating the property the first time caches the returned
    value, so that subsequent calls can return the cached value instead of repeating
    the property calculation. cached_property uses a threading lock to ensure that
    the property calculation is performed only once, even in a multithreaded environment.^([a](ch08.xhtml#ch01fn90))
    |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| cach⁠e⁠d⁠_​p⁠r⁠o⁠p⁠erty | cached_property(func) 3.8+ 一个缓存版本的属性修饰器。第一次计算属性时会缓存返回的值，因此后续调用可以返回缓存的值，而不是重复计算属性。cached_property
    使用线程锁确保在多线程环境中只执行一次属性计算。^([a](ch08.xhtml#ch01fn90)) |'
- en: '| lru_cache, cache | lru_cache(max_size=128, typed=**False**), cache()'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '| lru_cache, cache | lru_cache(max_size=128, typed=**False**), cache()'
- en: A *memoizing* decorator suitable for decorating a function whose arguments are
    all hashable, adding to the function a cache storing the last max_size results
    (max_size should be a power of 2, or **None** to have the cache keep all previous
    results); when you call the decorated function again with arguments that are in
    the cache, it immediately returns the previously cached result, bypassing the
    underlying function’s body code. When typed is **True**, arguments that compare
    equal but have different types, such as 23 and 23.0, are cached separately. 3.9+
    If setting max_size to **None**, use cache instead. For more details and examples,
    see the [online docs](https://oreil.ly/hLRYd). 3.8+ lru_cache may also be used
    as a decorator with no (). |
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 适合装饰一个函数的 *memoizing* 装饰器，其所有参数都是可散列的，向函数添加一个缓存，存储最后的 max_size 个结果（max_size
    应为 2 的幂，或 **None** 以保留所有先前的结果）；当再次使用与缓存中的参数调用装饰函数时，它将立即返回先前缓存的结果，绕过底层函数的主体代码。当
    typed 设置为 **True** 时，相等但类型不同的参数（例如 23 和 23.0）将分别缓存。3.9+ 如果将 max_size 设置为 **None**，则使用
    cache 替代。有关更多详细信息和示例，请参阅 [在线文档](https://oreil.ly/hLRYd)。3.8+ lru_cache 也可作为无括号的装饰器使用。
- en: '| partial | partial(*func*, /, **a, **k*) Returns a callable *p* that is just
    like *func* (which is any callable), but with some positional and/or named parameters
    already bound to the values given in *a* and *k*. In other words, *p* is a *partial
    application* of *func*, often also known (with debatable correctness, but colorfully,
    in honor of mathematician Haskell Curry) as a *currying* of *func* to the given
    arguments. For example, say that we have a list of numbers L and want to clip
    the negative ones to 0. One way to do it is:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '| partial | partial(*func*, /, **a, **k*) 返回一个可调用对象 *p*，它与 *func*（任何可调用对象）类似，但某些位置参数和/或命名参数已绑定到给定的
    *a* 和 *k* 的值。换句话说，*p* 是 *func* 的部分应用，通常也被称为 *func* 对给定参数的 *柯里化*（在数学家 Haskell Curry
    的荣誉上，尽管正确性有争议，但用语色彩丰富）。例如，假设我们有一个数字列表 L，并希望将负数剪切为 0。一种方法是：'
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'as an alternative to the **lambda**-using snippet:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为**lambda**使用的替代片段：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'and to the most concise approach, a list comprehension:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以及最简洁的方法，即列表推导：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: functools.partial comes into its own in situations that demand callbacks, such
    as event-driven programming for some GUIs and networking applications.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: functools.partial 在需要回调的情况下特别适用，例如某些 GUI 和网络应用的事件驱动编程。
- en: partial returns a callable with the attributes func (the wrapped function),
    args (the tuple of prebound positional arguments), and keywords (the dict of prebound
    named arguments, or **None**). |
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: partial 返回一个带有 func（包装函数）、args（预绑定的位置参数元组）和 keywords（预绑定的命名参数字典，或者 **None**）属性的可调用对象。
    |
- en: '| reduce | reduce(*func*, *seq*[, *init*], /) Applies *func* to the items of
    *seq*, from left to right, to reduce the iterable to a single value. *func* must
    be callable with two arguments. reduce calls *func* on the first two items of
    *seq*, then on the result of the first call and the third item, and so on, and
    returns the result of the last such call. When *init* is present, reduce uses
    it before *seq*’s first item, if any. When *init* is missing, *seq* must be nonempty.
    When *init* is missing and *seq* has only one item, reduce returns *seq*[0]. Similarly,
    when *init* is present and *seq* is empty, reduce returns *init**.* reduce is
    thus roughly equivalent to:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '| reduce | reduce(*func*, *seq*[, *init*], /) 将 *func* 应用于 *seq* 的项，从左到右，将可迭代对象减少为单个值。*func*
    必须是可调用的，接受两个参数。reduce 首先将 *func* 应用于 *seq* 的前两个项，然后将第一次调用的结果和第三个项进行调用，依此类推，返回最后一次调用的结果。如果存在
    *init*，reduce 在 *seq* 的第一项之前使用它（如果有的话）。如果 *init* 缺失，*seq* 必须非空。如果 *init* 缺失且 *seq*
    只有一个项，则 reduce 返回 *seq*[0]。类似地，如果存在 *init* 且 *seq* 为空，则 reduce 返回 *init*。因此，reduce
    大致等同于：'
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'An example use of reduce is to compute the product of a sequence of numbers:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 reduce 的示例用法是计算一系列数字的乘积：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| singledispatch, singledispatchmethod | Function decorators to support multiple
    implementations of a method with differing types for their first argument. See
    the [online docs](https://oreil.ly/1nle3) for a detailed description. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| singledispatch, singledispatchmethod | 函数装饰器，支持具有不同类型的第一个参数的方法的多个实现。有关详细描述，请参阅
    [在线文档](https://oreil.ly/1nle3)。 |'
- en: '| total_ordering | A class decorator suitable for decorating classes that supply
    at least one inequality comparison method, such as __lt__, and, ideally, also
    supply __eq__. Based on the class’s existing methods, the class decorator total_ordering
    adds to the class all other inequality comparison methods that aren’t implemented
    in the class itself or any of its superclasses, removing the need for you to add
    boilerplate code for them. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| total_ordering | 一个类装饰器，适用于装饰至少提供一个不等比较方法（如 __lt__）的类，并且最好也提供 __eq__。基于类的现有方法，total_ordering
    类装饰器为类添加了所有其他不等比较方法，这些方法在类本身或任何超类中都没有实现，从而避免您为它们添加样板代码。 |'
- en: '| wraps | wraps(wrapped) A decorator suitable for decorating functions that
    wrap another function, wrapped (often nested functions within another decorator).
    wraps copies the __name__, __doc__, and __module__ attributes of wrapped on the
    decorated function, thus improving the behavior of the built-in function help,
    and of doctests, covered in [“The doctest Module”](ch17.xhtml#the_doctest_module).
    |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| wraps | wraps(wrapped) 适用于装饰包装另一个函数 wrapped 的函数的装饰器（通常是在另一个装饰器内部的嵌套函数）。wraps
    复制了 wrapped 的 __name__、__doc__ 和 __module__ 属性到装饰函数上，从而改善了内置函数 help 和 doctests
    的行为，详情请参阅 [“The doctest Module”](ch17.xhtml#the_doctest_module)。 |'
- en: '| ^([a](ch08.xhtml#ch01fn90-marker)) In Python versions 3.8 to 3.11, cached_property
    is implemented using a class-level lock. As such, it synchronizes for all instances
    of the class or any subclass, not just the current instance. Thus, cached_property
    can reduce performance in a multithreaded environment, and is *not* recommended.
    |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch08.xhtml#ch01fn90-marker)) 在 Python 版本 3.8 到 3.11 中，cached_property
    是使用类级锁实现的。因此，它对于类或任何子类的所有实例都同步，而不仅仅是当前实例。因此，在多线程环境中，cached_property 可能会降低性能，*不*推荐使用。
    |'
- en: The heapq Module
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: heapq 模块
- en: The heapq module uses [*min-heap*](https://oreil.ly/RU6F_) algorithms to keep
    a list in “nearly sorted” order as items are inserted and extracted. heapq’s operation
    is faster than calling a list’s sort method after each insertion, and much faster
    than bisect (covered in the [online docs](https://oreil.ly/nZ_9m)). For many purposes,
    such as implementing “priority queues,” the nearly sorted order supported by heapq
    is just as good as a fully sorted order, and faster to establish and maintain.
    The heapq module supplies the functions listed in [Table 8-8](#functions_of_the_heapq_module).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: heapq 模块使用 [*min-heap*](https://oreil.ly/RU6F_) 算法，在插入和提取项目时将列表保持“几乎排序”的顺序。heapq
    的操作速度比每次插入后调用列表的排序方法要快得多，比 bisect（在 [在线文档](https://oreil.ly/nZ_9m) 中介绍）要快得多。对于许多目的，比如实现“优先队列”，heapq
    支持的几乎排序顺序和完全排序顺序一样好，并且建立和维护速度更快。heapq 模块提供了 [Table 8-8](#functions_of_the_heapq_module)
    中列出的函数。
- en: Table 8-8\. Functions of the heapq module
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Table 8-8\. heapq 模块的函数列表
- en: '| heapify | heapify(*alist*, /) Permutes list *alist* as needed to make it
    satisfy the (min) heap condition:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '| heapify | heapify(*alist*, /) 根据需要重新排列列表 *alist*，使其满足（最小）堆条件：'
- en: 'For any *i* >= 0:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何 *i* >= 0：
- en: alist[*i*] <= alist[2 * *i* + 1] and
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: alist[*i*] <= alist[2 * *i* + 1] and
- en: alist[*i*] <= alist[2 * *i* + 2]
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: alist[*i*] <= alist[2 * *i* + 2]
- en: as long as all the indices in question are <len(*alist*).
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要所有相关的索引都小于 len(*alist*)。
- en: If a list satisfies the (min) heap condition, the list’s first item is the smallest
    (or equal-smallest) one. A sorted list satisfies the heap condition, but many
    other permutations of a list also satisfy the heap condition without requiring
    the list to be fully sorted. heapify runs in O(len(*alist*)) time. |
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个列表满足（最小）堆条件，则列表的第一个项是最小的（或者相等最小的）项。排序后的列表满足堆条件，但列表的许多其他排列也可以满足堆条件，而不需要列表完全排序。heapify
    运行时间为 O(len(*alist*))。
- en: '| heappop | heappop(*alist*, /) Removes and returns the smallest (first) item
    of *alist*, a list that satisfies the heap condition, and permutes some of the
    remaining items of *alist* to ensure the heap condition is still satisfied after
    the removal. heappop runs in O(log(len(*alist*))) time. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| heappop | heappop(*alist*, /) 移除并返回 *alist* 中最小（第一个）项，一个满足堆条件的列表，并重新排列 *alist*
    的一些剩余项，以确保在移除后仍满足堆条件。heappop 运行时间为 O(log(len(*alist*)))。'
- en: '| heappush | heappush(*alist*, *item*, /) Inserts *item* in *alist*, a list
    that satisfies the heap condition, and permutes some items of *alist* to ensure
    the heap condition is still satisfied after the insertion. heappush runs in O(log(len(*alist*)))
    time. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| heappush | heappush(*alist*, *item*, /) 在满足堆条件的 *alist* 中插入 *item*，并重新排列一些
    *alist* 的项，以确保在插入后仍满足堆条件。heappush 运行时间为 O(log(len(*alist*)))。'
- en: '| heappushpop | heappushpop(*alist*, *item*, /) Logically equivalent to heappush
    followed by heappop, similar to:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '| heappushpop | heappushpop(*alist*, *item*, /) 逻辑上等价于先执行 heappush，然后执行 heappop，类似于：'
- en: '[PRE31]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'heappushpop runs in O(log(len(*alist*))) time and is generally faster than
    the logically equivalent function just shown. heappushpop can be called on an
    empty *alist*: in that case, it returns the *item* argument, as it does when *item*
    is smaller than any existing item of *alist*. |'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: heappushpop 运行时间为 O(log(len(*alist*)))，通常比逻辑上等价的函数更快。heappushpop 可以在空的 *alist*
    上调用：在这种情况下，它返回 *item* 参数，就像当 *item* 小于 *alist* 的任何现有项时一样。
- en: '| heapreplace | heapreplace(*alist*, *item*, /) Logically equivalent to heappop
    followed by heappush, similar to:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '| heapreplace | heapreplace(*alist*, *item*, /) 逻辑上等价于先执行 heappop，然后执行 heappush，类似于：'
- en: '[PRE32]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'heapreplace runs in O(log(len(*alist*))) time and is generally faster than
    the logically equivalent function just shown. heapreplace cannot be called on
    an empty *alist*: heapreplace always returns an item that was already in *alist*,
    never the *item* just being pushed onto it. |'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: heapreplace 运行时间为 O(log(len(*alist*)))，通常比逻辑上等价的函数更快。heapreplace 不能在空的 *alist*
    上调用：heapreplace 总是返回已经在 *alist* 中的项，而不是刚刚被推送到 *alist* 上的 *item*。
- en: '| merge | merge(**iterables*) Returns an iterator yielding, in sorted order
    (smallest to largest), the items of the *iterables*, each of which must be smallest-to-largest
    sorted. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| merge | merge(**iterables*) 返回一个迭代器，按照从小到大的顺序（排序顺序）产生 *iterables* 的项，其中每个项必须是从小到大排序的。'
- en: '| nlargest | nlargest(*n*, *seq*, /, key=**None**) Returns a reverse-sorted
    list with the *n* largest items of iterable *seq* (or less than *n* if *seq* has
    fewer than *n* items); like sorted(*seq*, reverse=**True**)[:*n*], but faster
    when *n* is “small enough”^([a](ch08.xhtml#ch01fn91)) compared to len(*seq*).
    You may also specify a (named or positional) key= argument, like you can for sorted.
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| nlargest | nlargest(*n*, *seq*, /, key=**None**) 返回一个逆序排列的列表，包含可迭代序列 *seq*
    的 *n* 个最大项（或者少于 *n* 项，如果 *seq* 的项少于 *n* 项）；当 *n* 相对于 len(*seq*) 足够小时比 sorted(*seq*,
    reverse=**True**)[:*n*] 更快。您也可以指定一个（命名或位置的）key= 参数，就像您可以为 sorted 指定的那样。'
- en: '| nsmallest | nsmallest(*n*, *seq*, /, key=**None**) Returns a sorted list
    with the *n* smallest items of iterable *seq* (or less than *n* if *seq* has fewer
    than *n* items); like sorted(*seq*)[:*n*], but faster when *n* is “small enough”
    compared to len(*seq*). You may also specify a (named or positional) key= argument,
    like you can for sorted. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| nsmallest | nsmallest(*n*, *seq*, /, key=**None**) 返回一个已排序的列表，包含可迭代序列 *seq*
    的 *n* 个最小项（或者少于 *n* 项，如果 *seq* 的项少于 *n* 项）；当 *n* 相对于 len(*seq*) 足够小时比 sorted(*seq*)[:*n*]
    更快。您也可以指定一个（命名或位置的）key= 参数，就像您可以为 sorted 指定的那样。'
- en: '| ^([a](ch08.xhtml#ch01fn91-marker)) To find out how specific values of *n*
    and len(*seq*) affect the timing of nlargest, nsmallest, and sorted on your specific
    Python version and machine, use timeit, covered in [“The timeit module”](ch17.xhtml#the_timeit_module).
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch08.xhtml#ch01fn91-marker)) 要了解特定的 *n* 值和 len(*seq*) 如何影响 nlargest、nsmallest
    和 sorted 在您的具体 Python 版本和机器上的时间，可以使用 timeit，详见[“timeit 模块”](ch17.xhtml#the_timeit_module)。'
- en: The Decorate–Sort–Undecorate Idiom
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰-排序-去装饰模式
- en: 'Several functions in the heapq module, although they perform comparisons, do
    not accept a key= argument to customize the comparisons. This is inevitable, since
    the functions operate in place on a plain list of the items: they have nowhere
    to “stash away” custom comparison keys computed once and for all.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 堆模块中的几个函数虽然执行比较，但不接受key=参数以自定义比较。这是不可避免的，因为这些函数在原地操作一个简单的项列表：它们没有地方“存放”一次性计算好的自定义比较键。
- en: When you need both heap functionality and custom comparisons, you can apply
    the good old [*decorate–sort–undecorate (DSU)* idiom](https://oreil.ly/7iR8O)^([4](ch08.xhtml#ch01fn92))
    (which used to be crucial to optimize sorting in ancient versions of Python, before
    the key= functionality was introduced).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要堆功能和自定义比较时，你可以应用古老的[*装饰-排序-去装饰（DSU）*惯用语](https://oreil.ly/7iR8O)^([4](ch08.xhtml#ch01fn92))（在Python早期版本引入key=功能之前，这个惯用语曾是优化排序的关键）。
- en: 'The DSU idiom, as applied to heapq, has the following components:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: DSU惯用语，适用于heapq，具有以下组件：
- en: Decorate
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰
- en: Build an auxiliary list *A* where each item is a tuple starting with the sort
    key and ending with the item of the original list *L*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 建立一个辅助列表*A*，其中每个项都是一个元组，以排序键开头，并以原始列表*L*的项结尾。
- en: Sort
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 排序
- en: Call heapq functions on *A*, typically starting with heapq.heapify(*A*).^([5](ch08.xhtml#ch01fn93))
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在*A*上调用heapq函数，通常以heapq.heapify(*A*)开始。^([5](ch08.xhtml#ch01fn93))
- en: Undecorate
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 去装饰
- en: When you extract an item from *A*, typically by calling heapq.heappop(*A*),
    return just the last item of the resulting tuple (which was an item of the original
    list *L*).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从*A*中提取一个项，通常通过调用heapq.heappop(*A*)，只返回结果元组的最后一项（这是原始列表*L*的一项）。
- en: When you add an item to *A* by calling heapq.heappush(*A*, /, *item*), decorate
    the actual item you’re inserting into a tuple starting with the sort key.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过调用heapq.heappush(*A*, /, *item*)向*A*中添加项时，装饰你要插入的实际项到以排序键开头的元组中。
- en: 'This sequence of operations can be wrapped up in a class, as in this example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作序列可以封装在一个类中，如本例所示：
- en: '[PRE33]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, we use an increasing number in the middle of the decorated
    tuple (after the sort key, before the actual item) to ensure that actual items
    are *never* compared directly, even if their sort keys are equal (this semantic
    guarantee is an important aspect of the key argument’s functionality for sort
    and the like).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们在装饰的元组中间（排序键后、实际项前）使用一个递增的数字，以确保即使它们的排序键相等，实际项也*永远*不会直接比较（这种语义保证是排序功能中关键参数的重要方面）。
- en: The argparse Module
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: argparse模块
- en: 'When you write a Python program meant to be run from the command line (or from
    a shell script in Unix-like systems, or a batch file in Windows), you often want
    to let the user pass to the program, on the command line or within the script,
    *command-line arguments* (including *command-line options*, which by convention
    are arguments starting with one or two dash characters). In Python, you can access
    the arguments as sys.argv, an attribute of the module sys holding those arguments
    as a list of strings (sys.argv[0] is the name or path by which the user started
    your program; the arguments are in the sublist sys.argv[1:]). The Python standard
    library offers three modules to process those arguments; we only cover the newest
    and most powerful one, argparse, and we only cover a small, *core* subset of argparse’s
    rich functionality. See the online [reference](https://oreil.ly/v_ml0) and [tutorial](https://oreil.ly/QWg01)
    for much, much more. argparse provides one class, which has the following signature:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个Python程序，意图从命令行运行（或从类Unix系统的shell脚本，或从Windows的批处理文件），你通常希望让用户传递*命令行参数*（包括*命令行选项*，按约定以一个或两个破折号字符开头的参数）。在Python中，你可以访问这些参数作为sys.argv，这是sys模块的一个属性，将这些参数作为字符串列表存放（sys.argv[0]是用户启动程序的名称或路径；参数在子列表sys.argv[1:]中）。Python标准库提供了三个模块来处理这些参数；我们只涵盖最新和最强大的一个，argparse，并且只涵盖了一个小而*核心*的argparse丰富功能子集。请参阅在线[参考资料](https://oreil.ly/v_ml0)和[教程](https://oreil.ly/QWg01)，了解更多内容。argparse提供一个类，其签名如下：
- en: '| ArgumentParser | ArgumentParser(***kwargs*) ArgumentParser is the class whose
    instances perform argument parsing. It accepts many named arguments, mostly meant
    to improve the help message that your program displays if command-line arguments
    include -h or --help. One named argument you should always pass is description=,
    a string summarizing the purpose of your program. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| ArgumentParser | ArgumentParser(**kwargs*) ArgumentParser 是执行参数解析的类。它接受许多命名参数，大多用于改善程序在命令行参数包含
    -h 或 --help 时显示的帮助消息。你应该始终传递一个命名参数 description=，这是一个总结你的程序目的的字符串。'
- en: Given an instance *ap* of ArgumentParser, prepare it with one or more calls
    to *ap*.add_argument, then use it by calling *ap*.parse_args() without arguments
    (so it parses sys.argv). The call returns an instance of argparse.Namespace, with
    your program’s arguments and options as attributes.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 ArgumentParser 的实例 *ap*，通过一个或多个调用 *ap*.add_argument 进行准备，然后通过调用 *ap*.parse_args()（不带参数，因此它解析
    sys.argv）使用它。该调用返回一个 argparse.Namespace 的实例，其中包含你程序的参数和选项作为属性。
- en: 'add_argument has a mandatory first argument: an identifier string for positional
    command-line arguments, or a flag name for command-line options. In the latter
    case, pass one or more flag names; an option can have both a short name (dash,
    then a character) and a long name (two dashes, then an identifier).'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: add_argument 有一个强制的第一个参数：用于位置命令行参数的标识符字符串，或用于命令行选项的标志名称。在后一种情况下，传递一个或多个标志名称；选项可以同时具有短名称（破折号，然后一个字符）和长名称（两个破折号，然后一个标识符）。
- en: After the positional arguments, pass to add_argument zero or more named arguments
    to control its behavior. [Table 8-9](#common_named_arguments_to_add_argument)
    lists the most commonly used ones.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在位置参数之后，传递零个或多个命名参数以控制其行为。[表 8-9](#common_named_arguments_to_add_argument) 列出了最常用的几个。
- en: Table 8-9\. Common named arguments to add_argument
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-9\. add_argument 的常见命名参数
- en: '| action | What the parser does with this argument. Default: ''store'', which
    stores the argument’s value in the namespace (at the name given by dest, described
    later in this table). Also useful: ''store_true'' and ''store_false'', making
    an option into a bool (defaulting to the opposite bool if the option is not present),
    and ''append'', appending argument values to a list (and thus allowing an option
    to be repeated). |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| action | 解析器对此参数的操作。默认值：''store''，将参数的值存储在命名空间中（使用 dest 指定的名称，在本表后述）。还有几个有用的选项：''store_true''
    和 ''store_false''，将选项转换为布尔值（如果选项不存在，则默认为相反的布尔值），以及 ''append''，将参数值附加到列表中（因此允许选项重复）。'
- en: '| choices | A set of values allowed for the argument (parsing the argument
    raises an exception if the value is not among these). Default: no constraints.
    |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| choices | 允许参数的一组值（如果值不在其中，则解析参数会引发异常）。默认值：无约束。'
- en: '| default | Value if the argument is not present. Default: **None**. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| default | 如果参数不存在时的值。默认值：**None**。'
- en: '| dest | Name of the attribute to use for this argument. Default: same as the
    first positional argument stripped of leading dashes, if any. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| dest | 用于此参数的属性名称。默认值：与第一个位置参数去掉前导破折号相同，如果有的话。'
- en: '| help | A str describing the argument, for help messages. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| help | 描述参数用途的字符串，用于帮助消息。'
- en: '| nargs | The number of command-line arguments used by this logical argument.
    Default: 1, stored in the namespace. Can be an int > 0 (uses that many arguments,
    stores them as a list), ''?'' (1 or none, in which case it uses default), ''*''
    (0 or more, stored as a list), ''+'' (1 or more, stored as a list), or argparse.REMAINDER
    (all remaining arguments, stored as a list). |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| nargs | 逻辑参数使用的命令行参数的数量。默认值：1，存储在命名空间中。可以是大于 0 的整数（使用指定数量的参数，将它们存储为列表），''?''（1
    或无，此时使用默认值），''*''（0 或多个，存储为列表），''+''（1 或多个，存储为列表），或 argparse.REMAINDER（所有剩余参数，存储为列表）。'
- en: '| type | A callable accepting a string, often a type such as int; used to transform
    values from strings to something else. Can be an instance of argparse.FileType
    to open the string as a filename (for reading if FileType(''r''), for writing
    if FileType(''w''), and so on). |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| type | 接受字符串的可调用对象，通常是类型（如 int），用于将值从字符串转换为其他类型。可以是 argparse.FileType 的实例，将字符串作为文件名打开（如果
    FileType(''r'')，则读取，如果 FileType(''w'')，则写入，等等）。'
- en: 'Here’s a simple example of argparse—save this code in a file called *greet.py*:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 argparse 示例——将此代码保存在名为 *greet.py* 的文件中：
- en: '[PRE34]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, **python** **greet.py** prints Hello, World!, while **python** **greet.py**
    **--formal Cornelia** prints Most felicitous salutations, o Cornelia.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**python** **greet.py** 打印 Hello, World!，而 **python** **greet.py** **--formal
    Cornelia** 打印 Most felicitous salutations, o Cornelia.
- en: The itertools Module
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: itertools 模块
- en: 'The itertools module offers high-performance building blocks to build and manipulate
    iterators. To handle long processions of items, iterators are often better than
    lists, thanks to the iterators’ intrinsic “lazy evaluation” approach: an iterator
    produces items one at a time, as needed, while all items of a list (or other sequence)
    must be in memory at the same time. This approach even makes it feasible to build
    and use unbounded iterators, while lists must always have finite numbers of items
    (since any machine has a finite amount of memory).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: itertools 模块提供了高性能的构建块来构建和操作迭代器。为了处理大量的项目，迭代器通常比列表更好，这要归功于迭代器固有的“惰性评估”方法：迭代器逐个生成项目，而列表（或其他序列）的所有项目必须同时在内存中。这种方法甚至使得构建和使用无界迭代器成为可能，而列表必须始终具有有限数量的项目（因为任何计算机都具有有限的内存量）。
- en: '[Table 8-10](#functions_and_attributes_of_the_itertoo) covers the most frequently
    used attributes of itertools; each of them is an iterator type, which you call
    to get an instance of the type in question, or a factory function behaving similarly.
    See the [online docs](https://oreil.ly/d5Eew) for more itertools attributes, including
    *combinatorial* generators for permutations, combinations, and Cartesian products,
    as well as a useful taxonomy of itertools attributes.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-10](#functions_and_attributes_of_the_itertoo) 涵盖了 itertools 中最常用的属性；每个属性都是一个迭代器类型，您可以调用它们来获取相应类型的实例，或者行为类似的工厂函数。有关更多
    itertools 属性，请参阅 [在线文档](https://oreil.ly/d5Eew)，其中包括 *组合* 生成器的排列、组合和笛卡尔积，以及有用的
    itertools 属性分类。'
- en: The online docs also offer recipes describing ways to combine and use itertools
    attributes. The recipes assume you have **from** itertools **import** * at the
    top of your module; this is *not* recommended use, just an assumption to make
    the recipes’ code more compact. It’s best to **import** itertools **as** it, then
    use references such as it.*something* rather than the more verbose itertools.*something*.^([6](ch08.xhtml#ch01fn94))
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在线文档还提供了有关组合和使用 itertools 属性的配方。这些配方假设您在模块顶部有 **from** itertools **import**
    *；这 *不* 是推荐的用法，只是假设以使配方的代码更紧凑。最好 **import** itertools **as** it，然后使用引用如 it.*something*
    而不是更冗长的 itertools.*something*。^([6](ch08.xhtml#ch01fn94))
- en: Table 8-10\. Functions and attributes of the itertools module
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-10\. itertools 模块的函数和属性
- en: '| accumulate | accumulate(*seq*, *func*, /[, initial*=init*]) Similar to functools.reduce(*func*,
    *seq*), but returns an iterator of all the intermediate computed values, not just
    the final value. **3.8+** You can also pass an initial value *init*, which works
    the same way as in functools.reduce (see [Table 8-7](#functions_and_attributes_of_the_functoo)).
    |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| accumulate | accumulate(*seq*, *func*, /[, initial*=init*]) 类似于 functools.reduce(*func*,
    *seq*)，但返回所有中间计算值的迭代器，而不仅仅是最终值。 **3.8+** 您还可以传递一个初始值 *init*，其工作方式与 functools.reduce
    中的相同（请参阅 [表 8-7](#functions_and_attributes_of_the_functoo)）。 |'
- en: '| chain | chain(**iterables*) Yields items from the first argument, then items
    from the second argument, and so on, until the end of the last argument. This
    is just like the generator expression:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '| chain | chain(**iterables*) 生成器，从第一个参数开始生成项目，然后从第二个参数开始生成项目，依此类推，直到最后一个参数结束。这就像生成器表达式一样：'
- en: '[PRE35]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| chain.from_ iterable | chain.from_iterable(*iterables*, /) Yields items from
    the iterables in the argument, in order, just like the genexp:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '| chain.from_ iterable | chain.from_iterable(*iterables*, /) 生成器，按顺序从参数中的可迭代对象中生成项目，就像生成器表达式一样：'
- en: '[PRE36]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| compress | compress(*data*, *conditions*, /) Yields each item from *data*
    corresponding to a true item in *conditions*, just like the genexp:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '| compress | compress(*data*, *conditions*, /) 生成器，生成 *conditions* 中的 true
    项对应的 *data* 中的每个项目，就像生成器表达式一样：'
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| count | count(start=0, step=1) Yields consecutive integers starting from
    *start*, just like the generator:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '| count | count(start=0, step=1) 生成连续整数，从 *start* 开始，就像生成器一样：'
- en: '[PRE38]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: count returns an unending iterator, so use it carefully, always ensuring you
    explicitly terminate any loop over it. |
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: count 返回一个无尽的迭代器，因此请小心使用，始终确保您显式终止对它的任何循环。 |
- en: '| cycle | cycle(*iterable*, /) Yields each item of *iterable*, endlessly repeating
    items from the beginning each time it reaches the end, just like the generator:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '| cycle | cycle(*iterable*, /) 生成器，无限重复 *iterable* 中的每个项目，每次到达末尾时从开头重新开始，就像生成器一样：'
- en: '[PRE39]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: cycle returns an unending iterator, so use it carefully, always ensuring you
    explicitly terminate any loop over it. |
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: cycle 返回一个无尽的迭代器，因此请小心使用，始终确保您显式终止对它的任何循环。 |
- en: '| dropwhile | dropwhile(*func*, *iterable*, /) Drops the 0+ leading items of
    *iterable* for which *func* is true, then yields each remaining item, just like
    the generator:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '| dropwhile | dropwhile(*func*, *iterable*, /) 丢弃*iterable*中*func*为真的前面的0+项，然后产生每个剩余的项，就像生成器一样：'
- en: '[PRE40]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| filterfalse | filterfalse(*func*, *iterable*, /) Yields those items of *iterable*
    for which *func* is false, just like the genexp:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '| filterfalse | filterfalse(*func*, *iterable*, /) 产生*iterable*中*func*为假的项，就像生成器表达式一样：'
- en: '[PRE41]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*func* can be any callable accepting a single argument, or **None**. When *func*
    is **None**, filterfalse yields false items, just like the genexp:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当*func*可以是接受单个参数的任何可调用对象，或**None**时。当*func*为**None**时，filterfalse产生假的项，就像生成器表达式一样：
- en: '[PRE42]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '|'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| groupby | groupby(*iterable*, /, key=**None**) *iterable* normally needs
    to be already sorted according to key (**None**, as usual, standing for the identity
    function, **lambda** x: x). groupby yields pairs (*k*, *g*), each pair representing
    a *group* of adjacent items from *iterable* having the same value *k* for *key*(*item*);
    each *g* is an iterator yielding the items in the group. When the groupby object
    advances, previous iterators *g* become invalid (so, if a group of items needs
    to be processed later, you’d better store somewhere a list “snapshot” of it, list(*g*)).'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '| groupby | groupby(*iterable*, /, key=**None**) *iterable*通常需要根据key（通常为**None**，表示恒等函数，**lambda**
    x: x）已排序。groupby产生对（*k*，*g*）的对，每个对表示*iterable*中具有相同值*key*(*item*)的相邻项组的*group*；每个*g*是一个迭代器，产生组中的项。当groupby对象前进时，先前的迭代器*g*变为无效（因此，如果需要稍后处理一组项，则最好在某处存储一个“快照”列表“它”，list(*g*)）。'
- en: Another way of looking at the groups groupby yields is that each terminates
    as soon as *key*(*item*) changes (which is why you normally call groupby only
    on an *iterable* that’s already sorted by *key*).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种查看groupby生成的组的方法是，每个组在*key*(*item*)更改时终止（这就是为什么通常只在已经按*key*排序的*iterable*上调用groupby）。
- en: 'For example, suppose that, given a set of lowercase words, we want a dict that
    maps each initial to the longest word having that initial (with “ties” broken
    arbitrarily). We could write:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一组小写单词，我们想要一个字典，将每个首字母映射到具有该首字母的最长单词（在“并列情况”下任意地打破）。我们可以写成：
- en: '[PRE43]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| islice | islice(*iterable*[, *start*], *stop*[, *step*], /) Yields items
    of *iterable* (skipping the first *start* ones, by default 0) up to but not including
    *stop*, advancing by steps of *step* (default 1) at a time. All arguments must
    be nonnegative integers (or **None**), and *step* must be > 0. Apart from checks
    and optional arguments, it’s like the generator:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '| islice | islice(*iterable*[, *start*], *stop*[, *step*], /) 返回*iterable*的项目（默认情况下跳过第一个*start*个项目，通常为0），直到但不包括*stop*，以*step*（默认为1）递增。所有参数必须是非负整数（或**None**），*step*必须大于0。除了检查和可选参数外，它类似于生成器：'
- en: '[PRE44]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| pairwise | pairwise(*seq*, /) **3.10+** Yields pairs of items in *seq*, with
    overlap (for example, pairwise(''ABCD'') will yield ''AB'', ''BC'', and ''CD'').
    Equivalent to the iterator returned from zip(*seq*, *seq*[1:]). |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| pairwise | pairwise(*seq*, /) **3.10+** 对*seq*中的项成对出现，允许重叠（例如，pairwise(''ABCD'')将生成''AB''，''BC''和''CD''）。等同于zip(*seq*,
    *seq*[1:])返回的迭代器。 |'
- en: '| repeat | repeat(*item*, /[*,* times]) Repeatedly yields *item*, just like
    the genexp:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '| repeat | repeat(*item*, /[*,* times]) 重复地产生*item*，就像生成器表达式一样：'
- en: '[PRE45]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When times is absent, the iterator is unbounded, yielding a potentially infinite
    number of items, each of which is the object *item*, just like the generator:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当*times*不存在时，迭代器是无界的，产生可能无限的项，每个项都是对象*item*，就像生成器一样：
- en: '[PRE46]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| starmap | starmap(*func*, *iterable*, /) Yields func(**item*) for each *item*
    in *iterable* (each such *item* must be an iterable, normally a tuple), just like
    the generator:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '| starmap | starmap(*func*, *iterable*, /) 对*iterable*中的每个*item*（通常是元组的可迭代对象）产生func(**item*)，就像生成器表达式一样：'
- en: '[PRE47]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| takewhile | takewhile(*func*, *iterable*, /) Yields items from *iterable*
    as long as *func*(*item*) is truthy, then finishes, just like the generator:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '| takewhile | takewhile(*func*, *iterable*, /) 只要*func*(*item*)为真，从*iterable*中产生项，然后完成，就像生成器表达式一样：'
- en: '[PRE48]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| tee | tee(*iterable*, *n*=2, /) Returns a tuple of *n* independent iterators,
    each yielding items that are the same as those of *iterable*. The returned iterators
    are independent from each other, but they are *not* independent from *iterable*;
    avoid altering the object *iterable* in any way, as long as you’re still using
    any of the returned iterators. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| tee | tee(*iterable*, *n*=2, /) 返回*n*个独立迭代器的元组，每个迭代器产生与*iterable*的项目相同的项。返回的迭代器彼此独立，但它们与*iterable*不独立；在仍然使用返回的任何迭代器时，请避免以任何方式更改对象*iterable*。'
- en: '| zip_longest | zip_longest(**iterables*, /, fillvalue=**None**) Yields tuples
    with one corresponding item from each of the *iterables*; stops when the longest
    of the *iterables* is exhausted, behaving as if each of the others was “padded”
    to that same length with references to fillvalue. If **None** is a value that
    might be valid in one or more of the *iterables* (such that it could be confused
    with **None** values used for padding), you can use a Python Ellipsis (...) or
    a sentinel object FILL=object() for fillvalue. |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| zip_longest | zip_longest(**可迭代对象*, /, fillvalue=**None**) 从每个*可迭代对象*中产生一个元组；当最长的*可迭代对象*耗尽时停止，行为就像其他每个对象都使用fillvalue“填充”到相同长度一样。如果**None**是*可迭代对象*中一个有效的值（以至于它可能会与用于填充的**None**值混淆），你可以使用Python省略号（...）或一个哨兵对象FILL=object()作为fillvalue。'
- en: 'We have shown equivalent generators and genexps for many attributes of itertools,
    but it’s important to take into account the sheer speed of itertools. As a trivial
    example, consider repeating some action 10 times:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了许多itertools属性的等效生成器和生成表达式，但重要的是要考虑itertools的速度优势。作为一个微不足道的例子，考虑重复某些操作10次：
- en: '[PRE49]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This turns out to be about 10 to 20% faster, depending on the Python release
    and platform, than the straightforward alternative:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是这种方式比直接的替代方式快大约10到20%，这取决于Python版本和平台：
- en: '[PRE50]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ^([1](ch08.xhtml#ch01fn84-marker)) I.e., according to the [Liskov substitution
    principle](https://oreil.ly/3jMaN), a core notion of object-oriented programming.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.xhtml#ch01fn84-marker)) 即根据[里氏替换原则](https://oreil.ly/3jMaN)，这是面向对象编程的核心概念之一。
- en: ^([2](ch08.xhtml#ch01fn88-marker)) When first introduced, defaultdict(int) was
    commonly used to maintain counts of items. Since Counter is now part of the collections
    module, use Counter instead of defaultdict(int) for the specific task of counting
    items.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.xhtml#ch01fn88-marker)) 首次引入时，defaultdict(int)常用于维护项目计数。由于Counter现在是collections模块的一部分，对于特定的项目计数任务，使用Counter而不是defaultdict(int)。
- en: ^([3](ch08.xhtml#ch01fn89-marker)) For last-in, first-out (LIFO) queues, aka
    “stacks,” a list, with its append and pop methods, is perfectly sufficient.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch08.xhtml#ch01fn89-marker)) 对于后进先出（LIFO）队列，又称为“堆栈”，列表及其附加和弹出方法完全足够。
- en: ^([4](ch08.xhtml#ch01fn92-marker)) Also known as the [*Schwartzian transform*](https://oreil.ly/FHlZB).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch08.xhtml#ch01fn92-marker)) 也称为[*施瓦茨变换*](https://oreil.ly/FHlZB)。
- en: ^([5](ch08.xhtml#ch01fn93-marker)) This step is not *quite* a full “sort,” but
    it looks close enough to call it one, at least if you squint.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch08.xhtml#ch01fn93-marker)) 这一步不完全是“排序”，但看起来足够接近，至少如果你眯起眼睛看的话。
- en: ^([6](ch08.xhtml#ch01fn94-marker)) Some experts recommend **from** itertools
    **import** *, but the authors of this book disagree.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch08.xhtml#ch01fn94-marker)) 一些专家建议**from** itertools **import** *，但本书的作者持不同意见。
