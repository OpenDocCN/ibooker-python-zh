- en: 10 Making some games
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 制作一些游戏
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章内容
- en: Adding randomness to our programs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的程序添加随机性
- en: Designing and programming a code-breaking logic game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和编程一个破译密码的逻辑游戏
- en: Designing and programming a press-your-luck dice game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和编程一个“押运运气”骰子游戏
- en: People learn to program for many reasons. Some people want to automate tedious
    tasks as we did in the previous chapter. Some people want to work with artificial
    intelligence (AI; you’ll get a taste of that in chapter 11). Other people want
    to make interactive websites, Android or iOS apps, or Alexa skills. There’s an
    endless amount of stuff that programmers can make.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 人们学习编程的原因有很多。有些人希望像我们在上一章中所做的那样自动化繁琐的任务。有些人希望从事人工智能（AI）的工作（你将在第11章中体验到）。还有些人希望制作互动网站、安卓或iOS应用程序，或者Alexa技能。程序员可以制作的东西是无穷无尽的。
- en: Another popular reason to learn programming is to create games. For that reason,
    we thought we’d continue our Copilot programming journey with you by designing
    two small computer games. The first is a code-breaking game where you use clues
    to identify the computer’s secret code. The second is a two-player dice game where
    each player needs to balance risk and luck to reach the required number of points
    before the other player does. Instead of using graphics and animation, these games
    use text. We’ve made this decision to help us stay focused on the game logic,
    rather than the way that the game is represented or the way that the player interacts
    with the games. Along the way, we offer some next steps if you’re interested in
    taking your game-making abilities further. And don’t worry, your current skills
    are a great start to that!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个学习编程的热门原因是创造游戏。因此，我们决定通过设计两个小型计算机游戏来继续我们的Copilot编程旅程。第一个是一个破译密码游戏，玩家通过线索来识别计算机的秘密密码。第二个是一个双人骰子游戏，两个玩家需要平衡风险和运气，在另一个玩家之前达到要求的点数。与使用图形和动画不同，这些游戏使用文本。我们做出这个决定，是为了帮助我们专注于游戏逻辑，而不是游戏的呈现方式或玩家与游戏的互动方式。在此过程中，如果你有兴趣进一步提升你的游戏制作能力，我们也提供了一些后续步骤。别担心，你目前的技能已经是一个很好的起点了！
- en: 10.1 Game programs
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 游戏程序
- en: If you think about playing a board game with your family or friends, you can
    break down what happens in two major phases. The first phase is game setup. This
    will include setting up the game board, giving each player starting funds or cards,
    and so on. The second phase is the playing of the game. In a board game, the game
    typically includes a person taking a turn and, assuming no one has won yet, another
    person taking a turn. With each turn, the game state (board, players’ funds, etc.)
    all change. We need to take care to implement each of these phases when programming
    a computer game as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑和家人或朋友一起玩棋盘游戏，你可以将整个过程分为两个主要阶段。第一个阶段是游戏设置。这包括设置游戏棋盘、为每个玩家分发起始资金或卡牌等。第二个阶段是游戏进行。在棋盘游戏中，通常是一个人轮流行动，如果没有人获胜，另一人再轮流行动。每一轮，游戏状态（棋盘、玩家资金等）都会发生变化。在编写计算机游戏时，我们也需要小心地实现这些阶段。
- en: In many programming environments catered to video game design, the two phases
    are often separate standard functions. There’s a setup function for what is done
    to set up the game and an update function to change the state of the game either
    because a player has taken an action or because time has passed. Figure 10.1 shows
    the basic flow for video games.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多专门为视频游戏设计的编程环境中，通常有两个分开处理的标准功能。一个是游戏设置功能，用来设置游戏内容，另一个是更新功能，用来在玩家采取行动或时间流逝时改变游戏状态。图
    10.1 展示了视频游戏的基本流程。
- en: '![figure](../Images/10-1.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/10-1.png)'
- en: Figure 10.1 Basic flow of most video games
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.1 大多数视频游戏的基本流程
- en: 'Let’s focus on the update part of the game for a moment. Suppose a player can
    press a button on their keyboard to move forward in a 2D game. The update function
    will cause the player’s character to move forward and also check to see if the
    player’s movement caused the player to interact with something in the game world.
    Some games also change state based on time, regardless of a player’s actions.
    In those games, the update function would also update the state of the game itself
    (e.g., move the ghosts in a game of Pac-Man). At the end of every time step or
    user action, the game will check for end conditions. End conditions typically
    include the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先集中讨论游戏的更新部分。假设玩家可以按下键盘上的一个按钮，在2D游戏中向前移动。更新函数将使玩家的角色向前移动，并检查玩家的移动是否使其与游戏世界中的某个元素发生交互。一些游戏还会根据时间变化状态，而不管玩家的行为如何。在这些游戏中，更新函数还会更新游戏本身的状态（例如，在吃豆人游戏中移动幽灵）。在每个时间步骤或用户操作的结束时，游戏将检查结束条件。结束条件通常包括以下内容：
- en: A player won the game by achieving an objective.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家通过完成某个目标赢得游戏。
- en: A player lost the game by falling off a cliff, running into a monster, and so
    on.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家因掉入悬崖、撞到怪物等原因失去游戏。
- en: A player chose to quit the game.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家选择退出游戏。
- en: There are many programming environments that cater to game design, and we recommend
    the Python pygame module [1] as a good starting place. If you continue pursuing
    game design beyond that, we recommend checking out Unity [2] for 3D game design.
    In this chapter though, we’ll be working with just standard Python to show you
    how to design a basic game without having to dive into these new environments.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多编程环境专门针对游戏设计，我们推荐Python的pygame模块[1]作为一个很好的起点。如果你在此基础上继续深入游戏设计，建议你查看Unity[2]，这是一个用于3D游戏设计的工具。然而，在本章中，我们将仅使用标准Python来向你展示如何设计一个基本的游戏，而无需深入这些新的环境。
- en: 10.2 Adding randomness
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 添加随机性
- en: Many games, including the two that we’ll build in this chapter, rely on randomness
    to make them fun. In our first game, we’ll need the computer to generate the random
    digits of the number that we’ll be deducing. In the second game, we’ll need to
    roll dice, which just amounts to generating random numbers between one and six.
    Enemy behavior, initial orientation of a puzzle, or amount of damage caused by
    attacks, that is, randomness, is typically involved in all of these and many other
    aspects of game design.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏，包括我们在本章中将要制作的两个游戏，都依赖于随机性来增加乐趣。在第一个游戏中，我们需要计算机生成我们将要推断的数字的随机数字。在第二个游戏中，我们需要掷骰子，这实际上就是生成介于一和六之间的随机数字。敌人的行为、谜题的初始朝向或攻击造成的伤害量，也就是随机性，通常涉及游戏设计中的这些以及其他许多方面。
- en: We’ll therefore need to be able to generate random numbers in our Python programs.
    To learn how to do that, let’s use Copilot Chat, much as we did in the previous
    chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要能够在Python程序中生成随机数字。为了学习如何做这一点，我们将像在上一章中一样使用Copilot Chat。
- en: LPHumanI need to generate random numbers in my **Python program. How can I do
    this?**
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我需要在我的**Python程序**中生成随机数字。我该怎么做？
- en: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the random module
    in Python to generate random numbers. Here’s an example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot 你可以使用Python中的random模块生成随机数字。以下是一个示例：'
- en: '[PRE0]`*[PRE1]`*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]`*[PRE1]`*'
- en: '*`*import random*`*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import random*`*'
- en: '*`*# Generate a random integer between 1 and 10 (inclusive)*`*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 生成一个介于1和10之间的随机整数（包括1和10）*`*'
- en: '*`*random_number = random.randint(1, 10)*`*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*random_number = random.randint(1, 10)*`*'
- en: '*`*print(random_number)*`*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(random_number)*`*'
- en: '*`*# Generate a random float between 0 and 1*`*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 生成一个介于0和1之间的随机浮动数*`*'
- en: '*`*random_float = random.random()*`*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*random_float = random.random()*`*'
- en: '*`*print(random_float)*`*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(random_float)*`*'
- en: '*[PRE2]*[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE2]*[PRE3]'
- en: This code imports the random module and then uses the `randint` function to
    generate a random integer between 1 and 10 (inclusive), and the `random` function
    to generate a random float between 0 and 1.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码导入了random模块，然后使用`randint`函数生成一个介于1到10之间的随机整数（包括1和10），并使用`random`函数生成一个介于0到1之间的随机浮动数。
- en: Copilot suggests using functions inside of a module called random to generate
    the random numbers. Let’s check whether the random module is built into Python.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot建议使用一个名为random的模块中的函数来生成随机数字。让我们检查一下random模块是否已经内置于Python中。
- en: LPHumanIs this random module built into Python?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman这个random模块是内置于Python中的吗？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, the random module is a
    built-in module in Python, so you don’t need to install any additional modules
    to use it. You can simply import it in your Python code and start using its functions.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 是的，random模块是Python的一个内置模块，因此你无需安装任何额外的模块就能使用它。你只需在Python代码中导入它并开始使用其函数。'
- en: 'We’ll follow Copilot’s suggestion and import this module to test the two functions
    that we just learned. We’ll do this at the Python >>> prompt, which we’ve used
    in previous chapters to explore how Python features work. To get to the Python
    prompt, press Ctrl-Shift-P, type `REPL`, and then select Python: Start REPL.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将按照Copilot的建议导入这个模块，测试我们刚学到的两个函数。我们将在Python >>> 提示符下进行测试，这是我们在前几章中用来探索Python功能的地方。要进入Python提示符，按Ctrl-Shift-P，输入`REPL`，然后选择Python:
    启动REPL。'
- en: 'Based on Copilot’s response to our first question, we know that we can use
    the `randint` function to generate a random integer in a range from the lowest
    allowed number to the highest allowed number. We might use this function to generate
    individual digits that could be assembled into a larger number. Each digit is
    between 0 and 9, so we’ll ask `randint` for some random numbers between 0 and
    9:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Copilot对我们第一个问题的回答，我们知道可以使用`randint`函数生成一个在最低允许数字和最高允许数字之间的随机整数。我们可能会使用这个函数生成可以组合成更大数字的单个数字。每个数字的范围在0到9之间，所以我们将让`randint`生成0到9之间的随机数：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 We happened to get the maximum value.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们恰好得到了最大值。'
- en: '#2 We happened to get the minimum value.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们恰好得到了最小值。'
- en: 'Or, we might want to generate rolls of a die. Each roll is between 1 and 6,
    so we can ask `randint` for some random numbers between 1 and 6:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可能想要生成骰子的掷点。每次掷骰子的结果在1到6之间，所以我们可以让`randint`生成1到6之间的随机数：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The other function that Copilot told us about is called `random`. (Yes, both
    the module and this function are called `random`! So, we’ll need to use `random.random()`
    to call this function.) This one doesn’t generate a random integer; rather, it
    generates a random fractional number between 0 and 1 (not including 1). For example,
    rather than a random number like 5, you’ll get a random number like 0.1926502\.
    These kinds of numbers, with decimals, are referred to as floats (or floating-point
    numbers). Here are a few calls of this function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot告诉我们的另一个函数叫做`random`。（是的，模块和这个函数都叫`random`！所以，我们需要使用`random.random()`来调用这个函数。）这个函数不会生成一个随机整数；而是生成一个在0和1之间的随机小数（不包括1）。例如，你可能得到的不是像5这样的随机数，而是像0.1926502这样的随机数。这类带小数的数字被称为浮动数（或浮点数）。下面是一些调用这个函数的例子：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can imagine this function being useful for games as well. For example, you
    can think of these float values as probabilities that an event occurs, with higher
    numbers corresponding to higher probabilities. You could then use these floats
    to determine whether an event should happen or not. For the games in this chapter,
    though, we won’t need this function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象这个函数对于游戏也会很有用。例如，你可以将这些浮动值视为事件发生的概率，较高的数字对应较高的概率。然后，你可以使用这些浮动值来判断事件是否应该发生。不过，在本章的游戏中，我们不需要这个函数。
- en: '10.3 Example 1: Bulls and Cows'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 示例1：公牛与奶牛
- en: '*Our first game will be based on an old code-breaking game called Bulls and
    Cows. It might remind you of the game Wordle (but don’t worry if you haven’t played
    Wordle before). We’ll be able to play this game against the computer. Randomness
    plays a critical role in this game, as we’ll see.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的第一个游戏将基于一个叫做“公牛与奶牛”的旧破译游戏。它可能让你想起游戏Wordle（但如果你没玩过Wordle也没关系）。我们将能与计算机一起玩这个游戏。随机性在这个游戏中扮演了至关重要的角色，正如我们将看到的那样。*'
- en: '*### 10.3.1 How the game works'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*### 10.3.1 游戏如何运作'
- en: In this game, Player 1 thinks up a secret code, which is a sequence of four
    digits. Player 2 has to figure out what that secret code is. In our version of
    the game, the computer will be Player 1, and the human player will be Player 2.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，玩家1想出一个秘密代码，这个代码是一个由四个数字组成的序列。玩家2必须猜出这个秘密代码是什么。在我们版本的游戏中，计算机将充当玩家1，而人类玩家将充当玩家2。
- en: Here’s how it works. The computer will randomly choose four distinct digits
    (duplicate digits aren’t allowed) as the secret code. For example, it might choose
    the digits 1862\. Then, you’ll guess what you think the computer’s four digits
    are. For example, you might guess 3821.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理是这样的。计算机会随机选择四个不同的数字（不允许重复数字）作为秘密代码。例如，它可能选择数字1862。然后，你猜测你认为计算机选择的四个数字是什么。例如，你可能猜测是3821。
- en: For each guess, you’re told two things. First, you’re told how many digits in
    your guess match the corresponding position in the secret code exactly. We’ll
    refer to digits that are in the correct place in the secret code as “correct.”
    Say that the secret code is 1862, and you guess 3821\. The second digit in both
    your guess and the secret code is 8, so that’s a match. There are no other matches,
    so you would be told for this guess that the number of correct digits is 1.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个猜测，你会被告知两件事情。首先，你会被告知你猜测中有多少个数字与秘密代码中对应位置的数字完全匹配。我们将出现在正确位置的数字称为“正确”。假设秘密代码是1862，你猜测的是3821。你的猜测和秘密代码中的第二个数字都是8，所以这是一个匹配。没有其他匹配，因此你会被告知这个猜测中正确的数字数量是1。
- en: Second, you’re told how many digits in your guess exist at some other position
    in the secret code. We’ll refer to digits that are in the secret code but in a
    different location as “misplaced.” Let’s again use 1862 for the secret code and
    3821 for your guess. The third digit in your guess is 2\. It doesn’t match the
    third digit of the secret code (that’s a 6), but there is a 2 somewhere else in
    the secret code. Similarly, the fourth digit in your guess is a 1\. It doesn’t
    match the fourth digit of the secret code, but there is a 1 somewhere else in
    the secret code. All told, two of your digits (1 and 2) exist in the secret code,
    although they don’t match their expected position. You would be told from this
    guess that the number of misplaced digits is 2\. You can use these clues to narrow
    down what the secret code could be.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你会被告知在你的猜测中有多少个数字出现在秘密代码的其他位置。我们将出现在秘密代码中但位置错误的数字称为“错误位置”。我们再次使用1862作为秘密代码，3821作为你的猜测。你猜测中的第三个数字是2。它与秘密代码中的第三个数字不匹配（那是6），但在秘密代码的其他位置有一个2。同样，你猜测中的第四个数字是1。它与秘密代码中的第四个数字不匹配，但在秘密代码的其他位置也有一个1。总的来说，你的两个数字（1和2）存在于秘密代码中，尽管它们不在预期的位置。通过这个猜测，你会被告知有2个数字在错误位置。你可以利用这些线索逐渐缩小秘密代码的可能性。
- en: Wordle
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Wordle
- en: If you’ve played Wordle before, you might notice some similarities between Wordle
    and our game here. Wordle uses letters, and ours uses digits, but the type of
    feedback you receive for your guesses is similar. In both cases, you’re told about
    letters or digits that are in the right or wrong place. In Wordle, you’re given
    a clue about each of your letters on its own. For example, if the first letter
    of your guess is *h*, you might be told that the *h* is in the word but in the
    wrong place. By contrast, in our game, you’re not given hints about each digit
    individually but instead are given hints about your guess in aggregate. Still,
    we hope you’re struck by these similarities and by the fact that you’re building
    something that resembles a recent, worldwide phenomenon of a game!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩过Wordle，你可能会注意到Wordle和我们的游戏之间的一些相似之处。Wordle使用字母，而我们的游戏使用数字，但你在猜测中得到的反馈类型是相似的。在这两种情况下，你都会被告知字母或数字是否在正确的位置或错误的位置。在Wordle中，你会得到关于每个字母的线索。例如，如果你猜测的第一个字母是*h*，你可能会被告知*h*在单词中，但位置不对。相比之下，在我们的游戏中，你不会被单独告知每个数字的提示，而是通过聚合提示来告知你整个猜测的情况。尽管如此，我们希望你能注意到这些相似之处，以及你正在构建的东西与最近全球流行的游戏现象相似！
- en: We found a free version of Bulls and Cows that you can play at [www.mathsisfun.com/games/bulls-and-cows.html](http://www.mathsisfun.com/games/bulls-and-cows.html).
    We recommend that you play a few rounds of the game before continuing, just so
    the way the game works is crystal clear in your head. (Note that they use the
    terminology *bulls* instead of *correct* and *cows* instead of *misplaced*.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了一款免费的“牛与牛”游戏，你可以在[www.mathsisfun.com/games/bulls-and-cows.html](http://www.mathsisfun.com/games/bulls-and-cows.html)玩。我们建议你在继续之前先玩几轮游戏，这样你可以清楚地理解游戏的规则。（注意，他们使用术语*牛*来表示*正确*，使用*牛*来表示*错误位置*。）
- en: In table 10.1, we’ve provided an example interaction with the game. We’ve included
    a Comments column to convey our thinking and what we learned from each guess.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格10.1中，我们提供了一个与游戏的交互示例。我们包括了“评论”列来传达我们的思考和从每个猜测中学到的内容。
- en: Table 10.1 Example of playing the game
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表格10.1 游戏示例
- en: '| Guess | Misplaced | Correct | Comments |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 猜测 | 错误位置 | 正确 | 评论 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0123  | 1  | 0  | One of 0, 1, 2, 3 is in the answer; none are in the correct
    location.  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 0123  | 1  | 0  | 在答案中，0、1、2、3中的一个数字存在，但都不在正确的位置。 |'
- en: '| 4567  | 3  | 0  | Three of 4, 5, 6, 7 are in the answer; none are in the
    correct location.  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 4567  | 3  | 0  | 在答案中，4、5、6、7中的三个数字存在，但都不在正确的位置。  |'
- en: '| 9045  | 0  | 1  | Because one number from 0123 and three numbers from 4567
    are in the answer, we know 8 and 9 aren’t in the answer. We know at least one
    of the numbers 4 or 5 must be in the answer from prior guesses and that 0 could
    be in the answer. One correct means that either 4 or 5 is in the correct location,
    either 4 or 5 isn’t present in the solution, and 0 isn’t in the solution.  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 9045  | 0  | 1  | 因为答案中包含一个来自0123的数字和三个来自4567的数字，我们知道8和9不在答案中。根据之前的猜测，我们知道至少有一个数字4或5必须在答案中，并且0可能在答案中。一个正确的提示意味着4或5在正确的位置，4或5不在解决方案中，0不在解决方案中。
    |'
- en: '| 9048  | 0  | 0  | We know 8, 9, and 0 aren’t in the answer from prior guesses.
    Zero correct and zero misplaced tells us 4 is also not in the answer, and from
    the previous guess, we now know that 5 is the last digit.  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 9048  | 0  | 0  | 我们知道8、9和0不在答案中，依据之前的猜测。零个正确和零个错位的提示告诉我们4也不在答案中，根据之前的猜测，我们现在知道5是最后一位数字。
    |'
- en: '| 1290  | 1  | 0  | Going back to the original guess, we want to know which
    digit of 1, 2, and 3 is in the answer. We know 9 and 0 aren’t in the answer, so
    one misplaced means either 1 or 2 is in the answer and 3 isn’t in the answer.
    In addition, whichever of the numbers 1 and 2 are in the answer, it’s currently
    in the wrong spot.  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 1290  | 1  | 0  | 回到最初的猜测，我们想知道1、2和3中的哪一位数字在答案中。我们知道9和0不在答案中，所以一个错位的提示意味着1或2在答案中，3不在答案中。此外，无论1或2哪个在答案中，它目前的位置是错误的。
    |'
- en: '| 6715  | 2  | 1  | Because 4 isn’t in the solution, we know from the second
    guess that 5, 6, and 7 are. Our guess here tells us that 1 isn’t in the answer
    and that 6 and 7 are in the wrong place. Since 1 isn’t in the answer, 2 must be
    (from the previous guess). Because 5 is at the end and we’ve tried 2 in the second
    and third position previously with zero correct, 2 must be in the first position.
    Because we’ve tried 6 in the first and third position and neither were correct,
    6 must be in the second position. That leaves 7 for the third position. We’ve
    got it.  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 6715  | 2  | 1  | 因为4不在解决方案中，我们从第二次猜测中得知5、6和7在答案中。我们的猜测告诉我们1不在答案中，6和7的位置错误。由于1不在答案中，2必须在答案中（根据之前的猜测）。因为5在最后，并且我们曾在第二和第三位置尝试过2，但没有正确的提示，2必须在第一位置。由于我们曾在第一和第三位置尝试过6，并且都不正确，6必须在第二位置。这样就剩下7在第三位置了。我们猜对了。
    |'
- en: '| 2675  | 0  | 4  | Yes, this is correct.  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 2675  | 0  | 4  | 是的，这是正确的。 |'
- en: The challenge of the game is that you have a limited number of guesses in which
    you must successfully guess the computer’s secret code. In our example from table
    10.1, we took seven guesses to guess the code 2675\. For each guess, we were given
    the number of digits misplaced and the number of digits correct to guide our thinking.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的挑战在于你有有限的猜测次数，必须在这些次数内成功猜出计算机的秘密代码。在我们表格10.1中的例子中，我们用七次猜测猜出了代码2675。每次猜测后，我们会根据提示中的错位数字和正确数字数量来指导我们的思考。
- en: In the free version of the game that we just mentioned, you’re not allowed to
    include the same digit multiple times in your guess. For example, the guess 1231
    wouldn’t be allowed because of the two 1s. We’ll maintain this restriction in
    our version of the game as well.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚提到的免费版本游戏中，不允许在猜测中多次使用相同的数字。例如，猜测1231就不被允许，因为有两个1。在我们的游戏版本中，我们也会保持这个限制。
- en: 10.3.2 Top-down design
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 自顶向下设计
- en: Our overall task is to write a program to play the Bulls and Cows game against
    the computer. Let’s do top-down design on this large task, just as we did in chapters
    7 and 9\. What has to happen during this game? Answering that question will help
    us break down the game into smaller tasks. To help us with this, we took the rules
    of the game and our example and thought through what happens at each step of the
    game. Each of those high-level steps appears in figure 10.2, so let’s break them
    down one by one.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的总体任务是编写一个程序来与计算机一起玩《猜数字》游戏。让我们像在第7章和第9章那样，对这个大任务进行自顶向下的设计。游戏过程中必须发生什么呢？回答这个问题将帮助我们将游戏分解成更小的任务。为了帮助我们完成这一任务，我们根据游戏规则和示例思考了游戏每一步发生的事情。每一个高层步骤都出现在图10.2中，所以让我们逐一分析它们。
- en: '![figure](../Images/10-2.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/10-2.png)'
- en: Figure 10.2 Steps in the Bulls and Cows game
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.2 《猜数字》游戏的步骤
- en: We’ll start with the setup. For us to be able to play the game, the computer
    has to randomly generate a secret code. We need to ensure that the secret code
    doesn’t have any duplicate digits. To us, this sounds like something that’s sufficiently
    complicated and self-contained, so it should be its own subtask function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从设置开始。为了让我们能够玩这个游戏，计算机必须随机生成一个秘密代码。我们需要确保秘密代码中没有重复的数字。对我们来说，这听起来像是一个足够复杂且自成一体的任务，因此它应该是一个独立的子任务函数。
- en: After the computer generates its secret code, we can move to the gameplay itself.
    Here’s where the player starts making their guesses. We might think that we could
    just use `input` to ask the player for their guesses and thereby avoid having
    a separate function for this. But we do need to ensure that the player enters
    the correct number of digits and that they don’t include duplicate digits in their
    guess. This is more than we can do with a single call of `input`, so we’ll make
    this its own function as well.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机生成秘密代码后，我们可以进入实际的游戏玩法。这时玩家开始进行猜测。我们可能认为可以仅使用`input`来询问玩家的猜测，从而避免使用一个单独的函数来处理这个问题。但我们确实需要确保玩家输入的数字是正确的，并且他们的猜测中没有重复的数字。单单通过一次`input`调用无法做到这些，因此我们也会为此创建一个函数。
- en: 'Once the player makes their valid guess, we need to figure out two things:
    How many digits are correct, and how many digits are misplaced? Should we have
    one function to carry out both of these tasks? Or, maybe we should have two functions,
    one for the correct information and one for the misplaced information? We see
    good arguments on each side. If we put the tasks together into the same function,
    we keep the player feedback centralized in one place, and that may make it easier
    for us to confirm it’s written correctly. On the other hand, having two separate
    functions would make it easier to test each type of feedback (correct or misplaced)
    at the expense of spreading out the logic for the feedback across two functions.
    We somewhat arbitrarily chose to use a single function here, but if you were hoping
    to have two separate functions, we encourage you to try that on your own after
    you finish working through this section.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家做出有效的猜测，我们需要弄清楚两件事：有多少数字是正确的，多少数字是位置错误的？我们应该使用一个函数来完成这两个任务吗？或者，也许我们应该有两个函数，一个用于正确的数字，另一个用于位置错误的数字？我们看到每种做法都有很好的理由。如果我们将这两个任务合并成同一个函数，我们可以将玩家反馈集中在一个地方，这可能会让我们更容易确认代码是正确的。另一方面，使用两个独立的函数会让我们更容易分别测试每种类型的反馈（正确或错误），但这也会导致反馈的逻辑分散到两个函数中。我们有些随意地选择在这里使用一个函数，但如果你希望使用两个独立的函数，我们鼓励你在完成本节内容后自己尝试。
- en: Let’s take stock. We have a function to generate the computer’s secret code.
    We have a function to get the player’s next guess. We have a function to get the
    correct/misplaced clues for the player’s guess. Those are three major subtasks
    that we’re happy to split out of our top-level function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下。我们有一个函数来生成计算机的秘密代码。我们有一个函数来获取玩家的下一个猜测。我们有一个函数来获取玩家猜测的正确/错误线索。这些是我们很高兴从顶层函数中拆分出来的三个主要子任务。
- en: Is there any other subtask to split out? There’s certainly a little more work
    to do in our top-level function. For example, we need to detect if the player’s
    guess matches the secret code and end the game in that case. We feel that we don’t
    need a separate function for that, though. To determine whether the user’s guess
    equals the secret code, we can use Python’s `==` operator, which tells us directly
    whether two values are equal. And to end the game, we can use a `return` statement
    to end the top-level game function and thereby stop the program. Similarly, if
    the player uses all of their guesses without getting the secret code, then we
    need to tell them that they lost the game, but again, we should be able to do
    this with a small amount of Python code. As such, we’ll stop here with our main
    top-level function calling three subtask functions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他子任务可以拆分吗？我们的顶层函数肯定还有一些工作要做。例如，我们需要检测玩家的猜测是否与秘密代码匹配，并在这种情况下结束游戏。不过，我们觉得不需要为此单独写一个函数。要判断用户的猜测是否等于秘密代码，我们可以使用
    Python 的`==`运算符，它可以直接告诉我们两个值是否相等。而结束游戏，我们可以使用`return`语句来结束顶层游戏函数，从而停止程序。类似地，如果玩家在用完所有猜测次数后仍未猜中秘密代码，我们需要告诉他们游戏结束，但同样，我们应该能通过少量的
    Python 代码做到这一点。因此，我们将在此结束顶层函数，调用三个子任务函数。
- en: When we worked through our spelling suggestions problem in chapter 7, we needed
    to break one of our subtasks into sub-subtasks. But here, each of our three subtasks
    will be manageable as a single function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第七章解决拼写建议问题时，我们需要将一个子任务拆分为子子任务。但是在这里，我们的三个子任务将作为单个函数来处理。
- en: 'For example, let’s think again about our first subtask: generating the computer’s
    secret code, with no duplicate digits allowed. Could we split any sub-subtasks
    out of here? Maybe we could have a function to check whether there are any duplicate
    digits in a proposed secret code. Then, we could keep generating secret codes,
    calling our sub-subtask function until it tells us that there are no duplicates.
    That would work, but we could also just generate the secret code digit by digit
    and not allow a duplicate to be added to the code in the first place. This latter
    plan seems to not need any sub-subtask to be split.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们再次考虑第一个子任务：生成计算机的秘密代码，且不允许重复数字。我们能从中拆分出任何子子任务吗？也许我们可以有一个函数来检查提议的秘密代码中是否有重复的数字。然后，我们可以继续生成秘密代码，调用我们的子子任务函数，直到它告诉我们没有重复数字为止。这样是可行的，但我们也可以逐位生成秘密代码，并且在一开始就不允许重复数字被加入到代码中。这个后者的方案似乎不需要拆分任何子子任务。
- en: 'Now let’s think about our second subtask: getting the player’s next guess.
    We could split out a sub-subtask to tell us whether a guess is valid (i.e., it
    has the correct length and has no duplicates). While we could surely do that,
    it’s not much of a stretch to do this with a couple of checks in the subtask function
    itself. (Did your mind just go back to our example in chapter 7 about valid passwords
    and detecting valid passwords, where we split the check for validity into its
    own function? If so, the difference is that checking whether a password is valid
    is likely a more substantial task than the validity checks we need here.) It would
    certainly be okay to break this into another sub-subtask, but we’ll move forward
    without doing so. We’ve already argued that our third subtask is fine as is, so
    we’ll stop our top-down design here.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑第二个子任务：获取玩家的下一个猜测。我们可以拆分出一个子子任务，告诉我们一个猜测是否有效（即，它具有正确的长度并且没有重复）。虽然我们当然可以这么做，但通过在子任务函数内部进行几个检查就能轻松完成这件事。（你是不是又回想起第七章关于有效密码和检测有效密码的例子，其中我们将有效性检查拆分成了一个独立的函数？如果是的话，区别在于检查密码是否有效很可能比我们这里需要的有效性检查要复杂得多。）将其拆分为另一个子子任务当然是可以的，但我们将不这样做。我们已经认为我们的第三个子任务按原样处理就很好，因此我们将在这里停止我们的自顶向下设计。
- en: We’ll name our top-level function `play`. In it, we’ll call three functions
    corresponding to the three subtasks that we just identified. We’ll call the function
    for our first subtask (generating the computer’s secret code) `random_string`,
    the function for our second subtask (getting the player’s next guess) `get_guess`,
    and the function for our third subtask (providing feedback to the player) `guess_result`.
    See figure 10.3 for this top-down design depicted as a tree.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把顶级函数命名为`play`。在其中，我们将调用对应于我们刚刚确定的三个子任务的三个函数。我们将第一个子任务（生成计算机的秘密代码）对应的函数命名为`random_string`，第二个子任务（获取玩家的下一个猜测）对应的函数命名为`get_guess`，第三个子任务（向玩家提供反馈）对应的函数命名为`guess_result`。有关这个自顶向下设计的树状图，请参见图10.3。
- en: '![figure](../Images/10-3.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/10-3.png)'
- en: Figure 10.3 Top-down design for the Bulls and Cows game. The top-most (left-most)
    function is `play`, which calls `random_string`, `get_guess`, and `guess_result`.
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3 《公牛与母牛》游戏的自顶向下设计。最上面（最左边）的函数是`play`，它调用`random_string`、`get_guess`和`guess_result`。
- en: 10.3.3 Parameters and return types
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 参数和返回类型
- en: '*Normally, we define the types of parameters and return value for each function
    during the top-down design itself, but we wanted to discuss that separately here
    because there are some subtle aspects this time. For example, you may already
    be imagining that we’ll use integers to represent the secret code and guesses;
    but, as we’ll see shortly, this isn’t the best choice. We’ll make some decisions
    about how we’ll represent the data for all the functions before we write each
    one.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*通常，我们会在自顶向下设计中为每个函数定义参数类型和返回值类型，但我们希望在这里单独讨论，因为这次有一些微妙的方面。例如，你可能已经想象到我们会使用整数来表示秘密代码和猜测；但正如我们稍后会看到的，这并不是最好的选择。在我们编写每个函数之前，我们将做出一些决定，关于如何表示所有函数的数据。*'
- en: '*The `play` function is our top-level function and the starting point for our
    game. It would be possible to have this function take no parameters. Somewhere
    in the code of the function, we’d have to hard-code the fact that the secret code
    has four digits and that the player gets, say, 10 guesses. But that wouldn’t be
    very flexible. What if we wanted to play a version of the game where the secret
    code is seven digits and the player gets 100 guesses? We’d have to go into the
    code and make all the necessary changes. So, to make the game easily configurable,
    we can provide some parameters to this function. For example, rather than always
    having the secret code be four digits, we could use a parameter to allow the length
    of the secret code to be set to whatever we want. Similarly, rather than putting
    the maximum number of player guesses directly into the function, we could make
    that a parameter as well so that we can easily change it. Then, all we need to
    do to alter the gameplay is to call this function with different values for these
    parameters, without having to mess around with the code of the function itself.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*`play`函数是我们顶层的函数，也是游戏的起始点。这个函数本来可以不接受任何参数。在函数的代码中，我们必须硬编码密钥是四位数字以及玩家可以获得例如10次猜测的事实。但这并不是很灵活。如果我们想玩一个密钥是七位数、玩家可以猜测100次的游戏版本怎么办？我们就得进入代码并做出所有必要的更改。因此，为了让游戏更容易配置，我们可以为这个函数提供一些参数。例如，尽管密钥的长度通常是四位数，但我们可以使用一个参数来设置密钥的长度，允许它设定为我们想要的任何值。同样地，玩家可以猜测的最大次数也可以不直接写在函数中，而是作为参数，这样我们就可以很方便地更改它。然后，我们所需要做的就是调用这个函数并传入不同的参数值，来改变游戏玩法，而不必修改函数本身的代码。'
- en: Using parameters and variables to avoid magic numbers
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用参数和变量来避免魔法数字
- en: The number of allowed guesses and the number of digits in the secret code are
    good examples that we can use to explain an important principle in code design.
    This principle is that when we write code, if a number can be a parameter or variable,
    it should be. This principle ensures the code is as versatile as possible. When
    programmers see a number being used, rather than a friendly name, they call this
    a “magic number” and that’s what we want to avoid. In our discussion about the
    number of guesses the player gets or the number of digits for the secret code,
    those should be parameters if we abide by this principle. At some point, these
    parameters need to be given concrete numbers for the code to work, but we should
    assign them values at the highest level of the code as possible (e.g., the player
    might set these parameters when the game starts).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 允许猜测次数和密钥位数的数量是我们用来解释代码设计中一个重要原则的好例子。这个原则是，当我们编写代码时，如果一个数字可以是参数或变量，它就应该是。这一原则确保了代码的灵活性。当程序员看到代码中出现数字，而不是友好的名称时，他们称这种数字为“魔法数字”，而我们要避免这种情况。在我们讨论玩家可猜测次数或密钥位数时，如果遵循这一原则，这些数字应该作为参数。在某个时刻，这些参数需要被赋予具体的数值以使代码正常工作，但我们应该尽可能在代码的最高层次为它们赋值（例如，玩家可能在游戏开始时设置这些参数）。
- en: To help adhere to this general principle, whenever you see a raw number (e.g.,
    4) in the code, ask yourself if that could be a parameter or variable. More often
    than not, it should be.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助遵守这一通用原则，每当你在代码中看到一个原始数字（例如4），就问问自己，是否可以将它作为参数或变量。大多数情况下，它应该是。
- en: Adding these parameters is another example, as per our discussion in chapter
    3, of making functions general purpose rather than unnecessarily restrictive.
    Our `random_string` function is the function that generates the computer’s secret
    code. Why did we put `string` in this function name? Shouldn’t we be returning
    a random integer, like 1862? What does a string have to do with this?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些参数是另一个例子，正如我们在第三章讨论的那样，将函数设为通用而不是不必要地限制性。我们的`random_string`函数是生成计算机密钥的函数。为什么我们在这个函数名中使用`string`？难道我们不应该返回一个随机整数，例如1862吗？字符串和这个有什么关系呢？
- en: Well, the problem with returning an integer is that the secret code might start
    with 0\. A secret code like 0825 is a perfectly valid four-digit secret code.
    But 0825 as an integer is 825, which doesn’t have enough digits. The string `'0825'`
    is just four characters that happen to each be digits, so there’s no problem with
    starting a string like this with a `'0'`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个整数的问题在于，密钥可能以0开始。像0825这样的密钥是一个完全有效的四位数密钥。但作为整数，0825是825，这就没有足够的位数。字符串`'0825'`仅仅是四个数字字符，因此以`'0'`开头的字符串没有问题。
- en: 'Beyond that, let’s think ahead about what we’ll eventually need to be doing
    with the computer’s secret code. We’ll need to compare it digit by digit with
    the player’s guess to determine which digits match. Using indexing on strings
    will give us easy access to each character of the string, which is exactly what
    we need. It’s more challenging to access each individual digit of an integer:
    integers don’t support indexing!'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，让我们提前思考一下我们最终需要做的事情——计算机的秘密代码。我们需要将其与玩家的猜测逐位比较，以确定哪些数字匹配。使用字符串的索引可以让我们轻松访问字符串中的每个字符，这正是我们所需要的。访问整数的每个单独数字则更加具有挑战性：整数不支持索引！
- en: 'So, our `random_string` function will take the required number of digits of
    the secret code as a parameter and will return a random string of that length,
    where each character in the string is a digit character. When we talk about digits
    in a string, all we’re referring to are the characters of the string. They happen
    to be digit characters, but they’re still characters, just like `''a''` or `''*''`.
    Don’t be confused by the fact that the string might look like a number! Here’s
    an example showing that these strings work the same way every other string works:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的`random_string`函数将接受秘密代码所需的位数作为参数，并返回一个该长度的随机字符串，其中每个字符都是一个数字字符。当我们谈论字符串中的数字时，我们指的只是字符串中的字符。它们恰好是数字字符，但它们仍然是字符，就像`'a'`或`'*'`一样。不要被字符串看起来像一个数字所困扰！这里有一个示例，显示这些字符串与其他字符串的工作方式相同：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 We access characters of the string as we always do.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们像往常一样访问字符串的字符。'
- en: '#2 We can’t add a string and an integer.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们不能将字符串和整数相加。'
- en: '#3 This is string concatenation, not numeric addition.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 这是字符串连接，而不是数字加法。'
- en: What about `get_guess`, the function to get the next guess from the player?
    As with `random_string`, this function will need to know the number of digits
    of a valid guess, so we’ll make that a parameter. It will return a string giving
    the player’s guess.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`get_guess`呢？这是一个从玩家那里获取下一个猜测的函数。与`random_string`一样，这个函数需要知道一个有效猜测的位数，所以我们将其设为一个参数。它将返回一个字符串，表示玩家的猜测。
- en: Finally, let’s talk about `guess_result`, the function that tells us how many
    digits are correct and how many are misplaced. This function will need both the
    player’s guess string and the computer’s secret code string in order to make comparisons
    between them, so we’ll need this function to take those two parameters. We need
    to return two pieces of information—the number of digits that are correct and
    the number of digits that are misplaced—so we’ll return a list of two integers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们谈谈`guess_result`，这个函数告诉我们有多少数字是正确的，有多少数字是错位的。这个函数需要玩家的猜测字符串和计算机的秘密代码字符串，以便进行比较，因此我们需要这个函数接受这两个参数。我们需要返回两条信息——正确的数字数量和错位的数字数量——所以我们将返回一个包含两个整数的列表。
- en: 10.3.4 Implementing our functions
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 实现我们的函数
- en: Having completed our top-down design, we can now work with Copilot to write
    the code for each of our functions. As always, we’re going to write the functions
    in order from bottom to top. This means that we’ll first implement our three subtask
    functions and then ultimately implement our top-level `play` function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了自上而下的设计后，我们现在可以与 Copilot 一起编写每个函数的代码了。像往常一样，我们将按自下而上的顺序编写函数。这意味着我们将首先实现我们的三个子任务函数，然后最终实现我们最高层次的`play`函数。
- en: random_string
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: random_string
- en: As always when working with Copilot to generate code, we provide the `def` line
    and docstring and then Copilot writes the code. In each code listing, we’ll also
    provide some guidance about how the code works.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，当使用 Copilot 来生成代码时，我们提供`def`行和文档字符串，然后 Copilot 编写代码。在每个代码列表中，我们还会提供一些关于代码如何工作的指导。
- en: We want our `random_string` function to take the number of digits in a secret
    code as a parameter and return a random secret code without duplicates. In the
    code for this function, we might expect Copilot to use `random.randint` in a loop
    that continues running as long as we don’t have enough digits. To avoid adding
    duplicate digits, the code would add a random digit to the secret code only if
    that digit isn’t already in there. We found such a solution in our Copilot results,
    and that’s the one we’ve chosen to present in the following listing.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望`random_string`函数接受一个秘密代码的位数作为参数，并返回一个没有重复数字的随机秘密代码。在这个函数的代码中，我们可以预期 Copilot
    使用`random.randint`在一个循环中运行，直到我们得到足够的位数。为了避免添加重复的数字，代码会仅在该数字不在代码中时才将一个随机数字添加到秘密代码中。我们在
    Copilot 的结果中找到了这样的解决方案，并且我们选择在以下列表中展示它。
- en: Listing 10.1 Function `random_string` for generating a secret code
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1 用于生成秘密代码的 `random_string` 函数
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 Don’t forget to import the random module.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 不要忘记导入 random 模块。'
- en: '#2 Starts with the empty string (no digits so far) as the secret code'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 从空字符串（当前没有数字）作为秘密代码开始'
- en: '#3 Loops while we still need digits'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 当我们还需要数字时，继续循环'
- en: '#4 Generates a random integer from 0 to 9'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 生成一个从 0 到 9 的随机整数'
- en: '#5 If this digit isn’t already in the secret code . . .'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 如果这个数字还没有出现在秘密代码中 . . .'
- en: '#6 . . . add this digit to the secret code.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 . . . 将此数字添加到秘密代码中。'
- en: '#7 Returns the secret code'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 返回秘密代码'
- en: We’re not focusing on testing in this chapter, but even if we were, we wouldn’t
    include exact tests in our docstring for this function. That’s because this function
    has a random result. Randomness can make testing functions difficult because it’s
    hard to control the random values you get. What we could do is add a test to our
    docstring that at least checks that the generated secret code contains the correct
    number of characters, that there are no duplicate characters, and that each character
    is a valid digit. You can also test such functions by running them and observing
    that their result is always within the bounds of your random range and that the
    results appear random.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们不专注于测试，但即使专注于测试，我们也不会在该函数的文档字符串中包括具体的测试。这是因为这个函数的结果是随机的。随机性会使得测试函数变得困难，因为很难控制你得到的随机值。我们可以做的是在文档字符串中添加一个测试，至少检查生成的秘密代码包含正确数量的字符，没有重复的字符，并且每个字符都是有效的数字。你也可以通过运行这些函数并观察它们的结果来进行测试，确保它们的结果总是在你的随机范围内，并且结果看起来是随机的。
- en: If you did carry through with testing, you’d find that we have a perfectly fine
    implementation of this function and that there’s no need to do more. If you just
    want the game to work, you can skip to where we start writing the `get_guess`
    function. If you’d like to learn more about Python and function design, we’d like
    to take this opportunity to spend a bit more time looking at different solutions
    to this function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进行了测试，你会发现我们对这个函数的实现完全没有问题，不需要做更多的修改。如果你只是希望游戏能够运行，可以跳到我们开始编写`get_guess`函数的部分。如果你希望更深入了解
    Python 和函数设计，我们愿意借此机会花些时间探讨不同的解决方案。
- en: We encourage you to check out the Copilot suggestions in the window that appears
    when you press Ctrl-Enter to see some of the other possibilities. For example,
    we can start with a list of all the integers from 0 to 9 and then use a function
    called `random.shuffle` to shuffle that list into random order. Then, all we do
    is take the first `length` integers from that shuffled list (where `length` is
    the length of the secret code), and that’s the secret code! We’re guaranteed not
    to get any duplicate digits because the original list that we shuffle doesn’t
    have any duplicate digits. That version of the function might look like the following
    listing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你查看在按下 Ctrl-Enter 时弹出的窗口中的 Copilot 提议，看看其他可能的方案。例如，我们可以从一个包含所有整数从 0 到 9
    的列表开始，然后使用一个名为 `random.shuffle` 的函数将该列表打乱顺序。然后，我们只需要从打乱后的列表中取出前 `length` 个整数（其中
    `length` 是秘密代码的长度），这就是秘密代码！我们可以确保不会得到重复的数字，因为我们打乱的原始列表中没有重复的数字。这个版本的函数可能看起来像以下列出的代码。
- en: Listing 10.2 Alternative solution for the function `random_string`
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.2 `random_string` 函数的替代解决方案
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '#1 Creates the list [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 创建列表 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]'
- en: '#2 Shuffles the list in a random order'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 随机打乱列表的顺序'
- en: '#3 Returns the first “length” digits from the shuffled list'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 从打乱后的列表中返回前 `length` 个数字'
- en: If you want to learn more about what this code is doing, you have the tools
    to do that! Don’t assume that the code is out of your grasp. You can ask Copilot
    to explain the code. You might get an explanation like the following.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解这段代码在做什么，你完全有工具去了解！不要认为这段代码是无法理解的。你可以请 Copilot 解释代码，可能得到如下解释。
- en: LPHumanWhat does my `random_string` function do?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman 我的 `random_string` 函数做了什么？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot The code is a Python function
    called `random_string` that takes an integer `length` as input and returns a string
    of the given length, where each character is a digit from 0 to 9, and with no
    repeated digits.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 这段代码是一个名为 `random_string` 的
    Python 函数，接受一个整数 `length` 作为输入，返回一个给定长度的字符串，其中每个字符都是 0 到 9 之间的数字，并且没有重复的数字。'
- en: The function first creates a list of digits from 0 to 9 using the `range` function
    and the `list` constructor. It then shuffles the list using the `shuffle` function
    from the random module. This ensures that the digits are in a random order.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先使用 `range` 函数和 `list` 构造器创建一个从 0 到 9 的数字列表。然后，使用随机模块中的 `shuffle` 函数对列表进行洗牌。这样可以确保数字顺序是随机的。
- en: Finally, the function uses a list comprehension to convert the first `length`
    digits of the shuffled list to strings and join them together into a single string
    using the `join` method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数使用列表推导式将洗牌后的列表中的前 `length` 位数字转换为字符串，并使用 `join` 方法将它们连接成一个单一的字符串。
- en: Overall, the `random_string` function generates a random string of digits with
    no repeated digits, which can be useful for generating unique identifiers or passwords.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，`random_string` 函数生成一个不重复的随机数字字符串，这对于生成唯一的标识符或密码非常有用。
- en: What’s a *list comprehension*? You don’t need to figure this out on your own,
    you can ask Copilot to explain it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 *列表推导式*？你不需要自己弄明白，你可以让 Copilot 解释给你听。
- en: LPHumanHow does that list comprehension work?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman：那个列表推导式是怎么工作的？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot The list comprehension in the
    `random_string` function is used to convert the first `length` digits of the shuffled
    list to strings and join them together into a single string using the `join` method.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot `random_string` 函数中的列表推导式用于将洗牌后的列表中的前
    `length` 位数字转换为字符串，并使用 `join` 方法将它们连接成一个单一的字符串。'
- en: 'Here’s a breakdown of how the list comprehension works:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是列表推导式如何工作的细节：
- en: '`str(d)` for d in `digits[:length]` is the expression that generates the list
    of strings. It takes each digit in the first `length` elements of the `digits`
    list, converts it to a string using the `str` function, and returns the resulting
    string.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`str(d)` 对于 `digits[:length]` 是生成字符串列表的表达式。它会取 `digits` 列表中前 `length` 个元素，将每个数字使用
    `str` 函数转换为字符串，并返回结果字符串。'
- en: '`digits[:length]` is the iterable that the list comprehension operates on.
    It takes the first `length` elements of the `digits` list, which have been shuffled
    randomly.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`digits[:length]` 是列表推导式操作的可迭代对象。它取 `digits` 列表中前 `length` 个元素，这些元素已经被随机洗牌过。'
- en: The entire list comprehension is enclosed in square brackets, which creates
    a new list from the elements generated by the expression.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个列表推导式被方括号括起来，这样可以从表达式生成的元素中创建一个新列表。
- en: Finally, the `join` method is called on the resulting list of strings to join
    them together into a single string with no separator between them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`join` 方法被调用在生成的字符串列表上，将它们连接成一个没有分隔符的单一字符串。
- en: Some of this text from Copilot may not be completely understandable, but you
    could keep asking it to explain what you’re unsure about until you’re satisfied
    you understand how this is working.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 中的一些文本可能不完全能理解，但你可以继续让它解释你不理解的部分，直到你确信你明白它是如何工作的。
- en: We didn’t need to show this second working solution for this function, but we
    want to take this opportunity to remind you of how far you’ve come. As you’ve
    progressed through the book, you’ve been developing tools and techniques to understand
    and create software as well as the confidence to learn and keep learning more!
    Getting back to the problem at hand, let’s code our next function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本不需要展示这个第二个有效解决方案，但我们想借此机会提醒你你已经取得了多大的进展。随着你在本书中的学习，你不断发展了理解和创建软件的工具和技巧，同时也培养了学习和持续学习的信心！回到当前的问题，让我们编写下一个函数。
- en: get_guess
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: get_guess
- en: Our `get_guess` function takes the number of required digits as a parameter
    and returns a valid guess from the player. Remember that for a guess to be valid,
    it must contain the right number of digits, and it must not have any duplicate
    digits. Here’s what we got from Copilot in the following listing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `get_guess` 函数接受所需数字的个数作为参数，并从玩家那里返回一个有效的猜测。记住，要使猜测有效，它必须包含正确数量的数字，并且不能有重复的数字。以下是我们从
    Copilot 获得的代码。
- en: Listing 10.3 Function `get_guess` for user input
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 10.3 函数 `get_guess` 用于用户输入
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#1 First tries to get a valid guess from the player'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 首先尝试从玩家那里获取有效猜测'
- en: '#2 While length is wrong, or the guess isn’t all digits or has duplicates .
    . .'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 如果长度错误，或者猜测不是全数字或有重复 . . .'
- en: '#3 . . . subsequently tries to get a valid guess from the player'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 . . . 随后尝试从玩家那里获取有效猜测'
- en: '#4 Returns the valid guess'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 返回有效的猜测'
- en: That `while-loop` condition is a complex one! The final part, `len(set(guess))`
    `!=` `length`, is responsible for checking whether the user entered any duplicate
    digits. It’s using a Python set to do that. We did see this trick back in chapter
    7, section 7.7.7, but that was a while ago! So, if you need a refresher, don’t
    hesitate to ask Copilot for an explanation of that line.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`while-loop`条件是个复杂的条件！最后一部分，`len(set(guess))` `!=` `length`，用于检查用户是否输入了重复的数字。它使用了Python集合来完成这个任务。我们在第7章第7.7.7节中曾见过这个技巧，不过那是很久以前的事了！所以，如果你需要复习一下，不妨请教Copilot来解释这一行。
- en: guess_result
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: guess_result
- en: 'Our `guess_result` function takes two strings as parameters: the player’s most
    recent guess and the secret code. It returns a list of two integers: the number
    of correct digits and the number of misplaced digits.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`guess_result`函数接受两个字符串作为参数：玩家最近的猜测和秘密代码。它返回一个包含两个整数的列表：正确数字的数量和位置错误数字的数量。
- en: This is a tricky function to get right, so even though we haven’t been showing
    the tests we’d want to run in prior functions, we’re going to provide some explicit
    tests in the docstring for this function. We’re adding these docstring tests because
    the logic for this function is going to be complex enough that it will be hard
    to determine whether the code is correct by solely reading the code. For our docstring
    tests, we’ll need some good example cases of different secret codes and user guesses
    to ensure the number of correct and misplaced digits returned by the function
    are as expected. Of course, per chapter 6, you’d likely want to add even more
    test cases if you were interested in doing serious testing. Our first test case
    is
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常难以正确实现的函数，因此尽管我们在之前的函数中没有展示我们希望运行的测试，但我们将在这个函数的文档字符串中提供一些明确的测试。我们之所以添加这些文档字符串测试，是因为这个函数的逻辑将足够复杂，仅凭阅读代码很难判断代码是否正确。对于我们的文档字符串测试，我们需要一些不同秘密代码和用户猜测的良好示例案例，以确保函数返回的正确和错误位置的数字数量符合预期。当然，按照第6章所说，如果你有兴趣进行更深入的测试，你可能还想添加更多的测试用例。我们的第一个测试用例是
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The correct return value here is `[1,` `2]` because there’s one digit that’s
    correct (the 8), and two misplaced digits (the 2 and the 1). Our second test case
    is
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里正确的返回值是`[1,` `2]`，因为有一个数字是正确的（8），有两个数字是位置错误的（2和1）。我们的第二个测试用例是
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The correct return value this time is `[0,` `4]` because there are zero correct
    digits, but all four digits of the guess are misplaced. Here’s our complete docstring,
    including test cases, and the code from Copilot.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这次正确的返回值是`[0,` `4]`，因为没有正确的数字，但猜测的四个数字都被放错了位置。以下是我们的完整文档字符串，包括测试用例，以及Copilot的代码。
- en: Listing 10.4 Function `guess_result` to get the result of a guess
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.4 函数`guess_result`用于获取猜测结果
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#1 This variable is for the correct digits.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这个变量用于正确的数字。'
- en: '#2 This variable is for the misplaced digits.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这个变量用于位置错误的数字。'
- en: '#3 Goes through each index of the digit strings'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 遍历每个数字字符串的索引'
- en: '#4 This digit is correct.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 这个数字是正确的。'
- en: '#5 Increases correct count by 1'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 将正确的计数增加1'
- en: '#6 This isn’t a match but is misplaced.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 这不是一个匹配项，但被放错了位置。'
- en: '#7 Increases misplaced count by 1'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 将位置错误的计数增加1'
- en: '#8 Returns both results in a list'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 返回一个包含两个结果的列表'
- en: The use of `elif` is subtle here. If it were written as `if` rather than `elif`,
    then the code would be wrong! Do you see why? If not, try conversing with Copilot
    before continuing to read our explanation here.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`elif`的使用非常微妙。如果它是用`if`而不是`elif`写的，那么代码就错了！你看出来为什么吗？如果没有，试着和Copilot交谈一下，再继续阅读我们这里的解释。
- en: Suppose that the `if` condition `guess[i]` `==` `secret_code[i]` is `True`.
    In that case, we increase `correct` by 1, and we skip the `elif` statements. (Remember,
    the `elif` statements run only if the preceding `if` and any preceding `elif`
    conditions are `False`.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`if`条件`guess[i]` `==` `secret_code[i]`为`True`。在这种情况下，我们将`correct`增加1，并跳过`elif`语句。（记住，`elif`语句只有在前面的`if`和任何前面的`elif`条件为`False`时才会执行。）
- en: Now, imagine we changed the `elif` to an `if`. If the `if` condition `guess[i]`
    `==` `secret_code[i]` is `True`, we’d still increase `correct` by 1\. But then,
    we’d check the `guess[i]` `in` `secret_code` condition, and this one would be
    `True` as well. After all, we just said that `guess[i]` `==` `secret_code[i]`,
    which proves that `guess[i]` is indeed somewhere in `secret_code`. So, we’d erroneously
    do the `misplaced` `+=` `1`, which we certainly don’t want to do (it’s a matched
    digit, not a misplaced one too)!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们将`elif`改为`if`。如果`if`条件`guess[i]` `==` `secret_code[i]`为`True`，我们仍然会将`correct`增加1。但接着，我们会检查`guess[i]`
    `in` `secret_code`条件，而这个条件也会为`True`。毕竟，我们刚才说了`guess[i]` `==` `secret_code[i]`，这证明`guess[i]`确实在`secret_code`中某个位置。所以，我们会错误地将`misplaced`
    `+=` `1`，这显然是我们不希望发生的（它是一个匹配的数字，而不是一个错误位置的数字）！
- en: play
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: play
- en: We’re done with our subtask functions! Now all we need to do is write the `play`
    top-level function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了子任务函数！现在我们只需要编写`play`顶级函数。
- en: 'Our `play` function takes two integers as parameters: the number of digits
    in the secret code and guesses, and the number of guesses that the player has
    to guess the secret code. It doesn’t return anything—it just plays the game! Our
    final prompt and code for this function is given in the following listing.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`play`函数接受两个整数作为参数：秘密代码和猜测的位数，以及玩家用来猜测秘密代码的猜测次数。它不返回任何内容——它只是进行游戏！我们为这个函数提供的最终提示和代码如下所示。
- en: Listing 10.5 Function `play` for playing the game
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.5 函数`play`用于玩游戏
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#1 Generates the computer’s secret code'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 生成计算机的秘密代码'
- en: '#2 Loops once for each possible player guess'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 每个可能的玩家猜测循环一次'
- en: '#3 Gets the next valid guess from the player'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 获取玩家的下一个有效猜测'
- en: '#4 Gets the “correct” and “misplaced” feedback for this guess'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 获取该猜测的“正确”和“错误位置”反馈'
- en: '#5 Tells the player the hints'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 告诉玩家提示'
- en: '#6 Player correctly guesses the secret code!'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 玩家正确猜出了秘密代码！'
- en: '#7 Exits the function; this ends the game.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 退出函数；这结束了游戏。'
- en: '#8 If we get here, then the player ran out of guesses.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 如果我们到这里，说明玩家已经用完了猜测次数。'
- en: 'If we ran our program now, nothing would happen. That’s because we haven’t
    called the `play` function yet! We always need to remember to call our top-level
    function. To call it, we can add this line below the `play` function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行程序，什么也不会发生。那是因为我们还没有调用`play`函数！我们总是需要记得调用我们的顶级函数。为了调用它，我们可以在`play`函数下添加这一行：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `4` means that we’re playing with four-digit codes and guesses, and the
    `10` means that we have 10 guesses to correctly guess the secret code. You can
    change these arguments to tune the game how you like.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`4`表示我们正在玩四位数的代码和猜测，`10`表示我们有10次猜测机会来正确猜出秘密代码。你可以更改这些参数，调整游戏的设置。'
- en: 'Let’s give our game a whirl before we continue. We’ll show our first few guesses
    and then our final guess:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们先试试我们的游戏。我们会展示我们最初的几个猜测，然后是我们的最终猜测：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ve succeeded in designing a computer game, which is a very different kind
    of program than the other programs we’ve written in this book. Our computer game
    interacts with the user, has randomness, involves two players (the human player
    guessing and the computer player providing the correct/misplaced clues), and has
    winning and losing conditions. That’s a lot of new stuff! However, we also hope
    that you see how much we’ve learned and brought forward from prior chapters. We’re
    still doing top-down design, still designing functions, still testing code, still
    reading code, and still conversing with Copilot. You hadn’t written a game prior
    to this chapter, but essentially, you already had the skills to do that. Don’t
    let a seemingly new type of program or app stop you from trying to do it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功设计了一个计算机游戏，这是一种与我们在本书中编写的其他程序非常不同的程序。我们的计算机游戏与用户互动，具有随机性，涉及两位玩家（人类玩家猜测，计算机玩家提供正确/错误位置的线索），并且有胜负条件。这是很多新东西！然而，我们也希望你能看到我们从之前的章节学到了多少并带了多少内容过来。我们依然在做自顶向下的设计，依然在设计函数，依然在测试代码，依然在阅读代码，依然在与Copilot交流。你在这一章节之前没有写过游戏，但从本质上讲，你已经具备了做到这一点的技能。不要让看似新的程序或应用类型阻止你尝试去做它。
- en: 10.3.5 Adding a graphical interface for Bulls and Cows
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.5 为“猜数字”添加图形界面
- en: You might be disappointed that our game doesn’t look much like a game you’ve
    recently played because there are no graphics, just text. For example, there’s
    no nice area to type in, no buttons to click, and no graphical interface at all.
    We’ve already argued why we focus on text games in this chapter, but it doesn’t
    mean that turning this game into a graphical interface version is entirely out
    of your grasp because you could interact with Copilot to see if it can help you
    get started.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您会对我们的游戏看起来不像您最近玩过的游戏感到失望，因为没有图形，只有文本。例如，没有一个漂亮的区域来输入文本，没有按钮可以点击，完全没有图形界面。在本章中，我们已经讨论了为什么专注于文本游戏，但这并不意味着将此游戏转换为图形界面版本完全超出了您的能力范围，因为您可以与Copilot交互，看看它是否可以帮助您入门。
- en: The challenge is that programmers create graphical user interfaces using a style
    of programming called *event-driven programming,* which we haven’t taught you
    yet and is too large to teach in this chapter. You can likely read through event-driven
    programming code and make some sense of it, and that’s what you’d need to do if
    you ask Copilot to write code to produce a graphical interface. That said, if
    Copilot doesn’t give you what you want, it may be difficult to fix without first
    becoming familiar with event-driven programming. There’s a nice book on game programming
    that includes graphical user interfaces and event-driven programming in Python
    called *Invent Your Own Computer Games with Python* [3] if you’d like to learn
    more.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于程序员使用称为*事件驱动编程*的编程样式创建图形用户界面，我们尚未在本章中教授，并且在本章中无法全部教授。您可以阅读事件驱动编程代码并理解其大致含义，这就是如果要求Copilot编写代码生成图形界面时需要做的事情。尽管如此，如果Copilot未能提供您想要的结果，则在熟悉事件驱动编程之前可能很难修复。如果您希望了解更多信息，关于使用Python进行游戏编程和包括图形用户界面和事件驱动编程的优秀书籍是*Invent
    Your Own Computer Games with Python* [3]。
- en: Event-driven programming
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 事件驱动编程
- en: Event-driven programming is commonly used for programs that interact with users.
    At a high level, the program sets up a way for the user to interact with the program
    (e.g., by pressing buttons or entering text) and then just sits and waits for
    the user to do something, sometimes updating the state of the game while waiting
    for the user input. Once the human interacts with the game, the code recognizes
    this interaction as an *event*,and each event has code associated with it that
    should execute when the event occurs. For example, when a user clicks the Quit
    Game button, it triggers the code that needs to be executed when the user wants
    to quit (e.g., saving the state of the game and exiting the program).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动编程通常用于与用户交互的程序。在高层次上，程序建立了一种用户与程序交互的方式（例如，按按钮或输入文本），然后只是等待用户采取行动，有时在等待用户输入时更新游戏状态。一旦用户与游戏交互，代码将此交互识别为*事件*，每个事件都有与之关联的代码，在事件发生时应执行。例如，当用户点击退出游戏按钮时，触发需要执行的代码（例如，保存游戏状态并退出程序）。
- en: 'We were quite impressed by what Copilot gave us when we asked it to create
    the graphical interface for Bulls and Cows, so we’d like to show you how well
    it did. The code is somewhat readable even without knowing event-driven programming.
    For example, you can probably find the title of the game and change it. To do
    this, we asked Copilot Chat the following question:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们要求Copilot为Bulls and Cows创建图形界面时，它给了我们令人印象深刻的结果，因此我们想向您展示它的表现。即使不了解事件驱动编程，代码也相对易读。例如，您可能会找到游戏的标题并更改它。为此，我们向Copilot
    Chat提出了以下问题：
- en: LPHumanCan you convert this program to use a graphical interface instead of
    a text interface?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman您能将此程序转换为使用图形界面而不是文本界面吗？
- en: Copilot responded to us by laying out, step by step, the changes that we’d need
    to make to do so. It then rewrote the code so that the game now used a graphical
    interface with buttons and edit boxes, rather than a text interface. See figure
    10.4 for the new interface. The code to generate this interface is on the website
    for the book in case you’re interested in running it yourself or learning about
    the code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot回应我们，逐步列出了我们需要进行的更改。然后，它重写了代码，使游戏现在使用带有按钮和编辑框的图形界面，而不是文本界面。有关新界面，请参见图10.4。要生成此界面的代码，请访问该书籍的网站，以便自行运行或了解代码。
- en: '![figure](../Images/10-4.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/10-4.png)'
- en: Figure 10.4 The graphical interface for the game as provided by Copilot. Note
    that it shows the secret code, presumably to help with testing (you’d want to
    remove that before playing the game).
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4 由Copilot提供的游戏图形界面。请注意，界面中显示了秘密代码，可能是为了帮助测试（你会在玩游戏之前删除它）。
- en: '10.4 Example 2: Bogart'
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 示例2：Bogart
- en: '*Our second game will be a two-player dice game. In Bulls and Cows, one of
    our players was human and the other was the computer. This time, we’ll write a
    game for two human players. Randomness again will play a key role. Once we’re
    done, you can play against a friend or family member!*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的第二个游戏将是一个双人骰子游戏。在“牛与牛”游戏中，一个玩家是人类，另一个是计算机。这一次，我们将为两个人类玩家编写一个游戏。随机性再次将在游戏中发挥关键作用。一旦我们完成，你可以与朋友或家人一起玩！*'
- en: '*### 10.4.1 How the game works'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*### 10.4.1 游戏规则'
- en: The game that we’ll be writing here is called Bogart and was designed by Crab
    Fragment Labs. This is a dice game for two players. The game also uses a pot of
    chips or coins. We obviously won’t need actual dice or chips, though, as we’re
    implementing this as a computer game.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里编写的游戏叫做Bogart，由Crab Fragment Labs设计。这是一个为两名玩家设计的骰子游戏。游戏还使用了一个筹码或硬币的锅。不过，由于我们将其实现为计算机游戏，因此显然不需要实际的骰子或筹码。
- en: Bogart
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Bogart
- en: 'The Bogart game was designed by James Ernest (© 1999 James Ernest and Cheapass
    Games, used by permission; [https://crabfragmentlabs.com/](https://crabfragmentlabs.com/)).
    You can download the instructions for the original game for free as part of a
    .pdf file of games: [https://crabfragmentlabs.com/shop/p/chief-herman-1](https://crabfragmentlabs.com/shop/p/chief-herman-1).
    If you enjoy the game and can’t stop playing our re-creation, we encourage you
    to support the work that Crab Fragment Labs is doing. We thank them for letting
    us use their game here!'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Bogart游戏由James Ernest设计（© 1999 James Ernest 和 Cheapass Games，已获许可；[https://crabfragmentlabs.com/](https://crabfragmentlabs.com/)）。你可以免费下载原版游戏的说明书，作为游戏.pdf文件的一部分：[https://crabfragmentlabs.com/shop/p/chief-herman-1](https://crabfragmentlabs.com/shop/p/chief-herman-1)。如果你喜欢这个游戏并且停不下来，我们鼓励你支持Crab
    Fragment Labs所做的工作。感谢他们允许我们在这里使用他们的游戏！
- en: When the game starts, the pot of chips is empty (has no chips in it). One of
    the two players is randomly chosen to start the game. From there, each player
    takes turns until the game is over. We’ll first explain what it means for a player
    to take a turn and then give the rules for when the game ends. Figure 10.5 provides
    an overview of the flow of the game as well.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时，锅中的筹码为空（没有任何筹码）。随机选择两名玩家中的一位开始游戏。从那里开始，每个玩家轮流进行，直到游戏结束。我们首先解释玩家进行回合意味着什么，然后给出游戏结束时的规则。图10.5也提供了游戏流程的概述。
- en: At the beginning of a player’s turn, one chip gets added to the pot, and that
    player rolls one die. If that die is a 1, then the player’s turn is over, and
    they don’t collect any chips. If that die isn’t a 1, then the player gets to decide
    whether to continue their turn or not. If they decide not to continue their turn,
    they collect all the chips from the pot (making the pot empty).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家回合开始时，向锅中添加一个筹码，玩家掷一个骰子。如果掷出的骰子是1，那么该玩家的回合结束，并且他们不会收集任何筹码。如果掷出的骰子不是1，那么玩家可以决定是否继续他们的回合。如果他们决定不继续回合，他们将收集锅中的所有筹码（使锅为空）。
- en: '![figure](../Images/10-5.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/10-5.png)'
- en: Figure 10.5 Player turn in Bogart
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.5 Bogart中的玩家回合
- en: If they do decide to continue their turn, then two chips get added to the pot,
    and they roll two dice. If one or both of those dice is a 1, then the player’s
    turn is over. Otherwise, the player again gets to decide whether to continue their
    turn or not.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们决定继续回合，那么向锅中添加两个筹码，并且他们掷两个骰子。如果其中一个或两个骰子是1，那么玩家的回合结束。否则，玩家再次可以决定是否继续他们的回合。
- en: If they continue their turn, then they roll three dice, then four dice, and
    then five dice. (Players can’t choose to skip a number of dice; they must work
    through the number of dice sequentially starting from one die.) If they ever roll
    a 1, then their turn ends, and they don’t collect any chips. If they decide not
    to continue their turn, then they collect all the chips from the pot.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们继续回合，那么他们先掷三个骰子，再掷四个骰子，然后掷五个骰子。（玩家不能跳过某个骰子的数量；他们必须按顺序掷骰，从一个骰子开始。）如果他们掷出了1，那么回合结束，他们不会收集任何筹码。如果他们决定不继续回合，那么他们将收集锅中的所有筹码。
- en: Rolling a 1 in this game is bad news for the current player. When rolling one
    die, the probability of rolling a 1 is low, only 1 in 6 (about 17%). When rolling
    two dice, the probability of rolling at least one 1 is higher, this time about
    31%. It’s higher still when rolling three dice (42%), four dice (52%), or five
    dice (60%). So, the longer you extend your turn, the higher the probability that
    you’ll eventually roll a 1 and get nothing for your turn. Worse, you’ll likely
    leave the pot quite full for the other player to collect if they play more conservatively
    than you. At the same time, the longer you extend your turn, the faster the chips
    in the pot accumulate and the more chips you can collect assuming that you do
    successfully end your turn eventually. The whole trick is to decide when to press
    your luck for more chips and when to take what you’ve got.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，掷出1对当前玩家来说是坏消息。当掷一个骰子时，掷出1的概率较低，只有1/6（约17%）。当掷两个骰子时，掷出至少一个1的概率更高，这次大约是31%。掷三个骰子的概率更高（42%），掷四个骰子的概率更高（52%），掷五个骰子的概率更高（60%）。因此，回合延长得越久，你最终掷出1的概率越大，这样你回合什么也得不到。更糟糕的是，如果另一个玩家比你更保守地玩，他们可能会收集到很多你留在锅里的筹码。与此同时，回合延长得越久，锅里的筹码积累得越快，假设你最终成功结束回合，你可以收集到更多的筹码。整个诀窍在于决定什么时候冒险争取更多筹码，什么时候拿走你已经拥有的筹码。
- en: 'This is how a player’s turn works. Players alternate turns, rolling dice and
    collecting chips, until the game ends. There are two ways that the game can end:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是玩家回合的运作方式。玩家轮流进行回合，掷骰子并收集筹码，直到游戏结束。游戏有两种结束方式：
- en: If a player collects a total of 30 or more chips, then that player wins.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个玩家收集了30个或更多筹码，那么这个玩家就赢了。
- en: 'Say a player on their turn rolls one die, then two dice, then three, then four,
    and then five, never once rolling a 1\. Then, that player instantly wins. It doesn’t
    matter how many chips they’ve collected: if they get to five dice of which none
    are a 1, they win.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设一个玩家在他们的回合里先掷一个骰子，然后是两个骰子，接着是三个、四个、五个骰子，而且他们从来没有掷出1。然后，这个玩家立刻赢了。不管他们收集了多少筹码：如果他们掷了五个骰子，且其中没有一个是1，他们就赢了。
- en: Example game of Bogart
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 博加特示例游戏
- en: Let’s play out a few turns of the game to make sure we’re clear on how it all
    works. The pot starts out empty. Let’s say that Player 1 is the player randomly
    chosen to go first. We add one chip to the pot, and Player 1 rolls one die. Let’s
    say that they roll a 5\. Now Player 1 has to decide whether to end their turn
    and take the one chip from the pot or continue their turn.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们模拟几回合游戏，确保我们清楚地了解一切是如何运作的。锅开始时是空的。假设玩家1是随机选择的第一个玩家。我们往锅里加一个筹码，玩家1掷了一个骰子。假设他们掷出了一个5。现在玩家1必须决定是结束回合拿走锅里的一个筹码，还是继续回合。
- en: Let’s say that they continue their turn. We add two chips to the pot; now the
    pot has three chips. Player 1 rolls two dice. Let’s say they roll a 4 and a 2.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 假设他们继续他们的回合。我们往锅里再加两个筹码；现在锅里有三个筹码。玩家1掷了两个骰子。假设他们掷出了一个4和一个2。
- en: Should they end their turn and take the three chips? Nah, nah. They want more.
    They continue their turn. We add three chips to the pot; now the pot has six chips.
    Player 1 rolls three dice. This time, they roll a 6, a 5, and—oh no!—a 1\. Player
    1’s turn is over. They got no chips, and they left a juicy six chips in the pot
    for Player 2.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 他们应该结束回合并拿走三个筹码吗？不，不行。他们想要更多。他们继续他们的回合。我们往锅里再加三个筹码；现在锅里有六个筹码。玩家1掷了三个骰子。这次他们掷出了一个6，一个5，还有——哦不！——一个1。玩家1的回合结束了。他们没有拿到任何筹码，并且留了六个诱人的筹码在锅里，供玩家2收集。
- en: Now it’s Player 2’s turn. We add one chip to the pot—that’s seven chips now!—and
    Player 2 rolls one die. Let’s say that they roll a 2\. If Player 2 ends their
    turn now, they’ll collect the seven chips from the pot. That feels like a lot,
    so let’s say that Player 2 does decide to end their turn.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到玩家2了。我们往锅里加一个筹码——现在锅里有七个筹码！——玩家2掷了一个骰子。假设他们掷出了一个2。如果玩家2现在结束回合，他们将收集到锅里的七个筹码。这看起来好多啊，所以假设玩家2决定结束回合。
- en: 'Now the pot is empty, and it’s back to being Player 1’s turn. Player 1 has
    some catching up to do: they have 0 chips and Player 2 has 7 chips. We’ll stop
    here, but the game will continue until one of the players racks up 30 or more
    chips or they get to roll five dice and manage not to roll a single 1.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在锅里空了，该轮到玩家1了。玩家1有很多追赶的任务：他们有0个筹码，而玩家2有7个筹码。我们暂时停在这里，但游戏会继续，直到有一个玩家收集到30个或更多筹码，或者他们成功地掷了五个骰子且没有掷出任何1。
- en: 10.4.2 Top-down design
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 自顶向下设计
- en: 'As was the case when we implemented our Bulls and Cows game, implementing Bogart
    is a large problem for which we need top-down design. We’ll offer that design
    now, but here we encourage you to try it on your own before continuing. We recommend
    this because we found an effective top-down design to be subtle for this game
    due to the number of interacting elements. For example, a player’s turn can end
    in one of three ways: collect the chips, don’t collect the chips, and instantly
    win. We need to be able to determine which of these situations happened. As another
    example, after each player’s turn, we need to switch to the other player—except,
    unfortunately, not always: if a player wins the game, we want to stop the game
    right there and declare them the winner, not switch to the other player! We’ll
    primarily focus on our successful top-down design here, but we’ll occasionally
    justify why we made our decisions and what went wrong with other decisions.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在实现“牛与牛”游戏时所遇到的那样，实现“博加特”是一个大问题，我们需要自上而下的设计。我们现在提供这个设计，但在继续之前，我们鼓励你自己尝试一下。我们推荐这样做，因为我们发现，对于这个游戏来说，有效的自上而下设计是微妙的，原因在于许多元素之间的相互作用。例如，玩家的回合可以以三种方式结束：收集筹码、不收集筹码以及直接获胜。我们需要能够确定发生了哪种情况。另一个例子是，在每个玩家的回合结束后，我们需要切换到另一个玩家——不过，遗憾的是，并非总是这样：如果玩家获胜，我们希望立即停止游戏并宣布他们为胜者，而不是切换到另一个玩家！我们将主要专注于我们成功的自上而下设计，但偶尔也会说明我们做出某些决策的原因，以及其他决策中的错误。
- en: 'We’ll name our top-level function `play`. Here are the main subtasks that we’ll
    need to solve for our game:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把顶层函数命名为`play`。以下是我们需要为游戏解决的主要子任务：
- en: Initialize the pot, and start Player 1 and Player 2 with zero chips. This is
    part of the game setup phase.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化锅，并让玩家 1 和玩家 2 从零筹码开始。这是游戏设置阶段的一部分。
- en: Randomly choose Player 1 or Player 2 to start the game. This too is part of
    the game setup.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机选择玩家 1 或玩家 2 开始游戏，这也是游戏设置的一部分。
- en: 'Now we enter the gameplay phase. While the game isn’t over, do the following:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在进入游戏阶段。在游戏未结束时，执行以下操作：
- en: Print the number of chips in the pot, number of chips Player 1 has, and number
    of chips Player 2 has.
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印锅中的筹码数量，玩家 1 的筹码数量，以及玩家 2 的筹码数量。
- en: Take a full turn for the current player.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行当前玩家的完整回合。
- en: If the current player won chips, give the chips to the current player, and reset
    the pot to have zero chips.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前玩家赢得了筹码，将筹码给当前玩家，并将锅中的筹码重置为零。
- en: Switch to the other player’s turn.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到另一位玩家的回合。
- en: Print the name of the player (Player 1 or Player 2) who won the game.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出获胜玩家的名字（玩家 1 或玩家 2）。
- en: At this point in the book, we suspect you’ve become familiar enough with the
    code from Copilot to have some nice intuition about which of these tasks will
    require separate functions. Task 1 is just a few variable assignments, so we don’t
    need a separate function for that. Other tasks for which we don’t need a separate
    function are task 2 (just a call to `random.randint`), 3a (just a few `print`
    calls), and 4 (a `print` call). We’ll capture each of the remaining subtasks in
    a function. The following subsections describe each of the remaining subtasks.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们推测你已经足够熟悉来自 Copilot 的代码，能够直观地理解哪些任务需要单独的函数。任务 1 只是一些变量赋值，因此我们不需要为此创建单独的函数。其他不需要单独函数的任务有任务
    2（只是调用了`random.randint`），任务 3a（只是几个`print`调用），和任务 4（一个`print`调用）。我们将把剩余的每个子任务封装在一个函数中。以下子部分描述了剩余子任务的具体内容。
- en: Task 3\. While the game isn’t over
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务 3。游戏未结束时
- en: We’ll have a `while` loop that continues while the game isn’t over, so we’ll
    need a function to tell us whether the game is over! How can the function know
    whether the game is over? It’ll need to know the current number of chips that
    Player 1 has and the current number of chips that Player 2 has. That way, it can
    check whether one of these is at least 30\. But remember that there’s another
    way for the game to end, and that’s when a player rolls five dice, none of which
    is a 1\. Therefore, this function will also need to know the most recent dice
    rolls for the current player.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个`while`循环，它在游戏未结束时持续进行，因此我们需要一个函数来判断游戏是否结束！这个函数如何知道游戏是否结束呢？它需要知道玩家 1 和玩家
    2 当前各自的筹码数量。这样，它就可以检查是否有玩家的筹码至少为 30。不过记住，游戏结束的另一种方式是当玩家掷出五个骰子，其中没有一个是 1。因此，这个函数还需要知道当前玩家最近的骰子投掷结果。
- en: 'We’ll name this function `game_over`. It will take three parameters: Player
    1 chips, Player 2 chips, and list of rolls. It will return `True` if the game
    is over and `False` otherwise. The code for this function will need to check a
    few conditions, but we should be able to do that without splitting it out into
    further subtasks.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个函数命名为`game_over`。它将接受三个参数：玩家1的筹码、玩家2的筹码和骰子掷出的列表。若游戏结束则返回`True`，否则返回`False`。该函数的代码需要检查一些条件，但我们应该能够在不拆分为更多子任务的情况下完成。
- en: Task 3b. Take a full turn for the current player
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务3b：为当前玩家进行完整回合
- en: 'We’ll name this function `take_full_turn`. The function *needs* to know how
    many chips are in the pot right now, so that it can update that as needed. It’ll
    also need to return the updated number of chips in the pot. Beyond that, there’s
    a lot that we need to manage to carry out a full turn, so we’re going to need
    to keep the complexity of this function under control. Here’s what comes to mind
    for what this function may need to do:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个函数命名为`take_full_turn`。该函数*需要*知道目前锅中有多少筹码，以便在需要时进行更新。它还需要返回更新后的锅中筹码数量。除此之外，我们需要管理很多事情才能执行完整的回合，因此我们需要控制这个函数的复杂性。下面是我们认为这个函数可能需要执行的操作：
- en: Allow the player to roll one die, then two dice, then three dice, and so on
    until the player’s turn is over.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许玩家先掷一个骰子，然后是两个骰子，接着是三个骰子，依此类推，直到玩家的回合结束。
- en: Update the current player’s number of chips based on what happened on this turn.
    We could add an additional return value to communicate this updated information
    to whoever called this function.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据本回合发生的情况更新当前玩家的筹码数量。我们可以添加一个额外的返回值，将这个更新的信息传递给调用此函数的对象。
- en: Determine whether the game is over. We could add an additional return value
    where `True` means that the game is over and `False` means that it isn’t.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定游戏是否结束。我们可以添加一个额外的返回值，其中`True`表示游戏已结束，`False`表示游戏尚未结束。
- en: We initially tried to have the function do all three of these things but were
    unable to receive satisfactory code from Copilot. This isn’t too surprising because
    we’re asking the function to do too much. This led us to focus on the core of
    this function, which is point 1.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初尝试让这个函数完成这三项任务，但未能从Copilot那里得到令人满意的代码。这并不令人意外，因为我们要求这个函数做的事情太多了。于是我们将注意力集中在这个函数的核心任务上，即第1点。
- en: But OK, if we focus only on point 1, then how are we going to update the current
    player’s number of chips (point 2), and how will we know whether the game is over
    (point 3)? For point 2, the solution we thought of is to not update the current
    player’s chip count at all in this function, instead returning the total number
    of chips in the pot after this turn.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 但是好吧，如果我们只关注第1点，那么我们将如何更新当前玩家的筹码数量（第2点），以及我们如何知道游戏是否结束（第3点）？对于第2点，我们想到的解决方案是，在这个函数中不更新当前玩家的筹码数量，而是返回回合结束后锅中筹码的总数。
- en: For example, if there were 10 chips in the pot and this player’s turn generated
    6 chips, then we’d return 16\. The player may or may not get to collect these
    16 chips—it depends on how their turn ended—but we won’t deal with that here (this
    is for the calling function to manage now).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果锅中有10个筹码，而这次玩家的回合产生了6个筹码，那么我们将返回16。玩家是否能收集到这16个筹码—这取决于他们的回合结束方式—但我们在这里不讨论这一点（这是由调用函数来处理的）。
- en: For point 3 (knowing whether the game is over), our solution is to have the
    function return the most recent list of rolls as part of its return value. (This
    list of rolls will also be needed by the calling function for point 2.) The function
    that calls this one can then use those rolls to determine whether the game is
    over.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第3点（判断游戏是否结束），我们的解决方案是让函数将最近的骰子掷出列表作为返回值的一部分。（调用此函数的函数还将需要这个掷出列表来处理第2点。）调用此函数的函数可以使用这些掷出结果来判断游戏是否结束。
- en: 'In summary, our function will take the number of chips in the pot as a parameter
    and will return a list of two values: the new number of chips in the pot after
    the player’s turn and the most recent list of rolls.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们的函数将接受锅中筹码的数量作为参数，并返回一个包含两个值的列表：玩家回合结束后锅中筹码的新数量，以及最近一次的骰子掷出列表。
- en: 'To take a full turn, we’ll need to be able to roll dice: first one die, then
    two dice, then three dice, and so on. We’ll split this out into a function named
    `roll_dice`. It will take the number of dice to roll as a parameter and will return
    a list of rolls. For example, if we ask the function to roll three dice, we might
    get back `[6,` `1,` `4]`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行完整的回合，我们需要能够掷骰子：首先是一颗骰子，然后是两颗骰子，接着是三颗骰子，以此类推。我们将这部分拆解成一个名为`roll_dice`的函数。该函数将以骰子的数量作为参数，并返回一个骰子结果列表。例如，如果我们要求该函数掷三颗骰子，返回的可能是`[6,
    1, 4]`。
- en: We’ll also need to be able to determine whether the turn is over based on the
    most recent list of rolls. If the player rolled any 1s or rolled five dice none
    of which is a 1, then the turn is over. We’ll split that out too into a function
    named `turn_over`. It will take the list of rolls as a parameter and will return
    `True` if the turn is over and `False` if not.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要根据最近的骰子结果列表来判断回合是否结束。如果玩家掷出了任何1，或者掷出了五颗骰子且没有一颗是1，那么回合结束。我们将这部分也拆解成一个名为`turn_over`的函数。该函数将以骰子结果列表为参数，如果回合结束，则返回`True`，否则返回`False`。
- en: If the turn isn’t over, then we’ll need to ask the player whether they want
    to continue their turn. We’ll ask for a yes (y) or no (n) response. We can do
    that using a call to the `input` function. If the player wants to keep going,
    we can again call `roll_dice`. We don’t need a separate function for asking for
    user input, so we won’t break this part down any further. If we wanted to validate
    the user’s input (rejecting any response that’s not y or n), that would increase
    the complexity enough so that we’d probably split it out.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回合没有结束，那么我们需要问玩家是否希望继续他们的回合。我们会要求玩家给出是（y）或否（n）的回答。我们可以通过调用`input`函数来实现。如果玩家想继续进行回合，我们可以再次调用`roll_dice`。我们不需要一个单独的函数来获取用户输入，因此不再进一步拆解这一部分。如果我们想要验证用户的输入（拒绝任何不是y或n的回答），这会增加足够的复杂性，可能会导致我们将其拆解出来。
- en: 'In summary, we’ve split out two subtasks for our `take_full_turn` function:
    `roll_ dice` and `turn_over`. These functions don’t need to be broken down any
    further. For `roll_dice`, we can use `random.randint` in a loop to generate the
    rolls that we need. And, `turn_over` will amount to a couple of checks on the
    dice rolls to determine whether they ended the turn for which we won’t need any
    further breaking down.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们为`take_full_turn`函数分解了两个子任务：`roll_dice`和`turn_over`。这些函数不需要进一步拆解。对于`roll_dice`，我们可以在循环中使用`random.randint`来生成我们需要的骰子结果。而`turn_over`将包括对骰子结果的几次检查，以确定是否结束了本轮，无需进一步拆解。
- en: Task 3c. If the current player won chips
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务3c。如果当前玩家赢得了筹码
- en: When a player’s turn ends, we’re furnished with the new number of chips in the
    pot and the final list of rolls that ended the turn. We need to determine whether
    the player gets those chips or not. (If the final list of rolls doesn’t contain
    a 1, then the player collects the chips; otherwise, they don’t, and the chips
    stay in the pot.)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家的回合结束时，我们将得到新筹码数和结束回合的最终骰子结果列表。我们需要判断玩家是否获得了这些筹码。（如果最终的骰子结果列表中没有1，则玩家获得筹码；否则，他们没有获得筹码，筹码留在了奖池中。）
- en: We’ll split out a function to tell us whether the player collects the chips
    or not. We’ll name it `wins_chips`. This function will take the most recent list
    of rolls as a parameter and will return `True` if the player wins the chips and
    `False` otherwise.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将拆解出一个函数来判断玩家是否获得筹码。我们将其命名为`wins_chips`。该函数将以最近的骰子结果列表为参数，如果玩家赢得了筹码，则返回`True`，否则返回`False`。
- en: Task 3d. Switch to the other player’s turn
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务3d. 切换到另一个玩家的回合
- en: 'We’ll name this function `switch_player`. Suppose that the current player has
    just finished their turn. We need to switch to the other player’s turn, but only
    if the game isn’t over yet. Our function will encapsulate this logic. It will
    need to call `game_over` to determine whether the game is over, so we need at
    least three parameters for `switch_player`: player 1’s chips, player 2’s chips,
    and the most recent list of dice rolls. We’ll also need a parameter to indicate
    the current player (1 or 2), so that we can return the number of the new current
    player. So, the function will take those four parameters, and it will return a
    1 or a 2 indicating the player that we’re switching to next.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个函数命名为 `switch_player`。假设当前玩家刚刚完成了他们的回合。我们需要切换到另一个玩家的回合，但前提是游戏还没有结束。我们的函数将封装这一逻辑。它需要调用
    `game_over` 来判断游戏是否结束，因此 `switch_player` 至少需要三个参数：玩家 1 的筹码，玩家 2 的筹码，以及最近一次的骰子掷出结果列表。我们还需要一个参数来指示当前玩家（1
    或 2），这样我们就可以返回下一个切换到的玩家编号。因此，函数将接受这四个参数，并返回 1 或 2，表示我们切换到的下一个玩家。
- en: If the game is over, this function won’t do anything. And if the game isn’t
    over, then we’ll need to change a 1 to a 2 or a 2 to a 1\. We already have the
    `game_over` function, and that’s sufficient for breaking down this function.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏已经结束，这个函数不会做任何事情。如果游戏没有结束，那么我们需要将 1 改为 2 或将 2 改为 1。我们已经有了 `game_over` 函数，这对于拆解这个函数已经足够了。
- en: We’ve finished our top-down design! Check out figure 10.6 for our tree of functions.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了自顶向下的设计！请查看图 10.6，查看我们的函数树。
- en: '![figure](../Images/10-6.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/10-6.png)'
- en: Figure 10.6 Top-down design for the Bogart game
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.6 Bogart 游戏的自顶向下设计
- en: 10.4.3 Implementing our functions
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3 实现我们的函数
- en: Now it’s time to work with Copilot to write the code for each of our functions.
    As always, we’ll start with leaf functions and move our way up (left in the diagram),
    implementing our top-level `play` function only when all other functions have
    been implemented. We can start with any leaf function. We’ll start with the `game_over`
    function because it’s needed both by `play` and by `switch_player`. Then, we’ll
    move on to other functions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候与 Copilot 一起编写每个函数的代码了。和往常一样，我们将从叶子函数开始，逐步实现自顶向下的 `play` 函数，只有当其他所有函数都实现之后，我们才会实现顶层的
    `play` 函数。我们可以从任何一个叶子函数开始。我们将从 `game_over` 函数开始，因为它同时被 `play` 和 `switch_player`
    需要。然后，我们将继续实现其他函数。
- en: game_over
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: game_over
- en: 'This function takes three parameters: the number of chips that Player 1 has,
    the number of chips that Player 2 has, and the most recent list of rolls. It returns
    `True` if the game is over, and `False` if not, as shown in the following listing.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受三个参数：玩家 1 拥有的筹码数量，玩家 2 拥有的筹码数量，以及最近一次的掷骰结果列表。如果游戏结束，它返回 `True`，如果没有结束，则返回
    `False`，如下所示的列表所示。
- en: Listing 10.6 `game_over` function in Bogart
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.6 中的 `game_over` 函数，位于 Bogart 中
- en: '[PRE17]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#1 The three ways that the game is over'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 游戏结束的三种方式'
- en: 'Remember that there are three ways for the game to be over: Player 1 has at
    least 30 chips, Player 2 has at least 30 chips, or a player managed to roll five
    dice on their last turn without rolling a 1.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，游戏有三种方式结束：玩家 1 至少有 30 个筹码，玩家 2 至少有 30 个筹码，或者某个玩家在最后一次回合中成功掷出了五个骰子且没有掷出 1。
- en: Returning a Boolean directly
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 直接返回布尔值
- en: 'You may have expected to see the code this way, with the use of `if-else` and
    actual `return` `True` and `return` `False` lines:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能预期代码应该是这样，使用 `if-else` 和实际的 `return` `True` 和 `return` `False` 语句：
- en: '[PRE18]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This would work, but it’s more common to see programmers use a `return` statement
    directly with the `True`/`False` expression. It works because the result of the
    expression is what is being returned. If the expression is true, `True` gets returned,
    and if the expression is false, `False` gets returned. That’s exactly the same
    thing that the `if-else` version does!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这样也可以，但更常见的是程序员直接使用 `return` 语句与 `True`/`False` 表达式一起使用。它之所以有效，是因为表达式的结果就是返回的内容。如果表达式为真，返回
    `True`，如果表达式为假，返回 `False`。这与 `if-else` 版本做的事情完全一样！
- en: roll_dice
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: roll_dice
- en: This is the function that rolls our dice and adds randomness to our game. It
    takes the number of dice to roll as a parameter, and it returns the list of dice
    rolls. We’ll expect Copilot to make use of `random.randint` here, as shown in
    listing 10.7.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于掷骰子并为游戏添加随机性的函数。它以要掷的骰子数量为参数，并返回骰子掷出的列表。我们可以预期 Copilot 会在这里使用 `random.randint`，如列表
    10.7 所示。
- en: In addition to returning the list of rolls, it’s also helpful if this function
    prints each dice roll. That way, the player can see exactly what they rolled.
    In the docstring, we ask Copilot to print the rolls (in addition to returning
    the list of rolls).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 除了返回投掷结果列表之外，如果这个函数还能够打印每次投掷的结果，那就更好了。这样玩家就能准确地看到他们投掷了什么。在文档字符串中，我们要求 Copilot
    打印投掷结果（除了返回投掷结果列表之外）。
- en: Listing 10.7 `roll_dice` function in Bogart
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例10.7 `roll_dice` 函数在 Bogart 中
- en: '[PRE19]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 List of dice rolls (integers between 1 and 6), starts empty'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 骰子投掷列表（1到6之间的整数），初始为空'
- en: '#2 Loops n times, once per roll'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 循环 n 次，每次投掷一次'
- en: '#3 Uses “randint” to generate a random integer between 1 and 6'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 使用 “randint” 生成一个1到6之间的随机整数'
- en: '#4 Prints roll for players to see'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 打印投掷结果，供玩家查看'
- en: '#5 Adds roll to list of rolls'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 将投掷结果添加到投掷列表中'
- en: '#6 Returns list of rolls'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 返回投掷结果列表'
- en: turn_over
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: turn_over
- en: This function takes the most recent list of rolls and uses that to determine
    whether the current player’s turn is over or not. It returns `True` if the turn
    is over, and `False` if not, as shown in the following listing.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受最近的投掷结果列表，并用它来判断当前玩家的回合是否结束。如果回合结束，返回 `True`，否则返回 `False`，如下所示的示例。
- en: Listing 10.8 `turn_over` function in Bogart
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例10.8 `turn_over` 函数在 Bogart 中
- en: '[PRE20]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#1 The two ways for the turn to be over'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 回合结束的两种方式'
- en: There are two ways for the player’s turn to be over. The first is when there’s
    a 1 in the list of rolls. The second is when the player has rolled five dice.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家回合结束有两种方式。第一种是投掷结果中出现了1。第二种是玩家投掷了五个骰子。
- en: Is `len(rolls)` `==` `5` really enough for the turn to be over? Don’t we have
    to check whether there were any 1s rolled? No, if the player rolls five dice,
    then their turn is over no matter what, regardless of what the dice rolls were.
    If they rolled any 1s, then the turn is over because they rolled a 1 (and they
    won’t collect any chips). If they didn’t roll any 1s, then the turn is still over
    (and they’ll win the game automatically in this case).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`len(rolls)` 是否为 `==` `5` 真的是回合结束的标志吗？我们难道不需要检查是否有投掷到1吗？不，如果玩家投掷了五个骰子，那么他们的回合就结束，无论骰子的结果如何。如果他们投掷了1，那么回合结束（且他们不会收集任何筹码）。如果他们没有投掷到1，那么回合仍然结束（而且在这种情况下他们将自动获胜）。'
- en: take_full_turn
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: take_full_turn
- en: 'We’re ready for `take_full_turn` now, as shown in listing 10.9\. This function
    takes the number of chips currently in the pot as a parameter. It will process
    all the rolls from a full turn for the current player and then returns a list
    of two values: the new number of chips in the pot and the final list of rolls.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `take_full_turn`，如示例10.9所示。这个函数接受当前奖池中的筹码数量作为参数。它将处理当前玩家完整回合中的所有投掷结果，并返回一个包含两个值的列表：奖池中新筹码的数量和最终的投掷结果列表。
- en: Listing 10.9 `take_full_turn` function in Bogart
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例10.9 `take_full_turn` 函数在 Bogart 中
- en: '[PRE21]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '#1 Rolls one dice'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 投掷一个骰子'
- en: '#2 Adds one chip to the pot'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 向奖池中添加一个筹码'
- en: '#3 While the current player’s turn isn’t over . . .'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 当当前玩家的回合没有结束时 . . .'
- en: '#4 . . . asks the player if they want to continue their turn.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 . . . 询问玩家是否要继续他们的回合。'
- en: '#5 If they do want to continue their turn . . .'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 如果玩家确实想继续他们的回合 . . .'
- en: '#6 . . . rolls one more dice than last time.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 . . . 比上次多投掷一个骰子。'
- en: '#7 Adds new chips to the pot'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 向奖池中添加新筹码'
- en: '#8 Gets out of the while loop'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 跳出 while 循环'
- en: '#9 Returns both number of chips in the pot and the final list of rolls'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '#9 返回奖池中的筹码数量和最终的投掷结果列表'
- en: wins_chips
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: wins_chips
- en: This function takes a list of rolls as a parameter. If the rolls are good (i.e.,
    contain no 1s), then the player will collect the chips. If the rolls contain any
    1s, then the player won’t collect the chips. This function returns `True` if the
    player gets to collect the chips, and `False` otherwise, as shown in the following
    listing.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受投掷结果列表作为参数。如果投掷结果有效（即没有1），玩家将收集筹码。如果投掷结果中包含任何1，玩家将无法收集筹码。这个函数返回 `True`
    如果玩家能够收集筹码，否则返回 `False`，如下所示的示例。
- en: Listing 10.10 `wins_chips` function in Bogart
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例10.10 `wins_chips` 函数在 Bogart 中
- en: '[PRE22]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Returns True when there are no 1s, and returns False otherwise'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 当没有1出现时返回 True，否则返回 False'
- en: switch_player
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: switch_player
- en: 'This function takes four parameters: the number of chips that Player 1 has,
    the number of chips that Player 2 has, the most recent list of rolls (rolled by
    the current player), and the number of the current player. If the game isn’t over,
    this function returns the number of the other player. If the game is over, then
    the function returns the current player (because there’s no turn for the other
    player!). See the following listing.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受四个参数：玩家1拥有的筹码数，玩家2拥有的筹码数，最近一轮的掷骰子列表（由当前玩家掷出），以及当前玩家的编号。如果游戏没有结束，这个函数返回另一个玩家的编号。如果游戏结束了，函数则返回当前玩家（因为另一个玩家已经没有回合了！）。请参见以下代码清单。
- en: Listing 10.11 `switch_player` function in Bogart
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 10.11 博加特中的`switch_player`函数
- en: '[PRE23]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 If game isn’t over . . .'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 如果游戏未结束…'
- en: '#2 . . . switches from 1 to 2 or from 2 to 1.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 …从1切换到2，或者从2切换到1。'
- en: '#3 Returns new current player'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 返回新的当前玩家'
- en: play
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: play
- en: We’ve made it all the way up to our `play` function! We’ve decided to write
    this function without any parameters. You might wonder if we could make the code
    more flexible by adding, say, a parameter for the number of chips required to
    win (currently 30). You could certainly do that; we haven’t done that here to
    keep the number of parameters smaller throughout the code. This function doesn’t
    return anything. Instead, it plays the game, as shown in the following listing.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了`play`函数！我们决定不使用任何参数来编写这个函数。你可能会想，如果我们添加一个参数来指定赢得游戏所需的筹码数（目前是30），代码会不会更灵活呢？当然可以这样做；我们在这里没有这样做，以保持代码中参数的数量较小。这个函数不返回任何内容，而是像下面的清单所示那样进行游戏。
- en: Listing 10.12 `play` function in Bogart
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 10.12 博加特中的`play`函数
- en: '[PRE24]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 Starts pot and players with 0 chips'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 初始化底池和玩家，开始时都没有筹码'
- en: '#2 Randomly makes Player 1 or Player 2 start the game'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 随机决定由玩家1或玩家2开始游戏'
- en: '#3 While the game isn’t over . . .'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 当游戏没有结束时…'
- en: '#4 . . . prints the current state of the game.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 …打印当前游戏状态。'
- en: '#5 Lets the current player have their turn'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 让当前玩家进行他们的回合'
- en: '#6 If current player wins chips . . .'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 如果当前玩家赢得筹码…'
- en: '#7 . . . and it’s Player 1 . . .'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 …然后是玩家1的回合…'
- en: '#8 . . . gives Player 1 the chips from the pot; . . .'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 …给玩家1从底池中拿筹码；…'
- en: '#9 . . . otherwise, gives Player 2 the chips from the pot.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '#9 …否则，给玩家2从底池中拿筹码。'
- en: '#10 Resets pot to now have 0 chips'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '#10 重置底池，底池现在有0筹码'
- en: '#11 Switches to the other player’s turn'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '#11 切换到另一个玩家的回合'
- en: '#12 Prints out who wins'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '#12 打印出谁赢了'
- en: We now have all the code that we need for the game. Just add
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有了游戏所需的所有代码。只需要添加
- en: '[PRE25]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: below all of your existing code to call our `play` function, and then you’ll
    be able to play!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在你现有的代码下方调用我们的`play`函数，然后你就能开始游戏了！
- en: Customizing the game
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义游戏
- en: 'We’re happy with what Copilot has given us, and the game is certainly playable.
    But, admittedly, the interaction with the players could be a little more user-friendly.
    For example, here’s how the game might start when we run it and press y a few
    times:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Copilot给出的结果很满意，游戏也确实可以玩。但是，老实说，与玩家的互动可以做得更具用户友好性。例如，以下是当我们运行游戏并按下y几次后，游戏开始时可能会出现的情况：
- en: 'Pot chips: 0'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 底池筹码：0
- en: 'Player 1 chips: 0'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家1的筹码：0
- en: 'Player 2 chips: 0'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家2的筹码：0
- en: Player 2 turn
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家2的回合
- en: '4'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: Continue? (y/n) y
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 继续吗？（y/n） y
- en: '5'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '2'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: Continue? (y/n) y
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 继续吗？（y/n） y
- en: '3'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '1'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '4'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: 'Pot chips: 6'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 底池筹码：6
- en: 'Player 1 chips: 0'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家1的筹码：0
- en: 'Player 2 chips: 0'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家2的筹码：0
- en: Player 1 turn
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家1的回合
- en: '2'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: Continue? (y/n)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 继续吗？（y/n）
- en: There’s no welcome message. Numbers like 4, 5, 2, and so on are just there,
    with no context of what they mean. The game asks us whether we want to “Continue?
    (y/n).” Continue what, though? It isn’t clear.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 没有欢迎信息。像4、5、2这样的数字只是出现在那里，毫无解释它们的含义。游戏问我们是否要“继续吗？（y/n）。”但是，继续什么呢？并不明确。
- en: We can make the interaction with the players more pleasant by spicing up the
    `print` calls in our functions. We can just put what we want in each `print` statement
    ourselves. Why not just use Copilot? It’s likely easier to just do it rather than
    trying to cajole Copilot to print exactly what we want. For example, the following
    listing shows a new version of `play` where we’ve added more `print` calls to
    explain what’s going on and to better format the game output.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过增加更多的`print`调用来使与玩家的互动更加愉快。我们可以直接在每个`print`语句中放入我们想要的内容。为什么不直接使用Copilot呢？实际上，直接做可能比让Copilot准确打印我们想要的内容要简单。例如，以下清单展示了一个新版的`play`函数，我们增加了更多的`print`调用来解释发生了什么并更好地格式化游戏输出。
- en: Listing 10.13 `play` function in Bogart with better formatting
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 10.13 博加特中格式更好的`play`函数
- en: '[PRE26]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#1 Prints welcome message'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 打印欢迎信息'
- en: '#2 Prints a blank line'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 打印空行'
- en: '#3 Prints message saying that the current player got chips'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 打印消息，说明当前玩家获得了筹码'
- en: '#4 Separates each turn from the next'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 将每个回合与下一个回合分开'
- en: 'We encourage you to add `print` calls elsewhere as well to make the game interaction
    even better! For example, in `roll_dice`, you could add a `print` call to tell
    the players that dice are about to be rolled (**ROLLS** in the following output).
    In `take_full_ turn`, you could add a `print` call to print the number of chips
    in the pot prior to asking the player whether they’d like to continue their turn.
    Here’s what an interaction with our game looks like after we made those changes:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你在其他地方也添加 `print` 调用，以使游戏互动更加生动！例如，在 `roll_dice` 中，你可以添加一个 `print` 调用，告诉玩家即将掷骰（**掷骰**将在下面的输出中显示）。在
    `take_full_turn` 中，你可以添加一个 `print` 调用，在询问玩家是否要继续回合之前，打印出底池中的筹码数量。以下是我们做出这些修改后，游戏互动的样子：
- en: Welcome to Bogart!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到博加特！
- en: 'Pot chips: 0'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 底池筹码：0
- en: 'Player 1 chips: 0'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家 1 的筹码：0
- en: 'Player 2 chips: 0'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家 2 的筹码：0
- en: Player 2 turn
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家 2 回合
- en: '**ROLLS**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**掷骰**'
- en: '2'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: The pot currently has 1 chips.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 底池当前有 1 个筹码。
- en: Continue turn? (y/n) y
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 继续回合吗？（y/n）y
- en: '**ROLLS**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**掷骰**'
- en: '6'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '3'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: The pot currently has 3 chips.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 底池当前有 3 个筹码。
- en: Continue turn? (y/n) y
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 继续回合吗？（y/n）y
- en: '**ROLLS**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**掷骰**'
- en: '1'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '6'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
- en: 'Pot chips: 6'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 底池筹码：6
- en: 'Player 1 chips: 0'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家 1 的筹码：0
- en: 'Player 2 chips: 0'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家 2 的筹码：0
- en: Player 1 turn
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家 1 回合
- en: '**ROLLS**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**掷骰**'
- en: '5'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: The pot currently has 7 chips.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 底池当前有 7 个筹码。
- en: Continue turn? (y/n)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 继续回合吗？（y/n）
- en: Try making such changes to your code as well. Make the game yours!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对你的代码做类似的修改。让游戏变成你的作品！
- en: 'In this chapter, we used Copilot to help us write two computer games: a logic
    game (similar to Wordle, but with numbers), and a two-player dice game. We were
    able to do this using the skills we’ve honed throughout the book, including problem
    decomposition, writing clear docstrings, and interacting with Copilot Chat.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Copilot 帮助我们编写了两个计算机游戏：一个逻辑游戏（类似于 Wordle，但用数字），以及一个两人掷骰游戏。我们能够做到这一点，利用了我们在整本书中培养的技能，包括问题分解、编写清晰的文档字符串和与
    Copilot Chat 的互动。
- en: 10.5 Exercises
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 练习
- en: 'There is an error in the following `guess_result` function that leads to incorrect
    counts of correct and misplaced digits. Identify and fix the error:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 `guess_result` 函数中存在一个错误，导致正确和错误位置数字的计数不正确。找出并修复该错误：
- en: '[PRE27]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '2\. Modify the `get_guess` function from this chapter to include error messages
    that guide the player to enter a valid guess. Ensure that these messages are clear
    and helpful. Be creative! Here are some examples:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 修改本章中的 `get_guess` 函数，以包含错误消息，指导玩家输入有效的猜测。确保这些消息清晰且有帮助。发挥创意！以下是一些示例：
- en: '“Error: Guess must contain only digits.”'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: “错误：猜测必须仅包含数字。”
- en: '“Error: Guess must not contain repeated digits.”'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: “错误：猜测不得包含重复的数字。”
- en: 3\. Why did we choose to pass the number of digits and the number of guesses
    as parameters to the `play` function for the Bulls and Cows game? How does this
    decision enhance the flexibility of the game?
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 为什么我们选择将数字个数和猜测次数作为参数传递给 `play` 函数来玩“公牛与犊牛”游戏？这个决策如何增强了游戏的灵活性？
- en: 4\. Implement a simple dice game where the player rolls two dice. If the total
    is 7 or 11, the player wins. If the total is 2, 3, or 12, the player loses. For
    any other total, the player continues to roll until they either match their initial
    roll (win) or roll a 7 (lose). Think carefully about how you want to divide the
    main problem here into smaller subproblems!
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 实现一个简单的掷骰游戏，玩家掷两个骰子。如果总和为 7 或 11，玩家获胜。如果总和为 2、3 或 12，玩家失败。对于任何其他总和，玩家继续掷骰，直到他们要么匹配最初的掷骰结果（获胜），要么掷出
    7（失败）。仔细思考一下你如何将这个主要问题分解成更小的子问题！
- en: 5\. Implement a version of the Bogart game where one player is human and the
    other is the computer. To do this, you’ll need to come up with some rules that
    the computer can use to end their turn. For example, the computer will certainly
    want to stop rolling dice when the number of chips that they’ve already accumulated
    on their turn is enough for them to win the game! The computer will also likely
    want to stop rolling once it can earn a large number of chips on its current turn.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. 实现一个博加特游戏版本，其中一名玩家是人类，另一名是计算机。为此，你需要制定一些规则，供计算机在结束其回合时使用。例如，当计算机在回合中已积累的筹码数量足够赢得游戏时，计算机肯定会选择停止掷骰子！此外，当计算机能在当前回合赚取大量筹码时，它也可能会选择停止掷骰子。
- en: '6\. *The Price Is Right* game show is a great source of little games that may
    be fun to implement. For example, you can try implementing the game called Any
    Number:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6. *价格对决*游戏节目是一个很好的小游戏来源，可能会很有趣实现。例如，你可以尝试实现名为“任何数字”的游戏：
- en: '[https://priceisright.fandom.com/wiki/Any_Number](https://priceisright.fandom.com/wiki/Any_Number)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://priceisright.fandom.com/wiki/Any_Number](https://priceisright.fandom.com/wiki/Any_Number)'
- en: In your game, the player should continue to choose numbers until all the digits
    of one of the prizes are revealed; that’s the prize that the player wins.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游戏中，玩家应该继续选择数字，直到揭示出某个奖品的所有数字；这就是玩家赢得的奖品。
- en: '7\. Create a simple game using the Pygame library. In this game, the player
    controls a character that moves left and right to collect falling objects. The
    objective is to collect as many objects as possible without missing them. You
    can be flexible here with how the objects in your game look, so have fun with
    it! As a potential extension: Can you think of how you would keep track of the
    player’s high score?'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7. 使用 Pygame 库创建一个简单的游戏。在这个游戏中，玩家控制一个角色左右移动，收集掉落的物体。目标是尽可能多地收集物体而不漏掉它们。你可以灵活设计游戏中的物体外观，所以尽情发挥吧！作为一个潜在的扩展：你能想到如何记录玩家的最高得分吗？
- en: Summary
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Games have a common program flow that includes game setup and gameplay.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏有一个共同的程序流程，包括游戏设置和游戏玩法。
- en: Randomness is an important ingredient of many games.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机性是许多游戏中的一个重要元素。
- en: We can add randomness to our Python games by using functions in the random module.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用 random 模块中的函数为我们的 Python 游戏添加随机性。
- en: We can implement games with Copilot using the same workflow that we’ve used
    throughout the book, with problem decomposition playing a key role.*****
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用与本书中相同的工作流，通过问题分解发挥关键作用，利用 Copilot 实现游戏。*****
