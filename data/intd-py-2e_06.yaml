- en: Chapter 5\. Text Strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。文本字符串
- en: I always liked strange characters.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我总是喜欢奇怪的字符。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tim Burton
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 蒂姆·伯顿
- en: Computer books often give the impression that programming is all about math.
    Actually, most programmers work with *strings* of text more often than numbers.
    Logical (and creative!) thinking is often more important than math skills.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机书籍通常给人一种编程都是关于数学的印象。实际上，大多数程序员更常用于处理文本的*字符串*，而不是数字。逻辑（和创造性！）思维通常比数学技能更重要。
- en: Strings are our first example of a Python *sequence*. In this case, they’re
    a sequence of *characters*. But what’s a character? It’s the smallest unit in
    a writing system, and includes letters, digits, symbols, punctuation, and even
    white space or directives like linefeeds. A character is defined by its meaning
    (how it’s used), not how it looks. It can have more than one visual representation
    (in different *fonts*), and more than one character can have the same appearance
    (such as the visual `H`, which means the `H` sound in the Latin alphabet but the
    Latin `N` sound in Cyrillic).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是 Python 的第一个*序列*示例。在这种情况下，它们是*字符*的序列。但是什么是字符？它是书写系统中的最小单位，包括字母、数字、符号、标点符号，甚至空格或类似换行符的指令。字符由其含义（如何使用它）来定义，而不是它的外观。它可以有多个视觉表示（在不同*字体*中），而且多个字符可以具有相同的外观（比如在拉丁字母表中表示
    `H` 音的视觉 `H`，但在西里尔字母表中表示拉丁 `N` 音）。
- en: 'This chapter concentrates on how to make and format simple text strings, using
    ASCII (basic character set) examples. Two important text topics are deferred to
    [Chapter 12](ch12.html#ch_munging): *Unicode* characters (like the `H` and `N`
    issue I just mentioned) and *regular expressions* (pattern matching).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章集中讨论如何制作和格式化简单文本字符串，使用 ASCII（基本字符集）示例。两个重要的文本主题推迟到[第 12 章](ch12.html#ch_munging)：*Unicode*
    字符（如我刚提到的 `H` 和 `N` 问题）和*正则表达式*（模式匹配）。
- en: Unlike other languages, strings in Python are *immutable*. You can’t change
    a string in place, but you can copy parts of strings to another string to get
    the same effect. We look at how to do this shortly.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言不同，Python 中的字符串是*不可变的*。你不能直接改变一个字符串，但你可以将字符串的部分复制到另一个字符串以达到相同的效果。我们马上看看如何做到这一点。
- en: Create with Quotes
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用引号创建
- en: 'You make a Python string by enclosing characters in matching single or double
    quotes:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将字符包含在匹配的单引号或双引号中，你可以创建一个 Python 字符串：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The interactive interpreter echoes strings with a single quote, but all are
    treated exactly the same by Python.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式解释器用单引号回显字符串，但 Python 对所有字符串处理都是完全相同的。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Python has a few special types of strings, indicated by a letter before the
    first quote. `f` or `F` starts an *f string*, used for formatting, and described
    near the end of this chapter. `r` or `R` starts a *raw string*, used to prevent
    *escape sequences* in the string (see [“Escape with \”](#escape) and [Chapter 12](ch12.html#ch_munging)
    for its use in string pattern matching). Then, there’s the combination `fr` (or
    `FR`, `Fr`, or `fR`) that starts a raw f-string. A `u` starts a Unicode string,
    which is the same as a plain string. And a `b` starts a value of type `bytes`
    ([Chapter 12](ch12.html#ch_munging)). Unless I mention one of these special types,
    I’m always talking about plain old Python Unicode text strings.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有几种特殊类型的字符串，第一个引号前面的字母指示。`f` 或 `F` 开始一个*f字符串*，用于格式化，在本章末尾描述。`r` 或 `R`
    开始一个*原始字符串*，用于防止字符串中的*转义序列*（参见[“用 \ 进行转义”](#escape) 和 [第 12 章](ch12.html#ch_munging)
    中有关它在字符串模式匹配中的用法）。然后，有组合 `fr`（或 `FR`、`Fr` 或 `fR`）开始一个原始 f-string。`u` 开始一个 Unicode
    字符串，它与普通字符串相同。`b` 开始一个 `bytes` 类型的值（参见[第 12 章](ch12.html#ch_munging)）。除非我提到这些特殊类型之一，我总是在谈论普通的
    Python Unicode 文本字符串。
- en: 'Why have two kinds of quote characters? The main purpose is to create strings
    containing quote characters. You can have single quotes inside double-quoted strings,
    or double quotes inside single-quoted strings:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要有两种引号字符？主要目的是创建包含引号字符的字符串。你可以在双引号字符串中放单引号，或在单引号字符串中放双引号：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can also use three single quotes (`''''''`) or three double quotes (`"""`):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用三个单引号（`'''`）或三个双引号（`"""`）：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Triple quotes aren’t very useful for short strings like these. Their most common
    use is to create *multiline strings*, like this classic poem from Edward Lear:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 三重引号对于这些短字符串并不是很有用。它们最常见的用途是创建*多行字符串*，就像爱德华·利尔的这首经典诗歌：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: (This was entered in the interactive interpreter, which prompted us with `>>>`
    for the first line and continuation prompts `...` until we entered the final triple
    quotes and went to the next line.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: （这是在交互式解释器中输入的，第一行我们用 `>>>` 提示，接着是 `...` 直到我们输入最后的三重引号并进入下一行。）
- en: 'If you tried to create that poem without triple quotes, Python would make a
    fuss when you went to the second line:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在没有三重引号的情况下创建那首诗，当你转到第二行时，Python会抱怨：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you have multiple lines within triple quotes, the line ending characters
    will be preserved in the string. If you have leading or trailing spaces, they’ll
    also be kept:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在三重引号中有多行文本，行尾字符将保留在字符串中。如果有前导或尾随空格，它们也将被保留：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By the way, there’s a difference between the output of `print()` and the automatic
    echoing done by the interactive interpreter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，`print()`的输出与交互式解释器的自动回显是有区别的。
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`print()` strips quotes from strings and prints their contents. It’s meant
    for human output. It helpfully adds a space between each of the things it prints,
    and a newline at the end:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()`会去除字符串的引号并打印它们的内容。它适用于人类输出。它会在打印的每个内容之间添加一个空格，并在末尾添加一个换行符：'
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you don’t want the space or newline, [Chapter 14](ch14.html#ch_files) explains
    how to avoid them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想要空格或换行符，请参阅[第14章](ch14.html#ch_files)中的说明以避免它们。
- en: The interactive interpreter prints the string with individual quotes and *escape
    characters* such as `\n`, which are explained in [“Escape with \”](#escape).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式解释器打印字符串时带有单独的引号和*转义字符*，例如`\n`，这些在[“使用\进行转义”](#escape)中有解释。
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, there is the *empty string*, which has no characters at all but is
    perfectly valid. You can create an empty string with any of the aforementioned
    quotes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有*空字符串*，它完全没有字符但却是完全有效的。你可以用前述任何引号创建空字符串：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create with str()
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`str()`创建字符串。
- en: 'You can make a string from another data type by using the `str()` function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`str()`函数从其他数据类型创建字符串：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Python uses the `str()` function internally when you call `print()` with objects
    that are not strings and when doing *string formatting*, which you’ll see later
    in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`print()`时，Python在对象不是字符串且在*字符串格式化*时内部使用`str()`函数，稍后在本章节中你会看到。
- en: Escape with \
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`\`进行转义
- en: 'Python lets you *escape* the meaning of some characters within strings to achieve
    effects that would otherwise be difficult to express. By preceding a character
    with a backslash (`\`), you give it a special meaning. The most common escape
    sequence is `\n`, which means to begin a new line. With this you can create multiline
    strings from a one-line string:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许你*转义*字符串中某些字符的含义，以实现其他难以表达的效果。通过在字符前加上反斜杠（`\`），你赋予它特殊的含义。最常见的转义序列是`\n`，表示开始新的一行。这样你可以从单行字符串创建多行字符串：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will see the escape sequence `\t` (tab) used to align text:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到`\t`（制表符）的转义序列用于对齐文本：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: (The final string has a terminating tab which, of course, you can’t see.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: （最终字符串具有终止的制表符，当然，你看不到。）
- en: 'You might also need `\''` or `\"` to specify a literal single or double quote
    inside a string that’s quoted by the same character:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要`\'`或`\"`来指定一个由相同字符引用的字符串中的字面单引号或双引号：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And if you need a literal backslash, type two of them (the first escapes the
    second):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个字面上的反斜杠，请输入两个（第一个转义第二个）：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As I mentioned early in this chapter, a *raw string* negates these escapes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头所提到的，*原始字符串*会取消这些转义。
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: (The extra backslash in the first `info` output was added by the interactive
    interpreter.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: （第一个`info`输出中的额外反斜杠是交互式解释器添加的。）
- en: 'A raw string does not undo any real (not `''\n''`) newlines:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串不会取消任何真正的（不是`'\n'`）换行符：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Combine by Using `+`
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过`+`进行组合
- en: 'You can combine literal strings or string variables in Python by using the
    `+` operator:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你可以通过使用`+`运算符来组合字面字符串或字符串变量。
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also combine *literal strings* (not string variables) just by having
    one after the other:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过简单地将一个字符串放在另一个字符串后面来组合*字面字符串*（而不是字符串变量）：
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you have a lot of these, you can avoid escaping the line endings by surrounding
    them with parentheses:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有很多这样的内容，你可以通过将其用括号括起来来避免转义行尾。
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Python does *not* add spaces for you when concatenating strings, so in some
    earlier examples, we needed to include spaces explicitly. Python *does* add a
    space between each argument to a `print()` statement and a newline at the end.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Python在连接字符串时不会为你添加空格，因此在一些早期的示例中，我们需要显式地包含空格。Python在`print()`语句的每个参数之间添加一个空格，并在末尾添加一个换行符。
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Duplicate with *
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`*`进行复制
- en: 'You use the `*` operator to duplicate a string. Try typing these lines into
    your interactive interpreter and see what they print:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`*`运算符来复制一个字符串。尝试在交互式解释器中输入这些行，并查看它们打印出什么：
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that the `*` has higher precedence than `+`, so the string is duplicated
    before the line feed is tacked on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`*` 比 `+` 优先级更高，因此在换行符附加之前字符串被复制。
- en: Get a Character with []
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 [] 获取一个字符
- en: 'To get a single character from a string, specify its *offset* inside square
    brackets after the string’s name. The first (leftmost) offset is 0, the next is
    1, and so on. The last (rightmost) offset can be specified with –1, so you don’t
    have to count; going to the left are –2, –3, and so on:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字符串中获取单个字符，请在字符串名称后的方括号内指定其 *offset*。第一个（最左边的）偏移量是 0，接下来是 1，依此类推。最后一个（最右边的）偏移量可以用
    -1 指定，因此你不必计数；向左是 -2，-3，等等：
- en: '[PRE23]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you specify an offset that is the length of the string or longer (remember,
    offsets go from 0 to length–1), you’ll get an exception:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的偏移量等于或超过字符串的长度（记住，偏移量从 0 到长度减 1），将会引发异常：
- en: '[PRE24]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Indexing works the same with the other sequence types (lists and tuples), which
    I cover in [Chapter 7](ch07.html#ch_lists).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 索引在其他序列类型（列表和元组）中的工作方式相同，我在[第7章](ch07.html#ch_lists)中介绍。
- en: 'Because strings are immutable, you can’t insert a character directly into one
    or change the character at a specific index. Let’s try to change `''Henny''` to
    `''Penny''` and see what happens:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字符串是不可变的，您无法直接插入字符或更改特定索引处的字符。让我们尝试将 `'Henny'` 更改为 `'Penny'` 看看会发生什么：
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Instead you need to use some combination of string functions such as `replace()`
    or a *slice* (which we look at in a moment):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您需要使用 `replace()` 或 *slice* 的某些组合（我们马上会看到的）等字符串函数：
- en: '[PRE26]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We didn’t change the value of `name`. The interactive interpreter just printed
    the result of the replacement.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有更改 `name` 的值。交互式解释器只是打印替换的结果。
- en: Get a Substring with a Slice
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 *slice* 提取一个 *substring*
- en: 'You can extract a *substring* (a part of a string) from a string by using a
    *slice*. You define a slice by using square brackets, a *`start`* offset, an *`end`*
    offset, and an optional *`step`* count between them. You can omit some of these.
    The slice will include characters from offset *`start`* to one before *`end`*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 *slice* 从字符串中提取 *substring*（字符串的一部分）。您可以通过使用方括号、*`start`* 偏移量、*`end`*
    偏移量和它们之间的可选 *`step`* 计数来定义 *slice*。您可以省略其中一些。切片将包括从 *`start`* 偏移量到 *`end`* 偏移量之前的字符：
- en: '`[:]` extracts the entire sequence from start to end.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:]` 提取从开头到结尾的整个序列。'
- en: '`[` *`start`* `:]` specifies from the *`start`* offset to the end.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[` *`start`* `:]` 指定从 *`start`* 偏移量到结尾。'
- en: '`[:` *`end`* `]` specifies from the beginning to the *`end`* offset minus 1.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:` *`end`* `]` 指定从开头到 *`end`* 偏移量减 1。'
- en: '`[` *`start`* `:` *`end`* `]` indicates from the *`start`* offset to the *`end`*
    offset minus 1.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[` *`start`* `:` *`end`* `]` 表示从 *`start`* 偏移量到 *`end`* 偏移量减 1。'
- en: '`[` *`start`* `:` *`end`* `:` *`step`* `]` extracts from the *`start`* offset
    to the *`end`* offset minus 1, skipping characters by *`step`*.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[` *`start`* `:` *`end`* `:` *`step`* `]` 提取从 *`start`* 偏移量到 *`end`* 偏移量减
    1，跳过 *`step`* 个字符。'
- en: As before, offsets go 0, 1, and so on from the start to the right, and –1,–2,
    and so forth from the end to the left. If you don’t specify *`start`*, the slice
    uses 0 (the beginning). If you don’t specify *`end`*, it uses the end of the string.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，偏移量从左到右为 0、1等等，从右到左为 -1、-2等等。如果不指定 *`start`*，则切片使用 0（开头）。如果不指定 *`end`*，则使用字符串的末尾。
- en: 'Let’s make a string of the lowercase English letters:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含小写英文字母的字符串：
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using a plain `:` is the same as `0:` (the entire string):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个普通的 `:` 等同于 `0:`（整个字符串）：
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s an example from offset 20 to the end:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个从偏移量 20 开始到结尾的示例：
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, from offset 10 to the end:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从偏移量 10 到结尾：
- en: '[PRE30]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And another, offset 12 through 14. Python does not include the end offset in
    the slice. The start offset is *inclusive*, and the end offset is *exclusive*:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个，偏移量从 12 到 14。Python 不包括切片中的结束偏移量。开始偏移量是 *包含* 的，结束偏移量是 *不包含* 的：
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The three last characters:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个字符：
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this next example, we go from offset 18 to the fourth before the end; notice
    the difference from the previous example, in which starting at –3 gets the `x`,
    but ending at –3 actually stops at –4, the `w`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们从偏移量 18 到倒数第 4 个提取；请注意与上一个示例的区别，在上一个示例中，从 -3 开始获取 `x`，但在 -3 结束实际上停在
    -4，`w`：
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the following, we extract from 6 before the end to 3 before the end:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们从倒数第 6 个到倒数第 3 个提取：
- en: '[PRE34]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you want a step size other than 1, specify it after a second colon, as shown
    in the next series of examples.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用除 1 外的步长大小，请在第二个冒号后指定它，如下一系列示例所示。
- en: 'From the start to the end, in steps of 7 characters:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从开头到结尾，步长为 7 个字符：
- en: '[PRE35]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'From offset 4 to 19, by 3:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从偏移量 4 到 19，步长为 3：
- en: '[PRE36]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'From offset 19 to the end, by 4:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从偏移量19到末尾，步进为4：
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'From the start to offset 20 by 5:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从开头到偏移量20加5：
- en: '[PRE38]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: (Again, the *end* needs to be one more than the actual offset.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: （同样，*结束*需要比实际偏移量多一位。）
- en: 'And that’s not all! Given a negative step size, this handy Python slicer can
    also step backward. This starts at the end and ends at the start, skipping nothing:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是全部！给定一个负步长，这个方便的Python切片器还可以向后步进。它从末尾开始，直到开头，跳过一切：
- en: '[PRE39]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It turns out that you can get the same result by using this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，你可以通过以下方式获得相同的结果：
- en: '[PRE40]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Slices are more forgiving of bad offsets than are single-index lookups with
    `[]`. A slice offset earlier than the beginning of a string is treated as `0`,
    and one after the end is treated as `-1`, as is demonstrated in this next series
    of examples.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 切片对于错误的偏移量更宽容，不像单索引查找`[]`那样严格。一个早于字符串开始的切片偏移量将被视为`0`，一个超过末尾的将被视为`-1`，正如在下面的示例中展示的那样。
- en: 'From 50 before the end to the end:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从倒数第50位到末尾：
- en: '[PRE41]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'From 51 before the end to 50 before the end:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从倒数第51位到倒数第50位之前：
- en: '[PRE42]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'From the start to 69 after the start:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从开头到开头后的第69位：
- en: '[PRE43]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'From 70 after the start to 70 after the start:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从开头后的第70位到开头后的第70位：
- en: '[PRE44]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Get Length with len()
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用len()获取长度
- en: 'So far, we’ve used special punctuation characters such as `+` to manipulate
    strings. But there are only so many of these. Now let’s begin to use some of Python’s
    built-in *functions*: named pieces of code that perform certain operations.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用特殊的标点字符如`+`来操作字符串。但这些字符并不多。现在让我们开始使用一些Python内置的*函数*：这些是执行特定操作的命名代码片段。
- en: 'The `len()` function counts characters in a string:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`len()`函数用于计算字符串中的字符数：'
- en: '[PRE45]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can use `len()` with other sequence types, too, as you’ll see in [Chapter 7](ch07.html#ch_lists).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像在[第7章](ch07.html#ch_lists)中看到的那样，使用`len()`处理其他序列类型。
- en: Split with split()
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用split()分割
- en: 'Unlike `len()`, some functions are specific to strings. To use a string function,
    type the name of the string, a dot, the name of the function, and any *arguments*
    that the function needs: `*string*.*function*(*arguments*)`. There’s a longer
    discussion of functions in [Chapter 9](ch09.html#ch_functions).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与`len()`不同，有些函数专门用于字符串。要使用字符串函数，输入字符串名称，一个点，函数名称和函数需要的*参数*：`*string*.*function*(*arguments*)`。关于函数的更长讨论请参见[第9章](ch09.html#ch_functions)。
- en: 'You can use the built-in string `split()` function to break a string into a
    *list* of smaller strings based on some *separator*. We look at lists in [Chapter 7](ch07.html#ch_lists).
    A list is a sequence of values, separated by commas and surrounded by square brackets:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用内置的字符串`split()`函数根据某个*分隔符*将字符串分割成一个*列表*。我们将在[第7章](ch07.html#ch_lists)中讨论列表。列表是一系列由逗号分隔并用方括号括起来的值：
- en: '[PRE46]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding example, the string was called `tasks` and the string function
    was called `split()`, with the single separator argument `'',''`. If you don’t
    specify a separator, `split()` uses any sequence of white space characters—newlines,
    spaces, and tabs:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，字符串称为`tasks`，字符串函数称为`split()`，带有单一的分隔符参数`','`。如果不指定分隔符，`split()`将使用任何连续的空白字符——换行符、空格和制表符：
- en: '[PRE47]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You still need the parentheses when calling `split` with no arguments—that’s
    how Python knows you’re calling a function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在不带参数调用`split`时，你仍然需要括号——这是Python知道你在调用函数的方式。
- en: Combine by Using join()
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用join()合并
- en: 'Not too surprisingly, the `join()` function is the opposite of `split()`: it
    collapses a list of strings into a single string. It looks a bit backward because
    you specify the string that glues everything together first, and then the list
    of strings to glue: *`string`* `.join(` *`list`* `)`. So, to join the list `lines`
    with separating newlines, you would say `''\n''.join(lines)`. In the following
    example, let’s join some names in a list with a comma and a space:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 不太意外的是，`join()`函数是`split()`的反向操作：它将字符串列表合并成一个单独的字符串。看起来有点反向，因为你首先指定将所有东西粘合在一起的字符串，然后是要粘合的字符串列表：*`string`*
    `.join(` *`list`* `)`。所以，要使用换行符将列表`lines`连接起来，你会说`'\n'.join(lines)`。在下面的示例中，让我们用逗号和空格将列表中的一些名字连接起来：
- en: '[PRE48]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Substitute by Using replace()
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用replace()替换
- en: 'You use `replace()` for simple substring substitution. Give it the old substring,
    the new one, and how many instances of the old substring to replace. It returns
    the changed string but does not modify the original string. If you omit this final
    count argument, it replaces all instances. In this example, only one string (`''duck''`)
    is matched and replaced in the returned string:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你用`replace()`进行简单的子字符串替换。给它旧的子字符串、新的子字符串，以及要替换的旧子字符串的实例数量。它返回更改后的字符串，但不修改原始字符串。如果省略这个最后的计数参数，它会替换所有实例。在这个例子中，只有一个字符串（`'duck'`）在返回的字符串中被匹配并替换：
- en: '[PRE49]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Change up to 100 of them:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 更改多达100个：
- en: '[PRE50]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When you know the exact substring(s) you want to change, `replace()` is a good
    choice. But watch out. In the second example, if we had substituted for the single
    character string `''a''` rather than the two character string `''a ''` (`a` followed
    by a space), we would have also changed `a` in the middle of other words:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道确切的子字符串要更改时，`replace()` 是一个很好的选择。但要小心。在第二个例子中，如果我们替换为单个字符字符串`'a'`而不是两个字符字符串`'a
    '`（`a`后跟一个空格），我们也会改变其他单词中间的`a`：
- en: '[PRE51]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Sometimes, you want to ensure that the substring is a whole word, or the beginning
    of a word, and so on. In those cases, you need *regular expressions*, which are
    described in numbing detail in [Chapter 12](ch12.html#ch_munging).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你想确保子字符串是一个完整的单词，或者是一个单词的开头等。在这些情况下，你需要*正则表达式*，在[第12章](ch12.html#ch_munging)中详细描述。
- en: Strip with strip()
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用 strip() 去除
- en: 'It’s very common to strip leading or trailing “padding” characters from a string,
    especially spaces. The `strip()` functions shown here assume that you want to
    get rid of whitespace characters (`'' ''`, `''\t''`, `''\n''`) if you don’t give
    them an argument. `strip()` strips both ends, `lstrip()` only from the left, and
    `rstrip()` only from the right. Let’s say the string variable `world` contains
    the string `"earth"` floating in spaces:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符串中去除前导或尾随的“填充”字符，尤其是空格，这是非常常见的。这里显示的`strip()`函数假设你想要去除空白字符（`' '`, `'\t'`,
    `'\n'`），如果你不给它们参数的话。`strip()`会去除两端，`lstrip()`只从左边，`rstrip()`只从右边。假设字符串变量`world`包含字符串`"earth"`浮动在空格中：
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If the character were not there, nothing happens:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符不在那里，什么也不会发生：
- en: '[PRE53]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Besides no argument (meaning whitespace characters) or a single character,
    you can also tell `strip()` to remove any character in a multicharacter string:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了没有参数（意味着空白字符）或单个字符外，你还可以告诉`strip()`去除多字符字符串中的任何字符：
- en: '[PRE54]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[Appendix E](app05.html#app_cheatsheets) shows some definitions of character
    groups that are useful with `strip()`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[附录 E](app05.html#app_cheatsheets)显示了一些对于`strip()`有用的字符组的定义：'
- en: '[PRE55]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Search and Select
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索和选择
- en: 'Python has a large set of string functions. Let’s explore how the most common
    of them work. Our test subject is the following string containing the text of
    the immortal poem “What Is Liquid?” by Margaret Cavendish, Duchess of Newcastle:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一组庞大的字符串函数。让我们探讨它们中最常见的一些如何工作。我们的测试对象是以下字符串，其中包含了玛格丽特·卡文迪许，纽卡斯尔公爵夫人的不朽诗作“液体是什么？”的文字：
- en: '[PRE56]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Inspiring!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓舞人心！
- en: 'To begin, get the first 13 characters (offsets 0 to 12):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，获取前13个字符（偏移量0到12）：
- en: '[PRE57]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How many characters are in this poem? (Spaces and newlines are included in the
    count.)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这首诗有多少个字符？（空格和换行符都包括在计数中。）
- en: '[PRE58]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Does it start with the letters `All`?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它以`All`开头吗？
- en: '[PRE59]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Does it end with `That's all, folks!`?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 它以`That's all, folks!`结尾吗？
- en: '[PRE60]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Python has two methods (`find()` and `index()`) for finding the offset of a
    substring, and has two versions of each (starting from the beginning or the end).
    They work the same if the substring is found. If it isn’t, `find()` returns `-1`,
    and `index()` raises an exception.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两个方法(`find()`和`index()`)用于找到子字符串的偏移量，并且有两个版本（从开始或结尾）。如果找到子字符串，它们的工作方式相同。如果找不到，`find()`返回`-1`，而`index()`引发异常。
- en: 'Let’s find the offset of the first occurrence of the word `the` in the poem:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到诗中单词`the`的第一次出现的偏移量：
- en: '[PRE61]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And the offset of the last `the`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个`the`的偏移量：
- en: '[PRE62]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'But if the substring isn’t in there:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果子字符串不在其中：
- en: '[PRE63]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How many times does the three-letter sequence `the` occur?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 三个字母序列`the`出现了多少次？
- en: '[PRE64]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Are all of the characters in the poem either letters or numbers?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 诗中的所有字符都是字母或数字吗？
- en: '[PRE65]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Nope, there were some punctuation characters.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 不，有一些标点字符。
- en: Case
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例
- en: 'In this section, we look at some more uses of the built-in string functions.
    Our test string is again the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一些内置字符串函数的更多用法。我们的测试字符串再次是以下内容：
- en: '[PRE66]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Remove `.` sequences from both ends:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从两端去除`.`序列：
- en: '[PRE67]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Because strings are immutable, none of these examples actually changes the `setup`
    string. Each example just takes the value of `setup`, does something to it, and
    returns the result as a new string.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串是不可变的，这些示例中没有一个实际上更改了`setup`字符串。每个示例只是取`setup`的值，对其进行处理，并将结果作为新字符串返回。
- en: 'Capitalize the first word:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一个单词大写：
- en: '[PRE68]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Capitalize all the words:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有单词大写：
- en: '[PRE69]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Convert all characters to uppercase:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有字符转换为大写：
- en: '[PRE70]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Convert all characters to lowercase:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有字符转换为小写：
- en: '[PRE71]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Swap uppercase and lowercase:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 交换大写和小写：
- en: '[PRE72]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Alignment
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对齐
- en: Now, let’s work with some layout alignment functions. The string is aligned
    within the specified total number of spaces (`30` here).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用一些布局对齐函数。字符串在指定的总空间内（这里为`30`）居中对齐。
- en: 'Center the string within 30 spaces:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在30个空格内居中对齐字符串：
- en: '[PRE73]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Left justify:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 左对齐：
- en: '[PRE74]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Right justify:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 右对齐：
- en: '[PRE75]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Next, we look at more ways to align a string.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看一下更多如何对齐字符串的方法。
- en: Formatting
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化
- en: You’ve seen that you can *concatenate* strings by using `+`. Let’s look at how
    to *interpolate* data values into strings using various formats. You can use this
    to produce reports, forms, and other outputs where appearances need to be just
    so.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到可以使用`+`来*连接*字符串。让我们看看如何使用各种格式将数据值*插值*到字符串中。您可以用此方法生成需要外观精确的报告、表格和其他输出。
- en: 'Besides the functions in the previous section, Python has three ways of formatting
    strings:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上一节中的函数外，Python还有三种格式化字符串的方法：
- en: '*old style* (supported in Python 2 and 3)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旧风格*（支持Python 2和3）'
- en: '*new style* (Python 2.6 and up)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*新风格*（Python 2.6及更高版本）'
- en: '*f-strings* (Python 3.6 and up)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f-strings*（Python 3.6及更高版本）'
- en: 'Old style: %'
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '旧风格：% '
- en: The old style of string formatting has the form *`format_string`* `%` *`data`*.
    Inside the format string are interpolation sequences. [Table 5-1](#conversion_types_table)
    illustrates that the very simplest sequence is a `%` followed by a letter indicating
    the data type to be formatted.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 旧式字符串格式化的形式为*`format_string`* `%` *`data`*。格式字符串中包含插值序列。[表5-1](#conversion_types_table)说明了最简单的序列是一个`%`后跟一个指示要格式化的数据类型的字母。
- en: Table 5-1\. Conversion types
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-1\. 转换类型
- en: '| `%s` | string |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `%s` | 字符串 |'
- en: '| `%d` | decimal integer |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | 十进制整数 |'
- en: '| `%x` | hex integer |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `%x` | 十六进制整数 |'
- en: '| `%o` | octal integer |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `%o` | 八进制整数 |'
- en: '| `%f` | decimal float |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `%f` | 十进制浮点数 |'
- en: '| `%e` | exponential float |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `%e` | 指数浮点数 |'
- en: '| `%g` | decimal or exponential float |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `%g` | 十进制或指数浮点数 |'
- en: '| `%%` | a literal `%` |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `%%` | 一个字面量`%` |'
- en: You can use a `%s` for any data type, and Python will format it as a string
    with no extra spaces.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`%s`来表示任何数据类型，Python会将其格式化为无额外空格的字符串。
- en: 'Following are some simple examples. First, an integer:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些简单的示例。首先，一个整数：
- en: '[PRE76]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'A float:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个浮点数：
- en: '[PRE77]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'An integer and a literal `%`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一个整数和一个字面量`%`：
- en: '[PRE78]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let’s try some string and integer interpolation:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些字符串和整数插值：
- en: '[PRE79]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: That `%s` inside the string means to interpolate a string. The number of `%`
    appearances in the string needs to match the number of data items after the `%`
    that follows the string. A single data item such as `actor` goes right after that
    final `%`. Multiple data must be grouped into a *tuple* (details in [Chapter 7](ch07.html#ch_lists);
    it’s bounded by parentheses, separated by commas) such as `(cat, weight)`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串中的`%s`表示插入一个字符串。字符串中`%`的数量需要与跟随字符串之后的数据项的数量匹配。单个数据项，如`actor`，直接放在最后一个`%`之后。多个数据必须分组成*元组*（详细信息见[第7章](ch07.html#ch_lists);
    由括号界定，逗号分隔），如`(cat, weight)`。
- en: Even though `weight` is an integer, the `%s` inside the string converted it
    to a string.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`weight`是一个整数，但字符串中的`%s`将其转换为字符串。
- en: 'You can add other values in the format string between the `%` and the type
    specifier to designate minimum and maximum widths, alignment, and character filling.
    This is a little language in its own right, and more limited than the one in the
    next two sections. Let’s take a quick look at these values:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在格式字符串的`%`和类型说明符之间添加其他值来指定最小宽度、最大宽度、对齐和字符填充。这本质上是一种小语言，比接下来的两个部分的语言更有限。让我们快速看看这些值：
- en: An initial `'%'` character.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始`'%'`字符。
- en: 'An optional *alignment* character: nothing or `''+''` means right-align, and
    `''-''` means left-align.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的*对齐*字符：没有或`'+'`表示右对齐，`'-'`表示左对齐。
- en: An optional *minwidth* field width to use.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的*最小宽度*字段宽度。
- en: An optional `'.'` character to separate *minwidth* and *maxchars*.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的`'.'`字符用于分隔*最小宽度*和*最大字符数*。
- en: An optional *maxchars* (if conversion type is `s`) saying how many characters
    to print from the data value. If the conversion type is `f`, this specifies *precision*
    (how many digits to print after the decimal point).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的*maxchars*（如果转换类型为`s`）指定要从数据值中打印多少个字符。如果转换类型为`f`，则指定*精度*（小数点后要打印多少位数）。
- en: The *conversion type* character from the earlier table.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 早期表格中的*转换类型*字符。
- en: 'This is confusing, so here are some examples for a string:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这很令人困惑，所以这里有一些字符串的示例：
- en: '[PRE82]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Once more with feeling, and a float with `%f` variants:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 再来一次，和一个带有`%f`变体的浮点数：
- en: '[PRE83]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'And an integer with `%d`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 和一个整数与`%d`：
- en: '[PRE84]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: For an integer, the `%+12d` just forces the sign to be printed, and the format
    strings with `.3` in them have no effect as they do for a float.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整数，`%+12d`只是强制打印符号，并且带有`.3`的格式字符串对其无效，就像对浮点数一样。
- en: 'New style: {} and format()'
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新风格：{} 和 format()
- en: 'Old style formatting is still supported. In Python 2, which will freeze at
    version 2.7, it will be supported forever. For Python 3, use the “new style” formatting
    described in this section. If you have Python 3.6 or newer, *f-strings* ([“Newest
    Style: f-strings”](#f_strings)) are even better.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然支持旧风格格式化。在Python 2中，将冻结在版本2.7上，将永远支持。对于Python 3，请使用本节中描述的“新风格”格式化。如果你使用的是Python
    3.6或更新版本，*f-strings*（[“最新风格：f-strings”](#f_strings)）更加推荐。
- en: “New style” formatting has the form `*format_string*.format(*data*)`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: “新风格”格式化的形式为`*format_string*.format(*data*)`。
- en: 'The format string is not exactly the same as the one in the previous section.
    The simplest usage is demonstrated here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串与前一节不完全相同。这里演示了最简单的用法：
- en: '[PRE85]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The arguments to the `format()` function need to be in the order as the `{}`
    placeholders in the format string:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()`函数的参数需要按照格式字符串中的`{}`占位符的顺序：'
- en: '[PRE86]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'With new-style formatting, you can also specify the arguments by position like
    this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新风格格式，你还可以像这样按位置指定参数：
- en: '[PRE87]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The value `0` referred to the first argument, `place`, and `1` referred to `thing`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 值`0`指的是第一个参数`place`，`1`指的是`thing`。
- en: The arguments to `format()` can also be named arguments
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()`的参数也可以是命名参数'
- en: '[PRE88]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'or a dictionary:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是一个字典：
- en: '[PRE89]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In the following example, `{0}` is the first argument to `format()` (the dictionary
    `d`):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`{0}`是`format()`的第一个参数（字典`d`）：
- en: '[PRE90]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'These examples all printed their arguments with default formats. New-style
    formatting has a slightly different format string definition from the old-style
    one (examples follow):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例都使用默认格式打印它们的参数。新风格格式化与旧风格的格式字符串定义略有不同（示例如下）：
- en: An initial colon (`':'`).
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始冒号（`':'`）。
- en: An optional *fill* character (default `' '`) to pad the value string if it’s
    shorter than *minwidth*.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的*填充*字符（默认为`' '`）以填充值字符串，如果比*minwidth*短。
- en: An optional *alignment* character. This time, left alignment is the default.
    `'<'` also means left, `'>'` means right, and `'^'` means center.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的*对齐*字符。这次，左对齐是默认的。`'<'`也表示左对齐，`'>'`表示右对齐，`'^'`表示居中。
- en: An optional *sign* for numbers. Nothing means only prepend a minus sign (`'-'`)
    for negative numbers. `' '` means prepend a minus sign for negative numbers, and
    a space (`' '`) for positive ones.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字的可选*符号*。没有意味着仅为负数添加减号（`'-'`）。`' '`表示负数前添加减号，正数前添加空格（`' '`）。
- en: An optional *minwidth*. An optional period (`'.'`) to separate *minwidth* and
    *maxchars*.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的*minwidth*。一个可选的句点（`'.'`）用于分隔*minwidth*和*maxchars*。
- en: An optional *maxchars*.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的*maxchars*。
- en: The *conversion type*.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*转换类型*。'
- en: '[PRE91]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Newest Style: f-strings'
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最新的风格：f-strings
- en: '*f-strings* appeared in Python 3.6, and are now the recommended way of formatting
    strings.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*f-strings*出现在Python 3.6中，现在是推荐的字符串格式化方式。'
- en: 'To make an f-string:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 制作f-string：
- en: Type the letter `f` or `F` directly before the initial quote.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接在初始引号之前输入字母`f`或`F`。
- en: Include variable names or expressions within curly brackets (`{}`) to get their
    values into the string.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大括号（`{}`）中包含变量名或表达式，以将它们的值放入字符串中。
- en: It’s like the previous section’s “new-style” formatting, but without the `format()`
    function, and without empty brackets (`{}`) or positional ones (`{1}`) in the
    format string.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像前一节的“新风格”格式化，但没有`format()`函数，并且格式字符串中没有空括号（`{}`）或位置参数（`{1}`）。
- en: '[PRE92]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'As I already mentioned, expressions are also allowed inside the curly brackets:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，大括号内也允许表达式：
- en: '[PRE93]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This means that the things that you could do inside `format()` in the previous
    section, you can now do inside a `{}` in your main string. This seems easier to
    read.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在前一节的`format()`中可以做的事情，在主字符串的`{}`内部现在也可以做到。这看起来更容易阅读。
- en: f-strings use the same formatting language (width, padding, alignment) as new-style
    formatting, after a `':'`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: f-strings使用与新式格式化相同的格式化语言（宽度、填充、对齐），在`':'`之后。
- en: '[PRE94]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Starting in Python 3.8, f-strings gain a new shortcut that’s helpful when you
    want to print variable names as well as their values. This is handy when debugging.
    The trick is to have a single `=` after the name in the `{}`-enclosed part of
    the f-string:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.8开始，f-strings增加了一个新的快捷方式，当你想打印变量名及其值时非常有帮助。在调试时非常方便。窍门是在f-string的`{}`括号内的变量名后面加上一个单独的`=`：
- en: '[PRE95]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The name can actually be an expression, and it will be printed literally:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 名称实际上可以是一个表达式，并且会按字面意思打印出来：
- en: '[PRE96]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Finally, the `=` can be followed by a `:` and the formatting arguments like
    width and alignment:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`=`后面可以跟着一个`:`和格式化参数，如宽度和对齐方式：
- en: '[PRE97]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: More String Things
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多字符串事项
- en: Python has many more string functions than I’ve shown here. Some will turn up
    in later chapters (especially [Chapter 12](ch12.html#ch_munging)), but you can
    find all the details at the [standard documentation link](http://bit.ly/py-docs-strings).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Python有比我展示的更多字符串函数。一些将出现在稍后的章节中（尤其是[第12章](ch12.html#ch_munging)），但你可以在[标准文档链接](http://bit.ly/py-docs-strings)找到所有细节。
- en: Coming Up
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将到来
- en: You’ll find Froot Loops at the grocery store, but Python loops are at the first
    counter in the next chapter.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在杂货店找到Froot Loops，但Python循环在下一章的第一个柜台上。
- en: Things to Do
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项
- en: '5.1 Capitalize the word starting with `m`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 5.1 将以`m`开头的单词大写：
- en: '[PRE98]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '5.2 Print each list question with its correctly matching answer, in the form:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 5.2 打印每个列表问题及其正确匹配的答案，格式为：
- en: 'Q: *question*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 'Q: *问题*'
- en: 'A: *answer*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 'A: *答案*'
- en: '[PRE99]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '5.3 Write the following poem by using old-style formatting. Substitute the
    strings `''roast beef''`, `''ham''`, `''head''`, and `''clam''` into this string:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 5.3 通过旧式格式编写以下诗歌。将字符串`'roast beef'`、`'ham'`、`'head'`和`'clam'`替换为此字符串中的内容：
- en: '[PRE100]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '5.4 Write a form letter by using new-style formatting. Save the following string
    as `letter` (you’ll use it in the next exercise):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 5.4 使用新式格式化编写一封表单信。将以下字符串保存为`letter`（你将在下一个练习中使用它）：
- en: '[PRE101]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 5.5 Assign values to variable strings named `'salutation'`, `'name'`, `'product'`,
    `'verbed'` (past tense verb), `'room'`, `'animals'`, `'percent'`, `'spokesman'`,
    and `'job_title'`. Print `letter` with these values, using `letter.format()`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 5.5 为字符串变量`'salutation'`、`'name'`、`'product'`、`'verbed'`（过去时动词）、`'room'`、`'animals'`、`'percent'`、`'spokesman'`和`'job_title'`分配值。使用`letter.format()`打印`letter`。
- en: '5.6 After public polls to name things, a pattern emerged: an English submarine
    (Boaty McBoatface), an Australian racehorse (Horsey McHorseface), and a Swedish
    train (Trainy McTrainface). Use `%` formatting to print the winning name at the
    state fair for a prize duck, gourd, and spitz.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 5.6 在公众投票之后为事物命名，出现了一个模式：英国潜艇（Boaty McBoatface）、澳大利亚赛马（Horsey McHorseface）和瑞典火车（Trainy
    McTrainface）。使用`%`格式化来打印国家集市上的获奖名字，以及鸭子、葫芦和spitz的奖品。
- en: 5.7 Do the same, with `format()` formatting.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 5.7 使用`format()`格式化方法做同样的事情。
- en: 5.8 Once more, with feeling, and *f strings*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 5.8 再来一次，使用*f strings*。
