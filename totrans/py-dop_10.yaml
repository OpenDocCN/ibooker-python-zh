- en: Chapter 10\. Infrastructure as Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。基础设施即代码
- en: Before we had fancy DevOps titles and job descriptions, we were lowly system
    administrators, or sysadmins for short. Those were the dark, pre-cloud days when
    we had to load the trunks of our cars with bare-metal servers and drive to a colocation
    (colo) facility to rack the servers, wire them, attach a wheeled monitor/keyboard/mouse
    to them, and set them up one by one. Grig still shudders to think about the hours
    he spent in colos, in blinding light and freezing A/C. We had to be wizards at
    Bash scripting, then we graduated to Perl, and the more fortunate of us to Python.
    As the saying went, the internet circa 2004 was held together with duct tape and
    bubble gum.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们拥有花哨的 DevOps 标题和工作描述之前，我们是卑微的系统管理员，或者简称为 sysadmins。那些是黑暗的，云计算之前的日子，当时我们不得不将我们的车的行李箱装满裸金属服务器，然后开车到一个机房设施，将服务器安装到机架上，连接它们，连接一个有轮子的监视器/键盘/鼠标，然后逐个设置它们。格里格仍然不敢想象他在机房度过的小时，灯光刺眼，空调冷得刺骨。我们必须成为
    Bash 脚本的巫师，然后我们毕业到 Perl，我们中更幸运的人到了 Python。俗话说，2004年左右的互联网是用胶带和泡泡糖粘在一起的。
- en: Somewhere during the period of 2006 to 2007, we discovered the magical world
    of Amazon EC2 instances. We were able to provision servers through a simple point-and-click
    interface, or through command-line tools. No more driving to colocation facilities,
    no more stacking and wiring bare-metal servers. We could go wild and launch 10
    EC2 instances at a time. Or even 20! Or even 100! The sky was the limit. However,
    we quickly figured out that manually connecting to each EC2 instance using SSH
    and then setting up our applications on every instance separately was not going
    to scale. It was fairly easy to provision the instances themselves. What was difficult
    was to install the required packages for our applications, add the correct users,
    make sure the file permissions looked right, and finally install and configure
    our applications. To scratch this itch, the first generation of infrastructure
    automation software came into being, represented by “configuration management”
    tools. Puppet was the first well-known configuration management tool, released
    in 2005 and predated the release of Amazon EC2\. Other such tools that were launched
    on the heels of Puppet were Chef in 2008, followed by SaltStack in 2011, and Ansible
    in 2012.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在2006年到2007年期间的某个时候，我们发现了亚马逊 EC2 实例的神奇世界。我们能够通过一个简单的点-and-click 接口或通过命令行工具来创建服务器。不再需要开车去机房，不再需要堆叠和连接裸金属服务器。我们可以疯狂地一次性启动
    10 个 EC2 实例。甚至 20！甚至 100！天空是极限。然而，我们很快发现，手动连接到每个 EC2 实例，然后在每个实例上单独设置我们的应用程序不会扩展。创建实例本身相当容易。困难的是安装我们应用程序所需的软件包，添加正确的用户，确保文件权限正确，最后安装和配置我们的应用程序。为了解决这个问题，第一代基础架构自动化软件诞生了，“配置管理”工具代表着。Puppet
    是第一个知名的配置管理工具，于 2005 年发布，早于 Amazon EC2 的发布。在 Puppet 推出后不久推出的其他类似工具包括2008年的 Chef，2011年的
    SaltStack，以及2012年的 Ansible。
- en: 'By 2009, the world was ready to welcome the arrival of a new term: DevOps.
    To this day, there are competing definitions of DevOps. What is interesting is
    that it came into being in the tumultuous early days of infrastructure software
    automation. While there are important people and culture aspects to DevOps, one
    thing stands out in this chapter: the ability to automate the provisioning, configuration,
    and deployment of infrastructure and applications.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到了2009年，世界准备迎来一个新术语的到来：DevOps。到今天为止，DevOps 有着竞争激烈的定义。有趣的是，它诞生在基础设施软件自动化的动荡早期。虽然
    DevOps 中有重要的人和文化方面，但在这一章中有一件事是突出的：即自动化基础架构和应用程序的配置、部署和部署能力。
- en: 'By 2011, it was getting hard to keep track of all the services comprising the
    Amazon Web Services (AWS) suite. The cloud was much more complicated than raw
    compute power (Amazon EC2) and object storage (Amazon S3). Applications started
    to rely on multiple services interacting with each other, and tools were needed
    to help automate the provisioning of these services. Amazon didn’t wait long to
    fill this need, and in 2011 it started offering just such a tool: AWS CloudFormation.
    This was one of the first moments when we could truly say that we were able to
    describe our infrastructure through code. CloudFormation opened the doors to a
    new generation of Infrastructure as Code (IaC) tools, which were operating at
    the layer of the cloud infrastructure itself, underneath the layer served by the
    first-generation configuration management tools.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到了2011年，要跟踪亚马逊网络服务（AWS）套件中所有的服务变得越来越困难。云比起原始计算能力（Amazon EC2）和对象存储（Amazon S3）要复杂得多。应用程序开始依赖于相互交互的多个服务，并且需要工具来帮助自动化这些服务的配置。亚马逊没有等待太久就填补了这个需求，2011年它开始提供这样的工具：AWS
    CloudFormation。这是我们真正能够通过代码描述基础设施的一个重要时刻之一。CloudFormation为基础设施即代码（IaC）工具的新一代打开了大门，这些工具操作的是云基础设施层，低于第一代配置管理工具所提供的层次。
- en: 'By 2014, AWS had launched dozens of services. That was the year when another
    important tool in the world of IaC came into being: Terraform, by HashiCorp. To
    this day, the two most used IaC tools are CloudFormation and Terraform.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到了2014年，AWS推出了数十项服务。那一年，另一个在IaC领域中重要的工具诞生了：HashiCorp的Terraform。时至今日，CloudFormation和Terraform仍然是最常用的IaC工具。
- en: 'Another important development in the world of IaC and DevOps was taking place
    sometime between late 2013 and early 2014: the release of Docker, which came to
    be synonymous with container technologies. Although containers had been around
    for a number of years, the great benefit that Docker brought to the table was
    that it wrapped technologies such as Linux containers and cgroups into an easy-to-use
    API and command-line interface (CLI) toolset that significantly lowered the barrier
    of entry for people who wanted to package their applications into containers that
    could be deployed and run wherever Docker was running. Container technologies
    and container orchestration platforms are discussed in detail in Chapters [11](ch11.html#containers-docker)
    and [12](ch12.html#containers-kubernetes).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在IaC和DevOps领域的另一个重要进展发生在2013年末到2014年初之间：Docker的发布，它成为容器技术的代名词。尽管容器技术已经存在多年，但Docker为此带来的巨大好处在于，它将Linux容器和cgroups等技术包装成易于使用的API和命令行界面（CLI）工具集，大大降低了希望将其应用程序打包成容器并在任何Docker运行的地方部署和运行的人们的准入门槛。容器技术和容器编排平台在第11章和第12章中有详细讨论。
- en: The usage and mindshare of Docker exploded and damaged the popularity of the
    first-generation configuration management tools (Puppet, Chef, Ansible, SaltStack).
    The companies behind these tools are reeling at the moment and are all trying
    to stay afloat and current by reinventing themselves as cloud friendly. Before
    the advent of Docker, you would provision the infrastructure for your application
    with an IaC tool such as CloudFormation or Terraform, then deploy the application
    itself (code and configuration) with a configuration management tool such as Puppet,
    Chef, Ansible, or SaltStack. Docker suddenly made these configuration management
    tools obsolete, since it provided a means for you to package your application
    (code + configuration) in a Docker container that would then run inside the infrastructure
    provisioned by the IaC tools.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的使用率和影响力急剧上升，损害了第一代配置管理工具（Puppet、Chef、Ansible、SaltStack）的流行度。这些工具背后的公司目前正陷入困境，并都在试图通过重塑自身以适应云环境来保持活力和时效性。在Docker出现之前，您会使用诸如CloudFormation或Terraform等IaC工具来配置应用程序的基础设施，然后使用配置管理工具（如Puppet、Chef、Ansible或SaltStack）部署应用程序本身（代码和配置）。Docker突然间使得这些配置管理工具变得过时，因为它提供了一种方式，您可以将应用程序（代码+配置）打包到一个Docker容器中，然后在由IaC工具配置的基础设施内运行。
- en: A Classification of Infrastructure Automation Tools
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施自动化工具分类
- en: Fast-forward to 2020 and it is easy to feel lost as a DevOps practitioner when
    faced with the multitude of infrastructure automation tools available.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到2020年，作为一名DevOps从业者，在面对众多基础设施自动化工具时很容易感到迷失。
- en: One way to differentiate IaC tools is by looking at the layer at which they
    operate. Tools such as CloudFormation and Terraform operate at the cloud infrastructure
    layer. They allow you to provision cloud resources such as compute, storage, and
    networking, as well as various services such as databases, message queues, data
    analytics, and many others. Configuration management tools such as Puppet, Chef,
    Ansible, and SaltStack typically operate at the application layer, making sure
    that all the required packages are installed for your application, and that the
    application itself is configured correctly (although many of these tools also
    have modules that can provision cloud resources). Docker also operates at the
    application layer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 区分 IaC 工具的一种方式是看它们运行的层级。CloudFormation 和 Terraform 等工具运行在云基础设施层。它们允许你提供云资源，如计算、存储和网络，以及各种服务，如数据库、消息队列、数据分析等。配置管理工具如
    Puppet、Chef、Ansible 和 SaltStack 通常在应用程序层操作，确保为你的应用程序安装所有所需的包，并确保应用程序本身配置正确（尽管这些工具中许多也有可以提供云资源的模块）。Docker
    也在应用程序层操作。
- en: Another way to compare IaC tools is by dividing them into declarative versus
    imperative categories. You can tell an automation tool what to do in a declarative
    manner where you describe the state of the system that you are trying to achieve.
    Puppet, CloudFormation, and Terraform operate in a declarative manner. Alternatively,
    you can use an automation tool in a procedural or imperative manner, where you
    specify the exact steps needed by the tool to achieve the desired system state.
    Chef and Ansible operate in an imperative manner. SaltStack can operate in both
    declarative and imperative manners.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种比较 IaC 工具的方法是将它们分为声明式和命令式两类。你可以用声明式方式告诉自动化工具要做什么，描述你想要实现的系统状态。Puppet、CloudFormation
    和 Terraform 采用声明式方式操作。或者，你可以使用程序化或命令式方式使用自动化工具，指定工具需要执行的确切步骤来实现所需的系统状态。Chef 和
    Ansible 采用命令式方式操作。SaltStack 可以同时采用声明式和命令式方式操作。
- en: Let’s look at the desired state of the system as a blueprint for the construction
    of a building, let’s say a stadium. You use procedural tools like Chef and Ansible
    to build the stadium, section by section and row by row inside each section. You
    need to keep track of the state of the stadium and the progress of the construction.
    Using declarative tools such as Puppet, CloudFormation, and Terraform, you first
    put together the blueprint for the stadium. The tool then makes sure that the
    construction achieves the state depicted in the blueprint.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把系统的期望状态看作建筑物（比如体育场）的建造蓝图。你可以使用 Chef 和 Ansible 这样的程序化工具，逐节、逐行地在每个部分内部建造体育场。你需要跟踪体育场的状态和建造进度。使用
    Puppet、CloudFormation 和 Terraform 这样的声明式工具，你首先组装体育场的蓝图。然后工具确保建造达到蓝图中描述的状态。
- en: Given this chapter’s title, we will focus the remaining discussion on IaC tools,
    which can be further classified along several dimensions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于本章的标题，我们将把剩下的讨论集中在 IaC 工具上，可以进一步按多个维度进行分类。
- en: One dimension is the way you specify the desired state of the system. In CloudFormation,
    you do it with JSON or YAML syntax, while in Terraform you do it with the proprietary
    HashiCorp Configuration Language (HCL) syntax. In contrast, Pulumi and the AWS
    Cloud Development Kit (CDK) allow you to use real programming languages, including
    Python, for specifying the desired state of the system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个维度是指定系统期望状态的方式。在 CloudFormation 中，你可以使用 JSON 或 YAML 语法，而在 Terraform 中，你可以使用
    HashiCorp Configuration Language (HCL) 语法。相比之下，Pulumi 和 AWS Cloud Development
    Kit (CDK) 允许你使用真正的编程语言，包括 Python，来指定系统的期望状态。
- en: Another dimension is the cloud providers supported by each tool. Since CloudFormation
    is an Amazon service, it stands to reason that it focuses on AWS (although one
    can define non-AWS resources with CloudFormation when using the custom resources
    feature). The same is true for the AWS CDK. In contrast, Terraform supports many
    cloud providers, as does Pulumi.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个维度是每个工具支持的云提供商。由于 CloudFormation 是亚马逊的服务，因此它专注于 AWS（尽管在使用自定义资源功能时可以定义非 AWS
    资源）。AWS CDK 也是如此。相比之下，Terraform 支持许多云提供商，Pulumi 也是如此。
- en: Because this is a book about Python, we would like to mention a tool called
    [troposphere](https://oreil.ly/Zdid-), which allows you to specify CloudFormation
    stack templates using Python code, and then exports them to JSON or YAML. Troposphere
    stops at the generation of the stack templates, which means that you need to provision
    the stacks using CloudFormation. One other tool that also uses Python and is worth
    mentioning is [stacker](https://oreil.ly/gBF_N). It uses troposphere under the
    covers, but it also provisions the generated CloudFormation stack templates.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本关于 Python 的书，我们想提到一个名为 [troposphere](https://oreil.ly/Zdid-) 的工具，它允许你使用
    Python 代码指定 CloudFormation 堆栈模板，然后将其导出为 JSON 或 YAML。Troposphere 只负责生成堆栈模板，这意味着你需要使用
    CloudFormation 进行堆栈的配置。另一个同样使用 Python 并值得一提的工具是 [stacker](https://oreil.ly/gBF_N)，它在底层使用
    troposphere，但它还可以配置生成的 CloudFormation 堆栈模板。
- en: The rest of this chapter shows two of these automation tools, Terraform and
    Pulumi, in action, each working on a common scenario, which is the deployment
    of a static website in Amazon S3, which is fronted by the Amazon CloudFront CDN
    and secured by an SSL certificate provisioned via the AWS Certificate Manager
    (ACM) service.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分展示了两个自动化工具 Terraform 和 Pulumi 的实际操作，它们分别应用于一个常见的场景，即在 Amazon S3 中部署静态网站，该网站由
    Amazon CloudFront CDN 托管，并通过 AWS 证书管理器（ACM）服务提供 SSL 证书保护。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the commands used in the following examples produce large amounts of
    output. Except for cases where it is critical to the understanding of the command,
    we will omit the majority of the output lines to save trees and enable you to
    focus better on the text.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中使用的某些命令会生成大量输出。除非这些输出对理解命令至关重要，否则我们将省略大部分输出行以节省资源，并帮助你更好地专注于文本内容。
- en: Manual Provisioning
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动配置
- en: We started by working through the scenario manually, using the AWS web-based
    console. Nothing like experiencing the pain of doing things manually so that you
    can better enjoy the results of automating tedious work!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过 AWS 的 Web 控制台手动完成了一系列操作。没有什么比亲自体验手动操作的痛苦更能让你更好地享受自动化繁琐工作的成果了！
- en: We first followed the documentation from AWS [website for hosting in S3](https://oreil.ly/kdv8T).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先按照 AWS [S3 托管网站](https://oreil.ly/kdv8T) 的文档进行操作。
- en: 'We already had a domain name bought via Namecheap: devops4all.dev. We created
    a hosted zone in Amazon Route 53 for the domain, and pointed the name servers
    for this domain in Namecheap to AWS DNS servers handling the hosted domain.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 Namecheap 购买了一个域名：devops4all.dev。我们为该域名在 Amazon Route 53 中创建了托管区域，并将该域名在
    Namecheap 中的名称服务器指向处理托管域名的 AWS DNS 服务器。
- en: We provisioned two S3 buckets, one for the root URL of the site (devops4all.dev)
    and one for the www URL (www.devops4all.dev). The idea was to redirect requests
    to www to the root URL. We also went through the guide and configured the buckets
    for static site hosting, with the proper permissions. We uploaded an *index.html*
    file and a JPG image to the root S3 bucket.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个 S3 存储桶，一个用于站点的根 URL（devops4all.dev），另一个用于 www URL（www.devops4all.dev）。我们的想法是将对
    www 的请求重定向到根 URL。我们还按照指南配置了这些存储桶，使其支持静态网站托管，并设置了适当的权限。我们上传了一个 *index.html* 文件和一张
    JPG 图片到根 S3 存储桶。
- en: The next step was to provision an SSL certificate to handle both the root domain
    name (devops4all.dev) and any subdomain of that domain (*.devops4all.dev). For
    verification, we used DNS records that we added to the Route 53 hosted zone.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是为处理根域名（devops4all.dev）及其任何子域名（*.devops4all.dev）的 SSL 证书进行配置。我们使用了添加到
    Route 53 托管区域的 DNS 记录进行验证。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The ACM certificate needs to be provisioned in the us-east-1 AWS region so that
    it can be used in CloudFront.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ACM 证书需要在 us-east-1 AWS 区域进行配置，以便在 CloudFront 中使用。
- en: We then created an AWS CloudFront CDN distribution pointing to the root S3 bucket
    and used the ACM certificate provisioned in the previous step. We specified that
    HTTP requests should be redirected to HTTPS. Once the distribution was deployed
    (which took approximately 15 minutes), we added Route 53 records for the root
    domain and the www domain as A records of type Alias pointing to the CloudFront
    distribution endpoint DNS name.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个 AWS CloudFront CDN 分发，指向根 S3 存储桶，并使用了前面配置的 ACM 证书。我们指定 HTTP 请求应重定向到
    HTTPS。分发部署完成后（大约需要 15 分钟），我们添加了 Route 53 记录，将根域名和 www 域名作为类型为别名的 A 记录，指向 CloudFront
    分发终端节点的 DNS 名称。
- en: At the end of this exercise, we were able to go to *http://devops4all.dev*,
    be redirected automatically to *https://devops4all.dev*, and see the home page
    of the site showing the image we uploaded. We also tried going to *http://www.devops4all.dev*
    and were redirected to *https://devops4all.dev*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本练习时，我们能够访问 *http://devops4all.dev*，自动重定向到 *https://devops4all.dev*，并看到我们上传的图片显示在站点首页上。我们还尝试访问
    *http://www.devops4all.dev*，并被重定向到 *https://devops4all.dev*。
- en: The manual creation of all the AWS resources we mentioned took approximately
    30 minutes. We also spent 15 minutes waiting for the CloudFront distribution propagation,
    for a total of 45 minutes. Note that we had done all this before, so we knew exactly
    what to do, with only minimal reference to the AWS guide.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手动创建所有提到的 AWS 资源大约花了 30 分钟。此外，我们还花了 15 分钟等待 CloudFront 分发的传播，总共是 45 分钟。请注意，我们之前已经做过这些，所以我们几乎完全知道该怎么做，只需要最少量地参考
    AWS 指南。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is worth taking a moment to appreciate how easy it is these days to provision
    a free SSL certificate. Gone are the days when you had to wait hours or even days
    for the SSL certificate provider to approve your request, only after you submitted
    proof that your company existed. Between AWS ACM, and Let’s Encrypt, there is
    no excuse not to have SSL enabled on all pages of your site in 2020.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，如今很容易配置免费的 SSL 证书。早已不再需要等待 SSL 证书提供商审批您的请求，并提交证明您的公司存在的时间，只需使用 AWS ACM
    或 Let’s Encrypt，2020 年再也没有不应该在站点的所有页面上启用 SSL 的借口。
- en: Automated Infrastructure Provisioning with Terraform
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 进行自动化基础设施配置
- en: We decided to use Terraform as the first IaC tool for the automation of these
    tasks, even though Terraform is not directly related to Python. It has several
    advantages, such as maturity, strong ecosystem, and multicloud provisioners.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定使用 Terraform 作为首选的 IaC 工具来自动化这些任务，尽管 Terraform 与 Python 没有直接关系。它有几个优点，如成熟性、强大的生态系统和多云供应商。
- en: The recommended way of writing Terraform code is to use modules, which are reusable
    components of Terraform configuration code. There is a common [registry](https://registry.terraform.io)
    of Terraform modules hosted by HashiCorp where you can search for ready-made modules
    that you might use for provisioning the resources you need. In this example, we
    will write our own modules.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Terraform 代码的推荐方式是使用模块，这些模块是 Terraform 配置代码的可重用组件。HashiCorp 托管的 Terraform
    模块的 [注册表](https://registry.terraform.io) 是一个通用的地方，您可以搜索用于配置所需资源的现成模块。在本示例中，我们将编写自己的模块。
- en: 'The version of Terraform used here is 0.12.1, which is the latest version at
    the time of this writing. Install it on a Mac by using `brew`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此处使用的 Terraform 版本是 0.12.1，在撰写本文时是最新版本。在 Mac 上通过 `brew` 安装它：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Provisioning an S3 Bucket
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置一个 S3 存储桶
- en: 'Create a *modules* directory and underneath it an *s3* directory containing
    three files: *main.tf*, *variables.tf*, and *outputs.tf*. The *main.tf* file in
    the *s3* directory tells Terraform to create an S3 bucket with a specific policy.
    It uses a variable called `domain_name` that is declared in *variables.tf* and
    whose value is passed to it by the caller of this module. It outputs the DNS endpoint
    of the S3 bucket, which will be used by other modules as an input variable.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 *modules* 目录，在其下创建一个 *s3* 目录，其中包含三个文件：*main.tf*、*variables.tf* 和 *outputs.tf*。*s3*
    目录中的 *main.tf* 文件告诉 Terraform 创建一个具有特定策略的 S3 存储桶。它使用一个名为 `domain_name` 的变量，在 *variables.tf*
    中声明，其值由调用此模块的用户传递给它。它输出 S3 存储桶的 DNS 端点，其他模块将使用它作为输入变量。
- en: 'Here are the three files in *modules/s3*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 *modules/s3* 中的三个文件：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `policy` attribute of the `aws_s3_bucket` resource above is an example of
    an S3 bucket policy that allows public access to the bucket. If you work with
    S3 buckets in an IaC context, it pays to familiarize yourself with the [official
    AWS documentation on bucket and user policies](https://oreil.ly/QtTYd).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `aws_s3_bucket` 资源的 `policy` 属性是允许公共访问该存储桶的 S3 存储桶策略的一个示例。如果您在 IaC 环境中使用
    S3 存储桶，请熟悉 [官方 AWS 存储桶和用户策略文档](https://oreil.ly/QtTYd)。
- en: 'The main Terraform script which ties together all the modules is a file called
    *main.tf* in the current directory:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有模块绑定在一起的主要 Terraform 脚本位于当前目录中的名为 *main.tf* 的文件中：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It refers to variables that are defined in a separate file called *variables.tf*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它引用了一个定义在名为 *variables.tf* 的单独文件中的变量：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the current directory tree at this point:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前目录树的情况：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first step in running Terraform is to invoke the `terraform init` command,
    which will read the contents of any module referenced by the main file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Terraform 的第一步是调用 `terraform init` 命令，它将读取主文件引用的任何模块的内容。
- en: The next step is to run the `terraform plan` command, which creates the blueprint
    mentioned in the earlier discussion.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是运行 `terraform plan` 命令，它创建了前面讨论中提到的蓝图。
- en: 'To create the resources specified in the plan, run `terraform apply`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建计划中指定的资源，请运行 `terraform apply` 命令：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At this point, check that the S3 bucket was created using the AWS web console
    UI.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，请检查是否使用 AWS Web 控制台 UI 创建了 S3 存储桶。
- en: Provisioning an SSL Certificate with AWS ACM
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 AWS ACM 配置 SSL 证书
- en: 'The next module is created for the provisioning of an SSL certificate using
    the AWS Certificate Manager service. Create a directory called *modules/acm* with
    three files: *main.tf*, *variables.tf*, and *outputs.tf*. The *main.tf* file in
    the *acm* directory tells Terraform to create an ACM SSL certificate using DNS
    as the validation method. It uses a variable called `domain_name` which is declared
    in *variables.tf* and whose value is passed to it by the caller of this module.
    It outputs the ARN identifier of the certificate, which will be used by other
    modules as an input variable.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个模块是为使用 AWS 证书管理器服务进行 SSL 证书配置而创建的。创建一个名为 *modules/acm* 的目录，其中包含三个文件：*main.tf*、*variables.tf*
    和 *outputs.tf*。*acm* 目录中的 *main.tf* 文件告诉 Terraform 使用 DNS 作为验证方法创建 ACM SSL 证书。它使用一个名为
    `domain_name` 的变量，该变量在 *variables.tf* 中声明，并由调用此模块的调用者传递其值。它输出证书的 ARN 标识符，该标识符将被其他模块用作输入变量。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add a reference to the new `acm` module in the main Terraform file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 Terraform 文件中添加对新的 `acm` 模块的引用：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next three steps are the same as in the S3 bucket creation sequence: `terraform
    init`, `terraform plan`, and `terraform apply`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个步骤与 S3 存储桶创建序列中的步骤相同：`terraform init`、`terraform plan` 和 `terraform apply`。
- en: Use the AWS console to add the necessary Route 53 records for the validation
    process. The certificate is normally validated and issued in a few minutes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AWS 控制台添加必要的 Route 53 记录以进行验证过程。证书通常会在几分钟内验证和发布。
- en: Provisioning an Amazon CloudFront Distribution
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Amazon CloudFront 分发
- en: 'The next module is created for the provisioning of an Amazon CloudFront distribution.
    Create a directory called *modules/cloudfront* with three files: *main.tf*, *variables.tf*,
    and *outputs.tf*. The *main.tf* file in the *cloudfront* directory tells Terraform
    to create a CloudFront distribution resource. It uses several variables that are
    declared in *variables.tf* and whose values are passed to it by the caller of
    this module. It outputs the DNS domain name for the CloudFront endpoint and the
    hosted Route 53 zone ID for the CloudFront distribution, which will be used by
    other modules as input variables:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个模块是为创建 Amazon CloudFront 分发而创建的。创建一个名为 *modules/cloudfront* 的目录，其中包含三个文件：*main.tf*、*variables.tf*
    和 *outputs.tf*。*cloudfront* 目录中的 *main.tf* 文件告诉 Terraform 创建 CloudFront 分发资源。它使用在
    *variables.tf* 中声明的多个变量，这些变量的值由调用此模块的调用者传递。它输出 CloudFront 端点的 DNS 域名和 CloudFront
    分发的托管 Route 53 区域 ID，这些将作为其他模块的输入变量使用：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Add a reference to the `cloudfront` module in the main Terraform file. Pass
    `s3_www_website_endpoint` and `acm_certificate_arn` as input variables to the
    `cloudfront` module. Their values are retrieved from the outputs of the other
    modules, `s3` and `acm`, respectively.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 Terraform 文件中添加对 `cloudfront` 模块的引用。将 `s3_www_website_endpoint` 和 `acm_certificate_arn`
    作为输入变量传递给 `cloudfront` 模块。它们的值从其他模块 `s3` 和 `acm` 的输出中获取。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: ARN stands for Amazon Resource Name. It is a string that uniquely identifies
    a given AWS resource. You will see many ARN values generated and passed around
    as variables when you use IaC tools that operate within AWS.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ARN 代表 Amazon 资源名称。它是一个字符串，用于唯一标识给定的 AWS 资源。当您使用在 AWS 内运行的 IaC 工具时，会看到许多生成的
    ARN 值作为变量传递和传递。
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next three steps are the usual ones for the provisioning of resources with
    Terraform: `terraform init`, `terraform plan`, and `terraform` `apply`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个步骤是使用 Terraform 进行资源配置的常规步骤：`terraform init`、`terraform plan` 和 `terraform
    apply`。
- en: The `terraform apply` step took almost 23 minutes in this case. Provisioning
    an Amazon CloudFront distribution is one of the lengthiest operations in AWS,
    because the distribution is being deployed globally by Amazon behind the scenes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`terraform apply` 步骤耗时约 23 分钟。创建 Amazon CloudFront 分发是 AWS 中最耗时的操作之一，因为该分发在幕后由
    Amazon 在全球范围内部署。
- en: Provisioning a Route 53 DNS Record
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Route 53 DNS 记录
- en: 'The next module was for the creation of a Route 53 DNS record for the main
    domain of the site www.devops4all.dev. Create a directory called *modules/route53*
    with two files: *main.tf* and *variables.tf*. The *main.tf* file in the *route53*
    directory tells Terraform to create a Route 53 DNS record of type `A` as an alias
    to the DNS name of the CloudFront endpoint. It uses several variables that are
    declared in *variables.tf* and whose values are passed to it by the caller of
    this module:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个模块是为站点 www.devops4all.dev 的主域创建 Route 53 DNS 记录。创建一个名为 *modules/route53*
    的目录，并包含两个文件：*main.tf* 和 *variables.tf*。*route53* 目录中的 *main.tf* 文件告诉 Terraform
    创建一个类型为 `A` 的 Route 53 DNS 记录，作为 CloudFront 终端节点的 DNS 名称的别名。它使用在 *variables.tf*
    中声明的几个变量，并通过调用此模块的调用者传递给它的值：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add a reference to the `route53` module in the *main.tf* Terraform file. Pass
    `zone_id`, `cloudfront_domain_name`, and `cloudfront_zone_id` as input variables
    to the `route53` module. The value of `zone_id` is declared in *variables.tf*
    in the current directory, while the other values are retrieved from the outputs
    of the `cloudfront` module:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *main.tf* Terraform 文件中添加对 `route53` 模块的引用。将 `zone_id`、`cloudfront_domain_name`
    和 `cloudfront_zone_id` 作为输入变量传递给 `route53` 模块。`zone_id` 的值在当前目录的 *variables.tf*
    中声明，而其他值则从 `cloudfront` 模块的输出中检索：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next three steps, which should be very familiar to you by now, are for
    the provisioning of resources with Terraform: `terraform init`, `terraform plan`,
    and `terraform apply`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个步骤，现在对您来说应该非常熟悉了，是使用 Terraform 配置资源的：`terraform init`、`terraform plan`
    和 `terraform apply`。
- en: Copying Static Files to S3
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将静态文件复制到 S3
- en: 'To test the provisioning of the static website from end to end, create a simple
    file called *index.html* that includes a JPEG image, and copy both files to the
    S3 bucket previously provisioned with Terraform. Make sure that the `AWS_PROFILE`
    environment variable is set to a correct value already present in the *~/.aws/credentials*
    file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试从头到尾创建静态网站的配置，创建一个名为 *index.html* 的简单文件，其中包含一个 JPEG 图像，并将这两个文件复制到之前使用 Terraform
    配置的 S3 存储桶。确保 `AWS_PROFILE` 环境变量已设置为 *~/.aws/credentials* 文件中已存在的正确值：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Visit [*https://www.devops4all.dev/*](https://www.devops4all.dev/) and verify
    that you can see the JPG image that was uploaded.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [*https://www.devops4all.dev/*](https://www.devops4all.dev/) 并验证您是否可以看到已上传的
    JPG 图像。
- en: Deleting All AWS Resources Provisioned with Terraform
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Terraform 删除所有已配置的 AWS 资源
- en: Whenever you provision cloud resources, you need to be mindful of the cost associated
    with them. It is very easy to forget about them, and you may be surprised by the
    AWS bill you receive at the end of the month. Make sure to delete all the resources
    provisioned above. Remove these resources by running the `terraform destroy` command.
    One more thing to note is that the contents of the S3 bucket need to be removed
    before running `terraform destroy` because Terraform will not delete a nonempty
    bucket.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您配置云资源时，都需要注意与其相关的费用。很容易忘记它们，您可能会在月底收到意外的 AWS 账单。确保删除上面配置的所有资源。通过运行 `terraform
    destroy` 命令来删除这些资源。还要注意，在运行 `terraform destroy` 之前需要删除 S3 存储桶的内容，因为 Terraform
    不会删除非空桶的内容。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Before running the `terraform destroy` command, make sure you will not delete
    resources that might still be used in production!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `terraform destroy` 命令之前，请确保您不会删除仍可能在生产环境中使用的资源！
- en: Automated Infrastructure Provisioning with Pulumi
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pulumi 自动化基础设施配置
- en: Pulumi is one of the new kids on the block when it comes to IaC tools. The keyword
    here is *new*, which means it is still somewhat rough around the edges, especially
    in regards to Python support.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 IaC 工具时，Pulumi 是新秀之一。关键词是 *new*，这意味着它在某些方面仍然有些粗糙，特别是在 Python 支持方面。
- en: Pulumi allows you to specify the desired state of your infrastructure by telling
    it which resources to provision using real programming languages. TypeScript was
    the first language supported by Pulumi, but nowadays Go and Python are also supported.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Pulumi 允许您通过告诉它使用真正的编程语言来提供所需的基础设施状态，来指定您的基础设施的期望状态。TypeScript 是 Pulumi 支持的第一种语言，但现在也支持
    Go 和 Python。
- en: It is important to understand the difference between writing infrastructure
    automation code in Python using Pulumi and an AWS automation library such as Boto.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 理解在 Python 中使用 Pulumi 编写基础设施自动化代码与使用 AWS 自动化库（如 Boto）之间的区别至关重要。
- en: With Pulumi, your Python code describes the resources that you want to be provisioned.
    You are, in effect, creating the blueprint or the state discussed at the beginning
    of the chapter. This makes Pulumi similar to Terraform, but the big difference
    is that Pulumi gives you the full power of a programming language such as Python
    in terms of writing functions, loops, using variables, etc. You are not hampered
    by the use of a markup language such as Terraform’s HCL. Pulumi combines the power
    of a declarative approach, where you describe the desired end state, with the
    power of a real programming language.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pulumi，您的Python代码描述了要部署的资源。实际上，您正在创建本章开头讨论的蓝图或状态。这使得Pulumi类似于Terraform，但其主要区别在于Pulumi允许您充分利用像Python这样的编程语言的全部功能，例如编写函数、循环、使用变量等。您不受Terraform的HCL等标记语言的限制。Pulumi结合了声明式方法的强大之处（描述所需的最终状态）与真正编程语言的强大之处。
- en: With an AWS automation library such as Boto, you both describe and provision
    individual AWS resources through the code you write. There is no overall blueprint
    or state. You need to keep track of the provisioned resources yourself, and to
    orchestrate their creation and removal. This is the imperative or procedural approach
    for automation tools. You still get the advantage of writing Python code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用诸如Boto之类的AWS自动化库，您可以通过编写的代码描述和提供单个AWS资源。没有整体蓝图或状态。您需要自行跟踪已提供的资源，并协调其创建和移除。这是自动化工具的命令式或过程化方法。您仍然可以利用编写Python代码的优势。
- en: To start using Pulumi, create a free account on their website pulumi.io. Then
    you can install the `pulumi` command-line tool on your local machine. On a Macintosh,
    use Homebrew to install `pulumi`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Pulumi，请在他们的网站pulumi.io上创建一个免费帐户。然后，您可以在本地计算机上安装`pulumi`命令行工具。在Macintosh上，请使用Homebrew安装`pulumi`。
- en: 'The first command to run locally is `pulumi login`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本地运行的第一个命令是`pulumi login`：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating a New Pulumi Python Project for AWS
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建AWS的新Pulumi Python项目
- en: 'Create a directory called *proj1*, run `pulumi new` in that directory, and
    chose the `aws-python` template. As part of the project creation, `pulumi` asks
    for the name of a stack. Call it `staging`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*proj1*的目录，在该目录中运行`pulumi new`，并选择`aws-python`模板。在项目创建的过程中，`pulumi`会要求您为堆栈命名。称其为`staging`：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is important to understand the difference between a Pulumi project and a
    Pulumi stack. A project is the code you write for specifying the desired state
    of the system, the resources you want Pulumi to provision. A stack is a specific
    deployment of the project. For example, a stack can correspond to an environment
    such as development, staging, or production. In the examples that follow, we will
    create two Pulumi stacks, one called `staging` that corresponds to a staging environment,
    and further down the line, another stack called `prod` that corresponds to a production
    environment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解Pulumi项目与Pulumi堆栈之间的区别。项目是您为指定系统所需状态编写的代码，即您希望Pulumi提供的资源。堆栈是项目的特定部署。例如，堆栈可以对应于开发、暂存或生产等环境。在接下来的示例中，我们将创建两个Pulumi堆栈，一个称为`staging`，对应于暂存环境，以及稍后的另一个称为`prod`，对应于生产环境。
- en: 'Here are the files automatically generated by the `pulumi new` command as part
    of the `aws-python` template:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是由`pulumi new`命令自动生成的文件，作为`aws-python`模板的一部分：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Follow the instructions in the output of `pulumi new` and install `virtualenv`,
    then create a new `virtualenv` environment and install the libraries specified
    in *requirements.txt*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 按照`pulumi new`的输出指示安装`virtualenv`，然后创建新的`virtualenv`环境并安装*requirements.txt*中指定的库：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Before provisioning any AWS resources with `pulumi up`, make sure you are using
    the AWS account that you are expecting to target. One way to specify the desired
    AWS account is to set the `AWS_PROFILE` environment variable in your current shell.
    In our case, an AWS profile called `gheorghiu-net` was already set up in the local
    *~/.aws/credentials* file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`pulumi up`之前，确保您正在使用预期目标的AWS帐户来配置任何AWS资源。指定所需AWS帐户的一种方法是在当前shell中设置`AWS_PROFILE`环境变量。在我们的情况下，本地*~/.aws/credentials*文件中已设置了名为`gheorghiu-net`的AWS配置文件。
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The *__main__.py* file generated by Pulumi as part of the `aws-python` template
    is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由Pulumi作为`aws-python`模板的一部分生成的*__main__.py*文件如下：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Clone the [Pulumi examples GitHub repository](https://oreil.ly/SIT-v) locally,
    then copy *__main__.py* and the *www* directory from *pulumi-examples/aws-py-s3-folder*
    into the current directory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本地克隆[Pulumi示例GitHub存储库](https://oreil.ly/SIT-v)，然后将\_\_main\_\_.py和*pulumi-examples/aws-py-s3-folder*中的www目录复制到当前目录中。
- en: 'Here is the new *__main__.py* file in the current directory:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是当前目录中的新\_\_main\_\_.py文件：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the use of Python variables for `content_dir` and `bucket_name`, the use
    of a `for` loop, and also the use of a regular Python function `public_read_policy_for_bucket`.
    It is refreshing to be able to use regular Python constructs in IaC programs!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意Python变量`content_dir`和`bucket_name`的使用，`for`循环的使用，以及正常Python函数`public_read_policy_for_bucket`的使用。能够在IaC程序中使用正常的Python结构感到耳目一新！
- en: 'Now it’s time to run `pulumi up` to provision the resources specified in *__main__.py*.
    This command will show all the resources that will be created. Moving the current
    choice to `yes` will kick off the provisioning process:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是运行`pulumi up`以提供在\_\_main\_\_.py中指定的资源的时候了。该命令将展示将要创建的所有资源。将当前选择移动到`yes`将启动配置过程：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inspect the existing Pulumi stacks:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 检查现有的Pulumi堆栈：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inspect the outputs of the current stack:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 检查当前堆栈的输出：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Visit the URL specified in the `website_url` output ([*http://s3-website-bucket-8e08f8f.s3-website-us-east-1.amazonaws.com*](http://s3-website-bucket-8e08f8f.s3-website-us-east-1.amazonaws.com))
    and make sure you can see the static site.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`website_url`输出中指定的URL（[*http://s3-website-bucket-8e08f8f.s3-website-us-east-1.amazonaws.com*](http://s3-website-bucket-8e08f8f.s3-website-us-east-1.amazonaws.com)），确保您可以看到静态站点。
- en: 'In the sections that follow, the Pulumi project will be enhanced by specifying
    more AWS resources to be provisioned. The goal is to have parity with the resources
    that were provisioned with Terraform: an ACM SSL certificate, a CloudFront distribution,
    and a Route 53 DNS record for the site URL.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，将通过指定更多的AWS资源来增强Pulumi项目。目标是与使用Terraform配置的资源保持一致：一个ACM SSL证书，一个CloudFront分发和一个用于站点URL的Route
    53 DNS记录。
- en: Creating Configuration Values for the Staging Stack
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Staging堆栈创建配置值
- en: 'The current stack is `staging`. Rename the existing *www* directory to *www-staging*,
    then use the `pulumi config set` command to specify two configuration values for
    the current `staging` stack: `domain_name` and `local_webdir`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当前堆栈为`staging`。将现有的www目录重命名为www-staging，然后使用`pulumi config set`命令为当前`staging`堆栈指定两个配置值：`domain_name`和`local_webdir`。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: For more details on how Pulumi manages configuration values and secrets, see
    [the Pulumi reference documentation](https://oreil.ly/D_Cy5).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Pulumi如何管理配置值和密钥的详细信息，请参阅[Pulumi参考文档](https://oreil.ly/D_Cy5)。
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To inspect the existing configuration values for the current stack, run:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查当前堆栈的现有配置值，请运行：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the configuration values are set, use them in the Pulumi code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 配置值设置完毕后，将它们用于Pulumi代码中：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that the configuration values are in place; next we will provision an SSL
    certificate with the AWS Certificate Manager service.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在配置值已经就位；接下来我们将使用AWS证书管理器服务来提供SSL证书。
- en: Provisioning an ACM SSL Certificate
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置ACM SSL证书
- en: Around this point, Pulumi starts to show its rough edges when it comes to its
    Python SDK. Just reading the Pulumi Python SDK reference for the [`acm`](https://oreil.ly/Niwaj)
    module is not sufficient to make sense of what you need to do in your Pulumi program.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在这一点上，当涉及到其Python SDK时，Pulumi开始显露出其不足之处。仅仅阅读Pulumi Python SDK参考中的[`acm`](https://oreil.ly/Niwaj)模块并不足以理解您在Pulumi程序中需要做的事情。
- en: Fortunately, there are many Pulumi examples in TypeScript that you can take
    inspiration from. One such example that illustrated our use case is [`aws-ts-static-website`](https://oreil.ly/7F39c).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有许多Pulumi TypeScript示例可供您参考。一个展示我们用例的示例是[`aws-ts-static-website`](https://oreil.ly/7F39c)。
- en: 'Here is the TypeScript code for creating a new ACM certificate (from [`index.ts`](https://oreil.ly/mlSr1)):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建新ACM证书的TypeScript代码（来自[`index.ts`](https://oreil.ly/mlSr1)）：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is the equivalent Python code that we wrote:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们编写的相应Python代码：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: A rule of thumb in porting Pulumi code from TypeScript to Python is that parameter
    names that are camelCased in TypeScript become snake_cased in Python. As you can
    see in the earlier example, `domainName` becomes `domain_name` and `validationMethod`
    becomes `validation_method`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从TypeScript转换Pulumi代码到Python的一个经验法则是，在TypeScript中使用驼峰命名法的参数在Python中会变成蛇形命名法。正如您在前面的示例中看到的，`domainName`变成了`domain_name`，而`validationMethod`变成了`validation_method`。
- en: Our next step was to provision a Route 53 zone and in that zone a DNS validation
    record for the ACM SSL certificate.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是为 ACM SSL 证书配置 Route 53 区域，并在该区域中为 DNS 验证记录。
- en: Provisioning a Route 53 Zone and DNS Records
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Route 53 区域和 DNS 记录
- en: Provisioning a new Route 53 zone with Pulumi is easy if you follow the [Pulumi
    SDK reference for route53](https://oreil.ly/cU9Yj).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循 [Pulumi SDK reference for route53](https://oreil.ly/cU9Yj)，使用 Pulumi 配置新的
    Route 53 区域非常容易。
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding snippet shows how to use a regular Python function to split the
    configuration value read into the `domain_name` variable into two parts. If `domain_name`
    is `staging.devops4all.dev`, the function will split it into `subdomain` (`staging`)
    and `parent_domain` (`devops4all.dev`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段显示了如何使用常规 Python 函数将读取的配置值拆分为 `domain_name` 变量的两部分。如果 `domain_name` 是
    `staging.devops4all.dev`，则函数将其拆分为 `subdomain` (`staging`) 和 `parent_domain` (`devops4all.dev`)。
- en: The `parent_domain` variable is then used as a parameter to the constructor
    of the `zone` object, which tells Pulumi to provision a `route53.Zone` resource.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`parent_domain` 变量然后作为 `zone` 对象的构造函数的参数使用，告诉 Pulumi 配置 `route53.Zone` 资源。'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Once the Route 53 zone was created, we had to point the Namecheap name servers
    at the name servers specified in the DNS record for the new zone so that the zone
    can be publicly accessible.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Route 53 区域后，我们必须将 Namecheap 的域名服务器指向新区域的 DNS 记录中指定的域名服务器，以便该区域可以公开访问。
- en: All was well and good so far. The next step was to create both the ACM certificate
    and a DNS record to validate the certificate.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利。接下来的步骤是同时创建 ACM 证书和用于验证证书的 DNS 记录。
- en: We first tried to port the example TypeScript code by applying the rule of thumb
    of turning camelCase parameter names into snake_case.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先尝试通过将 camelCase 参数名转换为 snake_case 的经验法则来移植示例 TypeScript 代码。
- en: 'TypeScript:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'TypeScript:'
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first attempt at porting to Python by switching camelCase to snake_case:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试通过将 camelCase 转换为 snake_case 来将示例移植到 Python：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'No luck. `pulumi up` shows this error:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 运气不佳。`pulumi up` 显示如下错误：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: At this point, we were stumped, because the Python SDK documentation doesn’t
    include this level of detail. We did not know what attributes we needed to specify
    for the `domain_validation_options` object.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们陷入困境，因为 Python SDK 文档没有包含这么详细的信息。我们不知道在 `domain_validation_options`
    对象中需要指定哪些属性。
- en: 'We were only able to get past this by adding the `domain_validation_options`
    object to the list of Pulumi exports, which are printed out by Pulumi at the end
    of the `pulumi up` operation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能通过在 Pulumi 的导出列表中添加 `domain_validation_options` 对象来解决此问题，这些对象由 Pulumi 在
    `pulumi up` 操作结束时打印出来。
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output from `pulumi up` was:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`pulumi up` 的输出如下：'
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Bingo! It turns out that the attributes of the `domain_validation_options` object
    are still camelCased.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 终于找到了！原来 `domain_validation_options` 对象的属性仍然是驼峰命名法。
- en: 'Here is the second attempt at porting to Python, which was successful:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二次成功移植到 Python 的尝试：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, specify a new type of resource to be provisioned: a certificate validation
    completion resource. This causes the `pulumi up` operation to wait until ACM validates
    the certificate by checking the Route 53 validation record created earlier.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，指定要配置的新类型资源：证书验证完成资源。这使得 `pulumi up` 操作等待 ACM 通过检查先前创建的 Route 53 验证记录来验证证书。
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At this point, you have a fully automated way of provisioning an ACM SSL certificate
    and of validating it via DNS.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，您已经拥有了通过完全自动化的方式配置 ACM SSL 证书并通过 DNS 进行验证的方法。
- en: The next step is to provision the CloudFront distribution in front of the S3
    bucket hosting the static files for the site.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是在托管站点静态文件的 S3 存储桶前面配置 CloudFront 分发。
- en: Provisioning a CloudFront Distribution
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 CloudFront 分发
- en: Use the SDK reference for the Pulumi [`cloudfront` module](https://oreil.ly/4n98-)
    to figure out which constructor parameters to pass to `cloudfront.Distribution`.
    Inspect the TypeScript code to know what the proper values are for those parameters.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Pulumi [`cloudfront` 模块](https://oreil.ly/4n98-) 的 SDK 参考来确定传递给 `cloudfront.Distribution`
    的构造函数参数。检查 TypeScript 代码以了解这些参数的正确值。
- en: 'Here is the final result:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是最终结果：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run `pulumi up` to provision the CloudFront distribution.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `pulumi up` 以配置 CloudFront 分发。
- en: Provisioning a Route 53 DNS Record for the Site URL
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为站点 URL 配置 Route 53 DNS 记录
- en: 'The last step in the end-to-end provisioning of the resources for the `staging`
    stack was the relatively simple task of specifying a DNS record of type `A` as
    an alias to the domain of the CloudFront endpoint:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在端到端为 `staging` 栈配置资源的最后一步是将 `A` 类型的 DNS 记录作为 CloudFront 终端节点的域的别名指定。
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Run `pulumi up` as usual.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如常运行 `pulumi up`。
- en: Visit [*https://staging.devops4all.dev*](https://staging.devops4all.dev) and
    see the files uploaded to S3\. Go to the logging bucket in the AWS console and
    make sure the CloudFront logs are there.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [*https://staging.devops4all.dev*](https://staging.devops4all.dev)，查看上传到
    S3 的文件。转到 AWS 控制台中的日志桶，并确保 CloudFront 日志在那里。
- en: Let’s see how to deploy the same Pulumi project to a new environment, represented
    by a new Pulumi stack.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将相同的 Pulumi 项目部署到一个新的环境，由新的 Pulumi 栈表示。
- en: Creating and Deploying a New Stack
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和部署新栈
- en: We decided to modify the Pulumi program so that it does not provision a new
    Route 53 zone, but instead uses the value of the zone ID for an existing zone
    as a configuration value.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定修改 Pulumi 程序，使其不再创建新的 Route 53 区域，而是使用现有区域的区域 ID 作为配置值。
- en: 'To create the `prod` stack, use the command `pulumi stack init` and specify
    `prod` for its name:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `prod` 栈，请使用命令 `pulumi stack init` 并将其名称指定为 `prod`：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing the stacks now shows the two stacks, `staging` and `prod`, with an
    asterisk next to `prod` signifying that `prod` is the current stack:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列出栈现在显示了两个栈，`staging` 和 `prod`，`prod` 栈旁边带有星号，表示 `prod` 是当前栈：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now it’s time to set the proper configuration values for the `prod` stack.
    Use a new `dns_zone_id` configuration value, set to the ID of the zone that was
    already created by Pulumi when it provisioned the `staging` stack:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是为 `prod` 栈设置正确配置值的时候了。使用一个新的 `dns_zone_id` 配置值，设置为在 Pulumi 配置 `staging` 栈时已创建的区域的
    ID：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Change the code to read `zone_id` from the configuration and to not create the
    Route 53 zone object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 更改代码以从配置中读取 `zone_id` 并且不创建 Route 53 区域对象。
- en: 'Run `pulumi up` to provision the AWS resources:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `pulumi up` 配置 AWS 资源：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Success! The `prod` stack was fully deployed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！`prod` 栈已完全部署。
- en: However, the contents of the *www-prod* directory containing the static files
    for the site are identical at this point to the contents of the *www-staging*
    directory.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此时 *www-prod* 目录中包含站点静态文件的内容与 *www-staging* 目录中的内容相同。
- en: 'Modify *www-prod/index.html* to change “Hello, S3!” to “Hello, S3 production!”,
    then run `pulumi up` again to detect the changes and upload the modified file
    to S3:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 *www-prod/index.html*，将“Hello, S3!”改为“Hello, S3 production!”，然后再次运行 `pulumi
    up` 以检测更改并将修改后的文件上传到 S3：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Invalidate the cache of the CloudFront distribution to see the change.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使 CloudFront 分发的缓存失效以查看更改。
- en: 'Visit [*https://www.devops4all.dev*](https://www.devops4all.dev) and see the
    message: `Hello, S3 production!`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [*https://www.devops4all.dev*](https://www.devops4all.dev)，查看消息：`Hello, S3
    production!`
- en: 'One caveat about IaC tools that keep track of the state of the system: there
    are situations when the state as seen by the tool will be different from the actual
    state. In that case, it is important to synchronize the two states; otherwise,
    they will drift apart more and more and you will be in the situation where you
    don’t dare make any more changes for fear that you will break production. It’s
    not for nothing that the word *Code* is prominent in *Infrastructure as Code*.
    Once you commit to using an IaC tool, best practices say that you should provision
    all resources via code, and no longer spin up any resource manually. It is hard
    to maintain this discipline, but it pays dividends in the long run.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 关于跟踪系统状态的 IaC 工具有一个注意事项：有时工具看到的状态与实际状态不同。在这种情况下，同步两种状态非常重要；否则，它们会越来越分离，你会陷入不敢再进行更改的境地，因为害怕会破坏生产环境。这就是为什么“Code”一词在“基础设施即代码”中占主导地位的原因。一旦决定使用
    IaC 工具，最佳实践建议所有资源都通过代码进行配置，不再手动创建任何资源。保持这种纪律是很难的，但长远来看会带来回报。
- en: Exercises
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Provision the same set of AWS resources by using the [AWS Cloud Development
    Kit](https://aws.amazon.com/cdk).
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 [AWS Cloud Development Kit](https://aws.amazon.com/cdk) 配置相同的一组 AWS 资源。
- en: Use Terraform or Pulumi to provision cloud resources from other cloud providers,
    such as Google Cloud Platform or Microsoft Azure.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 或 Pulumi 从其他云服务提供商（如 Google Cloud Platform 或 Microsoft Azure）配置云资源。
