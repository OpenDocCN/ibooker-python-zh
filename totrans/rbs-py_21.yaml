- en: Chapter 18\. Event-Driven Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Extensibility is important at every level of your codebase. At the code level,
    you employ extensibility to make your functions and classes flexible. At the abstract
    level, you utilize the same principles in your codebase’s architecture. *Architecture*
    is the set of high-level guidelines and constraints that shape how you design
    software. It is the vision that influences all developers, past, present, and
    future. This chapter, as well as the next one, are going to show two examples
    of how architectural examples improve maintability. Everything you’ve learned
    so far in this part of the book applies: good architecture promotes extensibility,
    manages dependencies well, and fosters composability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about event-driven architecture. *Event-driven
    architecture* revolves around events, or notifications in your system. It is a
    fantastic way to decouple different parts of your codebase, as well as extend
    your system for new functionality or performance. Event-driven architectures allow
    you to introduce new changes easily with minimal impact. First, I want to talk
    about the flexibility that event-driven architectures provide. Then, I’ll cover
    two separate variations of event-driven architectures: simple events and streaming
    events. While they are similar, you will use them in slightly different scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: How It Works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you focus on event-driven architectures, you are revolving around reactions
    to stimuli. You deal with reactions to simuli all the time, whether it’s pulling
    a casserole out of the oven or picking up a delivery from your front door after
    a phone notification. In an event-driven architecture, you architect your code
    to represent this model. Your stimulus is some *producer* of events. A *consumer*
    of these events is the reaction to that stimulus. An event is just a transmission
    of information from a producer to a consumer. [Table 18-1](part0023_split_001.html#producer_consumer_table)
    shows some common producer–consumer pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Table 18-1\. Everyday events and their consumers
  prefs: []
  type: TYPE_NORMAL
- en: '| Producer | Consumer |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Kitchen timer going off | Chef retrieves a casserole from the oven |'
  prefs: []
  type: TYPE_TB
- en: '| Cook ringing a bell when a dish is done | Server picks it up and serves it
    |'
  prefs: []
  type: TYPE_TB
- en: '| Alarm clock going off | Late sleeper wakes up |'
  prefs: []
  type: TYPE_TB
- en: '| A last call for boarding at an airport | Rushing family rushes, trying to
    make their connection |'
  prefs: []
  type: TYPE_TB
- en: 'You actually deal with producers and consumers every time you program. Any
    function that returns a value is a producer, and any piece of code that uses that
    returned value is a consumer. Observe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `complete_order` is *producing* information in the form of a completed
    order. Based on the function names, the customer and the restaurant are *consuming*
    the fact that an order is done. There is a direct linkage where the producer notifies
    the consumer. Event-driven architectures aim to sever this physical dependency.
    The goal is to decouple producers and consumers. Producers do not know about the
    consumers, and consumers do not know about the producers. This is what drives
    the flexibility of an event-driven architecture.
  prefs: []
  type: TYPE_NORMAL
- en: With this decoupling, it becomes incredibly easy to add onto your system. If
    you need new consumers, you can add them without ever touching the producer. If
    you need different producers, you can add them without ever touching the consumers.
    This bidirectional extensibility allows you to substantially change multiple parts
    of your codebase in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: What’s happening behind the scenes is quite ingenious. Instead of any dependencies
    between producer and consumer, they both depend on a transport mechanism, as shown
    in [Figure 18-1](part0023_split_001.html#transport_mechanism). A *transport mechanism*
    is simply the way that two pieces of code pass data back and forth.
  prefs: []
  type: TYPE_NORMAL
- en: '![ropy 1801](../images/00033.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-1\. Producer–consumer relationship
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Drawbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because the producer and consumer depend on a transport mechanism, they have
    to agree on the message format. In most event-driven architectures, both the producer
    and consumer agree on a common identifier and message format. This does create
    a *logical* dependency between the two but not a physical one. If either party
    changes the identifier or message format in an incompatible way, the scheme breaks
    down. And like most logical dependencies, it is difficult to link the dependencies
    together through inspection. Consult [Chapter 16](part0021_split_000.html#dependencies)
    to learn more about how to mitigate these problems.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this separation of code, your typechecker will not be much help when
    things go wrong. If a consumer starts depending on the wrong event type, the typechecker
    will not flag it. Be extra careful when changing the type of a producer or consumer,
    because you will have to update all the other producers–consumers to match.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven architectures can make debugging harder. When stepping through
    code in a debugger, you will get to the code that produces an event, but when
    you step into the transport mechanism, you often are stepping into third-party
    code. In the worst case, the code that actually transports your events may be
    running in a different process, or even on a different machine. You may need multiple
    debuggers active (one per process or system) to properly debug event-driven architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, error handling becomes a little more difficult when using event-driven
    architectures. Most producers are decoupled from their consumers; when a consumer
    throws an exception or returns an error, it’s not always easy to handle it from
    the producer side.
  prefs: []
  type: TYPE_NORMAL
- en: As a thought experiment, consider what would happen if a producer produced an
    event and five consumers consumed it. If the third consumer that was notified
    threw an exception, what should happen? Should the other consumers get the exception,
    or should the execution stop in its tracks? Should the producer know about any
    error conditions, or should the errors get swallowed up? If the producer receives
    an exception, what happens if different consumers produce different exceptions?
    There is no one right answer to all of these questions; consult the tools you’re
    using for event-driven architectures to better understand what happens in these
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Despite these drawbacks, event-driven architectures are worthwhile in situations
    where you need to give your system much-needed flexibility. Future maintainers
    can replace your producers or consumers with minimal impact. They can bring in
    new producers and consumers to create new functionality. They can quickly integrate
    with external systems, opening the door for new partnerships. And best of all,
    they are working with small, modular systems that are easy to test in isolation
    and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest case for event-oriented architectures is dealing with *simple
    events* such as acting or alerting you when certain conditions change. Your producer
    of information is the one sending the event, and your consumer receives and acts
    upon the event. There are two typical ways of implementing this: with or without
    a message broker.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a Message Broker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A message broker is a specific piece of code that acts as a transport of data.
    Producers will publish data, known as a message, to a specific *topic* on the
    message broker. The topic is simply a unique identifier, such as a string. It
    could be something simple, like “orders,” or complex, like “sandwich order is
    finished.” It’s just a namespace that distinguishes one message channel from another.
    Consumers use the same identifier to *subscribe* to a topic. The message broker
    then sends the message to all consumers subscribed to the topic. This type of
    system is also known as *publisher/subscriber*, or pub/sub for short. [Figure 18-2](part0023_split_004.html#message_broker)
    shows a hypothetical pub/sub architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![ropy 1802](../images/00034.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-2\. A hypothetical message broker–based architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For this chapter, I will design the notification system for an automated drone
    delivery service for restaurants. When a customer order is cooked, the drone system
    kicks into action, picks up the order, and delivers the meal to the correct address.
    There are five notifications that happen in this system, and I’ve broken them
    down into producer–consumer in [Table 18-2](part0023_split_004.html#drone_notification_table).
  prefs: []
  type: TYPE_NORMAL
- en: Table 18-2\. Producers and consumers in the automated drone delivery system
  prefs: []
  type: TYPE_NORMAL
- en: '| Producer | Consumer |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Meal has finished cooking | Drone is notified for pickup |'
  prefs: []
  type: TYPE_TB
- en: '| Meal has finished cooking | Customer is notified that the meal is cooked
    |'
  prefs: []
  type: TYPE_TB
- en: '| Drone is en route | Customer is notified about an ETA |'
  prefs: []
  type: TYPE_TB
- en: '| Drone has delivered meal | Customer is notified about delivery |'
  prefs: []
  type: TYPE_TB
- en: '| Drone has delivered meal | Restaurant is notified about delivery |'
  prefs: []
  type: TYPE_TB
- en: I don’t want any of these systems to directly know about one another, as the
    code handling customers, drones, and restaurants should remain independent (they
    are maintained by separate teams and I want to keep physical dependencies low).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I will define the topics that exist in the system: a meal has finished
    cooking, the drone is en route, and the order is delivered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, I will use the Python library [PyPubSub](https://oreil.ly/8xLj7),
    which is a publish-subscribe API used in single-process applications. To use it,
    you need to set up code to subscribe to a topic and other code to publish to the
    topic. First, you need to install `pypubsub`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to subscribe to the topic, you specify the topic and the function you
    want to be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then to publish to this topic, you do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Subscribers operate in the same thread as the publisher, which means that any
    blocking I/O, such as waiting on a socket to be read, will block the publisher.
    This will affect all other subscribers and should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two pieces of code have no knowledge of each other; all they depend upon
    is the PyPubSub library as well as agreeing on the topic/message data. This makes
    it incredibly easy to add new subscribers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can’t get much more extensible. By defining topics that exist within the
    system, you can create new producers or consumers with the utmost ease. As your
    system needs to grow, you extend it by interacting with the existing messaging
    system.
  prefs: []
  type: TYPE_NORMAL
- en: PyPubSub also comes with a few options to help with debugging. You can add audit
    operations by adding your own functionality for things like new topics being created
    or a message being sent. You can add error handlers for any subscriber exception
    being thrown. You can also set up subscribers for *all* topics at once. If you
    would like to learn more about any of these features, or any other piece of functionality
    in PyPubSub, check out the [PyPubSub documentation](https://pypubsub.readthedocs.io).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: PyPubSub is meant for single-process applications; you cannot publish to code
    running in other processes or systems. Other applications can be used to provide
    this functionality, such as [Kafka](https://kafka.apache.org), [Redis](https://redis.io),
    or [RabbitMQ](https://www.rabbitmq.com). Check out each of these tool’s documentation
    to learn how to use them in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you don’t want to use a message broker, you can choose to implement the
    Observer Pattern.^([1](part0023_split_008.html#idm45644730197896)) With the Observer
    Pattern, your producer contains of a list of *observers*: the consumers in this
    scenario. The Observer Pattern does not need a separate library to act as a message
    broker.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid directly linking producers and consumers, you need to keep the knowledge
    of observers *generic*. In other words, keep any specific knowledge about the
    observers abstracted away. I will do this by just using functions (type annotated
    as a `Callable`). Here is how I would rewrite the previous example to use an Observer
    Pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the producer only knows about a list of functions to call to notify.
    To add new observers, you just need to add them to the list passed in as an argument.
    Furthermore, since this is just function calls, your typechecker will be able
    to detect when a producer or its observers change in an incompatible way, which
    is a huge benefit over the message broker paradigm. It is also easier to debug,
    as you don’t need to step through third-party message broker code in your debugger.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer Pattern above does have some drawbacks. First, you are a bit more
    sensitive to errors that crop up. If the observer throws an exception, the producer
    needs to be able to handle that directly (or use a helper function or class to
    handle the notification wrapped in a `try…except`). Second, the linking of producer
    to observer is more direct than in the message broker paradigm. In a message broker
    paradigm, the publisher and subscriber can become connected regardless of where
    they live in the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the Observer Pattern requires the caller of the notification (in
    the previous case, this was `complete_order`) to know about the observers. If
    the caller doesn’t know directly about the observers, then its caller needs to
    pass in the observers. This can continue all the way up the call stack until you
    are in a piece of code that directly knows about the observers. This can pollute
    a lot your function calls with extra parameters if there is a large gap between
    what knows about the observers and the actual code issuing the notification. If
    you find yourself passing observers through multiple functions to get to a producer
    deep in the call stack, consider using a message broker instead.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to go more in-depth into event-driven architectures with simple
    events, I recommend the book [*Architecture Patterns with Python*](https://oreil.ly/JPpdr)
    by Harry Percival and Bob Gregory (O’Reilly); its Part II is all about event-driven
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How would event-driven architecture improve the decoupling within your codebase?
    Would the Observer Pattern or a message broker be more suitable for your needs?
  prefs: []
  type: TYPE_NORMAL
- en: Streaming Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, simple events were each represented as a discrete
    event that happened when a certain condition was fulfilled. Message brokers and
    the Observer Pattern are great ways to handle simple events. However, some systems
    deal with a never-ending series of events. The events flow into the system as
    a continuous series of data known as a stream. Think about the drone systems described
    in the last section. Consider all the data that comes from each drone. There might
    be location data, battery levels, current speed, wind data, weather data, and
    current weight carried. This data will be coming in at regular intervals, and
    you need a way to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: In these sorts of use cases, you don’t want to build all the boilerplate of
    pub/sub or observers; you want an architecture that matches your use case. You
    need a programming model that centers on events and defines workflows for handling
    every single event. Enter reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: '*Reactive programming* is an architectural style that revolves around streams
    of events. You define data sources as producers of these streams, and then link
    together multiple observers. Each observer is notified whenever there is a change
    in data and defines a series of operations for handling the data stream. The reactive
    programming style was popularized by [ReactiveX](http://reactivex.io). In this
    section, I’ll use the Python implementation of ReactiveX: RxPY.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I will install RxPy with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: From there, I need to define a stream of data. In RxPY parlance, this is known
    as an *observable*. For example purposes, I’ll use a single hard-coded observable,
    but in practice, you will generate multiple observables from real data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This observable is generated from a list of events of different types for the
    drone data.
  prefs: []
  type: TYPE_NORMAL
- en: 'I next need to define what to do to process each event. Once I have an observable,
    observers can subscribe to it, in a similar manner to the pub/sub mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This doesn’t look too different from a normal pub/sub idiom.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real magic comes with *pipable* operators. RxPY allows you to *pipe*, or
    chain, operations together to produce a pipeline of filters, transformations,
    and calculations. For instance, I can write an operator pipeline with `rx.pipe`
    to grab the average weight the drone has carried:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, I could write a pipeline chain that tracks the drone’s maximum altitude
    once it’s left the restaurant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *lambda function* is just an inline function without a name. It is often used
    for functions that are only used once where you don’t want to place the definition
    of the function too far away from its use.
  prefs: []
  type: TYPE_NORMAL
- en: This is our old friend *composability* (as seen in [Chapter 17](part0022_split_000.html#composability))
    coming to our aid. I can compose different operators however I want to produce
    a datastream that matches my use case. RxPY has support for over one hundred built-in
    operators, as well as a framework for defining your own operators. You can even
    compose the results from one pipe into a new stream of events that other parts
    of the program can observe. This composability, paired with the decoupled nature
    of event subscription, gives you a large amount of flexibility in writing code.
    Furthermore, reactive programming encourages immutability, which greatly decreases
    the chance of bugs. You can hook up new pipes, compose operators together, handle
    data asynchronously, and more with a reactive framework like RxPY.
  prefs: []
  type: TYPE_NORMAL
- en: It also becomes easy to debug in isolation. While you can’t easily step through
    RxPY with a debugger (you’ll end up in a lot of complicated code related to operations
    and observables), you can instead step into the functions that you pass to operators.
    Testing is a breeze too. Since all the functions are meant to be immutable, you
    can test any of them on their own. You end up with a lot of small, single-purpose
    functions that are easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of model excels in systems that revolve around streams of data, such
    as data pipelines and extract, transform, load (ETL) systems. It is also incredibly
    useful in applications dominated by reactions to I/O events, such as server applications
    and GUI applications. If reactive programming fits your domain model, I encourage
    you to read the [RxPY documentation](https://rxpy.readthedocs.io/en/latest). If
    you’d like more structured learning, I recommend the video course [*Reactive Python
    for Data Science*](https://oreil.ly/Kr9At) or the book [*Hands-On Reactive Programming
    with Python: Event-Driven Development Unraveled with RxPY*](https://oreil.ly/JCuf6)
    by Romain Picard (O’Reilly).'
  prefs: []
  type: TYPE_NORMAL
- en: Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event-driven architectures are incredibly powerful. An event-driven architecture
    allows you to separate producers and consumers of information. By decoupling the
    two, you introduce flexibility into your system. You can replace functionality,
    test your code in isolation, or extend new functionality by introducing new producers
    or consumers.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to architect an event-driven system. You can choose to stay
    with simple events and the Observer Pattern for lightweight events in your system.
    As you scale up, you may need to introduce a message broker, such as with PyPubSub.
    You may even need to use another library as a message broker if you want to scale
    across processes or systems. Finally, as you approach streams of events, you can
    consider a reactive programming framework, such as RxPY.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, I will cover a different type of architectural paradigm:
    plug-in architectures. Plug-in architectures offer similar flexibility, composability,
    and extensibility to event-driven architectures, but in a completely different
    way. Whereas event-driven architectures focus on events, plug-in architecture
    focuses on pluggable units of implementation. You’ll see how plug-in architectures
    can give you plenty of options to build a robust codebase that is easy to maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](part0023_split_005.html#idm45644730197896-marker)) The Observer Pattern
    is first described in *Design Patterns: Elements of Reusable Object-Oriented Software*
    by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley
    Professional). This book is colloquially known as the “Gang of Four (GoF)” book.'
  prefs: []
  type: TYPE_NORMAL
