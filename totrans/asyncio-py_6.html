<html><head></head><body><section data-type="appendix" epub:type="appendix" data-pdf-bookmark="Appendix A. A Short History of Async Support in Python"><div class="appendix" id="idm46363041117176">
<h1><span class="label">Appendix A. </span>A Short History of Async Support in Python</h1>

<blockquote>
<p>Despite having been part of the Python standard library for a long
time, the asyncore module suffers from fundamental flaws following
from an inflexible API that does not stand up to the expectations of a
modern asynchronous networking module.</p>

<p>Moreover, its approach is too simplistic to provide developers with
all the tools they need in order to fully exploit the potential of
asynchronous networking.</p>

<p>The most popular solution right now used in production involves the
use of third-party libraries. These often provide satisfactory
solutions, but there is a lack of compatibility between these
libraries, which tends to make codebases very tightly coupled to the
library they use.</p>

<p data-type="attribution">Laurens van Houtven, <a href="https://oreil.ly/pNyro">PEP 3153 (May 2011): Asynchronous IO Support</a></p>
</blockquote>

<p>The goal of<a data-type="indexterm" data-primary="async support in Python, short history of" id="ix_asyncsup"/> this appendix is to describe a little of the history behind
async programming in Python, and the point I want to make—which still
amazes me when I think about it—is that the key innovation that we’ve
been awaiting for 20 years was <em>language syntax</em>.<a data-type="indexterm" data-primary="Python" data-secondary="short history of async support in" id="ix_Pyasync"/><a data-type="indexterm" data-primary="van Houtven, Laurens" id="idm46363039348088"/></p>

<p>Many people will be surprised by this, but Asyncio is <em>not</em> the first
attempt that has been made to add support for asynchronous network programming to Python,
as is discussed next.<a data-type="indexterm" data-primary="async support in Python, short history of" data-secondary="asyncore" id="idm46363039346472"/><a data-type="indexterm" data-primary="asyncore library" id="idm46363039345528"/></p>






<section data-type="sect1" data-pdf-bookmark="In the Beginning, There Was asyncore"><div class="sect1" id="idm46363039344728">
<h1>In the Beginning, There Was asyncore</h1>
<blockquote>
<p>[Compared to asyncore,] Twisted is better in pretty much every possible way.
It’s more portable, more featureful, simpler, more scalable, better
maintained, better documented, and it can make a delicious omelette.
Asyncore is, for all intents and purposes, obsolete.</p>

<p data-type="attribution">Glyph ca. 2010 on <a href="https://oreil.ly/4pEeJ">Stack Overflow</a></p>
</blockquote>
<blockquote>
<p class="pagebreak-before">asyncore should really be considered a historical artifact and never actually used.</p>

<p data-type="attribution">Jean-Paul Calderone ca. 2013 on <a href="https://oreil.ly/oWGEZ">Stack Overflow</a></p>
</blockquote>

<p>Support for so-called <em>asynchronous features</em> was added to Python a
long time ago, in the <code>asyncore</code> module. As you can tell from the
preceding quotes, reception of <code>asyncore</code> was lukewarm, and usage low. What
is jaw-dropping, to this author at least, is <em>when</em> this module was added: in
Python 1.5.2! This is what it says at the top of <em>Lib/asyncore.py</em> in
the CPython source:<a data-type="indexterm" data-primary="Twisted" data-secondary="asyncore and" id="idm46363039336456"/></p>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># -*- Mode: Python -*-</code>
<code class="c1">#   Id: asyncore.py,v 2.51 2000/09/07 22:29:26 rushing Exp</code>
<code class="c1">#   Author: Sam Rushing &lt;rushing@nightmare.com&gt;</code>

<code class="c1"># =============================================================</code>
<code class="c1"># Copyright 1996 by Sam Rushing</code></pre>

<p>Furthermore, the first paragraph of the Python <a href="https://oreil.ly/tPp8_">documentation for <code>asyncore</code></a>
says the following, which could easily appear in <em>today’s</em> documentation
for <code>asyncio</code>:</p>
<blockquote>
<p>This module provides the basic infrastructure for writing asynchronous
socket service clients and servers.</p>

<p>There are only two ways to have a program on a single processor do
“more than one thing at a time.” Multithreaded programming is the
simplest and most popular way to do it, but there is another very
different technique, that lets you have nearly all the advantages of
multithreading, without actually using multiple threads. It’s really
only practical if your program is largely I/O bound. If your program is
processor bound, then preemptive scheduled threads are probably what
you really need. Network servers are rarely processor bound, however.</p></blockquote>

<p>1996, huh? Clearly it was already possible to manage multiple socket events
in a single thread in Python back then (and, in fact, much earlier than this in
other languages). So what has changed in the past quarter-century that makes
Asyncio special now?</p>

<p>The answer is language syntax. We’re going to be looking at this more
closely in the next section, but before closing out this window into the
past, it’s worth noting a small detail that appeared in the Python 3.6
docs for <code>asyncore</code> (ca. December 2016):</p>
<blockquote>
<p>Source code: Lib/asyncore.py</p>

<p><em>Deprecated since version 3.6</em>: Please use <code>asyncio</code> instead.</p></blockquote>
</div></section>













<section data-type="sect1" data-pdf-bookmark="The Path to Native Coroutines"><div class="sect1" id="idm46363039344184">
<h1>The Path to Native Coroutines</h1>

<p>Recall that I’m using the term <em>Asyncio</em> to refer to both the Python
language <a data-type="indexterm" data-primary="async support in Python, short history of" data-secondary="path to native coroutines" id="idm46363039325848"/><a data-type="indexterm" data-primary="native coroutines" data-secondary="path to" id="idm46363039324936"/><a data-type="indexterm" data-primary="coroutines" data-secondary="native" data-tertiary="path to" id="idm46363039323992"/>syntax changes, and the new <code>asyncio</code> module in the
standard library.<sup><a data-type="noteref" id="idm46363039318328-marker" href="app01.html#idm46363039318328">1</a></sup> Let’s
dig into that distinction a little more.</p>

<p>Today, support for asynchronous programming in Python has three
distinct components, and it’s interesting to consider when they were added:</p>
<dl>
<dt>Language syntax: generators</dt>
<dd>
<p>Keyword <code>yield</code>, added<a data-type="indexterm" data-primary="yield keyword" id="idm46363039314568"/><a data-type="indexterm" data-primary="generators" id="idm46363039313832"/> in Python 2.2 (2001) in
   <a href="https://oreil.ly/35Czp">PEP 255</a> and
   enhanced in Python 2.5 (2005) in
   <a href="https://oreil.ly/UDWl_">PEP 342</a> with the
   <code>send()</code> and <code>throw()</code> methods on generator objects, which allowed
   generators to be used as coroutines for the first time.</p>

<p>Keyword <code>yield from</code>, added in Python 3.3 (2009) in
   <a href="https://oreil.ly/38jVG">PEP 380</a> to make it
   much easier <a data-type="indexterm" data-primary="yield from statements" id="idm46363039309256"/><a data-type="indexterm" data-primary="nested yields of generators" id="idm46363039308552"/>to work with <em>nested</em> yields of generators, particularly
   in the case where generators are being used as
   makeshift (i.e., temporary) coroutines.</p>
</dd>
<dt>Language syntax: coroutines</dt>
<dd>
<p>Keywords <code>async</code> and <code>await</code>, added in Python 3.5 (2015) in
   <a href="https://oreil.ly/XJUmS">PEP 492</a>, which gave
   first-class support to coroutines<a data-type="indexterm" data-primary="coroutines" data-secondary="async and await keywords" id="idm46363039283240"/><a data-type="indexterm" data-primary="async keyword" id="idm46363039282296"/><a data-type="indexterm" data-primary="await keyword" id="idm46363039281624"/> as a language feature in their
   own right. This also means that generators can again be used
   as generators, even inside coroutine functions.</p>
</dd>
<dt>Library module: <code>asyncio</code></dt>
<dd>
<p>Added in Python 3.4 (2012) in
  <a href="https://oreil.ly/QKG4m">PEP 3156</a>, providing
  batteries-included support for both framework designers and end-user developers<a data-type="indexterm" data-primary="asyncio" data-secondary="library module" id="idm46363039278424"/>
  to work with coroutines and perform network I/O. Crucially, the
  design of the event loop in <code>asyncio</code> was intended to provide a common
  base upon which other existing third-party frameworks like
  Tornado and Twisted could standardize.</p>
</dd>
</dl>

<p>These three are quite distinct from each other, although you could be
forgiven confusion since the history of the development of these
features in Python has been difficult to follow.</p>

<p>The impact of new syntax for <code>async</code> and <code>await</code> is significant, and
it’s having an effect on other programming languages too, like JavaScript,
C#, Scala, Kotlin, and Dart.</p>

<p>It took a long time and a lot of thinking by the thousands of programmers
involved in the Python project to get us to this point.<a data-type="indexterm" data-primary="Python" data-secondary="short history of async support in" data-startref="ix_Pyasync" id="idm46363039273960"/><a data-type="indexterm" data-primary="async support in Python, short history of" data-startref="ix_asyncsup" id="idm46363039272744"/></p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46363039318328"><sup><a href="app01.html#idm46363039318328-marker">1</a></sup> <code>asyncio</code> was added in Python 3.4.</p></div></div></section></body></html>