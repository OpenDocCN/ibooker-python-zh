- en: Chapter 15\. Crawling Through APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has traditionally been the bane of web crawlers everywhere. At one
    point in the ancient history of the internet, you could be guaranteed that a request
    for an HTML page made to the web server would represent the same HTML website
    you would see in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'As JavaScript and Ajax content generation and loading become more ubiquitous,
    that situation is becoming less common. In [Chapter 14](ch14.html#c-14), you looked
    at one way of solving this: using Selenium to automate a browser and fetch the
    data. This is an easy thing to do. It works almost all of the time.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that, when you have a “hammer” as powerful and effective as Selenium,
    every web scraping problem starts to look a lot like a nail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll look at cutting through the JavaScript entirely (no
    need to execute it or even load it!) and getting straight to the source of the
    data: the APIs that generate it.'
  prefs: []
  type: TYPE_NORMAL
- en: A Brief Introduction to APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although countless books, talks, and guides have been written about the intricacies
    of REST, GraphQL, JSON, and XML APIs, at their core they are based on a simple
    concept. An *API*, or Application Programming Interface, defines a standardized
    syntax that allows one piece of software to communicate with another piece of
    software, even though they might be written in different languages or otherwise
    structured differently.
  prefs: []
  type: TYPE_NORMAL
- en: This section focuses on web APIs (in particular, APIs that allow a web server
    to communicate to a browser) and uses the term *API* to refer specifically to
    that type. But you may want to keep in mind that, in other contexts, *API* is
    also a generic term that can be used to, say, allow a Java program to communicate
    with a Python program running on the same machine. An API does not always have
    to be “across the internet” and does not necessarily involve any web technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Web APIs are most often used by developers who are using a well-advertised and
    documented public service. For example, the US National Weather Service provides
    a [weather API](https://www.weather.gov/documentation/services-web-api) that gives
    current weather data and forecasts for any location. Google has dozens of APIs
    in its [Developers section](https://console.developers.google.com) for language
    translations, analytics, and geolocation.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation for these APIs typically describes routes or *endpoints*,
    as URLs that you can request, with variable parameters, either in the path of
    the URL or as `GET` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following provides `pathparam` as a parameter in the route
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And this provides `pathparam` as the value for the parameter `param1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Both methods of passing variable data to the API are frequently used, although,
    like many topics in computer science, philosophic debate has raged on when and
    where variables should be passed through the path or through the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The response from the API is usually returned in a JSON or XML format. JSON
    is far more popular in modern times than XML, but you may still see some XML responses.
    Many APIs allow you to change the response type, using another parameter to define
    which type of response you would like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a JSON-formatted API response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of an XML-formatted API response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[ip-api.com](http://ip-api.com) provides an easy-to-use and simple API that
    translates IP addresses to actual physical addresses. You can try a simple API
    request by entering the following in your browser:^([1](ch15.html#id773))'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce a response like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the request contains the parameter `json` in the path. You can
    request an XML or CSV response by changing this parameter accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: HTTP Methods and APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, you looked at APIs making a `GET` request to the server
    for information. There are four main ways (or *methods*) to request information
    from a web server via HTTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `GET` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `POST` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `PUT` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `DELETE` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technically, more than these four exist (such as `HEAD`, `OPTIONS`, and `CONNECT`),
    but they are rarely used in APIs, and it is unlikely that you will ever see them.
    The vast majority of APIs limit themselves to these four methods or even a subset
    of these four methods. It is common to see APIs that use only `GET`, or use only
    `GET` and `POST`.
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` is what you use when you visit a website through the address bar in your
    browser. `GET` is the method you are using when you make a call to [*http://ip-api.com/json/50.78.253.58*](http://ip-api.com/json/50.78.253.58).
    You can think of `GET` as saying, “Hey, web server, please retrieve/get me this
    information.”'
  prefs: []
  type: TYPE_NORMAL
- en: A `GET` request, by definition, makes no changes to the information in the server’s
    database. Nothing is stored; nothing is modified. Information is only read.
  prefs: []
  type: TYPE_NORMAL
- en: '`POST` is what you use when you fill out a form or submit information, presumably
    to a backend script on the server. Every time you log in to a website, you are
    making a `POST` request with your username and (hopefully) encrypted password.
    If you are making a `POST` request with an API, you are saying, “Please store
    this information in your database.”'
  prefs: []
  type: TYPE_NORMAL
- en: '`PUT` is less commonly used when interacting with websites but is used from
    time to time in APIs. A `PUT` request is used to update an object or information.
    An API might require a `POST` request to create a new user, for example, but it
    might need a `PUT` request if you want to update that user’s email address.^([2](ch15.html#id776))'
  prefs: []
  type: TYPE_NORMAL
- en: '`DELETE` is used, as you might imagine, to delete an object. For instance,
    if you send a `DELETE` request to *http://example.com/user/23*, it will delete
    the user with the ID 23. `DELETE` methods are not often encountered in public
    APIs, which are primarily created to disseminate information or allow users to
    create or post information, rather than allow users to remove that information
    from their databases.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `GET` requests, `POST`, `PUT`, and `DELETE` requests allow you to send
    information in the body of a request, in addition to the URL or route from which
    you are requesting data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the response that you receive from the web server, this data in the
    body is typically formatted as JSON or, less commonly, as XML, and the format
    of this data is defined by the syntax of the API. For example, if you are using
    an API that creates comments on blog posts, you might make a `PUT` request to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'with the following request body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that the ID of the blog post (`123`) is passed as a parameter in the URL,
    where the content for the new comment you are making is passed in the body of
    the request. Parameters and data may be passed in both the parameter and the body.
    Which parameters are required and where they are passed is determined, again,
    by the syntax of the API.
  prefs: []
  type: TYPE_NORMAL
- en: More About API Responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you saw in the ip-api.com example at the beginning of the chapter, an important
    feature of APIs is that they have well-formatted responses. The most common types
    of response formatting are *eXtensible Markup Language* (XML) and *JavaScript
    Object Notation* (JSON).
  prefs: []
  type: TYPE_NORMAL
- en: 'In recent years, JSON has become vastly more popular than XML for a couple
    of major reasons. First, JSON files are generally smaller than well-designed XML
    files. Compare, for example, the following XML data, which clocks in at 98 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And now look at the same data in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is only 73 characters, or a whopping 36% smaller than the equivalent XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, one could argue that the XML could be formatted like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But this is considered bad practice because it doesn’t support deep nesting
    of data. Regardless, it still requires 71 characters, about the same length as
    the equivalent JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason JSON is quickly becoming more popular than XML is due to a shift
    in web technologies. In the past, it was more common for a server-side script
    such as PHP or .NET to be on the receiving end of an API. Nowadays, it is likely
    that a framework, such as Angular or Backbone, will be sending and receiving API
    calls. Server-side technologies are somewhat agnostic as to the form in which
    their data comes. But JavaScript libraries like Backbone find JSON easier to handle.
  prefs: []
  type: TYPE_NORMAL
- en: Although APIs are typically thought of as having either an XML response or a
    JSON response, anything is possible. The response type of the API is limited only
    by the imagination of the programmer who created it. CSV is another typical response
    output (as seen in the ip-api.com example). Some APIs may even be designed to
    generate files. A request may be made to a server to generate an image with some
    particular text overlaid on it or to request a particular XLSX or PDF file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some APIs return no response at all. For example, if you are making a request
    to a server to create a new blog post comment, it may return only an HTTP response
    code 200, meaning “I posted the comment; everything is great!” Others may return
    a minimal response like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If an error occurs, you may get a response like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Or if the API is not particularly well configured, you may get a nonparsable
    stack trace or some plain English text. When making a request to an API, it’s
    usually wise to first check that the response you get is actually JSON (or XML,
    or CSV, or whatever format you’re expecting back).
  prefs: []
  type: TYPE_NORMAL
- en: Parsing JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ve looked at various types of APIs and how they function,
    and you’ve looked at sample JSON responses from these APIs. Now let’s look at
    how to parse and use this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of the chapter you saw the example of the ip-api.com  API,
    which resolves IP addresses to physical addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can take the output of this request and use Python’s JSON-parsing functions
    to decode it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This prints the country code for the IP address 50.78.253.58.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON parsing library used is part of Python’s core library. Just type in
    `import json` at the top, and you’re all set! Unlike many languages that might
    parse JSON into a special JSON object or JSON node, Python uses a more flexible
    approach and turns JSON objects into dictionaries, JSON arrays into lists, JSON
    strings into strings, and so forth. In this way, it is extremely easy to access
    and manipulate values stored in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following gives a quick demonstration of how Python’s JSON library handles
    the values that might be encountered in a JSON string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Line 1 is a list of dictionary objects, line 2 is a dictionary object, line
    3 is an integer (the sum of the integers accessed in the dictionaries), and line
    4 is a string.
  prefs: []
  type: TYPE_NORMAL
- en: Undocumented APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we’ve discussed only APIs that are documented. Their
    developers intend them to be used by the public, publish information about them,
    and assume that the APIs will be used by other developers. But the vast majority
    of APIs don’t have any published documentation at all.
  prefs: []
  type: TYPE_NORMAL
- en: But why would you create an API without any public documentation? As mentioned
    in the beginning of this chapter, it all has to do with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, the web servers for dynamic websites had several tasks whenever
    a user requested a page:'
  prefs: []
  type: TYPE_NORMAL
- en: Handle `GET` requests from users requesting a page of a website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the data from the database that appears on that page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Format the data into the HTML template for the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send that formatted HTML to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As JavaScript frameworks became more ubiquitous, many of the HTML creation tasks
    handled by the server moved into the browser. The server might send a hardcoded
    HTML template to the user’s browser, but separate Ajax requests would be made
    to load the content and place it in the correct slots in that HTML template. All
    this would happen on the browser/client side.
  prefs: []
  type: TYPE_NORMAL
- en: This was initially a problem for web scrapers. They were accustomed to making
    a request for an HTML page and getting back exactly that—an HTML page with all
    of the content already in place. Instead, they now got an HTML template without
    any content.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium was used to solve this problem. Now the programmer’s web scraper could
    become the browser, request the HTML template, execute any JavaScript, allow all
    the data to load in its place, and only *then* scrape the page for data. Because
    the HTML was all loaded, it was essentially reduced to a previously solved problem—the
    problem of parsing and formatting existing HTML.
  prefs: []
  type: TYPE_NORMAL
- en: However, because the entire content management system (that used to reside only
    in the web server) had essentially moved to the browser client, even the simplest
    websites could balloon into several megabytes of content and a dozen HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, when Selenium is used, all of the “extras” that the user doesn’t
    necessarily care about are loaded: calls to tracking programs, loading sidebar
    ads, calls to tracking programs for the sidebar ads. Images, CSS, third-party
    font data—all of it needs to be loaded. This may seem great when you’re using
    a browser to browse the web, but if you’re writing a web scraper that needs to
    move fast, collect specific data, and place the lowest possible load on the web
    server, you can be loading a hundred times more data than you need.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s a silver lining to all of this JavaScript, Ajax, and web modernization:
    because servers are no longer formatting the data into HTML, they often act as
    thin wrappers around the database itself. This thin wrapper simply extracts data
    from the database and returns it to the page via an API.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, these APIs aren’t meant to be used by anyone or anything besides
    the web page itself, and so developers leave them undocumented and assume (or
    hope) that no one will notice them. But they do exist.
  prefs: []
  type: TYPE_NORMAL
- en: The American retail giant target.com, for example, loads all of its search results
    via JSON. You can search for a product on their site by visiting [*https://www.target.com/s?searchTerm=web%20scraping%20with%20python*](https://www.target.com/s?searchTerm=web%20scraping%20with%20python).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you scrape this page using urllib or the Requests library, you won’t find
    any search results. These are loaded separately via an API call to the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Because Target’s API requires a key for each request, and those API keys time
    out, I recommend that you try this out yourself and see the JSON results.
  prefs: []
  type: TYPE_NORMAL
- en: You could, of course, use Selenium to load all the search results and parse
    the resulting HTML. However, you would be making about 260 requests and transferring
    megabytes of data with each search. Using the API directly, you make only one
    request and transfer approximately only the 10 kb of nicely formatted data that
    you need.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Undocumented APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve used the Chrome inspector in previous chapters to examine the contents
    of an HTML page, but now you’ll use it for a slightly different purpose: to examine
    the requests and responses of the calls that are used to construct that page.'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, open the Chrome inspector window and click the Network tab, shown
    in [Figure 15-1](#chromeinspect).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/wsp3_1501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-1\. The Chrome network inspector tool provides a view into all calls
    your browser is making and receiving
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that you need to open this window before the page loads. It does not track
    network calls while it’s closed.
  prefs: []
  type: TYPE_NORMAL
- en: While the page is loading, you’ll see a line appear in real time whenever your
    browser makes a call back to the web server for additional information to render
    the page. This may include an API call.
  prefs: []
  type: TYPE_NORMAL
- en: Finding undocumented APIs can take a little detective work (to take the detective
    work out of this, see [“Documenting Undocumented APIs”](#documenting_undocumented_apis)),
    especially with larger sites with lots of network calls. Generally, though, you’ll
    know it when you see it.
  prefs: []
  type: TYPE_NORMAL
- en: 'API calls tend to have several features that are useful for locating them in
    the list of network calls:'
  prefs: []
  type: TYPE_NORMAL
- en: They often have JSON or XML in them. You can filter the list of requests by
    using the search/filter field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `GET` requests, the URL will contain the parameter values passed to them.
    This will be useful if, for example, you’re looking for an API call that returns
    the results of a search or is loading data for a specific page. Simply filter
    the results with the search term you used, page ID, or other identifying information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They will usually be of the type XHR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs may not always be obvious, especially in large sites with lots of features
    that may make hundreds of calls while loading a single page. However, spotting
    the metaphorical needle in the haystack becomes much easier with a little practice.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting Undocumented APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After you’ve found an API call being made, it’s often useful to document it
    to some extent, especially if your scrapers will rely heavily on the call. You
    may want to load several pages on the website, filtering for the target API call
    in the inspector console Network tab. By doing this, you can see how the call
    changes from page to page and identify the fields that it accepts and returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every API call can be identified and documented by paying attention to the
    following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP method used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Path parameters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Headers (including cookies)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Body content (for `PUT` and `POST` calls)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Response headers (including cookies set)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Response body type
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Response body fields
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining APIs with Other Data Sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the raison d'être of many modern web applications is to take existing
    data and format it in a more appealing way, I would argue that this isn’t an interesting
    thing to do in most instances. If you’re using an API as your only data source,
    the best you can do is merely copy someone else’s database that already exists
    and which is, essentially, already published. What can be far more interesting
    is to take two or more data sources and combine them in a novel way or use an
    API as a tool to look at scraped data from a new perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at one example of how data from APIs can be used in conjunction with
    web scraping to see which parts of the world contribute the most to Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve spent much time on Wikipedia, you’ve likely come across an article’s
    revision history page, which displays a list of recent edits. If users are logged
    in to Wikipedia when they make the edit, their username is displayed. If they
    are not logged in, their IP address is recorded, as shown in [Figure 15-2](#wiki_history).
  prefs: []
  type: TYPE_NORMAL
- en: '![Alt Text](assets/wsp3_1502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-2\. The IP address of an anonymous editor on the revision history
    page for Wikipedia’s Python entry
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The IP address provided on the history page is 121.97.110.145\. By using the
    ip-api.com API, that IP address is from Quezon, Philippines, as of this writing
    (IP addresses can occasionally shift geographically).
  prefs: []
  type: TYPE_NORMAL
- en: This information isn’t all that interesting on its own, but what if you could
    gather many points of geographic data about Wikipedia edits and where they occur?
    A few years ago, I did just that and used [Google’s GeoChart library](https://developers.google.com/chart/interactive/docs/gallery/geochart)
    to create an [interesting chart](http://www.pythonscraping.com/pages/wikipedia.html)
    that shows the origins of edits to the English-language Wikipedia, as well as
    the Wikipedias written in other languages ([Figure 15-3](#geochart_library)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Alt Text](assets/wsp3_1503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-3\. Visualization of Wikipedia edits created using Google’s GeoChart
    library
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Creating a basic script that crawls Wikipedia, looks for revision history pages,
    and then looks for IP addresses on those revision history pages isn’t difficult.
    Using modified code from [Chapter 6](ch06.html#c-6), the following script does
    just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This program uses two main functions: `getLinks` (which was also used in [Chapter 6](ch06.html#c-6)),
    and the  new `getHistoryIPs`, which searches for the contents of all links with
    the class `mw-anonuserlink` (indicating an anonymous user with an IP address,
    rather than a username) and returns it as a set.'
  prefs: []
  type: TYPE_NORMAL
- en: This code also uses a somewhat arbitrary (yet effective for the purposes of
    this example) search pattern to look for articles from which to retrieve revision
    histories. It starts by retrieving the histories of all Wikipedia articles linked
    to by the starting page (in this case, the article on the Python programming language).
    Afterward, it randomly selects a new starting page and retrieves all revision
    history pages of articles linked to by that page. It will continue until it hits
    a page with no links.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have code that retrieves IP addresses as a string, you can combine
    this with the `getCountry` function from the previous section to resolve these
    IP addresses to countries. You’ll modify `getCountry` slightly to account for
    invalid or malformed IP addresses that result in a 404 Not Found error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: More About APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has shown a few ways that modern APIs are commonly used to access
    data on the web, and how those APIs can be used to build faster and more powerful
    web scrapers. If you’re looking to build APIs instead of just using them, or if
    you want to learn more about the theory of their construction and syntax, I recommend [*RESTful
    Web APIs*](http://bit.ly/RESTful-Web-APIs) by Leonard Richardson, Mike Amundsen,
    and Sam Ruby (O’Reilly). This book provides a strong overview of the theory and
    practice of using APIs on the web. In addition, Mike Amundsen has a fascinating
    video series, [*Designing APIs for the Web*](http://oreil.ly/1GOXNhE) (O’Reilly),
    that teaches you how to create your own APIs—a useful thing to know if you decide
    to make your scraped data available to the public in a convenient format.
  prefs: []
  type: TYPE_NORMAL
- en: While some might bemoan the ubiquity of JavaScript and dynamic websites, making
    traditional “grab and parse the HTML page” practices outdated, I, for one, welcome
    our new robot overlords. As dynamic websites rely less on HTML pages for human
    consumption and more on strictly formatted JSON files for HTML consumption, this
    provides a boon for everyone trying to get clean, well-formatted data.
  prefs: []
  type: TYPE_NORMAL
- en: The web is no longer a collection of HTML pages with occasional multimedia and
    CSS adornments. It’s a collection of hundreds of file types and data formats,
    whizzing hundreds at a time to form the pages that you consume through your browser.
    The real trick is often to look beyond the page in front of you and grab the data
    at its source.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch15.html#id773-marker)) This API resolves IP addresses to geographic
    locations and is one you’ll be using later in the chapter as well.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch15.html#id776-marker)) In reality, many APIs use `POST` requests in
    lieu of `PUT` requests when updating information. Whether a new entity is created
    or an old one is merely updated is often left to how the API request itself is
    structured. However, it’s still good to know the difference, and you will often
    encounter `PUT` requests in commonly used APIs.
  prefs: []
  type: TYPE_NORMAL
