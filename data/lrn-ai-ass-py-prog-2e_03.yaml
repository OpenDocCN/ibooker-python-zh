- en: '4 Reading Python code: Part 1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 阅读 Python 代码：第一部分
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章内容包括
- en: Why knowing how to read code is important
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么知道如何阅读代码很重要
- en: How to ask Copilot to explain code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何让 Copilot 解释代码
- en: Using functions to break down large problems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数分解大问题
- en: Using variables to hang on to values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量保存值
- en: Using if-statements to make decisions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 if 语句进行决策
- en: Using strings to store and manipulate text
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符串存储和操作文本
- en: Using lists to collect and manipulate many values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表收集和操作多个值
- en: In chapter 3, we used Copilot to write several functions for us. What are they
    good for? Maybe our `money_made` function could be part of a stock trading system,
    our `is_strong_password` function could be used as part of a social networking
    website, or our `best_word` function could be used as part of some Scrabble AI.
    Overall, we’ve written some useful functions that could be part of larger programs.
    And, we did this without writing much code ourselves or, indeed, understanding
    what the code even does.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章中，我们让 Copilot 为我们写了几个函数。它们的作用是什么？也许我们的 `money_made` 函数可以成为股票交易系统的一部分，`is_strong_password`
    函数可以用在社交网络网站上，或者 `best_word` 函数可以用在某个拼字游戏 AI 中。总的来说，我们编写了一些有用的函数，它们可以成为更大程序的一部分。而且，我们几乎没有自己写很多代码，甚至没有理解这些代码到底在做什么。
- en: 'However, we believe that you need to understand at a high level what code does.
    Because this will require some time to learn, we’ve split this discussion over
    two chapters. In this chapter, we’ll explain why reading code is important and
    introduce you to a Copilot feature that can help you understand the code. After
    that, we’ll dive into the top 10 programming features you’ll need to recognize
    to read most basic code produced by Copilot. We’ll do the first five in this chapter
    and the remaining five in the next chapter. Don’t worry: you’ve actually been
    informally introduced to all 10 already—we’re just going to deepen your understanding
    of each one.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们认为你需要从高层次理解代码的作用。因为这需要一些时间来学习，我们将这一讨论分成了两章。在这一章中，我们将解释为什么阅读代码很重要，并向你介绍
    Copilot 的一个功能，帮助你理解代码。之后，我们将深入介绍你需要识别的 10 个编程特性，这些特性帮助你阅读 Copilot 生成的大部分基础代码。我们将在本章讲解前五个，剩下的五个将在下一章介绍。别担心：实际上你已经非正式地接触过这
    10 个特性——我们只是要加深你对每个特性的理解。
- en: 4.1 Why we need to read code
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 为什么我们需要阅读代码
- en: When we talk about reading code, what we mean is understanding what code does
    by looking at it. There are two such levels of understanding, and they’re both
    important.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论阅读代码时，我们指的是通过查看代码来理解它的作用。理解有两个层次，这两个层次都很重要。
- en: The first level is being able to understand, line by line, what a program will
    do. This often involves tracing the values of variables as the code runs to determine
    exactly what the code is doing at each step. This is useful, but isn’t the whole
    story. It’s like following a cooking recipe step-by-step without knowing what
    the recipe is making or how its ingredients fit together. At the end, you might
    have a cake, but you might not be able to grasp why the cake turned out so well
    or how you could come up with such a recipe yourself. You need to understand why
    the recipe, as a whole, is effective.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个层次是能够逐行理解一个程序的功能。这通常需要跟踪代码执行时变量的值，以确定代码在每一步到底做了什么。这很有用，但并不是全部内容。它就像一步一步地跟着食谱做菜，却不知道食谱要做什么，或者这些食材是如何配合的。最后，你可能做出了一个蛋糕，但你可能不理解为什么蛋糕做得那么好，或者你怎么能自己编出这样一个食谱。你需要了解整个食谱为何有效。
- en: 'So, that’s the second level: determining the overall purpose of a program.
    That is, you need to be able to zoom out, away from each line, and understand
    what the program is doing at a high level.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，第二个层次就是：确定程序的整体目的。也就是说，你需要能够从每一行代码中抽身出来，从高层次理解程序在做什么。
- en: At the end of these two chapters, we want you to be able to begin to understand
    code from Copilot at both of these levels. We’ll start focusing on that line-by-line
    understanding, but toward the end of this chapter and through the rest of the
    book, you’ll start being able to look at a small chunk of code and determine its
    overall purpose.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两章结束时，我们希望你能够从这两个层面开始理解 Copilot 生成的代码。我们将从逐行理解代码开始，但在本章结束时和本书剩余部分，你将开始能够查看一小段代码并判断它的整体目的。
- en: We can illustrate the difference between the two levels of reading code by referring
    back to our `best_word` function from chapter 3, reprinted in the following listing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过参考我们第三章的`best_word`函数来说明阅读代码的两个级别之间的区别，在以下列表中重新列出。
- en: Listing 4.1 `best_word` function for Scrabble
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1 Scrabble的`best_word`函数
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A *tracing description* of what this program does is a description of each line.
    For example, we would say that we’re defining a function called `best_word` that
    takes one parameter called `word_list`. We have a variable called `best_word`
    that we start off as a string with no characters, otherwise known as the empty
    string. (It’s unfortunate that the function and this variable are both called
    `best_word` because it makes it trickier to refer to one or the other, but that’s
    what Copilot gave us.) We also have another variable, `best_points`, that we start
    at `0`. Then, we have a `for` loop over each word in the `word_list`. Inside the
    `for` loop, we call our `num_points` helper function and store its return value
    in the points variable, and so on. (We’ll explain how we know what each line of
    code does over this chapter and the next.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的*追踪描述*是对每行代码做的描述。例如，我们会说我们正在定义一个名为`best_word`的函数，该函数接受一个名为`word_list`的参数。我们有一个称为`best_word`的变量，它最初是一个没有字符的字符串，也就是空字符串。（不幸的是，函数和此变量都称为`best_word`，因为这使得引用其中一个或另一个变得更加棘手，但这是Copilot给我们的。）我们还有另一个名为`best_points`的变量，我们从`0`开始。然后，我们在`word_list`中的每个单词上都有一个`for`循环。在`for`循环内部，我们调用我们的`num_points`辅助函数，并将其返回值存储在points变量中，等等。（我们将在本章和下一章解释我们如何知道每行代码的作用。）
- en: 'In contrast, a *description of the overall purpose* would be something like
    our docstring description: “Return the word with the highest Scrabble point value
    from a list of words.” Rather than refer to each line, this description refers
    to the code’s purpose as a whole, explaining what it does at a high level.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，*总体目的的描述*将类似于我们的文档字符串描述：“从单词列表中返回具有最高Scrabble点值的单词。”而不是参考每一行，此描述在高层次上解释了代码的目的，说明它作为一个整体的功能。
- en: 'You’ll come to an overall-purpose level of understanding through a combination
    of practice with tracing and testing, and we hope you arrive there in full glory
    by the end of the book. Working at a tracing level generally precedes the ability
    to work at an overall-purpose level [1], so in this chapter and the next, we’re
    going to focus on the tracing level by understanding what each line of code does.
    There are three reasons why we want you to be able to read code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过追踪和测试的结合实践，您将达到一个总体目标水平的理解，并希望您能在本书结束时以完整的荣耀达到那里。在追踪级别上的工作通常先于在总体目标级别上的工作能力[1]，因此在本章和下一章中，我们将重点关注追踪级别，通过理解每行代码的作用。我们希望您能够阅读代码的三个原因：
- en: '*To help determine whether code is correct —*In chapter 3, we practiced how
    to test the code that Copilot gives us. Testing is a powerful skill for determining
    whether code does the right thing, and we’ll continue to use it throughout the
    book. But many programmers, the two of us included, will only test something if
    it seems plausibly correct. If we can determine by inspection that the code is
    wrong, then we won’t bother to test it: we’ll try to fix the code first. Similarly,
    we want you to identify when code is simply wrong without having to spend time
    testing it. The more code that you can identify as wrong (through quick tracing
    or honing your overall-purpose skills), the more time you save testing broken
    code.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*帮助确定代码是否正确* —— 在第三章中，我们练习了如何测试Copilot给出的代码。测试是确定代码是否正确的强大技能，我们将在整本书中继续使用它。但是许多程序员，包括我们两个，只有在代码看起来可能正确时才会测试。如果我们能通过检查确定代码是错误的，那么我们将不会浪费时间测试它：我们会尝试先修复代码。同样，我们希望您能够识别代码是否简单错误，而无需花时间进行测试。通过快速追踪或磨练您的总体目标技能来识别更多错误代码，您将节省更多测试损坏代码的时间。'
- en: '*To inform testing —*Understanding what the code is doing line by line is useful
    on its own, but it also helps turbocharge your ability to test effectively. For
    example, in the next chapter, you’ll learn about loops—that they can cause your
    code to repeat zero times, one time, two times, or as many times as needed. You’ll
    be able to combine that knowledge with what you already know about testing to
    help you identify important categories of cases to test.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*为测试提供信息* — 逐行理解代码的作用本身就很有用，但它还能帮助你加速有效的测试能力。例如，在下一章中，你将学习到循环——它们可以让你的代码重复零次、一次、两次，或者根据需要重复任意次数。你可以将这些知识与已有的测试知识相结合，帮助你识别出需要测试的关键案例类别。'
- en: '*To help you write code —*We know, you want Copilot to write all of your code!
    We want that too. But inevitably, there will be code that Copilot just doesn’t
    get right, no matter how much prompt engineering you do. Or maybe enough prompt
    engineering could finally cajole Copilot to write the correct code, but it would
    be simpler and faster to just do it ourselves. In writing this book, the two of
    us strive to have Copilot write as much code as possible. But, because of our
    knowledge of Python programming, we’re often able to see a mistake and just fix
    it without going through any hoops to have Copilot fix it for us. Longer term,
    we want you to be empowered to learn more programming on your own, and having
    an understanding of Python is our way to provide a bridge for you from this book
    to other resources later. There is research evidence that being able to trace
    and explain code is prerequisite to being able to write code [1].'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*帮助你编写代码* — 我们知道，你希望 Copilot 为你编写所有代码！我们也希望如此。但不可避免地，总会有些代码是 Copilot 无法正确生成的，不管你做多少提示工程。或者，也许通过足够的提示工程，最终能让
    Copilot 编写出正确的代码，但我们自己做可能更简单、更快捷。在编写本书时，我们俩尽量让 Copilot 编写尽可能多的代码。但由于我们对 Python
    编程的了解，我们常常能够看到错误并直接修复，而不需要通过任何复杂的步骤让 Copilot 来修复。长期来看，我们希望你能有能力独立学习更多编程，而了解 Python
    是我们为你从本书到其他资源搭建的一座桥梁。有研究表明，能够追踪并解释代码是能够编写代码的前提[1]。'
- en: Before we get to it, we need to be clear about the level of depth that we’re
    striving for. We’re not going to teach you every nuance of every line of code.
    Doing so would revert us back to the traditional way programming was taught prior
    to tools like Copilot. Rather, through a combination of Copilot tools and our
    own explanations, we’re going to help you understand the gist or overall goal
    of each line of code. You’ll need more than this if you endeavor to write large
    portions of programs in the future. We’re trying to target the sweet spot between
    “this code is magic” and “I know exactly how every line of the code works.”
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要明确我们追求的深度水平。我们不会教你每一行代码的每一个细节。这样做会让我们回到像 Copilot 这样的工具出现之前传统的编程教学方式。相反，通过
    Copilot 工具和我们自己的解释的结合，我们将帮助你理解每一行代码的要点或整体目标。如果你以后打算编写大量程序，你需要的不止这些。我们力图找到“这段代码是魔法”与“我完全理解每行代码是如何工作的”之间的最佳平衡点。
- en: 4.2 Asking Copilot to explain code
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 请求 Copilot 解释代码
- en: 'To this point, we’ve used Copilot to generate code for us. That’s its most
    well-known feature, but it’s not the only one. We’re going to show you another
    of its best features right now: explaining what Python code does!'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 Copilot 为我们生成代码。这是它最著名的功能，但并不是唯一的功能。现在我们将向你展示它的另一个最棒的功能：解释 Python
    代码的作用！
- en: The Copilot extension is always changing. The specific steps we give here may
    vary somewhat, and, in that case, we encourage you to consult more general GitHub
    Copilot documentation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 扩展不断变化。我们在这里给出的具体步骤可能会有所不同，如果发生这种情况，我们鼓励你查阅更一般的 GitHub Copilot 文档。
- en: To try the Explain feature, you need to highlight some code that you want Copilot
    to describe to you. Let’s try this with our `best_word` function (listing 4.1).
    If you don’t have this code typed in from chapter 3, please enter it now.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试 Explain 功能，你需要高亮显示一些代码，让 Copilot 为你描述它。我们用我们的 `best_word` 函数（清单 4.1）来试试。如果你还没有输入这段代码，请现在输入。
- en: '![figure](../Images/4-1.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/4-1.png)'
- en: Figure 4.1 The code from the `best_word` function highlighted in the editor
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1 编辑器中高亮显示的 `best_word` 函数代码
- en: Highlight the code as in figure 4.1\. After this, we have a few options. The
    first is to click the Chat icon in the Activity Bar (on the left-hand side of
    VS Code), or press Ctrl-Alt-I. This will open the Copilot Chat interface, as in
    figure 4.2\. (There are other interfaces for Chat, including a Quick Chat that
    you can open with Ctrl-Shift-I—it doesn’t matter which chat interface you use.)
    Copilot Chat is able to respond to your questions not only with natural language
    but also with blocks of code, buttons/links that you can click to invoke commands,
    and more. It also suggests questions that you may wish to ask and, of course,
    allows you to type whatever code-related questions you like.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 按照图 4.1 中那样高亮代码。之后，我们有几个选项。第一个选项是点击活动栏中的聊天图标（位于 VS Code 的左侧），或者按 Ctrl-Alt-I。这样将打开
    Copilot Chat 界面，如图 4.2 所示。（还有其他聊天界面，包括你可以通过 Ctrl-Shift-I 打开的快速聊天——你可以使用任何一种聊天界面。）Copilot
    Chat 不仅能用自然语言回答你的问题，还能用代码块、可点击的按钮/链接来执行命令等。它还会建议你可能想要问的问题，当然，你也可以输入任何与代码相关的问题。
- en: '![figure](../Images/4-2.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/4-2.png)'
- en: Figure 4.2 Copilot Chat interface in VS Code
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.2 VS Code 中的 Copilot Chat 界面
- en: 'For now, we’ll use Copilot Chat to explain the code. In the text box, type
    the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将使用 Copilot Chat 来解释代码。在文本框中输入以下命令：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If Copilot asks, you want the @workspace option. If this doesn’t work for you,
    you can also try this command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Copilot 询问，你需要选择 @workspace 选项。如果这个不适用，你也可以尝试以下命令：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Typing a forward slash (/) is how you tell Copilot Chat that you’re specifying
    a command (Copilot documentation refers to these as slash commands), rather than
    natural language. In this case, we’re asking for the `/explain` command to be
    run by Copilot for the selected text.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输入斜杠（/）是告诉 Copilot Chat 你正在指定一个命令（Copilot 文档称这些为斜杠命令），而不是使用自然语言。在这种情况下，我们要求
    Copilot 对选中的文本执行`/explain`命令。
- en: Alternatively, you could ask Copilot to explain the code by highlighting the
    code in the function just like in figure 4.1\. Then, right-click the code in the
    function, and you’ll see the menu that appears in figure 4.3.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过像图 4.1 中那样高亮函数中的代码，要求 Copilot 解释代码。然后，右键点击函数中的代码，你会看到图 4.3 中出现的菜单。
- en: '![figure](../Images/4-3.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/4-3.png)'
- en: Figure 4.3 The menu that appears when you right-click the selected `best_word`
    function
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.3 右键点击选中的 `best_word` 函数时出现的菜单
- en: In this menu, highlight Copilot, and you’ll see the list of options shown in
    figure 4.4\. These options are the more commonly used features with Copilot.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜单中，点击 Copilot，你将看到图 4.4 中显示的选项列表。这些选项是与 Copilot 一起使用的更常见功能。
- en: '![figure](../Images/4-4.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/4-4.png)'
- en: Figure 4.4 A list of options that you can use with Copilot
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4 你可以与 Copilot 一起使用的选项列表
- en: The last step is to select the Explain This option. The Copilot Chat window
    will open (as shown earlier in figure 4.2), and you’ll get an explanation of the
    code. As usual, Copilot is nondeterministic, so your results will likely differ
    from ours. In fact, if an explanation is confusing you, you might try the `/explain`
    command again or writing your own prompt to get a different explanation. As educators,
    this is the start of a dream come true, where learners will be able to ask for
    as many explanations as they need to fully understand how code works.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的步骤是选择“解释此项”选项。Copilot Chat 窗口将打开（如图 4.2 中所示），并且你会得到代码的解释。像往常一样，Copilot 是非确定性的，因此你的结果可能与我们的不同。事实上，如果解释让你感到困惑，你可以尝试再次使用`/explain`命令，或者写下你自己的提示来获得不同的解释。作为教育工作者，这是梦想成真的开始，学习者可以根据需要请求尽可能多的解释，以便完全理解代码的工作原理。
- en: Copilot explanations can be wrong
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Copilot 的解释可能是错误的
- en: As with the code produced by Copilot, the explanations from Copilot can be wrong
    too. You might be thinking, “Wait, what’s the value of a tool to understand code
    if it can be wrong?!” First, we agree that this can be really frustrating. However,
    Copilot’s explanations are right often enough in our experience that they can
    be really helpful, particularly for understanding code basics such as the things
    we’re teaching in these two chapters. Moreover, what learners historically did
    when they were confused about their code was to ask friends or websites about
    the code, which can lead to mistakes too. A way to help mitigate the potential
    for error is to ask Copilot for its explanation a couple of times because you’re
    less likely to get grossly incorrect answers across multiple tries.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与Copilot生成的代码一样，Copilot的解释也可能是错误的。你可能会想，“等等，如果一个工具能理解代码却也会出错，那它的价值在哪里？！”首先，我们同意，这确实可能让人感到沮丧。然而，根据我们的经验，Copilot的解释足够准确，通常可以非常有帮助，尤其是在理解代码基础知识方面，例如我们在这两章中教授的内容。此外，当学习者对自己的代码感到困惑时，他们历史上通常会向朋友或网站询问代码，这同样可能导致错误。为了减少错误的可能性，一个有效的做法是多次询问Copilot解释，因为你不太可能在多次尝试中得到完全错误的答案。
- en: 'Here’s what Copilot gave us the first time we asked:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次询问时，Copilot给出的解释：
- en: The provided Python code defines a function named `best_word` that takes a list
    of words as an argument (`word_list`). The purpose of this function is to determine
    and return the word from the list that is worth the most points.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的Python代码定义了一个名为`best_word`的函数，该函数接受一个单词列表（`word_list`）作为参数。该函数的目的是从列表中确定并返回得分最高的单词。
- en: 'The function starts by initializing two variables: `best_word` and `best_points`.
    `best_word` is an empty string that will eventually hold the word with the highest
    point value, while `best_points` is set to 0 and will hold the highest point value
    found.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先初始化两个变量：`best_word`和`best_points`。`best_word`是一个空字符串，最终将保存得分值最高的单词，而`best_points`初始化为0，将保存找到的最高得分值。
- en: The function then enters a loop where it iterates over each word in the `word_list`.
    For each word, it calculates the point value of the word by calling the `num_points`
    function (not shown in the provided code). The `num_points` function presumably
    takes a word as an argument and returns its point value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，函数进入一个循环，遍历`word_list`中的每个单词。对于每个单词，它通过调用`num_points`函数（在提供的代码中未显示）来计算该单词的得分值。`num_points`函数预计接受一个单词作为参数并返回其得分值。
- en: If the point value of the current word is greater than the current `best_points`,
    the function updates `best_word` to be the current word and `best_points` to be
    the points of the current word. This way, the function always keeps track of the
    word with the highest point value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前单词的得分值大于当前的`best_points`，函数会将`best_word`更新为当前单词，并将`best_points`更新为当前单词的得分值。这样，函数始终跟踪得分值最高的单词。
- en: After the loop has iterated over all the words in the list, the function returns
    `best_word`, which at this point should be the word with the highest point value
    from the list. If the list is empty or all words have a point value of 0, the
    function will return an empty string.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环遍历完列表中的所有单词后，函数返回`best_word`，此时它应该是列表中得分值最高的单词。如果列表为空或所有单词的得分值为0，函数将返回一个空字符串。
- en: To us, this is an excellent description of what the code does. It starts with
    an overall explanation of the code, and then proceeds to give more of a line-by-line
    explanation. Notice, however, to make full sense of it, you need to know important
    Python terminology and features. The explanation from Copilot refers to functions,
    arguments, variables, strings, loops, making decisions (“If the point value”),
    and returning. This explanation is quite useful if you understand the terminology,
    but much less useful if you don’t. By the end of this and the next chapter, you’ll
    know the main terminology and features of Python that you need to interpret a
    typical explanation from Copilot.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，这是一个非常好的代码描述。它首先给出代码的整体解释，然后再逐行解释。然而，请注意，为了完全理解它，你需要了解重要的Python术语和特性。Copilot的解释涉及到函数、参数、变量、字符串、循环、做决策（“如果得分值”）和返回等内容。如果你理解这些术语，那么这个解释会非常有用，但如果你不理解，那么帮助就会大打折扣。通过本章和下一章的学习，你将掌握解读Copilot典型解释所需的主要Python术语和特性。
- en: Asking for explanations
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 请求解释
- en: 'The type of explanation that you get from the `/explain` command may not meet
    your requirements. For example, suppose that you want Copilot to explicitly give
    you each line of code and explain what it does, so that you can more easily connect
    the code to its specific explanation. You can make that happen! Try this prompt:
    “Explain that code again, but do it line by line. Give each line of code and the
    explanation of what it does.” Doing so gave us a very detailed breakdown of each
    line of code, followed by its explanation. We encourage you to craft your own
    prompts if built-in commands aren’t giving you the level of detail that you want.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `/explain` 命令获得的解释类型可能无法满足你的需求。例如，假设你希望 Copilot 明确地逐行给出代码并解释每行的作用，以便你能更容易地将代码与其具体解释联系起来。你可以实现这一点！尝试以下提示：“再解释一次这段代码，但按行解释。给出每行代码及其功能解释。”
    这样，我们得到了每行代码的详细分解，后面跟着它的解释。如果内置命令没有提供你想要的详细信息，我们鼓励你自行编写提示。
- en: '4.3 Top 10 programming features you need to know: Part 1'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 你需要了解的 10 大编程特性：第一部分
- en: 'We’re going to give you a whirlwind tour of the 10 Python features that you’ll
    need for the rest of your programming journey, starting with the first five of
    those in this chapter. Python is an interactive language, which makes it easier
    than other languages for us to play around with and see what stuff does. We’ll
    take advantage of that here as we explore programming features. This is how the
    two of us learned Python and how many thousands of programmers have done so. Don’t
    hesitate to experiment! To get started, press Ctrl–Shift–P and type `REPL`, and
    then select Python: Start REPL. This should result in the situation shown in figure
    4.5\. (REPL stands for read-execute-print-loop. It’s called that because Python
    reads what you type, executes/runs it, prints the results back to you, and does
    all of this over and over in a loop.)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将为你带来一个关于你编程旅程中需要的 10 个 Python 特性的小小旋风之旅，从本章开始的前五个特性。Python 是一种交互式语言，这使得我们比其他语言更容易进行实验并观察效果。我们将在这里利用这一点，探索编程特性。这就是我们俩学
    Python 的方式，也是成千上万程序员学习的方式。不要犹豫，尽管实验！首先，按下 Ctrl–Shift–P 并输入 `REPL`，然后选择 Python:
    Start REPL。这样应该会出现图 4.5 所示的情况。（REPL 代表读取-执行-打印-循环。之所以这么叫，是因为 Python 会读取你输入的内容，执行/运行它，再将结果打印回来，并不断循环这一过程。）'
- en: '![figure](../Images/4-5.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/4-5.png)'
- en: Figure 4.5 Starting REPL from VS Code
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.5 从 VS Code 启动 REPL
- en: This will put you back at the same Python prompt as in chapter 3 (as shown in
    figure 4.6), except with none of your functions loaded.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让你回到与第 3 章相同的 Python 提示符（如图 4.6 所示），只是没有加载任何函数。
- en: '![figure](../Images/4-6.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/4-6.png)'
- en: Figure 4.6 REPL running in VS Code
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.6 在 VS Code 中运行的 REPL
- en: Then, we can start typing Python code. For example, type
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以开始编写 Python 代码。例如，输入
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'and press Enter. You’ll see the response of `20`. We won’t spend time on simple
    math here, but the way you interact with Python to learn how it works is exactly
    the same: you type some code, and Python responds. Now, let’s jump into the first
    five of those 10 Python features we mentioned.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按 Enter。你会看到响应 `20`。我们在这里不花时间做简单的数学运算，但你与 Python 的交互方式完全一样：你输入一些代码，Python
    给你反馈。现在，让我们跳入我们提到的 10 个 Python 特性中的前五个。
- en: '4.3.1 #1\. Functions'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '4.3.1 #1\. 函数'
- en: 'You learned all about functions in chapter 3, so let’s just summarize what
    we learned. You use functions to break a large problem into smaller pieces. In
    retrospect, that `best_word` function we wrote in chapter 3 is a pretty big task:
    it has to figure out which word in a list of words is worth the most points. How
    many points is a word worth? Aha—that’s a subtask that we can carve out from this
    function, which we did in our earlier `num_points` function.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第 3 章已经学过了函数，所以我们只需总结一下我们学到的内容。你使用函数将一个大问题分解为更小的部分。回顾一下，我们在第 3 章编写的 `best_word`
    函数是一个相当大的任务：它需要找出在单词列表中得分最高的单词。一个单词值多少分？啊哈——这是我们可以从这个函数中分离出来的一个子任务，我们在之前的 `num_points`
    函数中做到了这一点。
- en: We design a function to take parameters, one parameter for each piece or collection
    of data that the function needs to do its job. After doing their work, most functions
    use `return` to send the answer back to the line of code that called them. When
    we call a function, we pass values, known as arguments, with one value for each
    parameter, and we often store that return value using a variable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计一个函数来接受参数，每个参数代表函数需要完成工作所需的数据的一部分或一个集合。大多数函数在完成工作后，使用`return`将结果返回给调用它们的代码行。当我们调用函数时，我们传递值，称为参数，每个参数对应一个值，我们通常使用变量来存储返回值。
- en: 'For each program we write, we’ll likely need to design a few functions, but
    there are also some functions that are built-in to Python that we get for free.
    We can call those like we call our own functions. For example, there’s a built-in
    `max` function that takes one or more arguments and tells us the largest:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们编写的每个程序，我们可能需要设计几个函数，但也有一些内置的 Python 函数可以免费使用。我们可以像调用自己的函数一样调用它们。例如，有一个内置的
    `max` 函数，它接受一个或多个参数，并返回最大的那个：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There’s also the `input` function, which we used in our `get_strong_password`
    function from chapter 3\. It takes an argument that becomes the prompt to the
    user, and it returns whatever the user types at the keyboard:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`input`函数，我们在第三章的`get_strong_password`函数中使用了它。它接受一个参数，该参数作为提示显示给用户，然后返回用户在键盘上输入的内容：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If `input` is the function to receive input from the keyboard, is there an
    `output` function to output a message to the screen? Well, yes, but it’s called
    `print`, not `output`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`input`是接收键盘输入的函数，那么是否有一个`output`函数来将消息输出到屏幕上呢？当然有，不过它叫做`print`，而不是`output`：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '4.3.2 #2\. Variables'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '4.3.2 #2\. 变量'
- en: A variable is a name that refers to a value. We used variables in chapter 3
    to keep track of `return` values from functions. We also just used a variable
    here to hold the user’s name. Whenever we need to remember a value for later,
    we use a variable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是指向某个值的名称。在第三章中，我们使用变量来跟踪函数的`return`值。我们这里也用一个变量来保存用户的姓名。每当我们需要记住某个值以供以后使用时，就会使用变量。
- en: 'To assign a value to a variable, we use the = (equals sign) symbol, which is
    called the *assignment* symbol. It figures out the value of whatever is on the
    right and then assigns that to the variable:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要给变量赋值，我们使用 =（等号）符号，这叫做*赋值*符号。它会计算等号右边的值，并将结果赋给左边的变量：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 The right-hand side of the = symbol is evaluated, which means 20 + 4 is
    evaluated to be 24\. Then, the variable age is assigned the value of 24.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 等号右边的表达式被计算，即 20 + 4 被计算为 24。然后，变量 `age` 被赋值为 24。'
- en: The = symbol is different in Python than in math
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 Python 中，= 符号与数学中的不同
- en: The = sign is used in Python and other programming languages to denote *assignment*.
    The variable on the left side of the = symbol is given the value of the calculation
    performed on the right side of the = symbol. This is *not* a permanent relationship
    as the variable can have its value changed. People new to programming who are
    strong in math can find this confusing, but just remember that the = sign in Python
    means assignment, not equality.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 以及其他编程语言中，= 符号表示*赋值*。= 符号左边的变量将得到右边计算结果的值。这*不是*一个永久关系，因为变量的值可以被改变。对数学强的人来说，刚接触编程时可能会觉得困惑，但只需要记住，Python
    中的 = 符号表示赋值，而不是相等。
- en: 'We can use the variable in a larger context, called an *expression*. The value
    that the variable refers to gets substituted for its name:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在更大的上下文中使用变量，称为*表达式*。变量所指代的值会替代它的名称：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 Age is still available in the Python prompt and has the value 24\. 24 +
    3 is evaluated to be 27.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 `age` 仍然可用，并且其值为 24。24 + 3 被计算为 27。'
- en: '#2 The expression of age + 3 doesn’t change age because we didn’t reassign
    age.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 `age + 3` 的表达式不会改变 `age`，因为我们没有重新赋值给 `age`。'
- en: Variables persist in the Python prompt
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 变量在 Python 提示符中保持存在
- en: We assigned `age` in the earlier batch of code. Why can we keep referring to
    it? Any variable declared during a session of programming with your Python prompt
    will stick around until you quit. That’s just how variables work in programs too.
    They’re available as soon as you assign a value to them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一段代码中给`age`赋了值。为什么我们可以一直引用它呢？任何在 Python 提示符下编程时声明的变量都会保留，直到退出为止。这也是程序中变量的工作方式。只要你给变量赋值，它就可以使用。
- en: 'But notice that the variable `age` didn’t change when we said `age` `+` `3`!
    To change it, we need another = assignment statement:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但是注意，当我们说 `age` `+` `3` 时，变量 `age` 并没有变化！要改变它，我们需要另一个 `=` 赋值语句：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '#1 We’ve changed age by doing an assignment (the = symbol).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们通过执行赋值操作（`=` 符号）改变了 age。'
- en: 'Let’s see a few more ways to change what a variable refers to. We’ll include
    some explanations as annotations with the code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更多改变变量引用方式的方法。我们将包含一些注释作为代码的说明：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#1 A shortcut way to add. age += 5 is equivalent to age = age + 5.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 一种快捷的加法方式。age += 5 相当于 age = age + 5。'
- en: '#2 A shortcut way to multiply by 2\. age *= 2 is equivalent to age = age *
    2\.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 一种快捷的乘以 2 的方式。age *= 2 相当于 age = age * 2\。'
- en: '4.3.3 #3\. Conditionals'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '4.3.3 #3\. 条件语句'
- en: Whenever our program has to make a decision, we need a conditional statement.
    For example, in chapter 2, we needed to make a decision about which players to
    include in our data (we wanted only quarterbacks). To do so, we used `if` statements.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们的程序需要做出决策时，我们就需要一个条件语句。例如，在第二章中，我们需要决定要在数据中包含哪些球员（我们只想要四分卫）。为此，我们使用了 `if`
    语句。
- en: Remember our larger function from chapter 3? We’ve reproduced it here in the
    following listing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在第三章中的较大值函数吗？我们已经在下面的列表中重新编写了它。
- en: Listing 4.2 Function to determine the larger of two values
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2 用于确定两个值中较大值的函数
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 The num1 &gt; num2 expression will be True if num1 is greater than num2
    and will be False if num1 is less than or equal to num2.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 如果 num1 大于 num2，num1 &gt; num2 表达式将为 True；如果 num1 小于或等于 num2，则为 False。'
- en: '#2 This line is executed when num1 is greater than num2.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 当 num1 大于 num2 时，这行代码会被执行。'
- en: '#3 The else keyword must be paired with an if keyword. When the if doesn’t
    execute (num1 &gt; num2 is False), the else executes instead.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 else 关键字必须与 if 关键字配对使用。当 if 不执行时（num1 &gt; num2 为 False），else 会执行。'
- en: '#4 This line is executed when num1 isn’t greater than num2.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 当 num1 不大于 num2 时，这行代码会被执行。'
- en: The `if-else` structure in listing 4.2 is known as a *conditional* statement,
    and it allows our program to make decisions. Here, if `num1` is greater than `num2`,
    then `num1` is returned; otherwise, `num2` is returned. That’s how it returns
    the larger one!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 中的 `if-else` 结构被称为 *条件语句*，它允许我们的程序做出决策。在这里，如果 `num1` 大于 `num2`，则返回 `num1`；否则，返回
    `num2`。这就是它如何返回较大的那个！
- en: After `if`, we put a Boolean condition (`num1` `>` `num2`). A Boolean condition
    is an expression that tests a condition where the result would either be `True`
    or `False`. If it’s `True`, then the code under the `if` runs; if it’s `False`,
    then the code under the `else` runs. We create Boolean expressions using comparison
    symbols such as `>=` for greater than or equal to, `<` for less than, > for greater
    than, == for equal to, and `!=` for not equal to. Notice that we’re using indentation
    not only for the code of the function but also for the code of the `if` and `else`
    parts of the `if-else` statement. Indentation is necessary for the code to function
    properly, so it’s worth paying attention to (we talk more about indentation in
    the next chapter). This is how Python knows which lines of code belong to the
    function and which additionally belong to the `if` or `else`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `if` 后面，我们放置一个布尔条件（`num1` `>` `num2`）。布尔条件是一个表达式，它测试一个条件，结果要么为 `True`，要么为
    `False`。如果为 `True`，则运行 `if` 下的代码；如果为 `False`，则运行 `else` 下的代码。我们通过使用比较符号来创建布尔表达式，例如
    `>=` 表示大于或等于，`<` 表示小于，`>` 表示大于，`==` 表示等于，`!=` 表示不等于。注意，我们不仅对函数的代码进行缩进，而且对 `if`
    和 `else` 部分的代码也进行缩进。缩进对于代码正常运行是必要的，因此值得注意（我们将在下一章进一步讨论缩进）。这就是 Python 知道哪些代码行属于函数，哪些代码行属于
    `if` 或 `else` 的原因。
- en: 'We can play around with conditional statements at the Python prompt too—we
    don’t need to be writing code inside of a function. Here’s an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 Python 提示符下玩条件语句——我们不需要在函数内部编写代码。这是一个例子：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#1 We assign 40 to age.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们将 40 赋值给 age。'
- en: '#2 Because age is 40, this code is asking whether 40 < 40\. It’s not, so the
    if part of the code is skipped.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 因为 age 为 40，这段代码在问是否 40 < 40\. 不是，所以跳过了 if 部分的代码。'
- en: '#3 The else portion runs because the if condition is False.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 else 部分运行，因为 if 条件为 False。'
- en: You’ll notice that the prompt changes from `>>>` to `...` when you’re typing
    inside the `if` statement. The change of prompt lets you know that you’re in the
    middle of typing code that you need to complete. You need an extra press of Enter
    when you’re done with the `else` code to get out of the `...` prompt and back
    to the `>>>` prompt.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当你在`if`语句内部输入时，提示符从`>>>`变成了`...`。提示符的变化让你知道你正在输入需要完成的代码。完成`else`代码后，按一次回车即可退出`...`提示符，回到`>>>`提示符。
- en: 'We set the age variable to 40\. As `40` `<` `40` is `False`, the `else` runs.
    Let’s try again, this time making the `if` run:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将年龄变量设置为40。因为`40` `<` `40`是`False`，所以`else`部分执行。让我们再试一次，这次让`if`部分执行：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#1 We assign 25 to age.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们将25赋给年龄。'
- en: '#2 Because age is 25, this is asking whether 25 < 40\. It is, so the if part
    of the code runs.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 因为年龄是25，所以这是在判断25 < 40。是的，所以代码中的`if`部分会执行。'
- en: '#3 The else portion doesn’t run (we already ran the if part of the code).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 `else`部分不执行（我们已经运行了`if`部分的代码）。'
- en: 'You might see some `if` statements with no `else` part, and that’s okay: the
    `else` part is optional. In that case, if the condition is `False`, then the `if`
    statement won’t do anything:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到一些没有`else`部分的`if`语句，这也是可以的：`else`部分是可选的。在这种情况下，如果条件为`False`，那么`if`语句将不会做任何事情：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#1 We assign 25 to age.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们将25赋给年龄。'
- en: '#2 == tests to see if the two values are equal.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 == 用于测试两个值是否相等。'
- en: Notice that the way to test whether two values are equal is to use two equals
    signs, (`==)`, not one equals sign. (We already know that one equals sign is for
    the assignment statement to assign a value to a variable.)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，测试两个值是否相等的方式是使用两个等号（`==`），而不是一个等号。（我们已经知道一个等号用于赋值语句，将值赋给变量。）
- en: What do you do if you have more than two possible outcomes? For example, let’s
    say that a person’s age determines the show they’ll likely binge, as shown in
    table 4.1.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有超过两个可能的结果该怎么办？例如，假设一个人的年龄决定了他们可能会狂看哪部电视剧，如表4.1所示。
- en: Table 4.1 Possible favorite TV shows by age
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.1 不同年龄段可能喜欢的电视节目
- en: '| Age | Show |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 年龄 | 显示 |'
- en: '| --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 30–39  | *Friends*  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 30–39  | *Friends*  |'
- en: '| 20–29  | *The Office*  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 20–29  | *The Office*  |'
- en: '| 10–19  | *Pretty Little Liars*  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 10–19  | *Pretty Little Liars*  |'
- en: '| 0–9  | *Chi’s Sweet Home*  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 0–9  | *Chi''s Sweet Home*  |'
- en: 'We can’t capture all of these outcomes with just an `if-else`, so the `elif`
    (short for `else-if`) allows us to capture the logic for more than two possible
    outcomes, as shown in the following code. We’re presenting this code without the
    Python prompts (`>>>` and `...`) because this would be a lot to type:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能仅通过`if-else`捕捉所有这些结果，因此`elif`（即`else-if`的缩写）使我们能够捕捉更多可能的结果，如下代码所示。我们在此展示的代码不包含Python提示符（`>>>`和`...`），因为那样打字会太多：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#1 This is True if both age >= 30 and age <= 39 are true; for example, if age
    were 35\.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 如果年龄大于或等于30且小于或等于39为真，则此条件为真；例如，如果年龄是35。'
- en: '#2 This condition is checked if the above condition is False.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 如果上述条件为假，则检查此条件。'
- en: '#3 This code runs if all conditions above are False.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 如果上述所有条件都为假，则执行此代码。'
- en: We’re using `and` to capture a complex condition. For example, in the first
    line, we want age to be greater than or equal to 30 and less than or equal to
    39\. Python works from top to bottom, and when it finds a condition that’s true,
    it runs the corresponding indented code. Then, it stops checking the remaining
    `elif`s or `else`—so if two conditions happened to be true, only the code for
    the first one would run.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`and`来捕捉复杂的条件。例如，在第一行，我们希望年龄大于或等于30且小于或等于39。Python是从上到下执行的，当它找到一个条件为真时，它会运行对应的缩进代码。然后，它停止检查剩余的`elif`或`else`——所以如果两个条件恰好为真，只有第一个条件对应的代码会运行。
- en: Try experimenting with various values for the age variable to observe that the
    correct code runs in each case. In fact, if we were serious about testing this
    code, we could use the `if` statement structure for a good sense of the values
    we’d want to test. It’s all about testing the boundaries of values. For example,
    we definitely want to test the ages 30 and 39 to make sure, for example, that
    we’re correctly capturing the full 30–39 range with the first condition. Similarly,
    we’d want to test 20, 29, 10, 19, 0, 9, and then something larger than 39 to test
    the `else` way at the bottom.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试用不同的`age`变量值进行实验，观察每种情况下正确的代码是否运行。实际上，如果我们真的要测试这段代码，我们可以使用`if`语句结构来大致确定我们要测试的值。关键在于测试值的边界。例如，我们肯定想要测试30和39岁，以确保我们正确捕捉到30到39岁的范围。同样，我们也应该测试20、29、10、19、0、9，然后再测试一个大于39的值，以测试位于最底部的`else`语句。
- en: If you use additional `if`s rather than `elif`s, then they become separate `if`
    statements, rather than a single `if` statement. This matters because Python always
    checks each independent `if` statement on its own, regardless of what may have
    happened in previous `if` statements.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用额外的`if`而不是`elif`，那么它们就变成了独立的`if`语句，而不是一个单独的`if`语句。这很重要，因为Python始终会单独检查每个独立的`if`语句，而不管之前的`if`语句发生了什么。
- en: 'For example, let’s change the `elif`s to `if`s in our age code. That gives
    us the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们把代码中的`elif`改成`if`。这将给我们以下结果：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '#1 This condition is always checked.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这个条件总是会被检查。'
- en: '#2 This else goes with the most recent if statement.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这个`else`与最近的`if`语句相关联。'
- en: Suppose that you put `age` `=` `25` above this code and run it. What do you
    think will happen? Well, the second `if` condition `age` `>=` `20` `and` `age`
    `<=` `29` is `True`, so we’ll certainly output `Binging` `The` `Office`. But that’s
    not all that happens! Remember, because we’re using `if`s here, each of the remaining
    ones is going to be checked. (If they were `elif`s, we’d be done.) `age` `>=`
    `10` `and` `age` `<=` `19` is `False`, so we’re not going to output `Binging`
    `Pretty` `Little` `Liars`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在这段代码上方写入`age` `=` `25`并运行它。你认为会发生什么？嗯，第二个`if`条件`age` `>=` `20` `and` `age`
    `<=` `29`是`True`，所以我们肯定会输出`Binging` `The` `Office`。但这并不是所有的结果！记住，因为我们在这里使用的是`if`，接下来的每一个条件都会被检查。（如果它们是`elif`，我们就完成了。）`age`
    `>=` `10` `and` `age` `<=` `19`是`False`，所以我们不会输出`Binging` `Pretty` `Little` `Liars`。
- en: The final `if` condition `age` `>=` `0` `and` `age` `<=` `9` is also `False`,
    so we’re not going to output `Binging` `Chi's` `Sweet` `Home`. But this `if` has
    an `else`! So, we *are* going to output `What's` `binging?` We didn’t intend this!
    We only wanted `What's` `binging?` for people whose age is at least 40\. This
    is all to say that `if` and `elif` behave differently and that we need to be using
    the one that matches the behavior that we want (`if` if we want multiple chunks
    of code to potentially run, and `elif` if we want only one).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`if`条件`age` `>=` `0` `and` `age` `<=` `9`也是`False`，所以我们不会输出`Binging` `Chi's`
    `Sweet` `Home`。但是这个`if`有一个`else`！所以，我们*会*输出`What's` `binging?` 我们并没有预期这样！我们只想在年龄至少为40的人群中输出`What's`
    `binging?`。这就是要说明，`if`和`elif`的行为是不同的，我们需要使用符合我们想要行为的那个（如果我们想让多个代码块可能运行，使用`if`；如果我们只想让一个代码块运行，使用`elif`）。
- en: '4.3.4 #4\. Strings'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '4.3.4 #4\. 字符串'
- en: As we learned in chapter 3, a string is the type we use whenever we want to
    store text. Text is everywhere—stats like in chapter 2, passwords, books—so strings
    show up in almost every Python program.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第3章中学到的，字符串是我们在想要存储文本时使用的类型。文本无处不在——像第2章中的统计数据、密码、书籍——因此字符串几乎出现在每个Python程序中。
- en: We use quotation marks to indicate the beginning and end of the string. You’ll
    see Copilot use double quotes or single quotes. It doesn’t matter which you use;
    just be sure to start and end the string with the same type of quote.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用引号来标识字符串的开始和结束。你会看到Copilot使用双引号或单引号。无论你使用哪种引号都没关系；只要确保字符串的开始和结束使用相同类型的引号。
- en: Strings come with a powerful set of methods. A *method* is a function that’s
    associated with a particular type—in this case, strings. The way you call a method
    is a little different from how you call a function. When you call a function,
    you put the argument values in parentheses. With methods, we still put values
    in parentheses, but we need to put the value on which we’re calling the method
    first, outside of the parentheses, followed by a dot. We’ll see an example of
    that next!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串具有一组强大的方法。*方法*是与特定类型相关联的函数——在这个例子中是字符串。调用方法的方式与调用函数的方式有所不同。当你调用函数时，你将参数值放在括号内。对于方法，我们仍然将值放在括号内，但需要先放置调用该方法的值，在括号外面，并且后面加一个点。接下来我们将看到一个示例！
- en: 'In chapter 3, Copilot used some string methods to implement `is_strong_password`.
    Let’s try using those methods here to gain a better understanding of how they
    work:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章，Copilot使用了一些字符串方法来实现`is_strong_password`。让我们在这里尝试使用这些方法，以更好地理解它们是如何工作的：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#1 isupper needs all characters to be uppercase for it to return True.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 isupper需要所有字符都是大写字母，才能返回True。'
- en: '#2 isdigit needs all characters to be numbers for it to return True.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 isdigit需要所有字符都是数字，才能返回True。'
- en: '#3 isalnum needs all characters to be alphanumeric to return True (a space
    isn’t considered alphanumeric).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 isalnum需要所有字符都是字母数字才能返回True（空格不被视为字母数字）。'
- en: There are many other string methods as well. Some help you convert strings between
    lowercase and uppercase, others help you search a string, and still others help
    you format a string (e.g., centering or right-justifying it).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他字符串方法。某些方法帮助你将字符串转换为小写或大写，其他方法帮助你搜索字符串，还有一些方法帮助你格式化字符串（例如，居中或右对齐）。
- en: 'Copilot’s Explain feature can often be helpful if you’re not sure what a given
    string method does. For example, what does this function do:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定某个字符串方法的作用，Copilot的解释功能通常会很有帮助。例如，这个函数做了什么：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '#1 Removes all ( characters from phone number'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 删除电话号码中的所有(字符'
- en: '#2 Removes all ) characters from phone number'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 删除电话号码中的所有)字符'
- en: '#3 Removes all – characters from phone number'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 删除电话号码中的所有–字符'
- en: 'Remember that we can ask Copilot to explain code, as we demonstrated in section
    4.2\. Here’s what we got when we asked Copilot to explain this code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们可以让Copilot解释代码，就像我们在第4.2节演示的那样。以下是我们请求Copilot解释这段代码时得到的结果：
- en: The provided Python code defines a function named `clean_number`. This function
    is designed to take a single argument, `phone_number`, which is expected to be
    a string representing a phone number. The purpose of this function is to remove
    certain characters from the phone number string, specifically parentheses “(”
    and “)” and hyphens “-”.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的Python代码定义了一个名为`clean_number`的函数。这个函数设计用于接受一个单一参数`phone_number`，它应该是一个表示电话号码的字符串。该函数的目的是从电话号码字符串中删除某些字符，特别是括号“(”和“)”，以及连字符“-”。
- en: 'The function uses the `replace()` method, which is a built-in method in Python
    for strings. The `replace()` method replaces a specified phrase with another specified
    phrase. It takes two arguments: the first is the substring that needs to be replaced,
    and the second is the substring that will replace the first substring.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用了`replace()`方法，这是Python内置的字符串方法。`replace()`方法将指定的子串替换为另一个指定的子串。它接受两个参数：第一个是需要被替换的子串，第二个是用来替换第一个子串的子串。
- en: 'In this function, the `replace()` method is called three times on `phone_number`.
    Each call to `replace()` is used to remove one type of character: first the open
    parenthesis “(”, then the close parenthesis “)”, and finally the hyphen “-”. It
    does this by replacing these characters with an empty string "", effectively removing
    them.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，`replace()`方法在`phone_number`上调用了三次。每次调用`replace()`都用于删除一种字符：首先是左括号“(”，然后是右括号“)”以及最后的连字符“-”。它通过将这些字符替换为空字符串""，有效地移除了它们。
- en: After all replacements are done, the cleaned `phone_number` is returned by the
    function. This will be a string containing the digits of the phone number without
    any parentheses or hyphens.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有替换后，函数返回清理后的`phone_number`。这将是一个字符串，包含电话号码的数字，没有任何括号或连字符。
- en: This function could be useful in situations where you need to process or store
    phone numbers in a consistent, character-free format. For example, you might want
    to remove these characters when storing phone numbers in a database, or when comparing
    phone numbers for equality.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在需要以一致且无字符的格式处理或存储电话号码的情况下可能会非常有用。例如，你可能希望在将电话号码存储到数据库时去除这些字符，或者在比较电话号码是否相等时进行去除。
- en: 'That confirms what this function does: removes parentheses and hyphens from
    a phone number string. And it uses the `replace` method to do so.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这确认了这个函数的作用：移除电话号码字符串中的括号和连字符。并且它使用 `replace` 方法来实现这一点。
- en: 'Wait—“replace” sounds like we’re changing some characters to some other characters
    (replacing them), not removing them. How is `replace` able to remove characters
    for us, then? The explanation said, “It does this by replacing these characters
    with an empty string "", effectively removing them.” That’s a clue to how `replace`
    is doing this, but we might want to know more. We therefore next used the prompt
    “How does the replace method use the empty string to remove characters?” and received
    the following explanation from Copilot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下——“replace”听起来像是我们在将某些字符替换为其他字符，而不是移除它们。那么，`replace`是如何帮助我们移除字符的呢？解释中说，“它通过将这些字符替换为空字符串
    ""，从而有效地移除它们。”这是`replace`如何做到这一点的线索，但我们可能还想了解更多。因此，我们接着使用了提示“`replace`方法是如何利用空字符串来移除字符的？”并从Copilot得到了以下解释：
- en: The `replace()` method in Python replaces all occurrences of a specified substring
    in the string it’s called on with another specified substring.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`replace()`方法将调用的字符串中所有指定子字符串的出现替换为另一个指定子字符串。
- en: In this case, the specified substrings are the characters “(”, “)”, and “-”.
    The method is called on the `phone_number` string, and the second argument to
    `replace()` is an empty string "".
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，指定的子字符串是字符“(”、“)”和“-”。该方法调用在 `phone_number` 字符串上，并且 `replace()` 的第二个参数是一个空字符串""。
- en: So, what happens is that every occurrence of the specified character in `phone_number`
    is replaced with an empty string. This effectively removes that character from
    the string, because replacing something with nothing is equivalent to removing
    it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，发生的事情是，`phone_number` 中每个指定字符的出现都被替换为空字符串。这有效地从字符串中移除了该字符，因为用空字符串替换相当于将其删除。
- en: This is done three times in the `clean_number` function, once for each character
    that needs to be removed. After all three characters have been removed, the cleaned
    `phone_number` is returned.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 `clean_number` 函数中执行了三次，每次移除一个需要去掉的字符。所有三个字符移除后，清理过的 `phone_number` 被返回。
- en: And if you wanted to learn even more, you could continue asking Copilot questions
    or do your own testing at the Python prompt. For example, you could verify that
    `replace` removes all (, ), and - characters, even if there are multiples of each.
    And you could explore using `replace` to actually replace characters (its typical
    use case), rather than removing them. This kind of exploration is also helpful
    if we need to separate truth from bits of incorrect information that Copilot may
    provide. This is why we need a baseline of our own Python knowledge!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多，你可以继续向Copilot提问或在Python提示符下进行测试。例如，你可以验证 `replace` 是否会移除所有的 `(`、`)`
    和 `-` 字符，即使每种字符有多个。你还可以探索使用 `replace` 来实际替换字符（它的典型用法），而不是移除它们。这种探索也很有帮助，如果我们需要从Copilot可能提供的不正确信息中分辨出真相。这就是为什么我们需要自己掌握Python知识的基础！
- en: 'You’ll also often see what look like mathematical operators being used on strings.
    They are the same as math symbols, but they do different things on strings. The
    + operator is used to put two strings together, and the * operator is used to
    repeat a string a specific number of times. Examples are shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你还经常会看到看似数学运算符的符号应用于字符串。它们和数学符号相同，但对字符串做的操作不同。`+` 运算符用于将两个字符串连接在一起，而 `*` 运算符用于将字符串重复特定次数。示例如下：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 Combines first and second strings and assigns result to sentence'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将第一个和第二个字符串合并，并将结果赋给句子'
- en: '#2 Repeats the -= string five times'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将“-=”字符串重复五次'
- en: '4.3.5 #5\. Lists'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '4.3.5 #5\. 列表'
- en: A *string is great when we have a sequence of characters, such as a password
    or a single Scrabble word. But sometimes, we need to store many words or many
    numbers. For that, we need a list. We used a list in chapter 3 for the `best_word`
    function because that function needed to work with a list of individual words.*
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*当我们需要存储一系列字符时，例如密码或一个 Scrabble 单词，字符串是很好的选择。但有时我们需要存储许多单词或许多数字。为此，我们需要一个列表。在第
    3 章中，我们为 `best_word` 函数使用了列表，因为该函数需要处理单个单词的列表。*'
- en: '*Whereas we use quotation marks to start and end a string, we use opening and
    closing square brackets to start and end a list. And, as for strings, there are
    many methods available on lists. To give you an idea of the kinds of list methods
    available and what they do, let’s explore some of these:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*而我们用引号来开始和结束一个字符串，我们用方括号来开始和结束一个列表。而且，和字符串一样，列表也有许多可用的方法。为了让你了解列表方法的种类及其功能，让我们来探索其中一些：*'
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#1 A list with three string values in it'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 一个包含三个字符串值的列表'
- en: '#2 Adds a new string value to the end of the list'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 在列表末尾添加一个新的字符串值'
- en: '#3 Reverses the list (now the values are in the opposite order)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 反转列表（现在值的顺序是相反的）'
- en: 'Many Python types, including strings and lists, allow you to work with particular
    values using an *index*. You need to use indices whenever you want to work with
    part of a string or list rather than the whole thing. An index is just a number
    that identifies an element. Indices start at 0 for the first element and go up
    to, but not including, the number of values. The first value has index 0 (not
    index 1!), the second has index 1, the third has index 2, and so on. The last
    value in the list is at the index, which is the length of the list minus 1\. The
    length of the list can be determined by using the `len` function. For example,
    if we do `len(books)`, we’ll get a value of `4` (so the valid indices are from
    0 up to and including 3). People also often use negative indices, which provides
    another way to index each value: the rightmost value has index –1, the value to
    its left has index –2, and so on. Figure 4.7 depicts this example with both positive
    and negative indexing.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Python 类型，包括字符串和列表，允许你使用 *索引* 来处理特定的值。当你只想处理字符串或列表的一部分而不是整个内容时，你需要使用索引。索引就是一个数字，用来标识一个元素。索引从
    0 开始，第一个元素的索引是 0（而不是 1！），第二个是 1，第三个是 2，以此类推。列表中的最后一个值的索引是列表长度减去 1。列表的长度可以通过使用
    `len` 函数来确定。例如，如果我们做 `len(books)`，我们会得到一个值 `4`（所以有效的索引范围是从 0 到 3）。人们也经常使用负索引，这为索引每个值提供了另一种方式：最右边的值索引为
    -1，左边的值索引为 -2，以此类推。图 4.7 展示了这个例子，既包括正索引也包括负索引。
- en: '![figure](../Images/4-7.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/4-7.png)'
- en: Figure 4.7 List elements can be accessed through either positive or negative
    indices.
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.7 列表元素可以通过正索引或负索引进行访问。
- en: 'Let’s practice indexing on the current books list:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习一下当前 books 列表上的索引操作：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '#1 books[0] corresponds to the first element.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 books[0] 对应第一个元素。'
- en: '#2 Error because index 3 is the last book!'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 错误，因为索引 3 是最后一本书！'
- en: '#3 books[-1] refers to the last element in the list.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 books[-1] 指的是列表中的最后一个元素。'
- en: 'There’s also a way to pull multiple values out of a string or list, rather
    than just one. It’s called *slicing*. We specify the index of the first value,
    a colon, and the index to the right of the value, like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以从字符串或列表中提取多个值，而不仅仅是一个。这种方法叫做 *切片*。我们指定第一个值的索引，一个冒号，以及右边的索引，像这样：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Starts at index 1, ends at index 2 (not 3!)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从索引 1 开始，到索引 2 结束（而不是 3！）'
- en: We specified 1:3, so you might expect to get the values including index 3\.
    But the value at the second index (the one after the colon) isn’t included. It’s
    counterintuitive but true!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了 1:3，所以你可能会期待获得包括索引 3 的值。但第二个索引（冒号后面的那个）对应的值并不包括在内。这是违反直觉的，但它确实是正确的！
- en: 'If we leave out the starting or ending index, Python uses the start or end
    as appropriate:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略起始索引或结束索引，Python 会根据需要使用起始或结束：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 Same as using books[0:3]'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 与使用 books[0:3] 相同'
- en: '#2 Same as using books[1:4]'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 与使用 books[1:4] 相同'
- en: 'We can also use indexing to change a specific value in a list, for example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用索引来更改列表中的特定值，例如：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 Changes books[0] to refer to the string value “The Android”'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将 books[0] 修改为引用字符串值“The Android”'
- en: '#2 Changes books[1] to be in all uppercase'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将 books[1] 修改为全部大写'
- en: 'If we try that on a string, though, we get an error:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们对字符串这样做，就会出错：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '#1 Looking up a char works fine.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 查找字符是可以正常工作的。'
- en: '#2 But assigning doesn’t!'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 但赋值操作不行！'
- en: A string is known as an *immutable* value, which means that you can’t change
    its characters. You can only create an entirely new string. By contrast, a list
    is known as a *mutable* value, which means that you can change it. If you get
    errors about a type not supporting item assignment, you’re likely trying to change
    a value that can’t be changed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串被认为是*不可变*的值，这意味着您不能改变它的字符。您只能创建一个全新的字符串。相比之下，列表被认为是*可变*的值，这意味着您可以改变它。如果您遇到类型不支持项赋值的错误，您可能是在尝试更改一个不能更改的值。
- en: In this chapter, we introduced you to five of the most common code features
    in Python. We’ll continue with five more in the next chapter. We also showed you
    how you can use the Copilot explanation tool to help you understand what the code
    is doing and offered guidance for verifying the veracity of these explanations.
    Table 4.2 provides a summary of the features we covered in this chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了 Python 中五个最常见的代码特性。在下一章，我们将继续介绍另外五个特性。我们还向您展示了如何使用 Copilot 解释工具来帮助您理解代码的作用，并提供了验证这些解释真实性的指导。表
    4.2 总结了本章中涉及的特性。
- en: Table 4.2 Summary of Python code features from this chapter
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.2 本章 Python 代码特性总结
- en: '| **Code Element** | Example | Brief Description |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| **代码元素** | 示例 | 简要说明 |'
- en: '| --- | --- | --- |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Functions  | `def larger(num1, num2)`  | Code feature that allows us to manage
    code complexity. Functions take in inputs, process those inputs, and possibly
    return an output.  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 函数  | `def larger(num1, num2)`  | 一种可以帮助我们管理代码复杂性的代码特性。函数接收输入，处理这些输入，并可能返回输出。  |'
- en: '| Variables  | `age = 25`  | A human-readable name that refers to a stored
    value. It can be assigned using the `=` assignment statement.  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 变量  | `age = 25`  | 一个可读的名称，指向存储的值。它可以通过 `=` 赋值语句进行赋值。  |'
- en: '| Conditionals  | `if age < 18: print("Can''t vote") else: print("Can vote")`  |
    Conditionals allow the code to make decisions. In Python, we have three keywords
    associated with conditionals: `if`, `elif`, and `else`.  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 条件语句  | `if age < 18: print("Can''t vote") else: print("Can vote")`  | 条件语句让代码能够做出决策。在
    Python 中，我们有三个与条件语句相关的关键字：`if`、`elif` 和 `else`。  |'
- en: '| Strings  | `name = ''Dan''`  | Strings store a sequence of characters (text).
    There are many powerful methods available for modifying strings.  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 字符串  | `name = ''Dan''`  | 字符串存储一系列字符（文本）。有许多强大的方法可用于修改字符串。  |'
- en: '| Lists  | `list = [''Leo'', ''Dan'']`  | A sequence of values of any type.
    There are many powerful methods available for modifying lists.  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 列表  | `list = [''Leo'', ''Dan'']`  | 一个包含任何类型值的序列。修改列表有许多强大的方法。  |'
- en: 4.4 Exercises
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 练习
- en: Recall the conditionals code we looked at in listing 4.2 (section 4.3.3). How
    does the behavior of this program differ from the original?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回忆一下我们在清单 4.2（4.3.3 节）中看到的条件语句代码。这个程序的行为与原始代码有何不同？
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 2\. In the following code, what gets printed if age is 32? What would be printed
    if you change every `if`, except for the first, to an `elif` instead?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 在以下代码中，如果 `age` 是 32，会打印什么？如果将每个 `if` 改成 `elif`（除了第一个），打印的内容会是什么？
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 3\. What Python data type would you use to hold a series of temperature readings
    from a sensor that records data every minute? What would this data type store?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 您会使用哪种 Python 数据类型来保存一个传感器的温度读数，该传感器每分钟记录一次数据？这种数据类型将存储什么？
- en: 4\. Arrange the following blocks of Python code to create a program that calculates
    the sum of all even numbers in a provided list.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 将以下 Python 代码块排列起来，创建一个计算提供的列表中所有偶数之和的程序。
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '5\. (Recall section 4.3.1.) Consider the Python function call `min(input("Enter`
    `a` `number:` `"),` `input("Enter` `another` `number:` `"))`. Before running this
    code, think about what this line is supposed to do, and then answer the following
    questions:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. （回顾 4.3.1 节。）考虑以下 Python 函数调用 `min(input("Enter` `a` `number:` `"),` `input("Enter`
    `another` `number:` `"))`。在运行此代码之前，思考这行代码应该做什么，然后回答以下问题：
- en: What do you expect to happen when this code is run? Describe each step of the
    execution process.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当运行这段代码时，您预期会发生什么？描述执行过程的每一步。
- en: How does Python handle the inputs and the `min` function together in this scenario?
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，Python 如何同时处理输入和 `min` 函数？
- en: If the inputs aren’t numbers but strings that are numeric (e.g., `5` or `2`),
    how might Python’s behavior change, if at all?
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入不是数字，而是数字形式的字符串（例如，`5` 或 `2`），Python 的行为会有什么变化（如果有的话）？
- en: What would be the outcome if one or both inputs aren’t numeric? Test your hypothesis
    by trying different inputs.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个或两个输入不是数字，会发生什么结果？通过尝试不同的输入来测试您的假设。
- en: 6\. In section 4.3.2, we talked about how variables persist in Python. How does
    this property of variables influence the way you might structure your code? Think
    of an example scenario where maintaining variable states across different parts
    of a program would be beneficial.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6. 在4.3.2节中，我们讨论了变量在Python中的持久性。变量的这一特性如何影响你编写代码的结构？想象一个场景，在程序的不同部分之间保持变量状态会带来什么好处。
- en: '7\. We ask Copilot to explain how the following code works:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7. 我们要求Copilot解释以下代码是如何工作的：
- en: '[PRE29]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Copilot provides the following explanation:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot提供以下解释：
- en: This Python code is a simple program that asks the user for their age and then
    prints out a message based on the age range they fall into.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这段Python代码是一个简单的程序，询问用户的年龄，然后根据年龄范围打印出相应的消息。
- en: 'The first line of the code uses the `input()` function to prompt the user to
    enter their age. The `input()` function reads a line from input (usually from
    the user’s keyboard), converts it into a string, and returns that string. In this
    case, the prompt is “Enter your age: ”. The returned string is then converted
    into an integer using the `int()` function and stored in the variable age.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行使用`input()`函数提示用户输入年龄。`input()`函数读取输入的一行（通常来自用户的键盘），将其转换为字符串并返回该字符串。在此情况下，提示为“请输入你的年龄：”。返回的字符串随后使用`int()`函数转换为整数并存储在变量age中。
- en: The rest of the code is a series of conditional statements that check the value
    of age and print out a corresponding message. The `if` statement checks if the
    age is less than 13, and if so, it prints “You are a child.” If the age is not
    less than 13, the program moves to the next condition, the `elif` (short for `else`
    `if`) statement, which checks if the age is less than 20\. If so, it prints “You
    are a teenager.” If the age is not less than 20, it moves to the next `elif` statement,
    which checks if the age is less than 60\. If so, it prints “You are an adult.”
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码是一些条件语句，检查年龄的值并打印相应的消息。`if`语句检查年龄是否小于13，如果是，打印“你是一个孩子”。如果年龄不小于13，程序会检查下一个条件，即`elif`（`else`
    `if`的简写）语句，检查年龄是否小于20。如果是，打印“你是一个青少年”。如果年龄不小于20，程序会继续检查下一个`elif`语句，检查年龄是否小于60。如果是，打印“你是一个成年人”。
- en: It turns out that the explanation from Copilot is incomplete as it doesn’t describe
    the code for *all inputs*. Determine what the explanation is missing, and add
    your answer to the explanation.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明Copilot的解释是不完整的，因为它没有描述*所有输入*的情况。找出解释缺少的部分，并将你的答案添加到解释中。
- en: 8\. Review the Python code provided and the initial prompt to Copilot. The explanation
    returned was too vague and didn’t help you understand the string methods used
    in the code.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 8. 回顾提供的Python代码和给Copilot的初始提示。返回的解释太模糊，无法帮助你理解代码中使用的字符串方法。
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Prompt given to Copilot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 给Copilot的提示：
- en: Can you explain what this code does?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你能解释这段代码是做什么的吗？
- en: 'Copilot explanation given back:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot给出的解释：
- en: The code involves manipulating a string stored in text by finding a specific
    word and replacing it with another word. It uses methods to locate where the word
    starts and then constructs a new string where the word has been replaced. Finally,
    it prints out the modified string.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 代码涉及操作存储在text中的字符串，通过找到一个特定的词并将其替换为另一个词。它使用方法来定位该词的起始位置，然后构建一个新字符串，其中词被替换。最后，打印出修改后的字符串。
- en: 'Your task is to do the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是做以下几件事：
- en: Identify why the initial prompt might lead to a vague or unhelpful explanation.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定为什么初始提示可能会导致模糊或不帮助的解释。
- en: Improve the prompt to ensure a more detailed and specific explanation from Copilot.
    Consider what you specifically don’t understand about the string methods and how
    the code uses them.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改进提示，以确保Copilot提供更详细、具体的解释。考虑一下你对字符串方法的理解上有哪些具体问题，以及代码如何使用这些方法。
- en: Write the revised prompt to Copilot, and discuss how your changes will lead
    to a better explanation.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出修改后的提示给Copilot，并讨论你的更改如何能引导出更好的解释。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We need to be able to read code to determine whether it’s correct, test it effectively,
    and write our own code when needed.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要能够阅读代码，以判断它是否正确，进行有效的测试，并在需要时编写自己的代码。
- en: Copilot can provide line-by-line explanations of code to explain what the code
    is doing, and you can use your own prompt to influence the type of explanation
    you get.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot可以提供逐行解释代码的功能，帮助解释代码在做什么，你可以使用自己的提示来影响解释的类型。
- en: Python has built-in functions such as `max`, `input`, and `print` that we call
    just like we call our own functions.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 有内建函数，如 `max`、`input` 和 `print`，我们像调用自己的函数一样调用它们。
- en: A variable is a name that refers to a value.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量是一个引用值的名称。
- en: An assignment statement makes a variable refer to a specific value.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值语句使变量引用特定的值。
- en: An `if` statement is used to have our programs make decisions and proceed down
    one of multiple paths.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 语句用于让我们的程序做出决策，并沿着多个路径之一继续执行。'
- en: A string is used to store and manipulate text.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串用于存储和操作文本。
- en: A method is a function associated with a particular type.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法是与特定类型关联的函数。
- en: A list is used to store and manipulate a general sequence of values (e.g., a
    sequence of numbers or a sequence of strings).
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表用于存储和操作一系列通用的值（例如，一系列数字或字符串）。
- en: Each value in a string or list has an index; indexing starts at 0, not 1\.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串或列表中的每个值都有一个索引；索引从 0 开始，而不是 1\。
- en: Strings are immutable (not changeable); lists are mutable (changeable).*
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串是不可变的（不可更改的）；列表是可变的（可更改的）*。
