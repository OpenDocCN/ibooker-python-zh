- en: Chapter 14\. Files and Directories
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。文件和目录。
- en: I have files, I have computer files and, you know, files on paper. But most
    of it is really in my head. So God help me if anything ever happens to my head!
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我有文件，我有电脑文件，你知道的，在纸上也有文件。但大部分都在我脑子里。所以如果我的脑子出了问题，上帝帮帮我！
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: George R. R. Martin
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 乔治·R·R·马丁。
- en: When you first start programming, you hear some words over and over but aren’t
    sure whether they have a specific technical meaning or are just handwaving. The
    terms *file* and *directory* are such words, and they do have actual technical
    meanings. A *file* is a sequence of bytes, stored in some *filesystem*, and accessed
    by a *filename*. A *directory* is a collection of files, and possibly other directories.
    The term *folder* is a synonym for directory. It turned up when computers gained
    graphical user interfaces, and mimicked office concepts to make things seem more
    familiar.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始学习编程时，你会反复听到一些词，但不确定它们是否具有特定的技术含义还是随意的说法。*文件*和*目录*就是这样的词，它们确实有实际的技术含义。*文件*是一系列字节，存储在某个*文件系统*中，并通过*文件名*访问。*目录*是文件和可能其他目录的集合。术语*文件夹*是目录的同义词。它出现在计算机获得图形用户界面时，模仿办公室概念，使事物看起来更加熟悉。
- en: Many filesystems are hierarchical, and often referred to as being like a tree.
    Real offices don’t tend to have trees in them, and the folder analogy only works
    if you visualize subfolders all the way down.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 许多文件系统是分层的，通常被称为类似于树。真实的办公室里不会有树，文件夹类比只有在你能够想象出所有子文件夹的情况下才有效。
- en: File Input and Output
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件的输入和输出。
- en: The simplest kind of persistence is a plain old file, sometimes called a *flat
    file*. You *read* from a file into memory and *write* from memory to a file. Python
    makes these jobs easy. As with many languages, its file operations were largely
    modeled on the familiar and popular Unix equivalents.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的持久性形式是普通的文件，有时称为*平面文件*。你从文件中*读取*到内存中，然后从内存中*写入*到文件中。Python使得这些工作变得容易。与许多语言一样，它的文件操作在很大程度上是模仿熟悉且受欢迎的Unix等效操作。
- en: Create or Open with open()
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`open()`创建或打开。
- en: 'You need to call the `open` function before you do the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行以下操作之前，您需要调用`open`函数：
- en: Read an existing file
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取现有文件。
- en: Write to a new file
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入到一个新文件。
- en: Append to an existing file
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追加到现有文件。
- en: Overwrite an existing file
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖现有文件。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s a brief explanation of the pieces of this call:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对这个调用的各部分的简要解释：
- en: '*`fileobj`* is the file object returned by `open()`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`fileobj`*是`open()`返回的文件对象。'
- en: '*`filename`* is the string name of the file'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`filename`*是文件的字符串名称。'
- en: '*`mode`* is a string indicating the file’s type and what you want to do with
    it'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`mode`*是一个表示文件类型及其操作的字符串。'
- en: 'The first letter of *`mode`* indicates the *operation*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*`mode`*的第一个字母表示操作：'
- en: '`r` means read.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`表示读取。'
- en: '`w` means write. If the file doesn’t exist, it’s created. If the file does
    exist, it’s overwritten.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`表示写入。如果文件不存在，则创建该文件。如果文件存在，则覆盖它。'
- en: '`x` means write, but only if the file does *not* already exist.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`表示写入，但只有在文件*不存在*时才会写入。'
- en: '`a` means append (write after the end) if the file exists.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`表示追加（在末尾写入），如果文件存在。'
- en: 'The second letter of *`mode`* is the file’s *type*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*`mode`*的第二个字母表示文件的*类型*：'
- en: '`t` (or nothing) means text.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t`（或什么都不写）表示文本。'
- en: '`b` means binary.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`表示二进制。'
- en: After opening the file, you call functions to read or write data; these will
    be shown in the examples that follow.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件后，您可以调用函数来读取或写入数据；这些将在接下来的示例中展示。
- en: Last, you need to *close* the file to ensure that any writes complete, and that
    memory is freed. Later, you’ll see how to use `with` to automate this for you.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要*关闭*文件以确保任何写入操作都已完成，并且内存已被释放。稍后，您将看到如何使用`with`来自动化此过程。
- en: 'This program opens a file called *oops.txt* and closes it without writing anything.
    This would create an empty file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序打开一个名为*oops.txt*的文件，并在不写入任何内容的情况下关闭它。这将创建一个空文件：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Write a Text File with print()
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`print()`写入文本文件。
- en: 'Let’s re-create *oops.txt*, but now write a line to it and then close it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新创建*oops.txt*，然后向其中写入一行内容，然后关闭它：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We created an empty *oops.txt* file in the previous section, so this just overwrites
    it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节创建了一个空的*oops.txt*文件，所以这只是覆盖它。
- en: We used the `file` argument to `print`. Without it, `print` writes to *standard
    output*, which is your terminal (unless you’ve told your shell program to redirect
    output to a file with `>` or piped it to another program with `|`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`print`函数的`file`参数。如果没有这个参数，`print`会将内容写入*标准输出*，也就是你的终端（除非你已经告诉你的shell程序使用`>`重定向输出到文件或使用`|`管道传输到另一个程序）。
- en: Write a Text File with write()
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`write()`写入文本文件。
- en: We just used `print` to write a line to a file. We can also use `write`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用`print`向文件中写入了一行。我们也可以使用`write`。
- en: For our multiline data source, let’s use this limerick about special relativity:^([1](ch14.html#idm45794985259544))
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的多行数据源，让我们使用这首关于狭义相对论的打油诗作为例子：^([1](ch14.html#idm45794985259544))
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following code writes the entire poem to the file `''relativity''` in one
    call:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码一次性将整首诗写入到名为`'relativity'`的文件中：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `write` function returns the number of bytes written. It does not add any
    spaces or newlines, as `print` does. As before, you can also `print` a multiline
    string to a text file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`write`函数返回写入的字节数。它不像`print`那样添加空格或换行符。同样，你也可以使用`print`将多行字符串写入文本文件：'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So, should you use `write` or `print`? As you’ve seen, by default `print` adds
    a space after each argument and a newline at the end. In the previous example,
    it appended a newline to the `relativity` file. To make `print` work like `write`,
    pass it the following two arguments:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，应该使用`write`还是`print`？正如你所见，默认情况下，`print`在每个参数后添加一个空格，并在末尾添加换行符。在前一个示例中，它向`relativity`文件附加了一个换行符。要使`print`像`write`一样工作，将以下两个参数传递给它：
- en: '`sep` (separator, which defaults to a space, `'' ''`)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sep`（分隔符，默认为空格，`'' ''`）'
- en: '`end` (end string, which defaults to a newline, `''\n''`)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`（结束字符串，默认为换行符，`''\n''`）'
- en: 'We’ll use empty strings to replace these defaults:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用空字符串来替换这些默认值：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you have a large source string, you can also write chunks (using slices)
    until the source is done:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个大的源字符串，你也可以写入分片（使用切片），直到源字符串处理完毕：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This wrote 100 characters on the first try and the last 50 characters on the
    next. Slices allow you to “go over the end” without raising an exception.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次在第一次尝试中写入了100个字符，下一次写入了最后50个字符。切片允许你“超过结尾”而不会引发异常。
- en: 'If the `relativity` file is precious to us, let’s see whether using mode `x`
    really protects us from overwriting it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对我们来说`relativity`文件很重要，让我们看看使用模式`x`是否真的保护我们免受覆盖：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can use this with an exception handler:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其与异常处理器一起使用：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Read a Text File with read(), readline(), or readlines()
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`read()`、`readline()`或`readlines()`读取文本文件
- en: 'You can call `read()` with no arguments to slurp up the entire file at once,
    as shown in the example that follows (be careful when doing this with large files;
    a gigabyte file will consume a gigabyte of memory):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不带参数调用`read()`一次性读取整个文件，就像下面的示例一样（在处理大文件时要小心；一个1GB文件将消耗1GB内存）：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can provide a maximum character count to limit how much `read()` returns
    at one time. Let’s read 100 characters at a time and append each chunk to a `poem`
    string to rebuild the original:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以提供一个最大字符数来限制`read()`一次返回多少内容。让我们一次读取100个字符，并将每个块追加到`poem`字符串以重建原始内容：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After you’ve read all the way to the end, further calls to `read()` will return
    an empty string (`''`), which is treated as `False` in `if not fragment`. This
    breaks out of the `while True` loop.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读取到结尾后，进一步调用`read()`会返回一个空字符串（`''`），这在`if not fragment`中被视作`False`。这会跳出`while
    True`循环。
- en: 'You can also read the file a line at a time by using `readline()`. In this
    next example, we append each line to the `poem` string to rebuild the original:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`readline()`一次读取一行。在下一个示例中，我们将每一行追加到`poem`字符串中以重建原始内容：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For a text file, even a blank line has a length of one (the newline character),
    and is evaluated as `True`. When the file has been read, `readline()` (like `read()`)
    also returns an empty string, which is also evaluated as `False`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本文件，即使是空行也有长度为一（换行符），并且被视作`True`。当文件被读取完毕时，`readline()`（和`read()`一样）也会返回一个空字符串，同样被视作`False`。
- en: 'The easiest way to read a text file is by using an *iterator*. This returns
    one line at a time. It’s similar to the previous example but with less code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文本文件的最简单方法是使用*迭代器*。它一次返回一行。与前面的示例类似，但代码更少：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All of the preceding examples eventually built the single string `poem`. The
    `readlines()` call reads a line at a time, and returns a list of one-line strings:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述示例最终构建了单个字符串`poem`。`readlines()`方法逐行读取，返回一个包含每行字符串的列表：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We told `print()` to suppress the automatic newlines because the first four
    lines already had them. The last line did not, causing the interactive prompt
    `>>>` to occur right after the last line.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉`print()`不要自动换行，因为前四行已经有了换行。最后一行没有换行，导致交互提示符`>>>`出现在最后一行之后。
- en: Write a Binary File with write()
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`write()`写入二进制文件
- en: If you include a `'b'` in the *mode* string, the file is opened in binary mode.
    In this case, you read and write `bytes` instead of a string.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在*模式*字符串中包含 `'b'`，文件将以二进制模式打开。在这种情况下，你读取和写入的是 `bytes` 而不是字符串。
- en: 'We don’t have a binary poem lying around, so we’ll just generate the 256 byte
    values from 0 to 255:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手头没有二进制诗歌，所以我们只会生成从 0 到 255 的 256 个字节值：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Open the file for writing in binary mode and write all the data at once:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以二进制模式打开文件进行写入，并一次性写入所有数据：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Again, `write()` returns the number of bytes written.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`write()` 返回写入的字节数。
- en: 'As with text, you can write binary data in chunks:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 和文本一样，你可以将二进制数据分块写入：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Read a Binary File with read()
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `read()` 读取二进制文件
- en: 'This one is simple; all you need to do is just open with `''rb''`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个很简单；你只需要用 `'rb'` 打开即可：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Close Files Automatically by Using with
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `with` 自动关闭文件
- en: If you forget to close a file that you’ve opened, it will be closed by Python
    after it’s no longer referenced. This means that if you open a file within a function
    and don’t close it explicitly, it will be closed automatically when the function
    ends. But you might have opened the file in a long-running function or the main
    section of the program. The file should be closed to force any remaining writes
    to be completed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记关闭已打开的文件，在不再引用后 Python 会关闭它。这意味着如果你在函数中打开文件但没有显式关闭它，在函数结束时文件会被自动关闭。但你可能在长时间运行的函数或程序的主要部分中打开了文件。应该关闭文件以确保所有未完成的写入被完成。
- en: 'Python has *context managers* to clean up things such as open files. You use
    the form `with` *`expression`* `as` *`variable`*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有*上下文管理器*来清理诸如打开的文件之类的资源。你可以使用形式 `with` *`表达式`* `as` *`变量`*：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That’s it. After the block of code under the context manager (in this case,
    one line) completes (normally *or* by a raised exception), the file is closed
    automatically.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。在上下文管理器（在本例中就是一行代码块）完成（正常完成 *或* 通过抛出异常）后，文件会自动关闭。
- en: Change Position with seek()
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `seek()` 改变位置
- en: As you read and write, Python keeps track of where you are in the file. The
    `tell()` function returns your current offset from the beginning of the file,
    in bytes. The `seek()` function lets you jump to another byte offset in the file.
    This means that you don’t have to read every byte in a file to read the last one;
    you can `seek()` to the last one and just read one byte.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读取和写入时，Python 会跟踪你在文件中的位置。`tell()` 函数返回你当前从文件开头的偏移量，以字节为单位。`seek()` 函数让你跳到文件中的另一个字节偏移量。这意味着你不必读取文件中的每个字节来读取最后一个字节；你可以
    `seek()` 到最后一个字节并只读取一个字节。
- en: 'For this example, use the 256-byte binary file `''bfile''` that you wrote earlier:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，使用你之前写的 256 字节二进制文件 `'bfile'`：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Use `seek()` to jump to one byte before the end of the file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `seek()` 跳转到文件末尾前一个字节：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Read until the end of the file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 读取直到文件末尾：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`seek()` also returns the current offset.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`seek()` 也会返回当前偏移量。'
- en: 'You can call `seek()` with a second argument: ``seek(*`offset`*, *`origin`*)``:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以给 `seek()` 调用一个第二参数：``seek(*`offset`*, *`origin`*)``：
- en: If `origin` is `0` (the default), go *`offset`* bytes from the start
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `origin` 是 `0`（默认值），就从文件开头向后 *`offset`* 字节
- en: If `origin` is `1`, go *`offset`* bytes from the current position
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `origin` 是 `1`，就从当前位置向后 *`offset`* 字节
- en: If `origin` is `2`, go *`offset`* bytes relative to the end
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `origin` 是 `2`，就从文件末尾相对 *`offset`* 字节
- en: 'These values are also defined in the standard `os` module:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值也在标准的 `os` 模块中定义：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So, we could have read the last byte in different ways:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以用不同的方式读取最后一个字节：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'One byte before the end of the file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 文件末尾前一个字节：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Read until the end of the file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 读取直到文件末尾：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You don’t need to call `tell()` for `seek()` to work. I just wanted to show
    that they both report the same offset.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要调用 `tell()` 来让 `seek()` 工作。我只是想展示它们报告相同的偏移量。
- en: 'Here’s an example of seeking from the current position in the file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从文件当前位置进行搜索的示例：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This next example ends up two bytes before the end of the file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例最终会在文件末尾前两个字节处结束：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now go forward one byte:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在向前移动一个字节：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, read until the end of the file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，读取直到文件末尾：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These functions are most useful for binary files. You can use them with text
    files, but unless the file is ASCII (one byte per character), you would have a
    hard time calculating offsets. These would depend on the text encoding, and the
    most popular encoding (UTF-8) uses varying numbers of bytes per character.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数对于二进制文件最有用。你可以用它们处理文本文件，但除非文件是 ASCII（每个字符一个字节），否则计算偏移量会很困难。这将取决于文本编码，而最流行的编码（UTF-8）使用不同数量的字节表示每个字符。
- en: Memory Mapping
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存映射
- en: An alternative to reading and writing a file is to *memory-map* it with the
    standard `mmap` module. This makes the contents of a file look like a `bytearray`
    in memory. See the [documentation](https://oreil.ly/GEzkf) and some [examples](https://oreil.ly/GUtdx)
    for more details.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入文件的替代方法是使用标准`mmap`模块将其*内存映射*。 这使得文件内容在内存中看起来像一个`bytearray`。 有关详细信息，请参阅[文档](https://oreil.ly/GEzkf)和一些[示例](https://oreil.ly/GUtdx)。
- en: File Operations
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件操作
- en: Python, like many other languages, patterned its file operations after Unix.
    Some functions, such as `chown()` and `chmod()`, have the same names, but there
    are a few new ones.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python，像许多其他语言一样，根据Unix模式化其文件操作。 一些函数，例如`chown()`和`chmod()`，具有相同的名称，但还有一些新函数。
- en: I’ll first show how Python handles these tasks with functions from the `os.path`
    module and then with the newer `pathlib` module.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将展示Python如何使用`os.path`模块的函数以及使用较新的`pathlib`模块处理这些任务。
- en: Check Existence with exists()
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`exists()`检查存在性。
- en: 'To verify whether the file or directory is really there or you just imagined
    it, you can provide `exists()`, with a relative or absolute pathname, as demonstrated
    here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证文件或目录是否确实存在，或者您只是想象了它，您可以提供`exists()`，并提供相对或绝对路径名，如此示例所示：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Check Type with isfile()
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`isfile()`检查类型。
- en: The functions in this section check whether a name refers to a file, directory,
    or symbolic link (see the examples that follow for a discussion of links).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分中的函数检查名称是否引用文件、目录或符号链接（有关链接讨论的示例，请参见后续内容）。
- en: 'The first function we’ll look at, `isfile`, asks a simple question: is it a
    plain old law-abiding file?'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看的第一个函数`isfile`，它提出一个简单的问题：这是一个普通的老实文件吗？
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here’s how you determine a directory:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是确定目录的方法：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A single dot (`.`) is shorthand for the current directory, and two dots (`..`)
    stands for the parent directory. These always exist, so a statement such as the
    following will always report `True`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 单个点(`.`)是当前目录的简写，两个点(`..`)代表父目录。 这些始终存在，因此像以下语句将始终报告`True`：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `os` module contains many functions dealing with *pathnames* (fully qualified
    filenames, starting with `/` and including all parents). One such function, `isabs()`,
    determines whether its argument is an absolute pathname. The argument doesn’t
    need to be the name of a real file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`模块包含许多处理*路径名*（完全合格的文件名，以`/`开头并包括所有父级）的函数。 其中一个函数`isabs()`确定其参数是否为绝对路径名。
    参数不需要是真实文件的名称：'
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Copy with copy()
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`copy()`复制。
- en: 'The `copy()` function comes from another module, `shutil`. This example copies
    the file *oops.txt* to the file *ohno.txt*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy()`函数来自另一个模块`shutil`。 例如，将文件*oops.txt*复制到文件*ohno.txt*：'
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `shutil.move()` function copies a file and then removes the original.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutil.move()`函数复制文件，然后删除原始文件。'
- en: Change Name with rename()
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`rename()`函数更改名称。
- en: 'This function does exactly what it says. In the example here, it renames *ohno.txt*
    to *ohwell.txt*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数正如其名称所示。 在此示例中，它将*ohno.txt*重命名为*ohwell.txt*：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Link with link() or symlink()
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`link()`或`symlink()`链接。
- en: In Unix, a file exists in one place, but it can have multiple names, called
    *links*. In low-level *hard links*, it’s not easy to find all the names for a
    given file. A *symbolic link* is an alternative method that stores the new name
    as its own file, making it possible for you to get both the original and new names
    at once. The `link()` call creates a hard link, and `symlink()` makes a symbolic
    link. The `islink()` function checks whether the file is a symbolic link.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix中，文件存在于一个位置，但可以有多个名称，称为*链接*。 在低级*硬链接*中，很难找到给定文件的所有名称。 *符号链接*是一种替代方法，它将新名称存储为自己的文件，使您可以同时获取原始名称和新名称。
    `link()`调用创建硬链接，`symlink()`创建符号链接。 `islink()`函数检查文件是否是符号链接。
- en: 'Here’s how to make a hard link to the existing file *oops.txt* from the new
    file *yikes.txt*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何为现有文件*oops.txt*创建硬链接到新文件*yikes.txt*的方法：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To create a symbolic link to the existing file *oops.txt* from the new file
    *jeepers.txt*, use the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要为现有文件*oops.txt*创建到新文件*jeepers.txt*的符号链接，请使用以下命令：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Change Permissions with chmod()
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`chmod()`更改权限。
- en: 'On a Unix system, `chmod()` changes file permissions. There are read, write,
    and execute permissions for the user (that’s usually you, if you created the file),
    the main group that the user is in, and the rest of the world. The command takes
    an intensely compressed octal (base 8) value that combines user, group, and other
    permissions. For instance, to make *oops.txt* readable only by its owner, type
    the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 系统中，`chmod()` 改变文件权限。对于用户（通常是你，如果你创建了该文件）、用户所在的主要组和其余世界，有读、写和执行权限。该命令使用紧凑的八进制（基数
    8）值，结合用户、组和其他权限。例如，要使 *oops.txt* 只能由其所有者读取，输入以下内容：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you don’t want to deal with cryptic octal values and would rather deal with
    (slightly less) obscure cryptic symbols, you can import some constants from the
    `stat` module and use a statement such as the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想处理晦涩的八进制值，而宁愿处理（稍微不那么）晦涩的符号，可以从 `stat` 模块导入一些常量，并使用如下语句：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Change Ownership with chown()
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 chown() 更改所有权
- en: 'This function is also Unix/Linux/Mac–specific. You can change the owner and/or
    group ownership of a file by specifying the numeric user ID (*uid*) and group
    ID (*gid*):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数同样适用于 Unix/Linux/Mac。你可以通过指定数值用户 ID (*uid*) 和组 ID (*gid*) 来改变文件的所有者和/或组所有权：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Delete a File with remove()
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 remove() 删除文件
- en: 'In this snippet, we use the `remove()` function and say farewell to *oops.txt*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用 `remove()` 函数，告别 *oops.txt*：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Directory Operations
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录操作
- en: In most operating systems, files exist in a hierarchy of *directories* (often
    called *folders*). The container of all of these files and directories is a *filesystem*
    (sometimes called a *volume*). The standard `os` module deals with operating specifics
    such as these and provides the following functions with which you can manipulate
    them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数操作系统中，文件存在于层级结构的*目录*（通常称为*文件夹*）中。所有这些文件和目录的容器是一个*文件系统*（有时称为*卷*）。标准的 `os`
    模块处理这些操作系统的具体细节，并提供以下函数，用于对它们进行操作。
- en: Create with mkdir()
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 mkdir() 创建
- en: 'This example shows how to create a directory called `poems` to store that precious
    verse:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了如何创建一个名为 `poems` 的目录来存储那些珍贵的诗句：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Delete with rmdir()
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 rmdir() 删除目录
- en: 'Upon second thought,^([2](ch14.html#idm45794983042312)) you decide you don’t
    need that directory after all. Here’s how to delete it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 经过重新考虑^([2](ch14.html#idm45794983042312))，你决定其实根本不需要那个目录。以下是如何删除它的方法：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: List Contents with listdir()
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 listdir() 列出内容
- en: 'OK, take two; let’s make `poems` again, with some contents:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，重来一次；让我们再次创建 `poems`，并添加一些内容：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now get a list of its contents (none so far):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在获取其内容列表（到目前为止还没有）：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, make a subdirectory:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个子目录：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a file in this subdirectory (don’t type all these lines unless you really
    feel poetic; just make sure you begin and end with matching quotes, either single
    or tripled):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个子目录中创建一个文件（如果你真的感觉有诗意，才输入所有这些行；确保使用匹配的单引号或三重引号开头和结尾）：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, let’s see what we have. It had better be there:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，让我们看看我们有什么。它最好在那里： '
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Change Current Directory with chdir()
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 chdir() 更改当前目录
- en: 'With this function, you can go from one directory to another. Let’s leave the
    current directory and spend a little time in `poems`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数，你可以从一个目录切换到另一个目录。让我们离开当前目录，花一点时间在 `poems` 中：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: List Matching Files with glob()
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 glob() 列出匹配的文件
- en: 'The `glob()` function matches file or directory names by using Unix shell rules
    rather than the more complete regular expression syntax. Here are those rules:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`glob()` 函数使用 Unix shell 规则而非更完整的正则表达式语法来匹配文件或目录名。以下是这些规则：'
- en: '`*` matches everything (`re` would expect `.*`)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 匹配任何内容（`re` 应该期望 `.*`）'
- en: '`?` matches a single character'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` 匹配一个单字符'
- en: '`[abc]` matches character `a`, `b`, or `c`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[abc]` 匹配字符 `a`、`b` 或 `c`'
- en: '`[!abc]` matches any character *except* `a`, `b`, or `c`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[!abc]` 匹配除了 `a`、`b` 或 `c` 之外的任何字符'
- en: 'Try getting all files or directories that begin with `m`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试获取所有以 `m` 开头的文件或目录：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How about any two-letter files or directories?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 任何两个字母的文件或目录如何？
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'I’m thinking of an eight-letter word that begins with `m` and ends with `e`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我在想一个以 `m` 开头、以 `e` 结尾的八个字母的单词：
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: What about anything that begins with a `k`, `l`, or `m`, and ends with `e`?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 那么任何以 `k`、`l` 或 `m` 开头、以 `e` 结尾的内容呢？
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Pathnames
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径名
- en: 'Almost all of our computers use hierarchical filesystems, with directories
    (“folders”) containing files and other directories, down to various levels. When
    you want to refer to a specific file or directory, you need its *pathname*: the
    sequence of directories needed to get there, either *absolute* from the top (the
    *root*), or *relative* to your current directory.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的计算机都使用层次化文件系统，其中目录（“文件夹”）包含文件和其他目录，向下延伸到不同的层级。当您想引用特定的文件或目录时，您需要它的 *路径名*：到达那里所需的目录序列，可以是
    *绝对* 从顶部（*根*）或 *相对* 到您当前目录。
- en: You’ll often hear people confusing a forward *slash* (`'/'`, not the Guns N’
    Roses guy) and *backslash* (`'\'`).^([3](ch14.html#idm45794982611688)) Unix and
    Macs (and web URLs) use slash as the *path separator*, and Windows uses backslash.^([4](ch14.html#idm45794982605768))
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当您指定名称时，您经常会听到人们混淆正斜杠（`'/'`，而不是 Guns N’ Roses 的家伙）和反斜杠（`'\'`）。^([3](ch14.html#idm45794982611688))
    Unix 和 Mac（以及 Web URL）使用正斜杠作为 *路径分隔符*，而 Windows 使用反斜杠。^([4](ch14.html#idm45794982605768))
- en: 'Python lets you use slash as the path separator when you’re specifying names.
    On Windows, you can use backslash, but you know that backslash is a ubiquitous
    escape character in Python, so you have to double it everywhere, or use Python’s
    raw strings:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许您在指定名称时使用斜杠作为路径分隔符。在 Windows 上，您可以使用反斜杠，但是您知道反斜杠在 Python 中是普遍的转义字符，所以您必须在所有地方加倍使用它，或者使用
    Python 的原始字符串：
- en: '[PRE56]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When you’re building a pathname, you can do the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建路径名时，您可以做以下操作：
- en: Use the appropriate path separation character (`'/'` or `'\'`)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用适当的路径分隔符 (`'/'` 或 `'\'`)
- en: Build a pathname (see [“Build a Pathname with os.path.join()”](#os_path_join))
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 os.path.join() 构建路径名（参见 [“使用 os.path.join() 构建路径名”](#os_path_join)）
- en: Use pathlib (see [“Use pathlib”](#pathlib))
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 pathlib（参见 [“使用 pathlib”](#pathlib)）
- en: Get a Pathname with abspath()
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 abspath() 获取路径名
- en: 'This function expands a relative name to an absolute one. If your current directory
    is */usr/gaberlunzie* and the file *oops.txt* is there, you can type the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将相对名扩展为绝对名。如果您的当前目录是 */usr/gaberlunzie* 并且文件 *oops.txt* 就在那里，您可以输入以下内容：
- en: '[PRE57]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Get a symlink Pathname with realpath()
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 realpath() 获取符号链接路径名
- en: 'In one of the earlier sections, we made a symbolic link to *oops.txt* from
    the new file *jeepers.txt*. In circumstances such as this, you can get the name
    of *oops.txt* from *jeepers.txt* by using the `realpath()` function, as shown
    here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在较早的某一部分中，我们从新文件 *jeepers.txt* 创造了对 *oops.txt* 的符号链接。在这种情况下，您可以使用 `realpath()`
    函数从 *jeepers.txt* 获取 *oops.txt* 的名称，如下所示：
- en: '[PRE58]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Build a Pathname with os.path.join()
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 os.path.join() 构建路径名
- en: 'When you’re constructing a multipart pathname, you can call `os.path.join()`
    to combine them pairwise with the proper path separation character for your operating
    system:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建一个多部分的路径名时，您可以使用 `os.path.join()` 将它们成对地组合，使用适合您操作系统的正确路径分隔符：
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If I run this on a Mac or Linux box, I get this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在 Mac 或 Linux 系统上运行这个程序，我会得到这个结果：
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Running on Windows would produce this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上运行会产生这个结果：
- en: '[PRE61]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: But if the same code produces different result depending on where it’s run,
    that could be a problem. The new `pathlib` module is a portable solution to this.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果相同的代码在不同位置运行会产生不同的结果，这可能是一个问题。新的 `pathlib` 模块是这个问题的一个便携解决方案。
- en: Use pathlib
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pathlib
- en: Python added the `pathlib` module in version 3.4. It’s an alternative to the
    `os.path` modules that I just described. But why do we need another module?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在版本 3.4 中添加了 `pathlib` 模块。它是我刚刚描述的 `os.path` 模块的一个替代方案。但我们为什么需要另一个模块呢？
- en: 'Rather that treating filesystem pathnames as strings, it introduces the `Path`
    object to treat them at a little higher level. Create a `Path` with the `Path()`
    class, and then knit your path together with bare slashes (not `''/''` characters):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是把文件系统路径名当作字符串，而是引入了 `Path` 对象来在稍高一级处理它们。使用 `Path()` 类创建一个 `Path`，然后用裸斜线（而不是
    `'/'` 字符）将您的路径编织在一起：
- en: '[PRE62]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This slash trick took advantage of Python’s [“Magic Methods”](ch10.html#magic_methods).
    A `Path` can tell you a bit about itself:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个斜杠技巧利用了 Python 的 [“魔术方法”](ch10.html#magic_methods)。一个 `Path` 可以告诉您关于自己的一些信息：
- en: '[PRE63]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You can feed `file_path` to `open()` as you would any filename or pathname string.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像对待任何文件名或路径名字符串一样将 `file_path` 提供给 `open()`。
- en: 'You can also see what would happen if you ran this program on another system
    or if you needed to generate foreign pathnames on your computer:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到如果在另一个系统上运行此程序会发生什么，或者如果需要在您的计算机上生成外国路径名：
- en: '[PRE64]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: See the [docs](https://oreil.ly/yN87f) for all the details.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[文档](https://oreil.ly/yN87f)以获取所有细节。
- en: BytesIO and StringIO
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BytesIO 和 StringIO
- en: You’ve seen how to modify data in memory and how to get data in and out of files.
    What do you do if you have in-memory data, but want to call a function that expects
    a file (or the reverse)? You’d want to modify the data and pass those bytes or
    characters around, without reading and writing temporary files.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何修改内存中的数据以及如何将数据读取到文件中和从文件中获取数据。如果你有内存中的数据，但想调用一个期望文件的函数（或者反过来），你会怎么做？你想修改数据并传递这些字节或字符，而不是读取和写入临时文件。
- en: You can use `io.BytesIO` for binary data (`bytes`) and `io.StringIO` for text
    data (`str`). Using either of these wraps data as a *file-like object*, suitable
    to use with all the file functions you’ve seen in this chapter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `io.BytesIO` 处理二进制数据（`bytes`）和 `io.StringIO` 处理文本数据（`str`）。使用其中任何一个都可以将数据包装为*类文件对象*，适用于本章中介绍的所有文件函数。
- en: One use case for this is data format conversion. Let’s apply this to the PIL
    library (details coming in [“PIL and Pillow”](ch20.html#pil)), which reads and
    writes image data. The first argument to its `Image` object’s `open()` and `save()`
    methods is a filename *or a file-like object*. The code in [Example 14-1](#ex1401)
    uses `BytesIO` to read *and* write in-memory data. It reads one or more image
    files from the command line, converts its image data to three different formats,
    and prints the length and first 10 bytes of these outputs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的一个用例是数据格式转换。让我们将其应用于 PIL 库（详细信息将在[“PIL 和 Pillow”](ch20.html#pil)中介绍），该库读取和写入图像数据。其
    `Image` 对象的 `open()` 和 `save()` 方法的第一个参数是文件名*或*类文件对象。[示例 14-1](#ex1401) 中的代码使用
    `BytesIO` 在内存中读取 *并且* 写入数据。它从命令行读取一个或多个图像文件，将其图像数据转换为三种不同的格式，并打印这些输出的长度和前 10 个字节。
- en: Example 14-1\. convert_image.py
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 14-1\. convert_image.py
- en: '[PRE65]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-236
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Because it acts like a file, you can `seek()`, `read()`, and `write()` a `BytesIO`
    object just like a normal file; if you did a `seek()` followed by a `read()`,
    you would get only the bytes from that seek position to the end. That `getvalue()`
    returns all the bytes in the `BytesIO` object.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它的行为类似于文件，所以你可以像处理普通文件一样使用 `seek()`、`read()` 和 `write()` 方法处理 `BytesIO` 对象；如果你执行了
    `seek()` 后跟着一个 `read()`，你将只获得从该 seek 位置到结尾的字节。`getvalue()` 返回 `BytesIO` 对象中的所有字节。
- en: 'Here’s the output, using an input image file that you’ll see in [Chapter 20](ch20.html#ch_art):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果，使用了你将在[第 20 章](ch20.html#ch_art)中看到的输入图像文件：
- en: '[PRE66]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Coming Up
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将到来
- en: The next chapter is a bit more complex. It deals with *concurrency* (ways of
    doing multiple things at about the same time) and *processes* (running programs).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章内容稍微复杂一些。它涉及*并发*（即大约同时执行多个任务的方式）和*进程*（运行程序）。
- en: Things to Do
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要做的事情
- en: 14.1 List the files in your current directory.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 14.1 列出当前目录中的文件。
- en: 14.2 List the files in your parent directory.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 14.2 列出父目录中的文件。
- en: 14.3 Assign the string `'This is a test of the emergency text system'` to the
    variable `test1`, and write `test1` to a file called *test.txt*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 14.3 将字符串 `'This is a test of the emergency text system'` 赋值给变量 `test1`，并将 `test1`
    写入名为 *test.txt* 的文件。
- en: 14.4 Open the file *test.txt* and read its contents into the string `test2`.
    Are `test1` and `test2` the same?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 14.4 打开文件 *test.txt* 并将其内容读取到字符串 `test2` 中。`test1` 和 `test2` 是否相同？
- en: ^([1](ch14.html#idm45794985259544-marker)) In the first manuscript of this book,
    I said *general* relativity, and was kindly corrected by a physicist reviewer.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch14.html#idm45794985259544-marker)) 在本书的第一份手稿中，我说的是*广义*相对论，被一位物理学家审阅者友善地纠正了。
- en: ^([2](ch14.html#idm45794983042312-marker)) Why is it never first?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch14.html#idm45794983042312-marker)) 为什么它从来都不是第一个？
- en: '^([3](ch14.html#idm45794982611688-marker)) One way to remember: forward slash
    tilts *forward*, backslash tilts *back*.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch14.html#idm45794982611688-marker)) 一种记忆方法是：斜杠向*前*倾斜，反斜杠向*后*倾斜。
- en: ^([4](ch14.html#idm45794982605768-marker)) QDOS was the operating system that
    Bill Gates bought for $50,000 to have “MS-DOS” when IBM came calling about their
    first PC. It mimicked CP/M, which used slashes for command-line arguments. When
    MS-DOS later added folders, it had to use backslashes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch14.html#idm45794982605768-marker)) 当 IBM 联系比尔·盖茨，询问他们的第一台个人电脑时，他以 $50,000
    购买了操作系统 QDOS，以获得“MS-DOS”。它模仿了使用斜杠作为命令行参数的 CP/M。当 MS-DOS 后来添加了文件夹时，它不得不使用反斜杠。
