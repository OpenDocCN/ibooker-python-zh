<html><head></head><body>
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 12. Subtyping" class="preface"><div class="preface" id="subtyping">
<h1 class="calibre10" id="calibre_pb_0"><span class="calibre">Chapter 12. </span>Subtyping</h1>


<p class="author1">Most of <a data-type="xref" href="part0011.html#part_2" class="calibre5">Part II</a> has focused on creating your own types and defining interfaces.<a data-type="indexterm" data-primary="subtyping" id="ix_subtyp" class="calibre5"/> These types do not exist in isolation; types are often related to one another. So far, you’ve seen <em class="calibre6">composition</em>, where types use other types as members.<a data-type="indexterm" data-primary="composition" id="idm45644737737912" class="calibre5"/> In this chapter, you’ll learn about <em class="calibre6">subtyping</em>, or creating types based on other types.</p>

<p class="author1">When applied correctly, subtyping makes it incredibly easy to extend your codebase. You can introduce new behaviors without ever worrying about breaking the rest of your codebase. However, you must be dilligent when creating a subtyping relationship; if you do it poorly, you can decrease the robustness of your codebase in unexpected ways.</p>

<p class="author1">I’ll start with one of the most common subtype relationships: inheritance. Inheritance <a data-type="indexterm" data-primary="inheritance" id="ix_inhe" class="calibre5"/>is seen as a traditional pillar of object-oriented programming (OOP).<sup class="calibre11"><a data-type="noteref" id="idm45644737734424-marker" href="part0016_split_007.html#idm45644737734424" class="calibre5">1</a></sup> Inheritance can be tricky if not applied correctly. I’ll then move on to other forms of subtyping present in the Python programming language. You’ll also learn about one of the more fundamental SOLID design principles, the Liskov Substitution Principle. This chapter will help you make sense of when and where subtyping is appropriate and where it is not.</p>






</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 12. Subtyping" class="preface">
<div class="preface" id="subtyping">
<section data-type="sect1" class="preface" data-pdf-bookmark="Inheritance"><div class="preface" id="idm45644737732152">
<h1 class="calibre12" id="calibre_pb_1">Inheritance</h1>

<p class="author1">Most <a data-type="indexterm" data-primary="subtyping" data-secondary="inheritance" id="ix_subtypinh" class="calibre5"/>developers immediately think of inheritance when they talk about subtyping. <em class="calibre6">Inheritance</em> is a way of creating a new type from another type, copying all the behaviors into the new type.<a data-type="indexterm" data-primary="child classes" id="idm45644737727688" class="calibre5"/><a data-type="indexterm" data-primary="derived classes" id="idm45644737726984" class="calibre5"/><a data-type="indexterm" data-primary="subclasses" id="idm45644737726312" class="calibre5"/> This new type is known as a <em class="calibre6">child class</em>, <em class="calibre6">derived class</em>, or <em class="calibre6">subclass</em>. In contrast, the type being inherited from is known as a <em class="calibre6">parent class</em>, <em class="calibre6">base class</em>, or <em class="calibre6">superclass</em>. <a data-type="indexterm" data-primary="base classes" id="idm45644737722920" class="calibre5"/>When talking about types in this way, we say that the relationship is an <em class="calibre6">is-a</em> relationship. <a data-type="indexterm" data-primary="is-a relationship" id="idm45644737721672" class="calibre5"/>Any object of a derived class is also an instance of a base class.</p>

<p class="author1">To illustrate this, you are going to design an app that helps owners of restaurants organize operations (tracking finances, customizing menus, etc.). For this scenario, a restaurant has the following behaviors:</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">A restaurant has the following attributes: a name, a location, a list of employees and their schedules, inventory, a menu, and current finances. All of these attributes are mutable; even a restaurant can be renamed or change locations. When a restaurant changes locations, its location attribute reflects its final <span class="calibre">destination</span>.</p>
</li>
<li class="calibre9">
<p class="author1">An owner can own multiple restaurants.</p>
</li>
<li class="calibre9">
<p class="author1">Employees can be moved from one restaurant to another, but they cannot work at two restaurants at the same time.</p>
</li>
<li class="calibre9">
<p class="author1">When a dish is ordered, the ingredients used are removed from the inventory. When a specific item is depleted in the inventory, any dish requiring the ingredient is no longer available through the menu.</p>
</li>
<li class="calibre9">
<p class="author1">Whenever a menu item is sold, the restaurant’s funds increase. Whenever new inventory is purchased, the restaurant’s funds decrease. For every hour that an employee works at that restaurant, the restaurant’s funds decrease according to the employee’s salary and/or wage.</p>
</li>
</ul>

<p class="author1">Restaurant owners will use this app to view all their restaurants, manage their inventory, and track profits in real time.</p>

<p class="author1">Since there are specific<a data-type="indexterm" data-primary="invariants" data-secondary="Restaurant class example" id="idm45644737712920" class="calibre5"/> invariants about the restaurant, I’ll use a class to represent a restaurant:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">restaurant</code> <code class="k">import</code> <code class="n">geo</code>
<code class="k">from</code> <code class="nn">restaurant</code> <code class="k">import</code> <code class="n">operations</code> <code class="k">as</code> <code class="n">ops</code>
<code class="k">class</code> <code class="nc">Restaurant</code><code class="calibre17">:</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code>
                 <code class="n">name</code><code class="calibre17">:</code> <code class="nb">str</code><code class="calibre17">,</code>
                 <code class="n">location</code><code class="calibre17">:</code> <code class="n">geo</code><code class="calibre17">.</code><code class="n">Coordinates</code><code class="calibre17">,</code>
                 <code class="n">employees</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">ops</code><code class="calibre17">.</code><code class="n">Employee</code><code class="calibre17">],</code>
                 <code class="n">inventory</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">ops</code><code class="calibre17">.</code><code class="n">Ingredient</code><code class="calibre17">],</code>
                 <code class="n">menu</code><code class="calibre17">:</code> <code class="n">ops</code><code class="calibre17">.</code><code class="n">Menu</code><code class="calibre17">,</code>
                 <code class="n">finances</code><code class="calibre17">:</code> <code class="n">ops</code><code class="calibre17">.</code><code class="n">Finances</code><code class="calibre17">):</code>
        <code class="c"># ... snip ...</code>
        <code class="c"># note that location refers to where the restaurant is located when</code>
        <code class="c"># serving food</code>

    <code class="k">def</code> <code class="nf">transfer_employees</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code>
                           <code class="n">employees</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">ops</code><code class="calibre17">.</code><code class="n">Employee</code><code class="calibre17">],</code>
                           <code class="n">restaurant</code><code class="calibre17">:</code> <code class="s">'Restaurant'</code><code class="calibre17">):</code>
        <code class="c"># ... snip ...</code>

    <code class="k">def</code> <code class="nf">order_dish</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">dish</code><code class="calibre17">:</code> <code class="n">ops</code><code class="calibre17">.</code><code class="n">Dish</code><code class="calibre17">):</code>
        <code class="c"># ... snip ..</code>

    <code class="k">def</code> <code class="nf">add_inventory</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">ingredients</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">ops</code><code class="calibre17">.</code><code class="n">Ingredient</code><code class="calibre17">],</code>
                      <code class="n">cost_in_cents</code><code class="calibre17">:</code> <code class="nb">int</code><code class="calibre17">):</code>
        <code class="c"># ... snip ...</code>

    <code class="k">def</code> <code class="nf">register_hours_employee_worked</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code>
                                       <code class="n">employee</code><code class="calibre17">:</code> <code class="n">Employee</code><code class="calibre17">,</code>
                                       <code class="n">minutes_worked</code><code class="calibre17">:</code> <code class="nb">int</code><code class="calibre17">):</code>
        <code class="c"># ... snip ...</code>

    <code class="k">def</code> <code class="nf">get_restaurant_data</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="n">ops</code><code class="calibre17">.</code><code class="n">RestaurantData</code><code class="calibre17">:</code>
        <code class="c"># ... snip ...</code>

    <code class="k">def</code> <code class="nf">change_menu</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">menu</code><code class="calibre17">:</code> <code class="n">ops</code><code class="calibre17">.</code><code class="n">Menu</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">__menu</code> <code class="calibre17">=</code> <code class="n">menu</code>

    <code class="k">def</code> <code class="nf">move_location</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">new_location</code><code class="calibre17">:</code> <code class="n">geo</code><code class="calibre17">.</code><code class="n">Coordinates</code><code class="calibre17">):</code>
        <code class="c"># ... snip ...</code></pre>

<p class="author1">In addition to a “standard” restaurant, as described above, there are a few “specialized” restaurants: a food truck and a pop-up stall.</p>

<p class="author1">Food trucks are mobile: they drive around to different spots and change their menu based on the occasion. Pop-up stalls are transient; they appear for a limited time with a limited menu (typically for some sort of event like a festival or fair). While slightly different in how they operate, both a food truck and pop-up stall are still restaurants.<a data-type="indexterm" data-primary="is-a relationship" id="idm45644737683960" class="calibre5"/> This is what I mean when I say an <em class="calibre6">is-a</em> relationship—a food truck <em class="calibre6">is a</em> restaurant and a pop-up stall <em class="calibre6">is a</em> restaurant. Because this is an <em class="calibre6">is-a</em> relationship, inheritance is an appropriate construct to use.</p>

<p class="author1">You denote inheritance<a data-type="indexterm" data-primary="inheritance" data-secondary="denoting when defining derived class" id="idm45644737522296" class="calibre5"/><a data-type="indexterm" data-primary="base classes" data-secondary="denoting inheritance in derived class" id="idm45644737521272" class="calibre5"/> by specifying the base class when you define your derived class:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">FoodTruck</code><code class="calibre17">(</code><code class="n">Restaurant</code><code class="calibre17">):</code>
    <code class="c">#... snip ...</code>

<code class="k">class</code> <code class="nc">PopUpStall</code><code class="calibre17">(</code><code class="n">Restaurant</code><code class="calibre17">):</code>
    <code class="c"># ... snip ...</code></pre>

<p class="author1"><a data-type="xref" href="part0016_split_001.html#inheritance_uml" class="calibre5">Figure 12-1</a> shows how this relationship is typically drawn.</p>

<figure class="calibre36"><div id="inheritance_uml" class="figure">
<img src="../images/00016.gif" alt="Inheritance tree of restaurants" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 12-1. </span>Inheritance tree of restaurants</h6>
</div></figure>

<p class="author1">By defining inheritance in this fashion, you ensure that the derived classes will inherit all the methods and attributes from the base class, without needing to redefine them.</p>

<p class="author1">This means that if you were to instantiate one of the derived classes, such as <code class="calibre17">FoodTruck</code>, you would be able to use all the same methods as if you were interacting with a <code class="calibre17">Restaurant</code>.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">food_truck</code> <code class="calibre17">=</code> <code class="n">FoodTruck</code><code class="calibre17">(</code><code class="s">"Pat's Food Truck"</code><code class="calibre17">,</code> <code class="n">location</code><code class="calibre17">,</code> <code class="n">employees</code><code class="calibre17">,</code>
                       <code class="n">inventory</code><code class="calibre17">,</code> <code class="n">menu</code><code class="calibre17">,</code> <code class="n">finances</code><code class="calibre17">)</code>
<code class="n">food_truck</code><code class="calibre17">.</code><code class="n">order_dish</code><code class="calibre17">(</code><code class="n">Dish</code><code class="calibre17">(</code><code class="s">'Pasta with Sausage'</code><code class="calibre17">))</code>
<code class="n">food_truck</code><code class="calibre17">.</code><code class="n">move_location</code><code class="calibre17">(</code><code class="n">geo</code><code class="calibre17">.</code><code class="n">find_coordinates</code><code class="calibre17">(</code><code class="s">'Huntsville, Alabama'</code><code class="calibre17">))</code></pre>

<p class="author1">What’s really nice about this is that a derived class can be passed to a function expecting a base class and the typechecker will not complain one bit:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">display_restaurant_data</code><code class="calibre17">(</code><code class="n">restaurant</code><code class="calibre17">:</code> <code class="n">Restaurant</code><code class="calibre17">):</code>
    <code class="n">data</code> <code class="calibre17">=</code> <code class="n">restaurant</code><code class="calibre17">.</code><code class="n">get_restaurant_data</code><code class="calibre17">()</code>
    <code class="c"># ... snip drawing code here ...</code>

<code class="n">restaurants</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">Restaurant</code><code class="calibre17">]</code> <code class="calibre17">=</code> <code class="calibre17">[</code><code class="n">food_truck</code><code class="calibre17">]</code>
<code class="k">for</code> <code class="n">restaurant</code> <code class="calibre19">in</code> <code class="n">restaurants</code><code class="calibre17">:</code>
    <code class="n">display_restaurant_data</code><code class="calibre17">(</code><code class="n">restaurant</code><code class="calibre17">)</code></pre>

<p class="author1">By default, the derived class operates exactly like the base class.<a data-type="indexterm" data-primary="derived classes" data-secondary="overriding or redefining base class methods" id="idm45644737431048" class="calibre5"/> If you’d like the derived class to do something different, you can override methods or redefine the methods in the derived class.<a data-type="indexterm" data-primary="inheritance" data-secondary="different behaviors in derived class" id="idm45644737307480" class="calibre5"/></p>

<p class="author1">Suppose I want my food truck to automatically drive to the next location when the location changes. For this use case, however, when asking for restaurant data, I only want the final location, not the location while the food truck is en route. Developers can call a separate method to show the current location (for use in a separate food truck–only map). I’ll set up a GPS locator in the <code class="calibre17">FoodTruck</code>’s constructor, and override <code class="calibre17">move_location</code> to start the automatic driving:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">restaurant.logging</code> <code class="k">import</code> <code class="n">log_error</code>
<code class="k">class</code> <code class="nc">FoodTruck</code><code class="calibre17">(</code><code class="n">Restaurant</code><code class="calibre17">):</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code>
                 <code class="n">name</code><code class="calibre17">:</code> <code class="nb">str</code><code class="calibre17">,</code>
                 <code class="n">location</code><code class="calibre17">:</code> <code class="n">geo</code><code class="calibre17">.</code><code class="n">Coordinates</code><code class="calibre17">,</code>
                 <code class="n">employees</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">ops</code><code class="calibre17">.</code><code class="n">Employee</code><code class="calibre17">],</code>
                 <code class="n">inventory</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">ops</code><code class="calibre17">.</code><code class="n">Ingredient</code><code class="calibre17">],</code>
                 <code class="n">menu</code><code class="calibre17">:</code> <code class="n">ops</code><code class="calibre17">:</code> <code class="n">Menu</code><code class="calibre17">,</code>
                 <code class="n">finances</code><code class="calibre17">:</code> <code class="n">ops</code><code class="calibre17">.</code><code class="n">Finances</code><code class="calibre17">):</code>
        <code class="nb">super</code><code class="calibre17">()</code><code class="calibre17">.</code><code class="calibre17">__init__</code><code class="calibre17">(</code><code class="n">name</code><code class="calibre17">,</code> <code class="n">location</code><code class="calibre17">,</code> <code class="n">employees</code><code class="calibre17">,</code><code class="n">inventory</code><code class="calibre17">,</code> <code class="n">menu</code><code class="calibre17">,</code> <code class="n">finances</code><code class="calibre17">)</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">__gps</code> <code class="calibre17">=</code> <code class="n">initialize_gps</code><code class="calibre17">()</code>

    <code class="k">def</code> <code class="nf">move_location</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">new_location</code><code class="calibre17">:</code> <code class="n">geo</code><code class="calibre17">.</code><code class="n">Coordinates</code><code class="calibre17">):</code>
        <code class="c"># schedule a task to drive us to our new location</code>
        <code class="n">schedule_auto_driving_task</code><code class="calibre17">(</code><code class="n">new_location</code><code class="calibre17">)</code>
        <code class="nb">super</code><code class="calibre17">()</code><code class="calibre17">.</code><code class="n">move_location</code><code class="calibre17">(</code><code class="n">new_location</code><code class="calibre17">)</code>

    <code class="k">def</code> <code class="nf">get_current_location</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="n">geo</code><code class="calibre17">.</code><code class="n">Coordinates</code><code class="calibre17">:</code>
        <code class="k">return</code> <code class="nb">self</code><code class="calibre17">.</code><code class="n">__gps</code><code class="calibre17">.</code><code class="n">get_coordinates</code><code class="calibre17">()</code></pre>

<p class="author1">I am using a special function, <code class="calibre17">super()</code>, to access the base class.<a data-type="indexterm" data-primary="super function" id="idm45644737302024" class="calibre5"/><a data-type="indexterm" data-primary="inheritance" data-secondary="using super function to access base class" id="idm45644737142104" class="calibre5"/> When I call <code class="calibre17">super().__init__()</code>, I am actually calling <code class="calibre17">Restaurant</code>’s constructor. When I call <code class="calibre17">super().move_location</code>, I am calling <code class="calibre17">Restaurant</code>’s <code class="calibre17">move_location</code>, not <code class="calibre17">FoodTruck</code>’s <code class="calibre17">move_location</code>. This way, the code can behave exactly like the base class.</p>

<p class="author1">Take a moment and reflect on the implications of extending code through subclassing.<a data-type="indexterm" data-primary="subclassing" data-secondary="implications of extending code through" id="idm45644737137672" class="calibre5"/> You can insert new behaviors into existing code without ever modifying that existing code. If you avoid modifying existing code, you drastically reduce the chance of introducing new bugs; you won’t inadvertently break consumers’ assumptions if you aren’t changing the code they depend on.<a data-type="indexterm" data-primary="inheritance" data-secondary="effects on maintainability" id="idm45644737136248" class="calibre5"/><a data-type="indexterm" data-primary="maintainable code" data-secondary="inheritance and" id="idm45644737135288" class="calibre5"/> A well-designed inheritance structure can greatly improve maintainability. Unfortunately, the inverse is true as well; design your inheritance poorly, and maintainability suffers. When working with inheritance, you always need to be thinking about how easy it is to substitute your code.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre32"><div class="sidebar" id="idm45644737133784">
<h5 class="calibre33">Multiple Inheritance</h5>
<p class="author1">In Python, it is possible<a data-type="indexterm" data-primary="multiple inheritance" id="idm45644737132216" class="calibre5"/><a data-type="indexterm" data-primary="inheritance" data-secondary="from multiple classes" data-secondary-sortas="multiple" id="idm45644737131512" class="calibre5"/> to inherit from multiple classes:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">FoodTruck</code><code class="o">(</code><code class="n">Restaurant</code><code class="o">,</code> <code class="n">Vehicle</code><code class="o">):</code>
    <code class="c"># ... snip ...</code></pre>

<p class="author1">In this case, you inherit all the methods and attributes from both base classes. When you call <code class="calibre17">super()</code>, you now have to decide exactly which class is initialized. This can get very confusing for beginners, and there is a complex set of rules governing the resolution order of methods.<a data-type="indexterm" data-primary="Method Resolution Ordering (MRO)" id="idm45644737122952" class="calibre5"/> You can learn more about Method Resolution Ordering (MRO) and how multiple base classes interact in the <a href="https://oreil.ly/BZox9" class="calibre5">Python documentation</a>.</p>

<p class="author1">Do not reach for multiple inheritance often.<a data-type="indexterm" data-primary="invariants" data-secondary="multiple inheritance and" id="idm45644737121048" class="calibre5"/> When a single class inherits two separate sets of invariants from its base classes, it creates extra cognitive burden for your readers. They not only have to keep two sets of invariants in their head but also the potential interactions between those invariants. Furthermore, the complex rules surrounding MRO make it incredibly easy to make mistakes if you don’t fully understand Python’s behavior. For the cases where you absolutely must use multiple inheritance, document it well with comments to explain why you need it and how you’re using it.</p>

<p class="author1">However, there is<a data-type="indexterm" data-primary="mixins" id="idm45644737119016" class="calibre5"/> one case that I am fond of for multiple inheritance: mixins. Mixins are classes that you can inherit generic functionality from. These base classes typically do not contain any invariants or data; they are just a set of methods that are not intended to be overridden.</p>

<p class="author1">For example, in the Python standard library, there are abstractions for creating a TCP socket server:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">socketserver</code> <code class="k">import</code> <code class="n">TCPServer</code>
<code class="k">class</code> <code class="nc">Server</code><code class="o">(</code><code class="n">TCPServer</code><code class="o">):</code>
    <code class="c"># ... snip ...</code></pre>

<p class="author1">You can customize this server to use multiple threads by also inheriting <code class="calibre17">socketserver.ThreadingMixIn</code>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">socketserver</code> <code class="k">import</code> <code class="n">TCPServer</code><code class="o">,</code> <code class="n">ThreadingMixIn</code>
<code class="k">class</code> <code class="nc">Server</code><code class="o">(</code><code class="n">TCPServer</code><code class="o">,</code> <code class="n">ThreadingMixIn</code><code class="o">):</code>
    <code class="c"># ... snip ...</code></pre>

<p class="author1">This mixin does not bring in any invariants, and none of its methods need to be called or overridden from the derived class. Just the mere act of inheriting the mixin provides everything you need. This simplification makes it much easier for maintainers to reason about your class.<a data-type="indexterm" data-primary="subtyping" data-secondary="inheritance" data-startref="ix_subtypinh" id="idm45644737076584" class="calibre5"/><a data-type="indexterm" data-primary="inheritance" data-startref="ix_inhe" id="idm45644737075496" class="calibre5"/></p>
</div></aside>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 12. Subtyping" class="preface">
<div class="preface" id="subtyping">
<section data-type="sect1" data-pdf-bookmark="Substitutability" class="preface"><div class="preface" id="idm45644737731368">
<h1 class="calibre12" id="calibre_pb_2">Substitutability</h1>

<p class="author1">As described earlier, inheritance is all about modeling an <em class="calibre6">is-a</em> relationship.<a data-type="indexterm" data-primary="subtyping" data-secondary="substitutability" id="ix_subtypsub" class="calibre5"/><a data-type="indexterm" data-primary="substitutability" id="ix_subs" class="calibre5"/> Describing something with an <em class="calibre6">is-a</em> relationship may sound simple, but you’d be surprised just how wrong things can go. To model <em class="calibre6">is-a</em> relationships properly, you need to understand substitutability.<a data-type="indexterm" data-primary="inheritance" data-secondary="substitutability and" id="ix_inhesubs" class="calibre5"/></p>

<p class="author1"><em class="calibre6">Substitutability</em> states that when you derive from a base class, you should be able to use that derived class in every instance that you use a base class.</p>

<p class="author1">If I were to create a function that could display relevant restaurant data:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">display_restaurant</code><code class="calibre17">(</code><code class="n">restaurant</code><code class="calibre17">:</code> <code class="n">Restaurant</code><code class="calibre17">):</code>
    <code class="c"># ... snip ...</code></pre>

<p class="author1">I should be able to pass a <code class="calibre17">Restaurant</code>, a <code class="calibre17">FoodTruck</code>, or a <code class="calibre17">PopUpStall</code>, and this function should be none the wiser. Again, this sounds simple; what’s the catch?</p>

<p class="author1">There is indeed a catch. To show you, I’d like to step away from the food concept for a second, and go back to a fundamental question that any first grader should be able to answer: is a square a rectangle?</p>

<p class="author1">From your early days of school, you probably know the answer as “yes, a square is a rectangle.” A rectangle is a polygon that has four sides, and each intersection of two sides is a 90-degree angle. A square is the same, with the extra requirement that each side must be the exact same length.</p>

<p class="author1">If I were to model this with inheritance, I might do so as follows:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">Rectangle</code><code class="calibre17">:</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">height</code><code class="calibre17">:</code> <code class="nb">int</code><code class="calibre17">,</code> <code class="n">width</code><code class="calibre17">:</code> <code class="nb">int</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">_height</code> <code class="calibre17">=</code> <code class="n">height</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">_width</code> <code class="calibre17">=</code> <code class="n">width</code>

    <code class="k">def</code> <code class="nf">set_width</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">new_width</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">_width</code> <code class="calibre17">=</code> <code class="n">new_width</code>

    <code class="k">def</code> <code class="nf">set_height</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">new_height</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">_height</code> <code class="calibre17">=</code> <code class="n">new_height</code>

    <code class="k">def</code> <code class="nf">get_width</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">int</code><code class="calibre17">:</code>
        <code class="k">return</code> <code class="nb">self</code><code class="calibre17">.</code><code class="n">_width</code>

    <code class="k">def</code> <code class="nf">get_height</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">int</code><code class="calibre17">:</code>
        <code class="k">return</code> <code class="nb">self</code><code class="calibre17">.</code><code class="n">_height</code>

<code class="k">class</code> <code class="nc">Square</code><code class="calibre17">(</code><code class="n">Rectangle</code><code class="calibre17">):</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">length</code><code class="calibre17">:</code> <code class="nb">int</code><code class="calibre17">):</code>
        <code class="nb">super</code><code class="calibre17">()</code><code class="calibre17">.</code><code class="calibre17">__init__</code><code class="calibre17">(</code><code class="n">length</code><code class="calibre17">,</code> <code class="n">length</code><code class="calibre17">)</code>

    <code class="k">def</code> <code class="nf">set_side_length</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">new_length</code><code class="calibre17">):</code>
        <code class="nb">super</code><code class="calibre17">()</code><code class="calibre17">.</code><code class="n">set_width</code><code class="calibre17">(</code><code class="n">new_length</code><code class="calibre17">)</code>
        <code class="nb">super</code><code class="calibre17">()</code><code class="calibre17">.</code><code class="n">set_height</code><code class="calibre17">(</code><code class="n">new_length</code><code class="calibre17">)</code>

    <code class="k">def</code> <code class="nf">set_width</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">new_width</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">set_side_length</code><code class="calibre17">(</code><code class="n">new_width</code><code class="calibre17">)</code>

    <code class="k">def</code> <code class="nf">set_height</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">new_height</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">set_side_length</code><code class="calibre17">(</code><code class="n">new_height</code><code class="calibre17">)</code></pre>

<p class="author1">So yes, from a geometry perspective a square is indeed a rectangle. But this assumption when mapped to <em class="calibre6">is-a</em> relationships is flawed. Take a few moments and see if you can catch where my assumptions break down.</p>

<p class="author1">Still don’t see it? Here’s a hint: what if I asked you if a <code class="calibre17">Square</code> is <em class="calibre6">substitutable</em> for a <code class="calibre17">Rectangle</code> for every use case? Can you construct a use case for a rectangle that a square would not be substitutable for?</p>

<p class="author1">Suppose the user of the app selects squares and rectangles on a map of restaurants to gauge market size. A user can draw a shape on the map, and then expand it as needed. One of the functions to handle this is as follows:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">double_width</code><code class="calibre17">(</code><code class="n">rectangle</code><code class="calibre17">:</code> <code class="n">Rectangle</code><code class="calibre17">):</code>
    <code class="n">old_height</code> <code class="calibre17">=</code> <code class="n">rectangle</code><code class="calibre17">.</code><code class="n">get_height</code><code class="calibre17">()</code>
    <code class="n">rectangle</code><code class="calibre17">.</code><code class="n">set_width</code><code class="calibre17">(</code><code class="n">rectangle</code><code class="calibre17">.</code><code class="n">get_width</code><code class="calibre17">()</code> <code class="calibre17">*</code> <code class="mi">2</code><code class="calibre17">)</code>
    <code class="c"># check that the height is unchanged</code>
    <code class="k">assert</code> <code class="n">rectangle</code><code class="calibre17">.</code><code class="n">get_height</code><code class="calibre17">()</code> <code class="calibre17">==</code> <code class="n">old_height</code></pre>

<p class="author1">With this code, what would happen if I were to pass a <code class="calibre17">Square</code> as the argument? All of a sudden, a previously passing assertion would start to fail, since the height of a square changes when the length changes. This is catastrophic; the whole intention of inheritance is to extend functionality without breaking existing code. In this case, by passing in a <code class="calibre17">Square</code> (since it’s also a <code class="calibre17">Rectangle</code>, the type checker won’t complain), I have introduced a bug just waiting to happen.</p>

<p class="author1">This sort of mistake impacts the derived class as well. The error above stems from overriding <code class="calibre17">set_width</code> in <code class="calibre17">Square</code> so that the height is changed as well. What if <code class="calibre17">set_width</code> were not overridden and the <code class="calibre17">Rectangle</code>’s <code class="calibre17">set_width function</code> were invoked? Well, if this were the case, and you passed a <code class="calibre17">Square</code> into the function, the assertion would not fail. Instead, something far less obvious but much more detrimental happens: the function succeeds. No longer do you receive an <code class="calibre17">AssertionError</code> with a stack trace that leads you to the bug. Now, you create a square that is no longer a square; the width is changed, but the height has not. You have committed a cardinal sin and have broken the invariants of that class.</p>

<p class="author1">What makes this so sinister is that the goal of inheritance is to decouple, or remove dependencies from, existing code and new code. Implementers and consumers of the base class have no view into different derived classes at runtime. It might be that the derived class definitions live in a completely different codebase, owned by a different organization. With this error case, you make it so that every time a derived class changes, you need to look at every invocation and use of the base class and assess whether or not your changes will break code.</p>

<p class="author1">In order to solve this, you have a few options available to you. First, you can not inherit <code class="calibre17">Square</code> from <code class="calibre17">Rectangle</code> in the first place and avoid the whole problem. Second, you can restrict the methods of <code class="calibre17">Rectangle</code> so that the <code class="calibre17">Square</code> does not contradict it (such as making the fields immutable). Last, you can abolish the class hierarchy altogether and provide an <code class="calibre17">is_square</code> method in the <code class="calibre17">Rectangle</code>.</p>

<p class="author1">These sorts of errors can break your codebase in subtle ways. Consider the use case where I want to franchise my restaurants; franchisees are allowed to create their own menu, but must always have a common set of dishes.</p>

<p class="author1">Here’s a potential implementation:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">RestrictedMenuRestaurant</code><code class="calibre17">(</code><code class="n">Restaurant</code><code class="calibre17">):</code>

    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code>
                 <code class="n">name</code><code class="calibre17">:</code> <code class="nb">str</code><code class="calibre17">,</code>
                 <code class="n">location</code><code class="calibre17">:</code> <code class="n">geo</code><code class="calibre17">.</code><code class="n">Coordinates</code><code class="calibre17">,</code>
                 <code class="n">employees</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">ops</code><code class="calibre17">.</code><code class="n">Employee</code><code class="calibre17">],</code>
                 <code class="n">inventory</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">ops</code><code class="calibre17">.</code><code class="n">Ingredient</code><code class="calibre17">],</code>
                 <code class="n">menu</code><code class="calibre17">:</code> <code class="n">ops</code><code class="calibre17">.</code><code class="n">Menu</code><code class="calibre17">,</code>
                 <code class="n">finances</code><code class="calibre17">:</code> <code class="n">ops</code><code class="calibre17">.</code><code class="n">Finances</code><code class="calibre17">,</code>
                 <code class="n">restricted_items</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">ops</code><code class="calibre17">.</code><code class="n">Ingredient</code><code class="calibre17">]):</code>
        <code class="nb">super</code><code class="calibre17">()</code><code class="calibre17">.</code><code class="calibre17">__init__</code><code class="calibre17">(</code><code class="n">name</code><code class="calibre17">,</code><code class="n">location</code><code class="calibre17">,</code><code class="n">employees</code><code class="calibre17">,</code><code class="n">inventory</code><code class="calibre17">,</code><code class="n">menu</code><code class="calibre17">,</code><code class="n">finances</code><code class="calibre17">)</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">__restricted_items</code> <code class="calibre17">=</code> <code class="n">restricted_items</code>

    <code class="k">def</code> <code class="nf">change_menu</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">menu</code><code class="calibre17">:</code> <code class="n">ops</code><code class="calibre17">.</code><code class="n">Menu</code><code class="calibre17">):</code>
        <code class="k">if</code> <code class="nb">any</code><code class="calibre17">(</code><code class="calibre19">not</code> <code class="n">menu</code><code class="calibre17">.</code><code class="n">contains</code><code class="calibre17">(</code><code class="n">ingredient</code><code class="calibre17">)</code>
               <code class="k">for</code> <code class="n">ingredient</code> <code class="calibre19">in</code> <code class="nb">self</code><code class="calibre17">.</code><code class="n">__restricted_items</code><code class="calibre17">):</code>
            <code class="c"># new menus MUST contain restricted ingredients</code>
            <code class="k">return</code> <code class="nb">super</code><code class="calibre17">()</code><code class="calibre17">.</code><code class="n">change_menu</code><code class="calibre17">(</code><code class="n">menu</code><code class="calibre17">)</code></pre>

<p class="author1">In this case, the function returns early if any of the restricted items aren’t in the new menu. What seems sensible in isolation completely falls apart when put in an inheritance hierarchy. Put yourself in another developer’s shoes, one who wants to implement the UI for changing menus in the app. They see a <code class="calibre17">Restaurant</code> class, and code against that interface. When a <code class="calibre17">RestrictedMenuRestaurant</code> inevitably gets used in place of a <code class="calibre17">Restaurant</code>, the UI will try to change a menu and have no indication that the update didn’t actually occur. The only way this bug could have been caught earlier would be for a developer to trawl through the codebase looking for derived classes that broke invariants. And if there’s any theme to this book, it’s that any time a developer has to go searching through a codebase to understand one piece of code, it’s a sure sign of fragility.</p>

<p class="author1">What if I wrote the code to throw an exception instead of just returning? Unfortunately, this doesn’t solve any problems either. Now, when users change the menu of a <code class="calibre17">Restaurant</code>, they are liable to receive an exception. If they look at the <code class="calibre17">Restaurant</code> class’s code, there is no indication that they would ever need to think about an exception. Nor should they be paranoid and wrap every call in a <code class="calibre17">try...except</code> block, worried that a derived class somewhere might throw an exception.</p>

<p class="author1">In both of these cases, subtle errors are introduced when a class inherits from a base class but does not behave exactly as that base class does. These errors require a specific combination of conditions to occur: code must execute methods on the base class, it must depend on specific behavior of that base class, and a derived class breaking that behavior has to be substituted as a base class. The tricky thing is that any of these conditions can be introduced long after the original code was written.<a data-type="indexterm" data-primary="Liskov Substitution Principle" id="idm45644736589448" class="calibre5"/><a data-type="indexterm" data-primary="substitutability" data-secondary="Liskov Substitution Principle" id="idm45644736588728" class="calibre5"/> This is why substitutability is so important. As a matter of fact, the importance of substitutability is embodied in a very important principle: the Liskov Substitution Principle.</p>

<p class="author1">The Liskov Substitution Principle (LSP), named after Barbara Liskov, states the <span class="calibre">following</span>:<sup class="calibre11"><a data-type="noteref" id="idm45644736586104-marker" href="part0016_split_007.html#idm45644736586104" class="calibre5">2</a></sup></p>
<blockquote class="pcalibre2 calibre28 pcalibre1">
<p class="calibre29"><em class="calibre6">Subtype Requirement</em>: Let <code class="calibre17">Φ(X)</code> be a property provable about objects <code class="calibre17">X</code> of type <code class="calibre17">T</code>. Then <code class="calibre17">Φ(Y)</code> should be true for objects <code class="calibre17">Y</code> of type <code class="calibre17">S</code> where <code class="calibre17">S</code> is a subtype of <code class="calibre17">T</code>.</p></blockquote>

<p class="author1">Don’t let the formal notation scare you. The LSP is quite simple: in order for a subtype to exist, it must adhere to all the same properties (behaviors) as the supertype. It all comes back to substitutability. You should keep the LSP in mind whenever you think about properties of supertypes and what they mean for subtypes. When designing with inheritance, think through the following:</p>
<dl class="calibre13">
<dt class="calibre14">Invariants</dt>
<dd class="calibre15">
<p class="calibre16"><a data-type="xref" href="part0014_split_000.html#classes" class="calibre5">Chapter 10</a> focused mostly on invariants (truths about your types that must not be violated).<a data-type="indexterm" data-primary="invariants" data-secondary="subtyping and" id="idm45644736576024" class="calibre5"/> When you’re subtyping from other types, the subtypes <em class="calibre6">must</em> preserve all invariants. When I subtyped <code class="calibre17">Square</code> from <code class="calibre17">Rectangle</code>, I disregarded the invariant that heights and widths can be set independent of one another.</p>
</dd>
<dt class="calibre14">Preconditions</dt>
<dd class="calibre15">
<p class="calibre16">A precondition is anything that must be true before interacting with a type’s property (such as calling a function).<a data-type="indexterm" data-primary="preconditions" id="idm45644736572088" class="calibre5"/> If the supertype defines preconditions that happen, the subtype <em class="calibre6">must not</em> be more restrictive. This is what happened when I subtyped <code class="calibre17">RestrictedMenuRestaurant</code> from <code class="calibre17">Restaurant</code>. I added an extra precondition that certain ingredients were mandatory when changing the menu. By throwing an exception, I’ve made it so that previously good data would now fail.</p>
</dd>
<dt class="calibre14">Postcondition</dt>
<dd class="calibre15">
<p class="calibre16">A postcondition is anything that must be true after interacting with a type’s property.<a data-type="indexterm" data-primary="postconditions" id="idm45644736568424" class="calibre5"/> If a supertype defines postconditions, the subtype must not <em class="calibre6">weaken</em> those postconditions. A postcondition is weakened if any of its guarantees are not met. When I subtyped <code class="calibre17">RestrictedMenuRestaurant</code> from <code class="calibre17">Restaurant</code> and returned early instead of changing the menu, I violated a postcondition. The base class guaranteed a postcondition that the menu would be updated, regardless of the menu contents. When subtyped like I did, I could no longer guarantee that postcondition.</p>
</dd>
</dl>

<p class="author1">If at any time you break an invariant, precondition, or postcondition in an overridden function, you are begging for an error to show up.<a data-type="indexterm" data-primary="overridden functions in derived class, red flags to look for" id="idm45644736565272" class="calibre5"/> Here are some red flags that I look for in the derived class’s overridden functions when evaluating inheritance <span class="calibre">relationships</span>:</p>
<dl class="calibre13">
<dt class="calibre14">Conditionally checking arguments</dt>
<dd class="calibre15">
<p class="calibre16">A good way to know if a precondition is more restrictive is to see if there are any <code class="calibre17">if</code> statements at the beginning of the function checking the arguments being passed in.<a data-type="indexterm" data-primary="conditionally checking arguments in derived class's overridden functions" id="idm45644736561448" class="calibre5"/> If there are, there’s a good chance they are different from the base class’s checks, typically meaning that the derived class is restricting the arguments further.</p>
</dd>
<dt class="calibre14">Early return statements</dt>
<dd class="calibre15">
<p class="calibre16">If a subtype’s function returns early (in the middle of the function block), this indicates <a data-type="indexterm" data-primary="early return statements, subtype functions" id="idm45644736558968" class="calibre5"/>that the latter part of the function is not going to execute. Check that latter part for any postcondition guarantees; you don’t want to omit those by returning early.</p>
</dd>
<dt class="calibre14">Throwing an exception</dt>
<dd class="calibre15">
<p class="calibre16">Subtypes should only throw exceptions that match what the supertype throws (either exactly or a derived exception type).<a data-type="indexterm" data-primary="exceptions" data-secondary="thrown by subtypes and supertype" id="idm45644736556424" class="calibre5"/> If any exceptions are different, callers are not going to expect them, let alone write code to catch them. It’s even worse if you throw an exception when the base class doesn’t indicate any possibility of an exception at all. The most flagrant violation of this that I’ve seen is throwing <code class="calibre17">NotImplementedError</code> exceptions (or similar).</p>
</dd>
<dt class="calibre14">Not calling <code class="calibre17">super()</code></dt>
<dd class="calibre15">
<p class="calibre16">By definition of substitutability, the subtype must offer the same behavior as the supertype.<a data-type="indexterm" data-primary="super function" id="idm45644736552792" class="calibre5"/> If you aren’t calling <code class="calibre17">super()</code> as part of your subtype’s overridden functions, your subtype has no defined relationship to that behavior in code. Even if you were to copy-paste the supertype’s code into your subtype, there’s no guarantee that these will stay synchronized; a developer could make an innocuous change to the supertype’s function and not even realize that there is a subtype that needs to change as well.</p>
</dd>
</dl>

<p class="author1">You need to be extra careful when modeling types with inheritance. Any mistake can introduce subtle bugs that could have catastrophic effects. When designing with inheritance, tread with utmost caution.<a data-type="indexterm" data-primary="inheritance" data-secondary="substitutability and" data-startref="ix_inhesubs" id="idm45644736550344" class="calibre5"/></p>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 12. Subtyping" class="preface">
<div class="preface" id="subtyping">
<section data-type="sect1" data-pdf-bookmark="Substitutability" class="preface">
<div class="preface" id="idm45644737731368">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_3">Discussion Topic</h1>
<p class="author1">Have you encountered any of the red flags in your codebase? Has it led to surprising behavior when inheriting from other classes? Discuss why these break assumptions and what errors can happen in those cases.</p>
</div>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 12. Subtyping" class="preface">
<div class="preface" id="subtyping">
<section data-type="sect1" class="preface" data-pdf-bookmark="Design Considerations"><div class="preface" id="idm45644737073640">
<h1 class="calibre12" id="calibre_pb_4">Design Considerations</h1>

<p class="author1">Take precautions whenever<a data-type="indexterm" data-primary="subtyping" data-secondary="substitutability" data-startref="ix_subtypsub" id="idm45644736546008" class="calibre5"/><a data-type="indexterm" data-primary="substitutability" data-startref="ix_subs" id="idm45644736544760" class="calibre5"/> you are writing classes intended to be derived from. Your goal is to make it as easy as possible for other developers to write derived classes.<a data-type="indexterm" data-primary="base classes" data-secondary="design considerations for" id="idm45644736543528" class="calibre5"/><a data-type="indexterm" data-primary="subtyping" data-secondary="design considerations in" id="ix_subtypdes" class="calibre5"/> Here are a few guidelines for writing base classes (I’ll cover guidelines for derived classes afterward):</p>
<dl class="calibre13">
<dt class="calibre14">Don’t change invariants</dt>
<dd class="calibre15">
<p class="calibre16">Normally, changing invariants is a bad idea in the first place.<a data-type="indexterm" data-primary="invariants" data-secondary="considerations in designing base classes" id="idm45644736539368" class="calibre5"/> Countless pieces of code can depend on your types, and changing an invariant will break assumptions made on your code. Unfortunately, derived classes can break if a base class changes invariants as well. If you have to change your base class, try to only add new functionality, not modify existing functionality.</p>
</dd>
<dt class="calibre14">Be cautious tying invariants to protected fields</dt>
<dd class="calibre15">
<p class="calibre16">Protected fields are inherently meant to be interacted with by derived classes. If you tie invariants to these fields, you are fundamentally restricting what operations should be invoked. This creates a tension that other developers may not be aware of. It’s better to keep invariants to private data and force derived classes to interact with public or protected methods in order to interact with that private data.</p>
</dd>
<dt class="calibre14">Document your invariants</dt>
<dd class="calibre15">
<p class="calibre16">This is the number one most important thing you can do to help your other developers. While some invariants are representable in code (as you saw in <a data-type="xref" href="part0014_split_000.html#classes" class="calibre5">Chapter 10</a>), there are simply some invariants that cannot be mathematically proven by a computer, such as guarantees around exceptions being thrown or not. You must document these invariants when you design your base class, and make it easy for derived classes to discover them, such as in a docstring.</p>
</dd>
</dl>

<p class="author1">Ultimately, it is the derived class’s responsibility to adhere to the base class’s invariants.<a data-type="indexterm" data-primary="derived classes" data-secondary="design considerations for" id="idm45644736533000" class="calibre5"/> If you are writing a derived class, heed the following guidelines:</p>
<dl class="calibre13">
<dt class="calibre14">Know the base class invariants</dt>
<dd class="calibre15">
<p class="calibre16">You can’t write a derived class properly without knowing the invariants. It is your job to understand all the base class’s invariants in order to preserve them. Look through code, documentation, and anything else related to the class to understand what you should and should not be doing.</p>
</dd>
<dt class="calibre14">Extend functionality in the base class</dt>
<dd class="calibre15">
<p class="calibre16">If you need to write code that doesn’t jive with your current invariants, you may want to put that functionality in the base class instead. Take the example of not supporting an overridable method. Rather than throw a <code class="calibre17">NotImplementedError</code>, you could create a Boolean flag indicating functionality support in the base class instead. If you do this, take note of all the guidelines earlier in this chapter for modifying the base class.</p>
</dd>
<dt class="calibre14">Every overridden method should contain <code class="calibre17">super()</code></dt>
<dd class="calibre15">
<p class="calibre16">If you don’t call <code class="calibre17">super()</code> in an overridden method, you have no guarantee that your subclass is behaving exactly like the base class, especially if the base class changes at all in the future.<a data-type="indexterm" data-primary="super function" id="idm45644736525448" class="calibre5"/> If you are going to override a method, make sure you call <code class="calibre17">super()</code>. The only time you can get away with this is when the base method is empty (such as an abstract base class) and you are sure it will remain empty for the remainder of the codebase’s life cycle.</p>
</dd>
</dl>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 12. Subtyping" class="preface">
<div class="preface" id="subtyping">
<section data-type="sect1" class="preface" data-pdf-bookmark="Design Considerations">
<div class="preface" id="idm45644737073640">
<section data-type="sect2" data-pdf-bookmark="Composition" class="preface"><div class="preface" id="idm45644736523688">
<h2 class="calibre34" id="calibre_pb_5">Composition</h2>

<p class="author1">It’s also important to know when not to use inheritance.<a data-type="indexterm" data-primary="subtyping" data-secondary="design considerations in" data-tertiary="using composition instead of inheritance" id="idm45644736521960" class="calibre5"/><a data-type="indexterm" data-primary="composition" data-secondary="using instead of inheritance" id="idm45644736520584" class="calibre5"/><a data-type="indexterm" data-primary="inheritance" data-secondary="overuse of" id="idm45644736519624" class="calibre5"/> One of the biggest mistakes I’ve seen is using inheritance solely for the purpose of code reuse. Don’t get me wrong, inheritance is a great way to reuse code, but the primary reason for inheritance is modeling a relationship where subtypes are used in place of the supertype. If you never interact with the subtype in the code that assumes the supertype, you aren’t modeling an <em class="calibre6">is-a</em> relationship.</p>

<p class="author1">In such cases, you want to use composition, also <a data-type="indexterm" data-primary="has-a relationship" id="idm45644736517320" class="calibre5"/>known as a <em class="calibre6">has-a</em> relationship. <em class="calibre6">Composition</em> is when you put member variables inside a type. I have primarily used composition to group types together. For instance, the restaurant from earlier:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">Restaurant</code><code class="calibre17">:</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code>
                 <code class="n">name</code><code class="calibre17">:</code> <code class="nb">str</code><code class="calibre17">,</code>
                 <code class="n">location</code><code class="calibre17">:</code> <code class="n">geo</code><code class="calibre17">.</code><code class="n">Coordinates</code><code class="calibre17">,</code>
                 <code class="n">employees</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">ops</code><code class="calibre17">.</code><code class="n">Employee</code><code class="calibre17">],</code>
                 <code class="n">inventory</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">ops</code><code class="calibre17">.</code><code class="n">Ingredient</code><code class="calibre17">],</code>
                 <code class="n">menu</code><code class="calibre17">:</code> <code class="n">ops</code><code class="calibre17">:</code> <code class="n">Menu</code><code class="calibre17">,</code>
                 <code class="n">finances</code><code class="calibre17">:</code> <code class="n">ops</code><code class="calibre17">.</code><code class="n">Finances</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">name</code> <code class="calibre17">=</code> <code class="n">name</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">location</code> <code class="calibre17">=</code> <code class="n">location</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">employees</code> <code class="calibre17">=</code> <code class="n">employees</code>
        <code class="c"># ... etc etc snip snip ...</code></pre>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 12. Subtyping" class="preface">
<div class="preface" id="subtyping">
<section data-type="sect1" class="preface" data-pdf-bookmark="Design Considerations">
<div class="preface" id="idm45644737073640">
<section data-type="sect2" data-pdf-bookmark="Composition" class="preface">
<div class="preface" id="idm45644736523688">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_6">Discussion Topic</h1>
<p class="author1">Where in your codebase have you overused inheritance? Are you using it anywhere as a conduit for reuse only? Discuss how to transform this to use composition instead.</p>
</div>

<p class="author1">Each of the member fields set in the constructor is an example of composition. It doesn’t make sense for a <code class="calibre17">Restaurant</code> to be substitutable for a <code class="calibre17">Menu</code> (<em class="calibre6">is-a</em> relationship), but it does make sense for a restaurant to be composed of a menu (<em class="calibre6">has-a</em> <span class="calibre">relationship</span>), among other things. You should prefer composition to inheritance anytime you need to reuse code but aren’t going to substitute types for one another.</p>

<p class="author1">Composition is preferable to inheritance as a reuse mechanism because it is a weaker form of <em class="calibre6">coupling</em>, which is another term for dependencies between entities.<a data-type="indexterm" data-primary="coupling" data-secondary="composition as weaker form of" id="idm45644736372232" class="calibre5"/> All other things being equal, you want weaker forms of coupling, as it makes it easier to reorganize classes and refactor functionality. If classes have high coupling between them, changes in one more directly affect the behavior of the other.</p>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1">Mixins are the exception to preferring composition over inheritance, as they are classes explicitly meant to be inherited to provide additions to a type’s interface.<a data-type="indexterm" data-primary="mixins" data-secondary="exception to favoring composition over inheritance" id="idm45644736369752" class="calibre5"/></p>
</div>

<p class="author1">With inheritance, a derived class is beholden to the base class’s changes. A developer must be cognizant of not only the public interface changing, but also changes to invariants and protected members. By contrast, when another class has an instance of your class, that class is only affected by a subset of changes: those impacting the public methods and invariants it depends on. By limiting the impact of changes, you lessen the chance of broken assumptions, decreasing fragility. To write robust code, use inheritance judiciously.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre32"><div class="sidebar" id="idm45644736367480">
<h5 class="calibre33">Subtyping Outside Inheritance</h5>
<p class="author1">Most of this chapter has focused exclusively on class-based subtyping, or inheritance.<a data-type="indexterm" data-primary="subtyping" data-secondary="outside of inheritance" id="idm45644736365944" class="calibre5"/> However, the notion of subtyping is much broader, mathematically speaking. Back in <a data-type="xref" href="part0005_split_000.html#types" class="calibre5">Chapter 2</a>, I described how types are really just a communication method around behaviors. You can apply this notion to subtypes as well: a subtype is a set of behaviors that can be completely used in place of some other supertype’s behaviors.</p>

<p class="author1">In fact, duck typing<a data-type="indexterm" data-primary="duck typing" data-secondary="subtype/supertype relationship" id="idm45644736363400" class="calibre5"/> is a subtype/supertype relationship as well:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">double_value</code><code class="o">(</code><code class="n">x</code><code class="o">):</code>
    <code class="k">return</code> <code class="n">x</code> <code class="o">+</code> <code class="n">x</code>

<code class="o">&gt;&gt;&gt;</code> <code class="n">double_value</code><code class="o">(</code><code class="mi">3</code><code class="o">)</code>
<code class="mi">6</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">double_value</code><code class="o">(</code><code class="s">"abc"</code><code class="o">)</code>
<code class="n">abcabc</code></pre>

<p class="author1">In this case, the supertype is the parameter. It supports the addition method, which must return the same type as its addends. Note that a supertype does not necessarily have to be a named type in Python; it is all about the expected behaviors.</p>

<p class="author1">The guidelines earlier in this chapter around designing your supertypes and subtypes are not exclusive to inheritance. Duck typing is a form of subtyping; all the same guidelines apply. Also, as a consumer, make sure that you are not passing in arguments that are not substitutable for the supertype. Otherwise, you are making it much harder for your other developers; duck typing obscures the supertype/subtype relationship just like inheritance does. Stick to the guidelines in this chapter to avoid headaches.<a data-type="indexterm" data-primary="subtyping" data-secondary="design considerations in" data-startref="ix_subtypdes" id="idm45644736349368" class="calibre5"/></p>
</div></aside>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 12. Subtyping" class="preface">
<div class="preface" id="subtyping">
<section data-type="sect1" data-pdf-bookmark="Closing Thoughts" class="preface"><div class="preface" id="idm45644736523064">
<h1 class="calibre12" id="calibre_pb_7">Closing Thoughts</h1>

<p class="author1">Subtyped relationships are a very powerful concept in programming. You can use them to extend existing functionality without modifying it. However, inheritance is often overused, or used improperly. Subtypes should only be used if they are directly substitutable for their supertype. If this isn’t the case, reach for composition instead.</p>

<p class="author1">Special care should be taken when introducing supertypes or subtypes. It may not be easy for developers to know of all the subtypes associated with a single supertype; some subtypes may even live in other codebases. Supertypes and subtypes are very closely coupled, so be cautious whenever you make changes. With the proper diligence, you can reap all the benefits of subtyping without introducing a slew of <span class="calibre">headaches</span>.</p>

<p class="author1">In the next chapter, I’m going to focus on a specific application of subtyping known as protocols. These are the missing link between the typechecker and duck typing. Protocols bridge the gap in an important way: they help your typechecker catch some of the errors introduced in a supertype/subtype relationship. Any time you catch more errors, especially through a typechecker, you are contributing to the robustness of your codebase.<a data-type="indexterm" data-primary="subtyping" data-startref="ix_subtyp" id="idm45644736337928" class="calibre5"/></p>
</div></section>







<div data-type="footnotes" class="calibre25"><p data-type="footnote" id="idm45644737734424" class="calibre26"><sup class="calibre27"><a href="part0016_split_000.html#idm45644737734424-marker" class="calibre5">1</a></sup> Object-oriented programming is a programming paradigm where you organize your code around encapsulated data and their behaviors. If you’d like an introduction to OOP, I suggest <a href="https://oreil.ly/6djy9" class="calibre5"><em class="calibre6">Head First Object-Oriented Analysis and Design</em></a> by Brett McLaughlin, Gary Pollice, and Dave West (O’Reilly).</p><p data-type="footnote" id="idm45644736586104" class="calibre26"><sup class="calibre27"><a href="part0016_split_002.html#idm45644736586104-marker" class="calibre5">2</a></sup> Barbara H. Liskov and Jeannette M. Wing. “A Behavioral Notion of Subtyping.” <em class="calibre6">ACM Trans. Program. Lang. Syst.</em> 16, 6 (Nov. 1994), 1811–41. <a href="https://doi.org/10.1145/197320.197383" class="calibre5"><em class="calibre6">https://doi.org/10.1145/197320.197383</em></a>.</p></div></div></section></body></html>