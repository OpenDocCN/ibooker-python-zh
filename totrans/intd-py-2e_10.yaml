- en: Chapter 9\. Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The smaller the function, the greater the management.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: C. Northcote Parkinson
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So far, all of our Python code examples have been little fragments. These are
    good for small tasks, but no one wants to retype fragments all the time. We need
    some way of organizing larger code into manageable pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to code reuse is the *function*: a named piece of code, separate
    from all others. A function can take any number and type of input *parameters*
    and return any number and type of output *results*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do two things with a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Define* it, with zero or more parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Call* it, and get zero or more results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a Function with def
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To define a Python function, you type `def`, the function name, parentheses
    enclosing any input *parameters* to the function, and then finally, a colon (`:`).
    Function names have the same rules as variable names (they must start with a letter
    or `_` and contain only letters, numbers, or `_`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take things one step at a time, and first define and call a function
    that has no parameters. Here’s the simplest Python function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Even for a function with no parameters like this one, you still need the parentheses
    and the colon in its definition. The next line needs to be indented, just as you
    would indent code under an `if` statement. Python requires the `pass` statement
    to show that this function does nothing. It’s the equivalent of *This page intentionally
    left blank* (even though it isn’t anymore).
  prefs: []
  type: TYPE_NORMAL
- en: Call a Function with Parentheses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You call this function just by typing its name and parentheses. It works as
    advertised, doing nothing, but doing it very well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s define and call another function that has no parameters but prints
    a single word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you called the `make_a_sound()` function, Python ran the code inside its
    definition. In this case, it printed a single word and returned to the main program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try a function that has no parameters but *returns* a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call this function and test its returned value by using `if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You’ve just made a big step. The combination of functions with tests such as
    `if` and loops such as `while` make it possible for you to do things that you
    could not do before.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments and Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, it’s time to put something between those parentheses. Let’s
    define the function `echo()` with one parameter called `anything`. It uses the
    `return` statement to send the value of `anything` back to its caller twice, with
    a space between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s call `echo()` with the string `''Rumplestiltskin''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The values you pass into the function when you call it are known as *arguments*.
    When you call a function with arguments, the values of those arguments are copied
    to their corresponding *parameters* inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Saying it another way: they’re called *arguments* outside of the function,
    but *parameters* inside.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, the function `echo()` was called with the argument
    string `'Rumplestiltskin'`. This value was copied within `echo()` to the parameter
    `anything`, and then returned (in this case doubled, with a space) to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'These function examples were pretty basic. Let’s write a function that takes
    an input argument and actually does something with it. We’ll adapt the earlier
    code fragment that comments on a color. Call it `commentary` and have it take
    an input string parameter called `color`. Make it return the string description
    to its caller, which can decide what to do with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Call the function `commentary()` with the string argument `'blue'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The function does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Assigns the value `'blue'` to the function’s internal `color` parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs through the `if`-`elif`-`else` logic chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caller then assigns the string to the variable `comment`.
  prefs: []
  type: TYPE_NORMAL
- en: What did we get back?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A function can take any number of input arguments (including zero) of any type.
    It can return any number of output results (also including zero) of any type.
    If a function doesn’t call `return` explicitly, the caller gets the result `None`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: None Is Useful
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`None` is a special Python value that holds a place when there is nothing to
    say. It is not the same as the boolean value `False`, although it looks false
    when evaluated as a boolean. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To distinguish `None` from a boolean `False` value, use Python’s `is` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This seems like a subtle distinction, but it’s important in Python. You’ll need
    `None` to distinguish a missing value from an empty value. Remember that zero-valued
    integers or floats, empty strings (`''`), lists (`[]`), tuples (`(,)`), dictionaries
    (`{}`), and sets (`set()`) are all `False`, but are not the same as `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a quick function that prints whether its argument is `None`, `True`,
    or `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run some sanity tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How about some real values?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Positional Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python handles function arguments in a manner that’s very flexible, when compared
    to many languages. The most familiar types of arguments are *positional arguments*,
    whose values are copied to their corresponding parameters in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function builds a dictionary from its positional input arguments and returns
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Although very common, a downside of positional arguments is that you need to
    remember the meaning of each position. If we forgot and called `menu()` with wine
    as the last argument instead of the first, the meal would be very different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Keyword Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To avoid positional argument confusion, you can specify arguments by the names
    of their corresponding parameters, even in a different order from their definition
    in the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can mix positional and keyword arguments. Let’s specify the wine first,
    but use keyword arguments for the entree and dessert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you call a function with both positional and keyword arguments, the positional
    arguments need to come first.
  prefs: []
  type: TYPE_NORMAL
- en: Specify Default Parameter Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can specify default values for parameters. The default is used if the caller
    does not provide a corresponding argument. This bland-sounding feature can actually
    be quite useful. Using the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, try calling `menu()` without the `dessert` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do provide an argument, it’s used instead of the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Default parameter values are calculated when the function is *defined*, not
    when it is run. A common error with new (and sometimes not-so-new) Python programmers
    is to use a mutable data type such as a list or dictionary as a default parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following test, the `buggy()` function is expected to run each time
    with a fresh empty `result` list, add the `arg` argument to it, and then print
    a single-item list. However, there’s a bug: it’s empty only the first time it’s
    called. The second time, `result` still has one item from the previous call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It would have worked if it had been written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix is to pass in something else to indicate the first call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is sometimes a Python job interview question. You’ve been warned.
  prefs: []
  type: TYPE_NORMAL
- en: Explode/Gather Positional Arguments with *
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve programmed in C or C++, you might assume that an asterisk (`*`) in
    a Python program has something to do with a *pointer*. Nope, Python doesn’t have
    pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used inside the function with a parameter, an asterisk groups a variable
    number of positional arguments into a single tuple of parameter values. In the
    following example, `args` is the parameter tuple that resulted from zero or more
    arguments that were passed to the function `print_args()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call the function with no arguments, you get nothing in `*args`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Whatever you give it will be printed as the `args` tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful for writing functions such as `print()` that accept a variable
    number of arguments. If your function has *required* positional arguments, as
    well, put them first; `*args` goes at the end and grabs all the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When using `*`, you don’t need to call the tuple argument `*args`, but it’s
    a common idiom in Python. It’s also common to use `*args` inside the function,
    as in the preceding example, although technically it’s called a parameter and
    could be referred to as `*params`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summarizing:'
  prefs: []
  type: TYPE_NORMAL
- en: You can pass positional argument to a function, which will match them inside
    to positional parameters. This is what you’ve seen so far in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can pass a tuple argument to a function, and inside it will be a tuple parameter.
    This is a simple case of the preceding one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can pass positional arguments to a function, and gather them inside as the
    parameter `*args`, which resolves to the tuple `args`. This was described in this
    section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also “explode” a tuple argument called `args` to positional parameters
    `*args` inside the function, which will be regathered inside into the tuple parameter
    `args`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can only use the `*` syntax in a function call or definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'So:'
  prefs: []
  type: TYPE_NORMAL
- en: Outside the function, `*args` explodes the tuple `args` into comma-separated
    positional parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the function, `*args` gathers all of the positional arguments into a
    single `args` tuple. You could use the names `*params` and `params`, but it’s
    common practice to use `*args` for both the outside argument and inside parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readers with synesthesia might also faintly hear `*args` as *puff-args* on the
    outside and *inhale-args* on the inside, as values are either exploded or gathered.
  prefs: []
  type: TYPE_NORMAL
- en: Explode/Gather Keyword Arguments with **
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use two asterisks (`**`) to group keyword arguments into a dictionary,
    where the argument names are the keys, and their values are the corresponding
    dictionary values. The following example defines the function `print_kwargs()`
    to print its keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try calling it with some keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Inside the function, `kwargs` is a dictionary parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Argument order is:'
  prefs: []
  type: TYPE_NORMAL
- en: Required positional arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional positional arguments (`*args`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional keyword arguments (`**kwargs`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with `args`, you don’t need to call this keyword argument `kwargs`, but it’s
    common usage.^([1](ch09.html#idm45795002646440))
  prefs: []
  type: TYPE_NORMAL
- en: The `**` syntax is valid only in a function call or definition:^([2](ch09.html#idm45795002644024))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Summarizing:'
  prefs: []
  type: TYPE_NORMAL
- en: You can pass keyword arguments to a function, which will match them inside to
    keyword parameters. This is what you’ve seen so far.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can pass a dictionary argument to a function, and inside it will be dictionary
    parameters. This is a simple case of the preceding one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can pass one or more keyword arguments (*name=value*) to a function, and
    gather them inside as `**kwargs`, which resolves to the dictionary parameter called
    `kwargs`. This was described in this section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside a function, `**kwargs` *explodes* a dictionary `kwargs` into *name=value*
    arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside a function, `**kwargs` *gathers* `name=value` arguments into the single
    dictionary parameter `kwargs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If auditory hallucinations help, imagine a puff for each asterisk exploding
    outside the function, and a little inhaling sound for each one gathering inside.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword-Only Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s possible to pass in a keyword argument that has the same name as a positional
    parameter, probably not resulting in what you want. Python 3 lets you specify
    *keyword-only arguments*. As the name says, they must be provided as *name=value*,
    not positionally as *value*. The single `*` in the function definition means that
    the following parameters `start` and `end` must be provided as named arguments
    if we don’t want their default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Mutable and Immutable Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that if you assigned the same list to two variables, you could change
    it by using either one? And that you could not if the variables both referred
    to something like an integer or a string? That was because the list was mutable
    and the integer and string were immutable.
  prefs: []
  type: TYPE_NORMAL
- en: You need to watch for the same behavior when passing arguments to functions.
    If an argument is mutable, its value can be changed *from inside the function*
    via its corresponding parameter:^([3](ch09.html#idm45795002479608))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It’s good practice to, uh, not do this.^([4](ch09.html#idm45795002478344)) Either
    document that an argument may be changed, or `return` the new value.
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Readability counts*, the Zen of Python verily saith. You can attach documentation
    to a function definition by including a string at the beginning of the function
    body. This is the function’s *docstring*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make a docstring quite long, and even add rich formatting if you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To print a function’s docstring, call the Python `help()` function. Pass the
    function’s name to get a listing of arguments along with the nicely formatted
    docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see just the raw docstring, without the formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: That odd-looking `__doc__` is the internal name of the docstring as a variable
    within the function. Double underscores (aka *dunder* in Python-speak) are used
    in many places to name Python internal variables, because programmers are unlikely
    to use them in their own variable names.
  prefs: []
  type: TYPE_NORMAL
- en: Functions Are First-Class Citizens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve mentioned the Python mantra, *everything is an object*. This includes numbers,
    strings, tuples, lists, dictionaries—and functions, as well. Functions are first-class
    citizens in Python. You can assign them to variables, use them as arguments to
    other functions, and return them from functions. This gives you the capability
    to do some things in Python that are difficult-to-impossible to carry out in many
    other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, let’s define a simple function called `answer()` that doesn’t
    have any arguments; it just prints the number `42`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this function, you know what you’ll get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s define another function named `run_something`. It has one argument
    called `func`, a function to run. Once inside, it just calls the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pass `answer` to `run_something()`, we’re using a function as data, just
    as with anything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that you passed `answer`, not `answer()`. In Python, those parentheses
    mean *call this function*. With no parentheses, Python just treats the function
    like any other object. That’s because, like everything else in Python, it *is*
    an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try running a function with arguments. Define a function `add_args()`
    that prints the sum of its two numeric arguments, `arg1` and `arg2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: And what is `add_args()`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, let’s define a function called `run_something_with_args()` that
    takes three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func`'
  prefs: []
  type: TYPE_NORMAL
- en: The function to run
  prefs: []
  type: TYPE_NORMAL
- en: '`arg1`'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument for `func`
  prefs: []
  type: TYPE_NORMAL
- en: '`arg2`'
  prefs: []
  type: TYPE_NORMAL
- en: The second argument for `func`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When you call `run_something_with_args()`, the function passed by the caller
    is assigned to the `func` parameter, whereas `arg1` and `arg2` get the values
    that follow in the argument list. Then, running `func(arg1, arg2)` executes that
    function with those arguments because the parentheses told Python to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test it by passing the function name `add_args` and the arguments `5`
    and `9` to `run_something_with_args()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the function `run_something_with_args()`, the function name argument
    `add_args` was assigned to the parameter `func`, `5` to `arg1`, and `9` to `arg2`.
    This ended up running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You can combine this with the `*args` and `**kwargs` techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a test function that takes any number of positional arguments,
    calculates their sum by using the `sum()` function, and then returns that sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: I haven’t mentioned `sum()` before. It’s a built-in Python function that calculates
    the sum of the values in its iterable numeric (int or float) argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define the new function `run_with_positional_args()`, which takes a function
    and any number of positional arguments to pass to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go ahead and call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You can use functions as elements of lists, tuples, sets, and dictionaries.
    Functions are immutable, so you can also use them as dictionary keys.
  prefs: []
  type: TYPE_NORMAL
- en: Inner Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can define a function within another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'An inner function can be useful when performing some complex task more than
    once within another function, to avoid loops or code duplication. For a string
    example, this inner function adds some text to its argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An inner function can act as a *closure*. This is a function that is dynamically
    generated by another function and can both change and remember the values of variables
    that were created outside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example builds on the previous `knights()` example. Let’s call
    the new one `knights2()`, because we have no imagination, and turn the `inner()`
    function into a closure called `inner2()`. Here are the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inner2()` uses the outer `saying` parameter directly instead of getting it
    as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`knights2()` returns the `inner2` function name instead of calling it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `inner2()` function knows the value of `saying` that was passed in and
    remembers it. The line `return inner2` returns this specialized copy of the `inner2`
    function (but doesn’t call it). That’s a kind of closure: a dynamically created
    function that remembers where it came from.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s call `knights2()` twice, with different arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so what are `a` and `b`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'They’re functions, but they’re also closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call them, they remember the `saying` that was used when they were created
    by `knights2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Anonymous Functions: lambda'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Python *lambda function* is an anonymous function expressed as a single statement.
    You can use it instead of a normal tiny function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate it, let’s first make an example that uses normal functions. To
    begin, let’s define the function `edit_story()`. Its arguments are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`words`—a list of words'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func`—a function to apply to each word in `words`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need a list of words and a function to apply to each word. For the words,
    here’s a list of (hypothetical) sounds made by my cat if he (hypothetically) missed
    one of the stairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the function, this will capitalize each word and append an exclamation
    point, perfect for feline tabloid newspaper headlines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Mixing our ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we get to the lambda. The `enliven()` function was so brief that we
    could replace it with a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: A lambda has zero or more comma-separated arguments, followed by a colon (`:`),
    and then the definition of the function. We’re giving this lambda one argument,
    `word`. You don’t use parentheses with `lambda` as you would when calling a function
    created with `def`.
  prefs: []
  type: TYPE_NORMAL
- en: Often, using real functions such as `enliven()` is much clearer than using lambdas.
    Lambdas are mostly useful for cases in which you would otherwise need to define
    many tiny functions and remember what you called them all. In particular, you
    can use lambdas in graphical user interfaces to define *callback functions*; see
    [Chapter 20](ch20.html#ch_art) for examples.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *generator* is a Python sequence creation object. With it, you can iterate
    through potentially huge sequences without creating and storing the entire sequence
    in memory at once. Generators are often the source of data for iterators. If you
    recall, we already used one of them, `range()`, in earlier code examples to generate
    a series of integers. In Python 2, `range()` returns a list, which limits it to
    fit in memory. Python 2 also has the generator `xrange()`, which became the normal
    `range()` in Python 3. This example adds all the integers from 1 to 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Every time you iterate through a generator, it keeps track of where it was the
    last time it was called and returns the next value. This is different from a normal
    function, which has no memory of previous calls and always starts at its first
    line with the same state.
  prefs: []
  type: TYPE_NORMAL
- en: Generator Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to create a potentially large sequence, you can write a *generator
    function*. It’s a normal function, but it returns its value with a `yield` statement
    rather than `return`. Let’s write our own version of `range()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s a normal function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'And it returns a generator object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We can iterate over this generator object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A generator can be run only once. Lists, sets, strings, and dictionaries exist
    in memory, but a generator creates its values on the fly and hands them out one
    at a time through an iterator. It doesn’t remember them, so you can’t restart
    or back up a generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to iterate this generator again, you’ll find that it’s tapped out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Generator Comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve seen comprehensions for lists, dictionaries, and sets. A *generator
    comprehension* looks like those, but is surrounded by parentheses instead of square
    or curly brackets. It’s like a shorthand version of a generator function, doing
    the `yield` invisibly, and also returns a generator object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you want to modify an existing function without changing its source
    code. A common example is adding a debugging statement to see what arguments were
    passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *decorator* is a function that takes one function as input and returns another
    function. Let’s dig into our bag of Python tricks and use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*args` and `**kwargs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inner functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions as arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function `document_it()` defines a decorator that will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Print the function’s name and the values of its arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the function with the arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print the result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the modified function for use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Whatever `func` you pass to `document_it()`, you get a new function that includes
    the extra statements that `document_it()` adds. A decorator doesn’t actually have
    to run any code from `func`, but `document_it()` calls `func` partway through
    so that you get the results of `func` as well as all the extras.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do you use this? You can apply the decorator manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative to the manual decorator assignment we just looked at, you
    can add @*`decorator_name`* before the function that you want to decorate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'You can have more than one decorator for a function. Let’s write another decorator
    called `square_it()` that squares the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The decorator that’s used closest to the function (just above the `def`) runs
    first and then the one above it. Either order gives the same end result, but you
    can see how the intermediate steps change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try reversing the decorator order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Namespaces and Scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Desiring this man’s art and that man’s scope
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: William Shakespeare
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A name can refer to different things, depending on where it’s used. Python programs
    have various *namespaces*—sections within which a particular name is unique and
    unrelated to the same name in other namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each function defines its own namespace. If you define a variable called `x`
    in a main program and another variable called `x` in a function, they refer to
    different things. But the walls can be breached: if you need to, you can access
    names in other namespaces in various ways.'
  prefs: []
  type: TYPE_NORMAL
- en: The main part of a program defines the *global* namespace; thus, the variables
    in that namespace are *global variables*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the value of a global variable from within a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you try to get the value of the global variable *and* change it within
    the function, you get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If you just change it, it changes a different variable also named `animal`,
    but this variable is inside the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: What happened here? The first line assigned the string `'fruitbat'` to a global
    variable named `animal`. The `change_local()` function also has a variable named
    `animal`, but that’s in its local namespace.
  prefs: []
  type: TYPE_NORMAL
- en: I used the Python function `id()` here to print the unique value for each object
    and prove that the variable `animal` inside `change_local()` is not the same as
    `animal` at the main level of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the global variable rather than the local one within a function,
    you need to be explicit and use the `global` keyword (you knew this was coming:
    *explicit is better than implicit*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t say `global` within a function, Python uses the local namespace
    and the variable is local. It goes away after the function completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python provides two functions to access the contents of your namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`locals()` returns a dictionary of the contents of the local namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`globals()` returns a dictionary of the contents of the global namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here they are in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The local namespace within `change_local()` contained only the local variable
    `animal`. The global namespace contained the separate global variable `animal`
    and a number of other things.
  prefs: []
  type: TYPE_NORMAL
- en: Uses of _ and __ in Names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Names that begin and end with two underscores (`__`) are reserved for use within
    Python, so you should not use them with your own variables. This naming pattern
    was chosen because it seemed unlikely to be selected by application developers
    for their own variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the name of a function is in the system variable *`function`*`.__name__`,
    and its documentation string is *`function`*`.__doc__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: As you saw in the earlier `globals` printout, the main program is assigned the
    special name `__main__`.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve called functions that do some things directly, and maybe call
    other functions. But what if a function calls itself?^([5](ch09.html#idm45795000110936))
    This is called *recursion*. Like an unbroken infinite loop with `while` or `for`,
    you don’t want infinite recursion. Do we still need to worry about cracks in the
    space-time continuum?
  prefs: []
  type: TYPE_NORMAL
- en: 'Python saves the universe again by raising an exception if you get too deep:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Recursion is useful when you’re dealing with “uneven” data, like lists of lists
    of lists. Suppose that you want to “flatten” all sublists of a list,^([6](ch09.html#idm45795000106696))
    no matter how deeply nested. A generator function is just the thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Python 3.3 added the `yield from` expression, which lets a generator hand off
    some work to another generator. We can use it to simplify `flatten()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Async Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The keywords `async` and `await` were added to Python 3.5 to define and run
    *asynchronous functions*. They’re:'
  prefs: []
  type: TYPE_NORMAL
- en: Relatively new
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different enough to be harder to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will become more important and better known over time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these reasons, I’ve moved discussion of these and other async topics to
    [Appendix C](app03.html#app_async).
  prefs: []
  type: TYPE_NORMAL
- en: For now, you need to know that if you see `async` before the `def` line for
    a function, it’s an asynchronous function. Likewise, if you see `await` before
    a function call, that function is asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between asynchronous and normal functions is that async
    ones can “give up control” rather than running to completion.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some languages, errors are indicated by special function return values.
    When things go south,^([7](ch09.html#idm45794999807944)) Python uses *exceptions*:
    code that is executed when an associated error occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen some of these already, such as accessing a list or tuple with an
    out-of-range position, or a dictionary with a nonexistent key. When you run code
    that might fail under some circumstances, you also need appropriate *exception
    handlers* to intercept any potential errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s good practice to add exception handling anywhere an exception might occur
    to let the user know what is happening. You might not be able to fix the problem,
    but at least you can note the circumstances and shut your program down gracefully.
    If an exception occurs in some function and is not caught there, it *bubbles up*
    until it is caught by a matching handler in some calling function. If you don’t
    provide your own exception handler, Python prints an error message and some information
    about where the error occurred and then terminates the program, as demonstrated
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Handle Errors with try and except
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do, or do not. There is no try.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Yoda
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rather than leaving things to chance, use `try` to wrap your code, and `except`
    to provide the error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The code inside the `try` block is run. If there is an error, an exception is
    raised and the code inside the `except` block runs. If there are no errors, the
    `except` block is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a plain `except` with no arguments, as we did here, is a catchall
    for any exception type. If more than one type of exception could occur, it’s best
    to provide a separate exception handler for each. No one forces you to do this;
    you can use a bare `except` to catch all exceptions, but your treatment of them
    would probably be generic (something akin to printing *Some error occurred*).
    You can use any number of specific exception handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you want exception details beyond the type. You get the full exception
    object in the variable *name* if you use the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The example that follows looks for an `IndexError` first, because that’s the
    exception type raised when you provide an illegal position to a sequence. It saves
    an `IndexError` exception in the variable `err`, and any other exception in the
    variable `other`. The example prints everything stored in `other` to show what
    you get in that object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Inputting position `3` raised an `IndexError` as expected. Entering `two` annoyed
    the `int()` function, which we handled in our second, catchall `except` code.
  prefs: []
  type: TYPE_NORMAL
- en: Make Your Own Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous section discussed handling exceptions, but all of the exceptions
    (such as `IndexError`) were predefined in Python or its standard library. You
    can use any of these for your own purposes. You can also define your own exception
    types to handle special situations that might arise in your own programs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This requires defining a new object type with a *class*—something we don’t get
    into until [Chapter 10](ch10.html#ch_objects). So, if you’re unfamiliar with classes,
    you might want to return to this section later.
  prefs: []
  type: TYPE_NORMAL
- en: 'An exception is a class. It is a child of the class `Exception`. Let’s make
    an exception called `UppercaseException` and raise it when we encounter an uppercase
    word in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We didn’t even define any behavior for `UppercaseException` (notice we just
    used `pass`), letting its parent class `Exception` figure out what to print when
    the exception was raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the exception object itself and print it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects! We had to get to them sometime in a book about an object-oriented language.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '9.1 Define a function called `good()` that returns the following list: `[''Harry'',
    ''Ron'', ''Hermione'']`.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.2 Define a generator function called `get_odds()` that returns the odd numbers
    from `range(10)`. Use a `for` loop to find and print the third value returned.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3 Define a decorator called `test` that prints `'start'` when a function is
    called, and `'end'` when it finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Define an exception called `OopsException`. Raise this exception to see
    what happens. Then, write the code to catch this exception and print `'Caught
    an oops'`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch09.html#idm45795002646440-marker)) Although *Args* and *Kwargs* sound
    like the names of pirate parrots.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch09.html#idm45795002644024-marker)) Or, as of Python 3.5, a dictionary
    merge of the form `{**a, **b}`, as you saw in [Chapter 8](ch08.html#ch_dicts).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch09.html#idm45795002479608-marker)) Like the teens-in-peril movies where
    they learn “The call’s coming from inside the house!”
  prefs: []
  type: TYPE_NORMAL
- en: '^([4](ch09.html#idm45795002478344-marker)) Like the old doctor joke: “It hurts
    when I do this.” “Well, then don’t do that.”'
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch09.html#idm45795000110936-marker)) It’s like saying, “I wish I had a
    dollar for every time I wished I had a dollar.”
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch09.html#idm45795000106696-marker)) Another Python interview question.
    Collect the whole set!
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch09.html#idm45794999807944-marker)) Is this northern hemispherism? Do
    Aussies and Kiwis say that things go “north” when they mess up?
  prefs: []
  type: TYPE_NORMAL
