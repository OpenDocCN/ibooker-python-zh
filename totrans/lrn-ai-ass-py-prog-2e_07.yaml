- en: 8 Debugging and better understanding your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Determining the source of a bug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing errors with Copilot techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging code with Copilot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the VS Code debugger to see how code is functioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be a point in every programmer’s career when their code isn’t doing
    what they want it to do. This has likely happened to you already, and, rest assured,
    it’s a normal part of learning to program. How do we fix the code? Sometimes,
    changing the prompt or better decomposing the problem like you learned in earlier
    chapters is sufficient to fix the problem. But what do you do when you just can’t
    get Copilot to give you different or better code, nor can you figure out why the
    code you’ve been given doesn’t work properly?
  prefs: []
  type: TYPE_NORMAL
- en: This chapter serves two purposes. The primary goal is to learn how to find errors
    (called bugs) in the code and fix them. To find those bugs, you’ll need to fulfill
    the second goal, which is gaining a deeper understanding of how your code works
    while you’re running it.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that having an error in your code is such a common occurrence
    for programmers that programming environments, such as Visual Studio Code (VS
    Code), have tools to help us uncover what’s going wrong. We’ll learn how to use
    that tool, called a debugger, in this chapter as well.
  prefs: []
  type: TYPE_NORMAL
- en: Like the past few chapters where we started small, we’ll learn the concepts
    behind finding and fixing errors with some small examples, and then we’ll more
    authentically showcase the process by diving into a larger example that’s similar
    to the kind of code you’re likely to write in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 What causes errors (bugs)?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First up is a quick terminology lesson. Many decades ago, computers used relays
    or vacuum tubes rather than transistors. The story goes that Dr. Grace Hopper,
    while programming one of these early computers, experienced an error caused by
    an actual bug (a moth) in a relay. Today, we use the term bug to refer to a mistake
    in a program, though we’re not dealing with literal bugs anymore. Now, bugs are
    caused by mistakes by programmers; when we debug our code, we’re working on removing
    those bugs. (There can be bugs in the implementation of Python itself or even
    in computer hardware, but they are so rare, it’s safe to assume an error in your
    code is because of your code.)
  prefs: []
  type: TYPE_NORMAL
- en: 'No one intentionally causes bugs in their code if they are genuinely trying
    to solve a problem. So why do bugs happen? Well, software engineers, and Copilot,
    make mistakes. What kind of mistakes you might ask? There are two primary categories
    of bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '***Syntax errors*—These errors occur when the code doesn’t follow the Python
    syntax requirements. For example, forgetting to write a `:` at the end of the
    first line of a `for` loop is a syntax error. When you run Python, because it’s
    trying to generate machine code based on your program description, it will run
    into a mistake, not know what to do, and give you an error. Sometimes, these error
    messages are more readable than others. When people learn to program in the traditional
    way, without Copilot, these errors are really, really common. It takes a while
    to learn all the rules of Python and to make those rules a habit. Even the two
    of us still sometimes write code with syntax errors, despite decades of writing
    code. The good news is that writing code with Copilot almost entirely eliminates
    this problem! The bad news is that of the two types of bugs, syntax errors are
    the easier to find and fix.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***   ***Logical errors—*These errors occur when there is something logically
    wrong with the program. For example, maybe the intent of the code is to count
    how many times the exact word “Dan” appears in a list of words, but the code actually
    counts how many words in the list contain “dan” (ignoring case) anywhere in the
    word. This code would be doing the wrong thing on two counts: it would count words
    like *dan* and *DAN* as matches even though we don’t want those to be matches,
    and it would find *dan* as any part of a word rather than the full word. That
    is, it would count words like *Daniel*, *danger*, and *dan*, even though we don’t
    want to count any of these! Somewhere, the code isn’t doing what it should, and
    we have to figure out where and why. Often, finding the logical error is the hardest
    part. Once we know where the mistake is, we have to fix it, and fixing these bugs
    can range from changing a single character to completely rewriting the code. Logical
    errors can happen when a prompt isn’t well described or when Copilot, for various
    reasons, generates the wrong code.****'
  prefs: []
  type: TYPE_NORMAL
- en: '****## 8.2 How to find the bug'
  prefs: []
  type: TYPE_NORMAL
- en: Finding bugs can be challenging. Fundamentally, whether you or Copilot wrote
    the code, you thought or Copilot “thought” the code was correct when it was written.
    This is why it’s often easier for a colleague to find a bug in the code rather
    than the author. The author can’t see the bug because they created it!
  prefs: []
  type: TYPE_NORMAL
- en: Bugs aren’t new to us in this book as we’ve seen mistakes in code already, and
    we’ve found those errors by reading the code and/or testing. In previous chapters,
    we figured out the source of the bug by reading through the code. In this chapter,
    we’ll address the bugs that you identify when testing but can’t seem to figure
    out why the code is wrong. Often, you can bypass the process of figuring out why
    the code is wrong by trying other Copilot suggestions, using new prompts to fix
    the error, or asking Copilot to fix the bug for you, but in our experience, these
    techniques don’t always work. What we need then are more tools to help us figure
    out where the error is in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1 Using print statements to learn about the code behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fundamentally, a logical error means that there is a mismatch between what the
    author thought the code would do and what the code actually does. A common way
    to identify that mismatch is by using `print` statements to get insight into the
    behavior of the program because they tell you what the computer is actually doing.
    A useful practice is to print variables at various points in time to see what
    the values of those variables are at those points. Let’s try this for that example
    we just gave of looking for the word *Dan* in a list of words. Here’s the wrong
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.1 Incorrect function for counting matching words
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The method lower makes the word all lowercase letters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may already see what’s wrong with the code, but let’s assume we don’t know
    what’s going on, and we’re trying to figure out where the code went wrong. Suppose
    we found out that our code is wrong by running the following test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We expected the answer of 1, but we got 2\. Notably, including *danger* in this
    test case helped us catch the error in the code. Where in the code did things
    go wrong? To figure that out, we could add `print` statements. When you want to
    do this, you’ll need to read the code to figure out where to put them. Looking
    at this code, printing the list at the start of the function might not be a bad
    idea depending on the bug we’re seeing, but the bug here seems to have to do with
    the count and not specifically with the list of words. Printing each word in the
    list as the first line in the `for` loop may be helpful so we can check that the
    code is processing each word. We might print `count` right before it’s returned,
    but we already have a good idea of the value returned. These are all reasonable
    ideas that will help you get closer to the bug, but it’s not where we’d start.
    To be clear, if we started with one of these other ideas, we wouldn’t be wrong;
    it might just take a few more steps before finding the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Because the bug is counting too many words as *Dan* words, we’d put the `print`
    statement within the `if` statement right where `count` is incremented, as in
    the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.2 Example of a print statement to find the bug
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '#1 A print statement to show which words are being counted'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerunning our code with the same test case, this is what is printed now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Aha! This would tell us that our program is counting the word *danger* when
    it shouldn’t be. We could then give Copilot a new prompt incorporating what we
    just learned to hopefully have Copilot fix the problem. Here’s the prompt we added
    in the editor, and Copilot fixed the code in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.3 Using a prompt to fix a known bug
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Prompt that causes Copilot to generate the correct code'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Code added by Copilot in response to the prompt'
  prefs: []
  type: TYPE_NORMAL
- en: Once we knew the bug, it was easier to tell Copilot how to fix it. Granted,
    this is a basic example, but the idea applies to far more complex code. The process
    is often iterative. You ask the code to print something, and what it prints aligns
    with what you think it should be doing. You then ask the code to print something
    else and check it against what you expect. You keep doing this until there’s a
    point where what the code prints doesn’t align with what you wanted it to do.
    That’s when you’ve found the bug and can give Copilot a prompt to help it give
    you better code, or if the fix is simple, you can change the code directly.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the complexity of the code, using `print` statements is often an
    effective way of debugging. We often use it as our first step in debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging: An art more than a science'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The iterative process when debugging is necessary because we’re genuinely confused
    about what the code is doing and why it isn’t matching our expectations. It’s
    okay to add a bunch of `print` statements that just tell you what you thought
    was happening in the first place because each of these `print` statements tells
    you where *not* to look for the bug and is an effective process of elimination.
    Figuring out where to look for bugs takes time and practice, so don’t worry if
    you find yourself spending a fair bit of time on it when you first start.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.2 Using VS Code’s debugger to learn about the code behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: VS Code is used by novices and professionals alike, so it has tools to help
    with the process of debugging. Because it’s used by professionals, debugging tools
    have a large number of features. For the purpose of this book, we’ll focus on
    a few of the most commonly used features, but feel free to look into more resources
    on using the VS Code debugger if you’re curious ([https://code.visualstudio.com/docs/editor/debugging](https://code.visualstudio.com/docs/editor/debugging)).
  prefs: []
  type: TYPE_NORMAL
- en: To showcase these tools, we’ll work through debugging the same function from
    the previous example (refer to listing 8.1) in a few ways. Listing 8.4 provides
    the code we’ll be working with throughout this section. Note that we’ve added
    the test of the `count_words` function to the program.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.4 Incorrect `count_words` function for debugging
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Code to call the count_words function directly'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the debugger and setting breakpoints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use the debugger, we need to set a *breakpoint* and start the debugger. Setting
    a breakpoint tells the debugger when you want to start debugging the program as
    it executes. Once you hit the breakpoint, you’ll be able to inspect variable values
    and step through the program line by line. Breakpoints are extremely useful. For
    a large program, you wouldn’t want to step line by line through the entire program
    because that could take a great deal of time. Instead, using a breakpoint, you
    can step through just the lines of code that are most relevant to you.
  prefs: []
  type: TYPE_NORMAL
- en: To set a breakpoint, hover your mouse cursor to the left of the code, and you’ll
    see a dot appear. Click that dot, as shown in figure 8.1, and you’ll have a breakpoint
    set. For your projects, you’ll likely want to start by creating a breakpoint at
    the start of the function’s execution and then step through it one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 Creating a breakpoint in VS Code by clicking to the left of the line
    of code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you see a red dot to the left of the breakpoint after you move your mouse
    away, as shown in figure 8.2, that means it’s properly set.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 A breakpoint has been set on line 2 of our count_words.py file in
    VS Code.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can have more than one breakpoint, but for this example, let’s just stick
    with the one breakpoint on line 2\. (Note that you can remove a breakpoint by
    clicking on that red dot again.) Next, we’ll start the debugger and see how it
    works with the breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: How to step through the code line by line
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To start the debugger, choose Run > Start Debugging, as shown in figure 8.3.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 Starting the debugger in VS Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once the debugger is started, you should see a screen similar to figure 8.4\.
    (If this is the first time using the debugger, it may ask you to select a debug
    configuration, in which case, you’ll want to choose Python.)
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 The Debugging view in VS Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The VS Code debugger has a number of components [1]. On the left-hand side,
    the Debug Side Bar contains the Variables section, Watch section, and Call Stack
    section. Let’s briefly examine each of these sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Variables section* contains the variables that are declared within the
    current scope (e.g., within `count_words`) and their current values. For example,
    the `words` parameter is defined to be a list containing `['Dan',` `'danger',`
    `'Leo']`. You can click the arrow (>) to the left of `words` to see more details
    about that variable. This section is incredibly useful because you can examine
    the value of each variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *Watch section* contains any expressions you want to watch specifically.
    For example, you might add the expression: `"dan"` `in` `word.lower()` to the
    watched expressions, and you’d be able to see if it’s `True` or `False` for each
    different value of `word`. To add an expression, hover over the Watch section
    and click the + sign.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Call Stack section* contains the functions that have been called that have
    led to this line of code executing. Here, the main function (called `<module>`
    by VS Code) called the function `count_words` on line 9\. Within the function
    `count_words`, we’re presently on line 2\. You can double-check that this is true
    by looking at the line of code presently highlighted as line 2 is highlighted
    in figure 8.4\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speaking of which, on the right-hand side, which shows our code editor, we can
    see the line `count` `=` `0` highlighted. This is the current line of code that
    hasn’t yet been executed. The reason the line hasn’t been executed yet is because
    we set our breakpoint, shown by the arrow with a dot in it, at this line of code.
    When we started the debugger, it ran the code until just before executing `count`
    `=` `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Debug Toolbar (figure 8.5) is critical as it drives the process once you
    start debugging: you can advance an instruction, restart debugging, or stop debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 The Debugging Toolbar
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The buttons on the toolbar, going left to right, are
  prefs: []
  type: TYPE_NORMAL
- en: '***Continue (F5)—*This button will advance until the next time a breakpoint
    is executed. In our example, line 2 of `count_words` never executes again, so
    clicking Continue will cause the program and debugging session to run to the end.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***   ***Step Over (F10)—*This button advances to the next line of code in
    the current function. Step Over means that if a line of code in this function
    calls another function (e.g., when `word.lower()` is called on line 4), the debugger
    will stay in the `count_words` function and will just run the called function
    (e.g., `word.lower()`) to its completion.*****   ***Step Into (F11)—*This button
    advances to the next line of code, including going into any functions that are
    called. Unlike Step Over, when you use Step Into, the debugger will go into any
    function called by the current function. For example, if you used Step Into on
    a line of code that calls another function, it would go into that function and
    continue debugging (line by line) from inside that function. By default, it doesn’t
    step into library function calls (e.g., `word.lower()` is part of the Python standard
    library) but will step into functions you’ve written.*****   ***Step Out (Shift
    + F11)—*This button will execute the code until the present function ends and
    then continue debugging from after this function’s exit.*****   ***Restart—*This
    button restarts the debugging process. It will restart the program, and the program
    will execute until its first breakpoint.*****   ***Stop—*This button stops the
    debugging process.************'
  prefs: []
  type: TYPE_NORMAL
- en: '******#### Stepping through the code line by line'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a handle on the debugger, let’s continue our example by using
    the Step Over button. Let’s click Step Over once and see how our view changes
    (figure 8.6). Step Over advanced to the next line of code, line 3\. This means
    it executed
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: and is just about ready to execute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/8-6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 Our debugger after clicking Step Over once. The next line (line 3)
    is now highlighted.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can see from various clues in the interface that the line `count` `=` `0`
    was executed. First, in the editor on the right, we can see the `for` loop is
    highlighted, and the arrow on the left points to this line of code. On the left,
    in the Call Stack section, we can see that it’s now on line 3 of `count_words`
    `(`as shown by the line `count_words` being highlighted and the number in the
    oval on the right reading 3:1). Perhaps most importantly, on the left in the Variables
    section, we can now see the variable `count` has been added to the local variables,
    and it has a value of `0`. This last piece is pretty amazing because if you were
    trying to read through the code and trace what is happening line by line, the
    line `count` `=` `0` on line 2 would mean that a variable count is created and
    assigned a value of `0`. This is just what the VS Code debugger has told us as
    well. We hope you’re starting to see how powerful this tool can be.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s click Step Over one more time. Now we’re stopping just before the line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there is now a new variable, `word`, which has been assigned
    the value `"Dan"`, and that’s just what we’d expect: `word` was given the value
    of the first element in the list `words`. This is a good spot to point out that
    in addition to being able to read the variables values in the Variables section,
    you can also just hover your mouse over any variable that’s been declared already
    to see its value as well. Pretty neat, huh?'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s click Step Over one more time and see that the condition in the `if` statement,
    `"dan"` `in` `word.lower()`, evaluated to `True`, so we’re going to execute the
    line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’re getting the hang of this, let’s keep clicking Step Over a few
    more times. The first time you click Step Over, it will go back to the `for` loop,
    and you can see `count` has incremented to `1`. The second time you click Step
    Over, it will stop at the `if` statement, and you can see that word is now `"danger"`.
    We could stop here and add a watch expression to see what this `if` statement
    will do. To add a watch expression, hover your mouse over the Watch section, and
    click the plus arrow that appears to the right of the word Watch. This will let
    you type anything you want. We typed `"dan"` `in` `word.lower()` and pressed Enter
    to add this watch expression, as shown in the Debug Side Bar of figure 8.7.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 View of the debugger after adding the watch expression
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If we hadn’t already found the bug earlier in this chapter, this is where we’d
    find it. The expression `"dan"` `in` `word.lower()` evaluates to `True`, which
    means `count` will be incremented again. But we only wanted exact matches to the
    word `"Dan"` and didn’t want `"danger"` to count!
  prefs: []
  type: TYPE_NORMAL
- en: This is a completely reasonable way to debug a function. As we noted earlier,
    putting a breakpoint at the start of the function’s execution and then stepping
    through it one step at a time often is a great starting point for debugging. The
    only times you might struggle to use this approach is if the `for` loop ran through
    thousands of values before making a mistake. To address challenges like this,
    we might put a breakpoint in a specific spot to avoid spending a lot of time in
    the debugger. Let’s stop the debugger (click Stop in the Debug Toolbar), remove
    the breakpoint from line 2 (click the red dot to the left of the line), and try
    a different breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Using a breakpoint to selectively debug
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This time, let’s put the breakpoint at a point in the code we want to monitor
    more closely. Based on our test case showing that two words of the list “counted”
    when we expected just one to, we should try putting our breakpoint at the line
    where `count` is incremented, as we have in figure 8.8.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 View of the code after placing our new breakpoint on line 5
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once we start the debugger, the code will run until the first time the `if`
    statement is evaluated to `True` and the line `count` `+=` `1` is ready to execute.
    Figure 8.9 offers the view of the debugger once we start it.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 View of the debugger when it encounters the breakpoint (line 5) for
    the first time
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We put the breakpoint at the incrementing of `count` because we wanted to see
    what item in the list is causing `count` to increment. Examining our local variables,
    we can see that `word` is `'Dan'`, and that is when we want the `count` variable
    to be incremented. Given this is what we wanted to happen, we haven’t found our
    bug yet.
  prefs: []
  type: TYPE_NORMAL
- en: Now is when we can really take advantage of our breakpoint placement. We want
    the code to execute until it comes across the breakpoint again. The way to do
    this is to click Continue in the Debug Toolbar (refer to figure 8.5). After clicking
    Continue, the debugger should appear as in figure 8.10.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 View of the debugger when it encounters the breakpoint (line 5)
    for the second time
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the Variables section, notice that the value of `count` and the value of
    `word` are highlighted. This is to tell you that because you clicked Continue,
    those two values have changed. The value in `count` increased to `1`, as expected,
    after having found the word `'Dan'`. The value in `word` updated to `'danger'`.
    Although `'danger'` is the next value in the list of words, we shouldn’t expect
    to find the code incrementing `count` for the word `'danger'`. At this point,
    we’d have found our bug. Notice how much quicker it can be to find a bug with
    a good placement of a breakpoint. But we caution that knowing the best place to
    put a breakpoint is a lot like knowing the best variables to print when debugging—it
    takes time and practice to learn how to do it well.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ve seen how powerful the debugger can be in VS Code. It’s
    pretty easy to set a breakpoint and start a debugging session. As the debugger
    monitors the variables in the function, you can inspect those in the Debug Side
    Bar as the code executes.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 How to fix a bug (once found)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the old way of learning to program, this would be a short section that would
    tell you to fix the bug yourself. Although that’s still an option, we have a lot
    of choices now with Copilot. These choices include asking Copilot to fix it, giving
    it a new prompt for the entire function that better describes the problem in a
    way to avoid the bug, giving Copilot a targeted prompt to fix the spot in the
    code you found that was wrong, and, if it’s a small fix, making it yourself. Let’s
    see how we could do each of these.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1 Asking Copilot to fix your bug via Copilot Chat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In the following example, we’ll interact with the Copilot Chat feature. The
    Copilot Chat feature lets you interact with Copilot as you might with ChatGPT
    but is limited to questions pertaining to programming. Feel free to interact with
    ChatGPT instead (available via [https://openai.com](https://openai.com) with free
    tiers at the time of writing) in the same way as we interact with Copilot in this
    section. We’re preferential to Copilot Chat just because its interface is built
    in to the latest version of VS Code and the Copilot extension.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*In previous chapters, we’ve mostly just asked Copilot Chat for single answers,
    whereas in this chapter and later chapters, we’ll be using Copilot Chat to have
    a conversation with the tool. When we’re having a conversation with the tool,
    we’ll work to separate out what we write (“Human”) from Copilot’s responses (“GitHub
    Copilot”). Using the Copilot Chat feature, let’s see if Copilot can help us out
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanI have a function, below, that is supposed to count the number of times
    the word “Dan” appears in the parameter list “words”. Instead, it seems to be
    counting the number of times the characters “dan” appear anywhere in the list.
    Can you help fix this for me?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Certainly! To count the number
    of times the word “Dan” appears in the list, you can modify the `if` statement
    to check if the whole word is equal to “Dan” (case-insensitive). Here’s the modified
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code will count the number of times the word “Dan” (case-insensitive) appears
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The answer back from Copilot Chat changed the line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Although the change may look small, it has a big effect. The original line of
    code searched for the string `"dan"` anywhere in `word` (after the word has been
    made all lowercase letters by the `.lower()` method). The new line of code checks
    to see whether `word` (again, made all lowercase letters by the `.lower()` method)
    is an exact match for the string `"dan"`.
  prefs: []
  type: TYPE_NORMAL
- en: This answer from Copilot is a step closer to a correct solution as it will only
    match the whole word rather than looking for an occurrence of `dan` anywhere in
    the word. However, the call to `.lower()` makes it case-insensitive, so it would
    also match `dan` rather than how our solution earlier (listing 8.3) was case-sensitive
    (it had to be exactly `Dan`). We’d like to be case-sensitive, so we could continue
    with Copilot Chat to have Copilot fix this for us.
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanCan you give me the same code but count only the word “Dan” (case-sensitive)?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Sure! Here’s the modified code
    that counts only the word “Dan” (case-sensitive):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code will count the number of times the word “Dan” (case-sensitive) appears
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, Copilot Chat was able to solve the problem for us when we knew
    how the code was misfunctioning. We didn’t explicitly say what line of code was
    broken, but if you knew this, you could convey that to Copilot Chat as well. One
    advantage of knowing which line was broken, like we did here, is that we could
    look to make sure the fix from Copilot changes the broken line. Let’s move on
    and examine other options for fixing the bug.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2 Giving Copilot a new prompt for the whole function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve seen us rewrite the prompt for a function a fair number of times already
    in this book. It simply involves rewriting the function prompt and seeing if Copilot
    can do better, sometimes using Ctrl-Enter to explore Copilot’s solutions. We won’t
    repeat this here because you’ve already seen it many times before (e.g., in chapter
    6, section 6.5.2).
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.3 Giving Copilot a targeted prompt for part of a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used this technique earlier in the chapter in listing 8.3\. We’ve reproduced
    this as listing 8.5.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.5 Using a prompt to fix a known bug (relisted)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Prompt that causes Copilot to generate correct code'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’d figured out that the previous line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: wasn’t doing what we wanted. So, we removed the incorrect code and specifically
    added a prompt to say exactly what we wanted Copilot to do, and it was able to
    produce the correct code.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.4 Modifying the code to fix the bug yourself
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach to fixing broken code is new to this chapter. You’ve seen enough
    code at this point in the book that you can likely fix some code by yourself by
    directly modifying it. For example, suppose we wrote the following code.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.6 Function to count specified numbers in a list
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We’ve seen functions like this earlier in the book. It iterates through all
    the numbers in the list of numbers and checks if each number is bigger than or
    equal to `x` and is less than or equal to `y`. If a number is between `x` and
    `y`, it increases the `count`. At the end of the function, it returns the `count`.
    The code isn’t wrong here if the goal is to count numbers in the list that are
    between `x` and `y` (including `x` and `y`).
  prefs: []
  type: TYPE_NORMAL
- en: However, the term *between* can be a bit ambiguous. Do you want to include `x`
    and `y` or just the values between them (not including them)? Suppose that when
    you imagined this function, you wanted to not include `x` and `y.` For example,
    if the list were 2, 4, 8, and you provided `x` and `y` values of 3 and 8, you
    would want the `count` to be 1 (including 4, but not 8). You might already see
    how the function is wrong for this goal and how to fix it, but let’s pretend you
    don’t realize yet that the code doesn’t match what you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any function that is created either by Copilot or us, we should test
    the function. Fortunately, when writing the first test case, we included a value
    in the test case (`numbers`) that is equal to `x` (the lower bound) and equal
    to `y` (the upper bound):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Testing the code at the prompt, we found that our function returns 5 as the
    answer, but we thought the answer should be 3\. By our definition of *between*,
    we felt that only the numbers 4, 5, and 6 are between 3 and 7, so the answer should
    be 3, that is, there are three numbers between 3 and 7\. Instead, the code gave
    us the answer of 5\. So, we know it isn’t working correctly thanks to our test
    cases. Whether we go on to find the bug by inspecting the code or by using the
    debugging techniques from this chapter, we realize the statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: is the culprit. Here, the complete fix requires us to change the `if` statement
    from
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is a change we could just make directly, without asking for Copilot’s help
    (although Copilot would likely be able to help us here as well). Listing 8.7 has
    the fixed function after the change.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.7 Function to count specified numbers (corrected)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Changed the >= to > and <= to < manually'
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Modifying our workflow in light of our new skills
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to find and fix bugs in a more deliberate manner, let’s
    revisit the workflow we last visited in chapter 6\. Note that this workflow is
    about how to design a single function, so it presumes you’ve already done the
    function decomposition described in chapter 7 to determine the appropriate functions.
    The new workflow appears in figure 8.11.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-11.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 The function design cycle with Copilot, augmented to include debugging
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Although the figure is starting to get a bit complicated, most of this is what
    you saw previously in chapter 6\. The only changes here are to include debugging.
    Specifically, if you’ve already tried to revise the prompt and you still can’t
    get code that works, then it’s time to try debugging explicitly. With the tools
    you’ve gained in this chapter, you’ll likely be successful at finding some bugs
    but not all possible bugs. If you find the bug and feel you’ve successfully fixed
    it, the flowchart sends you back to testing to make sure your fix worked (and
    didn’t break any other test cases). On the off chance you can’t get the code to
    work through new prompts and just can’t seem to debug it, we’ve found that problem
    decomposition is often your best next step. In other words, if you can’t get a
    function to work no matter how hard you try, the function should probably be broken
    into multiple functions, and you’re more likely to be successful coding those
    smaller functions.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Applying our debugging skills to a new problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our new skills in place and a new workflow, let’s try tackling a more challenging
    debugging problem. Remember in chapter 6 when we tried to determine the largest
    number of empty seats in a given row in a classroom? We’re going to solve a similar
    problem here.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of looking for empty seats, let’s say that we want to count the most
    students seated consecutively in a row because you’re trying to space them out
    better before an exam. You could also imagine using this to space out people more
    if they want more personal space or if there’s a pandemic. We wrote the prompt
    and a basic doctest, and Copilot generated a solution. The code appears in the
    following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.8 First attempt to count consecutive students in a row
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Our prompt to Copilot'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The first test case'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 The code from Copilot'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 The code to run the doctest that we added'
  prefs: []
  type: TYPE_NORMAL
- en: Given this chapter is about debugging, you can probably guess the code isn’t
    working correctly. We caught this bug when we read the code Copilot gave us, but
    it’s a subtle bug that we suspect could be missed fairly easily. If you see it
    already, great job, but pretend you didn’t for the rest of the chapter. If you
    haven’t seen it, the rest of the chapter is going to be more valuable to you.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine then that we just wrote this prompt and test case. We read through
    the code, and it looks like it’s probably keeping track of the most consecutive
    students. As long as it sees a student in a seat, it increments the count. When
    there isn’t a student in the seat, it checks to see whether the count is bigger
    than any previously seen and resets the count. It seems like it’s at least on
    the right track. We included a test case, so we ran the code, and the test case
    passed. We’re feeling pretty good about the code but know we need to do more test
    cases, particularly ones to catch edge cases (remember that edge cases are uncommon
    cases that could break the code).
  prefs: []
  type: TYPE_NORMAL
- en: 'We know when we work with lists, it’s good to check that the code does the
    right thing at the start and end of the list. To test the end of the list, let’s
    add a test case where the largest group of consecutive students includes the last
    seat and then rerun the code. Here’s the new test case we’re adding to the docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The longest group of consecutive students is 4.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We run the code again and are surprised when the test cases fail. Here’s what
    it told us (we reformatted the output for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s odd—the code seemed to be working properly. Something about this edge
    case has uncovered the error. At this point, we’d want to generate some hypotheses
    about why the code isn’t working properly to help guide our debugging efforts.
    (If you’re truly stumped, you could take the approach of just setting a breakpoint
    at the first line of code in the function and stepping through it rather than
    trying to create a hypothesis.) Here are two hypotheses that come to mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The updating of `count` is skipping the last element in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The updating of `max_count` is missing the last element in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To simplify the debugging process, we removed the test that is passing (just
    set it aside to restore later) and are only going to run the test that is failing.
    The following listing shows our full code before we start the debugging process.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.9 Code that we’ll debug to count consecutive students
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Failed test case'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the first hypothesis, that `count` isn’t updating properly
    at the end of the list and set a breakpoint at the updating of `count`. Figure
    8.12 shows the first time the debugger pauses after it’s started.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-12.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 Debugger stopping before the first update of `count`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: From the debugger, we can see that `count` is still `0`, so it hasn’t been updated
    yet. We’re in the first row of that first test case because `row` is `['S',` `'`
    `',` `'S',` `'S',` `'S',` `'S']`. The seat we’re looking at is an `'S'`, which
    is why the count is increasing. Let’s click Continue in the Debug Toolbar to see
    the next update of `count`. The state of the debugger after clicking Continue
    appears in figure 8.13.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-13.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 Debugger stopping before the second update of `count`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A fair bit has happened, it seems, since the last update of `count` because
    `max_count` is now `1`. This must have happened when the empty space was processed
    because `max_count` was set to `1` and `count` was reset back to `0`. At this
    point, we’re at the third seat in the row with a student there, and `count` is
    ready to update. We’ll want to check that `count` keeps updating with each new
    student. We clicked Continue, and `count` increased to `1`. We clicked Continue
    again, and the `count` increased to `2`. We click Continue once more, and the
    `count` increased to `3`. At this point, we’re at the last student in the row,
    and we want to check that `count` increases to `4`. To check this, we clicked
    Step Over once, and `count` indeed updates to `4`. You can see the state of the
    debugger at this point in figure 8.14.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-14.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 Debugger stopping right after the fourth consecutive update of `count`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Well, we have good news and bad news at this point. The good news is that `count`
    is properly updating. The bad news is that our first hypothesis was wrong, and
    we haven’t found our bug yet. We could move our breakpoint to the line where `max_
    count` is updated (line 22) and then click Restart and start over the debugging
    process for our second hypothesis, but given that `count` is `4` right now in
    our debugger, let’s just continue to trace through the code and make sure `max_count`
    gets updated. Or rather, we know it won’t be, so we want to see why.
  prefs: []
  type: TYPE_NORMAL
- en: Before clicking Step Over, we’ve got a clue already present in the debugger.
    This clue comes from the fact that the next line of code to execute is `for` `seat`
    `in` `row`. But the student we just saw was the last student in `row`. This means
    this `for` loop is just about to finish (meaning we won’t execute the body of
    the loop again, which means `max_count` can’t get updated). Let’s see whether
    that’s what happens by clicking Step Over. The state of the debugger appears in
    figure 8.15.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/8-15.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 Debugger stopping after finishing the first row
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We just finished processing the first row, but we never updated the `max_count`.
    The next line of code will pick the next `row`, and the line after that will set
    `count` to `0` again. We finished the loop over the row without ever updating
    `max_count` even though we found a `count` that’s bigger than the current `max_count`.
    If you don’t see the bug yet, we encourage you to step through until the next
    time `max_count` is updated, and it may be more obvious at that point.
  prefs: []
  type: TYPE_NORMAL
- en: The error in the code is that it only updates `max_count` when it encounters
    an empty seat. This means that if a row ends with a student, the code to check
    whether `max_count` should be updated will never run for that row. Examining the
    code more closely, the test to see whether `max_count` should be updated and the
    update of `max_count` should both occur either outside the `if-else` statement
    or right after `count` is updated.
  prefs: []
  type: TYPE_NORMAL
- en: This is a fix we can probably just make manually because all we need to do is
    move two lines of code to a better location. The code in listing 8.10 is the corrected
    function (without the tests or prompts).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 8.10 Corrected function to count consecutive students
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Moved the testing of count against max_count to immediately after the updating
    of count'
  prefs: []
  type: TYPE_NORMAL
- en: This new code does pass the test that failed with the old code and the original
    test. After adding another test that makes sure the code works when the longest
    group of consecutive students appears at the start of the row, we’re more confident
    the code is now working properly.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Using the debugger to better understand code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We suspect you’re already pretty impressed by the debugger. We are too. When
    students were taught programming in the traditional manner, a lot of time was
    spent making sure students could essentially trace through code like a debugger
    would, drawing out the state of all the variables and updating them with each
    new line of execution. Indeed, there’s even a free tool on the web called Python
    Tutor [2] that creates diagrams of the state of memory that can be easier to read
    than a debugger, just to help new programmers learn how the code executes.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you like using the debugger or want to use a tool like Python Tutor,
    we encourage you to play with some of the code you’ve written from earlier sections
    of the book. In our personal experience working with people learning how to program,
    walking through a program line by line and watching how the state of variables
    changes can be a truly enlightening experience, and we hope you’ll appreciate
    it too.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 A caution about debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From working with students, we’ve also seen that debugging can be a really frustrating
    experience for new learners [3]. When learning how to program, everyone wants
    their code to work, and finding and fixing bugs is time spent when things aren’t
    working. There are a couple of ways to help overcome this frustration. First,
    problem decomposition can go a really long way to helping you get code from Copilot
    that is right without the need for extensive debugging. Second, remember that
    everyone’s code doesn’t work sometimes, including ours. It’s just a natural part
    of the programming process and a part that can take some practice. Last, always,
    and we mean always, test every function you write. More often than not, when our
    students are really stuck debugging, it’s because there are bugs in multiple functions
    interacting as a result of not testing each function. When that happens, it’s
    exceptionally hard to find and remedy the bugs. Debugging interacting bugs is
    so frustrating that avoiding the experience is a big reason why both of us religiously
    test every function we write.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that if you test every function you write and diligently break
    down problems into small, manageable steps, you shouldn’t find yourself debugging
    that often. And, if you do, you’ll be debugging the error in one function, which
    is what essentially every programmer on the planet does. With some practice, you’ll
    get the hang of it.
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’re given a Python function that is supposed to calculate the sum of all
    even numbers in a list. However, the function isn’t working correctly. When you
    call the function with the list `[1,` `2,` `3,` `4]`, it returns `4` instead of
    `6`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Identify the bug in the `sum_even_numbers` function, and explain how to fix
    it. Modify the code to correct the bug, and verify your solution with the provided
    test case.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. You’re given a Python function that is supposed to find the maximum number
    in a list of numbers. However, the function isn’t working as expected. Your task
    is to determine why the function is working incorrectly, and how you can fix this
    (hint, think about the possible integer values in the input list):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '3\. You’re given a Python function that is supposed to check if a string is
    a valid password. A valid password must meet the following criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It must be at least 8 characters long.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It must contain at least one uppercase letter.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It must contain at least one lowercase letter.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It must contain at least one digit.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'However, the function isn’t working correctly. Determine what is wrong with
    the function and fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '4\. You’re writing a Python function to greet users based on the time of day.
    The function takes an hour (integer between 0 and 23) as input and returns a greeting
    message (“Good morning”, “Good afternoon”, or “Good evening”):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You’re considering using this prompt to ask Copilot to help you fix the bug:
    “I have a function to greet users based on the time of day, but it seems to classify
    noon as ‘Good evening’. Can you help me fix the logic?” The prompt mentions the
    problem but doesn’t pinpoint the exact error. See if you can edit the provided
    prompt to make it more specific and guide Copilot toward suggesting the correct
    fix.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging is an important skill that includes finding errors in code and then
    correcting them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Print` statements can be an effective way of learning about what is happening
    in your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The VS Code debugger is another way of learning what is happening in your code
    that provides powerful features for monitoring how variables change as the code
    executes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once an error is uncovered, there are multiple ways to help Copilot fix the
    error for you, but if that fails, you can often fix the code directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our workflow of designing functions now includes debugging, and with the skill
    of debugging, you’re more apt to write the software you want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside of debugging, the VS Code debugger can be a powerful tool in learning
    more about how the code works.***********
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
