- en: Chapter 14\. Customizing Execution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。执行定制
- en: Python exposes, supports, and documents many of its internal mechanisms. This
    may help you understand Python at an advanced level, and lets you hook your own
    code into such Python mechanisms, controlling them to some extent. For example,
    [“Python built-ins”](ch07.xhtml#python_built_ins) covers the way Python arranges
    for built-ins to be visible. This chapter covers some other advanced Python techniques,
    including site customization, termination functions, dynamic execution, handling
    internal types, and garbage collection. We’ll look at other issues related to
    controlling execution using multiple threads and processes in [Chapter 15](ch15.xhtml#concurrency_threads_and_processes);
    [Chapter 17](ch17.xhtml#testingcomma_debuggingcomma_and_optimiz) covers issues
    specific to testing, debugging, and profiling.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python公开、支持并记录其许多内部机制。这可能帮助您在高级水平上理解Python，并允许您将自己的代码连接到这些Python机制中，以某种程度上控制它们。例如，[“Python内置函数”](ch07.xhtml#python_built_ins)介绍了Python安排内置函数可见的方式。本章还涵盖了一些其他高级Python技术，包括站点定制、终止函数、动态执行、处理内部类型和垃圾回收。我们将在[第15章](ch15.xhtml#concurrency_threads_and_processes)中讨论使用多线程和进程控制执行的其他问题；[第17章](ch17.xhtml#testingcomma_debuggingcomma_and_optimiz)涵盖了与测试、调试和性能分析相关的特定问题。
- en: Per-Site Customization
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 站点定制
- en: Python provides a specific “hook” to let each site customize some aspects of
    Python’s behavior at the start of each run. Python loads the standard module site
    just before the main script. If Python is run with the option **-S**, it does
    not load site. **-S** allows faster startup but saddles the main script with initialization
    chores. site’s tasks are, chiefly, to put sys.path in standard form (absolute
    paths, no duplicates), including as directed by environment variables, by virtual
    environments, and by each *.pth* file found in a directory in sys.path.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一个特定的“钩子”来让每个站点在每次运行开始时定制Python行为的某些方面。Python在主脚本之前加载标准模块site。如果使用**-S**选项运行Python，则不加载site。**-S**允许更快的启动，但会为主脚本增加初始化任务。site的主要任务是将sys.path放置在标准形式中（绝对路径，无重复项），包括根据环境变量、虚拟环境和在sys.path中找到的每个*.pth*文件的指示。
- en: Secondarily, if the session starting is an interactive one, site adds several
    handy built-ins (such as exit, copyright, etc.) and, if readline is enabled, configure
    autocompletion as the function of the Tab key.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果启动的会话是交互式的，则site会添加几个方便的内置函数（例如exit、copyright等），并且如果启用了readline，则配置Tab键的自动完成功能。
- en: In any normal Python installation, the installation process sets everything
    up to ensure that site’s work is sufficient to let Python programs and interactive
    sessions run “normally,” i.e., as they would on any other system with that version
    of Python installed. In exceptional cases, if as a system administrator (or in
    an equivalent role, such as a user who has installed Python in their home directory
    for their sole use) you think you absolutely need to do some customization, perform
    it in a new file called *sitecustomize.py* (create it in the same directory where
    *site.py* lives).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何正常的Python安装中，安装过程设置了一切以确保site的工作足以让Python程序和交互式会话“正常”运行，即与安装了该版本Python的任何其他系统上的运行方式相同。在特殊情况下，如果作为系统管理员（或在等效角色，例如已将Python安装在其主目录以供个人使用的用户）认为绝对需要进行一些定制，则在名为*sitecustomize.py*的新文件中执行此操作（在与*site.py*相同的目录中创建它）。
- en: Avoid Modifying site.py
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免修改site.py
- en: We strongly recommend that you do *not* alter the *site.py* file that performs
    the base customization. Doing so might cause Python to behave differently on your
    system than elsewhere. In any case, the *site.py* file will be overwritten each
    and every time you update your Python installation, and your modifications will
    be lost.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您不要修改执行基础定制的*site.py*文件。这样做可能会导致Python在您的系统上的行为与其他地方不同。无论如何，*site.py*文件每次更新Python安装时都会被覆盖，您的修改将会丢失。
- en: In the rare cases where *sitecustomize.py* is present, what it typically does
    is add yet more dictionaries to sys.path—the best way to perform this task is
    for *sitecustomize.py* to **import** site and then to call site.addsitedir(*path_to_a_dir*).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在*sitecustomize.py*存在的罕见情况下，它通常的作用是将更多字典添加到sys.path中——执行此任务的最佳方法是让*sitecustomize.py*
    **import** site，然后调用site.addsitedir(*path_to_a_dir*)。
- en: Termination Functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止函数
- en: The atexit module lets you register termination functions (i.e., functions to
    be called at program termination, in LIFO order). Termination functions are similar
    to cleanup handlers established by **try**/**finally** or **with**. However, termination
    functions are globally registered and get called at the end of the whole program,
    while cleanup handlers are established lexically and get called at the end of
    a specific **try** clause or **with** statement. Termination functions and cleanup
    handlers are called whether the program terminates normally or abnormally, but
    not when the program ends by calling os._exit (so you normally call sys.exit instead).
    The atexit module supplies a function called register that takes as arguments
    *func*, **args*, and **kwds* and ensures that *func*(**args*, ***kwds*) is called
    at program termination time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`atexit` 模块允许你注册终止函数（即，在程序终止时按 LIFO 顺序调用的函数）。终止函数类似于由 **try**/**finally** 或
    **with** 建立的清理处理程序。然而，终止函数是全局注册的，在整个程序结束时调用，而清理处理程序是在特定 **try** 子句或 **with** 语句结束时调用的。终止函数和清理处理程序在程序正常或异常终止时都会被调用，但不会在通过调用
    `os._exit` 终止程序时调用（所以通常调用 `sys.exit`）。`atexit` 模块提供了一个名为 `register` 的函数，接受 *func*、**args**
    和 **kwds** 作为参数，并确保在程序终止时调用 *func*（**args**，***kwds***）。'
- en: Dynamic Execution and exec
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态执行和 `exec`
- en: 'Python’s exec built-in function can execute code that you read, generate, or
    otherwise obtain during a program’s run. exec dynamically executes a statement
    or a suite of statements. It has the following syntax:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的内置函数 `exec` 可以在程序运行时执行你读取、生成或以其他方式获取的代码。`exec` 动态执行一个语句或一组语句。其语法如下：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*code* can be a str, bytes, bytearray, or code object. *globals* is a dict,
    and *locals* can be any mapping.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*code* 可以是 str、bytes、bytearray 或 code 对象。*globals* 是一个字典，*locals* 可以是任何映射。'
- en: If you pass both *globals* and *locals*, they are the global and local namespaces
    in which *code* runs. If you pass only *globals*, exec uses *globals* as both
    namespaces. If you pass neither, *code* runs in the current scope.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同时传递 *globals* 和 *locals*，它们分别是代码运行的全局和局部命名空间。如果只传递 *globals*，`exec` 将同时使用
    *globals* 作为全局和局部命名空间。如果两者都不传递，*code* 将在当前作用域中运行。
- en: Never Run exec in the Current Scope
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 永远不要在当前作用域中运行 `exec`
- en: 'Running exec in the current scope is a particularly bad idea: it can bind,
    rebind, or unbind any global name. To keep things under control, use exec, if
    at all, only with specific, explicit dictionaries.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前作用域中运行 `exec` 是一个特别糟糕的主意：它可以绑定、重新绑定或解绑任何全局名称。为了保持控制，请只在特定、显式的字典中使用 `exec`，如果必须的话。
- en: Avoiding exec
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用 `exec`
- en: 'A frequently asked question about Python is “How do I set a variable whose
    name I just read or built?” Literally, for a *global* variable, exec allows this,
    but it’s a very bad idea to use exec for this purpose. For example, if the name
    of the variable is in *varname*, you might think to use:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中经常被问到的一个问题是“如何设置一个我刚刚读取或构建的变量的名称？”确实，对于一个 *global* 变量，`exec` 允许这样做，但是为此目的使用
    `exec` 是一个非常糟糕的主意。例如，如果变量名是 *varname*，你可能会考虑使用：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Don’t do this*. An exec like this in the current scope makes you lose control
    of your namespace, leading to bugs that are extremely hard to find and making
    your program unfathomably difficult to understand. Keep the “variables” that you
    need to set with dynamically found names not as actual variables, but as entries
    in a dictionary (say, *mydict*). You might then consider using:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要这样做*。在当前作用域中这样的 `exec` 会使你失去命名空间的控制，导致极难找到的错误，并使你的程序难以理解。将你需要动态设置的“变量”保存为字典条目（例如，*mydict*）而不是实际变量。然后可以考虑使用：'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'While this is not quite as terrible as the previous example, it is still a
    bad idea. Keeping such “variables” as dictionary entries means that you don’t
    have any need to use exec to set them! Just code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方式不如前面的例子那么糟糕，但仍然不是一个好主意。将这些“变量”保存为字典条目意味着你不需要使用 `exec` 来设置它们！只需编写代码：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This way, your program is clearer, direct, elegant, and faster. There *are*
    some valid uses of exec, but they are extremely rare: just use explicit dictionaries
    instead.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你的程序会更清晰、直接、优雅且更快。有一些情况下确实可以使用 `exec`，但这些情况非常罕见：最好是使用显式字典。
- en: Strive to Avoid exec
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 努力避免 `exec`
- en: 'Use exec only when it’s really indispensable, which is *extremely* rare. Most
    often, it’s best to avoid exec and choose more specific, well-controlled mechanisms:
    exec weakens your control of your code’s namespace, can damage your program’s
    performance, and exposes you to numerous hard-to-find bugs and huge security risks.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在确实不可或缺时才使用exec，这种情况*极为*罕见。通常最好避免exec，并选择更具体、更受控制的机制：exec会削弱您对代码命名空间的控制，可能损害程序的性能，并使您面临许多难以发现的错误和巨大的安全风险。
- en: Expressions
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式
- en: exec can execute an expression, because any expression is also a valid statement
    (called an *expression statement*). However, Python ignores the value returned
    by an expression statement. To evaluate an expression and obtain the expression’s
    value, use the built-in function eval, covered in [Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio).
    (Note, however, that just about all of the same security risk caveats for exec
    also apply to eval.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: exec可以执行表达式，因为任何表达式也都是有效的语句（称为*表达式语句*）。但是，Python会忽略表达式语句返回的值。要评估表达式并获取表达式的值，请使用内置函数eval，如[表格
    8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)中所述。（但请注意，exec的几乎所有安全风险警告同样适用于eval。）
- en: compile and Code Objects
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译和代码对象
- en: To make a code object to use with exec, call the built-in function compile with
    the last argument set to 'exec' (as covered in [Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一个代码对象用于exec，调用内置函数compile并将最后一个参数设置为'exec'（如[表格 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)中所述）。
- en: A code object *c* exposes many interesting read-only attributes whose names
    all start with 'co_', such as those listed in [Table 14-1](#read_only_attributes_of_code_objects).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个代码对象*c*展示了许多有趣的只读属性，它们的名称都以'co_'开头，比如在[表格 14-1](#read_only_attributes_of_code_objects)中列出的那些。
- en: Table 14-1\. Read-only attributes of code objects
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 14-1\. 代码对象的只读属性
- en: '| co_argcount | The number of parameters of the function of which *c* is the
    code (0 when *c* is not the code object of a function, but rather is built directly
    by compile) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| co_argcount | *c*所代表的函数的参数个数（当*c*不是函数的代码对象而是直接由compile构建时为0） |'
- en: '| co_code | A bytes object with *c*’s bytecode |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| co_code | 一个字节对象，包含*c*的字节码 |'
- en: '| co_consts | The tuple of constants used in *c* |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| co_consts | *c*中使用的常量的元组 |'
- en: '| co_filename | The name of the file *c* was compiled from (the string that
    is the second argument to compile, when *c* was built that way) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| co_filename | *c*编译生成的文件名（当*c*是这种方式构建时为compile的第二个参数的字符串） |'
- en: '| c⁠o⁠_⁠f⁠i⁠r⁠s⁠t​l⁠i⁠n⁠e⁠n⁠o | The initial line number (within the file named
    by co_filename) of the source code that was compiled to produce *c*, if *c* was
    built by compiling from a file |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| c⁠o⁠_⁠f⁠i⁠r⁠s⁠t​l⁠i⁠n⁠e⁠n⁠o | 源代码的初始行号（位于由co_filename命名的文件中），用于编译生成*c*，如果*c*是通过编译文件构建的话
    |'
- en: '| co_name | The name of the function of which *c* is the code (''<module>''
    when *c* is not the code object of a function but rather is built directly by
    compile) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| co_name | *c*所代表的函数的名称（当*c*不是函数的代码对象而是直接由compile构建时为''<module>''） |'
- en: '| co_names | The tuple of all identifiers used within *c* |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| co_names | *c*中使用的所有标识符的元组 |'
- en: '| co_varnames | The tuple of local variables’ identifiers in *c*, starting
    with parameter names |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| co_varnames | *c*中局部变量标识符的元组，以参数名称开头 |'
- en: Most of these attributes are useful only for debugging purposes, but some may
    help with advanced introspection, as exemplified later in this section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性大多仅用于调试目的，但有些可能有助于高级内省，正如本节后面所示的例子。
- en: If you start with a string holding one or more statements, first use compile
    on the string, then call exec on the resulting code object—that’s a bit better
    than giving exec the string to compile and execute. This separation lets you check
    for syntax errors separately from execution-time errors. You can often arrange
    things so that the string is compiled once and the code object executes repeatedly,
    which speeds things up. eval can also benefit from such separation. Moreover,
    the compile step is intrinsically safe (both exec and eval are extremely risky
    if you execute them on code that you don’t 100% trust), and you may be able to
    check the code object before it executes, to lessen the risk (though it will never
    truly be zero).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从包含一个或多个语句的字符串开始，首先对字符串使用 compile，然后在生成的代码对象上调用 exec—这比直接将字符串传递给 exec 来编译和执行要好一些。
    这种分离允许您单独检查语法错误和执行时错误。 您通常可以安排事务以便字符串只编译一次，而代码对象重复执行，这样可以加快速度。 eval 也可以从这种分离中受益。
    此外，编译步骤本质上是安全的（如果在您不完全信任的代码上执行 exec 和 eval 非常危险），您可以在执行代码对象之前检查它，以减少风险（尽管风险永远不会完全为零）。
- en: 'As mentioned in [Table 14-1](#read_only_attributes_of_code_objects), a code
    object has a read-only attribute co_names that is the tuple of the names used
    in the code. For example, say that you want the user to enter an expression that
    contains only literal constants and operators—no function calls or other names.
    Before evaluating the expression, you can check that the string the user entered
    satisfies these constraints:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 [表 14-1](#read_only_attributes_of_code_objects) 中所述，代码对象具有只读属性 co_names，该属性是代码中使用的名称的元组。
    例如，假设您希望用户输入仅包含文字常量和操作符的表达式—不包含函数调用或其他名称。 在评估表达式之前，您可以检查用户输入的字符串是否满足这些约束：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function safer_eval evaluates the expression passed in as argument *s*
    only when the string is a syntactically valid expression (otherwise, compile raises
    SyntaxError) and contains no names at all (otherwise, safer_eval explicitly raises
    ValueError). (This is similar to the standard library function ast.literal_eval,
    covered in [“Standard Input”](ch11.xhtml#standard_input), but a bit more powerful,
    since it does allow the use of operators.)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 safer_eval 评估作为参数传递的表达式 *s*，仅当字符串是语法上有效的表达式（否则，compile 会引发 SyntaxError），且完全不包含任何名称（否则，safer_eval
    明确引发 ValueError）。 （这类似于标准库函数 ast.literal_eval，详见 [“标准输入”](ch11.xhtml#standard_input)，但更为强大，因为它允许使用操作符。）
- en: 'Knowing what names the code is about to access may sometimes help you optimize
    the preparation of the dictionary that you need to pass to exec or eval as the
    namespace. Since you need to provide values only for those names, you may save
    work by not preparing other entries. For example, say that your application dynamically
    accepts code from the user, with the convention that variable names starting with
    data_ refer to files residing in the subdirectory *data* that user-written code
    doesn’t need to read explicitly. User-written code may, in turn, compute and leave
    results in global variables with names starting with result_, which your application
    writes back as files in the *data* subdirectory. Thanks to this convention, you
    may later move the data elsewhere (e.g., to BLOBs in a database instead of files
    in a subdirectory), and user-written code won’t be affected. Here’s how you might
    implement these conventions efficiently:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 了解代码即将访问的名称有时可能有助于优化您需要传递给 exec 或 eval 作为命名空间的字典的准备工作。 由于您只需要为这些名称提供值，因此您可以通过不准备其他条目来节省工作。
    例如，假设您的应用程序动态接受来自用户的代码，并且约定以 data_ 开头的变量名引用存储在子目录 *data* 中的文件，用户编写的代码不需要显式读取。
    用户编写的代码反过来可能会计算并将结果留在以 result_ 开头的全局变量中，您的应用程序将这些结果作为文件写回 *data* 子目录。 由于这种约定，稍后您可以将数据移动到其他位置（例如，到数据库中的
    BLOBs，而不是子目录中的文件），用户编写的代码不会受到影响。 这是您可能如何有效实现这些约定的方法：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Never exec or eval Untrusted Code
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 永远不要执行或评估不受信任的代码。
- en: 'Some older versions of Python supplied tools that aimed to ameliorate the risks
    of using exec and eval, under the heading of “restricted execution,” but those
    tools were never entirely secure against the ingenuity of able hackers, and recent
    versions of Python have dropped them to avoid offering the user an unfounded sense
    of security. If you need to guard against such attacks, take advantage of your
    operating system’s protection mechanisms: run untrusted code in a separate process,
    with privileges as restricted as you can possibly make them (study the mechanisms
    that your OS supplies for the purpose, such as chroot, setuid, and jail; in Windows,
    you might try the third-party commercial add-on [WinJail](https://oreil.ly/a4hf4),
    or run untrusted code in a separate, highly constrained virtual machine or container,
    if you’re an expert on how to securitize containers). To guard against denial
    of service attacks, have the main process monitor the separate one and terminate
    the latter if and when resource consumption becomes excessive. Processes are covered
    in [“Running Other Programs”](ch15.xhtml#running_other_programs).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的 Python 提供了旨在减轻使用 `exec` 和 `eval` 风险的工具，称为“受限执行”，但这些工具从未完全安全，无法抵御有能力的黑客的狡猾攻击。最近的
    Python 版本已经放弃了这些工具，以避免为用户提供不合理的安全感。如果需要防范此类攻击，请利用操作系统提供的保护机制：在一个单独的进程中运行不受信任的代码，并尽可能限制其权限（研究操作系统提供的用于此目的的机制，如
    chroot、setuid 和 jail；在 Windows 上，可以尝试第三方商业附加组件 [WinJail](https://oreil.ly/a4hf4)，或者如果你是容器安全化专家，可以在一个单独且高度受限的虚拟机或容器中运行不受信任的代码）。为了防范服务拒绝攻击，主进程应监控单独的进程，并在资源消耗过多时终止后者。进程在
    [“运行其他程序”](ch15.xhtml#running_other_programs) 中有详细描述。
- en: exec and eval Are Unsafe with Untrusted Code
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`exec` 和 `eval` 在不受信任的代码中是不安全的。'
- en: 'The function exec_with_data defined in the previous section is not at all safe
    against untrusted code: if you pass to it, as the argument *user_code*, some string
    obtained in a way that you cannot *entirely* trust, there is essentially no limit
    to the amount of damage it might do. This is unfortunately true of just about
    any use of exec or eval, except for those rare cases in which you can set extremely
    strict and fully checkable limits on the code to execute or evaluate, as was the
    case for the function safer_eval.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中定义的 `exec_with_data` 函数对不受信任的代码根本不安全：如果将作为参数 `user_code` 传递给它的字符串来自于你不能完全信任的方式，那么它可能会造成无法估量的损害。不幸的是，这几乎适用于任何使用
    `exec` 或 `eval` 的情况，除非你能对要执行或评估的代码设置极其严格和完全可检查的限制，就像 `safer_eval` 函数的情况一样。
- en: Internal Types
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部类型
- en: Some of the internal Python objects described in this section are hard to use,
    and indeed are not meant for you to use most of the time. Using such objects correctly
    and to good effect requires some study of your Python implementation’s C sources.
    Such black magic is rarely needed, except for building general-purpose development
    tools and similar wizardly tasks. Once you do understand things in depth, Python
    empowers you to exert control if and when needed. Since Python exposes many kinds
    of internal objects to your Python code, you can exert that control by coding
    in Python, even when you need an understanding of C to read Python’s sources and
    understand what’s going on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的一些内部 Python 对象使用起来很困难，事实上并不是大多数情况下你应该使用的。正确地使用这些对象并产生良好效果需要一些研究你的 Python
    实现的 C 源码。这种黑魔法很少需要，除非用于构建通用开发工具和类似的高级任务。一旦你深入理解事物，Python 赋予你在必要时施加控制的能力。由于 Python
    将许多种类的内部对象暴露给你的 Python 代码，即使需要理解 C 来阅读 Python 的源代码并理解正在发生的事情，你也可以通过在 Python 中编码来施加这种控制。
- en: Type Objects
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型对象
- en: The built-in type named type acts as a callable factory, returning objects that
    are types. Type objects don’t have to support any special operations except equality
    comparison and representation as strings. However, most type objects are callable
    and return new instances of the type when called. In particular, built-in types
    such as int, float, list, str, tuple, set, and dict all work this way; specifically,
    when called without arguments, they return a new empty instance, or, for numbers,
    one that equals 0. The attributes of the types module are the built-in types that
    don’t have built-in names. Besides being callable to generate instances, type
    objects are useful because you can inherit from them, as covered in [“Classes
    and Instances”](ch04.xhtml#classes_and_instances).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`type`的内置类型充当可调用的工厂，返回类型对象。类型对象除了等价比较和表示为字符串外，不需要支持任何特殊操作。但是，大多数类型对象是可调用的，并在调用时返回该类型的新实例。特别地，内置类型如`int`、`float`、`list`、`str`、`tuple`、`set`和`dict`都是这样工作的；具体来说，当不带参数调用它们时，它们返回一个新的空实例，或者对于数字，返回等于0的实例。类型模块的属性是没有内置名称的内置类型。除了调用以生成实例外，类型对象之所以有用，还因为你可以从中继承，正如[“类和实例”](ch04.xhtml#classes_and_instances)中所涵盖的那样。
- en: The Code Object Type
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码对象类型
- en: 'Besides using the built-in function compile, you can get a code object via
    the __code__ attribute of a function or method object. (For a discussion of the
    attributes of code objects, see [“compile and Code Objects”](#compile_and_code_objects).)
    Code objects are not callable, but you can rebind the __code__ attribute of a
    function object with the right number of parameters in order to wrap a code object
    into callable form. For example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用内置函数`compile`，你还可以通过函数或方法对象的`__code__`属性获取代码对象。（有关代码对象属性的讨论，请参见[“编译和代码对象”](#compile_and_code_objects)。）代码对象本身不能被调用，但是你可以重新绑定函数对象的`__code__`属性，使用正确数量的参数将代码对象包装成可调用形式。例如：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Code objects that have no parameters can also be used with exec or eval. Directly
    creating code objects requires many parameters; see Stack Overflow’s [unofficial
    docs](https://oreil.ly/pM3m7) on how to do it (but bear in mind that you’re usually
    better off calling compile instead).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数的代码对象也可以与`exec`或`eval`一起使用。直接创建代码对象需要许多参数；请参阅Stack Overflow的[非官方文档](https://oreil.ly/pM3m7)了解如何操作（但请记住，通常最好调用`compile`而不是直接创建）。
- en: The Frame Type
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帧类型
- en: The function _getframe in the module sys returns a frame object from Python’s
    call stack. A frame object has attributes giving information about the code executing
    in the frame and the execution state. The traceback and inspect modules help you
    access and display such information, particularly when an exception is being handled.
    [Chapter 17](ch17.xhtml#testingcomma_debuggingcomma_and_optimiz) provides more
    information about frames and tracebacks, and covers the module inspect, which
    is the best way to perform such introspection. As the leading underscore in the
    name _getframe hints, the function is “somewhat private”; it’s meant for use only
    by tools such as debuggers, which inevitably require deep introspection into Python’s
    internals.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`sys`中的函数`_getframe`从Python调用栈返回一个帧对象。帧对象具有属性，提供关于在帧中执行的代码和执行状态的信息。`traceback`和`inspect`模块帮助你访问和显示这些信息，特别是在处理异常时。[第17章](ch17.xhtml#testingcomma_debuggingcomma_and_optimiz)提供了关于帧和回溯的更多信息，并涵盖了模块`inspect`，这是执行此类内省的最佳方式。如函数名`_getframe`中的前导下划线提示的那样，该函数是“有些私有”的；它仅供调试器等工具使用，这些工具不可避免地需要深入内省Python的内部。
- en: Garbage Collection
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Python’s garbage collection normally proceeds transparently and automatically,
    but you can choose to exert some direct control. The general principle is that
    Python collects each object *x* at some time after *x* becomes unreachable—that
    is, when no chain of references can reach *x* by starting from a local variable
    of a function instance that is executing, or from a global variable of a loaded
    module. Normally, an object *x* becomes unreachable when there are no references
    at all to *x*. In addition, a group of objects can be unreachable when they reference
    each other but no global or local variables reference any of them, even indirectly
    (such a situation is known as a *mutual reference loop*).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的垃圾收集通常是透明且自动进行的，但您可以选择直接进行一些控制。一般原则是，Python 在对象 *x* 成为不可达时的某个时刻收集 *x*，即当没有从正在执行的函数实例的本地变量或从已加载模块的全局变量开始的引用链能够到达
    *x* 时。通常，当没有任何引用指向 *x* 时，对象 *x* 变得不可达。此外，当一组对象彼此引用但没有全局或局部变量间接引用它们时，它们也可能是不可达的（这种情况称为*相互引用循环*）。
- en: Classic Python keeps with each object *x* a count, known as a *reference count*,
    of how many references to *x* are outstanding. When *x*’s reference count drops
    to 0, CPython immediately collects *x*. The function getrefcount of the module
    sys accepts any object and returns its reference count (at least 1, since getrefcount
    itself has a reference to the object it’s examining). Other versions of Python,
    such as Jython or PyPy, rely on other garbage collection mechanisms supplied by
    the platform they run on (e.g., the JVM or the LLVM). The modules gc and weakref,
    therefore, apply only to CPython.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 经典 Python 对每个对象 *x* 都保留一个称为*引用计数*的计数，记录了有多少引用指向 *x*。当 *x* 的引用计数降至 0 时，CPython
    立即收集 *x*。模块 sys 的函数 getrefcount 接受任何对象并返回其引用计数（至少为 1，因为 getrefcount 本身对要检查的对象有一个引用）。其他版本的
    Python（如 Jython 或 PyPy）依赖于由其运行的平台提供的其他垃圾收集机制（例如 JVM 或 LLVM）。因此，模块 gc 和 weakref
    仅适用于 CPython。
- en: When Python garbage-collects *x* and there are no references to *x*, Python
    finalizes *x* (i.e., calls *x*.__del__) and frees the memory that *x* occupied.
    If *x* held any references to other objects, Python removes the references, which
    in turn may make other objects collectable by leaving them unreachable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 回收 *x* 并且没有对 *x* 的引用时，Python 会完成 *x* 的最终处理（即调用 *x*.__del__）并释放 *x*
    占用的内存。如果 *x* 持有对其他对象的引用，Python 会移除这些引用，从而可能使其他对象因无法访问而可回收。
- en: The gc Module
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gc 模块
- en: 'The gc module exposes the functionality of Python’s garbage collector. gc deals
    with unreachable objects that are part of mutual reference loops. As mentioned
    previously, in such a loop, each object in the loop refers to one or more of the
    others, keeping the reference counts of all the objects positive, but there are
    no outside references to any of the set of mutually referencing objects. Therefore,
    the whole group, also known as *cyclic garbage*, is unreachable and thus garbage-collectable.
    Looking for such cyclic garbage loops takes time, which is why the module gc exists:
    to help you control whether and when your program spends that time. By default,
    cyclic garbage collection functionality is enabled with some reasonable default
    parameters: however, by importing the gc module and calling its functions, you
    may choose to disable the functionality, change its parameters, and/or find out
    exactly what’s going on in this respect.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: gc 模块公开了 Python 垃圾收集器的功能。gc 处理了属于相互引用循环的不可达对象。如前所述，在这样的循环中，循环中的每个对象都引用另一个或多个其他对象，保持所有对象的引用计数为正数，但没有外部引用指向这组相互引用的对象集。因此，整个组，也称为*循环垃圾*，是不可达的，因此可以进行垃圾收集。寻找这样的循环垃圾需要时间，这也是为什么
    gc 模块存在的原因：帮助您控制程序是否以及何时花费这些时间。默认情况下，循环垃圾收集功能处于启用状态，并具有一些合理的默认参数；但是，通过导入 gc 模块并调用其函数，您可以选择禁用功能、更改其参数和/或详细了解这方面的情况。
- en: gc exposes attributes and functions to help you manage and instrument cyclic
    garbage collection, including those listed in [Table 14-2](#tabe_onefour_twodot_gc_functions_and_at).
    These functions can let you track down memory leaks—objects that are not collected
    even though there *should* be no more references to them—by helping you discover
    what other objects are in fact holding on to references to them. Note that gc
    implements the architecture known in computer science as [generational garbage
    collection](https://oreil.ly/zeGDK).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: gc 提供了属性和函数来帮助您管理和调整循环垃圾回收，包括 [表 14-2](#tabe_onefour_twodot_gc_functions_and_at)
    中列出的内容。这些函数可以帮助您追踪内存泄漏 —— 尽管 *应该* 不再有对它们的引用，但仍然没有被回收的对象 —— 通过帮助您发现确实持有对它们引用的其他对象来发现它们。请注意，gc
    实现了计算机科学中称为 [分代垃圾回收](https://oreil.ly/zeGDK) 的体系结构。
- en: Table 14-2\. gc functions and attributes
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-2\. gc 函数和属性
- en: '| callbacks | A list of callbacks that the garbage collector will invoke before
    and after collection. See [“Instrumenting garbage collection”](#instrumenting_garbage_collection)
    for further details. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| callbacks | 垃圾收集器将在收集之前和之后调用的回调函数列表。有关详细信息，请参阅 [“仪器化垃圾回收”](#instrumenting_garbage_collection)。
    |'
- en: '| collect | collect() Forces a full cyclic garbage collection run to happen
    immediately. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| collect | collect() 立即强制执行完整的循环垃圾回收运行。 |'
- en: '| disable | disable() Suspends automatic, periodic cyclic garbage collection.
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| disable | disable() 暂停自动周期性循环垃圾回收。 |'
- en: '| enable | enable() Reenables periodic cyclic garbage collection previously
    suspended with disable. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| enable | enable() 重新启用先前使用 disable 暂停的周期性循环垃圾回收。 |'
- en: '| freeze | freeze() Freezes all objects tracked by gc: moves them to a “permanent
    generation,” i.e., a set of objects to be ignored in all the future collections.
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| freeze | freeze() 冻结 gc 跟踪的所有对象：将它们移动到“永久代”，即一组在所有未来收集中被忽略的对象。 |'
- en: '| garbage | A list (but, treat it as read-only) of unreachable but uncollectable
    objects. This happens when any object in a cyclic garbage loop has a __del__ special
    method, as there may be no demonstrably safe order for Python to finalize such
    objects. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| garbage | 不可达但不可收集的对象列表（仅读）。当循环垃圾回收环中的任何对象具有 __del__ 特殊方法时，可能不存在明显安全的顺序来终结这些对象。
    |'
- en: '| get_count | get_count() Returns the current collection counts as a tuple,
    (count0, count1, count2). |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| get_count | get_count() 返回当前收集计数的元组，形式为 (count0, count1, count2)。 |'
- en: '| get_debug | get_debug() Returns an int bit string, the garbage collection
    debug flags set with set_debug. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| get_debug | get_debug() 返回一个整数位串，表示使用 set_debug 设置的垃圾回收调试标志。 |'
- en: '| get_freeze_count | get_freeze_count() Returns the number of objects in the
    permanent generation. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| get_freeze_count | get_freeze_count() 返回永久代中对象的数量。 |'
- en: '| get_objects | get_objects(generation=**None**) Returns a list of objects
    being tracked by the collector. 3.8+ If the optional generation argument is not
    **None**, lists only those objects in the selected generation. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| get_objects | get_objects(generation=**None**) 返回被收集器跟踪的对象列表。3.8+ 如果选择的 generation
    参数不是 **None**，则仅列出所选代中的对象。 |'
- en: '| get_referents | get_referents(**objs*) Returns a list of objects, visited
    by the arguments’ C-level tp_traverse methods, that are referred to by any of
    the arguments. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| get_referents | get_referents(**objs*) 返回由参数的 C 级 tp_traverse 方法访问的对象列表，这些对象被参数中任何一个引用。
    |'
- en: '| get_referrers | get_referrers(**objs*) Returns a list of all container objects
    currently tracked by the cyclic garbage collector that refer to any one or more
    of the arguments. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| get_referrers | get_referrers(**objs*) 返回当前由循环垃圾回收器跟踪的所有容器对象列表，这些对象引用参数中的任意一个或多个对象。
    |'
- en: '| get_stats | get_stats() Returns a list of three dicts, one per generation,
    containing counts of the number of collections, the number of objects collected,
    and the number of uncollectable objects. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| get_stats | get_stats() 返回三个字典的列表，每个字典代表一代，包含收集次数、收集的对象数和不可收集对象数。 |'
- en: '| get_threshold | get_threshold() Returns the current collection thresholds
    as a tuple of the three ints. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| get_threshold | get_threshold() 返回当前收集阈值，以三个整数的元组形式返回。 |'
- en: '| isenabled | isenabled() Returns **True** when cyclic garbage collection is
    currently enabled; otherwise returns **False****.** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| isenabled | isenabled() 当前循环垃圾回收启用时返回 **True**；否则返回 **False**。 |'
- en: '| is_finalized | is_finalized(*obj*) 3.9+ Returns **True** when the garbage
    collector has finalized *obj*; otherwise, returns **False**. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| is_finalized | is_finalized(*obj*) 3.9+ 当垃圾回收器已经完成对 *obj* 的终结时返回 **True**；否则返回
    **False**。 |'
- en: '| is_tracked | is_tracked(*obj*) Returns **True** when *obj* is currently tracked
    by the garbage collector; otherwise, returns **False**. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| is_tracked | is_tracked(*obj*) 当 *obj* 当前被垃圾收集器跟踪时返回 **True**；否则返回 **False**。
    |'
- en: '| set_debug | set_debug(*flags*) Sets flags for debugging behavior during garbage
    collection. *flags* is an int, interpreted as a bit string, built by ORing (with
    the bitwise OR operator, &#124;) zero or more constants supplied by the module
    gc. Each bit enables a specific debugging function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '| set_debug | set_debug(*flags*) 设置在垃圾收集期间的调试行为标志。 *flags* 是一个整数，被解释为通过按位 OR（位或运算符，&#124;）零个或多个模块
    gc 提供的常量来构建的位字符串。 每个位启用一个特定的调试功能：'
- en: DEBUG_COLLECTABLE
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: DEBUG_COLLECTABLE
- en: Prints information on collectable objects found during garbage collection.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 打印在垃圾收集期间发现的可收集对象的信息。
- en: DEBUG_LEAK
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: DEBUG_LEAK
- en: Combines behavior for DEBUG_COLLECTABLE, DEBUG_UNCOLLECTABLE, and DEBUG_SAVEALL.
    Together, these are the most common flags used to help you diagnose memory leaks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 结合 DEBUG_COLLECTABLE、DEBUG_UNCOLLECTABLE 和 DEBUG_SAVEALL 的行为。 这些通常是用于帮助诊断内存泄漏的最常见标志。
- en: DEBUG_SAVEALL
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: DEBUG_SAVEALL
- en: Saves all collectable objects to the list gc.garbage (where uncollectable ones
    are also always saved) to help you diagnose leaks.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有可收集对象保存到列表 gc.garbage 中（其中不可收集对象也始终保存）以帮助您诊断泄漏问题。
- en: DEBUG_STATS
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: DEBUG_STATS
- en: Prints statistics gathered during garbage collection to help you tune the thresholds.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 打印在垃圾收集期间收集的统计信息，以帮助您调整阈值。
- en: DEBUG_UNCOLLECTABLE
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: DEBUG_UNCOLLECTABLE
- en: Prints information on uncollectable objects found during garbage collection.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 打印在垃圾收集期间发现的不可收集对象的信息。
- en: '|'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| set_threshold | set_threshold(*thresh0*[, *thresh1*[, *thresh2*]]) Sets thresholds
    that control how often cyclic garbage collection cycles run. A *thresh0* of 0
    disables garbage collection. Garbage collection is an advanced, specialized topic,
    and the details of the generational garbage collection approach used in Python
    (and consequently the detailed meanings of these thresholds) are beyond the scope
    of this book; see the [online docs](https://oreil.ly/b3rm6) for details. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| set_threshold | set_threshold(*thresh0*[, *thresh1*[, *thresh2*]]) 设置控制循环垃圾收集周期运行频率的阈值。
    *thresh0* 为 0 会禁用垃圾收集。 垃圾收集是一个高级的专题，Python 中使用的分代垃圾收集方法的详细内容（以及因此这些阈值的详细含义）超出了本书的范围；
    有关详细信息，请参阅 [在线文档](https://oreil.ly/b3rm6)。'
- en: '| unfreeze | unfreeze() Unfreezes all objects in the permanent generation,
    moving them all back to the oldest generation. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| unfreeze | unfreeze() 解冻永久代中的所有对象，将它们全部移回到最老的代中。 |'
- en: 'When you know there are no cyclic garbage loops in your program, or when you
    can’t afford the delay of cyclic garbage collection at some crucial time, suspend
    automatic garbage collection by calling gc.disable(). You can enable collection
    again later by calling gc.enable(). You can test whether automatic collection
    is currently enabled by calling gc.isenabled(), which returns **True** or **False**.
    To control *when* time is spent collecting, you can call gc.collect() to force
    a full cyclic collection run to happen immediately. To wrap some time-critical
    code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当您知道程序中没有循环垃圾环路，或者在某些关键时刻不能承受循环垃圾收集的延迟时，通过调用 gc.disable() 暂时停止自动垃圾收集。 您可以稍后通过调用
    gc.enable() 再次启用收集。 您可以通过调用 gc.isenabled() 测试当前是否启用了自动收集，它返回 **True** 或 **False**。
    要控制收集时机，可以调用 gc.collect() 强制立即执行完整的循环收集运行。 要包装一些时间关键的代码：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You may find this easier to use if implemented as a context manager:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将其实现为上下文管理器，您可能会发现这更容易使用：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Other functionality in the module gc is more advanced and rarely used, and can
    be grouped into two areas. The functions get_threshold and set_threshold and debug
    flag DEBUG_STATS help you fine-tune garbage collection to optimize your program’s
    performance. The rest of gc’s functionality can help you diagnose memory leaks
    in your program. While gc itself can automatically fix many leaks (as long as
    you avoid defining __del__ in your classes, since the existence of __del__ can
    block cyclic garbage collection), your program runs faster if it avoids creating
    cyclic garbage in the first place.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块 gc 中的其他功能更为高级且很少使用，可以分为两个领域。 函数 get_threshold 和 set_threshold 以及调试标志 DEBUG_STATS
    帮助您微调垃圾收集以优化程序的性能。 gc 的其余功能可以帮助您诊断程序中的内存泄漏。 虽然 gc 本身可以自动修复许多泄漏问题（只要避免在类中定义 __del__，因为存在
    __del__ 可以阻止循环垃圾收集），但是如果首先避免创建循环垃圾，程序运行速度将更快。
- en: Instrumenting garbage collection
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 垃圾收集工具
- en: gc.callbacks is an initially empty list to which you can add functions f(*phase*,
    *info*) which Python is to call upon garbage collection. When Python calls each
    such function, *phase* is 'start' or 'stop' to mark the beginning or end of a
    collection, and *info* is a dictionary containing information about the generational
    collection used by CPython. You can add functions to this list, for example to
    gather statistics about garbage collection. See the [documentation](https://oreil.ly/GjJF-)
    for more details.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: gc.callbacks 是一个最初为空的列表，您可以向其中添加函数 f(*phase*, *info*)，Python 将在垃圾回收时调用这些函数。当Python调用每个这样的函数时，*phase*
    为 'start' 或 'stop'，用于标记收集的开始或结束，*info* 是一个字典，包含由CPython使用的分代收集的信息。您可以向此列表添加函数，例如用于收集有关垃圾回收的统计信息。有关更多详细信息，请参阅[文档](https://oreil.ly/GjJF-)。
- en: The weakref Module
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱引用模块
- en: 'Careful design can often avoid reference loops. However, at times you need
    objects to know about each other, and avoiding mutual references would distort
    and complicate your design. For example, a container has references to its items,
    yet it can often be useful for an object to know about a container holding it.
    The result is a reference loop: due to the mutual references, the container and
    items keep each other alive, even when all other objects forget about them. Weak
    references solve this problem by allowing objects to reference others without
    keeping them alive.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎的设计通常可以避免引用循环。然而，有时你需要对象彼此知道对方的存在，避免相互引用可能会扭曲和复杂化你的设计。例如，一个容器引用了其项目，但是对象知道容器持有它也常常很有用。结果就是引用循环：由于相互引用，容器和项目保持彼此存活，即使所有其他对象都忘记了它们。弱引用通过允许对象引用其他对象而不保持它们存活来解决了这个问题。
- en: A *weak reference* is a special object *w* that refers to some other object
    *x* without incrementing *x*’s reference count. When *x*’s reference count goes
    down to 0, Python finalizes and collects *x*, then informs *w* of *x*’s demise.
    Weak reference *w* can now either disappear or get marked as invalid in a controlled
    way. At any time, a given *w* refers to either the same object *x* as when *w*
    was created, or to nothing at all; a weak reference is never retargeted. Not all
    types of objects support being the target *x* of a weak reference *w*, but classes,
    instances, and functions do.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*弱引用* 是一个特殊对象 *w*，它引用某个其他对象 *x* 而不增加 *x* 的引用计数。当 *x* 的引用计数降至 0 时，Python 将终止并收集
    *x*，然后通知 *w* *x* 的消亡。弱引用 *w* 现在可以消失或以受控方式标记为无效。在任何时候，给定的 *w* 要么引用创建 *w* 时的相同对象
    *x*，要么完全不引用；弱引用永远不会被重新定位。并非所有类型的对象都支持成为弱引用 *w* 的目标 *x*，但是类、实例和函数支持。'
- en: The weakref module exposes functions and types to create and manage weak references,
    detailed in [Table 14-3](#functions_and_classes_of_the_weakref_mo).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用模块公开了用于创建和管理弱引用的函数和类型，详见[表格 14-3](#functions_and_classes_of_the_weakref_mo)。
- en: Table 14-3\. Functions and classes of the weakref module
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 14-3\. 弱引用模块的函数和类
- en: '| getweakrefcount | getweakrefcount(*x*) Returns len(getweakrefs(*x*)). |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| getweakrefcount | getweakrefcount(*x*) 返回 len(getweakrefs(*x*))。 |'
- en: '| getweakrefs | getweakrefs(*x*) Returns a list of all weak references and
    proxies whose target is *x*. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| getweakrefs | getweakrefs(*x*) 返回所有目标为 *x* 的弱引用和代理的列表。 |'
- en: '| proxy | proxy(*x*[, *f*]) Returns a weak proxy *p* of type ProxyType (CallableProxyType
    when *x* is callable) with *x* as the target. Using *p* is just like using *x*,
    except that, when you use *p* after *x* has been deleted, Python raises ReferenceError.
    *p* is never hashable (you cannot use *p* as a dictionary key). When *f* is present,
    it must be callable with one argument, and is the finalization callback for *p*
    (i.e., right before finalizing *x*, Python calls *f*(*p*)).) *f* executes right
    *after* *x* is no longer reachable from *p*. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| proxy | proxy(*x*[, *f*]) 返回类型为 ProxyType（当 *x* 是可调用对象时为 CallableProxyType）的弱代理
    *p*，以 *x* 为目标。使用 *p* 就像使用 *x* 一样，但是当使用 *p* 时，*x* 被删除后，Python 将引发 ReferenceError。*p*
    永远不可哈希（您不能将 *p* 用作字典键）。当 *f* 存在时，它必须是一个接受一个参数的可调用对象，并且是 *p* 的最终化回调（即在 *x* 不再从
    *p* 可达时，Python 调用 *f*(*p*)）。*f* 在 *x* 不再从 *p* 可达后立即执行。 |'
- en: '| ref | ref(*x*[, *f*]) Returns a weak reference *w* of type ReferenceType
    with object *x* as the target. *w* is callable without arguments: calling *w*()
    returns *x* when *x* is still alive; otherwise, *w*() returns None. *w* is hashable
    when *x* is hashable. You can compare weak references for equality (==, !=), but
    not for order (<, >, <=, >=). Two weak references *x* and *y* are equal when their
    targets are alive and equal, or when *x* is *y*. When *f* is present, it must
    be callable with one argument and is the finalization callback for *w* (i.e.,
    right before finalizing *x*, Python calls *f*(*w*)). *f* executes right *after*
    *x* is no longer reachable from *w*. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| ref | ref(*x*[, *f*]) 返回类型为 ReferenceType 的对象 *x* 作为目标的弱引用 *w*。*w* 可以无参数地调用：调用
    *w*() 在 *x* 仍然存活时返回 *x*；否则，调用 *w*() 返回 None。当 *x* 可散列时，*w* 是可散列的。您可以比较弱引用的相等性（==、!=），但不能进行顺序比较（<、>、<=、>=）。当它们的目标存活且相等时，或者
    *x* 等于 *y* 时，两个弱引用 *x* 和 *y* 是相等的。当存在 *f* 时，它必须是一个带有一个参数的可调用对象，并且是 *w* 的最终化回调（即，在
    *x* 从 *w* 不再可达之后，Python 调用 *f*(*w*)）。*f* 在 *x* 不再从 *w* 可达后立即执行。'
- en: '| W⁠e⁠a⁠k⁠K⁠e⁠y​D⁠i⁠c⁠t⁠i⁠o⁠n⁠a⁠r⁠y | class WeakKeyDictionary(adict={}) A WeakKeyDictionary
    *d* is a mapping weakly referencing its keys. When the reference count of a key
    *k* in *d* goes to 0, item *d*[*k*] disappears. adict is used to initialize the
    mapping. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 弱键字典 | class WeakKeyDictionary(adict={}) 弱键字典 *d* 是一个弱引用其键的映射。当 *d* 中键 *k*
    的引用计数为 0 时，项目 *d*[*k*] 消失。adict 用于初始化映射。 |'
- en: '| WeakSet | class WeakSet(elements=[]) A WeakSet *s* is a set weakly referencing
    its content elements, initialized from elements. When the reference count of an
    element *e* in *s* goes to 0, *e* disappears from *s*. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 弱引用集 | class WeakSet(elements=[]) 弱引用集 *s* 是一个弱引用其内容元素的集合，从元素初始化。当 *s* 中元素
    *e* 的引用计数为 0 时，*e* 从 *s* 中消失。 |'
- en: '| W⁠e⁠a⁠k⁠V⁠a⁠l⁠u⁠e​D⁠i⁠c⁠t⁠i⁠o⁠n⁠a⁠r⁠y | class WeakValueDictionary(adict={})
    A WeakValueDictionary *d* is a mapping weakly referencing its values. When the
    reference count of a value *v* in *d* goes to 0, all items of *d* such that *d*[*k*]
    **is** *v* disappear. adict is used to initialize the mapping. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 弱值字典 | class WeakValueDictionary(adict={}) 弱值字典 *d* 是一个弱引用其值的映射。当 *d* 中值
    *v* 的引用计数为 0 时，*d* 中所有 *d*[*k*] **为** *v* 的项目消失。adict 用于初始化映射。 |'
- en: WeakKeyDictionary lets you noninvasively associate additional data with some
    hashable objects, with no change to the objects. WeakValueDictionary lets you
    noninvasively record transient associations between objects, and build caches.
    In each case, use a weak mapping, rather than a dict, to ensure that an object
    that is otherwise garbage-collectable is not kept alive just by being used in
    a mapping. Similarly, a WeakSet provides the same weak containment functionality
    in place of a normal set.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: WeakKeyDictionary 允许您在一些可散列对象上非侵入式地关联附加数据，而无需更改这些对象。WeakValueDictionary 允许您非侵入式地记录对象之间的瞬时关联，并构建缓存。在每种情况下，使用弱映射而不是字典，以确保其他情况下可被垃圾回收的对象不会仅因在映射中使用而保持活动状态。类似地，WeakSet
    在普通集合的位置提供了相同的弱包含功能。
- en: 'A typical example is a class that keeps track of its instances, but does not
    keep them alive just to keep track of them:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 典型示例是一个跟踪其实例但不仅仅是为了跟踪它们而使它们保持活动状态的类：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the Tracking instances are hashable, a similar class can be implemented
    using a WeakSet of the instances, or a WeakKeyDictionary with the instances as
    keys and **None** for the values.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当跟踪实例是可散列的时候，可以使用一个实例的WeakSet类实现类似的类，或者使用一个WeakKeyDictionary，其中实例作为键，**None**作为值。
