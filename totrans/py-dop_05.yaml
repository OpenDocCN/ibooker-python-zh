- en: Chapter 5\. Package Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, small scripts grow in usefulness and importance, which creates a need
    to share and distribute their contents. Python libraries, as well as other code
    projects, require packaging. Without packaging, distributing code becomes problematic
    and brittle.
  prefs: []
  type: TYPE_NORMAL
- en: Once past the proof of concept stage, it is helpful to keep track of changes,
    advertise the type of change (for example, when introducing a backward-incompatible
    update), and provide a way for users to depend on a specific version. Even in
    the most straightforward use cases, it is beneficial to follow a few (packaging)
    guidelines. This, at the very least, should mean keeping track of a changelog
    and determining a version.
  prefs: []
  type: TYPE_NORMAL
- en: There are several strategies to follow for package management, and knowing a
    few of the ones most commonly used allows you to adopt the best option to solve
    a problem. For example, it might be easier to distribute a Python library through
    the Python Package Index (PyPI) instead of making it a system package like Debian
    and RPM. If a Python script needs to run at specific intervals or if it is a long-running
    process, then system packaging working together with `systemd` might work better.
  prefs: []
  type: TYPE_NORMAL
- en: Although `systemd` is not a packaging tool, it does play well on systems that
    depend on it to manage processes and the server startup sequence. Learning how
    to handle processes with a few `systemd` configuration settings and some packaging
    is a great way to increase the capabilities of a Python project further.
  prefs: []
  type: TYPE_NORMAL
- en: The native Python packaging tools have a public hosting instance for packages
    (PyPI). However, for Debian and RPM packages, it requires some effort to provide
    a local repository. This chapter covers a few tools that make it easier to create
    and manage a package repository, including a local alternative to PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: Having a good understanding of the different packaging strategies, and healthy
    practices like proper versioning and keeping a changelog, provide a stable, consistent
    experience when distributing software.
  prefs: []
  type: TYPE_NORMAL
- en: Why Is Packaging Important?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several factors make packaging software an essential feature of a project (regardless
    of size!). Keeping track of versions and changes (via a changelog) is an excellent
    way to provide some insight into new features and bug fixes. Versioning allows
    others to determine better what might work within a project.
  prefs: []
  type: TYPE_NORMAL
- en: When trying to identify issues and bugs, a changelog with an accurate description
    of changes is an invaluable tool to help identify potential causes of system breakage.
  prefs: []
  type: TYPE_NORMAL
- en: It takes discipline and hard work to version a project, describe changes in
    a changelog, and provide a way for others to install and use a project. However,
    the benefits when distributing, debugging, upgrading, or even uninstalling are
    significant.
  prefs: []
  type: TYPE_NORMAL
- en: When Packaging Might Not Be Needed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you don’t need to distribute a project to other systems at all. Ansible
    playbooks are usually run from one server to manage other systems in the network.
    In cases like Ansible, it might be enough to follow versioning and keep a changelog.
  prefs: []
  type: TYPE_NORMAL
- en: Version control systems like Git make this easy with the use of tags. Tagging
    in Git would still be useful if a project does need to get packaged, since most
    tooling can consume the tag (as long as a tag represents a version) to produce
    a package.
  prefs: []
  type: TYPE_NORMAL
- en: Recently, there was a long debug session to determine why an installer for a
    large software project had stopped working. Suddenly, all the functional tests
    for a small Python tool that depended on the installer completing its deployment
    were failing. The installer did have versions and kept those versions synchronized
    with version control, but there was no changelog whatsoever that would have explained
    that recent changes were going to break an existing API. To find the issue, we
    had to go through all the recent commits to determine what could be the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going through a few commits shouldn’t be difficult, but try doing so on a project
    with more than four thousand commits! After finding the cause, two tickets were
    opened: one that explained the bug and another one to ask for a changelog.'
  prefs: []
  type: TYPE_NORMAL
- en: Packaging Guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before packaging, a few things are worth considering so that the process is
    as smooth as possible. Even when you don’t plan to package a product, these guidelines
    help to improve a project overall.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Projects in version control are always ready to be packaged.
  prefs: []
  type: TYPE_NORMAL
- en: Descriptive Versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to version software, but it is a good idea to follow a well-known
    schema. The Python developer’s guide [has a clear definition](https://oreil.ly/C3YKO)
    for acceptable forms of versioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The versioning schema is meant to be extremely flexible, while keeping an eye
    on consistency so that installer tooling can make sense and prioritize accordingly
    (for example, a stable version over a beta one). In its purest form, and most
    commonly in Python packages, the following two variants are used: `major.minor`
    or `major.minor.micro`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Valid versions would then look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0.0.1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2.1.1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although there are many variations described by the excellent Python developer’s
    guide, concentrate on the simpler forms (listed above). They are good enough to
    produce packages, while adhering to most guidelines for both system and native
    Python packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'A commonly accepted format for releases is `major.minor.micro` (and also used
    by the [Semantic Versioning scheme](https://semver.org)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`major` for backward-incompatible changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minor` adds features that are also backward compatible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`micro` adds backward-compatible bug fixes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the listed versions above, you can deduce that a dependency on an
    application with version `1.0.0` might break with version `2.0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the decision for a release occurs, then it is easy to determine the version
    number. Assuming the current released version of the project under development
    is `1.0.0`, it means the following outcomes are possible:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the release has backward-incompatible changes, the version is: `2.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the release has added features that do not break compatibility, the version
    is `1.1.0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the release is to fix issues that also do not break compatibility, the version
    is `1.0.1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once a schema is being followed, then a release process is immediately descriptive.
    Although it would be nice for all software to follow a similar pattern, some projects
    have a completely different schema of their own. For example, the [Ceph](https://ceph.com)
    project uses the following: `major.[0|1|2].minor`'
  prefs: []
  type: TYPE_NORMAL
- en: '`major` indicates a major release, while not necessarily breaking backward-compatibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`, `1`, or `2` mean (in order) development release, release candidate, or
    stable version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minor` is used only for bug fixes and never for features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That schema would mean that `14.0.0` is a development release, while `14.2.1`
    is a bug fix release for the stable version of the major release (`14` in this
    case).
  prefs: []
  type: TYPE_NORMAL
- en: The changelog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have mentioned already, it is important to keep track of releases and
    what they mean in the context of a version number. Keeping a changelog is not
    that difficult, once a versioning schema is chosen. Although it can be a single
    file, large projects tend to break it down into smaller files in a directory.
    Best practice is using a simple format that is descriptive and easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is an actual portion of a *changelog* file in a production
    Python tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The example provides four essential pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: The latest version number released
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whether the latest release is backward compatible
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The release date of the last version
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changes included in the release
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The file doesn’t need to be of a specific format, as long as it is consistent
    and informative. A proper changelog can provide several pieces of information
    with little effort. It is tempting to try and automate the task of writing a changelog
    with every release, but we would advise against a fully automated process: nothing
    beats a well-written, thoughtful entry about a bug fix or a feature added.'
  prefs: []
  type: TYPE_NORMAL
- en: A poorly automated changelog is one that uses all the version control commits
    included in the release. This is not a good practice, since you can get the same
    information by listing the commits.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the type of distribution needed and what infrastructure services
    are available helps determine what type of packaging to use. Pure Python libraries
    that extend functionality for other Python projects are suitable as a native Python
    package, hosted on the Python Package Index (PyPI) or a local index.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone scripts and long-running processes are good candidates for system
    packages like RPM or Debian, but ultimately, it depends on what type of systems
    are available and if it is at all possible to host (and manage) a repository.
    In the case of long-running processes, the packaging can have rules to configure
    a `systemd` unit that makes it available as a controllable process. `systemd`
    allows for the graceful handling of start, stop, or restart operations. These
    are things that aren’t possible with native Python packaging.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the more a script or process needs to interact with a system, the
    better it is suited to a system package or a container. When writing a Python-only
    script, conventional Python packaging is the right choice.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There aren’t hard requirements on what strategy to choose. It depends! Pick
    the best environment available for distribution (RPM if the servers are CentOS,
    for example). Different types of packaging are not mutually exclusive; one project
    can offer multiple packaging formats at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, the details on how to create a package and host it are covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the code examples, assume a small Python project called `hello-world`
    with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The project has a top-level directory called `hello-world` and a subdirectory
    (`hello_world`) with two files in it. Depending on the packaging choice, different
    files are needed to create a package.
  prefs: []
  type: TYPE_NORMAL
- en: Native Python Packaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By far the simplest solution is using the native Python packaging tooling and
    hosting (via PyPI). Like the rest of the other packaging strategies, the project
    requires some files used by `setuptools`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'One easy way to source a virtual environment is to create a `bash` or `zsh`
    alias that both cd’s into the directory and sources the environment, like this:
    `alias sugar="source ~/.sugar/bin/activate && cd ~/src/sugar"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue, create a new virtual environment and then activate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`setuptools` is a requirement to produce a native Python package. It is a collection
    of tools and helpers to create and distribute Python packages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the virtual environment is active, the following dependencies exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setuptools`'
  prefs: []
  type: TYPE_NORMAL
- en: A set of utilities for packaging
  prefs: []
  type: TYPE_NORMAL
- en: '`twine`'
  prefs: []
  type: TYPE_NORMAL
- en: A tool for registering and uploading packages
  prefs: []
  type: TYPE_NORMAL
- en: 'Install them by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A very easy way to figure out what is installed is to use `IPython` and this
    snippet to list all of the Python packages as a `JSON` data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Package files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To produce the native Python package, we have to add a few files. To keep things
    simple, focus on the minimum amount of files needed to produce the package. The
    file that describes the package to `setuptools` is named *setup.py*. It exists
    at the top-level directory. For the example project, this is how that file looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The *setup.py* file will import two helpers from the `setuptools` module: `setup`
    and `find_packages`. The `setup` function is what requires the rich description
    about the package. The `find_packages` function is a utility to automatically
    detect where the Python files are. Additionally, the file imports `classifiers`
    that describe certain aspects of the package, such as the license, operating systems
    supported, and Python versions. These *classifiers* are called *trove classifiers*,
    and the [Python Package Index](https://pypi.org/classifiers) has a detailed description
    of other classifiers available. Detailed descriptions make a package get discovered
    when uploaded to PyPI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With just the addition of this one file, we can already produce a package,
    in this case, a *source distribution* package. Without a *README* file, a warning
    appears when running the commands. To prevent this, add an empty one in the top-level
    directory with the command: `touch README`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the project directory should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To produce the *source distribution* from it, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top-level directory of the project, a new directory called *dist* is
    there; it contains the *source distribution*: a file *hello-world-0.0.1.tar.gz*.
    If we check the contents of the directory, it has changed once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The newly created *tar.gz* file is an installable package! This package can
    now be uploaded to PyPI for others to install directly from it. By following the
    version schema, it allows installers to ask for a specific version (`0.0.1` in
    this case), and the extra metadata passed into the `setup()` function enables
    other tools to discover it and show information about it, such as the author,
    description, and version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python installer tool `pip` can be used to install the *tar.gz* file directly.
    To try it out, use the path to the file as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Python Package Index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python Package Index (PyPI) is a repository of Python software that allows
    users to host Python packages and also install from it. It is maintained by and
    for the community with the help of sponsors and donations as part of the [Python
    Software Foundation](https://www.python.org/psf).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This section requires registration for the *test instance* of PyPI. Make sure
    you have an account already or [register online](https://oreil.ly/lyVVx). You
    need your username and password for the account to upload packages.
  prefs: []
  type: TYPE_NORMAL
- en: In the sample *setup.py* file, an example email address contains a placeholder.
    If the package is going to get published to the index, this needs to be updated
    to reflect the same email address that owns the project at PyPI. Update any other
    fields, like the `author`, `url`, and `description`, to more accurately reflect
    the project being built.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure things work correctly, and to avoid *pushing to production*, the
    package is tested by uploading it to the test instance of PyPI. This test instance
    behaves the same as production and verifies that a package works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The `setuptools` and the *setup.py* file is the traditional method of uploading
    a package to PyPI. A new approach, called `twine`, can simplify things.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of this section, `twine` got installed in the virtual environment.
    Next, it can be used to upload the package to the test instance of PyPI. The following
    command uploads the *tar.gz* file and prompts for the username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To test out whether the package made it, we can try and install it with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The command looks like it has a space in the PyPI URL, but the index URL ends
    in `/simple/`, and `hello-world` is another argument that indicates the name of
    the Python package to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: For an actual production release, an account would need to exist or be [created](https://pypi.org/account/register).
    The same steps that are taken to upload to the test instance, including the validation,
    would also work for the *real* PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Older Python packaging guides may reference commands such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These may still work and are part of the `setuptools` set of utilities to package
    and upload projects to a package index. However, `twine` offers secure authentication
    over HTTPS, and allows signing with `gpg`. Twine works regardless if `python setup.py
    upload` doesn’t, and finally, it provides a way to test a package before uploading
    to the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'A final item to point out is that it may be helpful to create a `Makefile`
    and put a `make` command in it that automatically deploys your project and builds
    the documentation for you. Here is an example of how that could work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Hosting an internal package index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some situations, it might be preferable to host an internal PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: A company where Alfredo used to work had private libraries that were not supposed
    to be public at all, so it was a requirement to host an instance of PyPI. Hosting
    has its caveats, though. All dependencies and versions of those dependencies have
    to exist in the instance; otherwise, installs can fail. An installer can’t fetch
    dependencies from different sources at the same time! On more than one occasion,
    a new version had a missing component, so that package had to be uploaded for
    the install to complete correctly.
  prefs: []
  type: TYPE_NORMAL
- en: If package *A* is hosted internally and has requirements on packages *B* and
    *C*, all three need to exist (along with their required versions) in the same
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: An internal PyPI makes installations go faster, can keep packages private, and
    at its core, isn’t challenging to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A highly recommended full-featured tool for hosting an internal PyPI is `devpi`.
    It has features like mirroring, staging, replication, and Jenkins integration.
    The [project documentation](http://doc.devpi.net) has great examples and detailed
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new directory called `pypi` so that you can create a proper
    structure for hosting packages, and then create a subdirectory with the name of
    our example package (`hello-world`). The names of subdirectories are the names
    of the packages themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now copy the *tar.gz* file into the *hello-world* directory. The final version
    of this directory structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a web server with auto indexing enabled. Python
    comes with a built-in web server that is good enough to try this out, and it even
    has the auto indexing enabled by default! Change directories to the *pypi* directory
    containing the `hello-world` package and start the built-in web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In a new terminal session, create a temporary virtual environment to try out
    installing the `hello-world` package from the local PyPI instance. Activate it,
    and finally, try installing it by pointing `pip` to the custom local URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the session where the `http.server` module is running, there should be some
    logs demonstrating all the requests the installer made to retrieve the `hello-world`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A production environment needs a better-performing web server. The `http.server`
    module is used in this example for simplicity, but it isn’t meant to handle simultaneous
    multiple requests or scaling out.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When building a local index without a tool like `devpi`, there is a defined
    specification that includes descriptions of normalized names for the directory
    structure. This specification can be found in [PEP 503](https://oreil.ly/sRcAe).
  prefs: []
  type: TYPE_NORMAL
- en: Debian Packaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If targetting Debian (or a Debian-based distribution such as Ubuntu) for distributing
    a project, additional files are required. Understanding what these files are and
    how the Debian packaging tools use them improves the process of producing an installable
    `.deb` package and troubleshooting issues.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these plain-text files require a *very* strict formatting, and if the
    format is even slightly incorrect, the packaging cannot install.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This section assumes the packaging is in a Debian or Debian-based distro, so
    that it is easier to install and use the required packaging tools.
  prefs: []
  type: TYPE_NORMAL
- en: Package files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Debian packaging needs a *debian* directory with a few files in it. To narrow
    the scope of what is needed to produce a package, most of the available options
    are skipped, such as running a test suite before completing a build or declaring
    multiple Python versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the *debian* directory where all required files exist. In the end, the
    `hello-world` project structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that the directory includes the *setup.py* and *README* file from the native
    Python packaging section. It is required because Debian tooling uses these to
    produce the `.deb` package.
  prefs: []
  type: TYPE_NORMAL
- en: The changelog file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This file can be complicated to get right if done by hand. The errors produced
    when this file is not formatted correctly are not easy to debug. Most Debian packaging
    workflows rely on the `dch` tool to enhance debuggability.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve ignored my advice before and have tried to manually create this file.
    In the end I wasted time because error reporting is not very good, and spotting
    issues is very difficult. Below is an example of an entry in the *changelog* file
    that caused a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That entry produced the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Can you spot the fix?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A *space* between the dashes and my name was the cause. Save yourself the heartache
    and use `dch`. The tool is part of the `devscripts` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dch` command-line tool has many options, and it is useful to go through
    its documentation (the main page is comprehensive). We are going to run it to
    create the changelog for the first time (this requires the one-time use of the
    `--create` flag). Before running it, export your full name and email so that they
    get into the generated file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run `dch` to produce the changelog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The newly created file should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Debian changelog is specific to Debian packaging. It is fine to have a separate
    changelog for the project when the format doesn’t fit or if other information
    needs updating. Lots of projects keep the Debian *changelog* file as a separate
    Debian-only file.
  prefs: []
  type: TYPE_NORMAL
- en: The control file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the file that defines the package name, its description, and any dependencies
    needed for building and running the project. It also has a strict format, but
    it doesn’t need to change much (unlike the *changelog*). The file ensures that
    Python 3 is required and that it follows Debian’s Python naming guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the transition from Python 2 to Python 3, most distributions settled on
    using the following schema for Python 3 packages: `python3-{package name}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the dependencies, naming conventions, and a short description,
    this is how the file should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Other required files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a few other files needed to produce a Debian package. Most of them
    are just a couple of lines long and change infrequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *rules* file is an executable file that tells Debian what to run to produce
    the package; in this case it should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The *compat* file sets the corresponding `debhelper` (another packaging tool)
    compatibility, recommended to be set to `10` here. You might check to see whether
    a higher value is required if an error message complains about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Without a license, the build process might not work, and it is a good idea
    to state the license explicitly. This particular example uses the MIT license,
    and this is how it should look in *debian/copyright*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, after adding all these new files to the `debian` directory, the `hello-world`
    project looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Producing the binary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To produce the binary, use the `debuild` command-line tool. For this example
    project, the package remains unsigned (the signing process requires a GPG key),
    and the `debuild` documentation uses an example that allows skipping the signing.
    The script is run from inside the source tree to build only the binary package.
    This command works for the `hello-world` project (truncated version shown here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: A *python3-hello-world_0.0.1_all.deb* should now exist in the upper directory.
    The lintian call (a Debian packaging linter) complains at the very end that the
    *changelog* file has an invalid distribution, which is fine because we aren’t
    targeting a single distribution in particular (for example, Debian Buster). Rather,
    we are building a package that will most likely install in any Debian-base distro
    that complies with the dependencies (only Python 3, in this case).
  prefs: []
  type: TYPE_NORMAL
- en: Debian repositories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many tools to automate Debian repositories, but it is useful to understand
    how to go about creating one (Alfredo even helped [develop one](https://oreil.ly/hJMgY)
    for both RPM and Debian!). To continue, ensure that the binary package created
    previously is available at a known location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'For this section, the `reprepro` tool needs to be installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new directory somewhere in the system to hold packages. This example
    uses */opt/repo*. The basic configuration for a repository needs a file, called
    `distributions`, that describes the contents and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file at */opt/repo/conf/distributions*. Create another directory
    to hold the actual repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the repository, instruct `reprepro` to use the *distributions* file
    created, and that the base directory is */opt/repo/debian/sid*. Finally, add the
    binary previously created as a target for the Debian sid distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This command creates the repo for the Debian sid distribution! This command
    can be adapted for a different Debian-based distribution such as Ubuntu Bionic,
    for example. To do so would only require replacing `sid` with `bionic`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the repo exists, the next step is to ensure that it works as expected.
    For a production environment, a robust web server like Apache or Nginx would be
    a good choice, but to test this, use Python’s `http.server` module. Change directories
    to the directory containing the repository, and start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Aptitude (or `apt`, the Debian package manager) needs some configuration to
    be aware of this new location for packages. This configuration is a simple file
    with a single line in it pointing to the URL and components of our repo. Create
    a file at */etc/apt/sources.lists.d/hello-world.list*. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `[trusted=yes]` configuration tells `apt` not to enforce signed packages.
    On repositories that are properly signed, this step is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the file, update `apt` so that it recognizes the new location,
    and look for (and install) the `hello-world` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Searching for the `python3-hello-world` package provides the description added
    in the *distributions* file when configuring `reprepro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Installing and removing the package should work without a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: RPM Packaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as with Debian packaging, when working in RPM, it is necessary to have
    the native Python packaging done already. It should be possible to produce a Python
    package with a *setup.py* file. However, very unlike Debian, in which many files
    are needed, RPM packaging can work with just one: the *spec* file. If targeting
    a distribution like CentOS or Fedora, the RPM Package Manager (formerly known
    as Red Hat Package Manager) is the way to go.'
  prefs: []
  type: TYPE_NORMAL
- en: The spec file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In its simplest form, the *spec* file (named *hello-world.spec* for this example)
    is not difficult to understand, and most sections are self-explanatory. It can
    even be generated by using `setuptools`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output file in *dist/hello-world.spec* should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it looks simple, it is already creating a potential issue: the version
    is input and requires updating every time. This process is similar to Debian’s
    *changelog* file, which needs to have the version *bumped* on each release.'
  prefs: []
  type: TYPE_NORMAL
- en: The `setuptools` integration is advantageous, allows further modification to
    this file if needed, and copies to the root directory of the project for a permanent
    location. Some projects use a base template that gets populated to generate the
    spec file as part of the build process. This process is useful if following a
    rigorous release workflow. In the case of the [Ceph project](https://ceph.com),
    the release is tagged via version control (Git), and the release scripts use that
    tag to apply it to the template via a `Makefile`. It is worth noting that additional
    methods exist to automate this process further.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Generating a *spec* file is not always useful, because certain sections might
    need to be hardcoded to follow some distribution rule or a specific dependency
    that is not part of the generated file. In such cases, it is best to generate
    it once and configure it further to finally save it and make the *spec* file a
    formal part of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Producing the binary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a few different tools to produce RPM binaries; one in particular
    is the `rpmbuild` command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The command-line tool is `rpmbuild` but the package is called `rpm-build`, so
    make sure that `rpmbuild` (the command-line tool) is available in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'A directory structure is required by `rpmbuild` to create the binary. After
    the directories are created, the *source* file (the *tar.gz* file generated by
    `setuptools`) needs to be present in the *SOURCES* directory. This is how the
    structure should be created and how it will look once it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The directory structure is always needed, and by default, `rpmbuild` requires
    it in the home directory. To keep things isolated, a different location (in */opt/repo/centos*)
    is used. This process means configure `rpmbuild` uses this directory instead.
    This process produces both a binary and a *source* package with the `-ba` flag
    (output is abbreviated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The directory structure at */opt/repo/centos* will have lots of new files,
    but we are only interested in the one that has the `noarch` RPM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `noarch` RPM is an installable RPM package! The tool produced other useful
    packages that can be published as well (look at */opt/repo/centos/SRPMS*, for
    example).
  prefs: []
  type: TYPE_NORMAL
- en: RPM repositories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create an RPM repository, use the `createrepo` command-line tool. It handles
    the creation of the repository metadata (XML-based RPM metadata) from the binaries
    it finds in a given directory. In this section, create (and host) the `noarch`
    binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create the repository in the same location used to produce the `noarch`
    package, or use a new (clean) directory. Create new binaries if needed. Once that
    is completed, the package copies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the metadata, run the `createrepo` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Although an `x86_64` package does not exist, repeat the `createrepo` call for
    this new directory so that `yum` doesn’t complain about it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to use the `http.server` module to serve this directory over HTTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To access this repository, `yum` needs to be configured with a *repo file*.
    Create one at */etc/yum.repos.d/hello-world.repo*. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the `gpgcheck` value is `0`. This means we haven’t signed any packages
    and `yum` should not try to verify a signature, preventing a failure in this example.
    Searching for the package should now be possible, giving us the description as
    part of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The search function works correctly; installing the package should work as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing has to work as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `http.server` module should display some activity, demonstrating that `yum`
    was reaching out to get the `hello-world` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Management with systemd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`systemd` is a *system and service manager* for Linux (also known as *init
    system*). It is the default init system for many distributions, such as Debian
    and Red Hat. Here are some of the many features `systemd` provides:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy parallelization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooks and triggers for on-demand behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to depend on other units for orchestrating complicated startups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are plenty of other exciting aspects of `systemd`, such as network, DNS,
    and even mounting for devices. The idea of handling processes with ease in Python
    has always been challenging; at one point there were a few *init-like* projects
    in Python to choose from, all with their configuration and handling APIs. Using
    `systemd` allows portability and makes it easy to collaborate with others since
    it is widely available.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Two well-known process handlers in Python are [`supervisord`](http://supervisord.org)
    and [`circus`](https://oreil.ly/adGEj).
  prefs: []
  type: TYPE_NORMAL
- en: Not long ago, Alfredo wrote a small Python HTTP API that needed to go into production.
    The project had transitioned from `supervisord` to `circus`, and things were working
    fine. Unfortunately, production constraints meant the integration of `systemd`
    with the OS. The transition was rough because `systemd` was reasonably new, but
    once things were in place, we benefited from having the same production-like handling
    for development and catching integration issues earlier in the development cycle.
    When the API went into the release, we already felt comfortable with `systemd`
    to troubleshoot problems and even fine-tune the configuration to cope with external
    issues. (Have you ever seen an `init` script fail because the network was not
    operational?)
  prefs: []
  type: TYPE_NORMAL
- en: In this section we build a small HTTP service that needs to be available when
    the system boots and can restart at any moment. The unit configuration handles
    logging and ensures that specific system resources are available before attempting
    to start.
  prefs: []
  type: TYPE_NORMAL
- en: Long-Running Processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Processes that are meant to be running all the time are excellent candidates
    to be handled with `systemd`. Consider how a DNS or mail server works; these are
    *always on* programs, and they need some handling to capture logging or restart
    when configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use a small HTTP API server, based on the [Pecan web framework](https://www.pecanpy.org).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is nothing specific in this section as to how Pecan works, so that the
    examples can be used for other frameworks or long-running services.
  prefs: []
  type: TYPE_NORMAL
- en: Setting It Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pick a permanent location for the project to create a directory at */opt/http*,
    and then create a new virtual environment and install the Pecan framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Pecan has some built-in helpers that can create the necessary files and directories
    for an example project. Pecan can be used to create a basic “vanilla” HTTP API
    project that hooks up to `systemd`. Version `1.3.3` has two options: the `base`
    and the `rest-api` flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is important to use a consistent path, because it is used later when configuring
    the service with `systemd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By including the project scaffolding, we now have a fully functional project
    with no effort. It even has a *setup.py* file with everything in it, ready to
    become a native Python package! Let’s install the project so that we can run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pecan` command-line tool requires a configuration file. The configuration
    file has already been created for you by the scaffolding, and it lives in the
    top directory. Start the server with the *config.py* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing it out on the browser should produce a plain-text message. This is
    how it shows with the `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: A long-running process starts with `pecan serve config.py`. The only way to
    stop this process is to send a `KeyboardInterrupt` with `Control-C`. Starting
    it again requires the virtual environment to be activated, and the same `pecan
    serve` command runs again.
  prefs: []
  type: TYPE_NORMAL
- en: The systemd Unit File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike older init systems that work with executable scripts, `systemd` works
    with plain text files. The final version of the unit file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Save this file as `hello-world.service`. It will be copied into its final destination
    later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is essential to get all the section names and the configuration directives
    correct, as all are case-sensitive. If names don’t match exactly, things won’t
    work. Let’s go into detail for each section of the HTTP service:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit
  prefs: []
  type: TYPE_NORMAL
- en: Provides a description and includes an `After` directive that tells `systemd`
    that this service unit needs to have an operational network environment before
    being started. Other units may have more complex requirements, not only to start
    the service but even *after* it starts! `Condition` and `Wants` are other directives
    that are very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Service
  prefs: []
  type: TYPE_NORMAL
- en: This section is only needed when configuring a *service* unit. It defaults to
    `Type=simple`. Services of this type should not fork—they have to stay in the
    foreground so that `systemd` can handle their operation. The `ExecStart` line
    explains what the command should run to start the service. It is *crucial* to
    use absolute paths to avoid problems finding the right files.
  prefs: []
  type: TYPE_NORMAL
- en: Although not required, I’ve included the `WorkingDirectory` directive to ensure
    that the process is in the same directory where the application lives. If anything
    updates later, it might benefit from already being in a position relative to the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `StandardOutput` and `StandardError` directives are great to work with,
    and show how much `systemd` has to offer here. It will handle all the logging
    emitted via `stdout` and `stderr` through `systemd` machinery. We will demonstrate
    this further when explaining how to interact with the service.
  prefs: []
  type: TYPE_NORMAL
- en: Install
  prefs: []
  type: TYPE_NORMAL
- en: The `WantedBy` directive explains how this unit handles once it is enabled.
    The `multi-user.target` is equivalent to `runlevel 3` (the normal run level for
    a server that boots into a terminal). This type of configuration allows the system
    to determine how it behaves once enabled. Once enabled, a symlink is created in
    the *multi-user.target.wants* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Unit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The configuration file itself has to go to a specific location so that `systemd`
    can pick it up and *load it*. Various locations are supported, but */etc/systemd/system*
    is for units that are created or managed by an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'It is useful to make sure that the `ExecStart` directive works with those paths.
    Using absolute paths increases the chance of introducing a typo. To verify, run
    the whole line in the terminal and look for output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'After verifying that the command works, copy the unit file into this directory
    using `hello-world.service` as the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Once in place, `systemd` needs to be reloaded to make it aware of this new
    unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The service is now fully functional and can be started and stopped. This process
    is verified by using the `status` subcommand. Let’s go through the different commands
    you can use to interact with the service. First, let’s see if `systemd` recognizes
    it. This is how it should behave and what the output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the service is not running, it is not surprising to see it reported as
    `dead`. Start the service next and check the status once again (`curl` should
    report nothing is running on port `8080`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The service is running and fully operational. Verify it once again on port
    `8080` to make sure that the framework is up and running and responding to requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: If you stop the service with `systemctl stop hello-world`, the `curl` command
    will report a connection failure once again.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have created and installed the unit, verified it works by starting
    and stopping the service, and checked if the Pecan framework is responding to
    requests on its default port. You want this service up and running if the server
    reboots at any time, and this is where the `Install` section helps. Let’s `enable`
    the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: When the server restarts, the small HTTP API service is up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Log Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since this is a configured service with logging configuration (all `stdout`
    and `stderr` is going directly into `systemd`), the handling works *for free*.
    No need to configure file-based logging, rotation, or even expiration. There are
    a few interesting and very nice features provided by `systemd` that allow you
    to interact with logs, such as limiting the time range and filtering by unit or
    process ID.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The command to interact with logs from a unit is done through the `journalctl`
    command-line tool. This process might be a surprise if expecting another subcommand
    from `systemd` to provide the logging helpers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we started the service and sent some requests to it via `curl` in the
    previous section, let’s see what the logs say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `-u` flag specifies the *unit*, which in this case is `hello-world`, but
    you can also use a pattern or even specify multiple units.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common way to *follow* a log as it produces entries is to use the `tail`
    command. Specifically, this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The command to accomplish the same thing with `journalctl` looks slightly different,
    but it *works in the same way*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the `systemd` package is available with the `pcre2` engine, it allows you
    to use `--grep`. This further filters out log entries based on a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-f` flag means to *follow* the log, and it starts from the most recent
    entries and continues to show the entries as they happen, just like `tail -f`
    would. In production, the number of logs may be too many, and errors might have
    been showing up *today*. In those cases, you can use a combination of `--since`
    and `--until`. Both these flags accept a few different types of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`today`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yesterday`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"3 hours ago"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-1h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-15min`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-1h35min`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our small example, `journalctl` is unable to find anything for the last
    15 minutes. At the beginning of the output, it informs us of the range and produces
    the entries, if any:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use three different commands to get log output from `systemd` using `journalctl`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain what the `WorkinDirectory` configuration option is for `systemd` units.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is a changelog important?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a *setup.py* file for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name three differences between Debian and RPM packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case Study Question
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a local instance of PyPI using `devpi`, upload a Python package, and
    then try to install that Python package from the local `devpi` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
