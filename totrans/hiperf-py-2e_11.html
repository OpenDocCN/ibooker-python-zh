<html><head></head><body><div id="sbo-rt-content" class="calibre2"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 11. Using Less RAM" class="calibre3"><div class="preface" id="chapter-lessram">
<h1 class="calibre23"><span class="publishername">Chapter 11. </span>Using Less RAM</h1>

<aside data-type="sidebar" epub:type="sidebar" class="calibre40"><div class="sidebar" id="idm46122403682680">
<h5 class="calibre41">Questions You’ll Be Able to Answer After This Chapter</h5>
<ul class="printings">
<li class="calibre21">
<p class="calibre42">Why should I use less RAM?</p>
</li>
<li class="calibre21">
<p class="calibre42">Why are <code class="calibre26">numpy</code> and <code class="calibre26">array</code> better for storing lots of numbers?</p>
</li>
<li class="calibre21">
<p class="calibre42">How can lots of text be efficiently stored in RAM?</p>
</li>
<li class="calibre21">
<p class="calibre42">How could I count (approximately!) to <math alttext="10 Superscript 76">
  <msup><mn>10</mn> <mn>76</mn> </msup>
</math> using just 1 byte?</p>
</li>
<li class="calibre21">
<p class="calibre42">What are Bloom filters, and why might I need them?</p>
</li>
</ul>
</div></aside>

<p class="author1"><a data-type="indexterm" data-primary="RAM (random access memory)" id="ram_ch" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>We rarely think about how much RAM we’re using until we run out of it. If you run out while scaling your code, it can become a sudden blocker. Fitting more into a machine’s RAM means fewer machines to manage, and it gives you a route to planning capacity for larger projects. Knowing why RAM gets eaten up and considering more efficient ways to use this scarce resource will help you deal with scaling issues. We’ll use the Memory Profiler and IPython Memory Usage tools to measure the actual RAM usage, along with some tools that introspect objects to try to guess how much RAM they’re using.</p>

<p class="author1">Another route to saving RAM is to use containers that utilize features in your data for compression. In this chapter, we’ll look at a trie (ordered tree data structures) and a directed acyclic word graph (DAWG) that can compress a 1.2 GB <code class="calibre26">set</code> of strings down to just 30 MB with little change in performance. A third approach is to trade storage for accuracy. For this we’ll look at approximate counting and approximate set membership, which use dramatically less RAM than their exact counterparts.</p>

<p class="author1">A consideration with RAM usage is the notion that “data has mass.” The more there is of it, the slower it moves around. If you can be parsimonious in your use of RAM, your data will probably get consumed faster, as it’ll move around buses faster and more of it will fit into constrained caches. If you need to store it in offline storage (e.g., a hard drive or a remote data cluster), it’ll move far more slowly to your machine. Try to choose appropriate data structures so all your data can fit onto one machine. We’ll use NumExpr to efficiently calculate with NumPy and Pandas with fewer data movements than the more direct method, which will save us time and make certain larger calculations feasible in a fixed amount of RAM.</p>

<p class="author1">Counting the amount of RAM used by Python objects is surprisingly tricky. We don’t necessarily know how an object is represented behind the
scenes, and if we ask the
operating system for a count of bytes used, it will tell us about the total
amount allocated to the process. In both cases, we can’t see exactly how each
individual Python object adds to the total.</p>

<p class="author1">As some objects and libraries
don’t report their full internal allocation of bytes (or they wrap external
libraries that do not report their allocation at all), this has to be a case of
best-guessing. The approaches explored in this chapter can help us to decide on the best way to
represent our data so we use less RAM overall.</p>

<p class="author1">We’ll also look at several lossy methods for storing strings in scikit-learn and counts in data structures. This works a little like a JPEG compressed image—we lose some information (and we can’t undo the operation to recover it), and we gain a lot of compression as a result. By using hashes on strings, we compress the time and memory usage for a natural language processing task in scikit-learn, and we can count huge numbers of events with only a small amount of RAM.</p>






<section data-type="sect1" data-pdf-bookmark="Objects for Primitives Are Expensive" class="calibre3"><div class="preface" id="idm46122402884856">
<h1 class="calibre25">Objects for Primitives Are Expensive</h1>

<p class="author1"><a data-type="indexterm" data-primary="lists" data-secondary="RAM use of" id="idm46122402883288" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="RAM (random access memory)" data-secondary="objects for primitives" id="idm46122402882312" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>It’s common to work with containers like the <code class="calibre26">list</code>, storing hundreds or thousands of items. As soon as you store a large number, RAM usage becomes an issue.</p>

<p class="author1">A <code class="calibre26">list</code> with 100 million items consumes approximately 760 MB of RAM, <em class="hyperlink">if the items are
the same object</em>. If we store 100 million <em class="hyperlink">different</em> items (e.g., unique integers), we can expect to use gigabytes of RAM! Each unique object has a memory cost.</p>

<p class="author1">In <a data-type="xref" href="ch11_split_000.xhtml#lessram-memory-profiler-1e8-same-items" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-1</a>, we store many <code class="calibre26">0</code> integers in a <code class="calibre26">list</code>. If you stored 100 million references to any object (regardless of how large one instance of that object was), you’d still expect to see a memory cost of roughly 760 MB, as the <code class="calibre26">list</code> is storing references to (not copies of) the object. Refer back to <a data-type="xref" href="ch02.xhtml#memory_profiler" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Using memory_profiler to Diagnose Memory Usage”</a> for a reminder of how to use <code class="calibre26">memory_profiler</code>; here, we load it as a new magic function in IPython using <code class="calibre26">%load_ext memory_profiler</code>.</p>
<div id="lessram-memory-profiler-1e8-same-items" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-1. </span>Measuring memory usage of 100 million of the same integer in a list</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="o">%</code><code class="n">load_ext</code> <code class="n">memory_profiler</code>  <code class="c"># load the %memit magic function</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="o">%</code><code class="n">memit</code> <code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">*</code> <code class="nb">int</code><code class="p">(</code><code class="mi">1e8</code><code class="p">)</code>
<code class="n">peak</code> <code class="n">memory</code><code class="p">:</code> <code class="mi">806.33</code> <code class="n">MiB</code><code class="p">,</code> <code class="n">increment</code><code class="p">:</code> <code class="mi">762.77</code> <code class="n">MiB</code></pre></div>

<p class="author1">For our next example, we’ll start with a fresh shell. As the results of the first call to <code class="calibre26">memit</code> in <a data-type="xref" href="ch11_split_000.xhtml#lessram-memory-profiler-1e8-different-items" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-2</a> reveal, a fresh IPython shell consumes approximately 40 MB of RAM. Next, we can create a
temporary list of 100 million <em class="hyperlink">unique</em> numbers. In total, this consumes
approximately 3.8 GB.</p>
<div data-type="warning" epub:type="warning" class="calibre37"><h6 class="calibre38">Warning</h6>
<p class="author1">Memory can be cached in the running process, so it is always safer to exit and
restart the Python shell when using <a data-type="indexterm" data-primary="%memit" data-primary-sortas="memit" id="idm46122402835768" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="%memit" id="idm46122402834792" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">memit</code> for profiling.</p>
</div>

<p class="author1">After the <code class="calibre26">memit</code> command finishes, the temporary list is
deallocated. The final call to <code class="calibre26">memit</code> shows that the memory usage drops to its previous level.</p>
<div id="lessram-memory-profiler-1e8-different-items" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-2. </span>Measuring memory usage of 100 million different integers in a list</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="c"># we use a new IPython shell so we have a clean memory</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="o">%</code><code class="n">load_ext</code> <code class="n">memory_profiler</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="o">%</code><code class="n">memit</code> <code class="c"># show how much RAM this process is consuming right now</code>
<code class="n">peak</code> <code class="n">memory</code><code class="p">:</code> <code class="mi">43.39</code> <code class="n">MiB</code><code class="p">,</code> <code class="n">increment</code><code class="p">:</code> <code class="mi">0.11</code> <code class="n">MiB</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="o">%</code><code class="n">memit</code> <code class="p">[</code><code class="n">n</code> <code class="kn">for</code> <code class="n">n</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="nb">int</code><code class="p">(</code><code class="mi">1e8</code><code class="p">))]</code>
<code class="n">peak</code> <code class="n">memory</code><code class="p">:</code> <code class="mi">3850.29</code> <code class="n">MiB</code><code class="p">,</code> <code class="n">increment</code><code class="p">:</code> <code class="mi">3806.59</code> <code class="n">MiB</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="o">%</code><code class="n">memit</code>
<code class="n">peak</code> <code class="n">memory</code><code class="p">:</code> <code class="mi">44.79</code> <code class="n">MiB</code><code class="p">,</code> <code class="n">increment</code><code class="p">:</code> <code class="mi">0.00</code> <code class="n">MiB</code></pre></div>

<p class="author1">A subsequent <code class="calibre26">memit</code> in <a data-type="xref" href="ch11_split_000.xhtml#lessram-memory-profiler-1e8-different-items2" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-3</a> to create a second 100-million-item list consumes
approximately 3.8 GB again.</p>
<div id="lessram-memory-profiler-1e8-different-items2" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-3. </span>Measuring memory usage again for 100 million different integers in a list</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="o">%</code><code class="n">memit</code> <code class="p">[</code><code class="n">n</code> <code class="kn">for</code> <code class="n">n</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="nb">int</code><code class="p">(</code><code class="mi">1e8</code><code class="p">))]</code>
<code class="n">peak</code> <code class="n">memory</code><code class="p">:</code> <code class="mi">3855.78</code> <code class="n">MiB</code><code class="p">,</code> <code class="n">increment</code><code class="p">:</code> <code class="mi">3810.96</code> <code class="n">MiB</code></pre></div>

<p class="author1">Next, we’ll see that we can use the <code class="calibre26">array</code> module to store 100 million integers far more cheaply.</p>








<section data-type="sect2" data-pdf-bookmark="The array Module Stores Many Primitive Objects Cheaply" class="calibre3"><div class="preface" id="idm46122403459256">
<h2 class="calibre43">The array Module Stores Many Primitive Objects Cheaply</h2>

<p class="author1"><a data-type="indexterm" data-primary="array module" id="arr_abt" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="RAM (random access memory)" data-secondary="array module storage" id="ram_ams" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>The <code class="calibre26">array</code> module efficiently stores primitive types like integers, floats, and
characters, but <em class="hyperlink">not</em> complex numbers or classes. It creates a contiguous block of RAM to hold the underlying data.</p>

<p class="author1">In <a data-type="xref" href="ch11_split_000.xhtml#lessram-array1" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-4</a>, we allocate 100 million
integers (8 bytes each) into a contiguous chunk of memory. In total,
approximately 760 MB is consumed by the process. The difference between this
approach and the previous list-of-unique-integers approach is <code class="calibre26">3100MB - 760MB
== 2.3GB</code>. This is a huge savings in RAM.</p>
<div id="lessram-array1" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-4. </span>Building an array of 100 million integers with 760 MB of RAM</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="o">%</code><code class="n">load_ext</code> <code class="n">memory_profiler</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">array</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="o">%</code><code class="n">memit</code> <code class="n">array</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="s">'l'</code><code class="p">,</code> <code class="nb">range</code><code class="p">(</code><code class="nb">int</code><code class="p">(</code><code class="mi">1e8</code><code class="p">)))</code>
<code class="n">peak</code> <code class="n">memory</code><code class="p">:</code> <code class="mi">837.88</code> <code class="n">MiB</code><code class="p">,</code> <code class="n">increment</code><code class="p">:</code> <code class="mi">761.39</code> <code class="n">MiB</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">arr</code> <code class="o">=</code> <code class="n">array</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="s">'l'</code><code class="p">)</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">arr</code><code class="o">.</code><code class="n">itemsize</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="mi">8</code></pre></div>

<p class="author1">Note that the unique numbers in the <code class="calibre26">array</code> are <em class="hyperlink">not</em> Python objects; they are
bytes in the <code class="calibre26">array</code>. If we were to dereference any of them, a new Python
<code class="calibre26">int</code> object would be constructed. If you’re going to compute on them, no overall savings will occur, but if instead you’re going to pass the array to an external process or use only some of the data, you should see a good savings in RAM compared to using a <code class="calibre26">list</code> of integers.</p>
<div data-type="note" epub:type="note" class="calibre35"><h6 class="calibre36">Note</h6>
<p class="author1">If you’re working with a large array or matrix of numbers with<a data-type="indexterm" data-primary="Cython" data-secondary="processing in" id="idm46122403406072" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="numpy" data-secondary="arrays in" id="idm46122403405096" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> Cython and you don’t want an external dependency on <code class="calibre26">numpy</code>, be aware that you can store your data in an <code class="calibre26">array</code> and pass it into Cython for processing without any additional memory overhead.</p>
</div>

<p class="author1">The <code class="calibre26">array</code> module works with a limited set of datatypes with varying precisions (see <a data-type="xref" href="ch11_split_000.xhtml#lessram-array2" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-5</a>).
Choose the smallest precision that you need, so that you allocate just as much RAM as
needed and no more. Be aware that the byte size is platform-dependent—the sizes
here refer to a 32-bit platform (it states <em class="hyperlink">minimum</em> size), whereas we’re running the examples on
a 64-bit laptop.</p>
<div id="lessram-array2" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-5. </span>The basic types provided by the <code class="calibre26">array</code> module</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">array</code><code class="o">.</code><code class="n">array</code><code class="err">?</code> <code class="c"># IPython magic, similar to help(array)</code>
<code class="n">Init</code> <code class="n">signature</code><code class="p">:</code> <code class="n">array</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="o">/</code><code class="p">,</code> <code class="o">*</code><code class="n">args</code><code class="p">,</code> <code class="o">**</code><code class="n">kwargs</code><code class="p">)</code>
<code class="n">Docstring</code><code class="p">:</code>
<code class="n">array</code><code class="p">(</code><code class="n">typecode</code> <code class="p">[,</code> <code class="n">initializer</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">array</code>

<code class="n">Return</code> <code class="n">a</code> <code class="n">new</code> <code class="n">array</code> <code class="n">whose</code> <code class="n">items</code> <code class="n">are</code> <code class="n">restricted</code> <code class="n">by</code> <code class="n">typecode</code><code class="p">,</code> <code class="ow">and</code>
<code class="n">initialized</code> <code class="kn">from</code> <code class="nn">the</code> <code class="nn">optional</code> <code class="nn">initializer</code> <code class="nn">value</code><code class="p">,</code> <code class="n">which</code> <code class="n">must</code> <code class="n">be</code> <code class="n">a</code> <code class="nb">list</code><code class="p">,</code>
<code class="n">string</code><code class="p">,</code> <code class="ow">or</code> <code class="n">iterable</code> <code class="n">over</code> <code class="n">elements</code> <code class="n">of</code> <code class="n">the</code> <code class="n">appropriate</code> <code class="nb">type</code><code class="o">.</code>

<code class="n">Arrays</code> <code class="n">represent</code> <code class="n">basic</code> <code class="n">values</code> <code class="ow">and</code> <code class="n">behave</code> <code class="n">very</code> <code class="n">much</code> <code class="n">like</code> <code class="n">lists</code><code class="p">,</code> <code class="kn">except</code>
<code class="n">the</code> <code class="nb">type</code> <code class="n">of</code> <code class="n">objects</code> <code class="n">stored</code> <code class="ow">in</code> <code class="n">them</code> <code class="ow">is</code> <code class="n">constrained</code><code class="o">.</code> <code class="n">The</code> <code class="nb">type</code> <code class="ow">is</code> <code class="n">specified</code>
<code class="n">at</code> <code class="nb">object</code> <code class="n">creation</code> <code class="n">time</code> <code class="n">by</code> <code class="n">using</code> <code class="n">a</code> <code class="nb">type</code> <code class="n">code</code><code class="p">,</code> <code class="n">which</code> <code class="ow">is</code> <code class="n">a</code> <code class="n">single</code> <code class="n">character</code><code class="o">.</code>
<code class="n">The</code> <code class="n">following</code> <code class="nb">type</code> <code class="n">codes</code> <code class="n">are</code> <code class="n">defined</code><code class="p">:</code>

    <code class="n">Type</code> <code class="n">code</code>   <code class="n">C</code> <code class="n">Type</code>             <code class="n">Minimum</code> <code class="n">size</code> <code class="ow">in</code> <code class="nb">bytes</code>
    <code class="s">'b'</code>         <code class="n">signed</code> <code class="n">integer</code>     <code class="mi">1</code>
    <code class="s">'B'</code>         <code class="n">unsigned</code> <code class="n">integer</code>   <code class="mi">1</code>
    <code class="s">'u'</code>         <code class="n">Unicode</code> <code class="n">character</code>  <code class="mi">2</code> <code class="p">(</code><code class="n">see</code> <code class="n">note</code><code class="p">)</code>
    <code class="s">'h'</code>         <code class="n">signed</code> <code class="n">integer</code>     <code class="mi">2</code>
    <code class="s">'H'</code>         <code class="n">unsigned</code> <code class="n">integer</code>   <code class="mi">2</code>
    <code class="s">'i'</code>         <code class="n">signed</code> <code class="n">integer</code>     <code class="mi">2</code>
    <code class="s">'I'</code>         <code class="n">unsigned</code> <code class="n">integer</code>   <code class="mi">2</code>
    <code class="s">'l'</code>         <code class="n">signed</code> <code class="n">integer</code>     <code class="mi">4</code>
    <code class="s">'L'</code>         <code class="n">unsigned</code> <code class="n">integer</code>   <code class="mi">4</code>
    <code class="s">'q'</code>         <code class="n">signed</code> <code class="n">integer</code>     <code class="mi">8</code> <code class="p">(</code><code class="n">see</code> <code class="n">note</code><code class="p">)</code>
    <code class="s">'Q'</code>         <code class="n">unsigned</code> <code class="n">integer</code>   <code class="mi">8</code> <code class="p">(</code><code class="n">see</code> <code class="n">note</code><code class="p">)</code>
    <code class="s">'f'</code>         <code class="n">floating</code> <code class="n">point</code>     <code class="mi">4</code>
    <code class="s">'d'</code>         <code class="n">floating</code> <code class="n">point</code>     <code class="mi">8</code></pre></div>

<p class="author1">NumPy has arrays that can hold a wider range of datatypes—you have more
control over the number of bytes per item, and you can use complex numbers and
<code class="calibre26">datetime</code> objects.  A <code class="calibre26">complex128</code> object takes 16 bytes per item: each item is a
pair of 8-byte floating-point numbers. You can’t store <code class="calibre26">complex</code> objects in a Python array, but they come for free with <code class="calibre26">numpy</code>. If you’d like a refresher on <code class="calibre26">numpy</code>, look back to <a data-type="xref" href="ch06_split_000.xhtml#matrix_computation" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Chapter 6</a>.</p>

<p class="author1">In <a data-type="xref" href="ch11_split_000.xhtml#lessram-numpy1" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-6</a>, you can see an additional feature of <code class="calibre26">numpy</code> arrays; you can query for the number of items, the size of each primitive, and the combined total storage of the underlying block of RAM. Note that this doesn’t include the overhead of the Python object (typically, this is tiny in comparison to the data you store in the arrays).</p>
<div data-type="tip" class="calibre35"><h6 class="calibre36">Tip</h6>
<p class="author1">Be wary of lazy allocation with zeros. In the following example the call to <code class="calibre26">zeros</code> costs “zero” RAM, whilst the call to <code class="calibre26">ones</code> costs 1.5 GB. Both calls will ultimately cost 1.5 GB, but the call to <code class="calibre26">zeros</code> will allocate the RAM only after it is used, so the cost is seen later.</p>
</div>
<div id="lessram-numpy1" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-6. </span>Storing more complex types in a <code class="calibre26">numpy</code> array</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="o">%</code><code class="n">load_ext</code> <code class="n">memory_profiler</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">numpy</code> <code class="kn">as</code> <code class="nn">np</code>
<code class="c"># NOTE that zeros have lazy allocation so misreport the memory used!</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="o">%</code><code class="n">memit</code> <code class="n">arr</code><code class="o">=</code><code class="n">np</code><code class="o">.</code><code class="n">zeros</code><code class="p">(</code><code class="nb">int</code><code class="p">(</code><code class="mi">1e8</code><code class="p">),</code> <code class="n">np</code><code class="o">.</code><code class="n">complex128</code><code class="p">)</code>
<code class="n">peak</code> <code class="n">memory</code><code class="p">:</code> <code class="mi">58.37</code> <code class="n">MiB</code><code class="p">,</code> <code class="n">increment</code><code class="p">:</code> <code class="mi">0.00</code> <code class="n">MiB</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="o">%</code><code class="n">memit</code> <code class="n">arr</code><code class="o">=</code><code class="n">np</code><code class="o">.</code><code class="n">ones</code><code class="p">(</code><code class="nb">int</code><code class="p">(</code><code class="mi">1e8</code><code class="p">),</code> <code class="n">np</code><code class="o">.</code><code class="n">complex128</code><code class="p">)</code>
<code class="n">peak</code> <code class="n">memory</code><code class="p">:</code> <code class="mi">1584.41</code> <code class="n">MiB</code><code class="p">,</code> <code class="n">increment</code><code class="p">:</code> <code class="mi">1525.89</code> <code class="n">MiB</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">f</code><code class="s">"{arr.size:,}"</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="s">'100,000,000'</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">f</code><code class="s">"{arr.nbytes:,}"</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="s">'1,600,000,000'</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">arr</code><code class="o">.</code><code class="n">nbytes</code><code class="o">/</code><code class="n">arr</code><code class="o">.</code><code class="n">size</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="mi">16.0</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">arr</code><code class="o">.</code><code class="n">itemsize</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="mi">16</code></pre></div>

<p class="author1">Using a regular <code class="calibre26">list</code> to store many numbers is much less efficient in RAM than
using an <code class="calibre26">array</code> object. More memory allocations have to occur, which
each take time; calculations also occur on larger objects, which will be less cache
friendly, and more RAM is used overall, so less RAM is available to other
programs.</p>

<p class="author1">However, if you do any work on the contents of the <code class="calibre26">array</code> in Python numex, the primitives are likely to be converted into temporary objects, negating their benefit. Using them as a data store when communicating with other processes is a great use case for the <code class="calibre26">array</code>.</p>

<p class="author1"><code class="calibre26">numpy</code> arrays are almost certainly a better choice if you are doing anything
heavily numeric, as you get more datatype options and many specialized and fast
functions. You might choose to avoid <code class="calibre26">numpy</code> if you want fewer dependencies for
your project, though Cython works equally well with <code class="calibre26">array</code> and <code class="calibre26">numpy</code>
arrays; Numba works with <code class="calibre26">numpy</code> arrays only.</p>

<p class="author1">Python provides a few other tools to understand memory usage, as we’ll see in the following section.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Using Less RAM in NumPy with NumExpr" class="calibre3"><div class="preface" id="idm46122403458760">
<h2 class="calibre43">Using Less RAM in NumPy with NumExpr</h2>

<p class="author1">Large vectorized expressions in NumPy (which also happen behind the scenes in Pandas) can create intermediate large arrays during complex operations. These occur invisibly and may draw attention to themselves only when an out-of-memory error occurs. These calculations can also be slow, as large vectors will not be cache friendly—a cache can be megabytes or smaller, and large vectors of hundreds of megabytes or gigabytes of data will stop the cache from being used effectively.<a data-type="indexterm" data-primary="NumExpr" id="idm46122403833416" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> NumExpr is a tool that both speeds up and reduces the size of intermediate operations; we introduced it in <a data-type="xref" href="ch06_split_001.xhtml#matrix_vector_numexpr" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“numexpr: Making In-Place Operations Faster and Easier”</a>.</p>

<p class="author1">We’ve also introduced the <a data-type="indexterm" data-primary="Memory Profiler" id="idm46122403831016" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Memory Profiler before, in <a data-type="xref" href="ch02.xhtml#memory_profiler" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Using memory_profiler to Diagnose Memory Usage”</a>. Here, we build on it with the <a href="https://oreil.ly/i9Vc3" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">IPython Memory Usage tool</a>, which reports line-by-line memory changes inside the <a data-type="indexterm" data-primary="IPython" id="idm46122403828584" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>IPython shell or in a <a data-type="indexterm" data-primary="Jupyter Notebooks" id="idm46122403827784" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Jupyter Notebook. Let’s look at how these can be used to check that NumExpr is generating a result more efficiently.</p>
<div data-type="tip" class="calibre35"><h6 class="calibre36">Tip</h6>
<p class="author1">Remember to install the optional NumExpr when using Pandas. If NumExpr is installed in Pandas, calls to <code class="calibre26">eval</code> will run more quickly—but note that Pandas does not tell you if you <em class="hyperlink">haven’t</em> installed NumExpr.</p>
</div>

<p class="author1">We’ll use the <a data-type="indexterm" data-primary="cross entropy formula" id="idm46122403824440" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="Log Loss" id="idm46122403823704" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>cross entropy formula to calculate the error for a machine learning classification challenge. <em class="hyperlink">Cross entropy</em> (or <em class="hyperlink">Log Loss</em>) is a common metric for classification challenges; it penalizes large errors significantly more than small errors. Each row in a machine learning problem needs to be scored during the training and prediction phases:</p>
<div data-type="equation" class="calibre56">
<math alttext="minus l o g upper P left-parenthesis y t vertical-bar y p right-parenthesis equals minus left-parenthesis y t l o g left-parenthesis y p right-parenthesis plus left-parenthesis 1 minus y t right-parenthesis l o g left-parenthesis 1 minus y p right-parenthesis right-parenthesis" display="block">
  <mrow>
    <mo>-</mo>
    <mi>l</mi>
    <mi>o</mi>
    <mi>g</mi>
    <mi>P</mi>
    <mo>(</mo>
    <mi>y</mi>
    <mi>t</mi>
    <mo>|</mo>
    <mi>y</mi>
    <mi>p</mi>
    <mo>)</mo>
    <mo>=</mo>
    <mo>-</mo>
    <mo>(</mo>
    <mi>y</mi>
    <mi>t</mi>
    <mi>l</mi>
    <mi>o</mi>
    <mi>g</mi>
    <mo>(</mo>
    <mi>y</mi>
    <mi>p</mi>
    <mo>)</mo>
    <mo>+</mo>
    <mo>(</mo>
    <mn>1</mn>
    <mo>-</mo>
    <mi>y</mi>
    <mi>t</mi>
    <mo>)</mo>
    <mi>l</mi>
    <mi>o</mi>
    <mi>g</mi>
    <mo>(</mo>
    <mn>1</mn>
    <mo>-</mo>
    <mi>y</mi>
    <mi>p</mi>
    <mo>)</mo>
    <mo>)</mo>
  </mrow>
</math>
</div>

<p class="author1">We’ll use random numbers in the range [0, 1] here to simulate the results of a machine learning system from a package like scikit-learn or TensorFlow. <a data-type="xref" href="ch11_split_000.xhtml#FIG-cross-entropy" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Figure 11-1</a> shows the natural logarithm for the range [0, 1] on the right, and on the left it shows the result of calculating the cross entropy for any probability if the target is either 
<span class="publishername">0 or 1</span>.</p>

<p class="author1">If the target <code class="calibre26">yt</code> is 1, the first half of the formula is active and the second half goes to zero. If the target is 0, the second half of the formula is active and the first part goes to zero. This result is calculated for every row of data that needs to be scored and often for many iterations of the machine learning algorithm.</p>

<figure class="calibre46"><div id="FIG-cross-entropy" class="figure">
<img src="Images/hpp2_1101.png" alt="hpp2 1101" class="calibre110"/>
<h6 class="calibre47"><span class="publishername">Figure 11-1. </span>Cross entropy for <code class="calibre26">yt</code> (the “truth”) with values 0 and 1</h6>
</div></figure>

<p class="author1">In <a data-type="xref" href="ch11_split_000.xhtml#lessram-numexpr" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-7</a>, we generate 200 million random numbers in the range [0, 1] as <code class="calibre26">yp</code>. <code class="calibre26">yt</code> is the desired truth—in this case, an array of 1s. In a real application, we’d see <code class="calibre26">yp</code> generated by a machine learning algorithm, and <code class="calibre26">yt</code> would be the ground truth mixing 0s and 1s for the target we’d be learning provided by the machine learning researcher.</p>
<div id="lessram-numexpr" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-7. </span>The hidden cost of temporaries with large NumPy arrays</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">ipython_memory_usage.ipython_memory_usage</code> <code class="kn">as</code> <code class="nn">imu</code><code class="p">;</code> <code class="kn">import</code> <code class="nn">numpy</code> <code class="kn">as</code> <code class="nn">np</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="o">%</code><code class="n">ipython_memory_usage_start</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="s">'memory profile enabled'</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">nbr_items</code> <code class="o">=</code> <code class="mi">200</code><code class="n">_000_000</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">yp</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">uniform</code><code class="p">(</code><code class="n">low</code><code class="o">=</code><code class="mi">0.0000001</code><code class="p">,</code> <code class="n">size</code><code class="o">=</code><code class="n">nbr_items</code><code class="p">)</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]</code> <code class="n">used</code> <code class="mi">1526.0508</code> <code class="n">MiB</code> <code class="n">RAM</code> <code class="ow">in</code> <code class="mi">2.18</code><code class="n">s</code><code class="p">,</code> <code class="n">peaked</code> <code class="mi">0.00</code> <code class="n">MiB</code> <code class="n">above</code> <code class="n">current</code><code class="p">,</code>
       <code class="n">total</code> <code class="n">RAM</code> <code class="n">usage</code> <code class="mi">1610.05</code> <code class="n">MiB</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">yt</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">ones</code><code class="p">(</code><code class="n">shape</code><code class="o">=</code><code class="n">nbr_items</code><code class="p">)</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]</code> <code class="n">used</code> <code class="mi">1525.8516</code> <code class="n">MiB</code> <code class="n">RAM</code> <code class="ow">in</code> <code class="mi">0.44</code><code class="n">s</code><code class="p">,</code> <code class="n">peaked</code> <code class="mi">0.00</code> <code class="n">MiB</code> <code class="n">above</code> <code class="n">current</code><code class="p">,</code>
       <code class="n">total</code> <code class="n">RAM</code> <code class="n">usage</code> <code class="mi">3135.90</code> <code class="n">MiB</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">answer</code> <code class="o">=</code> <code class="o">-</code><code class="p">(</code><code class="n">yt</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">log</code><code class="p">(</code><code class="n">yp</code><code class="p">)</code> <code class="o">+</code> <code class="p">((</code><code class="mi">1</code><code class="o">-</code><code class="n">yt</code><code class="p">)</code> <code class="o">*</code> <code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">log</code><code class="p">(</code><code class="mi">1</code><code class="o">-</code><code class="n">yp</code><code class="p">))))</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]</code> <code class="n">used</code> <code class="mi">1525.8594</code> <code class="n">MiB</code> <code class="n">RAM</code> <code class="ow">in</code> <code class="mi">18.63</code><code class="n">s</code><code class="p">,</code> <code class="n">peaked</code> <code class="mi">4565.70</code> <code class="n">MiB</code> <code class="n">above</code> <code class="n">current</code><code class="p">,</code>
       <code class="n">total</code> <code class="n">RAM</code> <code class="n">usage</code> <code class="mi">4661.76</code> <code class="n">MiB</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="kn">del</code> <code class="n">answer</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]</code> <code class="n">used</code> <code class="o">-</code><code class="mi">1525.8242</code> <code class="n">MiB</code> <code class="n">RAM</code> <code class="ow">in</code> <code class="mi">0.11</code><code class="n">s</code><code class="p">,</code> <code class="n">peaked</code> <code class="mi">0.00</code> <code class="n">MiB</code> <code class="n">above</code> <code class="n">current</code><code class="p">,</code>
       <code class="n">total</code> <code class="n">RAM</code> <code class="n">usage</code> <code class="mi">3135.93</code> <code class="n">MiB</code></pre></div>

<p class="author1">Both <code class="calibre26">yp</code> and <code class="calibre26">yt</code> take 1.5 GB each, bringing the total RAM usage to just over 3.1 GB. The <code class="calibre26">answer</code> vector has the same dimension as the inputs and thus adds a further 1.5 GB. Note that the calculation peaks at 4.5 GB over the current RAM usage, so while we end with a 4.6 GB result, we had over 9 GB allocated during the calculation. The cross entropy calculation creates several temporaries (notably <code class="calibre26">1 – yt</code>, <code class="calibre26">np.log(1 – yp)</code>, and their multiplication). If you had an 8 GB machine, you’d have failed to calculate this result because of memory exhaustion.</p>

<p class="author1">In <a data-type="xref" href="ch11_split_000.xhtml#lessram-numexpr2" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-8</a>, we see the same expression placed as a string inside <code class="calibre26">numexpr.evaluate</code>. It peaks at 0 GB above the current usage—it doesn’t need any additional RAM in this case. Significantly, it also calculates much more quickly: the previous direct vector calculation in <code class="calibre26">In[6]</code> took 18 seconds, while here with NumExpr the same calculation takes 2.6 seconds.</p>

<p class="author1">NumExpr breaks the long vectors into shorter, cache-friendly chunks and processes each in series, so local chunks of results are calculated in a cache-friendly way. This explains both the requirement for no extra RAM and the increased speed.</p>
<div id="lessram-numexpr2" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-8. </span>NumExpr breaks the vectorized calculations into cache-efficient chunks</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">numexpr</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]</code> <code class="n">used</code> <code class="mi">0.0430</code> <code class="n">MiB</code> <code class="n">RAM</code> <code class="ow">in</code> <code class="mi">0.12</code><code class="n">s</code><code class="p">,</code> <code class="n">peaked</code> <code class="mi">0.00</code> <code class="n">MiB</code> <code class="n">above</code> <code class="n">current</code><code class="p">,</code>
       <code class="n">total</code> <code class="n">RAM</code> <code class="n">usage</code> <code class="mi">3135.95</code> <code class="n">MiB</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">answer</code> <code class="o">=</code> <code class="n">numexpr</code><code class="o">.</code><code class="n">evaluate</code><code class="p">(</code><code class="s">"-(yt * log(yp) + ((1-yt) * (log(1-yp))))"</code><code class="p">)</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]</code> <code class="n">used</code> <code class="mi">1525.8281</code> <code class="n">MiB</code> <code class="n">RAM</code> <code class="ow">in</code> <code class="mi">2.67</code><code class="n">s</code><code class="p">,</code> <code class="n">peaked</code> <code class="mi">0.00</code> <code class="n">MiB</code> <code class="n">above</code> <code class="n">current</code><code class="p">,</code>
       <code class="n">total</code> <code class="n">RAM</code> <code class="n">usage</code> <code class="mi">4661.78</code> <code class="n">MiB</code></pre></div>

<p class="author1">We can see a similar benefit in Pandas in <a data-type="xref" href="ch11_split_000.xhtml#lessram-numexpr3" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-9</a>. We construct a DataFrame with the same items as in the preceding example and invoke NumExpr by using <code class="calibre26">df.eval</code>. The Pandas machinery has to unpack the DataFrame for NumExpr, and more RAM is used overall; behind the scenes, NumExpr is still calculating the result in a cache-friendly manner. Note that here NumExpr was installed in addition to Pandas.</p>
<div id="lessram-numexpr3" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-9. </span>Pandas <code class="calibre26">eval</code> uses NumExpr if it is available</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="n">df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">({</code><code class="s">'yp'</code><code class="p">:</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">uniform</code><code class="p">(</code><code class="n">low</code><code class="o">=</code><code class="mi">0.0000001</code><code class="p">,</code> <code class="n">size</code><code class="o">=</code><code class="n">nbr_items</code><code class="p">),</code>
       <code class="s">'yt'</code><code class="p">:</code> <code class="n">np</code><code class="o">.</code><code class="n">ones</code><code class="p">(</code><code class="n">nbr_items</code><code class="p">)})</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">answer_eval</code> <code class="o">=</code> <code class="n">df</code><code class="o">.</code><code class="n">eval</code><code class="p">(</code><code class="s">"-(yt * log(yp) + ((1-yt) * (log(1-yp))))"</code><code class="p">)</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]</code> <code class="n">used</code> <code class="mi">3052.1953</code> <code class="n">MiB</code> <code class="n">RAM</code> <code class="ow">in</code> <code class="mi">5.26</code><code class="n">s</code><code class="p">,</code> <code class="n">peaked</code> <code class="mi">3045.77</code> <code class="n">MiB</code> <code class="n">above</code> <code class="n">current</code><code class="p">,</code>
       <code class="n">total</code> <code class="n">RAM</code> <code class="n">usage</code> <code class="mi">6185.45</code> <code class="n">MiB</code></pre></div>

<p class="author1">Contrast the preceding example with <a data-type="xref" href="ch11_split_000.xhtml#lessram-numexpr4" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-10</a>, where NumExpr has <em class="hyperlink">not</em> been installed. The call to <code class="calibre26">df.eval</code> falls back on the Python interpreter—the same result is calculated but with a 34-second execution time (compared to 5.2 seconds before) and a much larger peak memory usage. You can test whether NumExpr is installed with <code class="calibre26">import numexpr</code>—if this fails, you’ll want to install it.</p>
<div id="lessram-numexpr4" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-10. </span>Beware that Pandas without NumExpr makes a slow and costly call to <code class="calibre26">eval</code>!</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="n">df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">({</code><code class="s">'yp'</code><code class="p">:</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">uniform</code><code class="p">(</code><code class="n">low</code><code class="o">=</code><code class="mi">0.0000001</code><code class="p">,</code> <code class="n">size</code><code class="o">=</code><code class="n">nbr_items</code><code class="p">),</code>
       <code class="s">'yt'</code><code class="p">:</code> <code class="n">np</code><code class="o">.</code><code class="n">ones</code><code class="p">(</code><code class="n">nbr_items</code><code class="p">)})</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">answer_eval</code> <code class="o">=</code> <code class="n">df</code><code class="o">.</code><code class="n">eval</code><code class="p">(</code><code class="s">"-(yt * log(yp) + ((1-yt) * (log(1-yp))))"</code><code class="p">)</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]</code> <code class="n">used</code> <code class="mi">3052.5625</code> <code class="n">MiB</code> <code class="n">RAM</code> <code class="ow">in</code> <code class="mi">34.88</code><code class="n">s</code><code class="p">,</code> <code class="n">peaked</code> <code class="mi">7620.15</code> <code class="n">MiB</code> <code class="n">above</code> <code class="n">current</code><code class="p">,</code>
       <code class="n">total</code> <code class="n">RAM</code> <code class="n">usage</code> <code class="mi">6185.24</code> <code class="n">MiB</code></pre></div>

<p class="author1">Complex vector operations on large arrays will run faster if you can use NumExpr. Pandas will not warn you that NumExpr hasn’t been installed, so we recommend that you add it as part of your setup if you use <code class="calibre26">eval</code>. The IPython Memory Usage tool will help you to diagnose where your RAM is being spent if you have large arrays to process; this can help you fit more into RAM on your current machine so you don’t have to start dividing your data and introducing greater engineering effort.<a data-type="indexterm" data-primary="" data-startref="arr_abt" id="idm46122401960888" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="ram_ams" id="idm46122401849848" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Understanding the RAM Used in a Collection" class="calibre3"><div class="preface" id="idm46122402884232">
<h1 class="calibre25">Understanding the RAM Used in a Collection</h1>

<p class="author1"><a data-type="indexterm" data-primary="collections" id="coll_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="RAM (random access memory)" data-secondary="in collections" id="ram_coll" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>You may wonder if you can ask Python about the RAM that’s used by each object. Python’s <code class="calibre26">sys.getsizeof(obj)</code> call will tell us <em class="hyperlink">something</em> about the memory used by an object (most but not all objects provide this). If you haven’t seen it before, be warned
that it won’t give you the answer you’d expect for a container!</p>

<p class="author1">Let’s start by looking at some primitive types. An <code class="calibre26">int</code> in Python is a variable-sized object of arbitrary size, well above the range of an 8-byte C integer. The basic object costs 24 bytes in Python 3.7 when initialized with 0. More bytes are added as you count to larger numbers:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="n">sys</code><code class="o">.</code><code class="n">getsizeof</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="mi">24</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">sys</code><code class="o">.</code><code class="n">getsizeof</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="mi">28</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">sys</code><code class="o">.</code><code class="n">getsizeof</code><code class="p">((</code><code class="mi">2</code><code class="o">**</code><code class="mi">30</code><code class="p">)</code><code class="o">-</code><code class="mi">1</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="mi">28</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">sys</code><code class="o">.</code><code class="n">getsizeof</code><code class="p">((</code><code class="mi">2</code><code class="o">**</code><code class="mi">30</code><code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="mi">32</code></pre>

<p class="author1">Behind the scenes, sets of 4 bytes are added each time the size of the number you’re counting steps above the previous limit. This affects only the memory usage; you don’t see any difference externally.</p>

<p class="author1">We can do the same check for byte strings. An empty byte sequence costs 33 bytes, and each
additional character adds 1 byte to the cost:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">sys</code><code class="o">.</code><code class="n">getsizeof</code><code class="p">(</code><code class="calibre26">b</code><code class="s">""</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="mi">33</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">sys</code><code class="o">.</code><code class="n">getsizeof</code><code class="p">(</code><code class="calibre26">b</code><code class="s">"a"</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="mi">34</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">sys</code><code class="o">.</code><code class="n">getsizeof</code><code class="p">(</code><code class="calibre26">b</code><code class="s">"ab"</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="mi">35</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">sys</code><code class="o">.</code><code class="n">getsizeof</code><code class="p">(</code><code class="calibre26">b</code><code class="s">"abc"</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="mi">36</code></pre>

<p class="author1">When we use a list, we see different behavior<a data-type="indexterm" data-primary="getsizeof" id="idm46122401738632" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>. <code class="calibre26">getsizeof</code> isn’t counting the cost of the
contents of the list—just the cost of the list itself. An empty list costs 64
bytes, and each item in the list takes another 8 bytes on a 64-bit laptop:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="c"># goes up in 8-byte steps rather than the 24+ we might expect!</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">sys</code><code class="o">.</code><code class="n">getsizeof</code><code class="p">([])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="mi">64</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">sys</code><code class="o">.</code><code class="n">getsizeof</code><code class="p">([</code><code class="mi">1</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="mi">72</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">sys</code><code class="o">.</code><code class="n">getsizeof</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="mi">80</code></pre>

<p class="author1">This is more obvious if we use byte strings—we’d expect to see much larger
costs than <code class="calibre26">getsizeof</code> is reporting:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">sys</code><code class="o">.</code><code class="n">getsizeof</code><code class="p">([</code><code class="calibre26">b</code><code class="s">""</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="mi">72</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">sys</code><code class="o">.</code><code class="n">getsizeof</code><code class="p">([</code><code class="calibre26">b</code><code class="s">"abcdefghijklm"</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="mi">72</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">sys</code><code class="o">.</code><code class="n">getsizeof</code><code class="p">([</code><code class="calibre26">b</code><code class="s">"a"</code><code class="p">,</code> <code class="calibre26">b</code><code class="s">"b"</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="mi">80</code></pre>

<p class="author1"><code class="calibre26">getsizeof</code> reports only some of the cost, and often just for the parent object. As noted previously, it also isn’t always implemented, so it can have limited usefulness.</p>

<p class="author1">A better tool is<a data-type="indexterm" data-primary="asizeof tool" id="idm46122401485384" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="pympler" id="idm46122401484856" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">asizeof</code> in <a href="https://oreil.ly/HGCj5" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"><code class="calibre26">pympler</code></a>. This will walk a
container’s hierarchy and make a best guess about the size of each
object it finds, adding the sizes to a total. Be warned that it is quite slow.</p>

<p class="author1">In addition to relying on guesses and assumptions, <code class="calibre26">asizeof</code> also cannot count memory allocated
behind the scenes (such as a module that wraps a C library may not report the
bytes allocated in the C library). It is best to use this as a guide. We prefer
to use <code class="calibre26">memit</code>, as it gives us an accurate count of memory usage on the machine in
question.</p>

<p class="author1">We can check the estimate it makes for a large list—here we’ll use 10 million integers:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">from</code> <code class="nn">pympler.asizeof</code> <code class="kn">import</code> <code class="n">asizeof</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">asizeof</code><code class="p">([</code><code class="n">x</code> <code class="kn">for</code> <code class="n">x</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="nb">int</code><code class="p">(</code><code class="mi">1e7</code><code class="p">))])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="mi">401528048</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="o">%</code><code class="n">memit</code> <code class="p">[</code><code class="n">x</code> <code class="kn">for</code> <code class="n">x</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="nb">int</code><code class="p">(</code><code class="mi">1e7</code><code class="p">))]</code>
<code class="n">peak</code> <code class="n">memory</code><code class="p">:</code> <code class="mi">401.91</code> <code class="n">MiB</code><code class="p">,</code> <code class="n">increment</code><code class="p">:</code> <code class="mi">326.77</code> <code class="n">MiB</code></pre>

<p class="author1">We can validate this estimate by using<a data-type="indexterm" data-primary="%memit" data-primary-sortas="memit" id="idm46122401478920" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="%memit" id="idm46122401478072" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">memit</code> to see how the process grew. Both reports are approximate—<code class="calibre26">memit</code> takes snapshots of the RAM usage reported by the operating system while the statement is executing, and <code class="calibre26">asizeof</code> asks the objects about their size (which may not be reported correctly). We can conclude that 10 million integers in a list cost between 320 and 400 MB of RAM.</p>

<p class="author1">Generally, the <code class="calibre26">asizeof</code> process is slower than using <code class="calibre26">memit</code>, but <code class="calibre26">asizeof</code> can
be useful when you’re analyzing small objects. <code class="calibre26">memit</code> is probably more useful for
real-world applications, as the actual memory usage of the process is measured
rather than<a data-type="indexterm" data-primary="" data-startref="coll_ab" id="idm46122401389752" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="ram_coll" id="idm46122401388776" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <span class="publishername">inferred</span>.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Bytes Versus Unicode" class="calibre3"><div class="preface" id="idm46122401848680">
<h1 class="calibre25">Bytes Versus Unicode</h1>

<p class="author1"><a data-type="indexterm" data-primary="Unicode object storage" id="idm46122401385704" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="RAM (random access memory)" data-secondary="bytes versus Unicode" id="idm46122401384840" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>One of the (many!) advantages of Python 3.<em class="hyperlink">x</em> over Python 2.<em class="hyperlink">x</em> is the switch to Unicode-by-default. Previously, we had a mix of single-byte strings and multibyte Unicode objects, which could cause a headache during data import and export. In Python 3.<em class="hyperlink">x</em>, all strings are Unicode by default, and if you want to deal in bytes, you’ll explicitly create a <code class="calibre26">byte</code> sequence.</p>

<p class="author1">Unicode objects have more efficient RAM usage in Python 3.7 than in Python 2.<em class="hyperlink">x</em>. In <a data-type="xref" href="ch11_split_000.xhtml#lessram-memory-profiler-stringvsunicode1" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-11</a>, we can see a 100-million-character sequence being built as a collection of bytes and as a Unicode object. The Unicode variant for common characters (here we’re assuming UTF 8 as the system’s default encoding) costs the same—a single-byte implementation is used for these common characters.</p>
<div id="lessram-memory-profiler-stringvsunicode1" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-11. </span>Unicode objects can be as cheap as bytes in Python 3.x</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="o">%</code><code class="n">load_ext</code> <code class="n">memory_profiler</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="nb">type</code><code class="p">(</code><code class="calibre26">b</code><code class="s">"b"</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="nb">bytes</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="o">%</code><code class="n">memit</code> <code class="calibre26">b</code><code class="s">"a"</code> <code class="o">*</code> <code class="nb">int</code><code class="p">(</code><code class="mi">1e8</code><code class="p">)</code>
<code class="n">peak</code> <code class="n">memory</code><code class="p">:</code> <code class="mi">121.55</code> <code class="n">MiB</code><code class="p">,</code> <code class="n">increment</code><code class="p">:</code> <code class="mi">78.17</code> <code class="n">MiB</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="nb">type</code><code class="p">(</code><code class="s">"u"</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="nb">str</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="o">%</code><code class="n">memit</code> <code class="s">"u"</code> <code class="o">*</code> <code class="nb">int</code><code class="p">(</code><code class="mi">1e8</code><code class="p">)</code>
<code class="n">peak</code> <code class="n">memory</code><code class="p">:</code> <code class="mi">122.43</code> <code class="n">MiB</code><code class="p">,</code> <code class="n">increment</code><code class="p">:</code> <code class="mi">78.49</code> <code class="n">MiB</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="o">%</code><code class="n">memit</code> <code class="s">"Σ"</code> <code class="o">*</code> <code class="nb">int</code><code class="p">(</code><code class="mi">1e8</code><code class="p">)</code>
<code class="n">peak</code> <code class="n">memory</code><code class="p">:</code> <code class="mi">316.40</code> <code class="n">MiB</code><code class="p">,</code> <code class="n">increment</code><code class="p">:</code> <code class="mi">176.17</code> <code class="n">MiB</code></pre></div>

<p class="author1">The <a data-type="indexterm" data-primary="sigma character" id="idm46122401375592" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>sigma character (Σ) is more expensive—it is represented in UTF 8 as 2 bytes. We gained the flexible Unicode representation from Python 3.3 thanks to <a href="https://oreil.ly/_wNrP" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">PEP 393</a>. It works by observing the range of characters in the string and using a smaller number of bytes to represent the lower-order characters, if 
<span class="publishername">possible</span>.</p>

<p class="author1">The UTF-8 encoding of a Unicode object uses 1 byte per ASCII character and more bytes for less frequently seen characters. If you’re not sure about Unicode encodings versus Unicode objects, go and watch<a data-type="indexterm" data-primary="&quot;Pragmatic Unicode, or, How Do I Stop the Pain?&quot;" data-primary-sortas="pragmatic" id="idm46122401206232" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="Batchelder, Ned" id="idm46122401205224" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <a href="https://oreil.ly/udL3A" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Net Batchelder’s “Pragmatic Unicode, or, How Do I Stop the Pain?”</a>.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Efficiently Storing Lots of Text in RAM" class="calibre3"><div class="preface" id="idm46122401203608">
<h1 class="calibre25">Efficiently Storing Lots of Text in RAM</h1>

<p class="author1"><a data-type="indexterm" data-primary="RAM (random access memory)" data-secondary="text storage options" id="ram_tex" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="text storage" data-secondary="options for" id="ts_opf" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>A common problem with text is that it occupies a lot of RAM—but if we want to test
if we have seen strings before or count their frequency, having them in RAM is more convenient than paging them to and from a disk. Storing the strings
naively is expensive, but tries and <a data-type="indexterm" data-primary="DAWGs (directed acyclic word graphs)" id="idm46122401199352" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="directed acyclic word graphs (DAWGs)" id="idm46122401198712" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>directed acyclic word graphs (DAWGs) can be
used to compress their representation and still allow fast operations.</p>

<p class="author1">These more advanced algorithms can save you a significant amount of RAM, which means that you might not need to expand to more servers. For production systems, the savings can be huge. In this section we’ll look at compressing a <code class="calibre26">set</code> of strings costing 1.2 GB down to 30 MB using a trie, with only a small change in performance.</p>

<p class="author1"><a data-type="indexterm" data-primary="token lookup" id="idm46122401196376" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>For this example, we’ll use a text set built from a partial dump of
Wikipedia. This set contains 11 million unique tokens from a portion of the English Wikipedia and takes up 120 MB on disk.</p>

<p class="author1">The tokens are split on whitespace from their original articles; they have
variable length and contain Unicode characters and numbers. They look like this:</p>

<pre data-type="programlisting" class="calibre50">faddishness
'melanesians'
Kharálampos
PizzaInACup™
url="http://en.wikipedia.org/wiki?curid=363886"
VIIIa),
Superbagnères.</pre>

<p class="author1">We’ll use this text sample to test how quickly we can build a data
structure holding one instance of each unique word, and then we’ll see how
quickly we can query for a known word (we’ll use the uncommon “Zwiebel,” from the painter Alfred Zwiebel). This
lets us ask, “Have we seen Zwiebel before?” Token lookup is a common problem, and
being able to do it quickly is important.</p>
<div data-type="note" epub:type="note" class="calibre35"><h6 class="calibre36">Note</h6>
<p class="author1">When you try these containers on your own problems, be aware that you will
probably see different behaviors. Each container builds its internal structures
in different ways; passing in different types of token is likely to affect the
build time of the structure, and different lengths of token will affect the query
time. Always test in a methodical way.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Trying These Approaches on 11 Million Tokens" class="calibre3"><div class="preface" id="idm46122401191496">
<h2 class="calibre43">Trying These Approaches on 11 Million Tokens</h2>

<p class="author1"><a data-type="xref" href="ch11_split_000.xhtml#FIG-less-ram-8mil_tokens" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Figure 11-2</a> shows the 11-million-token text file (120 MB raw data) stored using a number of containers that we’ll discuss in this section. The x-axis shows RAM usage for each container, the y-axis tracks the query time, and the size of each point relates to the time taken to build the structure (larger means it took longer).</p>

<p class="author1">As we can see in this diagram, the <code class="calibre26">set</code> and <code class="calibre26">list</code> examples use a lot of RAM; the <code class="calibre26">list</code> example is both large <em class="hyperlink">and</em> slow!
The Marisa trie example is the most RAM-efficient for this dataset, while the <a data-type="indexterm" data-primary="DAWGs (directed acyclic word graphs)" id="idm46122401186456" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="tries" id="idm46122401185784" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="directed acyclic word graphs (DAWGs)" id="idm46122401185112" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>DAWG runs twice as fast for a relatively small increase in RAM usage.</p>

<figure class="calibre46"><div id="FIG-less-ram-8mil_tokens" class="figure">
<img src="Images/hpp2_1102.png" alt="DAWG and Tries versus built-in containers for 11 million tokens" class="calibre111"/>
<h6 class="calibre47"><span class="publishername">Figure 11-2. </span>DAWG and tries versus built-in containers</h6>
</div></figure>

<p class="author1">The figure doesn’t show the lookup time for the naive <code class="calibre26">list</code> without sort approach, which we’ll introduce shortly, as it takes far too long. Do be aware that you must test your problem with a variety of containers—each offers different trade-offs, such as construction time and API flexibility.</p>

<p class="author1">Next, we’ll build up a process to test the behavior of each container.</p>










<section data-type="sect3" data-pdf-bookmark="list" class="calibre3"><div class="preface" id="idm46122401180920">
<h3 class="calibre51">list</h3>

<p class="author1"><a data-type="indexterm" data-primary="lists" data-secondary="text storage in" id="lis_ts" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="text storage" data-secondary="in lists" id="ts_lis" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Let’s start with the simplest approach. We’ll load our tokens into a <code class="calibre26">list</code> and then query it using an <code class="calibre26">O(n)</code> linear search. You can’t do this on the large example that we’ve already mentioned—the search takes far too long—so we’ll demonstrate the <span class="publishername">technique</span> with a much smaller (500,000 tokens) example.</p>

<p class="author1">In each of the following examples, we use a generator, <code class="calibre26">text_example.readers</code>,
that extracts one Unicode token at a time from the input file. This means that the read process uses only a tiny amount of RAM:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="kn">print</code><code class="p">(</code><code class="s">"RAM at start {:0.1f}MiB"</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="n">memory_profiler</code><code class="o">.</code><code class="n">memory_usage</code><code class="p">()[</code><code class="mi">0</code><code class="p">]))</code>
<code class="n">t1</code> <code class="o">=</code> <code class="n">time</code><code class="o">.</code><code class="n">time</code><code class="p">()</code>
<code class="n">words</code> <code class="o">=</code> <code class="p">[</code><code class="n">w</code> <code class="kn">for</code> <code class="n">w</code> <code class="ow">in</code> <code class="n">text_example</code><code class="o">.</code><code class="n">readers</code><code class="p">]</code>
<code class="kn">print</code><code class="p">(</code><code class="s">"Loading {} words"</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">words</code><code class="p">)))</code>
<code class="n">t2</code> <code class="o">=</code> <code class="n">time</code><code class="o">.</code><code class="n">time</code><code class="p">()</code>
<code class="kn">print</code><code class="p">(</code><code class="s">"RAM after creating list {:0.1f}MiB, took {:0.1f}s"</code> \
      <code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="n">memory_profiler</code><code class="o">.</code><code class="n">memory_usage</code><code class="p">()[</code><code class="mi">0</code><code class="p">],</code> <code class="n">t2</code> <code class="o">-</code> <code class="n">t1</code><code class="p">))</code></pre>

<p class="author1">We’re interested in how quickly we can query this <code class="calibre26">list</code>. Ideally, we want to find
a container that will store our text and allow us to query it and modify it
without penalty. To query it, we look for a known word a number of times by using
<code class="calibre26">timeit</code>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="kn">assert</code> <code class="s">'Zwiebel'</code> <code class="ow">in</code> <code class="n">words</code>
<code class="n">time_cost</code> <code class="o">=</code> <code class="nb">sum</code><code class="p">(</code><code class="n">timeit</code><code class="o">.</code><code class="n">repeat</code><code class="p">(</code><code class="n">stmt</code><code class="o">=</code><code class="s">"'Zwiebel' in words"</code><code class="p">,</code>
                              <code class="n">setup</code><code class="o">=</code><code class="s">"from __main__ import words"</code><code class="p">,</code>
                              <code class="n">number</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code>
                              <code class="n">repeat</code><code class="o">=</code><code class="mi">10000</code><code class="p">))</code>
<code class="kn">print</code><code class="p">(</code><code class="s">"Summed time to look up word {:0.4f}s"</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="n">time_cost</code><code class="p">))</code></pre>

<p class="author1">Our test script reports that approximately 34 MB was used to store the original
5 MB file as a list, and that the aggregate lookup time was 53 seconds:</p>

<pre data-type="programlisting" class="calibre50">$ python text_example_list.py
RAM at start 36.6MiB
Loading 499056 words
RAM after creating list 70.9MiB, took 1.0s
Summed time to look up word 53.5657s</pre>

<p class="author1">Storing text in an unsorted <code class="calibre26">list</code> is obviously a poor idea; the <code class="calibre26">O(n)</code> lookup
time is expensive, as is the memory usage. This is the worst of all
worlds! If we tried this method on the following larger dataset, we’d expect an aggregate lookup time of 25 minutes rather than a fraction of a second for the methods we discuss.</p>

<p class="author1">We can improve the lookup time by sorting the <code class="calibre26">list</code> and using a binary search
via the<a data-type="indexterm" data-primary="bisect module" id="idm46122401049320" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <a href="https://oreil.ly/Uk6ry" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"><code class="calibre26">bisect</code> module</a>; this gives us a sensible lower bound for future
queries. In <a data-type="xref" href="ch11_split_000.xhtml#less_ram_list_sorted_code" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-12</a>, we time how long it takes to <code class="calibre26">sort</code>
the <code class="calibre26">list</code>. Here, we switch to the larger 11-million-token set.</p>
<div id="less_ram_list_sorted_code" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-12. </span>Timing the <code class="calibre26">sort</code> operation to prepare for using <code class="calibre26">bisect</code></h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59">    <code class="kn">print</code><code class="p">(</code><code class="s">"RAM at start {:0.1f}MiB"</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="n">memory_profiler</code><code class="o">.</code><code class="n">memory_usage</code><code class="p">()[</code><code class="mi">0</code><code class="p">]))</code>
    <code class="n">t1</code> <code class="o">=</code> <code class="n">time</code><code class="o">.</code><code class="n">time</code><code class="p">()</code>
    <code class="n">words</code> <code class="o">=</code> <code class="p">[</code><code class="n">w</code> <code class="kn">for</code> <code class="n">w</code> <code class="ow">in</code> <code class="n">text_example</code><code class="o">.</code><code class="n">readers</code><code class="p">]</code>
    <code class="kn">print</code><code class="p">(</code><code class="s">"Loading {} words"</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">words</code><code class="p">)))</code>
    <code class="n">t2</code> <code class="o">=</code> <code class="n">time</code><code class="o">.</code><code class="n">time</code><code class="p">()</code>
    <code class="kn">print</code><code class="p">(</code><code class="s">"RAM after creating list {:0.1f}MiB, took {:0.1f}s"</code> \
          <code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="n">memory_profiler</code><code class="o">.</code><code class="n">memory_usage</code><code class="p">()[</code><code class="mi">0</code><code class="p">],</code> <code class="n">t2</code> <code class="o">-</code> <code class="n">t1</code><code class="p">))</code>
    <code class="kn">print</code><code class="p">(</code><code class="s">"The list contains {} words"</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">words</code><code class="p">)))</code>
    <code class="n">words</code><code class="o">.</code><code class="n">sort</code><code class="p">()</code>
    <code class="n">t3</code> <code class="o">=</code> <code class="n">time</code><code class="o">.</code><code class="n">time</code><code class="p">()</code>
    <code class="kn">print</code><code class="p">(</code><code class="s">"Sorting list took {:0.1f}s"</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="n">t3</code> <code class="o">-</code> <code class="n">t2</code><code class="p">))</code></pre></div>

<p class="author1">Next, we do the same lookup as before, but with the addition of the <a data-type="indexterm" data-primary="index method" id="idm46122400997352" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">index</code>
method, which uses <code class="calibre26">bisect</code>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="kn">import</code> <code class="nn">bisect</code>
<code class="o">...</code>
<code class="kn">def</code> <code class="nf">index</code><code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="n">x</code><code class="p">):</code>
    <code class="s">'Locate the leftmost value exactly equal to x'</code>
    <code class="n">i</code> <code class="o">=</code> <code class="n">bisect</code><code class="o">.</code><code class="n">bisect_left</code><code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="n">x</code><code class="p">)</code>
    <code class="kn">if</code> <code class="n">i</code> <code class="o">!=</code> <code class="nb">len</code><code class="p">(</code><code class="n">a</code><code class="p">)</code> <code class="ow">and</code> <code class="n">a</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="o">==</code> <code class="n">x</code><code class="p">:</code>
        <code class="kn">return</code> <code class="n">i</code>
    <code class="kn">raise</code> <code class="ne">ValueError</code>
<code class="o">...</code>
    <code class="n">time_cost</code> <code class="o">=</code> <code class="nb">sum</code><code class="p">(</code><code class="n">timeit</code><code class="o">.</code><code class="n">repeat</code><code class="p">(</code><code class="n">stmt</code><code class="o">=</code><code class="s">"index(words, 'Zwiebel')"</code><code class="p">,</code>
                                  <code class="n">setup</code><code class="o">=</code><code class="s">"from __main__ import words, index"</code><code class="p">,</code>
                                  <code class="n">number</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code>
                                  <code class="n">repeat</code><code class="o">=</code><code class="mi">10000</code><code class="p">))</code></pre>

<p class="author1">In <a data-type="xref" href="ch11_split_000.xhtml#less_ram_bisect_list_output" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-13</a>, we see that the RAM usage is much larger than before, as we’re loading significantly more data. The sort takes a further 0.6 seconds, and the cumulative lookup time is 0.01 seconds.</p>
<div data-type="example" id="less_ram_bisect_list_output" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-13. </span>Timings for using <code class="calibre26">bisect</code> on a sorted <code class="calibre26">list</code></h5>
<pre data-type="programlisting" class="calibre59">$ <strong class="calibre83">python text_example_list_bisect.py </strong>
RAM at start 36.6MiB
Loading 11595290 words
RAM after creating list 871.9MiB, took 20.6s
The list contains 11595290 words
Sorting list took 0.6s
Summed time to look up word 0.0109s
</pre>
</div>

<p class="author1">We now have a sensible baseline for timing string lookups: RAM usage must get better than 871 MB, and the total lookup time should be better than 0.01 seconds.<a data-type="indexterm" data-primary="" data-startref="lis_ts" id="idm46122400760760" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="ts_lis" id="idm46122400759784" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="set" class="calibre3"><div class="preface" id="idm46122401180296">
<h3 class="calibre51">set</h3>

<p class="author1"><a data-type="indexterm" data-primary="set, text storage in" id="idm46122400757432" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="text storage" data-secondary="in sets" id="idm46122400756568" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Using the built-in <code class="calibre26">set</code> might seem to be the most obvious way to tackle our
task. In <a data-type="xref" href="ch11_split_000.xhtml#less_ram_set_code" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-14</a>, the <code class="calibre26">set</code> stores each string in a hashed structure (see <a data-type="xref" href="ch04.xhtml#section-dictionary-sets" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Chapter 4</a> if you need a refresher). It is quick to check for membership, but each string must be stored separately, which is expensive on RAM.</p>
<div id="less_ram_set_code" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-14. </span>Using a <code class="calibre26">set</code> to store the data</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59">    <code class="n">words_set</code> <code class="o">=</code> <code class="nb">set</code><code class="p">(</code><code class="n">text_example</code><code class="o">.</code><code class="n">readers</code><code class="p">)</code></pre></div>

<p class="author1">As we can see in <a data-type="xref" href="ch11_split_000.xhtml#running_the_set_example" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-15</a>, the <code class="calibre26">set</code> uses more RAM than the <code class="calibre26">list</code> by a further 250 MB; however, it gives us a very fast lookup time
without requiring an additional <code class="calibre26">index</code> function or an intermediate sorting operation.</p>
<div data-type="example" id="running_the_set_example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-15. </span>Running the <code class="calibre26">set</code> example</h5>
<pre data-type="programlisting" class="calibre59">$ <strong class="calibre83">python text_example_set.py</strong>
RAM at start 36.6MiB
RAM after creating set 1295.3MiB, took 24.0s
The set contains 11595290 words
Summed time to look up word 0.0023s
</pre>
</div>

<p class="author1">If RAM isn’t at a premium, this might be the most sensible first approach.</p>

<p class="author1">We have now lost the <em class="hyperlink">ordering</em> of the original data, though. If that’s important to you, note that you could store the strings as keys in a dictionary, with each value being an index connected to the original read order. This way, you could ask the dictionary if the key is present and for its index.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="More efficient tree structures" class="calibre3"><div class="preface" id="idm46122400742296">
<h3 class="calibre51">More efficient tree structures</h3>

<p class="author1"><a data-type="indexterm" data-primary="tree structures" id="idm46122400740888" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Let’s introduce a set of algorithms that use RAM more efficiently to represent our strings.</p>

<p class="author1"><a data-type="xref" href="ch11_split_000.xhtml#FIG-less-ram-trie-dawg-picture" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Figure 11-3</a> from <a href="http://commons.wikimedia.org" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Wikimedia Commons</a> shows the difference in representation of four words—“tap”, “taps”, “top”, and “tops”—between a trie and a<a data-type="indexterm" data-primary="Wikimedia Commons" id="idm46122400700056" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="DAWGs (directed acyclic word graphs)" id="idm46122400699352" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="directed acyclic word graphs (DAWGs)" id="idm46122400698712" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> DAWG.<sup class="calibre44"><a data-type="noteref" id="idm46122400697944-marker" href="ch11_split_001.xhtml#idm46122400697944" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">1</a></sup> With a <code class="calibre26">list</code> or a <code class="calibre26">set</code>, each of these words would be stored as a separate string. Both the DAWG and the trie share parts of the strings, so that less RAM is used.</p>

<p class="author1">The main difference between these is that a trie shares just common prefixes, while a DAWG shares common prefixes and suffixes. In languages (like English) that have many common word prefixes and suffixes, this can save a lot of repetition.</p>

<p class="author1">Exact memory behavior will depend on your data’s structure. Typically, a DAWG cannot assign a value to a key because of the multiple paths from the start to the end of the string, but the version shown here can accept a value mapping. Tries can also accept a value mapping. Some structures have to be constructed in a pass at the start, and others can be updated at any time.</p>

<p class="author1">A big strength of some of these structures is that they provide a <em class="hyperlink">common prefix search</em>; that is, you can ask for all words that share the prefix you provide. With our list of four words, the result when searching for “ta” would be “tap” and “taps.” Furthermore, since these are discovered through the graph structure, the retrieval of these results is very fast. If you’re working with DNA, for example, compressing millions of short strings by using a trie can be an efficient way to reduce RAM usage.</p>

<figure class="calibre46"><div id="FIG-less-ram-trie-dawg-picture" class="figure">
<img src="Images/hpp2_1103.png" alt="DAWG and Trie data structures" class="calibre116"/>
<h6 class="calibre47"><span class="publishername">Figure 11-3. </span>Trie and DAWG structures (image by <a href="https://oreil.ly/w71ZI" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Chkno</a> [CC BY-SA 3.0])</h6>
</div></figure>

<p class="author1">In the following sections, we take a closer look at DAWGs, tries, and their usage.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Directed acyclic word graph" class="calibre3"><div class="preface" id="idm46122400727384">
<h3 class="calibre51">Directed acyclic word graph</h3>

<p class="author1"><a data-type="indexterm" data-primary="tries" id="trie_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="DAWGs (directed acyclic word graphs)" id="idm46122400724968" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="directed acyclic word graphs (DAWGs)" id="idm46122400724232" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>The <a href="https://oreil.ly/4KfVO" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">directed acyclic word graph</a> (MIT
license) attempts to efficiently represent strings that share common prefixes and suffixes.</p>

<p class="author1">Note that at the time of writing, an <a href="https://oreil.ly/6T5le" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">open Pull Request on GitHub</a> has to be applied to make this DAWG work with Python 3.7.</p>

<p class="author1">In <a data-type="xref" href="ch11_split_000.xhtml#less_ram_dawg_code" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-16</a>, you see the very simple setup for a DAWG. For this implementation, the DAWG cannot be
modified after construction; it reads an iterator to construct itself once. The lack of post-construction updates might be a deal breaker for your use case. If so, you might need to look into using a trie instead. The DAWG does support rich queries, including prefix lookups; it also allows persistence and supports storing integer indices as values
along with byte and record values.</p>
<div id="less_ram_dawg_code" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-16. </span>Using a DAWG to store the data</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">import</code> <code class="nn">dawg</code>
<code class="o">...</code>
    <code class="n">words_dawg</code> <code class="o">=</code> <code class="n">dawg</code><code class="o">.</code><code class="n">DAWG</code><code class="p">(</code><code class="n">text_example</code><code class="o">.</code><code class="n">readers</code><code class="p">)</code></pre></div>

<p class="author1">As you can see in <a data-type="xref" href="ch11_split_000.xhtml#less-ram-dawg-example" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-17</a>, for the same set of strings it uses significantly less RAM than the earlier <code class="calibre26">set</code> example during the <em class="hyperlink">construction</em> phase. More similar input text will cause stronger <span class="publishername">compression</span>.</p>
<div data-type="example" id="less-ram-dawg-example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-17. </span>Running the DAWG example</h5>
<pre data-type="programlisting" class="calibre59">$ <strong class="calibre83">python text_example_dawg.py</strong>
RAM at start 38.1MiB
RAM after creating dawg 200.8MiB, took 31.6s
Summed time to look up word 0.0044s
</pre>
</div>

<p class="author1">More importantly, if we persist the DAWG to disk, as shown in <a data-type="xref" href="ch11_split_000.xhtml#less-ram-dawg-example2" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-18</a>, and then load it back into a fresh Python instance, we see a dramatic reduction in RAM usage—the disk file and the memory usage after loading are both 70 MB; this is a significant savings compared to the 1.2 GB <code class="calibre26">set</code> variant we built earlier!</p>
<div data-type="example" id="less-ram-dawg-example2" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-18. </span>Loading the DAWG that was built and saved in an earlier session is more RAM efficient</h5>
<pre data-type="programlisting" class="calibre59">$ <strong class="calibre83">python text_example_dawg_load_only.py</strong>
RAM at start 38.4MiB
RAM after load 109.0MiB
Summed time to look up word 0.0051s
</pre>
</div>

<p class="author1">Given that you’ll typically create a DAWG once and then load it many times, you’ll benefit from the construction costs repeatedly after you’ve persisted the structure to disk.</p>
</div></section>













</div></section>





</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 11. Using Less RAM" class="calibre3">
<div class="preface" id="chapter-lessram">
<section data-type="sect1" data-pdf-bookmark="Efficiently Storing Lots of Text in RAM" class="calibre3">
<div class="preface" id="idm46122401203608">
<section data-type="sect2" data-pdf-bookmark="Trying These Approaches on 11 Million Tokens" class="calibre3">
<div class="preface" id="idm46122401191496">
<section data-type="sect3" data-pdf-bookmark="Marisa trie" class="calibre3"><div class="preface" id="idm46122400726760">
<h3 class="calibre51">Marisa trie</h3>

<p class="author1"><a data-type="indexterm" data-primary="Marisa trie" id="idm46122400638440" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>The <a href="https://oreil.ly/tDvVQ" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Marisa trie</a> (dual-licensed
LGPL and BSD) is a static <a href="https://oreil.ly/suBhE" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">trie</a>
using Cython bindings to an external library. As it is static, it cannot be modified after construction. Like the DAWG, it supports storing integer indices as
values, as well as byte values and record values.</p>

<p class="author1">A key can be used to look up a value, and vice versa. All keys sharing the same
prefix can be found efficiently. The trie’s contents can be persisted. <a data-type="xref" href="ch11_split_001.xhtml#less_ram_marisa_trie_code" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-19</a> illustrates using a Marisa trie to store our sample data.</p>
<div id="less_ram_marisa_trie_code" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-19. </span>Using a Marisa trie to store the data</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">import</code> <code class="nn">marisa_trie</code>
<code class="o">...</code>
    <code class="n">words_trie</code> <code class="o">=</code> <code class="n">marisa_trie</code><code class="o">.</code><code class="n">Trie</code><code class="p">(</code><code class="n">text_example</code><code class="o">.</code><code class="n">readers</code><code class="p">)</code></pre></div>

<p class="author1">In <a data-type="xref" href="ch11_split_001.xhtml#less-ram-marisa-trie-example" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-20</a>, we can see that lookup times are slower than those offered by the DAWG.</p>
<div data-type="example" id="less-ram-marisa-trie-example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-20. </span>Running the Marisa trie example</h5>
<pre data-type="programlisting" class="calibre59">$ <strong class="calibre83">python text_example_trie.py</strong>
RAM at start 38.3MiB
RAM after creating trie 419.9MiB, took 35.1s
The trie contains 11595290 words
Summed time to look up word 0.0148s
</pre>
</div>

<p class="author1">The trie offers a further saving in memory on this dataset. While the lookups are a little slower in <a data-type="xref" href="ch11_split_001.xhtml#less-ram-marisa-trie-example2" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-21</a>, the disk and RAM usage are approximately 30 MB in the following snippet, if we save the trie to disk and then load it back into a fresh process; this is twice as good as what the DAWG achieved.</p>
<div data-type="example" id="less-ram-marisa-trie-example2" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-21. </span>Loading the Trie that was built and saved in an earlier session is more RAM efficient</h5>
<pre data-type="programlisting" class="calibre59">$ <strong class="calibre83">python text_example_trie_load_only.py</strong>
RAM at start 38.5MiB
RAM after loading trie from disk 76.7MiB, took 0.0s
The trie contains 11595290 words
Summed time to look up word 0.0092s
</pre>
</div>

<p class="author1">The trade-off between storage sizes after construction and lookup times will need to be investigated for your application. You may find that using one of these “works just well enough,” so you might avoid benchmarking other options and simply move on to your next challenge. We suggest that the Marisa trie is your first choice in this case; it has more stars than the DAWG on GitHub.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Using tries (and DAWGs) in production systems" class="calibre3"><div class="preface" id="idm46122400587080">
<h3 class="calibre51">Using tries (and DAWGs) in production systems</h3>

<p class="author1">The trie and DAWG data structures offer good benefits, but you must still benchmark them on your problem rather than blindly adopting them. If you have overlapping sequences in your strings, you’ll likely see a RAM improvement.</p>

<p class="author1">Tries and DAWGs are less well known, but they can provide strong benefits in production systems. We have an impressive success story in <a data-type="xref" href="ch12.xhtml#lessons-from-field-alex" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Large-Scale Social Media Analysis at Smesh (2014)”</a>. <a data-type="indexterm" data-primary="Matthews, Jamie" id="idm46122400583880" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="DabApps" id="idm46122400583176" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Jamie Matthews at DabApps (a Python software house based in the United Kingdom) also has a story about the use of tries in client systems to enable more efficient and cheaper deployments for customers:</p>
<blockquote class="calibre69 pcalibre5 pcalibre6">
<p class="calibre70">At DabApps, we often try to tackle complex technical architecture problems by dividing them into small, self-contained components, usually communicating over the network using HTTP. This approach<a data-type="indexterm" data-primary="SoA (service-oriented architecture)" id="idm46122400580792" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="service-oriented architecture (SoA)" id="idm46122400580120" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="microservice architecture" id="idm46122400579480" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> (referred to as a <em class="hyperlink">service-oriented</em> or <em class="hyperlink">microservice</em> architecture) has all sorts of benefits, including the possibility of reusing or sharing the <span class="publishername">functionality</span> of a single component between multiple projects.</p>

<p class="calibre70">One such task that is often a requirement in our consumer-facing client projects is postcode geocoding. This is the task of converting a full UK postcode (for example: BN1 1AG) into a latitude and longitude coordinate pair, to enable the application to perform geospatial calculations such as distance measurement.</p>

<p class="calibre70">At its most basic, a geocoding database is a simple mapping between strings and can conceptually be represented as a dictionary. The dictionary keys are the postcodes, stored in a normalized form (BN11AG), and the values are a representation of the coordinates (we used a geohash encoding, but for simplicity imagine a comma-separated pair such as 50.822921,-0.142871).</p>

<p class="calibre70">The UK has approximately 1.7 million postcodes. Naively loading the full dataset into a Python dictionary, as described previously, uses several hundred megabytes of memory. Persisting this data structure to disk using Python’s native Pickle format requires an unacceptably large amount of storage space. We knew we could do better.</p>

<p class="calibre70">We experimented with several different in-memory and on-disk storage and serialization formats, including storing the data externally in databases such as Redis and <span class="publishername">LevelDB</span>, and compressing the key/value pairs. Eventually, we hit on the idea of using a trie. Tries are extremely efficient at representing large numbers of strings in memory, and the available open source libraries (we chose “marisa-trie”) make them very simple to use.</p>

<p class="calibre70">The resulting application, including a tiny web API built with the <a data-type="indexterm" data-primary="Flask" id="idm46122400572824" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Flask framework, uses only 30 MB of memory to represent the entire UK postcode database, and can comfortably handle a high volume of postcode lookup requests. The code is simple; the service is very lightweight and painless to deploy and run on a free hosting platform such as <a data-type="indexterm" data-primary="Heroku" id="idm46122400554344" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Heroku, with no external requirements or dependencies on databases. Our implementation is open source, available at <a href="https://github.com/j4mie/postcodeserver" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"><em class="hyperlink">https://github.com/j4mie/postcodeserver</em></a>.</p>
<p data-type="attribution" class="calibre71 pcalibre7">Jamie Matthews, <cite class="publishername">technical director of DabApps.com (UK)</cite></p>
</blockquote>

<p class="author1">DAWG and tries are powerful data structures that can help you save RAM and time in exchange for a little additional effort in preparation. These data structures will be unfamiliar to many developers, so consider separating this code into a module that is reasonably isolated from the rest of your code to simplify maintenance.<a data-type="indexterm" data-primary="" data-startref="ram_tex" id="idm46122400550744" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="ts_opf" id="idm46122400549768" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="trie_ab" id="idm46122400548824" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Modeling More Text with Scikit-Learn’s FeatureHasher" class="calibre3"><div class="preface" id="idm46122401190872">
<h1 class="calibre25">Modeling More Text with Scikit-Learn’s FeatureHasher</h1>

<p class="author1"><a data-type="indexterm" data-primary="FeatureHasher" id="fh_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="RAM (random access memory)" data-secondary="DictVectorizer" id="ram_dv" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="RAM (random access memory)" data-secondary="FeatureHasher" id="ram_fh" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="scikit-learn" data-secondary="FeatureHasher" id="sci_fh" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="DictVectorizer" id="dv_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Scikit-learn is Python’s best-known machine learning framework, and it has excellent support for text-based natural language processing (NLP) challenges. Here, we’ll look at classifying public posts from Usenet archives to one of 20 prespecified categories; this is similar to the two-category spam classification process that cleans up our email inboxes.</p>

<p class="author1">One difficulty with text processing is that the vocabulary under analysis quickly explodes. The English language uses many nouns (e.g., the names of people and places, medical labels, and religious terms) and verbs (the “doing words” that often end in “-ing,” like “running,” “taking,” “making,” and “talking”) and their conjugations (turning the verb “talk” into “talked,” “talking,” “talks”), along with all the other rich forms of language. Punctuation and capitalization add an extra nuance to the representation of words.</p>

<p class="author1">A powerful and simple technique for classifying text is to break the original text into <em class="hyperlink">n-grams</em>, often unigrams, bigrams, and trigrams (also known as 1-grams, 2-grams, and 3-grams). A sentence like “there is a cat and a dog” can be turned into unigrams (“there,” “is,” “a,” and so on), bigrams (“there is,” “is a,” “a cat,” etc.), and trigrams (“there is a,” “is a cat,” “a cat and,” …).</p>

<p class="author1">There are 7 unigrams, 6 bigrams, and 5 trigrams for this sentence; in total this sentence can be represented in this form by a vocabulary of 6 unique unigrams (since the term “a” is used twice), 6 unique bigrams, and 5 unique trigrams, making 17 descriptive items in total. As you can see, the n-gram vocabulary used to represent a sentence quickly grows; some terms are very common, and some are very rare.</p>

<p class="author1">There are techniques to control the explosion of a vocabulary, such as eliminating stop-words (removing the most common and often uninformative terms, like “a,” “the,” and “of”), lowercasing everything, and ignoring less frequent types of terms (such as punctuation, numbers, and brackets). If you practice natural language processing, you’ll quickly come across these approaches.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Introducing DictVectorizer and FeatureHasher" class="calibre3"><div class="preface" id="dictvectorizer">
<h1 class="calibre25">Introducing DictVectorizer and FeatureHasher</h1>

<p class="author1">Before we look at the Usenet classification task, let’s look at two of
scikit-learn’s feature processing tools that help with NLP challenges. The first
is <code class="calibre26">DictVectorizer</code>, which takes a dictionary of terms and their frequencies
and converts them into a variable-width sparse matrix (we will discuss sparse
matrices in <a data-type="xref" href="ch11_split_001.xhtml#SEC-sparse" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“SciPy’s Sparse Matrices”</a>). The second is <code class="calibre26">FeatureHasher</code>, which converts
the same dictionary of terms and frequencies into a fixed-width sparse matrix.</p>

<p class="author1"><a data-type="xref" href="ch11_split_001.xhtml#less_ram_dict_vectorizer" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-22</a> shows two sentences—“there is a cat” and “there is a cat and a dog”—in which terms are shared between the sentences and the term “a” is used twice in one of the sentences. <code class="calibre26">DictVectorizer</code> is given the sentences in the call to <code class="calibre26">fit</code>; in a first pass it builds a list of words into an internal <code class="calibre26">vocabulary_</code>, and in a second pass it builds up a sparse matrix containing a reference to each term and its count.</p>

<p class="author1">Doing two passes takes longer than the one pass of <code class="calibre26">FeatureHasher</code>, and storing a vocabulary costs additional RAM. Building a vocabulary is often a serial process; by avoiding this stage, the feature hashing can potentially operate in parallel for additional speed.</p>
<div id="less_ram_dict_vectorizer" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-22. </span>Lossless text representation with <code class="calibre26">DictVectorizer</code></h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="kn">from</code> <code class="nn">sklearn.feature_extraction</code> <code class="kn">import</code> <code class="n">DictVectorizer</code>
   <code class="o">...</code><code class="p">:</code>
   <code class="o">...</code><code class="p">:</code> <code class="n">dv</code> <code class="o">=</code> <code class="n">DictVectorizer</code><code class="p">()</code>
   <code class="o">...</code><code class="p">:</code> <code class="c"># frequency counts for ["there is a cat", "there is a cat and a dog"]</code>
   <code class="o">...</code><code class="p">:</code> <code class="n">token_dict</code> <code class="o">=</code> <code class="p">[{</code><code class="s">'there'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'is'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'a'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'cat'</code><code class="p">:</code> <code class="mi">1</code><code class="p">},</code>
   <code class="o">...</code><code class="p">:</code>               <code class="p">{</code><code class="s">'there'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'is'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'a'</code><code class="p">:</code> <code class="mi">2</code><code class="p">,</code> <code class="s">'cat'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'and'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'dog'</code><code class="p">:</code> <code class="mi">1</code><code class="p">}]</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">dv</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">token_dict</code><code class="p">)</code>
   <code class="o">...</code><code class="p">:</code>
   <code class="o">...</code><code class="p">:</code> <code class="kn">print</code><code class="p">(</code><code class="s">"Vocabulary:"</code><code class="p">)</code>
   <code class="o">...</code><code class="p">:</code> <code class="n">pprint</code><code class="p">(</code><code class="n">dv</code><code class="o">.</code><code class="n">vocabulary_</code><code class="p">)</code>

<code class="n">Vocabulary</code><code class="p">:</code>
<code class="p">{</code><code class="s">'a'</code><code class="p">:</code> <code class="mi">0</code><code class="p">,</code> <code class="s">'and'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'cat'</code><code class="p">:</code> <code class="mi">2</code><code class="p">,</code> <code class="s">'dog'</code><code class="p">:</code> <code class="mi">3</code><code class="p">,</code> <code class="s">'is'</code><code class="p">:</code> <code class="mi">4</code><code class="p">,</code> <code class="s">'there'</code><code class="p">:</code> <code class="mi">5</code><code class="p">}</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">X</code> <code class="o">=</code> <code class="n">dv</code><code class="o">.</code><code class="n">transform</code><code class="p">(</code><code class="n">token_dict</code><code class="p">)</code></pre></div>

<p class="author1">To make the output a little clearer, see the Pandas DataFrame view of the matrix <code class="calibre26">X</code> in <a data-type="xref" href="ch11_split_001.xhtml#FIG-less-ram-dictvect-dataframe" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Figure 11-4</a>, where the columns are set to the vocabulary. Note that here we’ve made a <em class="hyperlink">dense</em> representation of the matrix—we have 2 rows and 6 columns, and each of the 12 cells contains a number. In the sparse form, we store only the 10 counts that are present and we do not store anything for the 2 items that are missing. With a larger corpus, the larger storage required by a dense representation, containing mostly 0s, quickly becomes prohibitive. For NLP the sparse representation is standard.</p>

<figure class="calibre46"><div id="FIG-less-ram-dictvect-dataframe" class="figure">
<img src="Images/hpp2_1104.png" alt="DictVectorizer transformed ouptput" class="calibre117"/>
<h6 class="calibre47"><span class="publishername">Figure 11-4. </span>Transformed output of <code class="calibre26">DictVectorizer</code> shown in a Pandas DataFrame</h6>
</div></figure>

<p class="author1">One feature of <code class="calibre26">DictVectorizer</code> is that we can give it a matrix and reverse the process. In <a data-type="xref" href="ch11_split_001.xhtml#less_ram_dict_vectorizer_reverse" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-23</a>, we use the vocabulary to recover the original frequency representation. Note that this does <em class="hyperlink">not</em> recover the original sentence; there’s more than one way to interpret the ordering of words in the first example (both “there is a cat” and “a cat is there” are valid interpretations). If we used bigrams, we’d start to introduce a constraint on the ordering of words.</p>
<div id="less_ram_dict_vectorizer_reverse" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-23. </span>Reversing the output of matrix <code class="calibre26">X</code> to the original dictionary representation</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="kn">print</code><code class="p">(</code><code class="s">"Reversing the transform:"</code><code class="p">)</code>
   <code class="o">...</code><code class="p">:</code> <code class="n">pprint</code><code class="p">(</code><code class="n">dv</code><code class="o">.</code><code class="n">inverse_transform</code><code class="p">(</code><code class="n">X</code><code class="p">))</code>

<code class="n">Reversing</code> <code class="n">the</code> <code class="n">transform</code><code class="p">:</code>
<code class="p">[{</code><code class="s">'a'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'cat'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'is'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'there'</code><code class="p">:</code> <code class="mi">1</code><code class="p">},</code>
 <code class="p">{</code><code class="s">'a'</code><code class="p">:</code> <code class="mi">2</code><code class="p">,</code> <code class="s">'and'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'cat'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'dog'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'is'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'there'</code><code class="p">:</code> <code class="mi">1</code><code class="p">}]</code></pre></div>

<p class="author1"><code class="calibre26">FeatureHasher</code> takes the same input and generates a similar output but with one key difference: it does not store a vocabulary and instead employs a hashing algorithm to assign token frequencies to columns.</p>

<p class="author1">We’ve already looked at <a data-type="indexterm" data-primary="hash functions" data-secondary="collisions and" id="idm46122400387880" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>hash functions in <a data-type="xref" href="ch04.xhtml#dict_set_how_work" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“How Do Dictionaries and Sets Work?”</a>. A hash converts a unique item (in this case a text token) into a number, where multiple unique items might map to the same hashed value, in which case we get a collision. Good hash functions cause few collisions. Collisions are inevitable if we’re hashing many unique items to a smaller representation. One feature of a hash function is that it can’t easily be reversed, so we can’t take a hashed value and convert it back to the original token.</p>

<p class="author1">In <a data-type="xref" href="ch11_split_001.xhtml#less_ram_featurehasher" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-24</a>, we ask for a fixed-width 10-column matrix—the default is a fixed-width matrix of 1 million elements, but we’ll use a tiny matrix here to show a collision. The default 1-million-element width is a sensible default for many applications.</p>

<p class="author1">The hashing process uses the fast <a data-type="indexterm" data-primary="MurmurHash3 algorithm" id="idm46122400174616" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>MurmurHash3 algorithm, which transforms each token into a number; this is then converted into the range we specify. Larger ranges have few collisions; a small range like our range of 10 will have many collisions. Since every token has to be mapped to one of only 10 columns, we’ll get many collisions if we add a lot of sentences.</p>

<p class="author1">The output <code class="calibre26">X</code> has 2 rows and 10 columns; each token maps to one column, and we don’t immediately know which column represents each word since hashing functions are one-way, so we can’t map the output back to the input. In this case we can deduce, using <code class="calibre26">extra_token_dict</code>, that the tokens <code class="calibre26">there</code> and <code class="calibre26">is</code> both map to column 8, so we get nine 0s and one count of 2 in column 8.</p>
<div id="less_ram_featurehasher" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-24. </span>Using a 10-column <code class="calibre26">FeatureHasher</code> to show a hash collision</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="kn">from</code> <code class="nn">sklearn.feature_extraction</code> <code class="kn">import</code> <code class="n">FeatureHasher</code>
   <code class="o">...</code><code class="p">:</code>
   <code class="o">...</code><code class="p">:</code> <code class="n">fh</code> <code class="o">=</code> <code class="n">FeatureHasher</code><code class="p">(</code><code class="n">n_features</code><code class="o">=</code><code class="mi">10</code><code class="p">,</code> <code class="n">alternate_sign</code><code class="o">=</code><code class="nb">False</code><code class="p">)</code>
   <code class="o">...</code><code class="p">:</code> <code class="n">fh</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">token_dict</code><code class="p">)</code>
   <code class="o">...</code><code class="p">:</code> <code class="n">X</code> <code class="o">=</code> <code class="n">fh</code><code class="o">.</code><code class="n">transform</code><code class="p">(</code><code class="n">token_dict</code><code class="p">)</code>
   <code class="o">...</code><code class="p">:</code> <code class="n">pprint</code><code class="p">(</code><code class="n">X</code><code class="o">.</code><code class="n">toarray</code><code class="p">()</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">int_</code><code class="p">))</code>
   <code class="o">...</code><code class="p">:</code>
<code class="n">array</code><code class="p">([[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code>
       <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">]])</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">extra_token_dict</code> <code class="o">=</code> <code class="p">[{</code><code class="s">'there'</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s">'is'</code><code class="p">:</code> <code class="mi">1</code><code class="p">},</code> <code class="p">]</code>
   <code class="o">...</code><code class="p">:</code> <code class="n">X</code> <code class="o">=</code> <code class="n">fh</code><code class="o">.</code><code class="n">transform</code><code class="p">(</code><code class="n">extra_token_dict</code><code class="p">)</code>
   <code class="o">...</code><code class="p">:</code> <code class="kn">print</code><code class="p">(</code><code class="n">X</code><code class="o">.</code><code class="n">toarray</code><code class="p">()</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">int_</code><code class="p">))</code>
   <code class="o">...</code><code class="p">:</code>
<code class="p">[[</code><code class="mi">0</code> <code class="mi">0</code> <code class="mi">0</code> <code class="mi">0</code> <code class="mi">0</code> <code class="mi">0</code> <code class="mi">0</code> <code class="mi">2</code> <code class="mi">0</code> <code class="mi">0</code><code class="p">]]</code></pre></div>

<p class="author1">Despite the occurrence of collisions, more than enough signal is often retained in this representation (assuming the default number of columns is used) to enable similar quality machine learning results with <code class="calibre26">FeatureHasher</code> compared to <code class="calibre26">DictVectorizer</code>.</p>








<section data-type="sect2" data-pdf-bookmark="Comparing DictVectorizer and FeatureHasher on a Real Problem" class="calibre3"><div class="preface" id="idm46122400343224">
<h2 class="calibre43">Comparing DictVectorizer and FeatureHasher on a Real Problem</h2>

<p class="author1">If we take the full 20 Newsgroups dataset, we have 20 categories, with approximately 18,000 emails spread across the categories. While some categories such as “sci.med” are relatively unique, others like “comp.os.ms-windows.misc” and “comp.windows.x” will contain emails that share similar terms. The machine learning task is to correctly identify the correct newsgroup from the 20 options for each item in the test set. The test set has approximately 4,000 emails; the training set used to learn the mapping of terms to the matching category has approximately 14,000 emails.</p>

<p class="author1">Note that this example does <em class="hyperlink">not</em> deal with some of the necessities of a realistic training challenge. We haven’t stripped newsgroup metadata, which can be used to overfit on this challenge; rather than generalize just from the text of the emails, some extraneous metadata artificially boosts the scores. We have randomly shuffled the emails. Here, we’re not trying to achieve a single excellent machine learning result; instead, we’re demonstrating that a lossy hashed representation can be equivalent to a nonlossy and more memory-hungry variant.</p>

<p class="author1">In <a data-type="xref" href="ch11_split_001.xhtml#less_ram_featurehasher_real_world" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-25</a>, we take 18,846 documents and build up a training and test set representation using both <code class="calibre26">DictVectorizer</code> and <code class="calibre26">FeatureHasher</code> with unigrams, bigrams, and trigrams.  The <code class="calibre26">DictVectorizer</code> sparse array has shape <code class="calibre26">(14,134, 4,335,793)</code> for the training set, where our 14,134 emails are represented using 4 million tokens. Building the vocabulary and transforming the training data takes 42 seconds.</p>

<p class="author1">Contrast this with the <code class="calibre26">FeatureHasher</code>, which has a fixed 1-million-element-wide hashed representation, and where the transformation takes 21 seconds. Note that in both cases, roughly 9.8 million nonzero items are stored in the sparse matrices, so they’re storing similar quantities of information. The hashed version stores approximately 10,000 fewer items because of collisions.</p>

<p class="author1">If we’d used a dense matrix, we’d have 14 thousand rows by 10 million columns, making 140,000,000,000 cells of 8 bytes each—significantly more RAM than is typically available in any current machine. Only a tiny fraction of this matrix would be nonzero. Sparse matrices avoid this RAM consumption.</p>
<div id="less_ram_featurehasher_real_world" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-25. </span>Comparing <code class="calibre26">DictVectorizer</code> and <code class="calibre26">FeatureHasher</code> on a real machine learning problem</h5>

<pre data-type="programlisting" class="calibre59">Loading 20 newsgroups training data
18846 documents - 35.855MB

DictVectorizer on frequency dicts
DictVectorizer has shape (14134, 4335793) with 78,872,376 bytes
 and 9,859,047 non-zero items in 42.15 seconds
Vocabulary has 4,335,793 tokens
LogisticRegression score 0.89 in 1179.33 seconds

FeatureHasher on frequency dicts
FeatureHasher has shape (14134, 1048576) with 78,787,936 bytes
 and 9,848,492 non-zero items in 21.59 seconds
LogisticRegression score 0.89 in 903.35 seconds</pre></div>

<p class="author1">Critically, the <code class="calibre26">LogisticRegression</code> classifier used on <code class="calibre26">DictVectorizer</code> takes 30% longer to train with 4 million columns compared to the 1 million columns used by the <code class="calibre26">FeatureHasher</code>. Both show a score of 0.89, so for this challenge the results are reasonably equivalent.</p>

<p class="author1">Using <code class="calibre26">FeatureHasher</code>, we’ve achieved the same score on the test set, built our training matrix faster, and avoided building and storing a vocabulary, and we’ve trained faster than using the more common <code class="calibre26">DictVectorizer</code> approach. In exchange, we’ve lost the ability to transform a hashed representation back into the original features for debugging and explanation, and since we often want the ability to diagnose <em class="hyperlink">why</em> a decision was made, this might be too costly a trade for you to make.<a data-type="indexterm" data-primary="" data-startref="fh_ab" id="idm46122400039672" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="ram_dv" id="idm46122400038696" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="ram_fh" id="idm46122400037752" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="sci_fh" id="idm46122400036808" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="dv_ab" id="idm46122400035864" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="SciPy’s Sparse Matrices" class="calibre3"><div class="preface" id="SEC-sparse">
<h1 class="calibre25">SciPy’s Sparse Matrices</h1>

<p class="author1"><a data-type="indexterm" data-primary="RAM (random access memory)" data-secondary="sparse matrices" id="ram_sm" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="SciPy" id="scip_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="sparse matrices" id="sm_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>In <a data-type="xref" href="ch11_split_001.xhtml#dictvectorizer" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Introducing DictVectorizer and FeatureHasher”</a>, we created a large feature representation using
<code class="calibre26">DictVectorizer</code>, which uses a sparse matrix in the background. These sparse
matrices can be used for general computation as well and are extremely
useful when working with sparse data.</p>

<p class="author1">A <em class="hyperlink">sparse matrix</em> is a matrix in which most matrix elements are 0. For these sorts of
matrices, there are many ways to encode the nonzero values and then simply say
“all other values are zero.” In addition to these memory savings, many
algorithms have special ways of dealing with sparse matrices that give
additional computational 
<span class="publishername">benefits</span>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="o">&gt;&gt;&gt;</code> <code class="kn">from</code> <code class="nn">scipy</code> <code class="kn">import</code> <code class="n">sparse</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">A_sparse</code> <code class="o">=</code> <code class="n">sparse</code><code class="o">.</code><code class="n">random</code><code class="p">(</code><code class="mi">2048</code><code class="p">,</code> <code class="mi">2048</code><code class="p">,</code> <code class="mi">0.05</code><code class="p">)</code><code class="o">.</code><code class="n">tocsr</code><code class="p">()</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">A_sparse</code>
<code class="o">&lt;</code><code class="mi">2048</code><code class="n">x2048</code> <code class="n">sparse</code> <code class="n">matrix</code> <code class="n">of</code> <code class="nb">type</code> <code class="s">'&lt;class '</code><code class="n">numpy</code><code class="o">.</code><code class="n">float64</code><code class="s">'&gt;'</code>
        <code class="kn">with</code> <code class="mi">209715</code> <code class="n">stored</code> <code class="n">elements</code> <code class="ow">in</code> <code class="n">Compressed</code> <code class="n">Sparse</code> <code class="n">Row</code> <code class="n">format</code><code class="o">&gt;</code>
<code class="o">&gt;&gt;&gt;</code> <code class="o">%</code><code class="n">timeit</code> <code class="n">A_sparse</code> <code class="o">*</code> <code class="n">A_sparse</code>
<code class="mi">150</code> <code class="n">ms</code> <code class="err">±</code> <code class="mi">1.71</code> <code class="n">ms</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">10</code> <code class="n">loops</code> <code class="n">each</code><code class="p">)</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">A_dense</code> <code class="o">=</code> <code class="n">A_sparse</code><code class="o">.</code><code class="n">todense</code><code class="p">()</code>
<code class="o">&gt;&gt;&gt;</code> <code class="nb">type</code><code class="p">(</code><code class="n">A_dense</code><code class="p">)</code>
<code class="n">numpy</code><code class="o">.</code><code class="n">matrix</code>
<code class="o">&gt;&gt;&gt;</code> <code class="o">%</code><code class="n">timeit</code> <code class="n">A_dense</code> <code class="o">*</code> <code class="n">A_dense</code>
<code class="mi">571</code> <code class="n">ms</code> <code class="err">±</code> <code class="mi">14.5</code> <code class="n">ms</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">1</code> <code class="n">loop</code> <code class="n">each</code><code class="p">)</code></pre>

<p class="author1">The simplest implementation of this is for <code class="calibre26">COO</code> matrices in SciPy, where for each
non-zero element we store the value in addition to the location of the value.
This means that for each nonzero value, we store three numbers in total. As long as
our matrix has at least 66% zero entries, we are reducing the amount of memory
needed to represent the data as a sparse matrix as opposed to a standard <code class="calibre26">numpy</code>
array. However, <code class="calibre26">COO</code> matrices are generally used only to <em class="hyperlink">construct</em> sparse
matrices and not for doing actual computation (for that, <a href="https://oreil.ly/nHc3h" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">CSR/CSC</a> is preferred).</p>

<p class="author1">We can see in <a data-type="xref" href="ch11_split_001.xhtml#FIG-sparse" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Figure 11-5</a> that for low densities, sparse matrices are much
faster than their dense counterparts. On top of this, they also use much less
memory.</p>

<figure class="calibre46"><div id="FIG-sparse" class="figure">
<img src="Images/hpp2_1105.png" alt="Testing the runtime speed of sparse matrices vs dense matrices for various values for matrix density. Sparse matrix is created with `sparse = scipy.sparse.random(2024, 2024, density).tocsr()` and dense matrix is created with `dense = sparse.todense()`" class="calibre84"/>
<h6 class="calibre47"><span class="publishername">Figure 11-5. </span>Sparse versus dense matrix multiplication</h6>
</div></figure>

<p class="author1">In <a data-type="xref" href="ch11_split_001.xhtml#FIG-sparse-footprint" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Figure 11-6</a>, the dense matrix is always using 32.7 MB of
memory (2048 × 2048 × 64-bit).  However, a sparse matrix of 20% density uses
only 10 MB, representing a 70% savings! As the density of the sparse matrix goes
up, <code class="calibre26">numpy</code> quickly dominates in terms of speed because of the benefits of
vectorization and better cache performance.</p>

<figure class="calibre46"><div id="FIG-sparse-footprint" class="figure">
<img src="Images/hpp2_1106.png" alt="Footprint for 2048 x 2048 dense versus sparse matrices at different densities" class="calibre84"/>
<h6 class="calibre47"><span class="publishername">Figure 11-6. </span>Sparse versus dense memory footprint</h6>
</div></figure>

<p class="author1">This extreme reduction in memory use is partly why the speeds are so much
better. In addition to running only the multiplication operation for elements
that are nonzero (thus reducing the number of operations needed), we also don’t
need to allocate such a large amount of space to save our result in. This is the
push and pull of speedups with sparse arrays—it is a balance between losing
the use of efficient caching and vectorization versus not having to do a lot of
the calculations associated with the zero values of the matrix.</p>

<p class="author1">One operation that sparse matrices are particularly good at is cosine similarity. In
fact, when creating a <code class="calibre26">DictVectorizer</code>, as we did in <a data-type="xref" href="ch11_split_001.xhtml#dictvectorizer" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Introducing DictVectorizer and FeatureHasher”</a>, it’s common to
use cosine similarity to see how similar two pieces of text are. In
general for these item-to-item comparisons (where the value of a particular
matrix element is compared to another matrix element), sparse matrices do quite
well. Since the calls to <code class="calibre26">numpy</code> are the same whether we are using a normal matrix
or a sparse matrix, we can benchmark the benefits of using a sparse matrix
without changing the code of the algorithm.</p>

<p class="author1">While this is impressive, there are severe limitations. The amount of
support for sparse matrices is quite low, and unless you are running special
sparse algorithms or doing only basic operations, you’ll probably hit a wall in
terms of support. In 
<span class="publishername">addition</span>, SciPy’s <code class="calibre26">sparse</code> module offers multiple
implementations of sparse matrices, all of which have different
benefits and drawbacks. Understanding which is the best one to use and when to use it demands some expert
knowledge and often leads to conflicting requirements. As a result, sparse
matrices probably aren’t something you’ll be using often, but when they are the
correct tool, they are invaluable.<a data-type="indexterm" data-primary="" data-startref="ram_sm" id="idm46122399802696" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="scip_ab" id="idm46122399801720" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="sm_ab" id="idm46122399800776" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Tips for Using Less RAM" class="calibre3"><div class="preface" id="idm46122400034456">
<h1 class="calibre25">Tips for Using Less RAM</h1>

<p class="author1"><a data-type="indexterm" data-primary="RAM (random access memory)" data-secondary="tips for using less" id="idm46122399798424" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Generally, if you can avoid putting it into RAM, do. Everything you load costs you RAM. You might be able to load just a part of your data, for example, using a<a data-type="indexterm" data-primary="memory-mapped file" id="idm46122399797176" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <a href="https://oreil.ly/l7ekl" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">memory-mapped file</a>; alternatively, you might be able to use generators to load only the part of the data that you need for partial computations rather than loading it all at once.</p>

<p class="author1">If you are working with numeric data, you’ll almost
certainly want to switch to using<a data-type="indexterm" data-primary="numpy" data-secondary="arrays in" id="idm46122399795096" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">numpy</code> arrays—the package offers many fast
algorithms that work directly on the underlying primitive objects. The RAM
savings compared to using lists of numbers can be huge, and the time savings can
be similarly amazing. Furthermore, if you are dealing with very sparse arrays,
using SciPy’s sparse array functionality can save incredible amounts of memory,
albeit with a reduced feature set as compared to normal <code class="calibre26">numpy</code> arrays.</p>

<p class="author1">If you’re working with strings, stick to <code class="calibre26">str</code> rather than <code class="calibre26">bytes</code> unless you have strong reasons to work at the byte level. Dealing with a myriad set of text encodings is painful by hand, and UTF-8 (or other Unicode formats) tends to make these problems disappear. If you’re storing many <a data-type="indexterm" data-primary="Unicode objects" id="idm46122399790952" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Unicode objects in a static structure, you probably want to investigate the <a data-type="indexterm" data-primary="trie structures" id="idm46122399790120" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="DAWGs (directed acyclic word graphs)" id="idm46122399789448" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="directed acyclic word graphs (DAWGs)" id="idm46122399788808" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>DAWG and trie structures that we’ve just discussed.</p>

<p class="author1">If you’re working with lots of bit strings, investigate <code class="calibre26">numpy</code> and the<a data-type="indexterm" data-primary="bitarray module" id="idm46122399787256" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <a href="https://oreil.ly/Oz4-2" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"><code class="calibre26">bitarray</code></a> package; both have efficient representations of bits packed into bytes. You might also benefit from looking at<a data-type="indexterm" data-primary="Redis" id="idm46122399785320" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> Redis, which offers efficient storage of bit patterns.</p>

<p class="author1">The <a data-type="indexterm" data-primary="PyPy" data-secondary="CPython versus" id="idm46122399784072" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>PyPy project is experimenting with more efficient representations of homogeneous data structures, so long lists of the same primitive type (e.g., integers) might cost much less in PyPy than the equivalent structures in CPython. The <a data-type="indexterm" data-primary="Micro Python" id="idm46122399782680" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a href="http://micropython.org" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">MicroPython</a> project will be interesting to anyone working with embedded systems: this tiny-memory-footprint implementation of Python is aiming for Python 3 compatibility.</p>

<p class="author1">It goes (almost!) without saying that you know you have to benchmark when you’re trying to optimize on RAM usage, and that it pays handsomely to have a unit test suite in place before you make algorithmic changes.</p>

<p class="author1">Having reviewed ways of compressing strings and storing numbers efficiently, we’ll now look at trading accuracy for storage space.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Probabilistic Data Structures" class="calibre3"><div class="preface" id="less_ram_prob_ds">
<h1 class="calibre25">Probabilistic Data Structures</h1>

<p class="author1"><a data-type="indexterm" data-primary="RAM (random access memory)" data-secondary="probabilistic data structures" id="idm46122399778008" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="probabilistic data structures" data-secondary="about" id="idm46122399777048" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Probabilistic data structures allow you to make trade-offs in accuracy for immense
decreases in memory usage.  In addition, the number of operations you can do on
them is much more restricted than with a <code class="calibre26">set</code> or a trie.  For example, with a
single <span class="publishername">HyperLogLog++</span> structure using 2.56 KB, you can count the number of unique items
up to approximately 7,900,000,000 items with 1.625% error.</p>

<p class="author1">This means that if we’re trying
to count the number of unique license plate numbers for cars, and our
<a data-type="indexterm" data-primary="HyperLogLog" id="idm46122399773976" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>HyperLogLog++ counter said there were 654,192,028, we would be confident that
the actual number is between 643,561,407 and 664,822,648.  Furthermore, if
this accuracy isn’t sufficient, you can simply add more memory to the structure
and it will perform better.  Giving it 40.96 KB of resources will decrease the
error from 1.625% to 0.4%.  However, storing this data in a <code class="calibre26">set</code> would take 3.925 GB, even
assuming no overhead!</p>

<p class="author1">On the other hand, the HyperLogLog++ structure would only be able to count a <code class="calibre26">set</code>
of license plates and merge with another <code class="calibre26">set</code>.  So, for example, we could have
one structure for every state, find how many unique license plates are in each of those
states, and then merge them all to get a count for the whole country.  If we were
given a license plate, we couldn’t tell you with very good accuracy whether
we’ve seen it before, and we couldn’t give you a sample of license plates we have already
seen.</p>

<p class="author1">Probabilistic data structures are fantastic when you have taken the time to
understand the problem and need to put something into production that can
answer a very small set of questions about a very large set of data.  Each
structure has different questions it can answer at different accuracies,
so finding the right one is just a matter of understanding your requirements.</p>
<div data-type="warning" epub:type="warning" class="calibre37"><h6 class="calibre38">Warning</h6>
<p class="author1">Much of this section goes into a deep dive into the mechanisms that power many
of the popular probabilistic data structures. This is useful, because once you
understand the mechanisms, you can use parts of them in algorithms you are
designing. If you are just beginning with probabilistic data structures, it may
be useful to first look at the real-world example (<a data-type="xref" href="ch11_split_001.xhtml#pds_example" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Real-World Example”</a>) before
diving into the internals.</p>
</div>

<p class="author1">In almost all cases, probabilistic data structures work by finding an alternative
representation for the data that is more compact and contains the relevant
information for answering a certain set of questions.  This can be thought of as
a type of lossy <span class="publishername">compression</span>, where we may lose some aspects of the data but we
retain the necessary components.  Since we are allowing the loss of data that
isn’t necessarily relevant for the particular set of questions we care about,
this sort of lossy compression can be much more efficient than the lossless
compression we looked at before with tries.  It is because of this that the
choice of which probabilistic data structure you will use is quite important—you want to pick one that retains the right information for your use case!</p>

<p class="author1">Before we dive in, it should be made clear that all the<a data-type="indexterm" data-primary="error rates" id="idm46122399764936" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> “error rates” here are
defined in terms of<a data-type="indexterm" data-primary="standard deviation" id="idm46122399764040" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <em class="hyperlink">standard deviations</em>.  This term comes from describing
<a data-type="indexterm" data-primary="Gaussian Distribution" id="idm46122399762824" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Gaussian distributions and says how spread out the function is around a center
value.  When the standard deviation grows, so do the number of values further away from the
center point.  Error rates for probabilistic data structures are framed this way
because all the analyses around them are probabilistic.  So, for example, when we
say that the <span class="publishername">HyperLogLog++</span> algorithm has an error of
<math alttext="e r r equals StartFraction 1.04 Over StartRoot m EndRoot EndFraction">
  <mrow>
    <mi>e</mi>
    <mi>r</mi>
    <mi>r</mi>
    <mo>=</mo>
    <mfrac><mrow><mn>1</mn><mo>.</mo><mn>04</mn></mrow> <msqrt><mi>m</mi></msqrt></mfrac>
  </mrow>
</math>, we mean that 68% of the time the error
will be smaller than <em class="hyperlink">err</em>, 95% of the time it will be smaller than 2 × <em class="hyperlink">err</em>, and 99.7% of
the time it will be smaller than 3 × <em class="hyperlink">err</em>.<sup class="calibre44"><a data-type="noteref" id="idm46122399754392-marker" href="ch11_split_001.xhtml#idm46122399754392" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">2</a></sup></p>








<section data-type="sect2" data-pdf-bookmark="Very Approximate Counting with a 1-Byte Morris Counter" class="calibre3"><div class="preface" id="idm46122399752984">
<h2 class="calibre43">Very Approximate Counting with a 1-Byte Morris Counter</h2>

<p class="author1"><a data-type="indexterm" data-primary="Morris counter" data-seealso="probabilistic data structures" id="mc_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="probabilistic data structures" data-secondary="Morris counter" id="pds_mc" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>We’ll introduce the topic of probabilistic counting with one of the earliest
probabilistic counters, the Morris counter<a data-type="indexterm" data-primary="Morris, Robert" id="idm46122399748648" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> (by Robert Morris of the NSA and Bell
Labs). Applications include counting millions of objects in a restricted-RAM
environment (e.g., on an embedded computer), understanding large data streams, and
working on problems in AI like image and speech recognition.</p>

<p class="author1">The Morris counter keeps track of an exponent and models the counted state as
<math alttext="2 Superscript e x p o n e n t">
  <msup><mn>2</mn> <mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow> </msup>
</math> (rather than a correct count)—it provides an
<a data-type="indexterm" data-primary="order of magnitude estimate" id="idm46122399742856" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><em class="hyperlink">order of magnitude</em> estimate. This estimate is updated using a probabilistic
rule.</p>

<p class="author1">We start with the exponent set to 0. If we ask for the <em class="hyperlink">value</em> of the counter,
we’ll be given <code class="calibre26">pow(2,<em class="calibre66">exponent</em>)=1</code> (the keen reader will note that this is
off by one—we did say this was an <em class="hyperlink">approximate</em> counter!). If we ask the
counter to increment itself, it will generate a random number (using the uniform
distribution), and it will test if <code class="calibre26">random.uniform(0, 1)</code> <code class="calibre26">&lt;=</code> <code class="calibre26">1/pow(2,<em class="calibre66">exponent</em>)</code>, which will
always be true (<code class="calibre26">pow(2,0) == 1</code>). The counter increments, and the exponent is set
to 1.</p>

<p class="author1">The second time we ask the counter to increment itself, it will test if <code class="calibre26">random.uniform(0, 1) &lt;= 1/pow(2,1)</code>. This will be true 50% of the time. If the test passes, the exponent is incremented. If not, the exponent is not
incremented for this increment request.</p>

<p class="author1"><a data-type="xref" href="ch11_split_001.xhtml#table_morris_counter" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Table 11-1</a> shows the likelihoods of an increment occurring for each of the first <span class="publishername">exponents</span>.</p>
<table id="table_morris_counter" class="stafflist_table">
<caption class="calibre85"><span class="publishername">Table 11-1. </span>Morris counter details</caption>
<thead class="calibre87">
<tr class="calibre88">
<th class="calibre89">Exponent</th>
<th class="calibre89">pow(2,<em class="hyperlink">exponent</em>)</th>
<th class="calibre89">P(<em class="hyperlink">increment</em>)</th>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre15">
<td class="calibre16"><p class="calibre17">0</p></td>
<td class="calibre16"><p class="calibre17">1</p></td>
<td class="calibre16"><p class="calibre17">1</p></td>
</tr>
<tr class="calibre18">
<td class="calibre16"><p class="calibre17">1</p></td>
<td class="calibre16"><p class="calibre17">2</p></td>
<td class="calibre16"><p class="calibre17">0.5</p></td>
</tr>
<tr class="calibre15">
<td class="calibre16"><p class="calibre17">2</p></td>
<td class="calibre16"><p class="calibre17">4</p></td>
<td class="calibre16"><p class="calibre17">0.25</p></td>
</tr>
<tr class="calibre18">
<td class="calibre16"><p class="calibre17">3</p></td>
<td class="calibre16"><p class="calibre17">8</p></td>
<td class="calibre16"><p class="calibre17">0.125</p></td>
</tr>
<tr class="calibre15">
<td class="calibre16"><p class="calibre17">4</p></td>
<td class="calibre16"><p class="calibre17">16</p></td>
<td class="calibre16"><p class="calibre17">0.0625</p></td>
</tr>
<tr class="calibre18">
<td class="calibre16"><p class="calibre17">…</p></td>
<td class="calibre16"><p class="calibre17">…</p></td>
<td class="calibre16"><p class="calibre17">…</p></td>
</tr>
<tr class="calibre19">
<td class="calibre16"><p class="calibre17">254</p></td>
<td class="calibre16"><p class="calibre17">2.894802e+76</p></td>
<td class="calibre16"><p class="calibre17">3.454467e-77</p></td>
</tr>
</tbody>
</table>

<p class="author1">The maximum we could approximately count where we use a single unsigned byte for
the exponent is <code class="calibre26">math.pow(2,255) == 5e76</code>. The error relative to the actual
count will be fairly large as the counts increase, but the RAM savings is
tremendous, as we use only 1 byte rather than the 32 unsigned bytes we’d
otherwise have to use. <a data-type="xref" href="ch11_split_001.xhtml#memory_morris_example_code" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-26</a>  shows a simple implementation of the Morris counter.</p>
<div id="memory_morris_example_code" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-26. </span>Simple Morris counter implementation</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="sd">"""Approximate Morris counter supporting many counters"""</code>
<code class="kn">import</code> <code class="nn">math</code>
<code class="kn">import</code> <code class="nn">random</code>
<code class="kn">import</code> <code class="nn">array</code>

<code class="n">SMALLEST_UNSIGNED_INTEGER</code> <code class="o">=</code> <code class="s">'B'</code> <code class="c"># unsigned char, typically 1 byte</code>


<code class="kn">class</code> <code class="nc">MorrisCounter</code><code class="p">(</code><code class="nb">object</code><code class="p">):</code>
    <code class="sd">"""Approximate counter, stores exponent and counts approximately 2^exponent</code>

<code class="sd">    https://en.wikipedia.org/wiki/Approximate_counting_algorithm"""</code>
    <code class="kn">def</code> <code class="calibre26">__init__</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">type_code</code><code class="o">=</code><code class="n">SMALLEST_UNSIGNED_INTEGER</code><code class="p">,</code> <code class="n">nbr_counters</code><code class="o">=</code><code class="mi">1</code><code class="p">):</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">exponents</code> <code class="o">=</code> <code class="n">array</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="n">type_code</code><code class="p">,</code> <code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">*</code> <code class="n">nbr_counters</code><code class="p">)</code>

    <code class="kn">def</code> <code class="calibre26">__len__</code><code class="p">(</code><code class="nb">self</code><code class="p">):</code>
        <code class="kn">return</code> <code class="nb">len</code><code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">exponents</code><code class="p">)</code>

    <code class="kn">def</code> <code class="nf">add_counter</code><code class="p">(</code><code class="nb">self</code><code class="p">):</code>
        <code class="sd">"""Add a new zeroed counter"""</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">exponents</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>

    <code class="kn">def</code> <code class="nf">get</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">counter</code><code class="o">=</code><code class="mi">0</code><code class="p">):</code>
        <code class="sd">"""Calculate approximate value represented by counter"""</code>
        <code class="kn">return</code> <code class="n">math</code><code class="o">.</code><code class="n">pow</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="nb">self</code><code class="o">.</code><code class="n">exponents</code><code class="p">[</code><code class="n">counter</code><code class="p">])</code>

    <code class="kn">def</code> <code class="nf">add</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">counter</code><code class="o">=</code><code class="mi">0</code><code class="p">):</code>
        <code class="sd">"""Probabilistically add 1 to counter"""</code>
        <code class="n">value</code> <code class="o">=</code> <code class="nb">self</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="n">counter</code><code class="p">)</code>
        <code class="n">probability</code> <code class="o">=</code> <code class="mi">1.0</code> <code class="o">/</code> <code class="n">value</code>
        <code class="kn">if</code> <code class="n">random</code><code class="o">.</code><code class="n">uniform</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code> <code class="o">&lt;</code> <code class="n">probability</code><code class="p">:</code>
            <code class="nb">self</code><code class="o">.</code><code class="n">exponents</code><code class="p">[</code><code class="n">counter</code><code class="p">]</code> <code class="o">+=</code> <code class="mi">1</code>

<code class="kn">if</code> <code class="calibre26">__name__</code> <code class="o">==</code> <code class="s">"__main__"</code><code class="p">:</code>
    <code class="n">mc</code> <code class="o">=</code> <code class="n">MorrisCounter</code><code class="p">()</code>
    <code class="kn">print</code><code class="p">(</code><code class="s">"MorrisCounter has {} counters"</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">mc</code><code class="p">)))</code>
    <code class="kn">for</code> <code class="n">n</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">10</code><code class="p">):</code>
        <code class="kn">print</code><code class="p">(</code><code class="s">"Iteration </code><code class="err">%d</code><code class="s">, MorrisCounter has: </code><code class="err">%d</code><code class="s">"</code> <code class="o">%</code> <code class="p">(</code><code class="n">n</code><code class="p">,</code> <code class="n">mc</code><code class="o">.</code><code class="n">get</code><code class="p">()))</code>
        <code class="n">mc</code><code class="o">.</code><code class="n">add</code><code class="p">()</code>

    <code class="kn">for</code> <code class="n">n</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">990</code><code class="p">):</code>
        <code class="n">mc</code><code class="o">.</code><code class="n">add</code><code class="p">()</code>
    <code class="kn">print</code><code class="p">(</code><code class="s">"Iteration 1000, MorrisCounter has: </code><code class="err">%d</code><code class="s">"</code> <code class="o">%</code> <code class="p">(</code><code class="n">mc</code><code class="o">.</code><code class="n">get</code><code class="p">()))</code></pre></div>

<p class="author1">Using this implementation, we can see
in <a data-type="xref" href="ch11_split_001.xhtml#morris_counter_example" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-27</a> that the first request to increment the counter succeeds, the second succeeds, and the third doesn’t.<sup class="calibre44"><a data-type="noteref" id="idm46122399671816-marker" href="ch11_split_001.xhtml#idm46122399671816" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">3</a></sup></p>
<div id="morris_counter_example" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-27. </span>Morris counter library example</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="o">&gt;&gt;&gt;</code> <code class="n">mc</code> <code class="o">=</code> <code class="n">MorrisCounter</code><code class="p">()</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">mc</code><code class="o">.</code><code class="n">get</code><code class="p">()</code>
<code class="mi">1.0</code>

<code class="o">&gt;&gt;&gt;</code> <code class="n">mc</code><code class="o">.</code><code class="n">add</code><code class="p">()</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">mc</code><code class="o">.</code><code class="n">get</code><code class="p">()</code>
<code class="mi">2.0</code>

<code class="o">&gt;&gt;&gt;</code> <code class="n">mc</code><code class="o">.</code><code class="n">add</code><code class="p">()</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">mc</code><code class="o">.</code><code class="n">get</code><code class="p">()</code>
<code class="mi">4.0</code>

<code class="o">&gt;&gt;&gt;</code> <code class="n">mc</code><code class="o">.</code><code class="n">add</code><code class="p">()</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">mc</code><code class="o">.</code><code class="n">get</code><code class="p">()</code>
<code class="mi">4.0</code></pre></div>

<p class="author1">In <a data-type="xref" href="ch11_split_001.xhtml#FIG-morris-counter" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Figure 11-7</a>, the thick black line shows a normal integer
incrementing on each iteration. On a 64-bit computer, this is an 8-byte integer.
The evolution of three 1-byte Morris counters is shown as dotted lines; the y-axis shows their values, which approximately represent the true count for each
iteration. Three counters are shown to give you an idea about their different
trajectories and the overall trend; the three counters are entirely independent
of one another.</p>

<figure class="calibre46"><div id="FIG-morris-counter" class="figure">
<img src="Images/hpp2_1107.png" alt="Three 1-byte Morris Counters" class="calibre118"/>
<h6 class="calibre47"><span class="publishername">Figure 11-7. </span>Three 1-byte Morris counters versus an 8-byte integer</h6>
</div></figure>

<p class="author1">This diagram gives you some idea about the error to expect when using a Morris
counter. Further details about the error behavior are available<a data-type="indexterm" data-primary="" data-startref="mc_ab" id="idm46122399329352" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="pds_mc" id="idm46122399328376" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <a href="http://bit.ly/Morris_error" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">online</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="K-Minimum Values" class="calibre3"><div class="preface" id="idm46122399752360">
<h2 class="calibre43">K-Minimum Values</h2>

<p class="author1"><a data-type="indexterm" data-primary="algorithms" id="alg_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="hash functions" data-secondary="properties of" id="hf_prop" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="K-Minimum Values algorithm" data-seealso="probabilistic data structures" id="kmin_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="probabilistic data structures" data-secondary="K-Minimum Values algorithm" id="pds_kmin" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>In the Morris counter, we lose any sort of information about the items we
insert.  That is to say, the counter’s internal state is the same whether we do
<code class="calibre26">.add("micha")</code> or <code class="calibre26">.add("ian")</code>.  This extra information is useful and, if used
properly, could help us have our counters count only unique items.  In this
way, calling <code class="calibre26">.add("micha")</code> thousands of times would increase the counter only
once.</p>

<p class="author1">To implement this behavior, we will exploit properties of hashing functions (see
<a data-type="xref" href="ch04.xhtml#SEC-dict-set-hash-and-entropy" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Hash Functions and Entropy”</a> for a more in-depth discussion of hash
functions).  The main property we would like to take advantage of is the fact
that the hash function takes input and <em class="hyperlink">uniformly</em> distributes it.  For example,
let’s assume we have a hash function that takes in a string and outputs a number
between 0 and 1.  For that function to be uniform means that when we feed it in a
string, we are equally likely to get a value of 0.5 as a value of 0.2
or any other value.  This also means that if we feed it in many string values, we
would expect the values to be relatively evenly spaced.  Remember, this is a
probabilistic argument: the values won’t always be evenly spaced, but if we have many strings and try this experiment many times, they will tend to be
evenly spaced.</p>

<p class="author1">Suppose we took 100 items and stored the hashes of those values (the hashes being numbers from 0 to 1).
Knowing the spacing is even means that instead of saying, “We have 100 items,” we
could say, “We have a distance of 0.01 between every item.”  This is
where the K-Minimum Values algorithm finally comes in<sup class="calibre44"><a data-type="noteref" id="idm46122399315416-marker" href="ch11_split_001.xhtml#idm46122399315416" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">4</a></sup>--if we keep the <code class="calibre26">k</code> smallest unique hash values we have
seen, we can approximate the overall spacing between hash values and infer
the total number of items. In <a data-type="xref" href="ch11_split_001.xhtml#FIG-kmv-hash-density" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Figure 11-8</a>, we can see the state
of a K-Minimum Values structure (also called a KMV) as more and more items are
added.  At first, since we don’t have many hash values, the largest hash we have
kept is quite large.  As we add more and more, the largest of the <code class="calibre26">k</code> hash
values we have kept gets smaller and smaller.  Using this method, we can
get error rates of <math alttext="upper O left-parenthesis StartRoot StartFraction 2 Over pi left-parenthesis k minus 2 right-parenthesis EndFraction EndRoot right-parenthesis">
  <mrow>
    <mi>O</mi>
    <mo>(</mo>
    <msqrt>
      <mfrac><mn>2</mn> <mrow><mi>π</mi><mo>(</mo><mi>k</mi><mo>-</mo><mn>2</mn><mo>)</mo></mrow></mfrac>
    </msqrt>
    <mo>)</mo>
  </mrow>
</math>.</p>

<p class="author1">The larger <code class="calibre26">k</code> is, the more we can account for the hashing function we are using
not being completely uniform for our particular input and for unfortunate hash
values.  An example of unfortunate hash values would be hashing  <code class="calibre26">['A', 'B', 'C']</code> and
getting the values <code class="calibre26">[0.01, 0.02, 0.03]</code>.  If we start hashing more and more values,
it is less and less probable that they will clump up.</p>

<p class="author1">Furthermore, since we are keeping only the smallest <em class="hyperlink">unique</em> hash values, the data
structure considers only unique inputs.  We can see this easily because if we
are in a state where we store only the smallest three hashes and currently
<code class="calibre26">[0.1, 0.2, 0.3]</code> are the smallest hash values, then if we add in something
with the hash value of <code class="calibre26">0.4</code>, our state also will not change.  Similarly, if we add more items with a hash value of <code class="calibre26">0.3</code>, our state will also not change.  This is a property called
<em class="hyperlink">idempotence</em>; it means that if we do the same operation, with the same inputs, on
this structure multiple times, the state will not be changed.  This is in
contrast to, for example, an <code class="calibre26">append</code> on a <code class="calibre26">list</code>, which will always change its
value.  This concept of idempotence carries on to all of the data structures in
this section except for the Morris counter.</p>

<p class="author1"><a data-type="xref" href="ch11_split_001.xhtml#memory_simple_kmv" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-28</a> shows a very basic K-Minimum Values implementation. Of note is our use of a <code class="calibre26">sortedset</code>, which, like a set, can contain only unique items. This uniqueness gives our <code class="calibre26">KMinValues</code> structure idempotence for free. To see this, follow the code through: when the same item is added more than once, the <code class="calibre26">data</code> property does not change.</p>

<figure class="calibre46"><div id="FIG-kmv-hash-density" class="figure">
<img src="Images/hpp2_1108.png" alt="Density of hash space for K-Min Value structures" class="calibre119"/>
<h6 class="calibre47"><span class="publishername">Figure 11-8. </span>The value stores in a KMV structure as more elements are added</h6>
</div></figure>
<div id="memory_simple_kmv" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-28. </span>Simple <code class="calibre26">KMinValues</code> implementation</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">import</code> <code class="nn">mmh3</code>
<code class="kn">from</code> <code class="nn">blist</code> <code class="kn">import</code> <code class="n">sortedset</code>


<code class="kn">class</code> <code class="nc">KMinValues</code><code class="p">:</code>
    <code class="kn">def</code> <code class="calibre26">__init__</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">num_hashes</code><code class="p">):</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">num_hashes</code> <code class="o">=</code> <code class="n">num_hashes</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">data</code> <code class="o">=</code> <code class="n">sortedset</code><code class="p">()</code>

    <code class="kn">def</code> <code class="nf">add</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">item</code><code class="p">):</code>
        <code class="n">item_hash</code> <code class="o">=</code> <code class="n">mmh3</code><code class="o">.</code><code class="n">hash</code><code class="p">(</code><code class="n">item</code><code class="p">)</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">data</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">item_hash</code><code class="p">)</code>
        <code class="kn">if</code> <code class="nb">len</code><code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">data</code><code class="p">)</code> <code class="o">&gt;</code> <code class="nb">self</code><code class="o">.</code><code class="n">num_hashes</code><code class="p">:</code>
            <code class="nb">self</code><code class="o">.</code><code class="n">data</code><code class="o">.</code><code class="n">pop</code><code class="p">()</code>

    <code class="kn">def</code> <code class="calibre26">__len__</code><code class="p">(</code><code class="nb">self</code><code class="p">):</code>
        <code class="kn">if</code> <code class="nb">len</code><code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">data</code><code class="p">)</code> <code class="o">&lt;=</code> <code class="mi">2</code><code class="p">:</code>
            <code class="kn">return</code> <code class="mi">0</code>
        <code class="n">length</code> <code class="o">=</code> <code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">num_hashes</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code> <code class="o">*</code> <code class="p">(</code><code class="mi">2</code> <code class="o">**</code> <code class="mi">32</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code> <code class="o">/</code>
                 <code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">data</code><code class="p">[</code><code class="o">-</code><code class="mi">2</code><code class="p">]</code> <code class="o">+</code> <code class="mi">2</code> <code class="o">**</code> <code class="mi">31</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code>
        <code class="kn">return</code> <code class="nb">int</code><code class="p">(</code><code class="n">length</code><code class="p">)</code></pre></div>

<p class="author1">Using the <code class="calibre26">KMinValues</code> implementation in the Python package <a href="https://oreil.ly/YF6uO" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"><code class="calibre26">countmemaybe</code></a> (<a data-type="xref" href="ch11_split_001.xhtml#countmemaybe_kminvalues_implementation" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-29</a>), we can begin to see the
utility of this data structure.  This implementation is very similar to the one
in <a data-type="xref" href="ch11_split_001.xhtml#memory_simple_kmv" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-28</a>, but it fully implements the other set
operations, such as union and intersection.  Also note that “size” and
“cardinality” are used interchangeably (the word “cardinality” is from set
theory and is used more in the analysis of probabilistic data structures). Here, we can see that even with a reasonably small value for <code class="calibre26">k</code>, we can store 50,000 items and calculate the cardinality of many set operations with relatively low error.</p>
<div id="countmemaybe_kminvalues_implementation" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-29. </span><code class="calibre26">countmemaybe</code> <code class="calibre26">KMinValues</code> implementation</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="kn">from</code><code class="calibre26"> </code><code class="nn">countmemaybe</code><code class="calibre26"> </code><code class="kn">import</code><code class="calibre26"> </code><code class="n">KMinValues</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="n">kmv1</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="n">KMinValues</code><code class="p">(</code><code class="n">k</code><code class="o">=</code><code class="mi">1024</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="n">kmv2</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="n">KMinValues</code><code class="p">(</code><code class="n">k</code><code class="o">=</code><code class="mi">1024</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="kn">for</code><code class="calibre26"> </code><code class="n">i</code><code class="calibre26"> </code><code class="ow">in</code><code class="calibre26"> </code><code class="nb">range</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">50000</code><code class="p">)</code><code class="p">:</code><code class="calibre26"> </code><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="co_using_less_ram_CO1-1" href="ch11_split_001.xhtml#callout_using_less_ram_CO1-1"><img src="Images/1.png" alt="1" class="calibre74"/></a><code class="calibre26">
</code><code class="calibre26">    </code><code class="n">kmv1</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="nb">str</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">   </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="kn">for</code><code class="calibre26"> </code><code class="n">i</code><code class="calibre26"> </code><code class="ow">in</code><code class="calibre26"> </code><code class="nb">range</code><code class="p">(</code><code class="mi">25000</code><code class="p">,</code><code class="calibre26"> </code><code class="mi">75000</code><code class="p">)</code><code class="p">:</code><code class="calibre26"> </code><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="co_using_less_ram_CO1-2" href="ch11_split_001.xhtml#callout_using_less_ram_CO1-2"><img src="Images/2.png" alt="2" class="calibre74"/></a><code class="calibre26">
</code><code class="calibre26">    </code><code class="n">kmv2</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="nb">str</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">   </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="kn">print</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">kmv1</code><code class="p">)</code><code class="p">)</code><code class="calibre26">
</code><code class="mi">50416</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="kn">print</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">kmv2</code><code class="p">)</code><code class="p">)</code><code class="calibre26">
</code><code class="mi">52439</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="kn">print</code><code class="p">(</code><code class="n">kmv1</code><code class="o">.</code><code class="n">cardinality_intersection</code><code class="p">(</code><code class="n">kmv2</code><code class="p">)</code><code class="p">)</code><code class="calibre26">
</code><code class="mi">25900.2862992</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="kn">print</code><code class="p">(</code><code class="n">kmv1</code><code class="o">.</code><code class="n">cardinality_union</code><code class="p">(</code><code class="n">kmv2</code><code class="p">)</code><code class="p">)</code><code class="calibre26">
</code><code class="mi">75346.2874158</code></pre></div>
<dl class="calibre28">
<dt class="calibre29"><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="callout_using_less_ram_CO1-1" href="ch11_split_001.xhtml#co_using_less_ram_CO1-1"><img src="Images/1.png" alt="1" class="calibre74"/></a></dt>
<dd class="calibre75"><p class="calibre76">We put 50,000 elements into <code class="calibre26">kmv1</code>.</p></dd>
<dt class="calibre29"><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="callout_using_less_ram_CO1-2" href="ch11_split_001.xhtml#co_using_less_ram_CO1-2"><img src="Images/2.png" alt="2" class="calibre74"/></a></dt>
<dd class="calibre75"><p class="calibre76"><code class="calibre26">kmv2</code> also gets 50,000 elements, 25,000 of which are also in <code class="calibre26">kmv1</code>.</p></dd>
</dl>
<div data-type="note" epub:type="note" class="calibre35"><h6 class="calibre36">Note</h6>
<p class="author1">With these sorts of algorithms, the choice of hash function can have a drastic
effect on the quality of the estimates.  Both of these implementations use
<a href="https://pypi.org/project/mmh3" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"><code class="calibre26">mmh3</code></a>, a Python
implementation of <code class="calibre26">murmurhash3</code> that has nice properties for hashing strings.
However, different hash functions could be used if they are more convenient for
your particular dataset.<a data-type="indexterm" data-primary="" data-startref="alg_ab" id="idm46122398892232" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="hf_prop" id="idm46122398891256" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="kmin_ab" id="idm46122398890312" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="pds_kmin" id="idm46122398889368" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Bloom Filters" class="calibre3"><div class="preface" id="idm46122399326184">
<h2 class="calibre43">Bloom Filters</h2>

<p class="author1"><a data-type="indexterm" data-primary="Bloom filters" data-seealso="probabilistic data structures" id="bf_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="probabilistic data structures" data-secondary="Bloom filters" id="pds_bf" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Sometimes we need to be able to do other types of set operations, for which we
need to introduce new types of probabilistic data structures.  <em class="hyperlink">Bloom filters</em> were
created to answer the question of whether we’ve seen an item before.<sup class="calibre44"><a data-type="noteref" id="idm46122398960952-marker" href="ch11_split_001.xhtml#idm46122398960952" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">5</a></sup></p>

<p class="author1">Bloom filters work by having multiple hash values in order to represent a value
as multiple integers.  If we later see something with the same set of integers,
we can be reasonably confident that it is the same value.</p>

<p class="author1">To do this in a way that efficiently utilizes available resources, we
implicitly encode the integers as the indices of a list.  This could be thought
of as a list of <code class="calibre26">bool</code> values that are initially set to <code class="calibre26">False</code>. If we are asked
to add an object with hash values <code class="calibre26">[10, 4, 7]</code>, we set the tenth, fourth, and
seventh indices of the list to <code class="calibre26">True</code>.  In the future, if we are asked if we have
seen a particular item before, we simply find its hash values and check if all
the corresponding spots in the <code class="calibre26">bool</code> list are set to <code class="calibre26">True</code>.</p>

<p class="author1">This method gives us no false negatives and a controllable rate of false
positives. If the Bloom filter says we have not seen an
item before, we can be 100% sure that we haven’t seen the item before.  On
the other hand, if the Bloom filter states that we <em class="hyperlink">have</em> seen an item before,
there is a probability that we actually have not and we are simply seeing an
erroneous result.  This erroneous result comes from the fact that we will have
hash collisions, and sometimes the hash values for two objects will be the same
even if the objects themselves are not the same.  However, in practice Bloom
filters are set to have error rates below 0.5%, so this error can be acceptable.</p>
<div data-type="note" epub:type="note" class="calibre35"><h6 class="calibre36">Note</h6>
<p class="author1">We can simulate having as many hash functions as we want simply by having two hash
functions that are independent of each other.  This method is called<a data-type="indexterm" data-primary="double hashing" id="idm46122398881560" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <em class="hyperlink">double
hashing</em>. If  we have a hash function that gives us two independent hashes, we can
do this:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre120"><code class="kn">def</code> <code class="nf">multi_hash</code><code class="p">(</code><code class="n">key</code><code class="p">,</code> <code class="n">num_hashes</code><code class="p">):</code>
    <code class="n">hash1</code><code class="p">,</code> <code class="n">hash2</code> <code class="o">=</code> <code class="n">hashfunction</code><code class="p">(</code><code class="n">key</code><code class="p">)</code>
    <code class="kn">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="n">num_hashes</code><code class="p">):</code>
        <code class="kn">yield</code> <code class="p">(</code><code class="n">hash1</code> <code class="o">+</code> <code class="n">i</code> <code class="o">*</code> <code class="n">hash2</code><code class="p">)</code> <code class="o">%</code> <code class="p">(</code><code class="mi">2</code><code class="o">^</code><code class="mi">32</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code></pre>

<p class="author1">The modulo ensures that the resulting hash values are 32-bit (we would modulo by
<code class="calibre26">2^64 - 1</code> for 64-bit hash functions).</p>
</div>

<p class="author1">The exact length of the <code class="calibre26">bool</code> list and the number of hash values per item we
need will be fixed based on the capacity and the error rate we require.  With
some reasonably simple statistical arguments,<sup class="calibre44"><a data-type="noteref" id="idm46122398840536-marker" href="ch11_split_001.xhtml#idm46122398840536" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">6</a></sup> we see
that the ideal values are as follows:</p>
<div data-type="equation" class="calibre56">
<math display="block" alttext="n u m normal bar b i t s equals minus c a p a c i t y dot StartFraction l o g left-parenthesis e r r o r right-parenthesis Over l o g left-parenthesis 2 right-parenthesis squared EndFraction">
  <mrow>
    <mi>n</mi>
    <mi>u</mi>
    <mi>m</mi>
    <mo>_</mo>
    <mi>b</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>s</mi>
    <mo>=</mo>
    <mo>–</mo>
    <mi>c</mi>
    <mi>a</mi>
    <mi>p</mi>
    <mi>a</mi>
    <mi>c</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>y</mi>
    <mo>×</mo>
    <mfrac><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>e</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>r</mi><mo>)</mo></mrow> <mrow><mi>l</mi><mi>o</mi><mi>g</mi><msup><mrow><mo>(</mo><mn>2</mn><mo>)</mo></mrow> <mn>2</mn> </msup></mrow></mfrac>
  </mrow>
</math>
</div>
<div data-type="equation" class="calibre56">
<math display="block" alttext="n u m normal bar h a s h e s equals n u m normal bar b i t s dot StartFraction l o g left-parenthesis 2 right-parenthesis Over c a p a c i t y EndFraction">
  <mrow>
    <mi>n</mi>
    <mi>u</mi>
    <mi>m</mi>
    <mo>_</mo>
    <mi>h</mi>
    <mi>a</mi>
    <mi>s</mi>
    <mi>h</mi>
    <mi>e</mi>
    <mi>s</mi>
    <mo>=</mo>
    <mi>n</mi>
    <mi>u</mi>
    <mi>m</mi>
    <mo>_</mo>
    <mi>b</mi>
    <mi>i</mi>
    <mi>t</mi>
    <mi>s</mi>
    <mo>×</mo>
    <mfrac><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow> <mrow><mi>c</mi><mi>a</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi></mrow></mfrac>
  </mrow>
</math>
</div>

<p class="author1">If we wish to store 50,000 objects (no matter how big the
objects themselves are) at a false positive rate of 0.05% (that is to say, 0.05%
of the times we say we have seen an object before, we actually have not), it
would require 791,015 bits of storage and 11 hash functions.</p>

<p class="author1">To further improve our efficiency in terms of memory use, we can use single bits
to represent the <code class="calibre26">bool</code> values (a native <code class="calibre26">bool</code> actually takes 4 bits).  We
can do this easily by using the <a data-type="indexterm" data-primary="bitarray module" id="idm46122398800904" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">bitarray</code> module. <a data-type="xref" href="ch11_split_001.xhtml#simple_bloom_filter_implemintation" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-30</a> shows a simple Bloom filter <span class="publishername">implementation</span>.</p>
<div id="simple_bloom_filter_implemintation" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-30. </span>Simple Bloom filter implementation</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">import</code> <code class="nn">math</code>

<code class="kn">import</code> <code class="nn">bitarray</code>
<code class="kn">import</code> <code class="nn">mmh3</code>


<code class="kn">class</code> <code class="nc">BloomFilter</code><code class="p">:</code>
    <code class="kn">def</code> <code class="calibre26">__init__</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">capacity</code><code class="p">,</code> <code class="n">error</code><code class="o">=</code><code class="mi">0.005</code><code class="p">):</code>
        <code class="sd">"""</code>
<code class="sd">        Initialize a Bloom filter with given capacity and false positive rate</code>
<code class="sd">        """</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">capacity</code> <code class="o">=</code> <code class="n">capacity</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">error</code> <code class="o">=</code> <code class="n">error</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">num_bits</code> <code class="o">=</code> <code class="nb">int</code><code class="p">((</code><code class="o">-</code><code class="n">capacity</code> <code class="o">*</code> <code class="n">math</code><code class="o">.</code><code class="n">log</code><code class="p">(</code><code class="n">error</code><code class="p">))</code> <code class="o">//</code> <code class="n">math</code><code class="o">.</code><code class="n">log</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code> <code class="o">**</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">num_hashes</code> <code class="o">=</code> <code class="nb">int</code><code class="p">((</code><code class="nb">self</code><code class="o">.</code><code class="n">num_bits</code> <code class="o">*</code> <code class="n">math</code><code class="o">.</code><code class="n">log</code><code class="p">(</code><code class="mi">2</code><code class="p">))</code> <code class="o">//</code> <code class="n">capacity</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">data</code> <code class="o">=</code> <code class="n">bitarray</code><code class="o">.</code><code class="n">bitarray</code><code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">num_bits</code><code class="p">)</code>

    <code class="kn">def</code> <code class="nf">_indexes</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">key</code><code class="p">):</code>
        <code class="n">h1</code><code class="p">,</code> <code class="n">h2</code> <code class="o">=</code> <code class="n">mmh3</code><code class="o">.</code><code class="n">hash64</code><code class="p">(</code><code class="n">key</code><code class="p">)</code>
        <code class="kn">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">num_hashes</code><code class="p">):</code>
            <code class="kn">yield</code> <code class="p">(</code><code class="n">h1</code> <code class="o">+</code> <code class="n">i</code> <code class="o">*</code> <code class="n">h2</code><code class="p">)</code> <code class="o">%</code> <code class="nb">self</code><code class="o">.</code><code class="n">num_bits</code>

    <code class="kn">def</code> <code class="nf">add</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">key</code><code class="p">):</code>
        <code class="kn">for</code> <code class="n">index</code> <code class="ow">in</code> <code class="nb">self</code><code class="o">.</code><code class="n">_indexes</code><code class="p">(</code><code class="n">key</code><code class="p">):</code>
            <code class="nb">self</code><code class="o">.</code><code class="n">data</code><code class="p">[</code><code class="n">index</code><code class="p">]</code> <code class="o">=</code> <code class="nb">True</code>

    <code class="kn">def</code> <code class="calibre26">__contains__</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">key</code><code class="p">):</code>
        <code class="kn">return</code> <code class="nb">all</code><code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">data</code><code class="p">[</code><code class="n">index</code><code class="p">]</code> <code class="kn">for</code> <code class="n">index</code> <code class="ow">in</code> <code class="nb">self</code><code class="o">.</code><code class="n">_indexes</code><code class="p">(</code><code class="n">key</code><code class="p">))</code>

    <code class="kn">def</code> <code class="calibre26">__len__</code><code class="p">(</code><code class="nb">self</code><code class="p">):</code>
        <code class="n">bit_off_num</code> <code class="o">=</code> <code class="nb">self</code><code class="o">.</code><code class="n">data</code><code class="o">.</code><code class="n">count</code><code class="p">(</code><code class="nb">True</code><code class="p">)</code>
        <code class="n">bit_off_percent</code> <code class="o">=</code> <code class="mi">1.0</code> <code class="o">-</code> <code class="n">bit_off_num</code> <code class="o">/</code> <code class="nb">self</code><code class="o">.</code><code class="n">num_bits</code>
        <code class="n">length</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1.0</code> <code class="o">*</code> <code class="nb">self</code><code class="o">.</code><code class="n">num_bits</code> <code class="o">*</code> <code class="n">math</code><code class="o">.</code><code class="n">log</code><code class="p">(</code><code class="n">bit_off_percent</code><code class="p">)</code> <code class="o">/</code> <code class="nb">self</code><code class="o">.</code><code class="n">num_hashes</code>
        <code class="kn">return</code> <code class="nb">int</code><code class="p">(</code><code class="n">length</code><code class="p">)</code>

    <code class="nd">@staticmethod</code>
    <code class="kn">def</code> <code class="nf">union</code><code class="p">(</code><code class="n">bloom_a</code><code class="p">,</code> <code class="n">bloom_b</code><code class="p">):</code>
        <code class="kn">assert</code> <code class="n">bloom_a</code><code class="o">.</code><code class="n">capacity</code> <code class="o">==</code> <code class="n">bloom_b</code><code class="o">.</code><code class="n">capacity</code><code class="p">,</code> <code class="s">"Capacities must be equal"</code>
        <code class="kn">assert</code> <code class="n">bloom_a</code><code class="o">.</code><code class="n">error</code> <code class="o">==</code> <code class="n">bloom_b</code><code class="o">.</code><code class="n">error</code><code class="p">,</code> <code class="s">"Error rates must be equal"</code>

        <code class="n">bloom_union</code> <code class="o">=</code> <code class="n">BloomFilter</code><code class="p">(</code><code class="n">bloom_a</code><code class="o">.</code><code class="n">capacity</code><code class="p">,</code> <code class="n">bloom_a</code><code class="o">.</code><code class="n">error</code><code class="p">)</code>
        <code class="n">bloom_union</code><code class="o">.</code><code class="n">data</code> <code class="o">=</code> <code class="n">bloom_a</code><code class="o">.</code><code class="n">data</code> <code class="o">|</code> <code class="n">bloom_b</code><code class="o">.</code><code class="n">data</code>
        <code class="kn">return</code> <code class="n">bloom_union</code></pre></div>

<p class="author1">What happens if we insert more items than we specified for the capacity of the
Bloom filter?  At the extreme end, all the items in the <code class="calibre26">bool</code> list will be set to <code class="calibre26">True</code>, in
which case we say that we have seen every item.  This means that Bloom filters
are very sensitive to what their initial capacity was set to, which can be quite
aggravating if we are dealing with a set of data whose size is unknown (for
example, a stream of data).</p>

<p class="author1">One way of dealing with this is to use a variant of Bloom filters called<a data-type="indexterm" data-primary="scalable Bloom filters" id="idm46122398752072" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <em class="hyperlink">scalable</em>
Bloom filters.<sup class="calibre44"><a data-type="noteref" id="idm46122398750824-marker" href="ch11_split_001.xhtml#idm46122398750824" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">7</a></sup> They work by chaining together multiple Bloom
filters whose error rates vary in a specific way.<sup class="calibre44"><a data-type="noteref" id="idm46122398488968-marker" href="ch11_split_001.xhtml#idm46122398488968" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">8</a></sup>  By doing
this, we can guarantee an overall error rate and add a new Bloom filter
when we need more capacity. To check if we’ve seen an item before, we
iterate over all of the sub-Blooms until either we find the object or we
exhaust the list.  A sample implementation of this structure can be seen in
<a data-type="xref" href="ch11_split_001.xhtml#memory_scaling_bloom" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-31</a>, where we use the previous Bloom filter implementation
for the underlying functionality and have a counter to simplify knowing when to
    add a new Bloom.</p>
<div id="memory_scaling_bloom" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-31. </span>Simple scaling Bloom filter implementation</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">from</code> <code class="nn">bloomfilter</code> <code class="kn">import</code> <code class="n">BloomFilter</code>

<code class="kn">class</code> <code class="nc">ScalingBloomFilter</code><code class="p">:</code>
    <code class="kn">def</code> <code class="calibre26">__init__</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">capacity</code><code class="p">,</code> <code class="n">error</code><code class="o">=</code><code class="mi">0.005</code><code class="p">,</code> <code class="n">max_fill</code><code class="o">=</code><code class="mi">0.8</code><code class="p">,</code>
                 <code class="n">error_tightening_ratio</code><code class="o">=</code><code class="mi">0.5</code><code class="p">):</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">capacity</code> <code class="o">=</code> <code class="n">capacity</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">base_error</code> <code class="o">=</code> <code class="n">error</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">max_fill</code> <code class="o">=</code> <code class="n">max_fill</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">items_until_scale</code> <code class="o">=</code> <code class="nb">int</code><code class="p">(</code><code class="n">capacity</code> <code class="o">*</code> <code class="n">max_fill</code><code class="p">)</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">error_tightening_ratio</code> <code class="o">=</code> <code class="n">error_tightening_ratio</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">bloom_filters</code> <code class="o">=</code> <code class="p">[]</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">current_bloom</code> <code class="o">=</code> <code class="nb">None</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">_add_bloom</code><code class="p">()</code>

    <code class="kn">def</code> <code class="nf">_add_bloom</code><code class="p">(</code><code class="nb">self</code><code class="p">):</code>
        <code class="n">new_error</code> <code class="o">=</code> <code class="nb">self</code><code class="o">.</code><code class="n">base_error</code> <code class="o">*</code> <code class="nb">self</code><code class="o">.</code><code class="n">error_tightening_ratio</code> <code class="o">**</code> <code class="nb">len</code><code class="p">(</code>
            <code class="nb">self</code><code class="o">.</code><code class="n">bloom_filters</code>
        <code class="p">)</code>
        <code class="n">new_bloom</code> <code class="o">=</code> <code class="n">BloomFilter</code><code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">capacity</code><code class="p">,</code> <code class="n">new_error</code><code class="p">)</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">bloom_filters</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">new_bloom</code><code class="p">)</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">current_bloom</code> <code class="o">=</code> <code class="n">new_bloom</code>
        <code class="kn">return</code> <code class="n">new_bloom</code>

    <code class="kn">def</code> <code class="nf">add</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">key</code><code class="p">):</code>
        <code class="kn">if</code> <code class="n">key</code> <code class="ow">in</code> <code class="nb">self</code><code class="p">:</code>
            <code class="kn">return</code> <code class="nb">True</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">current_bloom</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">key</code><code class="p">)</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">items_until_scale</code> <code class="o">-=</code> <code class="mi">1</code>
        <code class="kn">if</code> <code class="nb">self</code><code class="o">.</code><code class="n">items_until_scale</code> <code class="o">==</code> <code class="mi">0</code><code class="p">:</code>
            <code class="n">bloom_size</code> <code class="o">=</code> <code class="nb">len</code><code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">current_bloom</code><code class="p">)</code>
            <code class="n">bloom_max_capacity</code> <code class="o">=</code> <code class="nb">int</code><code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">current_bloom</code><code class="o">.</code><code class="n">capacity</code> <code class="o">*</code> <code class="nb">self</code><code class="o">.</code><code class="n">max_fill</code><code class="p">)</code>

            <code class="c"># We may have been adding many duplicate values into the Bloom, so</code>
            <code class="c"># we need to check if we actually need to scale or if we still have</code>
            <code class="c"># space</code>
            <code class="kn">if</code> <code class="n">bloom_size</code> <code class="o">&gt;=</code> <code class="n">bloom_max_capacity</code><code class="p">:</code>
                <code class="nb">self</code><code class="o">.</code><code class="n">_add_bloom</code><code class="p">()</code>
                <code class="nb">self</code><code class="o">.</code><code class="n">items_until_scale</code> <code class="o">=</code> <code class="n">bloom_max_capacity</code>
            <code class="kn">else</code><code class="p">:</code>
                <code class="nb">self</code><code class="o">.</code><code class="n">items_until_scale</code> <code class="o">=</code> <code class="nb">int</code><code class="p">(</code><code class="n">bloom_max_capacity</code> <code class="o">-</code> <code class="n">bloom_size</code><code class="p">)</code>
        <code class="kn">return</code> <code class="nb">False</code>

    <code class="kn">def</code> <code class="calibre26">__contains__</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">key</code><code class="p">):</code>
        <code class="kn">return</code> <code class="nb">any</code><code class="p">(</code><code class="n">key</code> <code class="ow">in</code> <code class="n">bloom</code> <code class="kn">for</code> <code class="n">bloom</code> <code class="ow">in</code> <code class="nb">self</code><code class="o">.</code><code class="n">bloom_filters</code><code class="p">)</code>

    <code class="kn">def</code> <code class="calibre26">__len__</code><code class="p">(</code><code class="nb">self</code><code class="p">):</code>
        <code class="kn">return</code> <code class="nb">int</code><code class="p">(</code><code class="nb">sum</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">bloom</code><code class="p">)</code> <code class="kn">for</code> <code class="n">bloom</code> <code class="ow">in</code> <code class="nb">self</code><code class="o">.</code><code class="n">bloom_filters</code><code class="p">))</code></pre></div>

<p class="author1">Another way of dealing with this is using a method called <em class="hyperlink">timing Bloom filters</em>.
This variant allows elements to be expired out of the data structure, thus
freeing up space for more elements.  This is especially nice for dealing with
streams, since we can have elements expire after, say, an hour and have the
capacity set large enough to deal with the amount of data we see per hour.  Using a
Bloom filter this way would give us a nice view into what has been happening in
the last hour.</p>

<p class="author1">Using this data structure will feel much like using a <code class="calibre26">set</code> object.  In the following interaction, we use the scalable Bloom filter to add several objects, test if we’ve seen them
before, and then try to experimentally find the false positive rate:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="o">&gt;&gt;&gt;</code> <code class="n">bloom</code> <code class="o">=</code> <code class="n">BloomFilter</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code>

<code class="o">&gt;&gt;&gt;</code> <code class="kn">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">50</code><code class="p">):</code>
   <code class="o">....</code><code class="p">:</code>     <code class="n">bloom</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="nb">str</code><code class="p">(</code><code class="n">i</code><code class="p">))</code>
   <code class="o">....</code><code class="p">:</code>

<code class="o">&gt;&gt;&gt;</code> <code class="s">"20"</code> <code class="ow">in</code> <code class="n">bloom</code>
<code class="nb">True</code>

<code class="o">&gt;&gt;&gt;</code> <code class="s">"25"</code> <code class="ow">in</code> <code class="n">bloom</code>
<code class="nb">True</code>

<code class="o">&gt;&gt;&gt;</code> <code class="s">"51"</code> <code class="ow">in</code> <code class="n">bloom</code>
<code class="nb">False</code>

<code class="o">&gt;&gt;&gt;</code> <code class="n">num_false_positives</code> <code class="o">=</code> <code class="mi">0</code>

<code class="o">&gt;&gt;&gt;</code> <code class="n">num_true_negatives</code> <code class="o">=</code> <code class="mi">0</code>

<code class="o">&gt;&gt;&gt;</code> <code class="c"># None of the following numbers should be in the Bloom.</code>
<code class="o">&gt;&gt;&gt;</code> <code class="c"># If one is found in the Bloom, it is a false positive.</code>
<code class="o">&gt;&gt;&gt;</code> <code class="kn">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">51</code><code class="p">,</code><code class="mi">10000</code><code class="p">):</code>
   <code class="o">....</code><code class="p">:</code>     <code class="kn">if</code> <code class="nb">str</code><code class="p">(</code><code class="n">i</code><code class="p">)</code> <code class="ow">in</code> <code class="n">bloom</code><code class="p">:</code>
   <code class="o">....</code><code class="p">:</code>         <code class="n">num_false_positives</code> <code class="o">+=</code> <code class="mi">1</code>
   <code class="o">....</code><code class="p">:</code>     <code class="kn">else</code><code class="p">:</code>
   <code class="o">....</code><code class="p">:</code>         <code class="n">num_true_negatives</code> <code class="o">+=</code> <code class="mi">1</code>
   <code class="o">....</code><code class="p">:</code>

<code class="o">&gt;&gt;&gt;</code> <code class="n">num_false_positives</code>
<code class="mi">54</code>

<code class="o">&gt;&gt;&gt;</code> <code class="n">num_true_negatives</code>
<code class="mi">9895</code>

<code class="o">&gt;&gt;&gt;</code> <code class="n">false_positive_rate</code> <code class="o">=</code> <code class="n">num_false_positives</code> <code class="o">/</code> <code class="nb">float</code><code class="p">(</code><code class="mi">10000</code> <code class="o">-</code> <code class="mi">51</code><code class="p">)</code>

<code class="o">&gt;&gt;&gt;</code> <code class="n">false_positive_rate</code>
<code class="mi">0.005427681173987335</code>

<code class="o">&gt;&gt;&gt;</code> <code class="n">bloom</code><code class="o">.</code><code class="n">error</code>
<code class="mi">0.005</code></pre>

<p class="author1">We can also do unions with Bloom filters to join multiple sets of
items:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="n">bloom_a</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="n">BloomFilter</code><code class="p">(</code><code class="mi">200</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="n">bloom_b</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="n">BloomFilter</code><code class="p">(</code><code class="mi">200</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="kn">for</code><code class="calibre26"> </code><code class="n">i</code><code class="calibre26"> </code><code class="ow">in</code><code class="calibre26"> </code><code class="nb">range</code><code class="p">(</code><code class="mi">50</code><code class="p">)</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">   </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code class="p">:</code><code class="calibre26">     </code><code class="n">bloom_a</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="nb">str</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">   </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="kn">for</code><code class="calibre26"> </code><code class="n">i</code><code class="calibre26"> </code><code class="ow">in</code><code class="calibre26"> </code><code class="nb">range</code><code class="p">(</code><code class="mi">25</code><code class="p">,</code><code class="mi">75</code><code class="p">)</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">   </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code class="p">:</code><code class="calibre26">     </code><code class="n">bloom_b</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="nb">str</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">   </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="n">bloom</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="n">BloomFilter</code><code class="o">.</code><code class="n">union</code><code class="p">(</code><code class="n">bloom_a</code><code class="p">,</code><code class="calibre26"> </code><code class="n">bloom_b</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="s">"</code><code class="s">51</code><code class="s">"</code><code class="calibre26"> </code><code class="ow">in</code><code class="calibre26"> </code><code class="n">bloom_a</code><code class="calibre26"> </code><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="co_using_less_ram_CO2-1" href="ch11_split_001.xhtml#callout_using_less_ram_CO2-1"><img src="Images/1.png" alt="1" class="calibre74"/></a><code class="calibre26">
</code><code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]</code><code class="p">:</code><code class="calibre26"> </code><code class="nb">False</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="s">"</code><code class="s">24</code><code class="s">"</code><code class="calibre26"> </code><code class="ow">in</code><code class="calibre26"> </code><code class="n">bloom_b</code><code class="calibre26"> </code><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="co_using_less_ram_CO2-2" href="ch11_split_001.xhtml#callout_using_less_ram_CO2-2"><img src="Images/2.png" alt="2" class="calibre74"/></a><code class="calibre26">
</code><code class="n">Out</code><code class="p">[</code><code class="mi">10</code><code class="p">]</code><code class="p">:</code><code class="calibre26"> </code><code class="nb">False</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="s">"</code><code class="s">55</code><code class="s">"</code><code class="calibre26"> </code><code class="ow">in</code><code class="calibre26"> </code><code class="n">bloom</code><code class="calibre26"> </code><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="co_using_less_ram_CO2-3" href="ch11_split_001.xhtml#callout_using_less_ram_CO2-3"><img src="Images/3.png" alt="3" class="calibre74"/></a><code class="calibre26">
</code><code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]</code><code class="p">:</code><code class="calibre26"> </code><code class="nb">True</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code class="calibre26"> </code><code class="s">"</code><code class="s">25</code><code class="s">"</code><code class="calibre26"> </code><code class="ow">in</code><code class="calibre26"> </code><code class="n">bloom</code><code class="calibre26">
</code><code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]</code><code class="p">:</code><code class="calibre26"> </code><code class="nb">True</code></pre>
<dl class="calibre28">
<dt class="calibre29"><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="callout_using_less_ram_CO2-1" href="ch11_split_001.xhtml#co_using_less_ram_CO2-1"><img src="Images/1.png" alt="1" class="calibre74"/></a></dt>
<dd class="calibre75"><p class="calibre76">The value of <code class="calibre26">51</code> is not in <code class="calibre26">bloom_a</code>.</p></dd>
<dt class="calibre29"><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="callout_using_less_ram_CO2-2" href="ch11_split_001.xhtml#co_using_less_ram_CO2-2"><img src="Images/2.png" alt="2" class="calibre74"/></a></dt>
<dd class="calibre75"><p class="calibre76">Similarly, the value of <code class="calibre26">24</code> is not in <code class="calibre26">bloom_b</code>.</p></dd>
<dt class="calibre29"><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="callout_using_less_ram_CO2-3" href="ch11_split_001.xhtml#co_using_less_ram_CO2-3"><img src="Images/3.png" alt="3" class="calibre74"/></a></dt>
<dd class="calibre75"><p class="calibre76">However, the <code class="calibre26">bloom</code> object contains all the objects in both <code class="calibre26">bloom_a</code> and <code class="calibre26">bloom_b</code>!</p></dd>
</dl>

<p class="author1">One caveat is that you can take the union of only two Blooms
with the same capacity and error rate.  Furthermore, the final Bloom’s used
capacity can be as high as the sum of the used capacities of the two Blooms
unioned to make it. This means that you could start with two Bloom filters
that are a little more than half full and, when you union them together,
get a new Bloom that is over capacity and not reliable!</p>
<div data-type="note" epub:type="note" class="calibre35"><h6 class="calibre36">Note</h6>
<p class="author1">A <a href="https://oreil.ly/oD6UM" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Cuckoo filter</a> is a
modern Bloom filter–like data structure that provides similar functionality to a
Bloom filter with the addition of better object deletion. Furthermore, the
Cuckoo filter in most cases has lower overhead, leading to better
space efficiencies than the Bloom filter. When a fixed number of
objects needs to be kept track of, it is often a better option. However, its
performance degrades dramatically when its load limit is reached and there are
no options for automatic scaling of the data structure (as we saw with the
scaling Bloom filter).</p>

<p class="author1">The work of doing fast set inclusion in a memory-efficient way 
<span class="publishername">is a very</span>
important and active part of database research. <a data-type="indexterm" data-primary="Cuckoo filter" id="idm46122397718248" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="Bloomier filter" id="idm46122397717544" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="Xor filter" id="idm46122397716872" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Cuckoo filters, <a href="https://arxiv.org/abs/0807.0928" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Bloomier filters</a>, <a href="https://arxiv.org/abs/1912.08258" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Xor filters</a>,
and more are being constantly
released. However, for most applications, it is still best to stick with the
well-known, well-supported Bloom filter.<a data-type="indexterm" data-primary="" data-startref="bf_ab" id="idm46122397714520" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="pds_bf" id="idm46122397713544" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="LogLog Counter" class="calibre3"><div class="preface" id="idm46122398964968">
<h2 class="calibre43">LogLog Counter</h2>

<p class="author1"><a data-type="indexterm" data-primary="hash values" id="hv_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="LogLog Counter" data-seealso="probabilistic data structures" id="llc_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="probabilistic data structures" data-secondary="LogLog Counter" id="pds_llc" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a href="http://bit.ly/LL-type_counters" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">LogLog-type counters</a> are based on the realization that the individual bits of a hash
function can also be considered random.  That is to say, the
probability of the first bit of a hash being <code class="calibre26">1</code> is 50%, the probability of the
first two bits being <code class="calibre26">01</code> is 25%, and the probability of the first three bits being <code class="calibre26">001</code> is 12.5%.  Knowing these
probabilities, and keeping the hash with the most <code class="calibre26">0</code>s at
the beginning (i.e., the least probable hash value), we can come up with an
estimate of how many items we’ve seen so far.</p>

<p class="author1">A good analogy for this method is flipping coins.  Imagine we would like to flip
a coin 32 times and get heads every time.  The number 32 comes from the fact that
we are using 32-bit hash functions.  If we flip the coin once and it comes
up tails, we will store the number <code class="calibre26">0</code>, since our best attempt yielded 0
heads in a row.  Since we know the probabilities behind this coin flip, we can also
tell you that our longest series was <code class="calibre26">0</code> long, and you can estimate that we’ve
tried this experiment <code class="calibre26">2^0 = 1</code> time.  If we keep flipping our coin and we’re able
to get 10 heads before getting a tail, then we would store the number <code class="calibre26">10</code>.  Using
the same logic, you could estimate that we’ve tried the experiment <code class="calibre26">2^10 = 1024</code>
times.  With this system, the highest we could count would be the maximum number
of flips we consider (for 32 flips, this is <code class="calibre26">2^32 = 4,294,967,296</code>).</p>

<p class="author1">To encode this logic with LogLog-type counters, we take the binary
representation of the hash value of our input and see how many <code class="calibre26">0</code>s there are
before we see our first <code class="calibre26">1</code>.  The hash value can be thought of as a series of 32
coin flips, where <code class="calibre26">0</code> means a flip for heads and <code class="calibre26">1</code> means a flip for tails (i.e., <code class="calibre26">000010101101</code> means we flipped four heads before our first tails, and <code class="calibre26">010101101</code>
means we flipped one head before flipping our first tail).  This gives us an idea
of how many tries happened before this hash value was reached.  The mathematics
behind this system is almost equivalent to that of the Morris counter, with one
major exception: we acquire the “random” values by 
<span class="publishername">looking</span> at the actual input
instead of using a random number generator.  This means that if we keep adding the same
value to a LogLog counter, its internal state will not change. <a data-type="xref" href="ch11_split_001.xhtml#simple_implementation_of_loglog_register" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-32</a> shows a simple implementation of a LogLog counter.</p>
<div id="simple_implementation_of_loglog_register" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-32. </span>Simple implementation of LogLog register</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">import</code> <code class="nn">mmh3</code>

<code class="kn">def</code> <code class="nf">trailing_zeros</code><code class="p">(</code><code class="n">number</code><code class="p">):</code>
    <code class="sd">"""</code>
<code class="sd">    Returns the index of the first bit set to 1 from the right side of a 32-bit</code>
<code class="sd">    integer</code>
<code class="sd">    &gt;&gt;&gt; trailing_zeros(0)</code>
<code class="sd">    32</code>
<code class="sd">    &gt;&gt;&gt; trailing_zeros(0b1000)</code>
<code class="sd">    3</code>
<code class="sd">    &gt;&gt;&gt; trailing_zeros(0b10000000)</code>
<code class="sd">    7</code>
<code class="sd">    """</code>
    <code class="kn">if</code> <code class="ow">not</code> <code class="n">number</code><code class="p">:</code>
        <code class="kn">return</code> <code class="mi">32</code>
    <code class="n">index</code> <code class="o">=</code> <code class="mi">0</code>
    <code class="kn">while</code> <code class="p">(</code><code class="n">number</code> <code class="o">&gt;&gt;</code> <code class="n">index</code><code class="p">)</code> <code class="o">&amp;</code> <code class="mi">1</code> <code class="o">==</code> <code class="mi">0</code><code class="p">:</code>
        <code class="n">index</code> <code class="o">+=</code> <code class="mi">1</code>
    <code class="kn">return</code> <code class="n">index</code>

<code class="kn">class</code> <code class="nc">LogLogRegister</code><code class="p">:</code>
    <code class="n">counter</code> <code class="o">=</code> <code class="mi">0</code>
    <code class="kn">def</code> <code class="nf">add</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">item</code><code class="p">):</code>
        <code class="n">item_hash</code> <code class="o">=</code> <code class="n">mmh3</code><code class="o">.</code><code class="n">hash</code><code class="p">(</code><code class="nb">str</code><code class="p">(</code><code class="n">item</code><code class="p">))</code>
        <code class="kn">return</code> <code class="nb">self</code><code class="o">.</code><code class="n">_add</code><code class="p">(</code><code class="n">item_hash</code><code class="p">)</code>

    <code class="kn">def</code> <code class="nf">_add</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">item_hash</code><code class="p">):</code>
        <code class="n">bit_index</code> <code class="o">=</code> <code class="n">trailing_zeros</code><code class="p">(</code><code class="n">item_hash</code><code class="p">)</code>
        <code class="kn">if</code> <code class="n">bit_index</code> <code class="o">&gt;</code> <code class="nb">self</code><code class="o">.</code><code class="n">counter</code><code class="p">:</code>
            <code class="nb">self</code><code class="o">.</code><code class="n">counter</code> <code class="o">=</code> <code class="n">bit_index</code>

    <code class="kn">def</code> <code class="calibre26">__len__</code><code class="p">(</code><code class="nb">self</code><code class="p">):</code>
        <code class="kn">return</code> <code class="mi">2</code><code class="o">**</code><code class="nb">self</code><code class="o">.</code><code class="n">counter</code></pre></div>

<p class="author1">The biggest drawback of this method is that we may get a hash value that
increases the counter right at the beginning and skews our estimates.  This would
be similar to flipping 32 tails on the first try.  To remedy this,
we should have many people flipping coins at the same time and combine their
results.  The law of large numbers tells us that as we add more and more
flippers, the total statistics become less affected by anomalous samples from
individual flippers.  The exact way that we combine the results is the root of
the difference between <a data-type="indexterm" data-primary="HyperLogLog" id="idm46122397743112" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="SuperLogLog" id="idm46122397742504" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>LogLog-type methods (classic LogLog, SuperLogLog,
HyperLogLog, HyperLogLog++, etc.).</p>

<p class="author1">We can accomplish this “multiple flipper” method by taking the first couple
of bits of a hash value and using that to designate which of our flippers had that
particular result.  If we take the first 4 bits of the hash, this means we have
<code class="calibre26">2^4 = 16</code> flippers.  Since we used the first 4 bits for this selection, we
have only 28 bits left (corresponding to 28 individual coin flips per coin flipper),
meaning each counter can count only up to <code class="calibre26">2^28 = 268,435,456</code>.  In addition,
there is a constant (alpha) that depends on the number of flippers,
which normalizes the estimation.<sup class="calibre44"><a data-type="noteref" id="idm46122397477912-marker" href="ch11_split_001.xhtml#idm46122397477912" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">9</a></sup>  All of this together
gives us an algorithm with <math alttext="1.05 slash StartRoot m EndRoot">
  <mrow>
    <mn>1</mn>
    <mo>.</mo>
    <mn>05</mn>
    <mo>/</mo>
    <msqrt>
      <mi>m</mi>
    </msqrt>
  </mrow>
</math> accuracy, where <em class="hyperlink">m</em> is the
number of registers (or flippers) used. <a data-type="xref" href="ch11_split_001.xhtml#simple_implementation_of_loglog_example11-26" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-33</a> shows a simple implementation of the LogLog algorithm.</p>
<div id="simple_implementation_of_loglog_example11-26" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-33. </span>Simple implementation of LogLog</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">import</code> <code class="nn">mmh3</code>

<code class="kn">from</code> <code class="nn">llregister</code> <code class="kn">import</code> <code class="n">LLRegister</code>

<code class="kn">class</code> <code class="nc">LL</code><code class="p">:</code>
    <code class="kn">def</code> <code class="calibre26">__init__</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">p</code><code class="p">):</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">p</code> <code class="o">=</code> <code class="n">p</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">num_registers</code> <code class="o">=</code> <code class="mi">2</code> <code class="o">**</code> <code class="n">p</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">registers</code> <code class="o">=</code> <code class="p">[</code><code class="n">LLRegister</code><code class="p">()</code> <code class="kn">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="nb">int</code><code class="p">(</code><code class="mi">2</code> <code class="o">**</code> <code class="n">p</code><code class="p">))]</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">alpha</code> <code class="o">=</code> <code class="mi">0.7213</code> <code class="o">/</code> <code class="p">(</code><code class="mi">1.0</code> <code class="o">+</code> <code class="mi">1.079</code> <code class="o">/</code> <code class="nb">self</code><code class="o">.</code><code class="n">num_registers</code><code class="p">)</code>

    <code class="kn">def</code> <code class="nf">add</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">item</code><code class="p">):</code>
        <code class="n">item_hash</code> <code class="o">=</code> <code class="n">mmh3</code><code class="o">.</code><code class="n">hash</code><code class="p">(</code><code class="nb">str</code><code class="p">(</code><code class="n">item</code><code class="p">))</code>
        <code class="n">register_index</code> <code class="o">=</code> <code class="n">item_hash</code> <code class="o">&amp;</code> <code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">num_registers</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code>
        <code class="n">register_hash</code> <code class="o">=</code> <code class="n">item_hash</code> <code class="o">&gt;&gt;</code> <code class="nb">self</code><code class="o">.</code><code class="n">p</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">registers</code><code class="p">[</code><code class="n">register_index</code><code class="p">]</code><code class="o">.</code><code class="n">_add</code><code class="p">(</code><code class="n">register_hash</code><code class="p">)</code>

    <code class="kn">def</code> <code class="calibre26">__len__</code><code class="p">(</code><code class="nb">self</code><code class="p">):</code>
        <code class="n">register_sum</code> <code class="o">=</code> <code class="nb">sum</code><code class="p">(</code><code class="n">h</code><code class="o">.</code><code class="n">counter</code> <code class="kn">for</code> <code class="n">h</code> <code class="ow">in</code> <code class="nb">self</code><code class="o">.</code><code class="n">registers</code><code class="p">)</code>
        <code class="n">length</code> <code class="o">=</code> <code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">num_registers</code> <code class="o">*</code> <code class="nb">self</code><code class="o">.</code><code class="n">alpha</code> <code class="o">*</code>
                  <code class="mi">2</code> <code class="o">**</code> <code class="p">(</code><code class="n">register_sum</code> <code class="o">/</code> <code class="nb">self</code><code class="o">.</code><code class="n">num_registers</code><code class="p">))</code>
        <code class="kn">return</code> <code class="nb">int</code><code class="p">(</code><code class="n">length</code><code class="p">)</code></pre></div>

<p class="author1">In addition to this algorithm deduplicating similar items by using the hash
value as an indicator, it has a tunable parameter that can be used to dial whatever
sort of accuracy versus storage compromise you are willing to make.</p>

<p class="author1">In the <code class="calibre26">__len__</code> method, we are averaging the estimates from all of
the individual LogLog registers.  This, however, is not the most efficient way
to combine the data!  This is because we may get some unfortunate hash values
that make one particular register spike up while the others are still at low
values.  Because of this, we are able to achieve an error rate of only
<math alttext="upper O left-parenthesis StartFraction 1.30 Over StartRoot m EndRoot EndFraction right-parenthesis">
  <mrow>
    <mi>O</mi>
    <mo>(</mo>
    <mfrac><mrow><mn>1</mn><mo>.</mo><mn>30</mn></mrow> <msqrt><mi>m</mi></msqrt></mfrac>
    <mo>)</mo>
  </mrow>
</math>, where <em class="hyperlink">m</em> is the number of registers used.</p>

<p class="author1">SuperLogLog was devised as a fix to this problem.<sup class="calibre44"><a data-type="noteref" id="idm46122397252728-marker" href="ch11_split_001.xhtml#idm46122397252728" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">10</a></sup> With this algorithm, only the lowest 70% of
the registers were used for the size estimate, and their value was limited by a
maximum value given by a restriction rule.  This addition decreased the error
rate to <math alttext="upper O left-parenthesis StartFraction 1.05 Over StartRoot m EndRoot EndFraction right-parenthesis">
  <mrow>
    <mi>O</mi>
    <mo>(</mo>
    <mfrac><mrow><mn>1</mn><mo>.</mo><mn>05</mn></mrow> <msqrt><mi>m</mi></msqrt></mfrac>
    <mo>)</mo>
  </mrow>
</math>.  This is counterintuitive, since
we got a better estimate by disregarding <span class="publishername">information</span>!</p>

<p class="author1">Finally, HyperLogLog came out in 2007 and gave us further
accuracy gains.<sup class="calibre44"><a data-type="noteref" id="idm46122397244632-marker" href="ch11_split_001.xhtml#idm46122397244632" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">11</a></sup> It did so by changing the method of averaging the individual
registers: instead of just averaging, we use a spherical averaging scheme that
also has special considerations for different edge cases the structure could be
in.  This brings us to the current best error rate of
<math alttext="upper O left-parenthesis StartFraction 1.04 Over StartRoot m EndRoot EndFraction right-parenthesis">
  <mrow>
    <mi>O</mi>
    <mo>(</mo>
    <mfrac><mrow><mn>1</mn><mo>.</mo><mn>04</mn></mrow> <msqrt><mi>m</mi></msqrt></mfrac>
    <mo>)</mo>
  </mrow>
</math>.  In addition, this formulation removes a
sorting operation that is necessary with SuperLogLog.  This can greatly speed up
the performance of the data structure when you are trying to insert items at a
high volume. <a data-type="xref" href="ch11_split_001.xhtml#example_11-27" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 11-34</a> shows a basic implementation of HyperLogLog.</p>
<div id="example_11-27" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 11-34. </span>Simple implementation of HyperLogLog</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">import</code> <code class="nn">math</code>

<code class="kn">from</code> <code class="nn">ll</code> <code class="kn">import</code> <code class="n">LL</code>

<code class="kn">class</code> <code class="nc">HyperLogLog</code><code class="p">(</code><code class="n">LL</code><code class="p">):</code>
    <code class="kn">def</code> <code class="calibre26">__len__</code><code class="p">(</code><code class="nb">self</code><code class="p">):</code>
        <code class="n">indicator</code> <code class="o">=</code> <code class="nb">sum</code><code class="p">(</code><code class="mi">2</code> <code class="o">**</code> <code class="o">-</code><code class="n">m</code><code class="o">.</code><code class="n">counter</code> <code class="kn">for</code> <code class="n">m</code> <code class="ow">in</code> <code class="nb">self</code><code class="o">.</code><code class="n">registers</code><code class="p">)</code>
        <code class="n">E</code> <code class="o">=</code> <code class="nb">self</code><code class="o">.</code><code class="n">alpha</code> <code class="o">*</code> <code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">num_registers</code> <code class="o">**</code> <code class="mi">2</code><code class="p">)</code> <code class="o">/</code> <code class="n">indicator</code>

        <code class="kn">if</code> <code class="n">E</code> <code class="o">&lt;=</code> <code class="mi">5.0</code> <code class="o">/</code> <code class="mi">2.0</code> <code class="o">*</code> <code class="nb">self</code><code class="o">.</code><code class="n">num_registers</code><code class="p">:</code>
            <code class="n">V</code> <code class="o">=</code> <code class="nb">sum</code><code class="p">(</code><code class="mi">1</code> <code class="kn">for</code> <code class="n">m</code> <code class="ow">in</code> <code class="nb">self</code><code class="o">.</code><code class="n">registers</code> <code class="kn">if</code> <code class="n">m</code><code class="o">.</code><code class="n">counter</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
            <code class="kn">if</code> <code class="n">V</code> <code class="o">!=</code> <code class="mi">0</code><code class="p">:</code>
                <code class="n">Estar</code> <code class="o">=</code> <code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">num_registers</code> <code class="o">*</code>
                         <code class="n">math</code><code class="o">.</code><code class="n">log</code><code class="p">(</code><code class="nb">self</code><code class="o">.</code><code class="n">num_registers</code> <code class="o">/</code> <code class="p">(</code><code class="mi">1.0</code> <code class="o">*</code> <code class="n">V</code><code class="p">),</code> <code class="mi">2</code><code class="p">))</code>

            <code class="kn">else</code><code class="p">:</code>
                <code class="n">Estar</code> <code class="o">=</code> <code class="n">E</code>
        <code class="kn">else</code><code class="p">:</code>
            <code class="kn">if</code> <code class="n">E</code> <code class="o">&lt;=</code> <code class="mi">2</code> <code class="o">**</code> <code class="mi">32</code> <code class="o">/</code> <code class="mi">30.0</code><code class="p">:</code>
                <code class="n">Estar</code> <code class="o">=</code> <code class="n">E</code>
            <code class="kn">else</code><code class="p">:</code>
                <code class="n">Estar</code> <code class="o">=</code> <code class="o">-</code><code class="mi">2</code> <code class="o">**</code> <code class="mi">32</code> <code class="o">*</code> <code class="n">math</code><code class="o">.</code><code class="n">log</code><code class="p">(</code><code class="mi">1</code> <code class="o">-</code> <code class="n">E</code> <code class="o">/</code> <code class="mi">2</code> <code class="o">**</code> <code class="mi">32</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>
        <code class="kn">return</code> <code class="nb">int</code><code class="p">(</code><code class="n">Estar</code><code class="p">)</code>

<code class="kn">if</code> <code class="calibre26">__name__</code> <code class="o">==</code> <code class="s">"__main__"</code><code class="p">:</code>
    <code class="kn">import</code> <code class="nn">mmh3</code>

    <code class="n">hll</code> <code class="o">=</code> <code class="n">HyperLogLog</code><code class="p">(</code><code class="mi">8</code><code class="p">)</code>
    <code class="kn">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">100000</code><code class="p">):</code>
        <code class="n">hll</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">mmh3</code><code class="o">.</code><code class="n">hash</code><code class="p">(</code><code class="nb">str</code><code class="p">(</code><code class="n">i</code><code class="p">)))</code>
    <code class="kn">print</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">hll</code><code class="p">))</code></pre></div>

<p class="author1">The only further increase in accuracy was given by the HyperLogLog++ algorithm,
which increases the accuracy of the data structure while it is relatively empty.
When more items are inserted, this scheme reverts to standard HyperLogLog.  This
is actually quite useful, since the statistics of the LogLog-type
counters require a lot of data to be accurate—having a scheme for allowing
better accuracy with fewer number items greatly improves the usability of this
method.  This extra accuracy is achieved by having a smaller but more accurate
HyperLogLog structure that can later be converted into the larger structure that
was originally requested.  Also, some empirically derived constants are used in the size estimates that remove biases.<a data-type="indexterm" data-primary="" data-startref="hv_ab" id="idm46122397151880" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="llc_ab" id="idm46122397151032" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="pds_llc" id="idm46122397020408" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Real-World Example" class="calibre3"><div class="preface" id="pds_example">
<h2 class="calibre43">Real-World Example</h2>

<p class="author1"><a data-type="indexterm" data-primary="probabilistic data structures" data-secondary="examples" id="pds_ex" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>To obtain a better understanding of the data structures, we first created a dataset
with many unique keys, and then one with duplicate entries. Figures <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch11_split_001.xhtml#FIG-prob-ds-comparison_repeating" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">11-9</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch11_split_001.xhtml#FIG-prob-ds-comparison_unique" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">11-10</a> show the results when we feed these keys into the
data structures we’ve just looked at and periodically query, “How many unique entries have there
been?”  We can see that the data structures that contain more stateful variables
(such as HyperLogLog and <code class="calibre26">KMinValues</code>) do better, since they more robustly handle
bad statistics.  On the other hand, the Morris counter and the single LogLog
register can quickly have very high error rates if one unfortunate random number or
hash value occurs.  For most of the algorithms, however, we know that the number
of stateful variables is directly correlated with the error guarantees, so this
makes sense.</p>

<figure class="calibre46"><div id="FIG-prob-ds-comparison_repeating" class="figure">
<img src="Images/hpp2_1109.png" alt="hpp2 1109" class="calibre121"/>
<h6 class="calibre47"><span class="publishername">Figure 11-9. </span>The approximate count of duplicate data using multiple probabilistic data structures. To do this, we generate 60,000 items with many duplicates and insert them into the various probabilistic data structures. Graphed is the structures prediction of the number of unique items during the process.</h6>
</div></figure>

<p class="author1">Looking just at the probabilistic data structures that have the best performance
(which really are the ones you will probably use), we can summarize their utility and
their approximate memory usage (see <a data-type="xref" href="ch11_split_001.xhtml#memory_pd_comparison" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Table 11-2</a>).  We can see a
huge change in memory usage depending on the questions we care to ask.  This
simply highlights the fact that when using a probabilistic data structure, you
must first consider what questions you really need to answer about the dataset
before proceeding.  Also note that only the Bloom filter’s size depends on the
number of elements.  The sizes of the HyperLogLog and <code class="calibre26">KMinValues</code> structures are sizes dependent
<em class="hyperlink">only</em> on the error rate.</p>

<p class="author1">As another, more realistic test, we chose to use a dataset derived from the text
of Wikipedia.  We ran a very simple script in order to extract all single-word
tokens with five or more characters from all articles and store them in a newline-separated file.  The question then was, “How many unique tokens are there?” The results can be seen in <a data-type="xref" href="ch11_split_001.xhtml#memory_pd_wiki_comparison" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Table 11-3</a>.</p>
<table id="memory_pd_comparison" class="stafflist_table">
<caption class="calibre85"><span class="publishername">Table 11-2. </span>Comparison of major probabilistic data structures and the set operations available on them</caption>
<thead class="calibre87">
<tr class="calibre88">
<th class="calibre89"/>
<th class="calibre89">Size</th>
<th class="calibre89">Union<sup class="calibre44"><a data-type="noteref" id="idm46122397003048-marker" href="ch11_split_001.xhtml#idm46122397003048" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">a</a></sup></th>
<th class="calibre89">Intersection</th>
<th class="calibre89">Contains</th>
<th class="calibre89">Size<sup class="calibre44"><a data-type="noteref" id="idm46122397001176-marker" href="ch11_split_001.xhtml#idm46122397001176" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">b</a></sup></th>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre15">
<td class="calibre16"><p class="calibre17">HyperLogLog</p></td>
<td class="calibre16"><p class="calibre17">Yes (<math alttext="upper O left-parenthesis StartFraction 1.04 Over StartRoot m EndRoot EndFraction right-parenthesis">
  <mrow>
    <mi>O</mi>
    <mo>(</mo>
    <mfrac><mrow><mn>1</mn><mo>.</mo><mn>04</mn></mrow> <msqrt><mi>m</mi></msqrt></mfrac>
    <mo>)</mo>
  </mrow>
</math>)</p></td>
<td class="calibre16"><p class="calibre17">Yes</p></td>
<td class="calibre16"><p class="calibre17">No<sup class="calibre44"><a data-type="noteref" id="memory_caveat-marker" href="ch11_split_001.xhtml#memory_caveat" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">c</a></sup></p></td>
<td class="calibre16"><p class="calibre17">No</p></td>
<td class="calibre16"><p class="calibre17">2.704 MB</p></td>
</tr>
<tr class="calibre18">
<td class="calibre16"><p class="calibre17">KMinValues</p></td>
<td class="calibre16"><p class="calibre17">Yes (<math alttext="upper O left-parenthesis StartRoot StartFraction 2 Over pi left-parenthesis m minus 2 right-parenthesis EndFraction EndRoot right-parenthesis">
  <mrow>
    <mi>O</mi>
    <mo>(</mo>
    <msqrt>
      <mfrac><mn>2</mn> <mrow><mi>π</mi><mo>(</mo><mi>m</mi><mo>-</mo><mn>2</mn><mo>)</mo></mrow></mfrac>
    </msqrt>
    <mo>)</mo>
  </mrow>
</math>)</p></td>
<td class="calibre16"><p class="calibre17">Yes</p></td>
<td class="calibre16"><p class="calibre17">Yes</p></td>
<td class="calibre16"><p class="calibre17">No</p></td>
<td class="calibre16"><p class="calibre17">20.372 MB</p></td>
</tr>
<tr class="calibre19">
<td class="calibre16"><p class="calibre17">Bloom filter</p></td>
<td class="calibre16"><p class="calibre17">Yes (<math alttext="upper O left-parenthesis StartFraction 0.78 Over StartRoot m EndRoot EndFraction right-parenthesis">
  <mrow>
    <mi>O</mi>
    <mo>(</mo>
    <mfrac><mrow><mn>0</mn><mo>.</mo><mn>78</mn></mrow> <msqrt><mi>m</mi></msqrt></mfrac>
    <mo>)</mo>
  </mrow>
</math>)</p></td>
<td class="calibre16"><p class="calibre17">Yes</p></td>
<td class="calibre16"><p class="calibre17">No<sup class="calibre44"><a data-type="noteref" href="ch11_split_001.xhtml#memory_caveat" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">c</a></sup></p></td>
<td class="calibre16"><p class="calibre17">Yes</p></td>
<td class="calibre16"><p class="calibre17">197.8 MB</p></td>
</tr>
</tbody>
<tbody class="calibre14"><tr class="footnotes"><td colspan="6" class="calibre16"><p data-type="footnote" id="idm46122397003048" class="calibre122"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122397003048-marker" class="pcalibre2 pcalibre calibre123 pcalibre3 pcalibre1">a</a></sup> Union operations occur without increasing the error rate.</p><p data-type="footnote" id="idm46122397001176" class="calibre122"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122397001176-marker" class="pcalibre2 pcalibre calibre123 pcalibre3 pcalibre1">b</a></sup> Size of data structure with 0.05% error rate, 100 million unique elements, and using a 64-bit hashing function.</p><p data-type="footnote" id="memory_caveat" class="calibre122"><sup class="calibre54"><a href="ch11_split_001.xhtml#memory_caveat-marker" class="pcalibre2 pcalibre calibre123 pcalibre3 pcalibre1">c</a></sup> These operations <em class="hyperlink">can</em> be done but at a considerable penalty in terms of accuracy.</p></td></tr></tbody></table>

<p class="author1">The major takeaway from this experiment is that if you are able to specialize
your code, you can get amazing speed and memory gains.  This has been true
throughout the entire book: when we specialized our code in
<a data-type="xref" href="ch06_split_001.xhtml#matrix_selective_optimizations" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Selective Optimizations: Finding What Needs to Be Fixed”</a>, we were similarly able to get speed
increases.</p>

<figure class="calibre46"><div id="FIG-prob-ds-comparison_unique" class="figure">
<img src="Images/hpp2_1110.png" alt="hpp2 1110" class="calibre124"/>
<h6 class="calibre47"><span class="publishername">Figure 11-10. </span>The approximate count of unique data using multiple probabilistic data structures. To do this, we insert the numbers 1 through 100,000 into the data structures. Graphed is the structures prediction of the number of unique items during the process.</h6>
</div></figure>

<p class="author1">Probabilistic data structures are an algorithmic way of specializing your code.
We store only the data we need in order to answer specific questions with given
error bounds.  By having to deal with only a subset of the information given,
we can not only make the memory footprint much smaller, but also perform most
operations over the structure faster.</p>
<table id="memory_pd_wiki_comparison" class="stafflist_table">
<caption class="calibre85"><span class="publishername">Table 11-3. </span>Size estimates for the number of unique words in Wikipedia</caption>
<thead class="calibre87">
<tr class="calibre88">
<th class="calibre89"/>
<th class="calibre89">Elements</th>
<th class="calibre89">Relative error</th>
<th class="calibre89">Processing time<sup class="calibre44"><a data-type="noteref" id="idm46122396962408-marker" href="ch11_split_001.xhtml#idm46122396962408" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">a</a></sup></th>
<th class="calibre89">Structure size<sup class="calibre44"><a data-type="noteref" id="idm46122396961256-marker" href="ch11_split_001.xhtml#idm46122396961256" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">b</a></sup></th>
</tr>
</thead>
<tbody class="calibre14">
<tr class="calibre15">
<td class="calibre16"><p class="calibre17">Morris counter<sup class="calibre44"><a data-type="noteref" id="idm46122396958776-marker" href="ch11_split_001.xhtml#idm46122396958776" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">c</a></sup></p></td>
<td class="calibre16"><p class="calibre17">1,073,741,824</p></td>
<td class="calibre16"><p class="calibre17">6.52%</p></td>
<td class="calibre16"><p class="calibre17">751s</p></td>
<td class="calibre16"><p class="calibre17">5 bits</p></td>
</tr>
<tr class="calibre18">
<td class="calibre16"><p class="calibre17">LogLog register</p></td>
<td class="calibre16"><p class="calibre17">1,048,576</p></td>
<td class="calibre16"><p class="calibre17">78.84%</p></td>
<td class="calibre16"><p class="calibre17">1,690s</p></td>
<td class="calibre16"><p class="calibre17">5 bits</p></td>
</tr>
<tr class="calibre15">
<td class="calibre16"><p class="calibre17">LogLog</p></td>
<td class="calibre16"><p class="calibre17">4,522,232</p></td>
<td class="calibre16"><p class="calibre17">8.76%</p></td>
<td class="calibre16"><p class="calibre17">2,112s</p></td>
<td class="calibre16"><p class="calibre17">5 bits</p></td>
</tr>
<tr class="calibre18">
<td class="calibre16"><p class="calibre17">HyperLogLog</p></td>
<td class="calibre16"><p class="calibre17">4,983,171</p></td>
<td class="calibre16"><p class="calibre17">–0.54%</p></td>
<td class="calibre16"><p class="calibre17">2,907s</p></td>
<td class="calibre16"><p class="calibre17">40 KB</p></td>
</tr>
<tr class="calibre15">
<td class="calibre16"><p class="calibre17">KMinValues</p></td>
<td class="calibre16"><p class="calibre17">4,912,818</p></td>
<td class="calibre16"><p class="calibre17">0.88%</p></td>
<td class="calibre16"><p class="calibre17">3,503s</p></td>
<td class="calibre16"><p class="calibre17">256 KB</p></td>
</tr>
<tr class="calibre18">
<td class="calibre16"><p class="calibre17">Scaling Bloom</p></td>
<td class="calibre16"><p class="calibre17">4,949,358</p></td>
<td class="calibre16"><p class="calibre17">0.14%</p></td>
<td class="calibre16"><p class="calibre17">10,392s</p></td>
<td class="calibre16"><p class="calibre17">11,509 KB</p></td>
</tr>
<tr class="calibre19">
<td class="calibre16"><p class="calibre17">True value</p></td>
<td class="calibre16"><p class="calibre17">4,956,262</p></td>
<td class="calibre16"><p class="calibre17">0.00%</p></td>
<td class="calibre16"><p class="calibre17">-----</p></td>
<td class="calibre16"><p class="calibre17">49,558 KB<sup class="calibre44"><a data-type="noteref" id="idm46122396935256-marker" href="ch11_split_001.xhtml#idm46122396935256" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">d</a></sup></p></td>
</tr>
</tbody>
<tbody class="calibre14"><tr class="footnotes"><td colspan="5" class="calibre16"><p data-type="footnote" id="idm46122396962408" class="calibre122"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122396962408-marker" class="pcalibre2 pcalibre calibre123 pcalibre3 pcalibre1">a</a></sup> Processing time has been adjusted to remove the time to read the dataset from disk. We also use the simple implementations provided earlier for testing.</p><p data-type="footnote" id="idm46122396961256" class="calibre122"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122396961256-marker" class="pcalibre2 pcalibre calibre123 pcalibre3 pcalibre1">b</a></sup> Structure size is theoretical given the amount of data since the implementations used were not optimized.</p><p data-type="footnote" id="idm46122396958776" class="calibre122"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122396958776-marker" class="pcalibre2 pcalibre calibre123 pcalibre3 pcalibre1">c</a></sup> Since the Morris counter doesn’t deduplicate input, the size and relative error are given with regard to the total number of values.</p><p data-type="footnote" id="idm46122396935256" class="calibre122"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122396935256-marker" class="pcalibre2 pcalibre calibre123 pcalibre3 pcalibre1">d</a></sup> The dataset is 49,558 KB considering only unique tokens, or 8.742 GB with all tokens.</p></td></tr></tbody></table>

<p class="author1">As a result, whether or not you use probabilistic data structures, you should
always keep in mind what questions you are going to be asking of your data and
how you can most effectively store that data in order to ask those specialized
questions.  This may come down to using one particular type of list over
another, using one particular type of database index over another, or maybe even using
a probabilistic data structure to throw out all but the relevant data!<a data-type="indexterm" data-primary="" data-startref="ram_ch" id="idm46122396933672" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="pds_ex" id="idm46122396932728" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</div></section>





</div></section>







<div data-type="footnotes" class="calibre52"><p data-type="footnote" id="idm46122400697944" class="calibre53"><sup class="calibre54"><a href="ch11_split_000.xhtml#idm46122400697944-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">1</a></sup> This example is taken from the Wikipedia article on the <a href="https://oreil.ly/M_pYe" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">deterministic acyclic finite state automaton</a> (DAFSA). DAFSA is another name for DAWG. The accompanying image is from Wikimedia Commons.</p><p data-type="footnote" id="idm46122399754392" class="calibre53"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122399754392-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">2</a></sup> These numbers come from the 68-95-99.7 rule of Gaussian distributions.  More information can be found in the <a href="http://bit.ly/Gaussian" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Wikipedia entry</a>.</p><p data-type="footnote" id="idm46122399671816" class="calibre53"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122399671816-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">3</a></sup> A more fully fleshed-out implementation that uses an <code class="calibre26">array</code> of bytes to make many counters is available at <a href="https://github.com/ianozsvald/morris_counter" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"><em class="hyperlink">https://github.com/ianozsvald/morris_counter</em></a>.</p><p data-type="footnote" id="idm46122399315416" class="calibre53"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122399315416-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">4</a></sup> Kevin Beyer et al., “On Synopses for Distinct-Value Estimation under Multiset Operations,” in <em class="hyperlink">Proceedings of the 2007 ACM SIGMOD International Conference on Management of Data</em> (New York: ACM, 2007), 199–210, <a href="https://doi.org/10.1145/1247480.1247504" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"><em class="hyperlink">https://doi.org/10.1145/1247480.1247504</em></a>.</p><p data-type="footnote" id="idm46122398960952" class="calibre53"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122398960952-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">5</a></sup> Burton H. Bloom, “Space/Time Trade-Offs in Hash Coding with Allowable Errors,” <em class="hyperlink">Communications of the ACM</em> 13, no. 7 (1970): 422–26, <a href="http://doi.org/10.1145/362686.362692" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"><em class="hyperlink">http://doi.org/10.1145/362686.362692</em></a>.</p><p data-type="footnote" id="idm46122398840536" class="calibre53"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122398840536-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">6</a></sup> The <a href="http://bit.ly/Bloom_filter" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Wikipedia page on Bloom filters</a> has a very simple proof for the properties of a Bloom filter.</p><p data-type="footnote" id="idm46122398750824" class="calibre53"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122398750824-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">7</a></sup> Paolo Sérgio Almeida et al., “Scalable Bloom Filters,” <em class="hyperlink">Information Processing Letters</em> 101, no. 6 (2007) 255–61, <a href="https://doi.org/10.1016/j.ipl.2006.10.007" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"><em class="hyperlink">https://doi.org/10.1016/j.ipl.2006.10.007</em></a>.</p><p data-type="footnote" id="idm46122398488968" class="calibre53"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122398488968-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">8</a></sup> The error values actually decrease like the geometric series.  This way, when you take the product of all the error rates, it approaches the desired error rate.</p><p data-type="footnote" id="idm46122397477912" class="calibre53"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122397477912-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">9</a></sup> A full description of the basic LogLog and SuperLogLog algorithms can be found at <a href="http://bit.ly/algorithm_desc" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"><em class="hyperlink">http://bit.ly/algorithm_desc</em></a>.</p><p data-type="footnote" id="idm46122397252728" class="calibre53"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122397252728-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">10</a></sup> Marianne Durand and Philippe Flajolet, “LogLog Counting of Large Cardinalities,” in <em class="hyperlink">Algorithms—ESA 2003</em>, ed. Giuseppe Di Battista and Uri Zwick, vol. 2832 (Berlin, Heidelberg: Springer, 2003), 605–17, <a href="https://doi.org/10.1007/978-3-540-39658-1_55" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"><em class="hyperlink">https://doi.org/10.1007/978-3-540-39658-1_55</em></a>.</p><p data-type="footnote" id="idm46122397244632" class="calibre53"><sup class="calibre54"><a href="ch11_split_001.xhtml#idm46122397244632-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">11</a></sup> Philippe Flajolet et al., “HyperLogLog: The Analysis of a Near-Optimal Cardinality Estimation Algorithm,” in <em class="hyperlink">AOFA ’07: Proceedings of the 2007 International Conference on Analysis of Algorithms</em>, (AOFA, 2007), 127–46.</p></div></div></section></div>



  </body></html>