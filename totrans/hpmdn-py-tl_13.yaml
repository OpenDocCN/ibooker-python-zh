- en: Chapter 10\. Using Types for Safety and Inspection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十章。使用类型来保证安全和检查
- en: 'What’s a type? As a first approximation, let’s say the *type* of a variable
    specifies the kind of values you can assign to it—​for example, integers or lists
    of strings. When Guido van Rossum created Python, most popular programming languages
    fell into two camps when it came to types: static and dynamic typing.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是什么？作为一个初步的近似，让我们说变量的*类型*指定了你可以分配给它的值的种类——例如整数或字符串列表。当吉多·范·罗苏姆创建Python时，大多数流行的编程语言在类型方面分为两大派别：静态类型和动态类型。
- en: '*Statically typed* languages, like C++, require you to declare the types of
    variables upfront (unless the compiler is smart enough to infer them automatically).
    In exchange, compilers ensure a variable only ever holds compatible values. That
    eliminates entire classes of bugs. It also enables optimizations: compilers know
    how much space the variable needs to store its values.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态类型*语言，如C++，要求您提前声明变量的类型（除非编译器足够智能以自动推断）。作为交换，编译器确保变量只能存储兼容的值。这消除了整个类别的错误。它还能进行优化：编译器知道变量需要多少空间来存储它的值。'
- en: '*Dynamically typed* languages break with this paradigm: they let you assign
    any value to any variable. Scripting languages like Javascript and Perl even convert
    values implicitly—​say, from strings to numbers. This radically speeds up the
    process of writing code. It also gives you more leeway to shoot yourself into
    the foot.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态类型*语言打破了这种范式：它们允许您将任何值赋给任何变量。像Javascript和Perl这样的脚本语言甚至隐式转换值——比如，从字符串到数字。这极大地加快了编写代码的过程。它还给了您更多的自由度来射击自己的脚。'
- en: 'Python is a dynamically typed language, yet it chose a middle ground between
    the opposing camps. Let’s demonstrate its approach with an example:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种动态类型语言，但它选择了两大派别之间的中间路线。让我们用一个例子来演示它的方法：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Python, a variable is just a name for a value. Variables don’t have types—*values*
    do. The program associates the same name, `number`, first with a value of type
    `str`, then with a value of type `float`. But unlike Perl and similar languages,
    Python never converts the values behind your back, in eager anticipation of your
    wishes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，变量只是一个值的名称。变量没有类型——*值*有。程序首先将相同的名称`number`与类型为`str`的值关联起来，然后与类型为`float`的值关联起来。但与Perl和类似语言不同，Python永远不会在您背后转换值，热切地期待您的愿望：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Python isn’t as forgiving as some of its contemporaries, but consider two limitations
    of this type check. First, you won’t see a `TypeError` until you run the offending
    code. Second, the Python interpreter doesn’t raise the error—​the library function
    checks explicitly if something other than an integer or floating-point number
    was passed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python并不像一些同行那样宽容，但请考虑此类型检查的两个限制。首先，在运行有问题的代码之前，您不会看到`TypeError`。其次，Python解释器不会引发错误——库函数显式检查是否传递了除整数或浮点数之外的东西。
- en: 'Most Python functions don’t check the types of their arguments at all. Instead,
    they simply invoke the operations they expect their arguments to provide. Fundamentally,
    the type of a Python object doesn’t matter as long as its behavior is correct.
    Taking inspiration from Vaucanson’s mechanical duck from the times of Louis XV,
    this approach is known as *duck typing*: “If it looks like a duck and quacks like
    a duck, then it must be a duck.”'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Python函数根本不检查它们的参数类型。相反，它们只是调用它们期望其参数提供的操作。从本质上讲，Python对象的类型并不重要，只要其行为正确。这种方法受到路易十五时期沃克松的机械鸭子的启发，被称为*鸭子类型*：“如果它看起来像鸭子，叫起来像鸭子，那么它就是鸭子。”
- en: '![An imaginary depiction of Vaucanson''s Duck published in the _Scientific
    American_ magazin in 1899.](assets/hmpt_10in01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![1899年《科学美国人》杂志上刊登的沃克松的虚构机械鸭图像](assets/hmpt_10in01.png)'
- en: As an example, consider the *join* operation in concurrent code. This operation
    lets you wait until some background work completes, “joining” the threads of control
    back together, as it were. [Example 10-1](#example_typing_duck) defines a duck-typed
    function that invokes `join` on a number of tasks, waiting for each in turn.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑并行代码中的*join*操作。此操作允许您等待直到一些后台工作完成，“加入”控制线程，如此类推。[示例 10-1](#example_typing_duck)定义了一个鸭子类型的函数，依次在多个任务上调用`join`。
- en: Example 10-1\. Duck-typing in action
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-1。鸭子类型的实现
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can use this function with `Thread` or `Process` from the standard `threading`
    or `multiprocessing` modules—​or with any other object that has a `join` method
    with the correct signature. (You can’t use it with strings because `str.join`
    takes an argument—​an iterable of strings.) Duck typing means that these classes
    don’t need a common base class to benefit from reuse. All the types need is a
    `join` method with the correct signature.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`threading`或`multiprocessing`模块中的`Thread`或`Process`——或者任何具有正确签名的`join`方法的其他对象。
    (不能用于字符串，因为`str.join`需要一个字符串可迭代对象作为参数。) 鸭子类型意味着这些类不需要共同的基类来实现重用。这些类型只需要一个正确签名的`join`方法。
- en: 'Duck typing is great because the function and its callers can evolve fairly
    independently—​a property known as *loose coupling*. Without duck typing, a function
    argument has to implement an explicit interface that specifies its behavior. Python
    gives you loose coupling for free: you can pass literally anything, as long as
    it satisfies the expected behavior.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型很棒，因为函数及其调用者可以相对独立地演变——这是一种称为*松耦合*的属性。没有鸭子类型，函数参数必须实现明确规定其行为的显式接口。Python为您免费提供了松耦合：只要它满足预期的行为，您可以传递任何东西。
- en: Unfortunately, this freedom can make some functions hard to understand.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种自由性可能使一些函数难以理解。
- en: 'If you’ve ever had to read an entire codebase to grasp the purpose of a few
    lines within it, you know what I mean: it can be impossible to understand a Python
    function in isolation. Sometimes, the only way to decipher what’s going on is
    to look at its callers, their callers, and so on ([Example 10-2](#example_typing_obscure)).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经不得不阅读整个代码库以了解其中几行代码的目的，你就知道我说的是什么：孤立地理解一个Python函数有时是不可能的。有时，唯一解释正在发生的事情的方法是查看其调用者、它们的调用者等等
    ([示例 10-2](#example_typing_obscure))。
- en: Example 10-2\. An obscure function
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-2\. 一个晦涩的函数
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Writing out the argument and return types of the function—​its type signature—​dramatically
    reduces the amount of context you need to understand the function. Traditionally,
    people have done so by listing the types in a docstring. Unfortunately, docstrings
    are often missing, incomplete, or incorrect. More importantly, there was no formal
    language for describing the types in a precise and verifiable way. And without
    tooling to enforce the type signatures, they amounted to little more than wishful
    thinking.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 写出函数的参数和返回类型——它的类型签名——显著减少了理解函数所需的上下文量。传统上，人们通过在文档字符串中列出类型来做到这一点。不幸的是，文档字符串经常缺失、不完整或不正确。更重要的是，并没有一个正式的语言来精确和可验证地描述类型。没有工具来强制执行类型签名，它们几乎等同于一厢情愿的想法。
- en: While this kind of problem is mildly annoying in a codebase with a few hundred
    lines of code, it quickly turns into an existential threat when you’re dealing
    with many millions of lines of code. Python codebases of this size are common
    at companies like Google, Meta, Microsoft, and Dropbox, all of which sponsored
    the development of static type checkers in the 2010s. A *static type checker*
    is a tool that verifies the type safety of a program without running it. In other
    words, it checks that the program doesn’t perform operations on values that don’t
    support those operations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在几百行代码的代码库中这种问题可能有点恼人，但当您处理数百万行代码时，它很快会变成一种存在威胁。像Google、Meta、Microsoft和Dropbox这样的公司在2010年代赞助了静态类型检查器的开发。*静态类型检查器*是一种工具，它在不运行程序的情况下验证程序的类型安全性。换句话说，它检查程序是否在不支持这些操作的值上执行操作。
- en: To some extent, type checkers can deduce the type of a function or variable
    automatically, using a process called *type inference*. They become much more
    powerful when you give programmers a way to specify types explicitly in their
    code. By the middle of the last decade, and thanks in particular to the foundational
    work of Jukka Lehtosalo and collaborators,^([1](ch10.html#id323)) the Python language
    acquired a way to express the types of functions and variables in source code,
    called *type annotations* ([Example 10-3](#example_typing_simple)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，类型检查器可以自动推断函数或变量的类型，使用一种称为*类型推断*的过程。当程序员能够在他们的代码中显式指定类型时，它们变得更加强大。由于上世纪中期的基础工作，特别是由Jukka
    Lehtosalo及其合作者的工作，^([1](ch10.html#id323)) Python语言获得了一种在源代码中表达函数和变量类型的方式，称为*类型注解*
    ([示例 10-3](#example_typing_simple))。
- en: Example 10-3\. A function with type annotations
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-3\. 带有类型注解的函数
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Type annotations have become the foundation of a rich ecosystem of developer
    tools and libraries.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解已成为丰富的开发工具和库生态系统的基础。
- en: On their own, type annotations mostly don’t affect the runtime behavior of a
    program. The interpreter doesn’t check that assignments are compatible with the
    annotated type; it merely stores the annotation inside the special `__annotations__`
    attribute of the containing module, class, or function. While this incurs a small
    overhead at runtime, it means you can inspect type annotations at runtime to do
    exciting stuff—​say, construct your domain objects from values transmitted on
    the wire, without any boilerplate.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 单独看，类型注解主要不会影响程序的运行时行为。解释器不会检查赋值是否与注释的类型兼容；它只是将注释存储在包含模块、类或函数的特殊`__annotations__`属性中。虽然这会在运行时产生一些小的开销，但这意味着您可以在运行时检查类型注解，从而进行一些有趣的操作——比如说，根据传输到网络的值构建您的域对象，而无需任何样板文件。
- en: 'One of the most important uses of type annotations, though, doesn’t happen
    at runtime: static type checkers, like mypy, use them to verify the correctness
    of your code without running it.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解的最重要用途之一是在运行时不会发生：静态类型检查器（如mypy）使用它们来验证代码的正确性，而不必运行代码。
- en: Benefits and Costs of Type Annotations
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型注解的利与弊
- en: You don’t have to use type annotations yourself to benefit from them. Type annotations
    are available for the standard library and many PyPI packages. Static type checkers
    can warn you when you use a module incorrectly, including when a breaking change
    in the library means your code no longer works with that library—​and type checkers
    can warn you *before* you run your code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必自己使用类型注解也能从中受益。类型注解已经为标准库和许多PyPI包提供。静态类型检查器可以在您使用模块不正确时警告您，包括当库中的重大更改导致您的代码不再与该库一起正常工作时——而类型检查器可以在运行代码之前警告您。
- en: Editors and IDEs leverage type annotations to give you a better coding experience,
    with auto-completion, tooltips, and class browsers. You can also inspect type
    annotations at runtime, unlocking powerful features such as data validation and
    serialization.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器和IDE利用类型注解为您提供更好的编码体验，包括自动完成、工具提示和类浏览器。您还可以在运行时检查类型注解，解锁诸如数据验证和序列化等强大功能。
- en: If you use type annotations in your own code, you reap more benefits. First,
    you’re also a user of your own functions, classes, and modules—​so all the benefits
    above apply, like auto-completion and type checking. Additionally, you’ll find
    it easier to reason about your code, refactor it without introducing subtle bugs,
    and build a clean software architecture. As a library author, typing lets you
    specify an interface contract on which your users can rely, while you’re free
    to evolve the implementation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在自己的代码中使用类型注解，您将获得更多好处。首先，您也是自己函数、类和模块的用户——因此，以上所有的好处也适用，例如自动完成和类型检查。此外，您会发现更容易理解您的代码、在不引入微妙错误的情况下重构它，并构建清晰的软件架构。作为库的作者，类型注解允许您指定用户可以依赖的接口契约，而您则可以自由演化实现。
- en: Even a decade after their introduction, type annotations aren’t free of controversy—​maybe
    understandably so, given Python’s proud stance as a dynamically typed language.
    Adding types to existing code poses similar challenges as introducing unit tests
    to a codebase that wasn’t written with testing in mind. Just as you may need to
    refactor for testability, you may need to refactor for “typability”—replacing
    deeply nested primitive types and highly dynamic objects with simpler and more
    predictable types. You’ll likely find it worth the effort.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在它们引入十年后，类型注解仍然不乏争议——这或许是可以理解的，考虑到Python自豪地作为动态类型语言的立场。在现有代码中添加类型与将单元测试引入不考虑测试的代码库面临相似的挑战。正如您可能需要重构以增强可测试性一样，您可能需要重构以增强“可类型化性”——用更简单、更可预测的类型替换深度嵌套的原始类型和高度动态的对象。您很可能会发现这是值得努力的。
- en: Another challenge is the rapid evolution of the Python typing language. These
    days, Python type annotations are governed by the Typing Council, which maintains
    a single, living specification of the typing language.^([2](ch10.html#id324))
    You can expect this specification to undergo more substantial changes over the
    coming years. While typed Python code needs to navigate this evolution, the typing
    language makes no exceptions to Python’s backward compatibility policy.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挑战是Python类型语言的快速演变。如今，Python类型注解受到Typing Council的管辖，该组织维护着类型语言的单一、持续更新的规范。^([2](ch10.html#id324))
    未来几年内，预计这一规范将会经历更大的变化。虽然带类型的Python代码需要适应这一演变，但类型语言对Python的向后兼容政策没有例外。
- en: In this chapter, you’ll learn how to verify the type safety of your Python programs
    using the static type checker mypy and the runtime type checker Typeguard. You’ll
    also see how runtime inspection of type annotations can greatly enhance the functionality
    of your programs. But first, let’s take a look at the typing language that has
    evolved within Python over the past decade.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用静态类型检查器mypy和运行时类型检查器Typeguard来验证你的Python程序的类型安全性。你还将看到如何通过运行时检查类型注解来极大地增强程序的功能。但首先，让我们来看看在过去十年内在Python中演变的类型语言。
- en: A Brief Tour of Python’s Typing Language
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python类型语言的简要介绍
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Try out the small examples in this section on one of the type-checker playgrounds:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在此节中的一个类型检查器playground中尝试一些小例子：
- en: the [mypy Playground](https://mypy-play.net/)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[mypy Playground](https://mypy-play.net/)'
- en: the [pyright Playground](https://pyright-play.net/)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pyright Playground](https://pyright-play.net/)'
- en: the [pyre Playground](https://pyre-check.org/play)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pyre Playground](https://pyre-check.org/play)'
- en: Variable Annotations
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量注解
- en: 'You can annotate a variable with the type of values that it may be assigned
    during the course of the program. The syntax for such type annotations consists
    of the variable name, a colon, and a type:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序运行过程中，你可以使用类型注解为变量指定可能分配的值的类型。此类类型注解的语法由变量名、冒号和类型组成：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Besides the simple built-in types like `bool`, `int`, `float`, `str`, or `bytes`,
    you can also use standard container types in type annotations, such as `list`,
    `tuple`, `set`, or `dict`. For example, here’s how you might initialize a variable
    used to store a list of lines read from a file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像`bool`、`int`、`float`、`str`或`bytes`这样的简单内置类型外，你还可以在类型注解中使用标准的容器类型，例如`list`、`tuple`、`set`或`dict`。例如，以下是如何初始化一个用于存储从文件中读取的行的列表变量的示例：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While the previous example was somewhat redundant, this one provides actual
    value: Without the type annotation, the type checker can’t deduce that you want
    to store strings in the list.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子有些多余，但这个例子提供了实际价值：没有类型注解，类型检查器无法推断你想要将字符串存储在列表中。
- en: 'The built-in containers are examples of *generic types*—types that take one
    or more arguments. Here’s an example of a dictionary mapping strings to integers.
    The two arguments of `dict` specify the key and value types, respectively:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 内置容器是*泛型类型*的示例——即接受一个或多个参数的类型。以下是将字符串映射到整数的字典示例。`dict`的两个参数分别指定键和值的类型：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Tuples are a bit special, because they come in two flavors. Tuples can be a
    combination of a fixed number of types, such as a pair of a string and int:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 元组有些特别，因为它们有两种形式。元组可以是固定数量类型的组合，例如字符串和整数对：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another example of this flavor holds coordinates in three-dimensional space:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例涉及在三维空间中保存坐标的情况：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The other common use of tuples is as an immutable sequence of arbitrary length.
    To accomodate for this, the typing language lets you write an ellipsis for zero
    or more items of the same type. For example, here’s a tuple that can hold any
    number of integers (including none at all):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种元组的常见用途是作为不可变的任意长度序列。为此，类型语言允许你为相同类型的零个或多个项目编写省略号。例如，以下是一个可以保存任意数量整数的元组（包括一个也没有）：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Any class you define in your own Python code is also a type:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你在自己的Python代码中定义的任何类也是一种类型：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Subtype Relation
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子类型关系
- en: The types on both sides of an assignment aren’t necessarily identical. In the
    example above, you assign a `NorwegianBlue` value to a `Parrot` variable. This
    works because a Norwegian Blue is a kind of parrot—​or technically speaking, because
    `NorwegianBlue` is a subclass of `Parrot`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值语句两边的类型不一定相同。在上面的示例中，你将`NorwegianBlue`值分配给`Parrot`变量。这是有效的，因为挪威蓝是鹦鹉的一种——或者从技术上讲，因为`NorwegianBlue`是`Parrot`的子类。
- en: In general, the Python typing language requires that the type on the right-hand
    side of a variable assignment be a *subtype* of the type on the left-hand side.
    A prime example of the subtype relation is the relationship of a subclass to its
    base class, like `NorwegianBlue` and `Parrot`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，Python类型语言要求变量赋值右侧的类型是左侧类型的*子类型*。一个典型的子类型关系例子是子类与其基类的关系，比如`NorwegianBlue`和`Parrot`。
- en: However, subtypes are a more general concept than subclasses. For example, a
    tuple of ints (like `numbers` above) is a subtype of a tuple of objects. Unions,
    introduced in the next section, are yet another example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，子类型是一个比子类更一般的概念。例如，整数元组（如上面的`numbers`）是对象元组的一个子类型。下一节介绍的联合类型是另一个例子。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Typing rules also permit assignments if the type on the right is *consistent*
    with that on the left. This lets you assign an `int` to a `float`, even though
    `int` isn’t derived from `float`. The `Any` type is consistent with any other
    type (see [“Gradual Typing”](#section_typing_gradual)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类型规则还允许在右侧类型与左侧类型*一致*时进行赋值。这使你可以将`int`赋给`float`，即使`int`不是`float`的派生类。`Any`类型与任何其他类型都一致（参见[“逐步类型化”](#section_typing_gradual)）。
- en: Union Types
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合类型
- en: 'You can combine two types using the pipe operator (`|`) to construct a *union
    type*, which is a type whose values range over all the values of its constituent
    types. For example, you can use it for a user ID that’s either numeric or a string:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道操作符（`|`）可以组合两种类型来构造*联合类型*，这种类型的值可以是其组成类型的任意值。例如，你可以将其用于用户ID，其值可以是数字或字符串：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Arguably the most important use of the union type is for “optional” values,
    where the missing value is encoded by `None`. Here’s an example where a description
    is read from a *README*, provided that the file exists:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型的一个最重要的用途是处理“可选”值，其中缺失的值用`None`来编码。以下是一个例子，从*README*中读取描述，前提是文件存在：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Union types are another example for the subtype relation: Each type involved
    in the union is a subtype of the union. For example, `str` and `None` are each
    subtypes of the union type `str | None`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型是子类型关系的另一个例子：联合中涉及的每种类型都是联合的子类型。例如，`str`和`None`分别是联合类型`str | None`的子类型。
- en: I skipped over `None` above when discussing the built-in types. Strictly speaking,
    `None` is a value, not a type. The type of `None` is called `NoneType`, and it’s
    available from the standard `types` module. For convenience, Python lets you write
    `None` in annotations to refer to the type, as well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面讨论内置类型时，我跳过了`None`。严格来说，`None`是一个值，不是一个类型。`None`的类型称为`NoneType`，可以从标准`types`模块中获取。为了方便起见，Python允许你在注释中使用`None`来指代这种类型。
- en: Tony Hoare, a British computer scientist who has made foundational contributions
    to many programming languages, famously called the invention of null references,
    or `None`, his “billion-dollar mistake”, due to the number of bugs they’ve caused
    since their introduction in `ALGOL` in 1965\. If you’ve ever seen a system crash
    with an error like the following, you may agree with him. (Python raises this
    error if you attempt to access an attribute on an object that’s in fact `None`.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 托尼·霍尔（Tony Hoare），一位对许多编程语言做出基础性贡献的英国计算机科学家，因其发明的空引用或`None`而被称为“十亿美元的错误”，因为自1965年在`ALGOL`中引入以来它们导致的bug数量。如果你曾经看到系统因为访问一个实际上为`None`的对象属性而崩溃，可能会同意他的看法。
    （如果你尝试访问一个实际上为`None`的对象属性时，Python会引发此错误。）
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The good news is that type checkers can warn you when you’re using a variable
    that’s potentially `None`. This can greatly reduce the risk of crashes in production
    systems.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是类型检查器可以在你使用可能为`None`的变量时发出警告。这可以大大减少生产系统中崩溃的风险。
- en: 'How do you tell the type checker that your use of `description` is fine? Generally,
    you should just check that the variable isn’t `None`. The type checker will pick
    up on this and allow you to use the variable:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如何告诉类型检查器你对`description`的使用是正确的？一般来说，你应该检查变量不是`None`。类型检查器会注意到这一点并允许你使用该变量：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are several methods for *type narrowing*, as this technique is known.
    I won’t discuss them all in detail here. As a rule of thumb, the control flow
    must only reach the line in question when the value has the right type—​and type
    checkers must be able to infer this fact from the source code. For example, you
    could also use the `assert` keyword with a built-in function like `isinstance`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种 *类型缩小* 的方法，这就是这种技术的称呼。我不会在这里详细讨论它们。作为经验法则，控制流仅在值具有正确类型时才会到达所在行——并且类型检查器必须能够从源代码推断出这一事实。例如，你还可以使用
    `assert` 关键字与内置函数如 `isinstance`：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you already *know* that the value has the right type, you can help out the
    type checker using the `cast` function from the `typing` module:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经 *知道* 值具有正确的类型，你可以使用 `typing` 模块的 `cast` 函数来帮助类型检查器：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At runtime, the `cast` function just returns its second argument. Unlike `isinstance`,
    it works with arbitrary type annotations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，`cast` 函数只是返回其第二个参数。与 `isinstance` 不同，它可以处理任意类型的注解。
- en: Gradual Typing
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渐进式类型化
- en: In Python, every type ultimately derives from `object`. This is true for user-defined
    classes and primitive types alike, even for types like `int` or `None`. In other
    words, `object` is a *universal supertype* in Python—​you can assign literally
    anything to a variable of this type.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，每种类型最终都派生自 `object`。这对于用户定义的类和原始类型都是如此，即使对于诸如 `int` 或 `None` 这样的类型也是如此。换句话说，`object`
    是 Python 中的 *通用超类型*——你可以将任何东西都赋给此类型的变量。
- en: 'This may sound kind of powerful, but it really isn’t. In terms of behavior,
    `object` is the smallest common denominator of all Python values, so there’s precious
    little you can do with it, as far as type checkers are concerned:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能很强大，但实际上并非如此。在行为方面，`object` 是所有 Python 值的最小公共分母，所以在类型检查器的视角下，你几乎无法使用它：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There’s another type in Python that, like `object`, can hold any value. It’s
    called `Any` (for obvious reasons) and it’s available from the standard `typing`
    module. When it comes to behavior, `Any` is `object`’s polar opposite. You can
    invoke any operation on a value of type `Any`—conceptually, it behaves like the
    intersection of all possible types. `Any` serves as an escape hatch that lets
    you opt out of type checking for a piece of code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中还有一种类型，像 `object` 一样，可以容纳任何值。它称为 `Any`（理由显而易见），并且可以从标准的 `typing` 模块中获取。就行为而言，`Any`
    是 `object` 的完全对立面。你可以对 `Any` 类型的值执行任何操作，概念上来说，它表现为所有可能类型的交集。`Any` 充当了一个逃生口，让你可以选择在某段代码中不进行类型检查：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the first example, the `object` type results in a false positive: the code
    works at runtime, but type checkers will reject it. In the second example, the
    `Any` type results in a false negative: the code crashes at runtime, but type
    checkers won’t flag it.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，`object` 类型导致了一个假阳性：代码在运行时有效，但类型检查器会拒绝它。在第二个例子中，`Any` 类型导致了一个假阴性：代码在运行时崩溃，但类型检查器不会标记它。
- en: Warning
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: When you’re working in typed Python code, watch out for `Any`. It can disable
    type-checking to a surprising degree. For example, if you access attributes or
    invoke operations on `Any` values, you’ll end up with more `Any` values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类型化的 Python 代码中工作时，要注意 `Any`。它可以在相当大的程度上禁用类型检查。例如，如果你访问 `Any` 值的属性或调用操作，你最终会得到更多的
    `Any` 值。
- en: The `Any` type is Python’s hat trick that lets you restrict type checking to
    portions of a codebase—​formally known as *gradual typing*. In variable assignments
    and function calls, `Any` is consistent with every other type, and every type
    is consistent with it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any` 类型是 Python 的法宝，它允许你将类型检查限制在代码库的部分区域内，正式称为 *渐进式类型化*。在变量赋值和函数调用中，`Any`
    与任何其他类型保持一致，而每种类型也与它保持一致。'
- en: There are at least a couple of reasons why gradual typing is valuable. First,
    Python existed without type annotations for two decades, and Python’s governing
    body has no intentions to make type annotations obligatory. Therefore, typed and
    untyped Python will coexist for the foreseeable future. Second, Python’s strength
    comes in part from its ability to be highly dynamic where needed—​for example,
    Python makes it easy to assemble or even modify classes on the fly. In some cases,
    it’s hard (or outright impossible) to apply strict types to such highly dynamic
    code.^([3](ch10.html#id325))
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进式类型化之所以有价值，至少有几个原因。首先，Python 在两十年间不存在类型注解，而且 Python 的管理机构没有意图要强制类型注解。因此，有类型和无类型的
    Python 将在可预见的未来共存。其次，Python 的优势部分来自于其在需要时能够高度动态化——例如，Python 让动态组装甚至修改类变得容易。在某些情况下，对这种高度动态代码应用严格的类型可能很困难（甚至根本不可能）。^([3](ch10.html#id325))
- en: Function Annotations
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数注解
- en: 'As you may recall from [Example 10-3](#example_typing_simple), type annotations
    for function arguments look quite similar to those for variables. Return types,
    on the other hand, are introduced with a right arrow instead of a colon—​after
    all, the colon already introduces the function body in Python. For example, here’s
    a type-annotated function for adding two numbers:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能从 [示例 10-3](https://example.org/example_typing_simple) 中记得的那样，函数参数的类型注解看起来与变量的注解非常相似。而返回类型则使用右箭头而不是冒号—毕竟，冒号已经在
    Python 中引入了函数体。例如，这里是一个类型注解的函数用于添加两个数字：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Python functions that don’t include a `return` statement implicitly return
    `None`. You might expect return type annotations to be optional in this case,
    too. This is not the case! As a general rule, always specify the return type when
    annotating a function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Python 函数如果不包含`return`语句，则隐式返回`None`。你可能期望在这种情况下返回类型注解是可选的。但事实并非如此！作为一般准则，总是在注解函数时指定返回类型：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Type checkers assume that a function without a return type returns `Any`. Likewise,
    function parameters without annotations default to `Any`. Effectively, this disables
    type checking for the function—​exactly the behavior you’d want in a world with
    large bodies of untyped Python code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器假定没有返回类型的函数返回`Any`。同样，没有注解的函数参数默认为`Any`。这有效地禁用了对函数的类型检查—在一个大量未类型化的 Python
    代码的世界中，这正是你想要的行为。
- en: 'Let’s take a look at a slightly more involved function signature:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个稍微复杂的函数签名：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Parameters with default arguments, like `check`, use a syntax similar to variable
    assignments. The `*args` parameter holds the tuple of positional arguments—​each
    argument must be a `str`. The `**kwargs` parameter holds the dictionary of keyword
    arguments—​using `Any` means that the keyword arguments aren’t restricted to any
    specific type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 具有默认参数的参数，例如`check`，使用类似变量赋值的语法。`*args`参数持有位置参数的元组—每个参数必须是`str`。`**kwargs`参数持有关键字参数的字典—使用`Any`意味着关键字参数不限于任何特定类型。
- en: 'In Python, you can use `yield` inside a function to define a *generator*, which
    is an object that produces a series of values you can use in a `for` loop. Generators
    support some behavior beyond iteration; when used only for iteration, they’re
    known as *iterators*. Here’s how you’d write their type:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你可以在函数内部使用`yield`来定义一个*生成器*，它是一个可以在`for`循环中产生一系列值的对象。生成器支持一些超出迭代的行为；当仅用于迭代时，它们被称为*迭代器*。以下是如何写出它们的类型：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Functions are first-class citizens in Python. You can assign a function to
    a variable or pass it to another function—​for example, to register a callback.
    Consequently, Python lets you express the type of a function outside of a function
    definition. `Callable` is a generic type takes two arguments—​a list of parameter
    types and the return type:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在 Python 中是一等公民。你可以将函数赋给一个变量或传递给另一个函数—例如用于注册回调。因此，Python 允许你在函数定义外表达函数的类型。`Callable`是一个泛型类型，接受两个参数—参数类型的列表和返回类型：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Annotating Classes
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注解类
- en: 'The rules for variable and function annotations also apply in the context of
    class definitions, where they describe instance variables and methods. You can
    omit the annotation for the `self` argument in a method. Type checkers can infer
    instance variables from assignments in a `__init__` method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和函数注解的规则也适用于类定义的上下文中，它们描述了实例变量和方法。在方法中，可以省略对`self`参数的注解。类型检查器可以从在`__init__`方法中的赋值推断出实例变量。
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The standard `dataclasses` module generates the canonical method definitions
    from the type annotations of any class decorated with `@dataclass`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`dataclasses`模块会从任何用`@dataclass`装饰的类的类型注解生成规范的方法定义：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The dataclass-style definition isn’t only more concise than the handwritten
    one, it also confers the class additional runtime behavior—​such as the ability
    to compare instances for equality based on their attributes, or to order them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: dataclass 风格的定义不仅比手写的更简洁，还赋予了类额外的运行时行为—比如能够根据其属性比较实例的相等性，或者对它们进行排序。
- en: 'When you’re annotating classes, the problem of forward references often appears.
    Consider a two-dimensional point, with a method to compute its Euclidean distance
    from another point:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为类进行注解时，前向引用问题经常会出现。考虑一个二维点，带有一个计算其与另一点欧几里德距离的方法：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: While type checkers are happy with this definition, the code raises an exception
    when you run it with the Python interpreter:^([4](ch10.html#id326))
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管类型检查器对此定义感到满意，但是当你在Python解释器中运行时，代码会引发异常：^([4](ch10.html#id326))
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Python doesn’t let you use `Point` in the method definition, because you’re
    not done defining the class—​the name doesn’t exist yet. There are several ways
    to resolve this situation. First, you can write the forward reference as a string
    to avoid the `NameError`, a technique known as *stringized* annotations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Python不允许你在方法定义中使用`Point`，因为你还没有完成类的定义，该名称尚不存在。有几种方法可以解决这种情况。首先，你可以将前向引用写为字符串，以避免`NameError`，这种技术称为*字符串化*注解。
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Second, you can implicitly stringize all annotations in the current module
    using the `annotations` future import:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你可以通过`annotations`未来引入隐式字符串化当前模块中的所有注解：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The third method does not help with all forward references, but it does here.
    You can use the special `Self` type to refer to the current class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法不适用于所有前向引用，但在这里适用。你可以使用特殊的`Self`类型来引用当前类：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Beware of a semantic difference in this third version compared to the earlier
    ones. If you derived a `SparklyPoint` class from `Point`, `Self` would refer to
    the derived class rather than the base class. In other words, you wouldn’t be
    able to compute the distance of sparkly points from plain old points.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这第三个版本中与之前的版本相比要注意语义上的差异。如果你从`Point`类派生出一个`SparklyPoint`类，`Self`将指代派生类而不是基类。换句话说，你无法计算闪光点到普通点的距离。
- en: Type Aliases
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型别名
- en: You can use the `type` keyword to introduce an alias for a type:^([5](ch10.html#id327))
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`type`关键字为类型引入一个别名：^([5](ch10.html#id327))
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This technique is useful to make your code self-documenting, and to keep it
    readable when the types become unwieldy, as they sometimes do. Type aliases also
    let you define types that would otherwise be impossible to express. Consider an
    inherently recursive data type such as a JSON object:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型变得笨重时，这种技术对于使你的代码自我描述和保持可读性非常有用。类型别名还允许你定义否则无法表达的类型。考虑一个本质上递归的数据类型，如JSON对象：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Recursive type aliases are another example of forward references. If your Python
    version doesn’t yet support the `type` keyword, you’ll need to replace `JSON`
    with `"JSON"` on the right-hand side to avoid a `NameError`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 递归类型别名是前向引用的另一个示例。如果你的Python版本尚未支持`type`关键字，你需要在右侧将`JSON`替换为`"JSON"`，以避免`NameError`。
- en: Generics
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型
- en: 'As you’ve seen at the beginning of this section, built-in containers like `list`
    are generic types. You can also define generic functions and classes yourself,
    and it’s quite straightforward to do so. Consider a function that returns the
    first item in a list of strings:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本节开头看到的那样，像`list`这样的内置容器是泛型类型。你还可以自己定义泛型函数和类，这非常简单。考虑一个返回字符串列表中第一个项目的函数：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There’s no reason to restrict the element type to a string: the logic doesn’t
    depend on it. Let’s make the function generic for all types. First, replace `str`
    with the placeholder `T`. Second, mark the placeholder as a *type variable* by
    declaring it in square brackets after the function name. (The name `T` is just
    a convention, you could name it anything.) Additionally, there’s no reason to
    restrict the function to lists, because it works with any type over which you
    can iterate in a `for` loop—​in other words, any *iterable*.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由将元素类型限制为字符串：逻辑不依赖于此。让我们将函数泛化到所有类型。首先，用占位符`T`替换`str`。其次，通过在函数名后方括号中声明占位符作为*类型变量*。
    （`T`只是一种约定，你可以使用任何名称。）此外，没有理由将函数限制为列表，因为它适用于任何你可以在`for`循环中迭代的类型，换句话说，任何*可迭代*对象。
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s how you might use the generic function in your code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在代码中如何使用泛型函数的方式：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can omit the variable annotations for `fruit` and `number`, by the way—​type
    checkers infer them from the annotation of your generic function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在泛型函数的注解中省略`fruit`和`number`的变量注释，类型检查器会从泛型函数的注解中推断它们。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Generics with the `[T]` syntax are supported in Python 3.12+ and the Pyright
    type checker. If you get an error, omit the `[T]` suffix from `first` and use
    `TypeVar` from the `typing` module:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.12+和Pyright类型检查器支持使用`[T]`语法的泛型。如果出现错误，请省略`first`的`[T]`后缀，并使用`typing`模块中的`TypeVar`：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Protocols
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议
- en: The `join_all` function from [Example 10-1](#example_typing_duck) works with
    threads, processes, or any other objects you can join. Duck typing makes your
    functions simple and reusable. But how can you verify the implicit contract between
    the functions and their callers?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[示例 10-1](#example_typing_duck)的 `join_all` 函数可以与线程、进程或其他任何可以加入的对象一起工作。鸭子类型使得您的函数简单且可重用。但是如何验证函数与其调用者之间的隐式契约呢？
- en: '*Protocols* bridge the gap between duck typing and type annotations. A protocol
    describes the behavior of an object, without requiring the object to inherit from
    it. It looks somewhat like an *abstract base class*—a base class that doesn’t
    implement any methods:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*协议* 消除了鸭子类型和类型注解之间的差距。协议描述了对象的行为，而无需对象从其继承。它看起来有些像 *抽象基类* —— 一个不实现任何方法的基类：'
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `Joinable` protocol requires the object to have a `join` method that takes
    no arguments and returns `None`. The `join_all` function can use the protocol
    to specify which objects it supports:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Joinable` 协议要求对象具有一个不接受参数且返回 `None` 的 `join` 方法。 `join_all` 函数可以使用该协议来指定其支持的对象：'
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Remarkably, this piece of code works with standard library types like `Thread`
    or `Process`, even though they don’t have any knowledge of your `Joinable` protocol—​a
    prime example of loose coupling.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，尽管标准库类型如 `Thread` 或 `Process` 并不了解您的 `Joinable` 协议，但此代码片段仍然能够正常工作 ——
    这是松耦合的一个典型例子。
- en: 'This technique is known as *structural subtyping*: it’s the internal structure
    of `Thread` and `Process` that makes them subtypes of `Joinable`. By contrast,
    *nominal subtyping* requires you to derive the subtype from the supertype explicitly.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为 *结构子类型化*：`Thread` 和 `Process` 的内部结构使它们成为 `Joinable` 的子类型。相比之下，*名义子类型化*
    要求您明确地从超类型派生子类型。
- en: Compatibility with Older Python Versions
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与旧版 Python 的兼容性
- en: The description above is based on the latest Python release as of this writing,
    Python 3.12\. [Table 10-1](#table_typing_compatibility) lists typing features
    that aren’t yet available on older Python versions, as well as their replacements
    in those versions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述描述基于撰写本文时的最新 Python 发行版，即 Python 3.12。[表 10-1](#table_typing_compatibility)
    列出了在旧版 Python 中尚不可用的 typing 特性及其在这些版本中的替代方案。
- en: Table 10-1\. Availability of Typing Features
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Table 10-1\. Typing 特性的可用性
- en: '| Feature | Example | Availability | Replacement |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 示例 | 可用性 | 替代方案 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| generics in standard collections | `list[str]` | Python 3.9 | `typing.List`
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 标准集合中的泛型 | `list[str]` | Python 3.9 | `typing.List` |'
- en: '| union operator | `str &#124; int` | Python 3.10 | `typing.Union` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 联合操作符 | `str &#124; int` | Python 3.10 | `typing.Union` |'
- en: '| Self type | `Self` | Python 3.11 | `typing_extensions.Self` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 自类型 | `Self` | Python 3.11 | `typing_extensions.Self` |'
- en: '| `type` keyword | `type UserID = ...` | Python 3.12 | `typing.TypeAlias` (Python
    3.10) |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `type` 关键字 | `type UserID = ...` | Python 3.12 | `typing.TypeAlias`（Python
    3.10） |'
- en: '| type parameter syntax | `def first[T](...)` | Python 3.12 | `typing.TypeVar`
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 类型参数语法 | `def first[T](...)` | Python 3.12 | `typing.TypeVar` |'
- en: The `typing-extensions` library provides backports for many features not available
    in older Python versions, see [“Automating mypy with Nox”](#section_typing_nox).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing-extensions` 库为许多在旧版 Python 中不可用的特性提供了后向兼容，参见[“使用 Nox 自动化 mypy”](#section_typing_nox)。'
- en: This concludes our brief tour of Python’s typing language. While there’s a lot
    more to typing in Python, I hope that this overview has taught you enough to make
    deeper forays into the exciting world of typing on your own.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对 Python typing 语言的简要介绍。虽然 Python 的类型检查还有很多内容，但我希望本概述已经教会您足够的知识，让您能够深入探索类型检查的激动人心世界。
- en: Static Type Checking with mypy
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 mypy 进行静态类型检查
- en: Mypy is a widely used static type checker for Python. A static type checker
    uses type annotations and type inference to detect bugs in a program without running
    it. Mypy was the original reference implementation when the typing system was
    codified in PEP 484\. This doesn’t mean that mypy is always the first type checker
    to implement a new feature of the typing language—​for example, the `type` keyword
    was first implemented in Pyright. However, it’s certainly a good default choice,
    and core members of the typing community are involved in its development.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy 是广泛使用的 Python 静态类型检查器。静态类型检查器利用类型注解和类型推断来在程序运行之前检测错误。Mypy 是在 PEP 484 中将类型系统规范化时的原始参考实现。这并不意味着
    mypy 总是第一个实现 typing 语言新特性的类型检查器 —— 例如，`type` 关键字首次在 Pyright 中实现。然而，它确实是一个很好的默认选择，typing
    社区的核心成员参与了其开发。
- en: First Steps with mypy
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mypy 的第一步
- en: 'Add mypy to the development dependencies of your project—​for example, by adding
    a `typing` extra:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将mypy添加到项目的开发依赖项中，例如通过添加一个`typing`额外：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can now install mypy in the project environment:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在项目环境中安装mypy：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you use Poetry, add mypy to your project using `poetry add`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Poetry，请使用`poetry add`将mypy添加到项目中：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, run mypy on the *src* directory of your project:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在项目的*src*目录上运行mypy：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s type-check some code with a type-related bug. Consider the following
    program, which passes `None` to a function that expects a string:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用带有类型相关错误的代码进行类型检查。考虑以下程序，它将`None`传递给期望字符串的函数：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you run mypy on this code, it dutifully reports that the argument in the
    call to `textwrap.fill` isn’t guaranteed to be a string:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在此代码上运行mypy，则它将忠实地报告在调用`textwrap.fill`时，参数不保证是一个字符串：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Revisiting the Wikipedia Example
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新访问维基百科示例
- en: Let’s revisit the Wikipedia API client from [Example 6-3](ch06.html#example_testing_refactored).
    In a fictional scenario, sweeping censorship laws have been passed. Depending
    on the country you’re connecting from, the Wikipedia API omits the article summary.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从[示例6-3](ch06.html#example_testing_refactored)重新审视维基百科API客户端。在一个虚构的场景中，通过了广泛的审查法规。根据您所连接的国家，维基百科API可能会省略文章摘要。
- en: 'You could store an empty string when this happens. But let’s be principled:
    An empty summary isn’t the same as no summary at all. Let’s store `None` when
    the response omits the field.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生这种情况时，您可以存储一个空字符串。但让我们遵循原则：一个空摘要并不等同于没有摘要。当响应省略该字段时，让我们存储`None`。
- en: As a first step, change the `summary` default to `None` instead of an empty
    string. Use a union type to signal that the field can hold `None` instead of a
    string.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，将`summary`默认更改为`None`，而不是空字符串。使用联合类型来表明该字段可以容纳`None`而不是字符串。
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A few lines below, the `show` function reformats the summary to ensure a line
    length of 72 characters or fewer:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的几行中，`show`函数重新格式化摘要，以确保每行不超过72个字符：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Presumably, mypy will balk at this error, just like it did above. Yet, when
    you run it on the file, it’s all sunshine. Can you guess why?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 据推测，mypy会对这个错误提出异议，就像之前一样。但是，当你在文件上运行它时，一切都很顺利。你能猜到为什么吗？
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Mypy doesn’t complain about the call because the `article` parameter doesn’t
    have a type annotation. It considers `article` to be `Any`, so the expression
    `article.summary` also becomes `Any`. (`Any` is infectious.) As far as mypy is
    concerned, that expression can be `str`, `None`, and a pink elephant, all at the
    same time. This is gradual typing in action, and it’s also why you should be wary
    of `Any` types and missing annotations in your code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy不会对调用抱怨，因为`article`参数没有类型注释。它认为`article`是`Any`，因此表达式`article.summary`也变成了`Any`。（`Any`是具有传染性的。）就mypy而言，该表达式可以同时是`str`、`None`和一只粉色大象。这是渐进类型在起作用，也是为什么您应该警惕在代码中使用`Any`类型和缺少注释的原因。
- en: 'You can help mypy detect the error by annotating the parameter as `article:
    Article`. Try actually fixing the bug, as well—​think about how you would handle
    the case of summaries being `None` in a real program. Here’s one way to solve
    this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以通过将参数注释为`article: Article`来帮助mypy检测错误。实际上尝试修复错误，考虑如何处理真实程序中的摘要为`None`的情况。以下是一种解决方法：'
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Strict Mode
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格模式
- en: 'Mypy defaults to gradual typing by treating parameters and return values as
    `Any` if they don’t have type annotations. Turn on strict mode in *pyproject.toml*
    to opt out of this lenient default:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不对函数进行类型注释，则mypy默认将参数和返回值视为`Any`，将其视为渐进类型的一部分。在*pyproject.toml*中打开严格模式以退出这种宽松的默认设置：
- en: '[PRE50]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `strict` setting changes the defaults of a dozen-odd more fine-grained settings.
    If you run mypy on the module again, you’ll notice that the type checker has become
    a lot more opinionated about your code. In strict mode, both defining and calling
    untyped functions will result in an error.^([6](ch10.html#id328))
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`strict`设置更改了十多个更精细的设置的默认值。如果您再次在模块上运行mypy，您会注意到类型检查器对您的代码变得更加主观。在严格模式下，定义和调用未注释函数将导致错误。^([6](ch10.html#id328))'
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[Example 10-4](#example_typing_wikipedia) shows the module with type annotations
    and introduces two concepts you haven’t seen yet. First, the `Final` annotation
    marks `API_URL` as a constant—​a variable to which you can’t assign another value.
    Second, the `TextIO` type is a file-like object for reading and writing strings
    (`str`), such as the standard output stream. Otherwise, the type annotations should
    look fairly familiar.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-4](#example_typing_wikipedia)展示了带有类型注释的模块，并介绍了两个你还没有见过的概念。首先，`Final`注释将`API_URL`标记为常量——一个你不能再给它赋值的变量。其次，`TextIO`类型是一个文件样对象，用于读取和写入字符串（`str`），比如标准输出流。除此之外，类型注释应该看起来相当熟悉。'
- en: Example 10-4\. The Wikipedia API client with type annotations
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-4\. 具有类型注释的维基百科 API 客户端
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: I recommend strict mode for any new Python project, because it’s much easier
    to annotate your code as you write it. Strict checks give you more confidence
    in the correctness of your program, because type errors are less likely to be
    masked by `Any`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议对于任何新的 Python 项目都使用严格模式，因为这样在你编写代码时注释代码会更容易。严格检查给了你更多对程序正确性的信心，因为类型错误不太可能被
    `Any` 掩盖。
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'My other favorite mypy setting in *pyproject.toml* is the `pretty` flag. It
    displays source snippets and indicates where the error occurred:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 *pyproject.toml* 中的另一个喜欢的 mypy 设置是 `pretty` 标志。它显示源代码片段并指示错误发生的位置：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Let mypy’s strict mode be your North Star when adding types to an existing Python
    codebase. Mypy gives you an arsenal of finer and coarser-grained ways to relax
    type checking when you’re not ready to fix a type error.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在现有的 Python 代码库中添加类型时，让 mypy 的严格模式成为你的北极星。Mypy 给了你一系列更精细和更粗粒度的方式来在你还没有准备好修复类型错误时放松类型检查。
- en: 'Your first line of defense is a special comment of the form `# type: ignore`.
    Always follow it with the error code in square brackets. For example, here’s a
    line from mypy’s output above with the error code included:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '你的第一道防线是形式为 `# type: ignore` 的特殊注释。始终在方括号中跟随错误代码。例如，这是来自 mypy 输出的一行，其中包含了错误代码：'
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can allow this specific call to an untyped function as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以允许这个特定调用一个未标注类型的函数，如下所示：
- en: '[PRE55]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If you have a module with a large number of untyped calls, you can ignore the
    error for the entire module using the following stanza in your *pyproject.toml*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个包含大量未标注调用的模块，你可以使用以下在你的 *pyproject.toml* 中的段落来忽略整个模块的错误：
- en: '[PRE56]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[![1](assets/1.png)](#co_using_types_for_safety_and_inspection_CO1-1)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_using_types_for_safety_and_inspection_CO1-1)'
- en: Replace `<module>` with the module that has the untyped calls. Use double quotes
    if the module’s name contains any dots.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 用 `<module>` 替换具有未标注调用的模块。如果模块名包含任何点，请使用双引号。
- en: 'You can also ignore an error globally, like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以全局忽略一个错误，就像这样：
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can even disable all type errors for a given module:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以为给定模块禁用所有类型错误：
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Automating mypy with Nox
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Nox 自动化 mypy
- en: All through this book, you’ve automated checks for your projects using Nox.
    Nox sessions allow you and other contributors to run checks easily and repeatedly
    during local development, the same way they’d run on a continuous integration
    (CI) server.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你已经使用 Nox 自动化了项目的检查。Nox 会话允许你和其他贡献者在本地开发期间轻松重复地运行检查，就像它们在持续集成（CI）服务器上运行的方式一样。
- en: '[Example 10-5](#example_typing_nox_mypy) shows a Nox session for type-checking
    your project with mypy:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-5](#example_typing_nox_mypy)展示了一个使用 mypy 对你的项目进行类型检查的 Nox 会话：'
- en: Example 10-5\. A Nox session for type checking with mypy
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-5\. 使用 mypy 进行类型检查的 Nox 会话
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Just like you run the test suite across all supported Python versions, you should
    also type-check your project on every Python version. This practice is fairly
    effective at ensuring that your project is compatible with those versions, even
    when your test suite doesn’t exercise that one code path where you forgot about
    backwards compatibility.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在所有支持的 Python 版本上运行测试套件一样，你还应该在每个 Python 版本上对你的项目进行类型检查。这种做法相当有效，可以确保你的项目与这些版本兼容，即使你的测试套件没有运行那个你忘记了向后兼容性的代码路径。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can also pass the target version using mypy’s `--python-version` option.
    However, installing the project on each version ensures that mypy checks your
    project against the correct dependencies. These may not be the same on all Python
    versions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 mypy 的 `--python-version` 选项传递目标版本。然而，安装项目在每个版本上确保了 mypy 检查你的项目是否与正确的依赖关系匹配。这些在所有
    Python 版本上可能不一样。
- en: Inevitably, as you type-check on multiple versions, you’ll get into situations
    where either the runtime code or the type annotations don’t work across all versions.
    For example, Python 3.9 deprecated `typing.Iterable` in favor of `collections.abc.Iterable`.
    Use conditional imports based on the Python version, as shown below. Static type
    checkers recognize Python version checks in your code, and they will base their
    type checks on the code relevant for the current version.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 不可避免地，在对多个版本进行类型检查时，你会遇到以下情况：运行时代码或类型注解在所有版本上都无法正常工作。例如，Python 3.9已弃用`typing.Iterable`，推荐使用`collections.abc.Iterable`。根据Python版本进行条件导入，如下所示。静态类型检查器识别你代码中的Python版本检查，并基于当前版本的相关代码进行类型检查。
- en: '[PRE60]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Another sticking point: typing features not yet available at the low end of
    your supported Python version range. Fortunately, these often come with backports
    in a third-party library named `typing-extensions`. For example, Python 3.11 added
    the useful `Self` annotation, which denotes the currently enclosing class. If
    you support versions older than that, add `typing-extensions` to your dependencies
    and import `Self` from there:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个难点：在支持的Python版本范围的低端尚未提供的类型特性。幸运的是，这些通常在名为`typing-extensions`的第三方库中提供了后续版本。例如，Python
    3.11添加了有用的`Self`注解，表示当前封闭类。如果你支持比这更旧的版本，将`typing-extensions`添加到你的依赖项中，并从那里导入`Self`：
- en: '[PRE61]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Distributing Types with Python Packages
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python包分发类型
- en: You may wonder why the Nox session in [Example 10-5](#example_typing_nox_mypy)
    installs the project into mypy’s virtual environment. By nature, a static type
    checker operates on source code; it doesn’t run your code. So why install anything
    but the type checker itself?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么[示例 10-5](#example_typing_nox_mypy)中的Nox会将项目安装到mypy的虚拟环境中。静态类型检查器本质上操作源代码；它不运行你的代码。那么除了类型检查器本身，为什么还要安装其他东西呢？
- en: To see why this matters, consider the version of the Wikipedia project in [Example 6-5](ch06.html#example_testing_rich)
    and [Example 6-14](ch06.html#example_testing_httpx), where you implemented the
    `show` and `fetch` functions using Rich and `httpx`. How can a type checker validate
    your use of a specific version of a third-party package?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一点的重要性，请考虑[示例 6-5](ch06.html#example_testing_rich)和[示例 6-14](ch06.html#example_testing_httpx)中维基百科项目的版本，你在那里使用了Rich和`httpx`实现了`show`和`fetch`函数。类型检查器如何验证你对特定版本的第三方包的使用？
- en: Rich and `httpx` are, in fact, fully type annotated. They include an empty marker
    file named *py.typed* next to their source files. When you install the packages
    into a virtual environment, the marker file allows static type checkers to locate
    their types.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Rich和`httpx`实际上都已经完全类型注解。它们在源文件旁边包含了一个名为*py.typed*的空标记文件。当你将这些包安装到虚拟环境时，标记文件使得静态类型检查器能够找到它们的类型。
- en: Many Python packages distribute their types inline with *py.typed* markers.
    However, other mechanisms for type distribution exist. Knowing them is useful
    when mypy can’t import the types for a package.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Python包使用*py.typed*标记内联分发其类型。然而，存在其他类型分发机制。当mypy无法导入包的类型时，了解它们非常有用。
- en: For example, the `factory-boy` library doesn’t yet ship with types—​instead,
    you need to install a stubs package named `types-factory-boy` from PyPI.^([7](ch10.html#id329))
    A *stubs package* is a Python package containing typing stubs, a special kind
    of Python source file with a *.pyi* suffix that has only type annotations and
    no executable code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`factory-boy`库尚未提供类型支持——你需要从PyPI安装名为`types-factory-boy`的存根包。^([7](ch10.html#id329))
    *存根包*是一个Python包，其中包含类型存根，这是一种特殊的Python源文件，后缀为*.pyi*，仅包含类型注解而没有可执行代码。
- en: 'If you’re entirely out of luck and types for your dependency simply don’t exist,
    disable the mypy error in *pyproject.toml*, like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你彻底不走运，或者你的依赖库根本没有类型支持，可以在*pyproject.toml*中禁用mypy错误，像这样：
- en: '[PRE62]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[![1](assets/1.png)](#co_using_types_for_safety_and_inspection_CO2-1)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_using_types_for_safety_and_inspection_CO2-1)'
- en: Replace `<package>` with the import name of the package.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 用导入包的名称替换`<package>`。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Python’s standard library doesn’t include type annotations. Type checkers vendor
    the third-party package `typeshed` for standard library types, so you don’t have
    to worry about supplying them.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库不包含类型注解。类型检查器为标准库类型提供了第三方包`typeshed`，因此你不必担心提供它们。
- en: Type-Checking the Tests
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型检查测试
- en: Treat your tests like you would treat any other code. Type-checking your tests
    helps you detect when they use your project, pytest, or testing libraries incorrectly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的测试视为任何其他代码一样对待。对你的测试进行类型检查有助于你在使用项目、pytest 或测试库时发现错误。
- en: Tip
  id: totrans-236
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Running mypy on your test suite also type-checks the public API of your project.
    This can be a good fallback when you’re unable to fully type your implementation
    code for every supported Python version.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试套件上运行 mypy 也会对你的项目的公共 API 进行类型检查。当你无法为每个支持的 Python 版本完全类型化实现代码时，这可能是一个很好的后备方案。
- en: '[Example 10-6](#example_typing_nox_mypy_full) extends the Nox session to type-check
    your test suite. Install your test dependencies, so mypy has access to type information
    for pytest and friends.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-6](#example_typing_nox_mypy_full) 扩展了 Nox 会话以对你的测试套件进行类型检查。安装你的测试依赖项，以便
    mypy 可以访问 pytest 和其他库的类型信息。'
- en: Example 10-6\. A Nox session for type checking with mypy
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-6\. 使用 mypy 进行类型检查的 Nox 会话
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The test suite imports your package from the environment. The type checker therefore
    expects your package to distribute type information. Add an empty *py.test* marker
    file to your import package, next to the `__init__` and `__main__` modules (see
    [“Distributing Types with Python Packages”](#section_typing_distributing)).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件从环境中导入你的包。因此，类型检查器期望你的包分发类型信息。在导入包中添加一个空的 *py.test* 标记文件，紧挨着 `__init__`
    和 `__main__` 模块（参见[“使用 Python 包分发类型”](#section_typing_distributing)）。
- en: 'There isn’t anything inherently special about typing a test suite. Recent versions
    of pytest come with high-quality type annotations. These help when your tests
    use one of pytest’s built-in fixtures. Many test functions don’t have arguments
    and return `None`. Here’s a slightly more involved example using a fixture and
    test from [Chapter 6](ch06.html#chapter_testing):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对测试套件进行类型检查没有任何特别之处。最新版本的 pytest 配备了高质量的类型注释。当你的测试使用 pytest 的内置 fixture 之一时，这些注释很有帮助。许多测试函数没有参数，并返回
    `None`。以下是一个稍微复杂的示例，使用一个 fixture 和来自[第 6 章](ch06.html#chapter_testing)的测试：
- en: '[PRE64]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, let’s indulge in a bout of self-referentialism and type-check the
    *noxfile.py* ([Example 10-7](#example_typing_nox_mypy_fullest)). You’ll need the
    `nox` package to validate your use of Nox. I’ll use a little trick here: When
    the session runs, there’s already a suitable environment with Nox installed—​you’re
    in it! Instead of creating another environment with Nox, point mypy to the existing
    one using its `--python-executable` option.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们沉迷于一种自我指涉的状态，并对 *noxfile.py* ([示例 10-7](#example_typing_nox_mypy_fullest))
    进行类型检查。你将需要 `nox` 包来验证你对 Nox 的使用。我在这里使用了一个小技巧：当会话运行时，已经有一个安装了 Nox 的合适环境——你就在其中！而不是创建另一个带有
    Nox 的环境，请使用其 `--python-executable` 选项指向现有的环境。
- en: Example 10-7\. Type-checking the noxfile.py with mypy
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-7\. 使用 mypy 对 *noxfile.py* 进行类型检查
- en: '[PRE65]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Inspecting Type Annotations at Runtime
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时检查类型注释
- en: Unlike in TypeScript, where static types are only available during compilation,
    Python type annotations are also available at runtime. Runtime inspection of type
    annotations is the foundation for powerful features, and an ecosystem of third-party
    libraries has evolved around its use.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于 TypeScript，在那里静态类型仅在编译期间可用，Python 类型注释也可以在运行时使用。运行时检查类型注释是强大功能的基础，并且围绕其使用已经形成了第三方库的生态系统。
- en: 'The interpreter stores the type annotations in a special attribute named `__annotations__`
    on the enclosing function, class, or module. Don’t access this attribute directly,
    however—​consider it part of Python’s plumbing. Python deliberately doesn’t shield
    the attribute from you, but it provides a high-level interface that’s easy to
    use correctly: the function `inspect.get_annotations()`.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器将类型注释存储在封闭函数、类或模块的名为 `__annotations__` 的特殊属性中。然而，不要直接访问这个属性——将其视为 Python
    的内部工具。Python 故意不会屏蔽该属性，但提供了一个易于正确使用的高级接口：函数 `inspect.get_annotations()`。
- en: 'Let’s inspect the type annotations of the `Article` class from [Example 10-4](#example_typing_wikipedia):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查来自[示例 10-4](#example_typing_wikipedia)的`Article`类的类型注释：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Recall that the `fetch` function instantiates the class like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`fetch` 函数以这种方式实例化类：
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If you can instantiate an `Article`, it must have a standard `__init__` method
    that initializes its attributes. (You can convince yourself of this fact by accessing
    it in the interactive session.) Where does the method come from?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以实例化一个 `Article`，它必须有一个标准的 `__init__` 方法来初始化其属性。（你可以通过在交互式会话中访问它来确信这一事实。）这个方法来自哪里？
- en: 'The Zen of Python^([8](ch10.html#id330)) says, “Special cases aren’t special
    enough to break the rules.” Dataclasses make no exception to this principle: they’re
    plain Python classes without any secret sauce. Given that the class doesn’t define
    the method itself, there’s only one possible origin for it: the `@dataclass` class
    decorator. In fact, the decorator synthesizes the `__init__` method on the fly,
    along with several other methods, using your type annotations! Don’t take my word
    for it, though. In this section, you’re going to write your own miniature `@dataclass`
    decorator.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Python之禅^([8](ch10.html#id330))说：“特例并不足以打破规则。”数据类也不例外：它们只是普通的Python类，没有任何秘密配方。鉴于该类没有定义方法本身，它的唯一可能来源是`@dataclass`类装饰器。事实上，该装饰器会根据你的类型注释动态合成`__init__`方法以及几个其他方法！当然，不要只听我的话。在这一节中，你将编写自己的迷你`@dataclass`装饰器。
- en: Warning
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Don’t use this in production! Use the standard `dataclasses` module, or better:
    the `attrs` library. Attrs is an actively maintained, industry-strength implementation
    with better performance, a clean API, and additional features, and it directly
    inspired `dataclasses`.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在生产中使用这个！使用标准的`dataclasses`模块，或者更好的是`attrs`库。Attrs是一个积极维护的、具有更好性能、干净API和附加功能的行业强度实现，它直接启发了`dataclasses`。
- en: Writing a @dataclass Decorator
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 @dataclass 装饰器
- en: First of all, be a good typing citizen and think about the signature of the
    `@dataclass` decorator. A class decorator accepts a class and returns it, usually
    after transforming it in some way, such as by adding a method. In Python, classes
    are objects you can pass around and manipulate to your liking.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，成为一个好的类型公民，并考虑`@dataclass`装饰器的签名。一个类装饰器接受一个类并返回它，通常在某种方式上转换它，比如通过添加一个方法。在Python中，类是可以传递和操纵的对象。
- en: The typing language allows you to refer to, say, the `str` class by writing
    `type[str]`. You can read this aloud as “the type of a string”. (You can’t use
    `str` on its own here. In a type annotation, `str` just refers to an individual
    string.) A class decorator should work for any class object, though—​it should
    be generic. Therefore, you’ll use a type variable instead of an actual class like
    `str`:^([9](ch10.html#id331))
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 输入语言允许你通过写`type[str]`来引用`str`类。你可以把它读作“字符串的类型”。（在这里不能单独使用`str`。在类型注释中，`str`仅仅是指一个具体的字符串。）一个类装饰器应该适用于任何类对象，虽然——它应该是泛化的。因此，你将使用一个类型变量而不是像`str`这样的实际类：^([9](ch10.html#id331))
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Type checkers need one more bit to properly understand your `@dataclass` decorator:
    they need to know which methods you’re adding to the class, and which instance
    variables they can expect on objects instantiated from the class. Traditionally,
    you had to write a type checker plugin to infuse this knowledge into the tool.
    These days, the `@dataclass_transform` marker from the standard library lets you
    inform type checkers that the class exhibits dataclass-like behavior.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器需要多一点东西才能正确理解你的`@dataclass`装饰器：它们需要知道你正在向类中添加哪些方法，以及它们可以在从类实例化的对象上期望哪些实例变量。传统上，你必须编写一个类型检查器插件来将这些知识注入到工具中。如今，标准库中的`@dataclass_transform`标记允许你告知类型检查器该类展示了类似数据类的行为。
- en: '[PRE69]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: With the function signature out of the way, let’s think about how to implement
    the decorator. You can break this down into two steps. First, you’ll need to assemble
    a string with the source code of the `__init__` method, using the type annotations
    on the dataclass. Second, you can use Python’s built-in `exec` function to evaluate
    that source code in the running program.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名的问题解决了，现在让我们考虑如何实现这个装饰器。你可以将其分解为两个步骤。首先，你需要组装一个包含数据类上类型注释的`__init__`方法的源代码字符串。其次，你可以使用Python内置的`exec`函数在运行中评估该源代码。
- en: 'You’ve likely written a few `__init__` methods in your career—​they’re pure
    boilerplate. For the `Article` class, the method would look like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在你的职业生涯中写过几个`__init__`方法——它们纯粹是样板文件。对于`Article`类，该方法看起来像这样：
- en: '[PRE70]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let’s tackle the first step: assembling the source code from the annotations
    ([Example 10-8](#example_typing_dataclass_init)). Don’t fret too much about the
    parameter types at this point—​just use the `__name__` attribute of each parameter
    type, which will work in many cases.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解决第一步：从注释中组装源代码（[Example 10-8](#example_typing_dataclass_init)）。此时不要太过担心参数类型——只需使用每个参数类型的`__name__`属性，在许多情况下都会有效。
- en: Example 10-8\.
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-8。
- en: '[PRE71]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[![1](assets/1.png)](#co_using_types_for_safety_and_inspection_CO3-1)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_using_types_for_safety_and_inspection_CO3-1)'
- en: Use a type variable `T` in the signature to make this generic for any class.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在签名中使用类型变量`T`使其对任何类都通用。
- en: '[![2](assets/2.png)](#co_using_types_for_safety_and_inspection_CO3-2)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_using_types_for_safety_and_inspection_CO3-2)'
- en: Retrieve the annotations of the class as a dictionary of names and types.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将类的注释作为名称和类型的字典检索出来。
- en: '[![3](assets/3.png)](#co_using_types_for_safety_and_inspection_CO3-3)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_using_types_for_safety_and_inspection_CO3-3)'
- en: The variable annotation is only required for `body`. Most type checkers won’t
    infer that `body` contains strings because it’s an empty list at this point. I’ve
    annotated both variables for symmetry.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 变量注释仅对`body`是必需的。大多数类型检查器不会推断`body`包含字符串，因为此时它是一个空列表。我为对称性注释了这两个变量。
- en: You can now pass the source code to the `exec` built-in. Apart from the source
    code, this function accepts dictionaries for the global and local variables.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将源代码传递给内置的`exec`。除了源代码外，此函数还接受全局和局部变量的字典。
- en: 'The canonical way to retrieve the global variables is the `globals()` built-in.
    However, you need to evaluate the source code in the context of the module where
    the class is defined, rather than the context of your decorator. Python stores
    the name of that module in the `__module__` attribute of the class, so you can
    look up the module object in `sys.modules` and retrieve the variables from its
    `__dict__` attribute (see [“The Module Cache”](ch02.html#section_environments_module_cache)):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 检索全局变量的经典方法是使用`globals()`内置函数。但是，您需要在定义类的模块的上下文中评估源代码，而不是在装饰器的上下文中。Python将该模块的名称存储在类的`__module__`属性中，因此您可以在`sys.modules`中查找模块对象，并从其`__dict__`属性中检索变量（参见[“模块缓存”](ch02.html#section_environments_module_cache)）：
- en: '[PRE72]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: For the local variables, you can pass an empty dictionary—​this is where `exec`
    will place the method definition. All that’s left is to copy the method from the
    locals dictionary into the class object and return the class. Without further
    ado, [Example 10-9](#example_typing_dataclass_decorator) shows the entire decorator.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于局部变量，可以传递一个空字典—这是`exec`将方法定义放置的地方。唯一需要做的就是将方法从局部字典复制到类对象中，并返回类。例[10-9](#example_typing_dataclass_decorator)展示了整个装饰器。
- en: Example 10-9\. Your own `@dataclass` decorator
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-9\. 您自己的`@dataclass`装饰器
- en: '[PRE73]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[![1](assets/1.png)](#co_using_types_for_safety_and_inspection_CO4-1)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_using_types_for_safety_and_inspection_CO4-1)'
- en: Retrieve the global variables from the module that defines the class.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从定义类的模块中检索全局变量。
- en: '[![2](assets/2.png)](#co_using_types_for_safety_and_inspection_CO4-2)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_using_types_for_safety_and_inspection_CO4-2)'
- en: 'This is where the magic happens: let the interpreter compile the generated
    code on the fly.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是魔法发生的地方：让解释器即时编译生成的代码。
- en: '[![3](assets/3.png)](#co_using_types_for_safety_and_inspection_CO4-3)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_using_types_for_safety_and_inspection_CO4-3)'
- en: Et voilà—the class now has an `__init__` method.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Et voilà—类现在有了一个`__init__`方法。
- en: Runtime Type Checking
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时类型检查
- en: 'There’s more you can do with types at runtime besides generating class boilerplate.
    One important example is runtime type checking. To see how useful this technique
    is, let’s take another look at the `fetch` function:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 除了生成类的样板外，您还可以在运行时处理类型。一个重要的例子是运行时类型检查。为了看到这种技术有多有用，让我们再次看一下`fetch`函数：
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If you’ve paid close attention, you may have noticed that `fetch` is not type-safe.
    Nothing guarantees that the Wikipedia API will return a JSON payload of the expected
    shape. You might object that Wikipedia’s [OpenAPI specification](https://en.wikipedia.org/api/rest_v1/)
    tells us exactly which data shape to expect from the endpoint. But don’t base
    your static types on assumptions about external systems—​unless you’re happy with
    your program crashing when a bug or API change breaks those assumptions.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，您可能会注意到`fetch`不是类型安全的。没有任何保证维基百科 API 将返回预期形状的 JSON 负载。您可能会反对说，维基百科的[OpenAPI
    规范](https://en.wikipedia.org/api/rest_v1/)准确告诉我们可以从端点期望什么数据形状。但是，不要基于对外部系统的假设来制定静态类型—除非您愿意在程序由于错误或
    API 更改而中断这些假设时崩溃。
- en: 'As you may have guessed, mypy silently passes over this issue, because `json.load`
    returns `Any`. How can we make the function type-safe? As a first step, let’s
    replace `Any` with the `JSON` type you defined in [“Type Aliases”](#section_typing_aliases):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经猜到的那样，mypy对此问题静默通过，因为`json.load`返回`Any`。我们如何使函数类型安全？首先，让我们用您在[“类型别名”](#section_typing_aliases)中定义的`JSON`类型替换`Any`：
- en: '[PRE75]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We haven’t fixed the bug, but at least mypy gives us diagnostics now (edited
    for brevity):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有修复 bug，但至少 mypy 现在为我们提供了诊断信息（编辑以简洁化）：
- en: '[PRE76]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Mypy’s diagnostics boil down to two separate issues in the function. First,
    the code indexes `data` without verifying that it’s a dictionary. Second, it passes
    the results to `Article` without making sure they’re strings.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy 的诊断归结为函数中的两个单独问题。首先，代码索引 `data` 时没有验证它是否是字典。其次，它将结果传递给 `Article` 而没有确保它们是字符串。
- en: 'Let’s check the type of `data` then—​it has to be a dictionary with strings
    under the `title` and `extract` keys. You can express this concisely using structural
    pattern matching:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一下 `data` 的类型——它必须是一个带有 `title` 和 `extract` 键的字典。您可以使用结构化模式匹配来简洁地表达这一点：
- en: '[PRE77]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Thanks to type narrowing, the runtime type checks also appease mypy—​in a way,
    bridging the worlds of runtime and static type checking. If you’d like to see
    the runtime type check in action, you can use the test harness from [Chapter 6](ch06.html#chapter_testing)
    and modify the HTTP server to return an unexpected response, such as `null` or
    `"teapot"`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型缩小，运行时类型检查也满足了 mypy——在某种程度上，它架起了运行时和静态类型检查的桥梁。如果您想看到运行时类型检查的实际效果，可以使用来自[第
    6 章](ch06.html#chapter_testing)的测试工具，并修改 HTTP 服务器以返回意外响应，如 `null` 或 `"teapot"`。
- en: Serialization and Deserialization with cattrs
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `cattrs` 进行序列化和反序列化
- en: The function is type-safe now, but can we do better than this? The validation
    code duplicates the structure of the `Article` class—​you shouldn’t need to spell
    out the types of its fields again. If your application must validate more than
    one input, the boilerplate can hurt readability and maintainability. It should
    be possible to assemble articles from JSON objects using only the original type
    annotations—​and it is.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在该函数是类型安全的了，但我们能做得比这更好吗？验证代码复制了 `Article` 类的结构——您不应该需要再次声明其字段的类型。如果您的应用程序必须验证多个输入，模板代码可能会影响可读性和可维护性。只使用原始类型注释即可从
    JSON 对象中组装文章，这应该是可能的——而且确实如此。
- en: The `cattrs` library provides flexible and type-safe serialization and deserialization
    for type-annotated classes such as dataclasses and attrs. It’s delightfully simple
    to use—​you pass the JSON object and the expected type to its `structure` function
    and get the assembled object back.^([10](ch10.html#id332)) There’s also a `destructure`
    function for transforming objects into primitive types for serialization.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`cattrs` 库为诸如数据类和 attrs 之类的类型注释类提供了灵活和类型安全的序列化和反序列化。它非常简单易用——您只需将 JSON 对象和预期类型传递给其
    `structure` 函数，就可以得到组装好的对象。^([10](ch10.html#id332)) 还有一个 `destructure` 函数，用于将对象转换为原始类型以进行序列化。'
- en: 'For this last iteration on the Wikipedia example, add `cattrs` to your dependencies:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在维基百科示例的最后迭代中，将 `cattrs` 添加到您的依赖项中：
- en: '[PRE78]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Replace the `fetch` function with the three-liner below (don’t run this yet,
    we’ll get to the final version in a second):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 用下面的三行代码替换 `fetch` 函数（尚未运行此代码，我们稍后将达到最终版本）：
- en: '[PRE79]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Deserializing `Article` objects is now entirely determined by their type annotations.
    Besides being clear and concise, this version of the code is type-safe, thanks
    to the internal runtime checks in `cattrs`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Article` 对象的反序列化完全由其类型注释决定。除了清晰简洁外，这个版本的代码还是类型安全的，这要归功于 `cattrs` 中的内部运行时检查。
- en: 'However, you still need to take care of one complication. The `summary` attribute
    doesn’t match the name of its corresponding JSON field, `extract`. Fortunately,
    `cattrs` is flexible enough to let you create a custom converter that renames
    the field on the fly:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您仍然需要解决一个复杂的问题。`summary` 属性与其对应的 JSON 字段 `extract` 的名称不匹配。幸运的是，`cattrs` 具有足够的灵活性，可以让您创建一个自定义转换器，在运行时即时重命名字段：
- en: '[PRE80]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, use the custom converter in the `fetch` function:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `fetch` 函数中使用自定义转换器：
- en: '[PRE81]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: From a software-architecture perspective, the `cattrs` library has advantages
    over other popular data-validation libraries. It keeps serialization and deserialization
    separate from your *models*—the classes at the core of your application that express
    its problem domain and provide all the business logic. Decoupling the domain model
    from the data layer gives you architectural flexibility and improves the testability
    of your code.^([11](ch10.html#id333))
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件架构的角度来看，`cattrs` 库相比其他流行的数据验证库有其优势。它将序列化和反序列化与您的*模型*（即应用程序核心的类，表达其问题域并提供所有业务逻辑）分离开来。将领域模型与数据层解耦为您提供了架构上的灵活性，并改善了代码的可测试性。^([11](ch10.html#id333))
- en: 'There are also practical advantages to the `cattrs` approach. You can serialize
    the same object in different ways if you need to. It’s not intrusive—​it doesn’t
    add methods to your objects. And it works with all kinds of types: dataclasses,
    attrs-classes, named tuples, typed dicts, and even plain type annotations like
    `tuple[str, int]`.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`cattrs` 方法也有其实际优势。如果需要的话，你可以以不同的方式序列化相同的对象。它不会侵入——不会向你的对象添加方法。它适用于各种类型：数据类、attrs-类、命名元组、类型字典，甚至是像
    `tuple[str, int]` 这样的普通类型注解。'
- en: Runtime Type Checking with Typeguard
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Typeguard 进行运行时类型检查
- en: Do you find the type unsafety of the original `fetch` function disconcerting?
    The issue was easy enough to spot in a short script. But how do you find similar
    issues in a large codebase before they cause problems? After all, you ran mypy
    in strict mode, and it remained silent.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否觉得原始 `fetch` 函数的类型不安全令人不安？在一个短脚本中很容易发现这个问题。但是在一个大型代码库中如何找到类似的问题以避免它们造成问题？毕竟，你以严格模式运行了
    mypy，但它保持沉默。
- en: Static type checkers won’t catch every type-related error. In this case, gradual
    typing obscured the issue—​specifically, `json.load` returning `Any`. Real-world
    code has plenty of situations like this. A library outside of your control might
    have overly permissive type annotations—​or none at all. A bug in your persistence
    layer might load corrupted objects from disk. Maybe mypy would have caught the
    issue, but you silenced type errors for the module in question.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型检查器不会捕捉到每一个与类型相关的错误。在这种情况下，逐步类型化模糊了问题——具体来说，`json.load` 返回 `Any`。真实世界的代码存在许多类似的情况。你无法控制的库可能有过于宽容的类型注解——或者根本没有。你的持久化层可能会从磁盘加载损坏的对象。也许
    mypy 本来会捕捉到这个问题，但你却在该模块中禁止了类型错误。
- en: 'Typeguard is a third-party library and pytest plugin for runtime type checking.
    It can be an invaluable tool for verifying the type safety of your code in situations
    that elude static type checkers, such as:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Typeguard 是一个第三方库和 pytest 插件，用于运行时类型检查。在静态类型检查器无法捕捉到的情况下，它可以成为验证代码类型安全的宝贵工具，比如：
- en: Dynamic code
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 动态代码
- en: Python code can be highly dynamic, forcing type annotations to be permissive.
    Your assumptions about the code may be at odds with the concrete types you end
    up with at runtime.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Python 代码可以是高度动态的，这迫使类型注解变得宽容。你对代码的假设可能与运行时实际得到的具体类型不一致。
- en: External systems
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 外部系统
- en: Most real-world code eventually crosses the boundary to external systems such
    as a web service, a database, or the file system. Data you receive from these
    systems may not have the shape you expect it to. Its format can also unexpectedly
    change from one day to another.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数真实世界的代码最终会跨越到外部系统的边界，比如一个 web 服务、数据库或文件系统。你从这些系统接收到的数据可能不是你期望的格式。它的格式也可能会在一天之内意外地改变。
- en: Third-party libraries
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方库
- en: Some of your Python dependencies may not have type annotations, or their type
    annotations might be incomplete or overly permissive.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你的一些 Python 依赖项可能没有类型注解，或者它们的类型注解可能不完整或过于宽容。
- en: 'Add Typeguard to your dependencies in *pyproject.toml*:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Typeguard 添加到你的依赖项中的 *pyproject.toml* 文件：
- en: '[PRE82]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Typeguard comes with a function called `check_type`, which you can think of
    as `isinstance` for arbitrary type annotations. Those annotations can be quite
    simple—​say, a list of floating-point numbers:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Typeguard 提供了一个名为 `check_type` 的函数，你可以将其视为任意类型注解的 `isinstance`。这些注解可能非常简单——比如，一个浮点数列表：
- en: '[PRE83]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The checks can also be more elaborate. For example, you can use the `TypedDict`
    construct to specify the precise shape of a JSON object you’ve fetched from some
    external service, such as the keys you expect to find and which types their associated
    values should have:^([12](ch10.html#id334))
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这些检查也可以更加复杂。例如，你可以使用 `TypedDict` 结构来指定从某些外部服务获取的 JSON 对象的精确形状，比如你期望找到的键以及它们关联值应该具有的类型：
- en: '[PRE84]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Here’s how you might use it:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可以使用它的方式：
- en: '[PRE85]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Typeguard also comes with a decorator named `@typechecked`. When used as a
    function decorator, it instruments the function to check the types of its arguments
    and return value. When used as a class decorator, it instruments every method
    in this way. For example, you could slap this decorator onto a function that reads
    `Person` records from a JSON file:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Typeguard 还提供了一个名为 `@typechecked` 的装饰器。当作为函数装饰器使用时，它会使函数被检查其参数和返回值的类型。当作为类装饰器使用时，它会以这种方式检查每个方法。例如，你可以将此装饰器应用于从
    JSON 文件中读取 `Person` 记录的函数：
- en: '[PRE86]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: By default, Typeguard only checks the first item in a collection to reduce runtime
    overhead. You can change this strategy to check all items in the global configuration
    object:^([13](ch10.html#id335))
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Typeguard仅检查集合中的第一个项以减少运行时开销。您可以在全局配置对象中更改此策略以检查所有项:^([13](ch10.html#id335))
- en: '[PRE87]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Finally, Typeguard comes with an import hook that instruments all functions
    and methods in a module on import. While you can use the import hook explicitly,
    arguably its greatest use case involves enabling Typeguard as a pytest plugin
    while running your test suite. Let’s add a Nox session that runs the test suite
    with runtime type checking:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Typeguard带有一个导入钩子，在导入时为模块中的所有函数和方法提供仪表化。虽然您可以显式使用导入钩子，但其最大的用例可能是在运行测试套件时将Typeguard作为pytest插件启用。让我们添加一个Nox会话，用于带有运行时类型检查的测试套件：
- en: Example 10-10\. Nox session for runtime type checking with Typeguard
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-10\. 使用Typeguard进行运行时类型检查的Nox会话
- en: '[PRE88]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Running Typeguard as a pytest plugin lets you track down type-safety bugs in
    a large codebase—​provided it has good test coverage. If it doesn’t, consider
    enabling runtime type checking for individual functions or modules in production.
    Be careful here: Look for false positives from the type checks, and measure their
    runtime overhead.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 将Typeguard作为pytest插件运行，可以帮助您在大型代码库中找出类型安全性问题，前提是它具有良好的测试覆盖率。如果没有良好的测试覆盖率，请考虑在生产环境中为单个函数或模块启用运行时类型检查。在此要小心：注意类型检查可能出现的误报，并测量它们的运行时开销。
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: Type annotations let you specify the types of variables and functions in your
    source code. You can use built-in types and user-defined classes, as well as many
    higher-level constructs, such as union types, `Any` for gradual typing, generics,
    and protocols. Stringized annotations and `Self` are useful for handling forward
    references. The `type` keyword lets you introduce type aliases.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解允许您在源代码中指定变量和函数的类型。您可以使用内置类型和用户定义的类，以及许多更高级别的构造，例如联合类型、渐进式类型化中的`Any`、泛型和协议。字符串化的注解和`Self`对处理前向引用非常有用。`type`关键字允许您引入类型别名。
- en: Static type checkers like mypy leverage type annotations and type inference
    to verify the type safety of your program without running it. Mypy facilitates
    gradual typing by defaulting to `Any` for unannotated code. You can and should
    enable strict mode where possible to allow for more thorough checks. Run mypy
    as part of your mandatory checks, using a Nox session for automation.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 类似mypy这样的静态类型检查器利用类型注解和类型推断来验证程序的类型安全性，而无需运行程序。Mypy通过将未注释的代码默认为`Any`来促进渐进式类型化。您应该尽可能启用严格模式以进行更彻底的检查。使用Nox会话作为自动化的一部分来运行mypy作为您的强制性检查之一。
- en: Type annotations are available for inspection at runtime. They’re the foundation
    for powerful features such as class generation with `dataclasses` or the `attrs`
    library, and automatic serialization and deserialization with the help of the
    `cattrs` library. The runtime type checker Typeguard allows you to instrument
    your code to verify the types of function arguments and return values at runtime.
    You can enable it as a pytest plugin while running your test suite.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解在运行时可供检查。它们是强大功能的基础，例如使用`dataclasses`或`attrs`库生成类，并且借助`cattrs`库实现自动序列化和反序列化。运行时类型检查器Typeguard允许您在运行时检查函数参数和返回值的类型。您可以将其作为pytest插件启用，并在运行测试套件时使用。
- en: There’s a widespread sentiment that type annotations are for the sprawling codebases
    found at giant tech corporations—​and not worth the trouble for reasonably sized
    projects, let alone the quick script you hacked together yesterday afternoon.
    I disagree. Type annotations make your programs easier to understand, debug, and
    maintain, no matter how large they are or how many people work on them.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种普遍的观点认为类型注解适用于巨型科技公司的庞大代码库，而对于合理规模的项目，更不用说昨天下午匆忙拼凑的快速脚本。我不同意。类型注解使您的程序更易于理解、调试和维护，无论其规模有多大或有多少人参与开发。
- en: Try using types for any Python code you write. Ideally, configure your editor
    to run a type checker in the background, if it doesn’t already come with typing
    support out-of-the-box. If you feel that types get in your way, consider using
    gradual typing—but also consider whether there might be a simpler way to write
    your code that gives you type safety for free. If your project has any mandatory
    checks, type checking should be a part of them.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试为您编写的任何 Python 代码使用类型。如果可能的话，最好配置您的编辑器在后台运行类型检查器（如果编辑器没有开箱即用的类型支持）。如果您觉得类型会妨碍您，考虑使用渐进式类型；但同时也要考虑是否有更简单的方法来编写代码，从而免费获取类型安全性。如果您的项目有任何强制性检查，类型检查应该是其中的一部分。
- en: With this chapter, the book comes to a close.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一章的结束，本书也告一段落。
- en: 'Throughout the book, you’ve automated checks and tasks for your project using
    Nox. Nox sessions allow you and other contributors to run checks early and repeatedly
    during local development, in the same way they’d run on a CI server. For reference,
    here’s a listing of the Nox sessions you’ve defined:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，您使用 Nox 自动化了项目的检查和任务。Nox 会话允许您和其他贡献者在本地开发期间早期和重复地运行检查，就像它们在 CI 服务器上运行一样。以下是您定义的
    Nox 会话列表供参考：
- en: Building packages ([Example 8-2](ch08.html#example_nox_build))
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建软件包（[示例 8-2](ch08.html#example_nox_build))
- en: Running tests across multiple Python versions ([Example 8-5](ch08.html#example_nox_python))
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个 Python 版本上运行测试（[示例 8-5](ch08.html#example_nox_python))
- en: Running tests with code coverage ([Example 8-9](ch08.html#example_nox_coverage_notify))
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行带代码覆盖率的测试（[示例 8-9](ch08.html#example_nox_coverage_notify))
- en: Measuring coverage in subprocesses ([Example 8-11](ch08.html#example_nox_coverage_subprocess))
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在子进程中测量覆盖率（[示例 8-11](ch08.html#example_nox_coverage_subprocess))
- en: Generating the coverage report ([Example 8-8](ch08.html#example_nox_coverage_report))
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成覆盖率报告（[示例 8-8](ch08.html#example_nox_coverage_report))
- en: Locking the dependencies with uv ([Example 8-14](ch08.html#example_nox_constraints))
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 uv 锁定依赖项（[示例 8-14](ch08.html#example_nox_constraints))
- en: Installing dependencies with Poetry ([Example 8-19](ch08.html#example_nox_poetry_install))
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Poetry 安装依赖项（[示例 8-19](ch08.html#example_nox_poetry_install))
- en: Linting with pre-commit ([Example 9-6](ch09.html#example_linting_nox))
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 pre-commit 进行代码风格检查（[示例 9-6](ch09.html#example_linting_nox))
- en: Static type checking with mypy ([Example 10-7](#example_typing_nox_mypy_fullest))
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 mypy 进行静态类型检查（[示例 10-7](#example_typing_nox_mypy_fullest))
- en: Runtime type checking with Typeguard ([Example 10-10](#example_typing_nox_typeguard))
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Typeguard 进行运行时类型检查（[示例 10-10](#example_typing_nox_typeguard))
- en: There’s a fundamental philosophy behind this approach, dubbed “Shift Left.”
    Consider the software development lifecycle on a timeline extending from left
    to right—​all the way from writing a line of code to running the program in production.
    (If you’re Agile minded, picture the timeline as a circle where feedback from
    production flows back into planning and local development.)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法背后有一种基本的哲学理念，被称为“左移”。考虑软件开发生命周期，从左到右的时间轴—​从编写一行代码到在生产环境中运行程序。 （如果您是敏捷思维的，把时间轴想象成一个圆圈，从生产中获取的反馈再回流到计划和本地开发中。）
- en: The earlier you identify a software defect, the smaller the cost of fixing it.
    In the best case, you discover issues while they’re still in your editor—​their
    cost is near zero. In the worst case, you ship the bug to production. Before even
    starting to track down the issue in the code, you may have to roll back the bad
    deployment and contain its impact. For this reason, shift all your checks as far
    to the left on that imaginary timeline as possible.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 发现软件缺陷越早，修复成本越低。在最好的情况下，您在编辑器中发现问题—​它们的成本几乎为零。在最坏的情况下，您会将错误提交到生产环境。在开始追踪代码中的问题之前，您可能需要回滚错误的部署并控制其影响。因此，尽可能将所有检查向那个想象中的时间轴的左侧移动。
- en: (Run checks towards the right of the timeline, as well. End-to-end tests against
    your production environments are invaluable for increasing confidence that your
    systems are operating as expected.)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: （在时间轴的右侧也要运行检查。针对生产环境的端到端测试对于增强系统按预期运行的信心非常有价值。）
- en: 'Mandatory checks in CI are the main gatekeeper: they decide which code changes
    make it into the main branch and ship to production. But don’t wait for CI. Run
    checks locally, as early as possible. Automating checks with Nox and pre-commit
    helps achieve this goal.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: CI 中的强制性检查是主要的守门员：它们决定哪些代码变更进入主分支并运行到生产环境。但不要等待 CI。尽早在本地运行检查。使用 Nox 和 pre-commit
    自动化检查有助于实现此目标。
- en: Integrate linters and type checkers with your editor, as well! Alas, people
    haven’t yet agreed on a single editor that everybody should use. Tools like Nox
    give you a common baseline for local development in your teams.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，请将linters和类型检查器与您的编辑器集成！然而，人们尚未就所有人都应该使用的单一编辑器达成一致。像Nox这样的工具为您的团队本地开发提供了共同的基线。
- en: Automation also greatly reduces the cost of project maintenance. Contributors
    run a single command, such as `nox`, as an entrypoint to the mandatory checks.
    Other chores, like refreshing lock files or generating documentation, likewise
    only require simple commands. By encoding each process, you eliminate human error
    and create a basis for constant improvement.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化还极大地降低了项目维护成本。贡献者只需运行单个命令，例如`nox`，作为强制检查的入口。其他任务，如刷新锁文件或生成文档，同样只需要简单的命令。通过编码每个过程，您消除了人为错误，并为持续改进奠定了基础。
- en: Thank you for reading this book! While the book ends here, your journey through
    the ever-shifting landscape of modern Python developer tooling continues. Hopefully,
    the lessons from this book will remain valid and helpful, as Python continues
    to reinvent itself.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您阅读本书！尽管书籍到此结束，您在现代Python开发工具的不断变化中的旅程仍在继续。希望本书的教训仍然有效和有帮助，因为Python继续自我革新。
- en: ^([1](ch10.html#id323-marker)) Jukka Lehtosalo, [“Our journey to type checking
    4 million lines of Python,”](https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python)
    September 5, 2019.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.html#id323-marker)) Jukka Lehtosalo, [“我们在Python 4百万行代码中的类型检查之旅,”](https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python)
    2019年9月5日。
- en: '^([2](ch10.html#id324-marker)) [“Specification for the Python type system.”](https://typing.readthedocs.io/en/latest/spec/index.html)
    Last accessed: January 22, 2024.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.html#id324-marker)) [“Python类型系统规范.”](https://typing.readthedocs.io/en/latest/spec/index.html)
    最后访问时间：2024年1月22日。
- en: '^([3](ch10.html#id325-marker)) Tin Tvrtković: [“Python is two languages now,
    and that’s actually great,”](https://threeofwands.com/python-is-two-languages-now-and-thats-actually-great/)
    February 27, 2023.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '^([3](ch10.html#id325-marker)) Tin Tvrtković: [“Python如今是两种语言，这实际上很棒,”](https://threeofwands.com/python-is-two-languages-now-and-thats-actually-great/)
    2023年2月27日。'
- en: '^([4](ch10.html#id326-marker)) In a future Python version, this will work out
    of the box. See Larry Hastings: [“PEP 649 – Deferred Evaluation Of Annotations
    Using Descriptors”](https://peps.python.org/pep-0649/), January 11, 2021.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '^([4](ch10.html#id326-marker)) 在未来的Python版本中，这将直接可用。参见Larry Hastings: [“PEP
    649 – 使用描述符延迟评估注释,”](https://peps.python.org/pep-0649/) 2021年1月11日。'
- en: ^([5](ch10.html#id327-marker)) If you see an error message like “PEP 695 type
    aliases are not yet supported,” just omit the `type` keyword for now. The type
    checker still interprets the assignment as a type alias. If you want to be more
    explicit, you can use the `typing.TypeAlias` annotation from Python 3.10 upwards.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch10.html#id327-marker)) 如果您看到“PEP 695 类型别名尚未支持”的错误消息，请暂时省略`type`关键字。类型检查器仍将此赋值解释为类型别名。如果希望更明确，您可以从
    Python 3.10 开始使用`typing.TypeAlias`注解。
- en: ^([6](ch10.html#id328-marker)) For brevity, I’ve removed error codes and leading
    directories from mypy’s output.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch10.html#id328-marker)) 为简洁起见，我已从mypy输出中删除了错误代码和前导目录。
- en: ^([7](ch10.html#id329-marker)) As of this writing, the upcoming release of `factory-boy`
    is expected to distribute types inline.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch10.html#id329-marker)) 我写作时，预期的`factory-boy`即将内联发布类型。
- en: '^([8](ch10.html#id330-marker)) Tim Peters: [“PEP 20 – The Zen of Python,”](https://peps.python.org/pep-0387/)
    August 19, 2004.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '^([8](ch10.html#id330-marker)) Tim Peters: [“PEP 20 – Python之禅,”](https://peps.python.org/pep-0387/)
    2004年8月19日。'
- en: ^([9](ch10.html#id331-marker)) As of this writing, mypy hasn’t yet added support
    for PEP 695 type variables. If you get a mypy error, type-check the code in the
    Pyright playground instead or use the older `TypeVar` syntax.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch10.html#id331-marker)) 我写作时，mypy 还未支持 PEP 695 类型变量。如果遇到 mypy 错误，请在 Pyright
    游乐场中检查代码类型，或使用旧版`TypeVar`语法。
- en: ^([10](ch10.html#id332-marker)) In fact, the `cattrs` library is format-agnostic,
    so it doesn’t matter if you read the raw object from JSON, YAML, TOML, or another
    data format.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch10.html#id332-marker)) 实际上，`cattrs`库与格式无关，因此无论您是从 JSON、YAML、TOML 还是其他数据格式读取原始对象，都不会有影响。
- en: '^([11](ch10.html#id333-marker)) If you’re interested in this topic, you should
    absolutely read [*Architecture Patterns in Python*](https://learning.oreilly.com/library/view/architecture-patterns-with/9781492052197/),
    by Harry Percival and Bob Gregory (Sebastopol: O’Reilly, 2020).'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch10.html#id333-marker)) 如果你对这个主题感兴趣，绝对应该阅读 [*Python 架构模式*](https://learning.oreilly.com/library/view/architecture-patterns-with/9781492052197/)，作者是哈里·佩西瓦尔和鲍勃·格雷戈里（塞巴斯托波尔：O’Reilly，2020）。
- en: ^([12](ch10.html#id334-marker)) This is less useful than it may seem. `TypedDict`
    classes must list every field even if you only use a subset.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch10.html#id334-marker)) 这看起来可能没那么有用。 `TypedDict` 类必须列出每个字段，即使你只使用其中的一个子集。
- en: ^([13](ch10.html#id335-marker)) If you call `check_type` directly, you’ll need
    to pass the `collection_check_strategy` argument explicitly.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch10.html#id335-marker)) 如果你直接调用 `check_type`，你需要显式传递 `collection_check_strategy`
    参数。
- en: About the Author
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于作者
- en: '**Claudio Jolowicz** is a senior software engineer at Cloudflare with nearly
    two decades of industry experience in Python and C++ and an open source maintainer
    active in the Python community. He is the author of the Hypermodern Python blog
    and project template, and co-maintainer of Nox, a Python tool for test automation.
    In former lives, Claudio has worked as a legal scholar and as a musician touring
    from Scandinavia to West Africa. Get in touch with him on Mastodon: @cjolowicz@fosstodon.org'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**克劳迪奥·约洛维奇**是Cloudflare的高级软件工程师，拥有近20年的Python和C++行业经验，并且是Python社区中的开源维护者。他是《超现代
    Python》博客和项目模板的作者，以及Python测试自动化工具Nox的共同维护者。在前世中，克劳迪奥曾是法学学者和从斯堪的纳维亚到西非巡演的音乐家。欢迎在Mastodon上与他联系：@cjolowicz@fosstodon.org'
- en: Colophon
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版权信息
- en: The animal on the cover of *Hypermodern Python Tooling* is the Peruvian sheartail
    (*Thaumastura cora*), a member of the *Mellisugini* tribe of bee hummingbirds.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 《超现代 Python 工具链》封面上的动物是秘鲁剪尾鸟（*Thaumastura cora*），它是蜂鸟族（*Mellisugini*）中的一员。
- en: The males of most species in this tribe have specialized tail feathers, often
    used to produce sounds during courtship display. As shown on the cover of this
    book, male Peruvian sheartails indeed sport very long, black and white forked
    tails. The upperparts of both sexes are a luminous green, while males’ throat
    feathers are a lustrous purple to magenta.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数蜂鸟族中的雄鸟都有特化的尾羽，常用于求偶展示时制造声音。正如本书封面所示，秘鲁剪尾鸟的雄性确实拥有非常长的黑白分叉尾羽。雄性和雌性的上部羽毛呈发光的绿色，而雄性的喉部羽毛则呈亮紫色至品红色。
- en: The Peruvian sheartail is one of the smallest hummingbirds, and some believe
    it to be the lightest of all South American hummingbirds. The sheartail makes
    its home among the arid coastal shrubland of Peru, as well as in farmland, gardens,
    and orchards, where it forages flowering plants for nectar. The population is
    expanding into Chile, and individuals have also been sighted in Ecuador.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 秘鲁剪尾鸟是最小的蜂鸟之一，有人认为它是所有南美蜂鸟中体重最轻的。剪尾鸟栖息在秘鲁干旱的沿海灌木地带，以及农田、花园和果园中，寻找开花植物采集花蜜。它们的种群正在向智利扩展，个体也曾在厄瓜多尔被发现。
- en: Due to its stable population, the Peruvian sheartail has been classified by
    the IUCN as being of least concern from a conservation standpoint. Many of the
    animals on O’Reilly covers are endangered; all of them are important to the world.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其稳定的种群数量，秘鲁剪尾鸟被IUCN评定为从保护角度来看是最不受关注的物种。O’Reilly 封面上的许多动物都濒临灭绝；它们对世界至关重要。
- en: The cover illustration is by Karen Montgomery, based on an antique line engraving
    from Wood’s *Natural History*. The series design is by Edie Freedman, Ellie Volckhausen,
    and Karen Montgomery. The cover fonts are Gilroy Semibold and Guardian Sans. The
    text font is Adobe Minion Pro; the heading font is Adobe Myriad Condensed; and
    the code font is Dalton Maag’s Ubuntu Mono.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 封面插图由卡伦·蒙哥马利绘制，基于伍德斯的古线刻画。系列设计由伊迪·弗里德曼、埃莉·沃尔克豪森和卡伦·蒙哥马利完成。封面字体为Gilroy Semibold和Guardian
    Sans。正文字体为Adobe Minion Pro；标题字体为Adobe Myriad Condensed；代码字体为道尔顿·马格的Ubuntu Mono。
