- en: 'Chapter 17\. Data in Space: Networks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 17 章。空间中的数据：网络
- en: Time is nature’s way of keeping everything from happening at once. Space is
    what prevents everything from happening to me.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 时间是自然使一切都不同时发生的方式。空间则是防止一切同时发生于我身上的东西。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Quotes About Time](http://bit.ly/wiki-time)'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[关于时间的引语](http://bit.ly/wiki-time)'
- en: 'In [Chapter 15](ch15.html#ch_systems), you read about *concurrency*: how to
    do more than one thing at a time. Now we’ll try to do things in more than one
    place: *distributed computing* or *networking*. There are many good reasons to
    challenge time and space:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 15 章](ch15.html#ch_systems) 中，您了解了 *并发性*：如何同时做多件事情。现在我们将尝试在多个地方做事情：*分布式计算*
    或 *网络*。有许多充分的理由来挑战时间和空间：
- en: Performance
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 性能
- en: Your goal is to keep fast components busy, not waiting for slow ones.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您的目标是保持快速组件繁忙，而不是等待慢组件。
- en: Robustness
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 鲁棒性
- en: There’s safety in numbers, so you want to duplicate tasks to work around hardware
    and software failures.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数量越多越安全，因此您希望复制任务以解决硬件和软件故障。
- en: Simplicity
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 简洁性
- en: It’s best practice to break complex tasks into many little ones that are easier
    to create, understand, and fix.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是将复杂的任务分解成许多更容易创建、理解和修复的小任务。
- en: Scalability
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可伸缩性
- en: Increase your servers to handle load, decrease them to save money.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 增加服务器以处理负载，减少以节省成本。
- en: In this chapter, we work our way up from networking primitives to higher-level
    concepts. Let’s start with TCP/IP and sockets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从网络基元向更高级别的概念发展。让我们从 TCP/IP 和套接字开始。
- en: TCP/IP
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP
- en: The internet is based on rules about how to make connections, exchange data,
    terminate connections, handle timeouts, and so on. These are called *protocols*,
    and they are arranged in *layers*. The purpose of layers is to allow innovation
    and alternative ways of doing things; you can do anything you want on one layer
    as long as you follow the conventions in dealing with the layers above and below
    you.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网基于关于如何建立连接、交换数据、终止连接、处理超时等规则。这些被称为 *协议*，它们按层次排列。层次的目的是允许创新和以不同方式做事情的替代方式；只要您在处理上层和下层约定时遵循惯例，您可以在任何一层上做任何您想做的事情。
- en: 'The very lowest layer governs aspects such as electrical signals; each higher
    layer builds on those below. In the middle, more or less, is the IP (Internet
    Protocol) layer, which specifies how network locations are addressed and how *packets*
    (chunks) of data flow. In the layer above that, two protocols describe how to
    move bytes between locations:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最低层次管理诸如电信号等方面；每个更高的层次都建立在下面的层次之上。中间差不多是 IP（Internet Protocol）层，它指定网络位置的寻址方式以及*数据包*（数据块）的流动方式。在其上一层，有两个协议描述如何在位置之间传递字节：
- en: UDP (User Datagram Protocol)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: UDP（用户数据报协议）
- en: This is used for short exchanges. A *datagram* is a tiny message sent in a single
    burst, like a note on a postcard.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于短期交流。*数据报* 是一种以单次传送为单位的微小消息，就像明信片上的便签。
- en: TCP (Transmission Control Protocol)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: TCP（传输控制协议）
- en: This protocol is used for longer-lived connections. It sends *streams* of bytes
    and ensures that they arrive in order without duplication.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协议用于持久连接。它发送字节*流*，确保它们按顺序到达且不重复。
- en: 'UDP messages are not acknowledged, so you’re never sure whether they arrive
    at their destination. If you wanted to tell a joke over UDP:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 消息不会收到确认，因此你永远不确定它们是否到达目的地。如果你想通过 UDP 讲笑话：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'TCP sets up a secret handshake between sender and receiver to ensure a good
    connection. A TCP joke would start like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 在发送方和接收方之间建立秘密握手以确保良好的连接。一个 TCP 笑话会以这样开始：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Your local machine always has the IP address `127.0.0.1` and the name `localhost`.
    You might see this called the *loopback interface*. If it’s connected to the internet,
    your machine will also have a *public* IP. If you’re just using a home computer,
    it’s behind equipment such as a cable modem or router. You can run internet protocols
    even between processes on the same machine.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您的本地机器始终具有 IP 地址 `127.0.0.1` 和名称 `localhost`。您可能会看到这被称为 *环回接口*。如果连接到互联网，您的机器还将有一个
    *公共* IP。如果您只是使用家用计算机，则它位于诸如电缆调制解调器或路由器等设备之后。您可以在同一台机器上的进程之间运行互联网协议。
- en: Most of the internet with which we interact—the web, database servers, and so
    on—is based on the TCP protocol running atop the IP protocol; for brevity, TCP/IP.
    Let’s first look at some basic internet services. After that, we explore general
    networking patterns.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与之交互的大多数互联网——网页、数据库服务器等——都是基于 TCP 协议运行在 IP 协议之上的；简称 TCP/IP。让我们先看一些基本的互联网服务。之后，我们探索通用的网络模式。
- en: Sockets
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套接字
- en: If you like to know how things work, all the way down, this section is for you.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道事情是如何工作的，一直到底层，这一部分是为你准备的。
- en: The lowest level of network programming uses a *socket*, borrowed from the C
    language and the Unix operating system. Socket-level coding is tedious. You’ll
    have more fun using something like ZeroMQ, but it’s useful to see what lies beneath.
    For instance, messages about sockets often turn up when networking errors take
    place.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 网络编程的最底层使用了一个*socket*，从C语言和Unix操作系统中借用而来。套接字级别的编码很繁琐。使用像ZeroMQ这样的东西会更有趣，但看到底层是很有用的。例如，当发生网络错误时，关于套接字的消息经常出现。
- en: Let’s write a very simple client-server exchange, once with UDP and once with
    TCP. In the UDP example, the client sends a string in a UDP datagram to a server,
    and the server returns a packet of data containing a string. The server needs
    to listen at a particular address and port—like a post office and a post office
    box. The client needs to know these two values to deliver its message and receive
    any reply.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个非常简单的客户端-服务器交换，一次使用UDP，一次使用TCP。在UDP示例中，客户端将字符串发送到服务器的UDP数据报中，服务器返回一个包含字符串的数据包。服务器需要在特定地址和端口上监听，就像一个邮局和一个邮箱一样。客户端需要知道这两个值以便发送消息并接收任何回复。
- en: In the following client and server code, `address` is a tuple of (*address*,
    *port*). The `address` is a string, which can be a name or an *IP address*. When
    your programs are just talking to one another on the same machine, you can use
    the name `'localhost'` or the equivalent address string `'127.0.0.1'`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下客户端和服务器代码中，`address`是一个元组（*地址*，*端口*）。`address`是一个字符串，可以是名称或*IP地址*。当你的程序只是在同一台机器上相互交流时，你可以使用名称`'localhost'`或等效的地址字符串`'127.0.0.1'`。
- en: First, let’s send a little data from one process to another and return a little
    data back to the originator. The first program is the client and the second is
    the server. In each program, we print the time and open a socket. The server will
    listen for connections to its socket, and the client will write to its socket,
    which transmits a message to the server.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从一个进程向另一个进程发送一些数据，并将一些数据返回给发送者。第一个程序是客户端，第二个是服务器。在每个程序中，我们打印时间并打开一个套接字。服务器将监听其套接字的连接，客户端将写入其套接字，该套接字将向服务器传输一条消息。
- en: '[Example 17-1](#udp_server) presents the first program, *udp_server.py*.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-1](#udp_server)呈现了第一个程序，*udp_server.py*。'
- en: Example 17-1\. udp_server.py
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-1。udp_server.py
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The server has to set up networking through two methods imported from the `socket`
    package. The first method, `socket.socket`, creates a socket, and the second,
    `bind`, *binds* to it (listens to any data arriving at that IP address and port).
    `AF_INET` means we’ll create an IP socket. (There’s another type for *Unix domain
    sockets*, but those work only on the local machine.) `SOCK_DGRAM` means we’ll
    send and receive datagrams—in other words, we’ll use UDP.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器必须通过从`socket`包导入的两种方法来设置网络。第一个方法，`socket.socket`，创建一个套接字，第二个方法，`bind`，*绑定*到它（监听到达该IP地址和端口的任何数据）。`AF_INET`表示我们将创建一个IP套接字。（还有另一种类型的*Unix域套接字*，但这些仅在本地机器上工作。）`SOCK_DGRAM`表示我们将发送和接收数据报，换句话说，我们将使用UDP。
- en: At this point, the server sits and waits for a datagram to come in (`recvfrom`).
    When one arrives, the server wakes up and gets both the data and information about
    the client. The `client` variable contains the address and port combination needed
    to reach the client. The server ends by sending a reply and closing its connection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，服务器坐在那里等待数据报的到来（`recvfrom`）。当数据报到达时，服务器将唤醒并获取数据以及关于客户端的信息。`client`变量包含了到达客户端所需的地址和端口组合。服务器最后通过发送回复并关闭连接来结束。
- en: Let’s take a look at *udp_client.py* ([Example 17-2](#udp_client)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下*udp_client.py*（[示例 17-2](#udp_client)）。
- en: Example 17-2\. udp_client.py
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-2。udp_client.py
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The client has most of the same methods as the server (with the exception of
    `bind()`). The client sends and then receives, whereas the server receives first.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端有大部分与服务器相同的方法（除了`bind()`）。客户端先发送再接收，而服务器先接收。
- en: 'Start the server first, in its own window. It will print its greeting and then
    wait with an eerie calm until a client sends it some data:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在它自己的窗口中启动服务器。它将打印问候语，然后静静地等待，直到客户端发送一些数据：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, start the client in another window. It will print its greeting, send
    data (the bytes value `''Hey''`) to the server, print the reply, and then exit:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在另一个窗口中启动客户端。它将打印问候语，向服务器发送数据（字节值为`'Hey'`），打印回复，然后退出：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, the server will print the message it received, and exit:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，服务器将打印接收到的消息，并退出：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The client needed to know the server’s address and port number but didn’t need
    to specify a port number for itself. That was automatically assigned by the system—in
    this case, it was `56267`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端需要知道服务器的地址和端口号，但不需要为自己指定端口号。系统会自动分配端口号——在这种情况下是 `56267`。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: UDP sends data in single chunks. It does not guarantee delivery. If you send
    multiple messages via UDP, they can arrive out of order, or not at all. It’s fast,
    light, connectionless, and unreliable. UDP is useful when you need to push packets
    quickly, and can tolerate a lost packet now and then, such as with VoIP (voice
    over IP).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 以单个数据块发送数据。它不保证传递。如果通过 UDP 发送多个消息，它们可能无序到达，或者根本不到达。UDP 快速、轻便、无连接且不可靠。UDP
    在需要快速推送数据包并且可以偶尔容忍丢失数据包的情况下非常有用，比如 VoIP（互联网电话）。
- en: Which brings us to TCP (Transmission Control Protocol). TCP is used for longer-lived
    connections, such as the web. TCP delivers data in the order in which you send
    it. If there were any problems, it tries to send it again. This makes TCP a bit
    slower than UDP, but usually a better choice when you need all the packets, in
    the right order.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们来谈谈 TCP（传输控制协议）。TCP 用于更长时间的连接，比如 Web。TCP 按照发送顺序传递数据。如果出现任何问题，它会尝试重新发送。这使得
    TCP 比 UDP 稍慢，但通常在需要所有数据包按正确顺序到达时更可靠。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The first two versions of the web protocol HTTP were based on TCP, but HTTP/3
    is based on a protocol called [QUIC](https://oreil.ly/Y3Jym), which itself uses
    UDP. So choosing between UDP and TCP can involve many factors.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Web 协议 HTTP 的前两个版本基于 TCP，但 HTTP/3 基于一个称为 [QUIC](https://oreil.ly/Y3Jym) 的协议，QUIC
    本身使用 UDP。因此，在 UDP 和 TCP 之间选择可能涉及许多因素。
- en: Let’s shoot a few packets from client to server and back with TCP.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 TCP 从客户端到服务器再返回射击几个数据包。
- en: '*tcp_client.py* acts like the previous UDP client, sending only one string
    to the server, but there are small differences in the socket calls, illustrated
    in [Example 17-3](#tcp_client).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcp_client.py* 的行为类似于之前的 UDP 客户端，只向服务器发送一个字符串，但套接字调用中有小差异，[示例 17-3](#tcp_client)中有所说明。'
- en: Example 17-3\. tcp_client.py
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-3\. tcp_client.py
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ve replaced `SOCK_DGRAM` with `SOCK_STREAM` to get the streaming protocol,
    TCP. We also added a `connect()` call to set up the stream. We didn’t need that
    for UDP because each datagram was on its own in the wild, wooly internet.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用 `SOCK_STREAM` 替换了 `SOCK_DGRAM` 以获取流协议 TCP。我们还添加了一个 `connect()` 调用来建立流。我们在
    UDP 中不需要这样做，因为每个数据报都是独立的，存在于广阔而不受控制的互联网上。
- en: As [Example 17-4](#tcp_server) demonstrates, *tcp_server.py* also differs from
    its UDP cousin.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[示例 17-4](#tcp_server)所示，*tcp_server.py* 与其 UDP 表兄弟也有所不同。
- en: Example 17-4\. tcp_server.py
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-4\. tcp_server.py
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`server.listen(5)` is configured to queue up to five client connections before
    refusing new ones. `server.accept()` gets the first available message as it arrives.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.listen(5)` 被配置为在拒绝新连接之前排队最多五个客户端连接。`server.accept()` 获取到达的第一个可用消息。'
- en: The `client.recv(1000)` sets a maximum acceptable message length of 1,000 bytes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.recv(1000)` 设置了最大可接受消息长度为 1,000 字节。'
- en: 'As you did earlier, start the server and then the client, and watch the fun.
    First, the server:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，先启动服务器，然后启动客户端，看看有趣的事情发生了。首先是服务器：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, start the client. It will send its message to the server, receive a response,
    and then exit:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动客户端。它会将消息发送到服务器，接收响应，然后退出：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The server collects the message, prints it, responds, and then quits:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器收集消息，打印消息，响应消息，然后退出：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that the TCP server called `client.sendall()` to respond, and the earlier
    UDP server called `client.sendto()`. TCP maintains the client-server connection
    across multiple socket calls and remembers the client’s IP address.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 TCP 服务器调用了 `client.sendall()` 来响应，而之前的 UDP 服务器调用了 `client.sendto()`。TCP
    在多次套接字调用中维护客户端-服务器连接，并记住客户端的 IP 地址。
- en: 'This didn’t look so bad, but if you try to write anything more complex, you’ll
    see how sockets really operate at a low level:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来还不错，但如果你尝试写更复杂的内容，你会看到套接字在低层真正的操作方式：
- en: UDP sends messages, but their size is limited and they’re not guaranteed to
    reach their destination.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP 发送消息，但其大小受限且不能保证到达目的地。
- en: TCP sends streams of bytes, not messages. You don’t know how many bytes the
    system will send or receive with each call.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP 发送字节流，而不是消息。你不知道系统在每次调用中会发送或接收多少字节。
- en: 'To exchange entire messages with TCP, you need some extra information to reassemble
    the full message from its segments: a fixed message size (bytes), or the size
    of the full message, or some delimiting character.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用TCP交换整个消息，您需要一些额外的信息来从其段重新组装完整消息：固定的消息大小（字节），或完整消息的大小，或一些分隔字符。
- en: Because messages are bytes, not Unicode text strings, you need to use the Python
    `bytes` type. For more information on that, see [Chapter 12](ch12.html#ch_munging).
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为消息是字节而不是Unicode文本字符串，所以您需要使用Python的`bytes`类型。有关更多信息，请参阅[第12章](ch12.html#ch_munging)。
- en: After all of this, if you find yourself interested in socket programming, check
    out the Python socket programming [HOWTO](http://bit.ly/socket-howto) for more
    details.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一切之后，如果你对套接字编程感兴趣，请查看Python套接字编程[HOWTO](http://bit.ly/socket-howto)获取更多详细信息。
- en: Scapy
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scapy
- en: Sometimes you need to dip into the networking stream and watch the bytes swimming
    by. You may want to debug a web API, or track down some security issue. The `scapy`
    library and program provide a domain-specific language to create and inspect packets
    in Python, which is much easier than writing and debugging the equivalent C programs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要深入网络流并观察数据字节的传递。您可能需要调试Web API或追踪某些安全问题。`scapy`库和程序提供了一个领域特定语言，用于在Python中创建和检查数据包，这比编写和调试等效的C程序要容易得多。
- en: A standard install uses `pip install scapy`. The [docs](https://scapy.readthedocs.io)
    are extremely thorough. If you use tools like `tcpdump` or `wireshark` to investigate
    TCP issues, you should look at `scapy`. Finally, don’t confuse `scapy` with `scrapy`,
    which is covered in [“Crawl and Scrape”](ch18.html#scraping).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 标准安装使用`pip install scapy`。[文档](https://scapy.readthedocs.io)非常详尽。如果您使用`tcpdump`或`wireshark`等工具来调查TCP问题，您应该查看`scapy`。最后，请不要将`scapy`与`scrapy`混淆，后者在[“爬取和抓取”](ch18.html#scraping)中有介绍。
- en: Netcat
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Netcat
- en: 'Another tool to test networks and ports is [Netcat](https://oreil.ly/K37H2),
    often abbreviated to `nc`. Here’s an example of an HTTP connnection to Google’s
    website, and requesting some basic information about its home page:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个测试网络和端口的工具是[Netcat](https://oreil.ly/K37H2)，通常缩写为`nc`。这里有一个连接到谷歌网站的HTTP示例，并请求其主页的一些基本信息：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the next chapter, there’s an example that uses [“Test with telnet”](ch18.html#telnet)
    to do the same.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，有一个示例使用[“使用 telnet 进行测试”](ch18.html#telnet)来做同样的事情。
- en: Networking Patterns
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络模式
- en: 'You can build networking applications from some basic patterns:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从一些基本模式构建网络应用程序：
- en: 'The most common pattern is *request*-*reply*, also known as *request*-*response*
    or *client*-*server*. This pattern is synchronous: the client waits until the
    server responds. You’ve seen many examples of request-reply in this book. Your
    web browser is also a client, making an HTTP request to a web server, which returns
    a reply.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最常见的模式是*请求*-*回复*，也称为*请求*-*响应*或*客户端*-*服务器*。这种模式是同步的：客户端等待服务器响应。在本书中您已经看到了许多请求-响应的例子。您的Web浏览器也是一个客户端，向Web服务器发送HTTP请求，后者返回一个响应。
- en: 'Another common pattern is *push*, or *fanout*: you send data to any available
    worker in a pool of processes. An example is a web server behind a load balancer.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种常见模式是*推送*或*扇出*：您将数据发送到进程池中的任何可用工作进程。一个例子是负载均衡器后面的Web服务器。
- en: 'The opposite of push is *pull*, or *fanin*: you accept data from one or more
    sources. An example would be a logger that takes text messages from multiple processes
    and writes them to a single log file.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送的反义是*拉取*或*扇入*：您从一个或多个来源接受数据。一个例子是一个日志记录器，它从多个进程接收文本消息并将它们写入单个日志文件。
- en: 'One pattern is similar to radio or television broadcasting: *publish*-*subscribe*,
    or *pub*-*sub*. With this pattern, a publisher sends out data. In a simple pub-sub
    system, all subscribers would receive a copy. More often, subscribers can indicate
    that they’re interested only in certain types of data (often called a *topic*),
    and the publisher will send just those. So, unlike the push pattern, more than
    one subscriber might receive a given piece of data. If there’s no subscriber for
    a topic, the data are ignored.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种模式类似于广播电台或电视广播：*发布*-*订阅*，或*pub*-*sub*。使用此模式，发布者发送数据。在简单的发布-订阅系统中，所有订阅者都会收到一份副本。更常见的是，订阅者可以指示他们仅对某些类型的数据感兴趣（通常称为*主题*），发布者将仅发送这些数据。因此，与推送模式不同，可能会有多个订阅者收到给定数据。如果没有主题的订阅者，则数据将被忽略。
- en: Let’s show some request-reply examples, and later some pub-sub ones.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示一些请求-响应的例子，稍后再展示一些发布-订阅的例子。
- en: The Request-Reply Pattern
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求-响应模式
- en: This is the most familiar pattern. You request DNS, web, or email data from
    the appropriate servers, and they reply, or tell you whether there’s a problem.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最熟悉的模式。您可以从适当的服务器请求DNS、Web或电子邮件数据，它们会回复，或告诉您是否有问题。
- en: I just showed you how to make some basic requests with UDP or TCP, but it’s
    hard to build a networking application at the socket level. Let’s see if ZeroMQ
    can help.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚向你展示了如何使用UDP或TCP进行一些基本的请求，但在套接字级别上构建网络应用程序很难。让我们看看ZeroMQ是否可以帮助解决这个问题。
- en: ZeroMQ
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ZeroMQ
- en: 'ZeroMQ is a library, not a server. Sometimes described as *sockets on steroids*,
    ZeroMQ sockets do the things that you sort of expected plain sockets to do:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ZeroMQ是一个库，不是一个服务器。有时被描述为*增强版套接字*，ZeroMQ套接字执行的是您预期普通套接字能够执行的操作：
- en: Exchange entire messages
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换整个消息
- en: Retry connections
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试连接
- en: Buffer data to preserve them when the timing between senders and receivers doesn’t
    line up
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲数据以在发件人和接收者之间的时间不匹配时保护它们
- en: 'The [online guide](http://zguide.zeromq.org) is well written and witty, and
    it presents the best description of networking patterns that I’ve seen. The printed
    version (*ZeroMQ: Messaging for Many Applications*, by Pieter Hintjens, from that
    animal house, O’Reilly) has that good code smell and a big fish on the cover,
    rather than the other way around. All the examples in the printed guide are in
    the C language, but the online version lets you choose from multiple languages
    for each code example. The Python [examples are also viewable](http://bit.ly/zeromq-py).
    In this chapter, I show you some basic request-reply ZeroMQ examples.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[在线指南](http://zguide.zeromq.org)写得很好，富有幽默感，并且它提供了我见过的最佳网络模式描述。印刷版（*ZeroMQ:
    Messaging for Many Applications*，作者Pieter Hintjens，出版商是O''Reilly，上面有一条大鱼）有着良好的代码质量，但不是反过来。印刷指南中的所有示例都是用C语言编写的，但在线版本可以让您为每个代码示例选择多种语言，Python的[示例也可以查看](http://bit.ly/zeromq-py)。在本章中，我将向您展示一些基本的请求-回复ZeroMQ示例。'
- en: 'ZeroMQ is like a LEGO set, and we all know that you can build an amazing variety
    of things from a few Lego shapes. In this case, you construct networks from a
    few socket types and patterns. The basic “LEGO pieces” presented in the following
    list are the ZeroMQ socket types, which by some twist of fate look like the network
    patterns we’ve already discussed:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ZeroMQ就像一个乐高积木套件，我们都知道您可以从几个乐高形状构建出各种惊人的东西。在这种情况下，您从几种套接字类型和模式构建网络。以下列出的基本“乐高积木”是ZeroMQ套接字类型，出于某种巧合，它们看起来像我们已经讨论过的网络模式：
- en: REQ (synchronous request)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REQ（同步请求）
- en: REP (synchronous reply)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REP（同步回复）
- en: DEALER (asynchronous request)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DEALER（异步请求）
- en: ROUTER (asynchronous reply)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROUTER（异步回复）
- en: PUB (publish)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PUB（发布）
- en: SUB (subscribe)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SUB（订阅）
- en: PUSH (fanout)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PUSH（扇出）
- en: PULL (fanin)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PULL（汇聚）
- en: 'To try these yourself, you’ll need to install the Python ZeroMQ library by
    typing this command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要自己尝试这些内容，您需要通过输入以下命令安装Python ZeroMQ库：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The simplest pattern is a single request-reply pair. This is synchronous: one
    socket makes a request and then the other replies. First, the code for the reply
    (server), *zmq_server.py*, as shown in [Example 17-5](#zmq_server).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的模式是一个单一的请求-回复对。这是同步的：一个套接字发送请求，然后另一个套接字回复。首先是回复（服务器）的代码，*zmq_server.py*，如示例[17-5](#zmq_server)所示。
- en: Example 17-5\. zmq_server.py
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-5\. zmq_server.py
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We create a `Context` object: this is a ZeroMQ object that maintains state.
    Then, we make a ZeroMQ `socket` of type `REP` (for REPly). We call `bind()` to
    make it listen on a particular IP address and port. Notice that they’re specified
    in a string such as `''tcp://localhost:6789''` rather than a tuple, as in the
    plain-socket examples.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`Context`对象：这是一个维护状态的ZeroMQ对象。然后，我们创建一个类型为`REP`（代表回复）的ZeroMQ`socket`。我们调用`bind()`方法使其监听特定的IP地址和端口。请注意，它们以字符串形式指定，如`'tcp://localhost:6789'`，而不是像普通套接字示例中的元组。
- en: This example keeps receiving requests from a sender and sending a response.
    The messages can be very long—ZeroMQ takes care of the details.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例保持接收来自发送方的请求并发送响应。消息可能非常长，但ZeroMQ会处理这些细节。
- en: '[Example 17-6](#zmq_client) shows the code for the corresponding request (client),
    *zmq_client.py*. Its type is `REQ` (for REQuest), and it calls `connect()` rather
    than `bind()`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-6](#zmq_client)展示了相应请求（客户端）的代码，*zmq_client.py*。其类型为`REQ`（代表请求），并调用了`connect()`而不是`bind()`。'
- en: Example 17-6\. zmq_client.py
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-6\. zmq_client.py
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now it’s time to start them. One interesting difference from the plain-socket
    examples is that you can start the server and client in either order. Go ahead
    and start the server in one window in the background:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候启动它们了。与普通套接字示例的一个有趣区别是，你可以按任意顺序启动服务器和客户端。请在一个窗口后台启动服务器：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Start the client in the same window:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一窗口中启动客户端：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You’ll see these alternating output lines from the client and server:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到客户端和服务器交替输出的这些行：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our client ends after sending its fifth message, but we didn’t tell the server
    to quit, so it sits by the phone, waiting for another message. If you run the
    client again, it will print the same five lines, and the server will print its
    five also. If you don’t kill the *zmq_server.py* process and try to run another
    one, Python will complain that the address is already is use:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端在发送其第五条消息后结束，但我们没有告诉服务器退出，所以它仍然在等待另一条消息。如果您再次运行客户端，它将打印相同的五行，服务器也会打印它的五行。如果您不终止
    *zmq_server.py* 进程并尝试运行另一个，Python 将投诉地址已经在使用中。
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The messages need to be sent as byte strings, so we encoded our example’s text
    strings in UTF-8 format. You can send any kind of message you like, as long as
    you convert it to `bytes`. We used simple text strings as the source of our messages,
    so `encode()` and `decode()` were enough to convert to and from byte strings.
    If your messages have other data types, you can use a library such as [MessagePack](http://msgpack.org).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 消息需要以字节字符串形式发送，因此我们以 UTF-8 格式对示例的文本字符串进行了编码。您可以发送任何类型的消息，只要将其转换为 `bytes`。我们使用简单的文本字符串作为消息的源，因此
    `encode()` 和 `decode()` 足以进行字节字符串的转换。如果您的消息具有其他数据类型，可以使用像 [MessagePack](http://msgpack.org)
    这样的库。
- en: Even this basic REQ-REP pattern allows for some fancy communication patterns,
    because any number of REQ clients can `connect()` to a single `REP` server. The
    server handles requests one at a time, synchronously, but doesn’t drop other requests
    that are arriving in the meantime. ZeroMQ buffers messages, up to some specified
    limit, until they can get through; that’s where it earns the Q in its name. The
    Q stands for Queue, the M stands for Message, and the Zero means there doesn’t
    need to be any broker.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这种基本的 REQ-REP 模式也允许一些花式通信模式，因为任意数量的 REQ clients 可以 `connect()` 到单个 `REP` server。服务器一次处理一个请求，同步地，但不会丢弃同时到达的其他请求。ZeroMQ
    缓冲消息，直到它们能够通过，这是它名字中 Q 的来源。Q 代表队列，M 代表消息，而 Zero 意味着不需要任何代理。
- en: Although ZeroMQ doesn’t impose any central brokers (intermediaries), you can
    build them where needed. For example, use DEALER and ROUTER sockets to connect
    multiple sources and/or destinations asynchronously.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 ZeroMQ 不强制使用任何中央代理（中介），但可以在需要时构建它们。例如，使用 DEALER 和 ROUTER sockets 异步连接多个源和/或目的地。
- en: Multiple REQ sockets connect to a single ROUTER, which passes each request to
    a DEALER, which then contacts any REP sockets that have connected to it ([Figure 17-1](#fig_broker)).
    This is similar to a bunch of browsers contacting a proxy server in front of a
    web server farm. It lets you add multiple clients and servers as needed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 多个 REQ sockets 连接到单个 ROUTER，后者将每个请求传递给 DEALER，然后再联系连接到它的任何 REP sockets（[Figure 17-1](#fig_broker)）。这类似于一堆浏览器联系位于
    web 服务器群前面的代理服务器。它允许您根据需要添加多个客户端和服务器。
- en: The REQ sockets connect only to the ROUTER socket; the DEALER connects to the
    multiple REP sockets behind it. ZeroMQ takes care of the nasty details, ensuring
    that the requests are load balanced and that the replies go back to the right
    place.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: REQ sockets 只连接到 ROUTER socket；DEALER 则连接到它后面的多个 REP sockets。ZeroMQ 处理繁琐的细节，确保请求负载平衡，并且确保回复返回到正确的地方。
- en: Another networking pattern called the *ventilator* uses PUSH sockets to farm
    out asynchronous tasks, and PULL sockets to gather the results.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个网络模式称为*ventilator*，使用 PUSH sockets 分发异步任务，并使用 PULL sockets 收集结果。
- en: 'The last notable feature of ZeroMQ is that it scales up *and* down, just by
    changing the connection type of the socket when it’s created:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ZeroMQ 的最后一个显著特点是，通过在创建时改变套接字的连接类型，它可以进行*上下*的扩展：
- en: '`tcp` between processes, on one or more machines'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tcp` 是在一台或多台机器上进程之间的通信方式。'
- en: '`ipc` between processes on one machine'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipc` 是在同一台机器上进程之间的通信方式。'
- en: '`inproc` between threads in a single process'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inproc` 是单个进程内线程之间的通信方式。'
- en: That last one, `inproc`, is a way to pass data between threads without locks,
    and an alternative to the `threading` example in [“Threads”](ch15.html#threads).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个，`inproc`，是一种在不使用锁的情况下在线程之间传递数据的方式，也是在[“Threads”](ch15.html#threads)中 `threading`
    示例的替代方式。
- en: '![inp2 1701](assets/inp2_1701.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![inp2 1701](assets/inp2_1701.png)'
- en: Figure 17-1\. Using a broker to connect multiple clients and services
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 17-1\. 使用经纪人连接多个客户端和服务
- en: After using ZeroMQ, you may not want to write raw socket code again.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了 ZeroMQ 后，您可能不再想编写原始套接字代码。
- en: Other Messaging Tools
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他消息传递工具
- en: 'ZeroMQ is certainly not the only message-passing library that Python supports.
    Message passing is one of the most popular ideas in networking, and Python keeps
    up with other languages:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ZeroMQ 绝对不是 Python 支持的唯一消息传递库。消息传递是网络中最流行的概念之一，而 Python 与其他语言保持同步：
- en: The Apache project, whose web server we saw in [“Apache”](ch18.html#apache),
    also maintains the [ActiveMQ](https://activemq.apache.org) project, including
    several Python interfaces using the simple-text [STOMP](https://oreil.ly/a3h_M)
    protocol.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache 项目，我们在[“Apache”](ch18.html#apache)中看到其 Web 服务器，还维护 [ActiveMQ](https://activemq.apache.org)
    项目，包括使用简单文本 [STOMP](https://oreil.ly/a3h_M) 协议的几个 Python 接口。
- en: '[RabbitMQ](http://www.rabbitmq.com) is also popular, and it has useful online
    Python [tutorials](http://bit.ly/rabbitmq-tut).'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RabbitMQ](http://www.rabbitmq.com) 也很受欢迎，它有有用的在线 Python [教程](http://bit.ly/rabbitmq-tut)。'
- en: '[NATS](http://www.nats.io) is a fast messaging system, written in Go.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NATS](http://www.nats.io) 是一个快速的消息系统，使用 Go 编写。'
- en: The Publish-Subscribe Pattern
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布-订阅模式
- en: Publish-subscribe is not a queue but a broadcast. One or more processes publish
    messages. Each subscriber process indicates what type of messages it would like
    to receive. A copy of each message is sent to each subscriber that matched its
    type. Thus, a given message might be processed once, more than once, or not at
    all. Like a lonely radio operator, each publisher is just broadcasting and doesn’t
    know who, if anyone, is listening.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅不是队列，而是广播。一个或多个进程发布消息。每个订阅进程指示它想接收哪些类型的消息。每条消息的副本都发送给与其类型匹配的每个订阅者。因此，给定消息可能会被处理一次，多次或根本不处理。就像一个孤独的无线电操作员一样，每个发布者只是广播，并不知道谁在听。
- en: Redis
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redis
- en: You’ve seen Redis in [Chapter 16](ch16.html#ch_databases), mainly as a data
    structure server, but it also contains a pub-sub system. The publisher emits messages
    with a topic and a value, and subscribers say which topics they want to receive.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 16 章](ch16.html#ch_databases)中，您已经看过 Redis，主要作为数据结构服务器，但它也包含发布-订阅系统。发布者通过主题和值发送消息，订阅者指定它们想要接收的主题。
- en: '[Example 17-7](#redis_pub) contains a publisher, *redis_pub.py*.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-7](#redis_pub) 包含一个发布者，*redis_pub.py*。'
- en: Example 17-7\. redis_pub.py
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-7\. redis_pub.py
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each topic is a breed of cat, and the accompanying message is a type of hat.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主题都是一种猫的品种，伴随的消息是一种帽子的类型。
- en: '[Example 17-8](#redis_sub) shows a single subscriber, *redis_sub.py*.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-8](#redis_sub) 展示了一个单一的订阅者，*redis_sub.py*。'
- en: Example 17-8\. redis_sub.py
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-8\. redis_sub.py
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This subscriber wants all messages for cat types `'maine coon'` and `'persian'`,
    and no others. The `listen()` method returns a dictionary. If its type is `'message'`,
    it was sent by the publisher and matches our criteria. The `'channel'` key is
    the topic (cat), and the `'data'` key contains the message (hat).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此订阅者希望接收所有 `'maine coon'` 和 `'persian'` 类型的消息，而不是其他类型。`listen()` 方法返回一个字典。如果其类型是
    `'message'`，则它是由发布者发送并符合我们的标准。 `'channel'` 键是主题（猫），`'data'` 键包含消息（帽子）。
- en: 'If you start the publisher first and no one is listening, it’s like a mime
    falling in the forest (does he make a sound?), so start the subscriber first:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您先启动发布者而没有人在监听，就像一位哑剧艺术家在森林中倒下（他会发出声音吗？），所以先启动订阅者：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, start the publisher. It will send 10 messages and then quit:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来启动发布者。它会发送 10 条消息然后退出：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The subscriber cares about only two types of cat:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者只关心两种类型的猫：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We didn’t tell the subscriber to quit, so it’s still waiting for messages. If
    you restart the publisher, the subscriber will grab a few more messages and print
    them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有告诉订阅者退出，所以它仍在等待消息。如果重新启动发布者，订阅者将抓取更多消息并打印它们。
- en: You can have as many subscribers (and publishers) as you want. If there’s no
    subscriber for a message, it disappears from the Redis server. However, if there
    are subscribers, the messages stay in the server until all subscribers have retrieved
    them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以拥有任意数量的订阅者（和发布者）。如果没有消息的订阅者，消息会从 Redis 服务器中消失。但是，如果有订阅者，消息会一直留在服务器中，直到所有订阅者都检索到它们。
- en: ZeroMQ
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ZeroMQ
- en: ZeroMQ has no central server, so each publisher writes to all subscribers. The
    publisher, *zmq_pub.py*, is provided in [Example 17-9](#zmq_pub).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ZeroMQ 没有中央服务器，因此每个发布者都向所有订阅者写入。发布者 *zmq_pub.py* 提供在[示例 17-9](#zmq_pub)。
- en: Example 17-9\. zmq_pub.py
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-9\. zmq_pub.py
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice how this code uses UTF-8 encoding for the topic and value strings.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此代码如何使用 UTF-8 编码来处理主题和值字符串。
- en: The file for the subscriber is *zmq_sub.py* ([Example 17-10](#zmq_sub)).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者的文件名为 *zmq_sub.py*（[例 17-10](#zmq_sub)）。
- en: Example 17-10\. zmq_sub.py
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例 17-10\. zmq_sub.py
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this code, we subscribe to two different byte values: the two strings in
    `topics`, encoded as UTF-8.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们订阅了两个不同的字节值：`topics` 中的两个字符串，编码为 UTF-8。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It seems a little backward, but if you want *all* topics, you need to subscribe
    to the empty bytestring `b''`; if you don’t, you’ll get nothing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有点反向，但如果您想订阅 *所有* 主题，则需要订阅空字节字符串 `b''`；如果不这样做，您将一无所获。
- en: Notice that we call `send_multipart()` in the publisher and `recv_multipart()`
    in the subscriber. This makes it possible for us to send multipart messages and
    use the first part as the topic. We could also send the topic and message as a
    single string or bytestring, but it seems cleaner to keep cats and hats separate.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在发布者中我们称之为 `send_multipart()`，而在订阅者中称之为 `recv_multipart()`。这使我们能够发送多部分消息并将第一部分用作主题。我们也可以将主题和消息作为单个字符串或字节字符串发送，但将它们分开看起来更清晰。
- en: 'Start the subscriber:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 启动订阅者：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Start the publisher. It immediately sends 10 messages and then quits:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 启动发布者。它立即发送 10 条消息然后退出：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The subscriber prints what it requested and received:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者打印其请求和接收的内容：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Other Pub-Sub Tools
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他 Pub-Sub 工具
- en: 'You might like to explore some of these other Python pub-sub links:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望探索一些其他 Python 发布-订阅链接：
- en: RabbitMQ is a well-known messaging broker, and `pika` is a Python API for it.
    See [the `pika` documentation](http://pika.readthedocs.org) and a [pub-sub tutorial](http://bit.ly/pub-sub-tut).
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ 是一个著名的消息代理，`pika` 是其 Python API。参见 [pika 文档](http://pika.readthedocs.org)
    和 [发布-订阅教程](http://bit.ly/pub-sub-tut)。
- en: Go to the [PyPi](https://pypi.python.org) search window and type `pubsub` to
    find Python packages like [`pypubsub`](http://pubsub.sourceforge.net).
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转到 [PyPi](https://pypi.python.org) 搜索窗口，并键入 `pubsub` 以查找类似 [`pypubsub`](http://pubsub.sourceforge.net)
    的 Python 包。
- en: '[PubSubHubbub](https://code.google.com/p/pubsubhubbub) enables subscribers
    to register callbacks with publishers.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PubSubHubbub](https://code.google.com/p/pubsubhubbub) 允许订阅者向发布者注册回调。'
- en: '[NATS](https://nats.io) is a fast, open source messaging system that supports
    pub-sub, request-reply, and queuing.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NATS](https://nats.io) 是一个快速、开源的消息系统，支持发布-订阅、请求-响应和排队。'
- en: Internet Services
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网服务
- en: Python has an extensive networking toolset. In the following sections, we look
    at ways to automate some of the most popular internet services. The official,
    comprehensive [documentation](http://bit.ly/py-internet) is available online.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Python 拥有广泛的网络工具集。在接下来的几节中，我们将探讨如何自动化一些最流行的互联网服务。官方、全面的 [文档](http://bit.ly/py-internet)
    在线可用。
- en: Domain Name System
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域名系统
- en: Computers have numeric IP addresses such as `85.2.101.94`, but we remember names
    better than numbers. The Domain Name System (DNS) is a critical internet service
    that converts IP addresses to and from names via a distributed database. Whenever
    you’re using a web browser and suddenly see a message like “looking up host,”
    you’ve probably lost your internet connection, and your first clue is a DNS failure.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机具有如 `85.2.101.94` 这样的数字 IP 地址，但我们更容易记住名称而不是数字。域名系统（DNS）是一个关键的互联网服务，通过分布式数据库将
    IP 地址与名称相互转换。每当您在使用 Web 浏览器时突然看到“looking up host”这样的消息时，您可能已经失去了互联网连接，而您的第一个线索是
    DNS 失败。
- en: 'Some DNS functions are found in the low-level `socket` module. `gethostbyname()`
    returns the IP address for a domain name, and the extended edition `gethostbyname_ex()`
    returns the name, a list of alternative names, and a list of addresses:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 DNS 功能可以在低级别的 `socket` 模块中找到。`gethostbyname()` 返回域名的 IP 地址，而扩展版的 `gethostbyname_ex()`
    返回名称、备用名称列表和地址列表：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `getaddrinfo()` method looks up the IP address, but it also returns enough
    information to create a socket to connect to it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`getaddrinfo()` 方法查找 IP 地址，但它还返回足够的信息以创建一个连接到该地址的套接字：'
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding call returned two tuples: the first for UDP, and the second for
    TCP (the `6` in the `2, 1, 6` is the value for TCP).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的调用返回了两个元组：第一个用于 UDP，第二个用于 TCP（`2, 1, 6` 中的 `6` 是 TCP 的值）。
- en: 'You can ask for TCP or UDP information only:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以仅请求 TCP 或 UDP 信息：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Some [TCP and UDP port numbers](http://bit.ly/tcp-udp-ports) are reserved for
    certain services by IANA, and are associated with service names. For example,
    HTTP is named `http` and is assigned TCP port 80.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 [TCP 和 UDP 端口号](http://bit.ly/tcp-udp-ports) 由 IANA 保留，并与服务名称相关联。例如，HTTP
    被命名为 `http` 并分配给 TCP 端口 80。
- en: 'These functions convert between service names and port numbers:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在服务名称和端口号之间进行转换：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Python Email Modules
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 电子邮件模块
- en: 'The standard library contains these email modules:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库包含以下电子邮件模块：
- en: '[`smtplib`](https://oreil.ly/_kF6V) for sending email messages via Simple Mail
    Transfer Protocol (SMTP)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`smtplib`](https://oreil.ly/_kF6V) 用于通过简单邮件传输协议 (SMTP) 发送电子邮件消息'
- en: '[`email`](https://oreil.ly/WVGbE) for creating and parsing email messages'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`email`](https://oreil.ly/WVGbE) 用于创建和解析电子邮件消息'
- en: '[`poplib`](https://oreil.ly/xiJT7) for reading email via Post Office Protocol
    3 (POP3)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`poplib`](https://oreil.ly/xiJT7) 用于通过邮局协议 3 (POP3) 读取电子邮件'
- en: '[`imaplib`](https://oreil.ly/wengo) for reading email via Internet Message
    Access Protocol (IMAP)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`imaplib`](https://oreil.ly/wengo) 用于通过互联网消息访问协议 (IMAP) 读取电子邮件'
- en: If you want to write your own Python SMTP server, try [`smtpd`](https://oreil.ly/JkLsD),
    or the new asynchronous version [`aiosmtpd`](https://aiosmtpd.readthedocs.io).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想编写自己的 Python SMTP 服务器，请尝试[`smtpd`](https://oreil.ly/JkLsD)，或者新的异步版本[`aiosmtpd`](https://aiosmtpd.readthedocs.io)。
- en: Other Protocols
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他协议
- en: Using the standard [`ftplib` module](http://bit.ly/py-ftplib), you can push
    bytes around by using the File Transfer Protocol (FTP). Although it’s an old protocol,
    FTP still performs very well.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准的[`ftplib` 模块](http://bit.ly/py-ftplib)，你可以通过文件传输协议 (FTP) 传输字节。尽管这是一个老协议，FTP
    仍然表现非常好。
- en: You’ve seen many of these modules in various places in this book, but also try
    the documentation for standard library support of [internet protocols](http://bit.ly/py-internet).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本书的多个地方看到了这些模块，但也尝试一下标准库支持的[互联网协议](http://bit.ly/py-internet)的文档。
- en: Web Services and APIs
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 服务和 API
- en: Information providers always have a website, but those are targeted for human
    eyes, not automation. If data is published only on a website, anyone who wants
    to access and structure the data needs to write scrapers (as shown in [“Crawl
    and Scrape”](ch18.html#scraping)), and rewrite them each time a page format changes.
    This is usually tedious. In contrast, if a website offers an API to its data,
    the data becomes directly available to client programs. APIs change less often
    than web page layouts, so client rewrites are less common. A fast, clean data
    pipeline also makes it easier to build unforeseen but useful combinations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 信息提供者总是有网站，但这些网站面向的是人类眼睛，而不是自动化。如果数据仅在网站上发布，任何想要访问和结构化数据的人都需要编写爬虫（如[“爬取和解析”](ch18.html#scraping)中所示），并在页面格式更改时重新编写。这通常很乏味。相比之下，如果一个网站提供其数据的
    API，数据就可以直接提供给客户端程序。API 的更改频率比网页布局低，因此客户端重写较少。一个快速、清晰的数据管道也使得构建未曾预见但有用的组合更加容易。
- en: In many ways, the easiest API is a web interface, but one that provides data
    in a structured format such as JSON or XML rather than plain text or HTML. The
    API might be minimal or a full-fledged RESTful API (defined in [“Web APIs and
    REST”](ch18.html#rest)), but it provides another outlet for those restless bytes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，最简单的 API 是一个 Web 接口，但提供的数据是结构化格式，如 JSON 或 XML，而不是纯文本或 HTML。API 可能很简单，也可能是完整的
    RESTful API（在[“Web API 和 REST”](ch18.html#rest)中定义），但它为这些不安静的字节提供了另一个出口。
- en: At the very beginning of this book, you saw a web API query the Internet Archive
    for an old copy of a website.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的开头，你看到了一个 Web API 查询互联网档案馆以获取旧网站的副本。
- en: APIs are especially useful for mining well-known social media sites such as
    Twitter, Facebook, and LinkedIn. All these sites provide APIs that are free to
    use, but they require you to register and get a key (a long-generated text string,
    sometimes also known as a *token*) to use when connecting. The key lets a site
    determine who’s accessing its data. It can also serve as a way to limit request
    traffic to servers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: API 尤其适用于挖掘像 Twitter、Facebook 和 LinkedIn 这样的知名社交媒体网站。所有这些网站都提供免费使用的 API，但需要注册并获取一个密钥（一个长生成的文本字符串，有时也称为*令牌*）以在连接时使用。密钥使得网站能够确定谁在访问其数据。它还可以作为限制请求流量到服务器的一种方式。
- en: 'Here are some interesting service APIs:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的服务 API：
- en: '[New York Times](http://developer.nytimes.com)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[纽约时报](http://developer.nytimes.com)'
- en: '[Twitter](https://python-twitter.readthedocs.io)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Twitter](https://python-twitter.readthedocs.io)'
- en: '[Facebook](https://developers.facebook.com/tools)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Facebook](https://developers.facebook.com/tools)'
- en: '[Weather Underground](http://www.wunderground.com/weather/api)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Weather Underground](http://www.wunderground.com/weather/api)'
- en: '[Marvel Comics](http://developer.marvel.com)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[漫威漫画](http://developer.marvel.com)'
- en: You can see examples of APIs for maps in [Chapter 21](ch21.html#ch_business),
    and others in [Chapter 22](ch22.html#ch_science).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第 21 章](ch21.html#ch_business)看到地图 API 的示例，以及在[第 22 章](ch22.html#ch_science)看到其他内容。
- en: Data Serialization
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据序列化
- en: As you saw in [Chapter 16](ch16.html#ch_databases), formats like XML, JSON,
    and YAML are ways to store structured text data. Networked applications need to
    exchange data with other programs. The conversion between data in memory and byte
    sequences “on the wire” is called *serialization* or *marshaling*. JSON is a popular
    serialization format, especially with web RESTful systems, but it can’t express
    all Python data types directly. Also, as a text format it tends to be more verbose
    than some binary serialization methods. Let’s look at some approaches that you’re
    likely to run into.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 [第16章](ch16.html#ch_databases) 中看到的，像 XML、JSON 和 YAML 这样的格式是存储结构化文本数据的方式。网络应用程序需要与其他程序交换数据。在内存中和“在传输线上”之间的数据转换称为
    *序列化* 或 *编组*。JSON 是一种流行的序列化格式，特别适用于 Web RESTful 系统，但它不能直接表示所有 Python 数据类型。另外，作为文本格式，它往往比某些二进制序列化方法更冗长。让我们看看一些你可能会遇到的方法。
- en: Serialize with pickle
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pickle 进行序列化
- en: Python provides the `pickle` module to save and restore any object in a special
    binary format.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了 `pickle` 模块来保存和恢复任何对象到一个特殊的二进制格式。
- en: 'Remember how JSON lost its mind when encountering a `datetime` object? Not
    a problem for `pickle`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得 JSON 在遇到 `datetime` 对象时变得混乱吗？对于 `pickle` 来说不是问题：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`pickle` works with your own classes and objects, too. Let’s define a little
    class called `Tiny` that returns the string `''tiny''` when treated as a string:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle` 也可以处理你自己定义的类和对象。让我们定义一个叫做 `Tiny` 的小类，在被当作字符串处理时返回字符串 `''tiny''`：'
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`pickled` is the pickled binary string made from the object `obj1`. We converted
    that back to the object `obj2` to make a copy of `obj1`. Use `dump()` to pickle
    to a file, and `load()` to unpickle from one.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickled` 是从对象 `obj1` 制作的 pickled 二进制字符串。我们将其转换回对象 `obj2` 来复制 `obj1`。使用 `dump()`
    将 pickle 到文件，使用 `load()` 从文件中反序列化。'
- en: The `multiprocessing` module uses `pickle` to interchange data among processes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing` 模块使用 `pickle` 在进程之间交换数据。'
- en: If `pickle` can’t serialize your data format, a newer third-party package called
    [`dill`](https://pypi.org/project/dill) might.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `pickle` 无法序列化你的数据格式，一个更新的第三方包叫做 [`dill`](https://pypi.org/project/dill)
    可能会有所帮助。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Because `pickle` can create Python objects, the same security warnings that
    were discussed in earlier sections apply. A public service announcement: don’t
    unpickle something that you don’t trust.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `pickle` 可以创建 Python 对象，所以同样适用于之前讨论过的安全警告。公共服务公告：不要反序列化你不信任的内容。
- en: Other Serialization Formats
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他序列化格式
- en: 'These binary data interchange formats are usually more compact and faster than
    XML or JSON:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些二进制数据交换格式通常比 XML 或 JSON 更紧凑且更快：
- en: '[MsgPack](http://msgpack.org)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MsgPack](http://msgpack.org)'
- en: '[Protocol Buffers](https://code.google.com/p/protobuf)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Protocol Buffers](https://code.google.com/p/protobuf)'
- en: '[Avro](http://avro.apache.org/docs/current)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Avro](http://avro.apache.org/docs/current)'
- en: '[Thrift](http://thrift.apache.org)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Thrift](http://thrift.apache.org)'
- en: '[Lima](https://lima.readthedocs.io)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Lima](https://lima.readthedocs.io)'
- en: '[`Serialize`](https://pypi.org/project/Serialize) is a Python frontend to other
    formats, including JSON, YAML, pickle, and MsgPack.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Serialize`](https://pypi.org/project/Serialize) 是一个 Python 前端，支持 JSON、YAML、pickle
    和 MsgPack 等其他格式。'
- en: A [benchmark](https://oreil.ly/S3ESH) of various Python serialization packages.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[各种 Python 序列化包的基准](https://oreil.ly/S3ESH)。'
- en: Because they are binary, none can be easily edited by a human with a text editor.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们是二进制的，所以无法通过文本编辑器轻松编辑。
- en: 'Some third-party packages interconvert objects and basic Python data types
    (allowing further conversion to/from formats like JSON), and provide *validation*
    of the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一些第三方包可以互相转换对象和基本的 Python 数据类型（允许进一步转换为/从 JSON 等格式），并提供以下的 *验证*：
- en: Data types
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: Value ranges
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值范围
- en: Required versus optional data
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必需与可选数据
- en: 'These include:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包括：
- en: '[Marshmallow](https://marshmallow.readthedocs.io/en/3.0)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Marshmallow](https://marshmallow.readthedocs.io/en/3.0)'
- en: '[Pydantic](https://pydantic-docs.helpmanual.io)—uses type hints, so requires
    at least Python 3.6'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Pydantic](https://pydantic-docs.helpmanual.io)——使用类型提示，因此至少需要 Python 3.6。'
- en: '[TypeSystem](https://www.encode.io/typesystem)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TypeSystem](https://www.encode.io/typesystem)'
- en: These are often used with web servers to ensure that the bytes that came over
    the wire via HTTP end up in the right data structures for further processing.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通常与 Web 服务器一起使用，以确保通过 HTTP 传输的字节最终进入正确的数据结构以供进一步处理。
- en: Remote Procedure Calls
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程过程调用
- en: 'Remote Procedure Calls (RPCs) look like normal functions but execute on remote
    machines across a network. Instead of calling a RESTful API with arguments encoded
    in the URL or request body, you call an RPC function on your own machine. Your
    local machine:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 远程过程调用（RPC）看起来像是普通的函数，但是在网络上的远程机器上执行。与在URL或请求体中编码参数并调用RESTful API不同，您在自己的机器上调用RPC函数。你的本地机器：
- en: Serializes your function arguments into bytes.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的函数参数序列化为字节。
- en: Sends the encoded bytes to the remote machine.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将编码的字节发送到远程机器。
- en: 'The remote machine:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 远程机器：
- en: Receives the encoded request bytes.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收编码的请求字节。
- en: Deserializes the bytes back to data structures.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字节反序列化回数据结构。
- en: Finds and calls the service function with the decoded data.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到并调用具有解码数据的服务函数。
- en: Encodes the function results.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对函数结果进行编码。
- en: Sends the encoded bytes back to the caller.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将编码的字节发送回调用者。
- en: 'And finally, the local machine that started it all:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，启动一切的本地机器：
- en: Decodes the bytes to return values.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码字节以返回值。
- en: RPC is a popular technique, and people have implemented it in many ways. On
    the server side, you start a server program, connect it with some byte transport
    and encoding/decoding method, define some service functions, and light up your
    *RPC is open for business* sign. The client connects to the server and calls one
    of its functions via RPC.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: RPC是一种流行的技术，人们已经用许多方式实现了它。在服务器端，您启动一个服务器程序，将其连接到某些字节传输和编码/解码方法，定义一些服务函数，然后点亮您的*RPC已开放营业*标志。客户端连接到服务器并通过RPC调用其中一个函数。
- en: XML RPC
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML RPC
- en: 'The standard library includes one RPC implementation that uses XML as the exchange
    format: `xmlrpc`. You define and register functions on the server, and the client
    calls them as though they were imported. First, let’s explore the file *xmlrpc_server.py*,
    as shown in [Example 17-11](#xmlrpc_server).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库包括一个使用XML作为交换格式的RPC实现：`xmlrpc`。您在服务器上定义和注册函数，客户端调用它们就像它们被导入一样。首先，让我们探索文件*xmlrpc_server.py*，如[示例17-11](#xmlrpc_server)所示。
- en: Example 17-11\. xmlrpc_server.py
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-11\. xmlrpc_server.py
- en: '[PRE37]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The function we’re providing on the server is called `double()`. It expects
    a number as an argument and returns the value of that number times two. The server
    starts up on an address and port. We need to *register* the function to make it
    available to clients via RPC. Finally, start serving and carry on.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在服务器上提供的函数称为`double()`。它期望一个数字作为参数，并返回该数字乘以2的值。服务器在地址和端口上启动。我们需要*注册*函数以使其通过RPC对客户端可用。最后，开始服务并继续。
- en: Now—you guessed it—*xmlrpc_client.py*, proudly presented in [Example 17-12](#xmlrpc_client).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在——你猜对了——*xmlrpc_client.py*，自豪地呈现在[示例17-12](#xmlrpc_client)中。
- en: Example 17-12\. xmlrpc_client.py
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-12\. xmlrpc_client.py
- en: '[PRE38]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The client connects to the server by using `ServerProxy()`. Then, it calls the
    function `proxy.double()`. Where did that come from? It was created dynamically
    by the server. The RPC machinery magically hooks this function name into a call
    to the remote server.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过使用`ServerProxy()`连接到服务器。然后，它调用函数`proxy.double()`。这是从哪里来的？它是由服务器动态创建的。RPC机制神奇地将此函数名连接到对远程服务器的调用中。
- en: 'Give it a try—start the server and then run the client:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 试一试——启动服务器，然后运行客户端：
- en: '[PRE39]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the client again:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行客户端：
- en: '[PRE40]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The server then prints the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后服务器打印如下内容：
- en: '[PRE41]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Popular transport methods are HTTP and ZeroMQ.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的传输方法包括HTTP和ZeroMQ。
- en: JSON RPC
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON RPC
- en: 'JSON-RPC (versions [1.0](https://oreil.ly/OklKa) and [2.0](https://oreil.ly/4CS0r))
    is similar to XML-RPC, but with JSON. There are many Python JSON-RPC libraries,
    but the simplest one I’ve found comes in two parts: [client](https://oreil.ly/8npxf)
    and [server](https://oreil.ly/P_uDr).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-RPC（版本[1.0](https://oreil.ly/OklKa)和[2.0](https://oreil.ly/4CS0r)）类似于XML-RPC，但使用JSON。有许多Python
    JSON-RPC库，但我找到的最简单的一个分为两部分：[客户端](https://oreil.ly/8npxf)和[服务器端](https://oreil.ly/P_uDr)。
- en: 'Installation of both is familiar: `pip install jsonrpcserver` and `pip install
    jsonrpclient`.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这两者都很熟悉：`pip install jsonrpcserver`和`pip install jsonrpclient`。
- en: These libraries provide many alternative ways to write a [client](https://oreil.ly/fd412)
    and [server](https://oreil.ly/SINeg). In [Example 17-13](#jsonrpc_server) and
    [Example 17-14](#jsonrpc_client), I use this library’s built-in server, which
    uses port 5000 and is the simplest.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库提供了许多写[客户端](https://oreil.ly/fd412)和[服务器](https://oreil.ly/SINeg)的替代方法。在[示例17-13](#jsonrpc_server)和[示例17-14](#jsonrpc_client)中，我使用了这个库的内置服务器，它使用端口5000，是最简单的。
- en: First, the server.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，服务器端。
- en: Example 17-13\. jsonrpc_server.py
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-13\. jsonrpc_server.py
- en: '[PRE42]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Second, the client.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，客户端。
- en: Example 17-14\. jsonrpc_client.py
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-14\. jsonrpc_client.py
- en: '[PRE43]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As with most of the client-server examples in this chapter, start the server
    first (in its own terminal window, or with a following `&` to put it in the background)
    and then run the client:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的大多数客户端-服务器示例一样，首先启动服务器（在其自己的终端窗口中，或者使用后面的`&`将其放入后台），然后运行客户端：
- en: '[PRE44]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you put the server in the background, kill it when you’re done.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将服务器放入后台，请在完成后将其关闭。
- en: MessagePack RPC
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MessagePack RPC
- en: 'The encoding library MessagePack has its own [Python RPC implementation](http://bit.ly/msgpack-rpc).
    Here’s how to install it:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 编码库 MessagePack 有自己的[Python RPC 实现](http://bit.ly/msgpack-rpc)。以下是如何安装它：
- en: '[PRE45]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will also install `tornado`, a Python event-based web server that this
    library uses as a transport. As usual, the server (*msgpack_server.py*) comes
    first ([Example 17-15](#msgpack_server)).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会安装`tornado`，这是一个Python基于事件的 Web 服务器，该库将其用作传输。和往常一样，首先启动服务器（*msgpack_server.py*）（[示例
    17-15](#msgpack_server)）。
- en: Example 17-15\. msgpack_server.py
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-15\. msgpack_server.py
- en: '[PRE46]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `Services` class exposes its methods as RPC services. Go ahead and start
    the client, *msgpack_client.py* ([Example 17-16](#msgpack_client)).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`Services`类将其方法公开为RPC服务。继续启动客户端，*msgpack_client.py*（[示例 17-16](#msgpack_client)）。'
- en: Example 17-16\. msgpack_client.py
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-16\. msgpack_client.py
- en: '[PRE47]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To run these, follow the usual drill—start the server and client in separate
    terminal windows,^([1](ch17.html#idm45794970661368)) and observe the results:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些，请按照通常的步骤-在单独的终端窗口中启动服务器和客户端^([1](ch17.html#idm45794970661368))，并观察结果：
- en: '[PRE48]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Zerorpc
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Zerorpc
- en: Written by the developers of Docker (when they were called dotCloud), [zerorpc](http://www.zerorpc.io)
    uses ZeroMQ and MsgPack to connect clients and servers. It magically exposes functions
    as RPC endpoints.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Docker 的开发人员（当时被称为 dotCloud）编写，[zerorpc](http://www.zerorpc.io)使用 ZeroMQ 和
    MsgPack 连接客户端和服务器。它会将函数神奇地公开为 RPC 端点。
- en: Type `pip install zerorpc` to install it. The sample code in [Example 17-17](#zerorpc_server)
    and [Example 17-18](#zerorpc_client) shows a request-reply client and server.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`pip install zerorpc`来安装它。[示例 17-17](#zerorpc_server)和[示例 17-18](#zerorpc_client)中的示例代码显示了一个请求-回复客户端和服务器。
- en: Example 17-17\. zerorpc_server.py
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-17\. zerorpc_server.py
- en: '[PRE50]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Example 17-18\. zerorpc_client.py
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-18\. zerorpc_client.py
- en: '[PRE51]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Notice that the client calls `client.double()`, even though there’s no definition
    of it in there:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端调用`client.double()`，即使在其中没有定义：
- en: '[PRE52]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The site has many more [examples](https://github.com/0rpc/zerorpc-python).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 该网站有许多其他[示例](https://github.com/0rpc/zerorpc-python)。
- en: gRPC
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC
- en: Google created [gRPC](https://grpc.io) as a portable and fast way to define
    and connect services. It encodes data as [protocol buffers](https://oreil.ly/UINlc).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌创建了[gRPC](https://grpc.io)，作为一种便捷快速定义和连接服务的方式。它将数据编码为[协议缓冲区](https://oreil.ly/UINlc)。
- en: 'Install the Python parts:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Python 部分：
- en: '[PRE53]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The Python client [docs](https://grpc.io/docs/quickstart/python) are very detailed,
    so I’m giving only a brief overview here. You may also like this separate [tutorial](https://oreil.ly/awnxO).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Python 客户端[文档](https://grpc.io/docs/quickstart/python)非常详细，所以这里我只是简要概述。你可能也喜欢这个单独的[教程](https://oreil.ly/awnxO)。
- en: To use gRPC, you write a *.proto* file to define a `service` and its `rpc` methods.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 gRPC，你需要编写一个 *.proto* 文件来定义一个`service`及其`rpc`方法。
- en: 'An `rpc` method is like a function definition (describing its arguments and
    return types) and may specify one of these networking patterns:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`rpc`方法类似于一个函数定义（描述其参数和返回类型），并且可以指定以下其中一种网络模式：
- en: Request-response (sync or async)
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求-响应（同步或异步）
- en: Request-streaming response
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求-流式响应
- en: Streaming request-response (sync or async)
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式请求-响应（同步或异步）
- en: Streaming request-streaming response
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式请求-流式响应
- en: Single responses can be blocking or asynchronous. Streaming responses are iterated.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 单个响应可以是阻塞或异步的。流式响应会被迭代。
- en: Next, you would run the `grpc_tools.protoc` program to create Python code for
    the client and server. gRPC handles the serialization and network communication;
    you add your application-specific code to the client and server stubs.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将运行`grpc_tools.protoc`程序为客户端和服务器创建Python代码。gRPC 处理序列化和网络通信；你将应用特定的代码添加到客户端和服务器存根中。
- en: gRPC is a top-level alternative to web REST APIs. It seems to be a better fit
    than REST for inter-service communication, and REST may be preferred for public
    APIs.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 是 Web REST API 的顶级替代方案。它似乎比 REST 更适合服务间通信，而 REST 可能更适合公共 API。
- en: Twirp
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Twirp
- en: '[Twirp](https://oreil.ly/buf4x) is similar to gRPC, but claims to be simpler.
    You define a `.proto` file as you would with gRPC, and twirp can generate Python
    code to handle the client and server ends.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[Twirp](https://oreil.ly/buf4x) 类似于gRPC，但声称更简单。你可以像使用gRPC一样定义一个`.proto`文件，twirp可以生成处理客户端和服务器端的Python代码。'
- en: Remote Management Tools
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程管理工具
- en: '[`Salt`](http://www.saltstack.com) is written in Python. It started as a way
    to implement remote execution, but grew to a full-fledged systems management platform.
    Based on ZeroMQ rather than SSH, it can scale to thousands of servers.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Salt`](http://www.saltstack.com) 是用Python编写的。它起初是一种实现远程执行的方法，但发展成为一个完整的系统管理平台。基于ZeroMQ而不是SSH，它可以扩展到数千台服务器。'
- en: '[`Puppet`](http://puppetlabs.com) and [`Chef`](http://www.getchef.com/chef)
    are popular and closely tied to Ruby.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Puppet`](http://puppetlabs.com) 和 [`Chef`](http://www.getchef.com/chef) 非常流行，并与Ruby密切相关。'
- en: The [`Ansible`](http://www.ansible.com/home) package, which like Salt is written
    in Python, is also comparable. It’s free to download and use, but support and
    some add-on packages require a commercial license. It uses SSH by default and
    does not require any special software to be installed on the machines that it
    will manage.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Ansible`](http://www.ansible.com/home) 软件包，像Salt一样是用Python编写的，也是类似的。它可以免费下载和使用，但支持和一些附加软件包需要商业许可证。它默认使用SSH，不需要在要管理的机器上安装任何特殊软件。'
- en: '`Salt` and `Ansible` are both functional supersets of `Fabric`, handling initial
    configuration, deployment, and remote execution.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`Salt` 和 `Ansible` 都是 `Fabric` 的功能超集，处理初始配置、部署和远程执行。'
- en: Big Fat Data
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大数据
- en: As Google and other internet companies grew, they found that traditional computing
    solutions didn’t scale. Software that worked for single machines, or even a few
    dozen, could not keep up with thousands.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 随着谷歌和其他互联网公司的发展，他们发现传统的计算解决方案无法满足需求。对单台机器有效的软件，甚至只是几十台机器，无法跟上数千台机器。
- en: Disk storage for databases and files involved too much *seeking*, which requires
    mechanical movement of disk heads. (Think of a vinyl record, and the time it takes
    to move the needle from one track to another manually. And think of the screeching
    sound it makes when you drop it too hard, not to mention the sounds made by the
    record’s owner.) But you could *stream* consecutive segments of the disk more
    quickly.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库和文件的磁盘存储涉及太多*寻址*，这需要磁盘头的机械移动。（想象一下黑胶唱片，以及将唱针手动从一条曲目移动到另一条曲目所需的时间。再想想当你把它掉得太重时发出的尖叫声，更不用说唱片所有者发出的声音了。）但你可以更快地*流*传统磁盘的连续片段。
- en: Developers found that it was faster to distribute and analyze data on many networked
    machines than on individual ones. They could use algorithms that sounded simplistic
    but actually worked better overall with massively distributed data. One of these
    is MapReduce, which spreads a calculation across many machines and then gathers
    the results. It’s similar to working with queues.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员发现，将数据分布式地分析在许多网络化的机器上比在单个机器上更快。他们可以使用听起来简单但实际上在处理海量分布式数据时效果更好的算法。其中之一是MapReduce，它将计算分布在许多机器上，然后收集结果。这类似于使用队列。
- en: Hadoop
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hadoop
- en: After Google published its MapReduce results in a [paper](https://oreil.ly/cla0d),
    Yahoo followed with an open source Java-based package named *Hadoop* (named after
    the toy stuffed elephant of the lead programmer’s son).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌在一篇[论文](https://oreil.ly/cla0d)中公布了其MapReduce的结果后，雅虎推出了一个名为*Hadoop*的开源基于Java的软件包（以主要程序员儿子的毛绒大象玩具命名）。
- en: 'The phrase *big data* applies here. Often it just means “data too big to fit
    on my machine”: data that exceeds the disk, memory, CPU time, or all of the above.
    To some organizations, if *big data* is mentioned somewhere in a question, the
    answer is always Hadoop. Hadoop copies data among machines, running them through
    *map* (scatter) and *reduce* (gather) programs, and saving the results on disk
    at each step.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 短语*大数据*适用于这里。通常它只是指“数据太大，无法放在我的机器上”：超过磁盘、内存、CPU时间或以上所有的数据。对一些组织来说，如果问题中提到了*大数据*，答案总是Hadoop。Hadoop在机器之间复制数据，通过*map*（分散）和*reduce*（聚集）程序运行数据，并在每一步将结果保存在磁盘上。
- en: This batch process can be slow. A quicker method called *Hadoop streaming* works
    like Unix pipes, streaming the data through programs without requiring disk writes
    at each step. You can write Hadoop streaming programs in any language, including
    Python.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这个批处理过程可能很慢。一个更快的方法叫做*Hadoop streaming*，类似于Unix管道，通过程序流式传输数据，而不需要在每一步都写入磁盘。你可以用任何语言编写Hadoop流式处理程序，包括Python。
- en: Many Python modules have been written for Hadoop, and some are discussed in
    the blog post [“A Guide to Python Frameworks for Hadoop”](http://bit.ly/py-hadoop).
    Spotify, known for streaming music, open sourced its Python component for Hadoop
    streaming, [Luigi](https://github.com/spotify/luigi).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Python模块已经为Hadoop编写，并且一些在博文[“Python框架指南”](http://bit.ly/py-hadoop)中有所讨论。以流媒体音乐而闻名的Spotify，开源了其Hadoop流处理的Python组件[Luigi](https://github.com/spotify/luigi)。
- en: Spark
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spark
- en: A rival named [Spark](http://bit.ly/about-spark) was designed to run 10 to 100
    times faster than Hadoop. It can read and process any Hadoop data source and format.
    Spark includes APIs for Python and other languages. You can find the [installation](http://bit.ly/dl-spark)
    documents online.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 一位名为[Spark](http://bit.ly/about-spark)的竞争对手被设计成比Hadoop快10到100倍。它可以读取和处理任何Hadoop数据源和格式。Spark包括Python等语言的API。你可以在网上找到[安装](http://bit.ly/dl-spark)文档。
- en: Disco
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Disco
- en: Another alternative to Hadoop is [Disco](http://discoproject.org), which uses
    Python for MapReduce processing and Erlang for communication. Alas, you can’t
    install it with `pip`; see the [documentation](http://bit.ly/get-disco).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个替代Hadoop的选择是[Disco](http://discoproject.org)，它使用Python进行MapReduce处理，并使用Erlang进行通信。不幸的是，你不能用`pip`安装它；请参阅[文档](http://bit.ly/get-disco)。
- en: Dask
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dask
- en: '[Dask](https://dask.org) is similar to Spark, although it’s written in Python
    and is largely used with scientific Python packages like NumPy, Pandas, and scikit-learn.
    It can spread tasks across thousand-machine clusters.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[Dask](https://dask.org)类似于Spark，尽管它是用Python编写的，并且主要与NumPy、Pandas和scikit-learn等科学Python包一起使用。它可以将任务分散到千台机器的集群中。'
- en: 'To get Dask and all of its extra helpers:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Dask及其所有额外的帮助程序：
- en: '[PRE54]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: See [Chapter 22](ch22.html#ch_science) for related examples of *parallel programming*,
    in which a large structured calculation is distributed among many machines.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[第22章](ch22.html#ch_science)，了解*并行编程*的相关示例，其中大型结构化计算分布在许多机器之间。
- en: Clouds
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clouds
- en: I really don’t know clouds at all.
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我真的不了解云。
- en: ''
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Joni Mitchell
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Joni Mitchell
- en: 'Not so long ago, you would buy your own servers, bolt them into racks in data
    centers, and install layers of software on them: operating systems, device drivers,
    filesystems, databases, web servers, email servers, name servers, load balancers,
    monitors, and more. Any initial novelty wore off as you tried to keep multiple
    systems alive and responsive. And you worried constantly about security.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 不久以前，你会购买自己的服务器，将它们安装在数据中心的机架上，并在其上安装各种软件层：操作系统、设备驱动程序、文件系统、数据库、Web服务器、电子邮件服务器、名称服务器、负载均衡器、监视器等等。任何最初的新奇感都会随着你试图保持多个系统的运行和响应而消失。而且你会持续担心安全问题。
- en: Many hosting services offered to take care of your servers for a fee, but you
    still leased the physical devices and had to pay for your peak load configuration
    at all times.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 许多托管服务提供了为你管理服务器的服务，但你仍然租用物理设备，并且必须始终支付峰值负载配置的费用。
- en: 'With more individual machines, failures are no longer infrequent: they’re very
    common. You need to scale services horizontally and store data redundantly. You
    can’t assume that the network operates like a single machine. The eight fallacies
    of distributed computing, according to Peter Deutsch, are as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 随着个体机器的增多，故障不再是偶发的：它们非常普遍。你需要横向扩展服务并冗余存储数据。不能假设网络像单一机器一样运行。根据Peter Deutsch，分布式计算的八个谬误如下：
- en: The network is reliable.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络是可靠的。
- en: Latency is zero.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟是零。
- en: Bandwidth is infinite.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带宽是无限的。
- en: The network is secure.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络是安全的。
- en: Topology doesn’t change.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拓扑结构不会改变。
- en: There is one administrator.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个管理员。
- en: Transport cost is zero.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运输成本为零。
- en: The network is homogeneous.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络是同质的。
- en: 'You can try to build these complex distributed systems, but it’s a lot of work,
    and a different toolset is needed. To borrow an analogy, when you have a handful
    of servers, you treat them like pets—you give them names, know their personalities,
    and nurse them back to health when needed. But at scale, you treat servers more
    like livestock: they look alike, have numbers, and are just replaced if they have
    any problems.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试构建这些复杂的分布式系统，但这是一项艰巨的工作，需要不同的工具集。借用一个类比，当你有一小群服务器时，你对待它们像宠物一样——给它们起名字，了解它们的个性，并在需要时照顾它们。但在规模化时，你更像对待牲畜一样对待服务器：它们看起来一样，有编号，有问题就直接更换。
- en: Instead of building, you can rent servers in the *cloud*. By adopting this model,
    maintenance is someone else’s problem, and you can concentrate on your service,
    or blog, or whatever you want to show the world. Using web dashboards and APIs,
    you can spin up servers with whatever configuration you need, quickly and easily—they’re
    *elastic*. You can monitor their status, and be alerted if some metric exceeds
    a given threshold. Clouds are currently a pretty hot topic, and corporate spending
    on cloud components has spiked.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是自己搭建，您可以在*云*中租用服务器。通过采用这种模式，维护工作成为了别人的问题，您可以专注于您的服务、博客或者任何您想向世界展示的内容。使用 Web
    仪表板和 API，您可以快速轻松地启动具有所需配置的服务器——它们*弹性*。您可以监视它们的状态，并在某些指标超过给定阈值时收到警报。云目前是一个非常热门的话题，企业在云组件上的支出激增。
- en: 'The big cloud vendors are:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 大型云供应商包括：
- en: Amazon (AWS)
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊 (AWS)
- en: Google
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌
- en: Microsoft Azure
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Azure
- en: Amazon Web Services
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 亚马逊网络服务
- en: 'As Amazon was growing from hundreds to thousands to millions of servers, developers
    ran into all the nasty problems of distributed systems. One day in 2002 or thereabouts,
    CEO Jeff Bezos declared to Amazon employees that, henceforth, all data and functionality
    needed to be exposed only via network service interfaces—not files, or databases,
    or local function calls. They had to design these interfaces as though they were
    being offered to the public. The memo ended with a motivational nugget: *“Anyone
    who doesn’t do this will be fired.”*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当亚马逊从数百台服务器增长到数千台、数百万台时，开发人员遇到了所有分布式系统的可怕问题。大约在2002年某一天，CEO 杰夫·贝佐斯向亚马逊员工宣布，今后所有数据和功能都必须仅通过网络服务接口公开——而不是文件、数据库或本地函数调用。他们必须设计这些接口，就像它们是向公众提供的一样。备忘录以一句激励人心的话结束：“任何不这样做的人都会被解雇。”
- en: 'Not surprisingly, developers got to work, and over time built a huge service-oriented
    architecture. They borrowed or innovated many solutions, evolving into [Amazon
    Web Services (AWS)](http://aws.amazon.com), which now dominates the market. The
    official Python AWS library is `boto3`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么奇怪的，开发人员开始行动，并随着时间的推移构建了一个庞大的面向服务的架构。他们借鉴或创新了许多解决方案，发展成为[亚马逊网络服务 (AWS)](http://aws.amazon.com)，目前主导市场。官方的
    Python AWS 库是 `boto3`：
- en: '[documentation](https://oreil.ly/y2Baz)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[文档](https://oreil.ly/y2Baz)'
- en: '[SDK](https://aws.amazon.com/sdk-for-python) pages'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SDK](https://aws.amazon.com/sdk-for-python) 页面'
- en: 'Install it with:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装：
- en: '[PRE55]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can use `boto3` as an alternative to AWS’s web-based management pages.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `boto3` 作为 AWS 的基于 Web 的管理页面的替代品。
- en: Google Cloud
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谷歌云
- en: Google uses Python a lot internally, and it employs some prominent Python developers
    (even Guido van Rossum himself, for some time). From its [main](https://cloud.google.com)
    and [Python](https://cloud.google.com/python) pages, you can find details on its
    many services.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌在内部大量使用 Python，并雇佣了一些著名的 Python 开发者（甚至包括 Guido van Rossum 自己）。从其[主页](https://cloud.google.com)和[Python](https://cloud.google.com/python)页面，您可以找到其许多服务的详细信息。
- en: Microsoft Azure
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Microsoft Azure
- en: Microsoft caught up with Amazon and Google with its cloud offering, [Azure](https://azure.microsoft.com).
    See [Python on Azure](https://oreil.ly/Yo6Nz) to learn how to develop and deploy
    Python applications.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 在其云服务提供中赶上了亚马逊和谷歌，[Azure](https://azure.microsoft.com)。查看[Python on
    Azure](https://oreil.ly/Yo6Nz)以了解如何开发和部署 Python 应用程序。
- en: OpenStack
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenStack
- en: '[OpenStack](https://www.openstack.org) is an open source framework of Python
    services and REST APIs. Many of the services are similar to those in the commercial
    clouds.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '[OpenStack](https://www.openstack.org) 是一个 Python 服务和 REST API 的开源框架。许多服务类似于商业云中的服务。'
- en: Docker
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: The humble standardized shipping container revolutionized international trade.
    Only a few years ago, Docker applied the *container* name and analogy to a *virtualization*
    method using some little-known Linux features. Containers are much lighter than
    virtual machines, and a bit heavier than Python virtualenvs. They allow you to
    package an application separately from other applications on the same machine,
    sharing only the operating system kernel.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 随着一个简单的标准化集装箱彻底改变了国际贸易。仅仅几年前，Docker 将*容器*这个名字和类比应用于使用一些鲜为人知的 Linux 特性的*虚拟化*方法。容器比虚拟机轻得多，比
    Python 的虚拟环境重一点。它们允许您将应用程序与同一台机器上的其他应用程序分开打包，只共享操作系统内核。
- en: 'To install Docker’s Python client [library](https://pypi.org/project/docker):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 若要安装 Docker 的 Python 客户端[库](https://pypi.org/project/docker)：
- en: '[PRE56]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Kubernetes
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes
- en: 'Containers caught on and spread through the computing world. Eventually, people
    needed ways to manage multiple containers and wanted to automate some of the manual
    steps that have been usually required in large distributed systems:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在计算领域迅速流行开来。最终，人们需要管理多个容器的方法，并希望自动化一些在大型分布式系统中通常需要的手动步骤：
- en: Failover
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障转移
- en: Load balancing
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Scaling up and down
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展和收缩
- en: It looks like [Kubernetes](https://kubernetes.io) is leading the pack in this
    new area of *container orchestration*.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 [Kubernetes](https://kubernetes.io) 在这个新领域的*容器编排*中处于领先地位。
- en: 'To install the Python client [library](https://github.com/kubernetes-client/python):'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Python 客户端 [库](https://github.com/kubernetes-client/python)：
- en: '[PRE57]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Coming Up
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将到来
- en: As they say on television, our next guest needs no introduction. Learn why Python
    is one of the best languages to tame the web.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 正如电视上所说，我们的下一个嘉宾无需介绍。了解为什么 Python 是驯服网络的最佳语言之一。
- en: Things to Do
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要做的事情
- en: 17.1 Use a plain `socket` to implement a current-time-service. When a client
    sends the string *time* to the server, return the current date and time as an
    ISO string.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 17.1 使用一个普通的 `socket` 来实现一个当前时间服务。当客户端向服务器发送字符串 *time* 时，返回当前日期和时间作为 ISO 字符串。
- en: 17.2 Use ZeroMQ REQ and REP sockets to do the same thing.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 17.2 使用 ZeroMQ 的 REQ 和 REP sockets 来做同样的事情。
- en: 17.3 Try the same with XMLRPC.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 17.3 尝试使用 XMLRPC 来做同样的事情。
- en: 17.4 You may have seen the classic *I Love Lucy* television episode in which
    Lucy and Ethel worked in a chocolate factory. The duo fell behind as the conveyor
    belt that supplied the confections for them to process began operating at an ever-faster
    rate. Write a simulation that pushes different types of chocolates to a Redis
    list, and Lucy is a client doing blocking pops of this list. She needs 0.5 seconds
    to handle a piece of chocolate. Print the time and type of each chocolate as Lucy
    gets it, and how many remain to be handled.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 17.4 你可能看过经典的《我爱 Lucy》电视剧集，讲述了 Lucy 和 Ethel 在巧克力工厂工作的故事。由于给她们加工的传送带开始以越来越快的速度运转，二人落后了。编写一个模拟，将不同类型的巧克力推送到一个
    Redis 列表中，Lucy 是一个执行阻塞弹出此列表的客户端。她需要 0.5 秒来处理一块巧克力。打印 Lucy 收到的每块巧克力的时间和类型，以及剩下需要处理的数量。
- en: 17.5 Use ZeroMQ to publish the poem from exercise 12.4 (from [Example 12-1](ch12.html#mammoth)),
    one word at a time. Write a ZeroMQ consumer that prints every word that starts
    with a vowel, and another that prints every word that contains five letters. Ignore
    punctuation characters.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 17.5 使用 ZeroMQ 逐字发布来自练习 12.4 的诗歌（来自 [示例 12-1](ch12.html#mammoth)），一次一个字。编写一个
    ZeroMQ 消费者，打印每个以元音开头的单词，以及打印每个包含五个字母的单词。忽略标点符号字符。
- en: ^([1](ch17.html#idm45794970661368-marker)) Or put the server in the background
    with a final `&`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch17.html#idm45794970661368-marker)) 或使用最后的 `&` 将服务器放在后台。
