- en: 3 Designing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions in Python and their role in designing software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard workflow when interacting with Copilot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of writing good functions using Copilot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reasonable tasks for Copilot to solve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the hardest challenges for programming novices is to know what a reasonable
    task is to give to Copilot so that it finds a good solution. If you give Copilot
    too big of a task, it will often fail in spectacular ways that can be extremely
    difficult to fix. What, then, is a reasonable task?
  prefs: []
  type: TYPE_NORMAL
- en: This question is important for our use of Copilot but goes far beyond it. Human
    programmers struggle with complexity too. If experienced software engineers try
    to write code to solve a problem that’s too complex without breaking it down into
    smaller, more solvable subparts, they often have trouble as well. The solution
    for humans has been to use something called a *function,* whose job is to perform
    one task. Functions help us organize our code and make it easier to think about
    and fix any bugs. There are various rules of thumb for how to write a reasonable
    function in terms of number of lines of code, but, fundamentally, these rules
    try to capture writing something that (1) performs a single task and (2) isn’t
    so complex that it’s hard to get right.
  prefs: []
  type: TYPE_NORMAL
- en: For people who learned to program the old-fashioned way, without Copilot, they
    may have struggled with syntax in code that’s 5–10 lines long before being introduced
    to functions. At that point, it’s natural for them to understand through experience
    that they shouldn’t write more code in a single function than they can handle
    testing and debugging. Because you’re learning to work with Copilot rather than
    syntax directly, our job in this chapter is to teach you about functions and what
    are considered reasonable and unreasonable tasks to ask Copilot to solve in a
    single function.
  prefs: []
  type: TYPE_NORMAL
- en: To help you gain perspective on functions, we’ll provide you with a number of
    examples in this chapter. Those examples employ the central workflow of interacting
    with Copilot—specifically, the cycle of writing prompts, receiving code from Copilot,
    and testing to see whether that code is correct. In the functions produced by
    Copilot, you’ll begin to see the core programming tools, such as loops, conditionals,
    and lists, which we’ll expand on in the next two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can learn about the details of writing a function, we need some insight
    into their purpose in software. Functions are small tasks that help accomplish
    larger tasks, which, in turn, help solve larger tasks, and so forth. You probably
    already have a lot of intuition about breaking apart large tasks into smaller
    tasks. Let’s make that intuition concrete with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you’ve found a word search puzzle in the newspaper that you’d like to
    solve (see figure 3.1 for an example puzzle). In these kinds of puzzles, you’re
    looking for each word in the word list. The words can be found going from left
    to right, right to left, top to bottom, or bottom to top.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 Example word search puzzle
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At a high level, your task is “find all the words in the word search.” Unfortunately,
    that description of the task isn’t helpful on its own. It doesn’t tell us what
    steps we need to take to solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Try working on the problem right now for a couple minutes. How did you start?
    How did you break down the overall task to make it more achievable?
  prefs: []
  type: TYPE_NORMAL
- en: One thing you might do is say, “OK, finding every word is a big task, but a
    smaller task is just finding the first word (CAT). Let me work on that first!”
    This is an example of taking a large task and breaking it into smaller tasks.
    To solve the entire puzzle, then, you could repeat that smaller task for each
    word that you need to find.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how would we find an individual word, such as CAT? Even this task can
    be broken down further to make it easier to accomplish. For example, we could
    break it into four tasks: search for CAT from left to right, search for CAT from
    right to left, search for CAT from top to bottom, and search for CAT from bottom
    to top. Not only are we making simpler and simpler tasks, but we’re also organizing
    our work into logical pieces. Most importantly, as we’ll see throughout the chapter,
    it’s these simpler tasks whose code we’re going to ask Copilot to write and ultimately
    assemble into our complete programs.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking a large problem and dividing it into smaller tasks is called *problem
    decomposition,* which is such an important skill in software design that we’ve
    dedicated all of chapter 7 to it. For now, it’s essential to know when a task
    is too big to ask Copilot to complete it. Asking Copilot to make a new video game
    that’s a combination of Wordscapes meets Wordle isn’t going to work at all. However,
    you can get Copilot to write a function that’s important to solve a larger problem;
    for example, you might have a function that checks whether the word provided by
    the player is present in a list of valid words. Copilot can solve that problem
    well, and that function would help Copilot get closer to solving the larger problem.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.1 The components of a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The origin of the name *function* goes back to math where functions define
    the output of something based on an input. For example, in high school math, you
    probably learned to recognize the common way to write a function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: f(*x*) = *x*²
  prefs: []
  type: TYPE_NORMAL
- en: This is a function that is given a value for the variable *x* and computes the
    square of that value. So, we can say that when *x* is 6, f(*x*) is 36\. As programming
    functions also have expected output for a particular input, the name is apt for
    programming as well.
  prefs: []
  type: TYPE_NORMAL
- en: As programmers, we also like to think of functions as promises or contracts.
    If there is a function called `larger`, and we’re told that it takes two numbers
    and gives us the larger of the two, we have faith that when we give the function
    the numbers 2 and 5, it will return the answer of 5\. We don’t need to see how
    that function works to use it, any more than we need to know how the mechanics
    of a car works to use the brake pedal. Press the brake pedal, and the car slows
    down. Give the `larger` function two numbers, and it gives us back the larger
    of the two.
  prefs: []
  type: TYPE_NORMAL
- en: Every function in Python has a *function header* (also called a *function signature*),
    which is the first line of code of the function. Given their ubiquitous nature,
    we’ll want to read and write function headers. The function header describes the
    name of the function and its inputs. In some other languages, the function header
    sometimes includes information about what the output looks like, but in Python,
    you have to find that elsewhere in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In chapter 2, we wrote # comments to tell Copilot what to do. We can continue
    to use that approach if we want Copilot to generate a function. For example, we
    can use comments to ask Copilot to write a function that tells us which of two
    numbers is larger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '#1 This function header defines a function called “larger” that accepts two
    inputs called num1 and num2.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Function body'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the code in the previous chapter, we just wrote the comments to prompt
    Copilot to give us the code. The function header has three main components: the
    `def` keyword, which tells Python that this is a function; the name of the function;
    and the inputs to the function. There’s also a colon at the end of the line—be
    sure to include that or the code won’t be valid Python code. The word `def` denotes
    that it’s creating (defining) a function. After `def` is the name of the function;
    that name should describe the behavior of the function as well as possible. The
    name of this function is `larger`. If it’s hard to name a function because it
    does a bunch of different things, that’s usually a clue that it’s too big of a
    task for a single function (more on that later).'
  prefs: []
  type: TYPE_NORMAL
- en: In the parentheses of the function declaration, you’ll find the parameters.
    *Parameters* are how you provide information to a function that it needs to run.
    A function can have any number of parameters, and some functions have no parameters.
    This function has two parameters named `num1` and `num2`; there are two parameters
    because it needs to know the two numbers it’s comparing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There can be only one output of a function; the keyword to look for when determining
    what the function is outputting is *return*. Whatever follows `return` is the
    output of the function. In this code, either `num1` or `num2` will be returned.
    Functions aren’t required to return anything (e.g., a function that prints a list
    to the screen has no reason to return anything), so if you don’t see a return
    statement, it isn’t necessarily a problem because the function may be doing something
    else (interacting with the user, for example) rather than returning something.
    Functions must also either return something or not return something: they can’t
    return something in some cases and nothing in other cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we had Copilot generate this function using # comments, this approach
    is actually a lot of work for Copilot. It first must get the header right, including
    figuring out how many parameters you need. Then, it must get the actual code of
    the function right. In this example, Copilot also provided the code for the function
    (also known as the function’s body).'
  prefs: []
  type: TYPE_NORMAL
- en: There’s an alternate way to prompt Copilot to write the code for a function
    that may help it generate code more accurately and may help us better understand
    exactly what we want our function to do. It involves writing a docstring, and
    we’ll use docstrings to write functions for the majority of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings explain function behavior
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Docstrings* are how Python functions are described by programmers. They follow
    the function header and begin and end with three double quotation marks, as shown
    in the upcoming code function for `larger`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By writing the header and docstring, you’ll make it easier for Copilot to generate
    the right code. In the header, you’ll be the one deciding on the name of the function
    and providing the names of each parameter that you want the function to use. After
    the function header, you’ll provide a docstring that tells Copilot what the function
    does. Then, just as before, Copilot will generate the code for the function. Because
    we gave Copilot the function header, it will be able to learn from the header
    and is less likely to make mistakes. Here’s what the alternate approach would
    look like when writing that same `larger` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**#1 Docstring description of the function**  **Notice that we wrote the function
    header as well as the docstring, and Copilot supplied the body of the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2 Using a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have a function, how do we use it? Thinking back to our f(*x*) = *x*²
    analogy, how do we give the function a value of 6 for *x* so that it returns 36?
    Let’s see how to do this with code by using that `larger` function we just wrote.
  prefs: []
  type: TYPE_NORMAL
- en: The way to use a function is to *call* it. Calling a function means to invoke
    the function on specific values of parameters. These parameter values are called
    arguments. Each value in Python has a *type*, and we need to take care to give
    values of the proper type. For example, that `larger` function is expecting two
    numbers; it might not work as expected if we supply inputs that aren’t numbers.
    When we call a function, it runs its code and returns its result. We need to capture
    that result so that we can use it later; otherwise, it will be lost. To capture
    a result, we use a *variable*, which is just a name that refers to a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we ask Copilot to call the function, store the result in a variable,
    and then print the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Calls the larger function with the values 3 and 5 as inputs and stores the
    result'
  prefs: []
  type: TYPE_NORMAL
- en: The code correctly calls `larger`. Notice that it puts the two values we want
    compared after the opening parenthesis. When the function finishes, it returns
    a value that we assign to result. Then we print the result. If you run this program,
    you’ll see that the output 5 gets produced because 5 is the larger of the two
    values that we asked about.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s okay if you aren’t comfortable with all the details here, but what we
    want you to recognize is when a function is being called, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The general format for a function call is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, when you see those parentheses right after a name, it means there’s a function
    call. Calling functions as we did here will be important to our workflow with
    Copilot, particularly in how we test functions to see if they are working properly.
    We’ll also need to call functions to get work done because functions don’t do
    anything until we call them.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 The design cycle of functions with Copilot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s introduce you to the workflow we’ll use for the next few chapters. Designing
    functions with Copilot involves the following cycle of steps (see figure 3.2):'
  prefs: []
  type: TYPE_NORMAL
- en: Determine the desired behavior of the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a prompt that describes the function as clearly as possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow Copilot to generate the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read through the code to see if it seems reasonable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test the code to see if it’s correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the code is correct after multiple tests, move on.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the code is incorrect, move to step 2, and edit the prompt.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![figure](../Images/3-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 General editing cycle with Copilot. This assumes you define a reasonable
    function.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We won’t learn how to do step 4 until the next chapter, but we bet you can already
    recognize when the code is blatantly wrong. For example, Copilot might give you
    only comments to fill the body of the function. Comments don’t do anything—they
    aren’t code—so a bunch of comments with no other code is clearly not the right
    thing to do. Or, Copilot might just write a single line such as `return` `-1`,
    or, our personal favorite, `Your` `code` `here`. Copilot learned that one from
    us professors when we provide students partial code and ask them to write the
    rest with “Your code here.” Those are all obviously incorrect, but in the next
    chapter, we’ll go over how to read code so you can more quickly spot when more
    complicated code is incorrect and, perhaps more importantly, see where and how
    to fix it. In later chapters, we’ll keep expanding on this cycle to include effective
    debugging practices, and we’ll keep practicing how to improve prompts.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Examples of creating good functions with Copilot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’re going to write a bunch of functions with Copilot. We
    think you’ll get a much better feel for functions by seeing concrete examples,
    and we’ll code them entirely in Copilot to help you see the cycle of function
    design we just described. Although our goal in this chapter isn’t to help you
    read code just yet, we’ll see programming features (sometimes called *constructs*)
    in the solutions that are very common in code (e.g., `if` statements, loops),
    so we’ll point those out when we see them. Then, in chapter 4, we’ll say more
    about how to read this code in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the functions we’re about to work on are unrelated to each other. For
    example, we’ll start with a function about stock share prices and move to functions
    about strong passwords. You typically wouldn’t store unrelated stuff like this
    in the same Python file. Because we’re just exploring different examples of good
    functions, feel free to store all functions in the same Python file, perhaps named
    function ch3.py or function_practice.py.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1 Dan’s stock pick
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dan is an investor in a stock called AAAPL. He purchased 10 shares for $15 each.
    Now, each of those shares is worth $17\. Dan would like to know how much money
    he has made on the stock.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we want to make our function as general as possible. If the only
    thing our function does is calculate this exact AAAPL situation, it wouldn’t be
    that useful in general. Sure, it would help Dan right now, but what about when
    AAAPL’s share price changes again or when he is interested in another stock entirely?
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful general function here would take three parameters, all of which are
    numbers. The first parameter is the number of shares purchased, the second is
    the share price when the shares were purchased, and the third is the current share
    price. Let’s call this function `money_made`, because it’s going to determine
    how much money we’ve made or lost on the stock. In general, you want to name your
    function as an action word or words that describe what your function is doing.
    With that, we have enough to write the function header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need a docstring. In the docstring, we need to explain what each parameter
    is for by using its name in a sentence. We also need to include what the function
    is supposed to do. Adding our docstring, here is the full prompt we provide to
    Copilot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After typing that prompt, go to the next line, and press the Tab key. Copilot
    will fill in the code for the function. Don’t worry that the code gets indented:
    the code of functions is supposed to be indented, and, in fact, it’s an error
    if it isn’t! Here’s what we got from Copilot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code seems sensible. In the parentheses, it figures out the difference
    between the current price and the purchase price (the `-` is used for subtraction),
    and then it multiplies that by the number of shares that we have (the `*` is used
    for multiplication). Inspecting code like this is a useful skill, and we’ll get
    serious about it in the next chapter. Another useful skill is testing the function.
  prefs: []
  type: TYPE_NORMAL
- en: To test the `money_made` function, we call it using various inputs and observe
    the output in each case. We could do this by asking Copilot to call the function,
    and then we run our program, much as we did with our `larger` function. We could
    then ask Copilot to change the function call by asking it to call the function
    with a different input, and then we would run our program again, repeating as
    many times as needed. However, we find it easier and more convenient to call the
    function ourselves from an interactive window. This way, we can call the function
    as many times as we like without going through Copilot at all and without cluttering
    up our program with stuff we’re going to delete anyway.
  prefs: []
  type: TYPE_NORMAL
- en: To try this interactive approach, select/highlight all the code of the function,
    and then press Shift-Enter (you can access a similar interactive session by selecting
    the text, right-clicking, and choosing Run Selection/Line in the Python window,
    but the guidance here is if you use Shift-Enter). Figure 3.3 shows what this looks
    like if you select the text of the function and press Shift-Enter.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 Running Python in an interactive session in VS Code. Note the >>>
    at the bottom of the TERMINAL tab.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At the bottom of the resulting window, you’ll see three greater-than symbols
    >>>. This is called a *prompt*, and you’re allowed to type Python code here. (This
    prompt has nothing to do with the kind of prompt that we use when interacting
    with Copilot.) It will show us right away the result of the code that we type,
    which is convenient and fast.
  prefs: []
  type: TYPE_NORMAL
- en: To call our `money_made` function, we need to provide three arguments, and they
    will be assigned left to right to the parameters. Whatever we put first will be
    assigned to `num_shares`, whatever we put second will be assigned to `purchase_share_price`,
    and whatever we put third will be assigned to `current_share_price`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try this! At the prompt, type the following, and press Enter (or Shift-Enter).
    Don’t type the >>>, as that’s already there; we’re including it throughout the
    book to make it clear where we’re typing. Figure 3.4 shows an example of running
    the function in the terminal at the Python prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Is `20` correct? Well, we bought 10 shares, and each of them went up $2 (from
    $15 to $17), so we did make $20\. Looks good!
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 Calling the `money_made` function from the Python prompt in the VS
    Code terminal
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’re not done testing, though. When testing a function, you want to test it
    in various ways, not just once. All one test case tells you is that it happened
    to work with the particular input values that you provided. The more test cases
    we try, each testing the function in a different way, the more confident we are
    that our function is correct.
  prefs: []
  type: TYPE_NORMAL
- en: How do we test this function in a different way? We’re looking for inputs that
    are somehow a different *category* of input. One not-so-good test right now would
    be to say, “What if our stock went from $15 to $18, instead of $15 to $17?” This
    is pretty much the same test as before, and chances are that it will work just
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good idea is to test what happens when the stock actually *loses* money.
    We expect to get a negative return value in this case. And it appears that our
    function works just fine with this category of test. Here’s our function call
    and the output returned to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'What other tests can we do? Well, sometimes a stock price doesn’t change at
    all. We expect 0 in this case. Let’s verify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Looks good! Testing is a combination of science and art. How many categories
    of things are there to test? Are these two calls really two different categories?
    Have we missed any categories? You’ll improve your testing ability through practice,
    and we’ll spend all of chapter 6 talking about testing. For now, it looks like
    our `money_made` function is doing its job.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible for a function to use variables (rather than just its parameters)
    in its code, and we want to show you an example of that now so that you’re ready
    when you see Copilot doing it. Here’s an equivalent way to write the code for
    our `money_made` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This code may even be easier to read for you: it first figures out the difference
    in share price, and then it multiplies that by the number of shares. We encourage
    you to test this version to help convince yourself that it’s still correct.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2 Leo’s password
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Leo is signing up for a new social network website called ProgrammerBook. He
    wants to make sure that his password is strong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Leo starts with a modest definition of what it means for a password to be strong:
    it’s strong if it’s not the word *password* and not the word *qwerty*. Those are
    terrible passwords, for sure, but in reality, we have to do way better than this
    definition to ensure that our password is strong! A helpful function would be
    one that takes a proposed password and tells us whether it’s strong or not.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike our previous functions in this chapter, we’re not dealing with numbers
    here. The parameter, the password to check, is text. And the return value is supposed
    to indicate some yes/no result. We need new types!
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python type for text is called a *string*. There are zillions of possible
    strings because we can use a string to store whatever text we want. The Python
    type for a yes/no result is called a *Boolean* or *bool*. A bool has only two
    values: `True` or `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright! We’re ready to prompt Copilot. For functions that return bool (`True`/`False`)
    values, we usually name the function as `has_x`, `is_x`, or similar using some
    other verb that implies a true/false result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In response, here’s what Copilot wrote for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Look over that code for a moment. That `!=` operator is the “not equal” operator,
    and each string that doesn’t count as a strong password is in single quotation
    marks. We’re going to use quotation marks every time we need to specify a specific
    string value. Again, we’ll talk more about how to read code in the next chapter,
    but for now, we hope that the code makes a fuzzy sort of sense: it looks like
    it’s checking that the password isn’t `password` and isn’t `qwerty`, which matches
    our definition of a strong password.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s make sure that this function does indeed work by making a few test
    calls. We’ll start by testing the passwords that aren’t strong. We had better
    get back `False` for each of these—and we do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Good! Now, let’s try a strong password. We need to see `True` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Good stuff! We now see that the function sometimes returns `False` and other
    times returns `True`, so at least it’s not always returning `False`. Let’s try
    one more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, technically `True` is correct, but, wow, is `Leo` a bad password. We
    should really have done better with our definition of a strong password. Let’s
    change our prompt to give a more reasonable definition of what it means for a
    password to be strong. Here’s our next prompt and what Copilot gave us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That `for` `char` `in` `password` that shows up a few times here is a way for
    Python to consider each character of the password. It enables something called
    a *loop*, which is a key topic that we’ll study in chapter 5.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it’s possible that you didn’t get the same code from Copilot as we
    did. But based on the code that we got, it looks like the first piece is looking
    for any uppercase character, the second piece is looking for any digit, and the
    third is looking for something that’s not an `isalnum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe `isalnum` means “is alphanumeric.” Does that include special symbols,
    and, if so, which ones? Let’s test this function to see how well we’re doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Uh-oh! We got the wrong answer for that third password. It looks pretty strong,
    but it’s not, because it lacks a special symbol. Our function returned `True`,
    but that’s the wrong return value: it was supposed to return `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: The code that Copilot gave us is wrong. Maybe the code that you got worked fine,
    but we didn’t get so lucky, and it’s important we know how to identify (like we
    just did) when the code is wrong and then fix it. It’s not important to know why
    it’s wrong right now, but if you’re curious about why our prompt may have given
    us the wrong behavior, it’s because we didn’t specify what we meant by a special
    character, and the code it gave us counts spaces as special characters.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, as we begin to troubleshoot our wrong code, we have two options.
    One option is to press Ctrl-Enter and look through the other suggestions that
    Copilot gives us. Maybe one of those suggestions will have something to do with
    special symbols that looks different from the one that didn’t work?
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, on our computer here, we see such options, including this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Specific choice of special symbols'
  prefs: []
  type: TYPE_NORMAL
- en: Test this function with strings such as `Leo`, `N3w` `Y0rk` `J375`, and `N3w`
    `Y0rk` `J375$` and you should see that the function works well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our second option is to do some prompt engineering, which means adjusting our
    prompt to influence what Copilot gives us. In our original prompt, we talked about
    special symbols. This, in retrospect, is vague. We probably meant something more
    specific, such as punctuation. If we specifically talk about punctuation in our
    prompt, we get this interaction with Copilot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks good! That last line is talking about punctuation, which is hopeful.
    Let’s test it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the bottom of that error message, you’ll see that `'string'` isn’t
    defined. Copilot wants to use a module, called `string`, but it’s a module that
    needs to be imported before we can use it. This “not defined” result can happen
    for various types of errors related to names not being found, and oftentimes the
    culprit is a module that hasn’t been imported. There are a lot of modules in Python,
    but the `string` module is well known. As you work with Copilot more, you’ll learn
    which modules are commonly used so you know to import them. You could also do
    a quick internet search to ask, “Is string a Python module,” and the results would
    confirm that it is. What we need to do is import the module.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is similar to what happened in the code that Copilot generated
    for us in chapter 2\. Back then, Copilot was using the csv module, which is a
    module already installed with Python. The string module is similarly included
    with Python; Copilot just forgot to import it. As we discussed in chapter 2, some
    modules do need to be manually installed, but the string module isn’t one of them.
    So, we don’t need to install string; we just have to import it.
  prefs: []
  type: TYPE_NORMAL
- en: Importing modules
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are a number of useful modules available in Python. In chapter 2, Copilot
    used the csv module to make it easier to deal with comma-separated values (CSV)
    files. But for Python code to take advantage of a module, we have to import that
    module. You might ask why we don’t have modules available to us without importing
    them, but that would massively increase the complexity of the code and what Python
    has to do to run code behind the scenes. Instead, the model is to include modules
    if you want to use them, and they aren’t included by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add `import` `string` at the top of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’re in good shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That last one is `True`. It’s a strong password because it has the `$` punctuation
    added to it.
  prefs: []
  type: TYPE_NORMAL
- en: We hope that you’re now convinced of the value of testing. Sometimes, new programmers
    don’t test their code. They assume that the code they write is correct because
    it made sense to them. An interesting difference between novice and experienced
    programmers is that novices often assume their code is right, whereas experienced
    programmers assume their code is wrong until thoroughly tested and proved otherwise.
    Beyond this, we find that new programmers sometimes fail to test well because
    it’s disheartening to learn that the code is wrong. But it’s better to know now
    rather than later when others are using your code in a serious application. Finding
    errors through testing is actually a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.3 Getting a strong password
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have a function that tells us whether a password is strong or not,
    let’s write a function that obtains a strong password from the user. It will ask
    again and again for a password until the user types a strong one. This is the
    kind of code that websites use when they tell you, “Sorry, your password is too
    weak, try again.”
  prefs: []
  type: TYPE_NORMAL
- en: 'What should the header for such a function look like? Well, it’s going to ask
    the user for a password, but we won’t have a password parameter. In fact, we won’t
    have any parameters at all because the function doesn’t need any information to
    do its job—it just has to prompt the user, and the user will type the password
    at the keyboard. When the function has done its work, it will return the strong
    password, so it will continue to return a string as the output. Let’s try this
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following code from Copilot as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '#1 It’s calling our earlier is_strong_password function!'
  prefs: []
  type: TYPE_NORMAL
- en: That `while` keyword creates another kind of loop, this one continuing as long
    as the entered password isn’t strong. Copilot is also smart enough to call our
    earlier `is_strong_password` function to determine what counts as a strong password.
    As you’ll see in future chapters, using functions as building blocks in this way
    is precisely how large programs are built. You’ll often notice Copilot calling
    your earlier functions to solve later ones, much as we observed here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test this! Highlight all the code from our two password functions, and
    press Shift-Enter. We’ll call the function that we want to test. Then, try typing
    passwords, pressing Enter after each one. You’ll notice that it keeps asking until
    you finally provide a strong password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it stops asking us for a password when we finally provide a strong
    password. Then, we see the string in quotes that it returned, which is, indeed,
    our strong password.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.4 Scrabble scoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of Dan’s favorite board games is Scrabble. Have you played it? If not, all
    you need to know is that you have some tiles in your hand, each with a letter
    on it, and your goal is to form a word using any combination of those letters.
    You don’t need to form the word exclusively with your tiles—you can attach those
    letters to existing letters on the board to create longer words—but we’re not
    going to worry about that here. The important thing for us is that different letters
    are worth different numbers of points. For example, an *a* is worth only 1 point
    because *a* is such a common letter. But *q* and *z*? Those doozies are each worth
    10 points because they’re so tough to use—or should we say *puzzling* to use.
    Yeah, that’s better.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the score for a word, we add up the scores for each of its letters.
    For example, the score for *zap* would be 14\. That’s because *z* is worth 10,
    *a* is worth 1, and *p* is worth 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dan would like a function that, given a word, tells him how many points that
    word is worth. OK, so we need a function that takes a word (which is just one
    parameter). Let’s try this prompt, where we’ve included the number of points that
    each letter is worth per official Scrabble rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For this function, Copilot isn’t filling in the whole body for us with one press
    of the Tab key. Tab is also used to indent the code, which we also need to do
    here before Copilot will present us with code. So, we’re having to press Tab (sometimes
    once for the indentation and then again for Copilot), wait for the code to appear,
    then press Tab to accept that code, then press Enter again for more code to be
    presented, and repeat the process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Copilot to suggest code may require pressing Tab or Enter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We find that Copilot will sometimes pause in giving suggestions until you press
    a key to help prompt it. As mentioned in table 2.1, if you’re giving it comments,
    Copilot will sometimes just want to give you more comments as suggestions. Pressing
    Enter another time can often trigger it to start generating code instead. Other
    times, pressing Tab will cause it to continue providing suggestions. Refer to
    table 2.1 if Copilot isn’t generating code for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, after doing that a few times, the entire code unfurls, and we get
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that all the letters of the alphabet are accounted for here, and the
    number of points that each category is worth is on the following line. We’ll discuss
    this overall kind of decision structure in the next chapter, but, at a high level,
    it’s walking through the word character by character and, for each character,
    figuring out which letter it is and adding the appropriate number of points for
    that letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test this to make sure our code is performing the way we want. We know
    that the word *zap* should be worth 14 points, and it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try a couple more. In each case, calculate by hand what you expect the
    answer to be—that way, you’ll know if the code is doing the right thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many ways to write correct code for a function. If you press Ctrl-Enter
    and look at the Copilot suggestions, you may see different types of code. It doesn’t
    necessarily mean that one of these types is right and the others are wrong. For
    example, here’s another solution for `num_points` that we got from the other Copilot
    suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Notice here that each letter is listed individually along with its number of
    points. This structure with the letters and points is called a *dictionary*, and
    again, you’ll learn about dictionaries properly in a later chapter. The point
    for now is just that there are often multiple, equivalently good ways for Copilot
    to write the code for a function. Give this one a try with some test cases before
    you continue!
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.5 The best word
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s continue with the Scrabble theme. Suppose that Dan has a bunch of words
    that he can make right now, but he doesn’t know which one will give him the most
    points. Should he make the word *zap*, *pack*, or *quack*? It would be nice if
    we had a function that could take a bunch of words and tell us which is the best
    one.
  prefs: []
  type: TYPE_NORMAL
- en: How many parameters should we have in such a function? Your first instinct may
    be three parameters, one for each of the 3 words in our options. But that wouldn’t
    be very flexible. After all, what if we want to know the best of 5 words, 10 words,
    or 50 words? We would like our function to work no matter how many words we’re
    considering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trick is to use a function with one (yes, just one!) parameter, which is
    a *list* of words. Just like numbers, strings, and dictionaries, a `list` is a
    type supported by Python. It’s incredibly useful because it allows us to collect
    as many values into one place as we like. We can prompt Copilot like this to get
    the function that we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'How will Copilot know how many points each word is worth? Well, it can call
    that `num_points` function that we wrote in the previous section! Here’s the code
    that Copilot gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We need to be careful to call this function correctly when testing. Using
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'won’t work because that’s passing values for three parameters, not one. The
    right way to call it is to put the words inside square brackets, like this (we’ll
    see more about lists in the next chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'But, as usual, you shouldn’t be content with just one test case. This function
    should work in other valid but perhaps strange cases too, such as when we have
    only one word in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: However, we wouldn’t test this function on a list that has no words in it. What
    would it even make sense to do in that case? Regardless of what the function does,
    it’d be hard to say one way or the other whether it was doing the correct thing
    in a situation where there really is no correct behavior!
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Benefits of functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you’ve seen a number of functions, we hope you’re starting to get
    a feel for how functions are used in software. We already mentioned that functions
    are critical in performing problem decomposition. Beyond problem decomposition,
    functions are valuable in software for a number of other reasons, including the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cognitive load —*You may have heard of cognitive load [1] before. It’s the
    amount of information your brain can handle at any given time and still be effective.
    If you’re given four random words and asked to repeat them back, you might be
    able to do that. If you’re given the same task with 20 words, most of us would
    fail because it’s too much information to handle at once. Similarly, if you’ve
    ever been on a road trip with your family and are trying to optimize the travel
    time, combined with stops for the kids, lunch breaks, bathroom stops, gas station
    stops, good locations for hotels, and so on, you might have felt your head swimming
    to manage all those constraints at once. That point when you can’t handle it all
    at once is when you’ve exceeded your own brain’s processing power. Programmers
    have the same problem. If they are trying to do too much at once or solve too
    complex a problem in one piece of code, they struggle to do it correctly. Functions
    are designed to help programmers avoid doing too much work at once.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**   **Avoid repetition —*Programmers (and, we’d argue, humans in general)
    aren’t very excited about solving the same problem over and over. If I write a
    function that can correctly compute the area of a circle once, I don’t need to
    write that code ever again. That means if I have two sections of my code that
    need to compute the area of a circle, I’d write one function that computes the
    area of the circle, and then I’d have my code call that function in each of those
    two places.***   *Improve* **testing —*It’s a lot harder to test a section of
    code that does multiple things compared to code that does one thing. Programmers
    use a variety of testing techniques, but a key technique is known as *unit testing*.
    Every function takes some input and produces some output. For a function that
    computes the area of a circle, for example, the input would be the circle’s radius,
    and the output would be its area. Unit tests give a function an input and then
    compare that input to the desired result. For the area-of-a-circle function, we
    might test it by giving it varying inputs (e.g., some small positive numbers,
    some large positive numbers, and 0) and compare the result of the function against
    the values we know to be correct. If the answers from the function match what
    we expect, we have a higher degree of confidence that the code is correct. If
    the code produces a mistake, we won’t have much code to check to find and fix
    the problem. But if a function does more than one task, it vastly complicates
    the testing process because you need to test each task and the interaction of
    those tasks.***   **Improve reliability —*When we write code as experienced software
    engineers, we know we make mistakes. We also know Copilot makes mistakes. If you
    imagine you’re an amazing programmer and each line of code you write is 95% likely
    to be correct, how many lines of code do you think you can write before at least
    one of those lines is likely to be incorrect? The answer is only 14\. We think
    95% correctness per line is probably a high bar for even experienced programmers
    and is likely a higher bar than what Copilot produces. By keeping the tasks small,
    tasks solvable in 12–20 lines of code, we reduce the likelihood that there’s an
    error in the code. If combined with good testing as noted previously, we can feel
    even more confident that the code is correct. Last, nothing is worse than code
    that has multiple mistakes that interact together, and the likelihood of multiple
    mistakes grows the more code you write. Both of us have been on multi-hour debugging
    expeditions because our code had more than one mistake, and we both became a lot
    better at frequent testing of short pieces of code as a result!***   **Improve
    code readability —*In this book, we mostly use Copilot to write code from scratch,
    but that’s not the only way to use Copilot. If you have a larger piece of software
    that you or your coworkers are all editing and using, Copilot can jump in to help
    write code for that too. It’s in everyone’s interest to understand the code, whether
    most of it is written by humans or by Copilot. That way, we can find bugs more
    easily, determine what code to start modifying when we want to add new features,
    and understand at a high level what would be easy or difficult to achieve with
    our overall program design. Having tasks broken down into functions helps us understand
    what each part of the code is doing so we can gain better insight into how it
    all works together. It also helps divide up the work and responsibility for ensuring
    the code is correct.*****'
  prefs: []
  type: TYPE_NORMAL
- en: '**These benefits are huge for programmers. Programming languages haven’t always
    had functions. But even before they did, programmers did their best to use other
    features to mimic functions. They were ugly hacks (google “goto statements” if
    you’re interested), and all programmers are happy that we have proper functions
    now.'
  prefs: []
  type: TYPE_NORMAL
- en: You may be asking, “I see how these advantages matter to humans, but how do
    they affect Copilot?” In general, we believe all the principles that apply to
    humans apply to Copilot, albeit sometimes for different reasons. Copilot may not
    have cognitive load, but it’s going to do better when we ask it to solve problems
    similar to what’s been done by humans before. Because humans write functions to
    solve tasks, Copilot will mimic that and write functions as well. Once we’ve written
    and tested a function, whether by hand or by Copilot, we don’t want to write it
    again. Knowing how to test if your program is working properly is just as essential
    for code produced by humans as it is by Copilot. Copilot is as likely to make
    mistakes when it generates code, so we want to catch those mistakes quickly, just
    as we do with human-written code. Even if you only work on your own code and never
    have anyone else read it, you’ll often have to go back years later to edit what
    you’ve written. Having done this ourselves, we can attest that it’s important
    for your code to be readable for your future self!
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Roles of functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are used in many different roles in programming. At a high level,
    programs are functions that (often) call other functions. Critically, all programs,
    including Python programs, originate with a single function (named `main` in languages
    such as Java, C, and C++). Python’s `main` function is essentially the first line
    of code that isn’t in a function. But if every program starts with a single function
    and trying to solve a large problem with a single function is a mistake, how does
    that work? Well, `main` will call other functions, which, in turn, will call other
    functions, and so forth. The code will still execute (mostly) sequentially in
    each function, so it may start in `main` but then move to another function, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s use the code in the following listing. We wrote this code,
    not Copilot, because no one would ever want to write this code for anything useful
    outside of teaching. It’s just for demonstrating how function calls work.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 3.1 Code to demonstrate how Python handles function calls
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '#1 This is the start of the program. We’ll call this “main” after the main
    function in other languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we ran this program, the output would be (we’ll explain why next):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In figure 3.5, we provide a diagram of how the code in listing 3.1 would be
    executed by the computer. We’ve intentionally provided an example that has many
    function calls to tie together what we just learned. Again, this is *not* practical
    code; it’s just for learning purposes. Let’s trace through the code execution
    together. It may be easier to refer to figure 3.5 than listing 3.1 as you follow
    along, but either will work.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/3-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 Flow of function execution in our example from listing 3.1
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The program will start execution with the first line in the Python code that
    isn’t a function ( `print("Hi")`). Although Python doesn’t have a `main` function
    per se, we’ll refer to the block of code after the functions as `main` to help
    with this explanation. Code executes sequentially unless it encounters commands
    that tell it to execute code somewhere else. So, after executing `print("Hi")`,
    it will go to the next line, which is the call to `funct1`: `funct1()`. The call
    to `funct1` changes where the code is executing to the start of that function,
    which is the following statement: `print("there")`. The next line of `funct1`
    calls `funct2`, so the program will execute the first line of `funct2`: `print("my")`.
    What gets interesting is what happens when `funct2` finishes. There are no more
    lines of code to execute, so it automatically moves execution back to the first
    line following the call to `funct2` in `funct1`. (If the function call is in the
    middle of another statement, that statement resumes execution, but for this example,
    the function calls are each on their own line.) You may be curious why it goes
    to the next line after the call to `funct2` rather than back to the call of `funct2`.
    The problem is if it returned back to the call to `funct2`, it would be trapped
    calling `funct2` forever. As a result, functions always return back to the next
    piece of code to execute (in this example, the next line) after they are called.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing this example, the next line of the code executed will be the line
    that prints `friend`. The next line calls `funct3`, which prints a period (.)
    and then returns back to its caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we’re back in `funct1`, on the line `print("")`. Printing an empty piece
    of text causes a new line. Now `funct1` is finished, so it transfers execution
    back to the next line in `main` after it was called. We suspect you’re getting
    the idea by now, so let’s move a bit more quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main` next prints `I''m` and then calls `funct4`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`funct4` prints `well` and then returns to `main` where the next line of code
    calls `funct3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`funct3` prints a period (.) and then returns to `main`. Notice that `funct3`
    was called both by `funct1` and by `main`, but that’s okay because functions remember
    how to return to the function that called them. In fact, having multiple functions
    calling the same function is a sign that the function being called multiple times
    is a good function because of its reuse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After `funct3` returns to main, it will print `""`, which causes a new line
    to be started, and then it prints the word `Bye`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That was a long example, but we provided it to give you an idea of how functions
    execute and how programs consist of defining and calling functions. In any software
    you use, think about the specific tasks that it performs: the programmers probably
    wrote one or more functions for each one. The button in a text editor that changes
    the text to bold probably calls a function to change the text to bold. That function
    might change the editor’s internal idea of the text (the editor likely stores
    your text in a different format than how you view it), and then it might call
    another function that updates the user’s (your) view of the text.'
  prefs: []
  type: TYPE_NORMAL
- en: We’d also like to use this example to discuss the different roles that functions
    play. A *helper* function is a function whose job is to make another function’s
    job easier. In a sense, every function that isn’t `main` is a helper function.
    The best helper functions are those that carry out some small, well-defined part
    of some other task, such as our `is_strong_password` function in section 3.3.2
    serving as a helper function for our `get_strong_password` function in section
    3.3.3.
  prefs: []
  type: TYPE_NORMAL
- en: Some functions simply call a bunch of other functions without doing any of their
    own work. There aren’t any of these in our example. However, if you removed the
    three `print` statements from `funct1`, it becomes this type of coordinating function.
    Others may call helper function(s) and then do some work on their own. `funct1`
    is a great example of a function that calls other functions but also does work
    on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Another type of function—which we call a *leaf* function—stands on its own without
    calling other functions for help (except perhaps functions that already come with
    Python). Why leaf? If you imagine all the function calls as a big tree, these
    functions are the leaves of the tree because they have nothing coming out of them.
    `funct2`, `funct3`, and `funct4` are all leaf functions in our example. We’re
    primarily concerned with leaf functions in this chapter, but you’ll see examples
    of other kinds of functions here and especially in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 What’s a reasonable task for a function?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s no clear rule for what makes a good function, but there are some intuitions
    and recommendations we can share. Make no mistake, though—identifying good functions
    is a skill that takes time and practice. To help you with this, we gave you some
    examples of good functions in section 3.3\. In this section, we’ll outline our
    recommendations and provide you with some additional good and bad examples to
    help build that intuition.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.1 Attributes of good functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some guidelines that we believe will help you see what makes a good
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '*One clear* **task to perform —*A leaf function might be something like “compute
    the volume of a sphere,” “find the largest number in a list,” or “check to see
    if a list contains a specific value.” Nonleaf functions can achieve broader goals,
    like “update the game graphics” or “collect and sanitize input from the user.”
    Nonleaf functions should still have a particular goal in mind, but they are designed
    knowing that they will likely call other functions to achieve their goal.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**   **Clearly defined behavior —*The task “find the largest number in a list”
    is clearly defined. If I gave you a list of numbers and asked you for the largest
    number, you know what you should do. In contrast, the task “find the best word
    in the list” is poorly defined as stated. You need more information: What is the
    “best” word? Is it the longest, the one that uses the fewest vowels, or the one
    that doesn’t share any of the same letters as “Leo” or “Dan”? You get the point;
    subjective tasks aren’t great for computers. Instead, we could write the function
    “find the word in the list that has the most characters” because what is expected
    is well defined. Often, programmers can’t put all the particulars of a function
    just in the name, so they fill in the details in the docstring to clarify its
    use. If you find yourself having to write more than a few sentences to describe
    the function’s behavior, the task is probably too much for a single function.***   **Short
    in number of lines of code —*We’ve heard different rules over the years for the
    length of functions, informed by different company style guidelines. The lengths
    we’ve heard vary from 12 to 20 lines of Python code as the maximum number of lines.
    In these rules, the number of lines is being used as a proxy for code complexity,
    and it’s not a bad rule of thumb. As programmers ourselves, we both apply similar
    rules to our code to ensure the complexity doesn’t get out of hand. With Copilot,
    we can use this as a guide as well. If you ask Copilot for a function, and it
    gives you back 50 lines of code, this probably isn’t a good function name or task.
    As we discussed earlier, that many lines of code are likely to have errors anyway.***   **General
    value over specific use —*A function that returns the number of values in a list
    that are greater than 1 might be a specific need for a part of your program, but
    there’s a way to make this better. The function should be rewritten to return
    the number of values in the list that are greater than another parameter. The
    new function would work for your use case (give the function 1 for the second
    parameter) and for any value other than 1\. We strive to have functions be as
    simple but as powerful as possible. This is why we wrote our function in section
    3.3.1 to work for any stock, not just AAAPL.***   **Clear input and output —*You
    generally don’t want a lot of parameters. That doesn’t mean you can’t have a lot
    of input, though. A single parameter could be a list of items, as in our `best_word`
    function in section 3.3.5\. It does mean that you want to find ways to keep the
    number of inputs to a minimum. You can only return one thing, but again, you can
    return a list so you aren’t as limited as it may appear. But if you find yourself
    writing a function that sometimes returns a list, sometimes returns a single value,
    and sometimes returns nothing, that’s probably not a good function.*****'
  prefs: []
  type: TYPE_NORMAL
- en: '**### 3.6.2 Examples of good (and bad) leaf functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are examples of good leaf functions (the function is on the left in italics,
    and the goal of that function is described on the right):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Compute the volume of a sphere —*Given the sphere’s radius, return its volume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Find the largest number in a list —*Given a list, return the largest value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Check whether a list contains a specific value —*Given a list and a value,
    return True if the list contains the value and False if it does not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Print the state of the checkers game —*Given a 2D list representing the game
    board, output the game board to the screen in text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Insert a value in a list —*Given a list, a new value, and a location in the
    list, return a new list that is the old list with the new value inserted at the
    desired location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are examples of bad leaf functions and our reasons for why they are bad:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Request a user’s tax information and return the amount they owe this year —*Perhaps
    in some countries this wouldn’t be too bad, but we can’t imagine this as a single
    function in either the United States or Canada given the complexity of the tax
    rules!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Identify the largest value in the list and remove that value from the list —*This
    might not seem so bad, but it’s really doing two things. The first is to find
    the largest value in the list. The second is to remove a value from the list.
    We’d recommend two leaf functions, one that finds the largest and one that removes
    the value from the list. However, this might make a good nonleaf function if your
    program needs to perform this task frequently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Thinking of our dataset from chapter 2.) *Return the names of the quarterbacks
    with more than 4,000 yards of passing in the dataset —*This has too much specificity.
    Without a doubt, the number 4,000 should be a parameter. But it’s likely better
    to make a function that takes as input the position (quarterback, running back),
    the statistic (passing yards, games played), and the cutoff that we care about
    (4,000, 8,000) as parameters. This new function provides far more capability than
    the original, allowing a user to call the function to determine not only the names
    of particular quarterbacks who threw for more than 4,000 yards but also, for example,
    running backs who had more than 12 rushing touchdowns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Determine the best movie of all time —*This function is too vague. Best movie
    by what definition? What movies should be considered? A better version of this
    might be a function that determines the highest-rated movie by users given at
    least a minimum number of ratings. This function would likely be part of a larger
    program where the function would have data from a movie database (say, IMDB) and
    minimum number of user ratings as inputs. The output of the function would be
    the highest-rated movie that has at least as many ratings as specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Play Call of Duty —*This might be the `main` function in the large code base
    for the Call of Duty game, but it’s definitely not a leaf function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, in this chapter, you’ve learned about functions in Python and how you
    can use Copilot to help write them. You’ve also learned about the characteristics
    of good functions and how important it is to make sure your functions are solving
    tasks that can be managed well by Copilot.
  prefs: []
  type: TYPE_NORMAL
- en: Our next steps in this book all revolve around understanding whether the code
    produced by Copilot is correct and how to fix it when it isn’t. In the next chapter,
    we’ll start by explaining the basics of being able to read the code produced by
    Copilot because this gives us the first sanity check for whether Copilot is doing
    what we think it should be. Then, in later chapters, we’ll dig deeper into how
    to carefully test the code and what to do when it’s wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 3.7 Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Review the following function descriptions, and determine if each is a leaf
    function. Provide reasons for your answers based on the complexity of the tasks
    the functions perform and whether they are likely to require calling additional
    custom functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Scrape data.* Given a list of URLs, scrape data from each page, parse the
    content to extract specific information, and save the extracted data to a database.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Process customer orders.* Given a list of customer orders, process each order
    by checking inventory, calculating total price with discounts and taxes, updating
    inventory, and generating an order summary.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Find the largest number in a list.* Given a list, return the largest value.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Check whether a list contains a specific value.* Given a list and a value,
    return `True` if the list contains the value, and `False` if it does not.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Generate student report cards.* Given a list of students and their grades,
    calculate the final grades, assign letter grades, determine class rank, and generate
    a formatted report card for each student.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review the cycle of designing functions with Copilot as outlined in this chapter.
    This cycle includes steps from determining the function’s behavior to testing
    the generated code. Based on general programming practices, identify which of
    the following steps is *not* included in the cycle described but is commonly part
    of a software development process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying the logical correctness of the generated code by running unit tests
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Editing the function’s code manually to simplify complex logic after Copilot
    generation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Conducting performance benchmarks on the generated code to ensure efficiency
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Consulting documentation or external resources to refine the function’s prompt
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on the problem description provided, write a clear and concise prompt
    for Copilot that specifies the task to be completed. Ensure your prompt includes
    all necessary details such as expected inputs, the processing to be performed,
    and the expected output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a quaint little town, there was a humble shopkeeper who, every so often,
    would delight his customers with discounts on his goods. To streamline this process,
    he sought to create a magical formula. This formula would take the original price
    of any item in his store and the special discount he wished to offer. With these
    two pieces of information, the formula would then reveal the final price the customer
    needed to pay after the discount was woven into the original tag, making both
    the shopkeeper and his customers very happy with the ease of their transactions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you think of two or three input examples to verify the correctness of the
    function generated by Copilot based on your prompts? Include some scenarios to
    ensure the function handles different types of input correctly and calculates
    the correct output.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Review the function description and the provided test cases for calculating
    the total cost of a meal, including tax and tip. Based on the scenario and typical
    requirements of such a function, can you think of inputs where the function doesn’t
    work correctly? Explain why handling this input is necessary to ensure the function’s
    reliability and correctness across all potential use cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Problem description: Create a function that calculates the total cost of a
    meal, including tax and tip. The function should take three inputs: the base price
    of the meal, the tax rate as a percentage, and the tip rate as a percentage. The
    function should calculate and return the total cost of the meal.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test cases:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Standard Case*—Calculate the total price of a $50 meal with a 10% tax and
    a 15% tip:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Input: `base_price = 50`, `tax_rate = 10`, `tip_rate = 15`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expected output: $62.50 (calculated as $50 + $5 tax + $7.50 tip)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Zero Tip Case*—Calculate the total price of a $30 meal with a 5% tax and no
    tip:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Input: `base_price = 30`, `tax_rate = 5`, `tip_rate = 0`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expected output: $31.50 (calculated as $30 + $1.50 tax + $0 tip)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*High Tax and Tip Case*—Calculate the total price of a $100 meal with a 20%
    tax and a 25% tip:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Input: `base_price = 100`, `tax_rate = 20`, `tip_rate = 25`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expected output: $145 (calculated as $100 + $20 tax + $25 tip)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 5\. Review the initial prompt provided to Copilot and the resulting Python function.
    The code doesn’t fulfill the requirements as it only converts from Fahrenheit
    to Celsius and lacks the capability to convert in both directions based on a user-specified
    mode. How would you improve the prompt to ensure that the generated code meets
    the full requirements of the problem description?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Problem decomposition involves breaking a large problem into smaller tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use functions to perform problem decomposition in our programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each function must solve one small, well-defined task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function header or signature is the first line of code of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters are used to provide information to functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function header indicates the name of the function and names of its parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `return` to pass a value from a function to its caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A docstring uses the names of each function parameter to describe the purpose
    of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To ask Copilot to write a function, we provide it the function header and docstring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get a function to do its work by calling it with values (also called arguments)
    for its parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To test whether a function is correct, we call it with different types of inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable is a name that refers to a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every Python value has a type, such as a number, text (string), true/false value
    (bool), or collection of values (list or dictionary).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompt engineering involves modifying our prompt for Copilot to influence the
    code that we get back.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to ensure that we import any module (e.g., string) our code is using.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions reduce duplication, make it easier to test our code, and reduce the
    likelihood of bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing involves checking that the function does what we expect on a variety
    of different inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A helper function is a small function written to make it easier to write a bigger
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A leaf function doesn’t call any other function to do its job.******
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
