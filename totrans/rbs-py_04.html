<html><head></head><body>
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Type Annotations" class="preface"><div class="preface" id="annotations">
<h1 class="calibre10" id="calibre_pb_0"><span class="calibre">Chapter 3. </span>Type Annotations</h1>


<p class="author1">Python is a dynamically typed language; types aren’t known until runtime. This is an obstacle when trying to write robust code.<a data-type="indexterm" data-primary="type annotations" id="ix_typan" class="calibre5"/> Since types are embedded in the value itself, developers have a very tough time knowing what type they are working with. Sure, that name looks likes a <code class="calibre17">str</code> today, but what happens if someone makes it <code class="calibre17">bytes</code>? Assumptions about types are built on shaky ground with dynamically typed languages. Hope is not lost, though. In Python 3.5, a brand-new feature was introduced: type annotations.<a data-type="indexterm" data-primary="annotations" data-see="type annotations" id="idm45644756805464" class="calibre5"/></p>

<p class="author1">Type annotations bring your ability to write robust code to a whole new level. Guido van Rossum, creator of Python, says it best:</p>
<blockquote class="pcalibre2 calibre28 pcalibre1">
<p class="calibre29">I’ve learned a painful lesson that for small programs dynamic typing is great. For large programs you have to have a more disciplined approach and it helps if the language actually gives you that discipline, rather than telling you “Well, you can do whatever you want.”<sup class="calibre11"><a data-type="noteref" id="idm45644756802936-marker" href="part0006_split_008.html#idm45644756802936" class="calibre5">1</a></sup></p></blockquote>

<p class="author1">Type annotations are the more disciplined approach, the extra bit of care you need to wrangle larger codebases. In this chapter, you’ll learn how to use type annotations, why they are so important, and how to utilize a tool called a typechecker to enforce your intentions throughout your codebase.</p>






</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Type Annotations" class="preface">
<div class="preface" id="annotations">
<section data-type="sect1" class="preface" data-pdf-bookmark="What Are Type Annotations?"><div class="preface" id="idm45644756800280">
<h1 class="calibre12" id="calibre_pb_1">What Are Type Annotations?</h1>

<p class="author1">In <a data-type="xref" href="part0005_split_000.html#types" class="calibre5">Chapter 2</a>, you got your first glance at a type annotation:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code><code class="calibre17"> </code><code class="nf">close_kitchen_if_past_close</code><code class="calibre17">(</code><code class="n">point_in_time</code><code class="calibre17">:</code><code class="calibre17"> </code><code class="n">datetime</code><code class="calibre17">.</code><code class="n">datetime</code><code class="calibre17">)</code><code class="calibre17">:</code><code class="calibre17"> </code><a class="calibre5" id="co_type_annotations_CO1-1" href="part0006_split_001.html#callout_type_annotations_CO1-1"><img src="../images/00002.gif" alt="1" class="calibre40"/></a><code class="calibre17">
</code><code class="calibre17">    </code><code class="k">if</code><code class="calibre17"> </code><code class="n">point_in_time</code><code class="calibre17"> </code><code class="calibre17">&gt;</code><code class="calibre17">=</code><code class="calibre17"> </code><code class="n">closing_time</code><code class="calibre17">(</code><code class="calibre17">)</code><code class="calibre17">:</code><code class="calibre17">
</code><code class="calibre17">        </code><code class="n">close_kitchen</code><code class="calibre17">(</code><code class="calibre17">)</code><code class="calibre17">
</code><code class="calibre17">        </code><code class="n">log_time_closed</code><code class="calibre17">(</code><code class="n">point_in_time</code><code class="calibre17">)</code></pre>
<dl class="calibre13">
<dt class="calibre14"><a class="calibre5" id="callout_type_annotations_CO1-1" href="part0006_split_001.html#co_type_annotations_CO1-1"><img src="../images/00002.gif" alt="1" class="calibre40"/></a></dt>
<dd class="calibre41"><p class="calibre42">The type annotation here is <code class="calibre17">: datetime.datetime</code></p></dd>
</dl>

<p class="author1">Type annotations are an additional syntax notifying the user of an expected type of your variables.<a data-type="indexterm" data-primary="type hints" data-seealso="type annotations" id="idm45644756738712" class="calibre5"/> These annotations serve as <em class="calibre6">type hints</em>; they provide hints to the reader, but they are not actually used by the Python language at runtime. In fact, you are completely free to ignore the hints. Consider the following snippet of code, along with a comment written by the developer.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="c"># CustomDateTime offers all the same functionality with</code>
<code class="c"># datetime.datetime. I'm using it here for its better</code>
<code class="c"># logging facilities.</code>
<code class="n">close_kitchen_if_past_close</code><code class="calibre17">(</code><code class="n">CustomDateTime</code><code class="calibre17">(</code><code class="s">"now"</code><code class="calibre17">))</code> <code class="c"># no error</code></pre>
<div data-type="warning" epub:type="warning" class="calibre23"><h6 class="calibre24">Warning</h6>
<p class="author1">It should be a rare case where you go against a type hint. The author very clearly intended a specific use case. If you aren’t going to follow the type annotation, you are setting yourself up for problems if the original code changes in a way that is incompatible with the types that you are using (such as expecting a certain function to work with that type).</p>
</div>

<p class="author1">Python will not throw any error at runtime in this scenario. As a matter of fact, it won’t use the type annotations at all during runtime. There is no checking or cost for using these when Python executes.<a data-type="indexterm" data-primary="robustness" data-secondary="type annotations and" id="idm45644756706856" class="calibre5"/> These type annotations still serve a crucial purpose: informing your readers of the expected type. Maintainers of code will know what types they are allowed to use when changing your implementation. Calling code will also benefit, as developers will know exactly what type to pass in. By implementing type annotations, you reduce friction.</p>

<p class="author1">Put yourself in your future maintainer’s shoes. Wouldn’t it be nice to come across code that is intuitive to use? You wouldn’t have to dig through function after function to determine usage. You wouldn’t assume a wrong type and then need to deal with the fallout of exceptions and wrong behavior.</p>

<p class="author1">Consider another piece of code that takes in employees’ availability and a restaurant’s opening time, and then schedules available workers for that day. You want to use this piece of code and you see the following:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">schedule_restaurant_open</code><code class="calibre17">(</code><code class="n">open_time</code><code class="calibre17">,</code> <code class="n">workers_needed</code><code class="calibre17">):</code></pre>

<p class="author1">Let’s ignore the implementation for a minute, because I want to focus on first impressions. What do you think can get passed into this? Stop, close your eyes, and ask yourself what are reasonable types that can be passed in before reading on. Is <code class="calibre17">open_time</code> a <code class="calibre17">datetime</code>, the number of seconds since epoch, or maybe a string containing an hour? Is <code class="calibre17">workers_needed</code> a list of names, a list of <code class="calibre17">Worker</code> objects, or something else? If you guess wrong, or aren’t sure, you need to go look at either the implementation or calling code, which I’ve established takes time and is frustrating.</p>

<p class="author1">Let me provide an implementation and you can see how close you were.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">import</code> <code class="nn">datetime</code>
<code class="k">import</code> <code class="nn">random</code>

<code class="k">def</code> <code class="nf">schedule_restaurant_open</code><code class="calibre17">(</code><code class="n">open_time</code><code class="calibre17">:</code> <code class="n">datetime</code><code class="calibre17">.</code><code class="n">datetime</code><code class="calibre17">,</code>
                             <code class="n">workers_needed</code><code class="calibre17">:</code> <code class="nb">int</code><code class="calibre17">):</code>
    <code class="n">workers</code> <code class="calibre17">=</code> <code class="n">find_workers_available_for_time</code><code class="calibre17">(</code><code class="n">open_time</code><code class="calibre17">)</code>
    <code class="c"># Use random.sample to pick X available workers</code>
    <code class="c"># where X is the number of workers needed.</code>
    <code class="k">for</code> <code class="n">worker</code> <code class="calibre19">in</code> <code class="n">random</code><code class="calibre17">.</code><code class="n">sample</code><code class="calibre17">(</code><code class="n">workers</code><code class="calibre17">,</code> <code class="n">workers_needed</code><code class="calibre17">):</code>
        <code class="n">worker</code><code class="calibre17">.</code><code class="n">schedule</code><code class="calibre17">(</code><code class="n">open_time</code><code class="calibre17">)</code></pre>

<p class="author1">You probably guessed that <code class="calibre17">open_time</code> is a <code class="calibre17">datetime</code>, but did you consider that <span class="calibre"><code class="calibre17">workers_needed</code></span> could have been an <code class="calibre17">int</code>? As soon as you see the type annotations, you get a much better picture of what’s happening. This reduces cognitive overhead and reduces friction for maintainers.</p>
<div data-type="tip" class="calibre21"><h6 class="calibre22">Tip</h6>
<p class="author1">This is certainly a step in the right direction, but don’t stop here. If you see code like this, consider renaming the variable to <span class="calibre"><code class="calibre17">number_of_workers_needed</code></span> to reflect just what the integer means. In the next chapter, I’ll also explore type aliases, which provide an alternate way of expressing yourself.</p>
</div>

<p class="author1">So far, all the examples I’ve shown have focused on parameters, but you’re also allowed<a data-type="indexterm" data-primary="return types, annotations" id="idm45644756587112" class="calibre5"/> to annotate <em class="calibre6">return types</em>.</p>

<p class="author1">Consider the <code class="calibre17">schedule_restaurant_open</code> function. In the middle of that snippet, I called <code class="calibre17">find_workers_available_for_time</code>. This returns to a variable named <span class="calibre"><code class="calibre17">workers</code></span>.  Suppose you want to change the code to pick workers who have gone the longest without working, rather than random sampling? Do you have any indication what type <code class="calibre17">workers</code> is?</p>

<p class="author1">If you were to just look at the function signature, you would see the following:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">find_workers_available_for_time</code><code class="calibre17">(</code><code class="n">open_time</code><code class="calibre17">:</code> <code class="n">datetime</code><code class="calibre17">.</code><code class="n">datetime</code><code class="calibre17">):</code></pre>

<p class="author1">Nothing in here helps us do your job more quickly. You could guess and the tests would tell us, right? Maybe it’s a list of names? Instead of letting the tests fail, maybe you should go look through the implementation.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">find_workers_available_for_time</code><code class="calibre17">(</code><code class="n">open_time</code><code class="calibre17">:</code> <code class="n">datetime</code><code class="calibre17">.</code><code class="n">datetime</code><code class="calibre17">):</code>
    <code class="n">workers</code> <code class="calibre17">=</code> <code class="n">worker_database</code><code class="calibre17">.</code><code class="n">get_all_workers</code><code class="calibre17">()</code>
    <code class="n">available_workers</code> <code class="calibre17">=</code> <code class="calibre17">[</code><code class="n">worker</code> <code class="k">for</code> <code class="n">worker</code> <code class="calibre19">in</code> <code class="n">workers</code>
                           <code class="k">if</code> <code class="n">is_available</code><code class="calibre17">(</code><code class="n">worker</code><code class="calibre17">)]</code>
    <code class="k">if</code> <code class="n">available_workers</code><code class="calibre17">:</code>
        <code class="k">return</code> <code class="n">available_workers</code>

    <code class="c"># fall back to workers who listed they are available</code>
    <code class="c"># in an emergency</code>
    <code class="n">emergency_workers</code> <code class="calibre17">=</code> <code class="calibre17">[</code><code class="n">worker</code> <code class="k">for</code> <code class="n">worker</code> <code class="calibre19">in</code> <code class="n">get_emergency_workers</code><code class="calibre17">()</code>
                           <code class="k">if</code> <code class="n">is_available</code><code class="calibre17">(</code><code class="n">worker</code><code class="calibre17">)]</code>

    <code class="k">if</code> <code class="n">emergency_workers</code><code class="calibre17">:</code>
        <code class="k">return</code> <code class="n">emergency_workers</code>

    <code class="c"># Schedule the owner to open, they will find someone else</code>
    <code class="k">return</code> <code class="calibre17">[</code><code class="n">OWNER</code><code class="calibre17">]</code></pre>

<p class="author1">Oh no, there’s nothing in here that tells you what type you should be expecting. There are three different return statements throughout this code, and you hope that they all return the same type. (Surely every <code class="calibre17">if</code> statement is tested through unit tests to make sure they are consistent, right? Right?)  You need to dig deeper. You need to look at <code class="calibre17">worker_database</code>. You need to look at <code class="calibre17">is_available</code> and <code class="calibre17">get_emergency_workers</code>. You need to look at the <code class="calibre17">OWNER</code> variable. Every one of these needs to be consistent, or else you’ll need to handle special cases in your original code.</p>

<p class="author1">And what if these functions also don’t tell you exactly what you need? What if you have to go deeper through multiple function calls? Every layer you have to go through is another layer of abstraction you need to keep in your brain. Every piece of information contributes to cognitive overload. The more cognitive overload you are burdened with, the more likely it is that a mistake will happen.</p>

<p class="author1">All of this is avoided by annotating a return type. Return types are annotated by putting <code class="calibre17">-&gt; &lt;type&gt;</code> at the end of the function declaration.<a data-type="indexterm" data-primary="functions" data-secondary="return type annotations" id="idm45644756450280" class="calibre5"/> Suppose you came across this function signature:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">find_workers_available_for_time</code><code class="calibre17">(</code><code class="n">open_time</code><code class="calibre17">:</code> <code class="n">datetime</code><code class="calibre17">.</code><code class="n">datetime</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">list</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">]:</code></pre>

<p class="author1">You now know that you should indeed treat workers as a list of strings. No digging through databases, function calls, or modules needed.</p>
<div data-type="tip" class="calibre21"><h6 class="calibre22">Tip</h6>
<p class="author1">In Python 3.8 and earlier, built-in collection types such as <code class="calibre17">list</code>, <code class="calibre17">dict</code>, and <code class="calibre17">set</code> did not allow bracket syntax such as <code class="calibre17">list[Cookbook]</code> or <code class="calibre17">dict[str,int]</code>. Instead, you needed to use type annotations from the typing module:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre43"><code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">Dict</code><code class="calibre17">,</code><code class="n">List</code>
<code class="n">AuthorToCountMapping</code> <code class="calibre17">=</code> <code class="n">Dict</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">,</code> <code class="nb">int</code><code class="calibre17">]</code>
<code class="k">def</code> <code class="nf">count_authors</code><code class="calibre17">(</code>
                   <code class="n">cookbooks</code><code class="calibre17">:</code> <code class="n">List</code><code class="calibre17">[</code><code class="n">Cookbook</code><code class="calibre17">]</code>
                 <code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="n">AuthorToCountMapping</code><code class="calibre17">:</code>
    <code class="c"># ...</code></pre>
</div>

<p class="author1">You can also <a data-type="indexterm" data-primary="variables" data-secondary="annotating" id="idm45644756441448" class="calibre5"/>annotate variables when needed:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">workers</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">]</code> <code class="calibre17">=</code> <code class="n">find_workers_available_for_time</code><code class="calibre17">(</code><code class="n">open_time</code><code class="calibre17">)</code>
<code class="n">numbers</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="nb">int</code><code class="calibre17">]</code> <code class="calibre17">=</code> <code class="calibre17">[]</code>
<code class="n">ratio</code><code class="calibre17">:</code> <code class="nb">float</code> <code class="calibre17">=</code> <code class="n">get_ratio</code><code class="calibre17">(</code><code class="mi">5</code><code class="calibre17">,</code><code class="mi">3</code><code class="calibre17">)</code></pre>

<p class="author1">While I will annotate all of my functions, I typically don’t bother annotating variables unless there is something specific I want to convey in my code (such as a type that is different than expected). I don’t want to get too into the realm of putting type annotations on literally everything—the lack of verbosity is what drew many developers to Python in the first place. The types can clutter your code, especially when it is blindingly obvious what the type is.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">number</code><code class="calibre17">:</code> <code class="nb">int</code> <code class="calibre17">=</code> <code class="mi">0</code>
<code class="n">text</code><code class="calibre17">:</code> <code class="nb">str</code> <code class="calibre17">=</code> <code class="s">"useless"</code>
<code class="n">values</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="nb">float</code><code class="calibre17">]</code> <code class="calibre17">=</code> <code class="calibre17">[</code><code class="mi">1.2</code><code class="calibre17">,</code> <code class="mi">3.4</code><code class="calibre17">,</code> <code class="mi">6.0</code><code class="calibre17">]</code>
<code class="n">worker</code><code class="calibre17">:</code> <code class="n">Worker</code> <code class="calibre17">=</code> <code class="n">Worker</code><code class="calibre17">()</code></pre>

<p class="author1">None of these type annotations provide more value than what is already provided by Python itself. Readers of this code know that <code class="calibre17">"useless"</code> is a <code class="calibre17">str</code>. Remember, type annotations are used for type hinting; you are providing notes for the future to improve communication. You don’t need to state the obvious everywhere.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre32"><div class="sidebar" id="idm45644756244792">
<h5 class="calibre33">Type Annotations Before Python 3.5</h5>
<p class="author1">If you have the misfortune of not being able to use a later version of Python, hope is not lost.<a data-type="indexterm" data-primary="Python" data-secondary="type annotations before version 3.5" id="idm45644756243208" class="calibre5"/><a data-type="indexterm" data-primary="type annotations" data-secondary="before Python 3.5" id="idm45644756242264" class="calibre5"/> There is an alternative syntax for type annotations, even for Python 2.7.</p>

<p class="author1">To write the annotations, you need to do so in a comment:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">ratio</code> <code class="o">=</code> <code class="n">get_ratio</code><code class="o">(</code><code class="mi">5</code><code class="o">,</code><code class="mi">3</code><code class="o">)</code> <code class="c"># type: float</code>
<code class="k">def</code> <code class="nf">get_workers</code><code class="o">(</code><code class="nb">open</code><code class="o">):</code> <code class="c"># type: (datetime.datetime) -&gt; List[str]</code></pre>

<p class="author1">This is easier to miss, as the types are not visually close to the variable itself. If you have the ability to upgrade to Python 3.5, consider doing so and using the newer method of type annotations.</p>
</div></aside>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Type Annotations" class="preface">
<div class="preface" id="annotations">
<section data-type="sect1" data-pdf-bookmark="Benefits of Type Annotations" class="preface"><div class="preface" id="idm45644756799368">
<h1 class="calibre12" id="calibre_pb_2">Benefits of Type Annotations</h1>

<p class="author1">As with every decision you make, you need to weigh the costs and benefits.<a data-type="indexterm" data-primary="type annotations" data-secondary="benefits of" id="ix_typanben" class="calibre5"/> Thinking about types up front helps your deliberate design process, but do type annotations provide other benefits? I’ll show you how type annotations really pull their weight through tooling.</p>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Type Annotations" class="preface">
<div class="preface" id="annotations">
<section data-type="sect1" data-pdf-bookmark="Benefits of Type Annotations" class="preface">
<div class="preface" id="idm45644756799368">
<section data-type="sect2" data-pdf-bookmark="Autocomplete" class="preface"><div class="preface" id="idm45644756229896">
<h2 class="calibre34" id="calibre_pb_3">Autocomplete</h2>

<p class="author1">I’ve mainly talked about communication to other developers, but your Python environment benefits from type annotations as well.<a data-type="indexterm" data-primary="type annotations" data-secondary="benefits of" data-tertiary="autocomplete" id="idm45644756189256" class="calibre5"/><a data-type="indexterm" data-primary="autocompletion of variable operations" id="idm45644756188008" class="calibre5"/> Since Python is dynamically typed, it is difficult to know what operations are available.<a data-type="indexterm" data-primary="code editors, autocompletion of variable operations" id="idm45644756187128" class="calibre5"/> With type annotations, many Python-aware code editors will autocomplete your variable’s operations.</p>

<p class="author1">In <a data-type="xref" href="part0006_split_003.html#figure_3_1" class="calibre5">Figure 3-1</a>, you’ll see a screenshot that illustrates a popular code editor, VS Code, detecting a <code class="calibre17">datetime</code> and offering to autocomplete my variables.</p>

<figure class="calibre36"><div id="figure_3_1" class="figure">
<img src="../images/00003.jpeg" alt="VS Code showing autocompletion" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 3-1. </span>VS Code showing autocompletion</h6>
</div></figure>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Type Annotations" class="preface">
<div class="preface" id="annotations">
<section data-type="sect1" data-pdf-bookmark="Benefits of Type Annotations" class="preface">
<div class="preface" id="idm45644756799368">
<section data-type="sect2" data-pdf-bookmark="Typecheckers" class="preface"><div class="preface" id="idm45644756182312">
<h2 class="calibre34" id="calibre_pb_4">Typecheckers</h2>

<p class="author1">Throughout this book, I’ve been talking about how types communicate intent, but have been<a data-type="indexterm" data-primary="type annotations" data-secondary="benefits of" data-tertiary="typecheckers" id="idm45644756180472" class="calibre5"/> leaving out one key detail: no programmer has to honor these type annotations if they don’t want to. If your code contradicts a type annotation, it is probably an error and you’re still relying on humans to catch bugs. I want to do better. I want a computer to find these sorts of bugs for me.</p>

<p class="author1">I showed this snippet when talking about dynamic typing back in <a data-type="xref" href="part0005_split_000.html#types" class="calibre5">Chapter 2</a>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="calibre17">&gt;&gt;&gt;</code> <code class="n">a</code><code class="calibre17">:</code> <code class="nb">int</code> <code class="calibre17">=</code> <code class="mi">5</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="n">a</code> <code class="calibre17">=</code> <code class="s">"string"</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="n">a</code>
<code class="s">"string"</code></pre>

<p class="author1">Herein lies the challenge: how do type annotations make your codebase robust, when you can’t trust that developers will follow their guidance? In order to be robust, you want your code to stand the test of time. To do that, you need some sort of tool that can check all your type annotations and flag if anything is amiss. That tool is called a typechecker.<a data-type="indexterm" data-primary="typecheckers" id="idm45644756169848" class="calibre5"/></p>

<p class="author1">Typecheckers are what allow the type annotations to transcend from communication method to a safety net. It is a form of static analysis. <em class="calibre6">Static analysis tools</em> are tools that run on your source code, and don’t impact your runtime at all.<a data-type="indexterm" data-primary="static analysis" id="idm45644756141368" class="calibre5"/> You’ll learn more about static analysis tools in <a data-type="xref" href="part0026_split_000.html#static_analysis" class="calibre5">Chapter 20</a>, but for now, I will just explain typecheckers.</p>

<p class="author1">First, I need to install one.<a data-type="indexterm" data-primary="mypy typechecker" id="idm45644756139320" class="calibre5"/> I’ll use mypy, a very popular typechecker.</p>

<p class="author1"><code class="calibre17">pip install mypy</code></p>

<p class="author1">Now I’ll create a file named <em class="calibre6">invalid_type.py</em> with incorrect behavior:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">a</code><code class="calibre17">:</code> <code class="nb">int</code> <code class="calibre17">=</code> <code class="mi">5</code>
<code class="n">a</code> <code class="calibre17">=</code> <code class="s">"string"</code></pre>

<p class="author1">If I run <code class="calibre17">mypy</code> on the command line against that file, I will get an error:</p>

<pre data-type="programlisting" class="calibre35">mypy invalid_type.py

chapter3/invalid_type.py:2: error: Incompatible types in assignment
                            (expression has type "str", variable has type
                             "int")
Found 1 error in 1 file (checked 1 source file)</pre>

<p class="author1">And just like that, my type annotations become a first line of defense against errors. Anytime you make a mistake and go against the author’s intent, a type  checker will find out and alert you. In fact, in most development environments, it’s possible to get this analysis in real time, notifying you of errors as you type. (Without reading your mind, this is about as early as a tool can catch errors, which is pretty great.)</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Type Annotations" class="preface">
<div class="preface" id="annotations">
<section data-type="sect1" data-pdf-bookmark="Benefits of Type Annotations" class="preface">
<div class="preface" id="idm45644756799368">
<section data-type="sect2" data-pdf-bookmark="Exercise: Spot the Bug" class="preface"><div class="preface" id="idm45644756181688">
<h2 class="calibre34" id="calibre_pb_5">Exercise: Spot the Bug</h2>

<p class="author1">Here are some more examples of mypy catching errors in my code.<a data-type="indexterm" data-primary="typecheckers" data-secondary="spot the bug exercise" id="idm45644756125784" class="calibre5"/><a data-type="indexterm" data-primary="mypy typechecker" data-secondary="spot the bug exercise" id="idm45644756098456" class="calibre5"/> I want you to look for the error in each code snippet and time how long it takes you to find the bug or give up, and then check the output listed below the snippet to see if you got it right.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">read_file_and_reverse_it</code><code class="calibre17">(</code><code class="n">filename</code><code class="calibre17">:</code> <code class="nb">str</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">str</code><code class="calibre17">:</code>
    <code class="k">with</code> <code class="nb">open</code><code class="calibre17">(</code><code class="n">filename</code><code class="calibre17">)</code> <code class="k">as</code> <code class="n">f</code><code class="calibre17">:</code>
        <code class="c"># Convert bytes back into str</code>
        <code class="k">return</code> <code class="n">f</code><code class="calibre17">.</code><code class="n">read</code><code class="calibre17">()</code><code class="calibre17">.</code><code class="n">encode</code><code class="calibre17">(</code><code class="s">"utf-8"</code><code class="calibre17">)[::</code><code class="calibre17">-</code><code class="mi">1</code><code class="calibre17">]</code></pre>

<p class="author1">Here’s the mypy output showing the error:</p>

<pre data-type="programlisting" class="calibre35">mypy chapter3/invalid_example1.py
chapter3/invalid_example1.py:3: error: Incompatible return value type
                                       (got "bytes", expected "str")
Found 1 error in 1 file (checked 1 source file)</pre>

<p class="author1">Whoops, I’m returning <code class="calibre17">bytes</code>, not a <code class="calibre17">str</code>. I made a call to encode instead of decode, and got my return type all mixed up. I can’t even tell you how many times I made this mistake moving Python 2.7 code to Python 3. Thank goodness for typecheckers.</p>

<p class="author1">Here’s another example:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="c"># takes a list and adds the doubled values</code>
<code class="c"># to the end</code>
<code class="c"># [1,2,3] =&gt; [1,2,3,2,4,6]</code>
<code class="k">def</code> <code class="nf">add_doubled_values</code><code class="calibre17">(</code><code class="n">my_list</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="nb">int</code><code class="calibre17">]):</code>
    <code class="n">my_list</code><code class="calibre17">.</code><code class="n">update</code><code class="calibre17">([</code><code class="n">x</code><code class="calibre17">*</code><code class="mi">2</code> <code class="k">for</code> <code class="n">x</code> <code class="calibre19">in</code> <code class="n">my_list</code><code class="calibre17">])</code>

<code class="n">add_doubled_values</code><code class="calibre17">([</code><code class="mi">1</code><code class="calibre17">,</code><code class="mi">2</code><code class="calibre17">,</code><code class="mi">3</code><code class="calibre17">])</code></pre>

<p class="author1">The mypy error is as follows:</p>

<pre data-type="programlisting" class="calibre35">mypy chapter3/invalid_example2.py
chapter3/invalid_example2.py:6: error: "list[int]" has no attribute "update"
Found 1 error in 1 file (checked 1 source file)</pre>

<p class="author1">Another innocent mistake I made by calling <code class="calibre17">update</code> on a list instead of <code class="calibre17">extend</code>. These sorts of mistakes can happen quite easily when moving between collection types (in this case from a <code class="calibre17">set</code>, which does offer an <code class="calibre17">update</code> method, to a <code class="calibre17">list</code>, which doesn’t).</p>

<p class="author1">One more example to wrap it up:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="c"># The restaurant is named differently</code>
<code class="c"># in different parts of the world</code>
<code class="k">def</code> <code class="nf">get_restaurant_name</code><code class="calibre17">(</code><code class="n">city</code><code class="calibre17">:</code> <code class="nb">str</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">str</code><code class="calibre17">:</code>
    <code class="k">if</code> <code class="n">city</code> <code class="calibre19">in</code> <code class="n">ITALY_CITIES</code><code class="calibre17">:</code>
            <code class="k">return</code> <code class="s">"Trattoria Viafore"</code>
    <code class="k">if</code> <code class="n">city</code> <code class="calibre19">in</code> <code class="n">GERMANY_CITIES</code><code class="calibre17">:</code>
            <code class="k">return</code> <code class="s">"Pat's Kantine"</code>
    <code class="k">if</code> <code class="n">city</code> <code class="calibre19">in</code> <code class="n">US_CITIES</code><code class="calibre17">:</code>
            <code class="k">return</code> <code class="s">"Pat's Place"</code>
    <code class="k">return</code> <code class="nb">None</code>


<code class="k">if</code> <code class="n">get_restaurant_name</code><code class="calibre17">(</code><code class="s">'Boston'</code><code class="calibre17">):</code>
    <code class="k">print</code><code class="calibre17">(</code><code class="s">"Location Found"</code><code class="calibre17">)</code></pre>

<p class="author1">The mypy error is as follows:</p>

<pre data-type="programlisting" class="calibre35">chapter3/invalid_example3.py:14: error: Incompatible return value type
                                        (got "None", expected "str")
Found 1 error in 1 file (checked 1 source file)</pre>

<p class="author1">This one is subtle. I’m returning <code class="calibre17">None</code> when a string value is expected. If all the code is just checking conditionally for the restaurant name to make decisions, like I do above, tests will pass, and nothing will be amiss. This is true even for the negative case, because <code class="calibre17">None</code> is absolutely fine to check for in <code class="calibre17">if</code> statements (it is false-y). This is an example of Python’s dynamic typing coming back to bite us.</p>

<p class="author1">However, a few months from now, some developer will start trying to use this return value as a string, and as soon as a new city needs to be added, the code starts trying to operate on <code class="calibre17">None</code> values, which causes exceptions to be raised. This is not very robust; there is a latent code bug just waiting to happen. But with typecheckers, you can stop worrying about this and catch these mistakes early.</p>
<div data-type="warning" epub:type="warning" class="calibre23"><h6 class="calibre24">Warning</h6>
<p class="author1">With typecheckers<a data-type="indexterm" data-primary="errors" data-secondary="typechecking and" id="idm45644755896088" class="calibre5"/><a data-type="indexterm" data-primary="typechecking" data-secondary="testing and" id="idm45644755895080" class="calibre5"/> available, do you even need tests? You certainly do. Typecheckers catch a specific class of errors: those of incompatible types. There are plenty of other classes of errors that you still need to test for. Treat typecheckers as just one tool in your arsenal of bug identification.</p>
</div>

<p class="author1">In all of these examples, typecheckers found a bug just waiting to happen. It doesn’t matter if the bug would have been caught by tests, or by code review, or by customers; typecheckers catch it earlier, which saves time and money. Typecheckers start giving us the benefit of a statically typed language, while still allowing the Python runtime to remain dynamically typed. This truly is the best of both worlds.</p>

<p class="author1">At the beginning of the chapter, you’ll find a quote from Guido van Rossum. While working at Dropbox, he found that large codebases struggled without having a safety net.  He became a huge proponent for driving type hinting into the language. If you want your code to communicate intent and catch errors, start adopting type annotations and typechecking today.</p>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Type Annotations" class="preface">
<div class="preface" id="annotations">
<section data-type="sect1" data-pdf-bookmark="Benefits of Type Annotations" class="preface">
<div class="preface" id="idm45644756799368">
<section data-type="sect2" data-pdf-bookmark="Exercise: Spot the Bug" class="preface">
<div class="preface" id="idm45644756181688">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_6">Discussion Topic</h1>
<p class="author1">Has your codebase had an error slip through that could have been caught by typecheckers? How much do those errors cost you? How many times has it been a code review or an integration test that caught the bug? How about bugs that made it to production?</p>
</div>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Type Annotations" class="preface">
<div class="preface" id="annotations">
<section data-type="sect1" data-pdf-bookmark="When to Use Type Annotations" class="preface"><div class="preface" id="idm45644756126888">
<h1 class="calibre12" id="calibre_pb_7">When to Use Type Annotations</h1>

<p class="author1">Now, before you go adding types to <a data-type="indexterm" data-primary="type annotations" data-secondary="benefits of" data-startref="ix_typanben" id="idm45644755889112" class="calibre5"/>everything, I need to talk about the cost. Adding types is simple, but can be overdone. <a data-type="indexterm" data-primary="type annotations" data-secondary="when to use" id="idm45644755887624" class="calibre5"/>As users try to test and play around with code, they may start fighting the typechecker because they feel bogged down when writing all the type annotations. There is an adoption cost for users who are just getting started with type hinting. I also mentioned that I don’t type annotate everything. I won’t annotate all my variables, especially if the type is obvious. I also won’t typically type annotate parameters for every small private method in a class.</p>

<p class="author1">When should you use typecheckers?</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">With functions<a data-type="indexterm" data-primary="typecheckers" data-secondary="when to use" id="idm45644755884584" class="calibre5"/> that you expect other modules or users to call (e.g., public APIs, library entry points, etc.)</p>
</li>
<li class="calibre9">
<p class="author1">When you want to highlight where a type is complicated (e.g., a dictionary of strings mapped to lists of objects) or unintuitive</p>
</li>
<li class="calibre9">
<p class="author1">Areas where mypy complains that you need a type (typically when assigning to an empty collection—it’s easier to go along with the tool than against it)</p>
</li>
</ul>

<p class="author1">A typechecker will infer types for any value that it can, so even if you don’t fill in all types, you still reap the benefits. I will cover configuring typecheckers in <a data-type="xref" href="part0009_split_000.html#typechecker" class="calibre5">Chapter 6</a>.</p>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Type Annotations" class="preface">
<div class="preface" id="annotations">
<section data-type="sect1" data-pdf-bookmark="Closing Thoughts" class="preface"><div class="preface" id="idm45644756126488">
<h1 class="calibre12" id="calibre_pb_8">Closing Thoughts</h1>

<p class="author1">There was consternation in the Python community when type hinting was introduced.<a data-type="indexterm" data-primary="type hints" id="idm45644755878088" class="calibre5"/> Developers were afraid that Python was becoming a statically typed language like Java or C++. They worried that adding types everywhere would slow them down and destroy the benefits of the dynamically typed language they fell in love with.</p>

<p class="author1">However, type hints are just that: hints. They are completely optional. I don’t recommend them for small scripts, or any piece of code that isn’t going to live a very long time. But if your code needs to be maintainable for the long term, type hints are invaluable. They serve as a communication method, make your environment smarter, and detect errors when combined with typecheckers. They protect the original author’s intent. When annotating types, you decrease the burden a reader has in understanding your code. You reduce the need to read the implementation of a function to know what its doing. Code is complicated, and you should be minimizing how much code a developer needs to read. By using well-thought-out types, you reduce surprise and increase reading comprehension.</p>

<p class="author1">The typechecker is also a confidence builder. Remember, in order for your code to be robust, it has to be easy to change, rewrite, and delete if needed. The typechecker can allow developers to do that with less trepidation.<a data-type="indexterm" data-primary="robustness" data-secondary="typechecking and" id="idm45644755875160" class="calibre5"/> If something was relying on a type or field that got changed or deleted, the typechecker will flag the offending code as incompatible. Automated tooling makes you and your future collaborators’ jobs simpler; fewer bugs will make it to production and features will get delivered quicker.</p>

<p class="author1">In the next chapter, you’re going to go beyond basic type annotations and learn how to build a vocabulary of all new types. These types will help you constrain behavior in your codebase, limiting the ways things can go wrong. I’ve only scratched the surface of how useful type annotations can be.<a data-type="indexterm" data-primary="type annotations" data-startref="ix_typan" id="idm45644755873048" class="calibre5"/></p>
</div></section>







<div data-type="footnotes" class="calibre25"><p data-type="footnote" id="idm45644756802936" class="calibre26"><sup class="calibre27"><a href="part0006_split_000.html#idm45644756802936-marker" class="calibre5">1</a></sup> Guido van Rossum. “A Language Creators’ Conversation.” PuPPy (Puget Sound Programming Python) Annual Benefit 2019. <a href="https://oreil.ly/1xf01" class="calibre5"><em class="calibre6">https://oreil.ly/1xf01</em></a>.</p></div></div></section></body></html>