- en: 6\. Return Values#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkPython/chap06.html](https://allendowney.github.io/ThinkPython/chap06.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In previous chapters, we’ve used built-in functions – like `abs` and `round`
    – and functions in the math module – like `sqrt` and `pow`. When you call one
    of these functions, it returns a value you can assign to a variable or use as
    part of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: The functions we have written so far are different. Some use the `print` function
    to display values, and some use turtle functions to draw figures. But they don’t
    return values we assign to variables or use in expressions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll see how to write functions that return values.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1\. Some functions have return values[#](#some-functions-have-return-values
    "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you call a function like `math.sqrt`, the result is called a **return value**.
    If the function call appears at the end of a cell, Jupyter displays the return
    value immediately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you assign the return value to a variable, it doesn’t get displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: But you can display it later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Or you can use the return value as part of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here’s an example of a function that returns a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`circle_area` takes `radius` as a parameter and computes the area of a circle
    with that radius.'
  prefs: []
  type: TYPE_NORMAL
- en: The last line is a `return` statement that returns the value of `area`.
  prefs: []
  type: TYPE_NORMAL
- en: If we call the function like this, Jupyter displays the return value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can assign the return value to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Or use it as part of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Later we can display the value of the variable we assigned the result to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: But we can’t access `area`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`area` is a local variable in a function, so we can’t access it from outside
    the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.2\. And some have None[#](#and-some-have-none "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a function doesn’t have a `return` statement, it returns `None`, which is
    a special value like `True` and `False`. For example, here’s the `repeat` function
    from Chapter 3.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If we call it like this, it displays the first line of the Monty Python song
    “Finland”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This function uses the `print` function to display a string, but it does not
    use a `return` statement to return a value. If we assign the result to a variable,
    it displays the string anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: And if we display the value of the variable, we get nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`result` actually has a value, but Jupyter doesn’t show it. However, we can
    display it like this.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The return value from `repeat` is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Now here’s a function similar to `repeat` except that has a return value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we can use an expression in a `return` statement, not just a variable.
  prefs: []
  type: TYPE_NORMAL
- en: With this version, we can assign the result to a variable. When the function
    runs, it doesn’t display anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: But later we can display the value assigned to `line`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A function like this is called a **pure function** because it doesn’t display
    anything or have any other effect – other than returning a value.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3\. Return values and conditionals[#](#return-values-and-conditionals "Link
    to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If Python did not provide `abs`, we could write it like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If `x` is negative, the first `return` statement returns `-x` and the function
    ends immediately. Otherwise, the second `return` statement returns `x` and the
    function ends. So this function is correct.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you put `return` statements in a conditional, you have to make sure
    that every possible path through the program hits a `return` statement. For example,
    here’s an incorrect version of `absolute_value`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what happens if we call this function with `0` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We get nothing! Here’s the problem: when `x` is `0`, neither condition is true,
    and the function ends without hitting a `return` statement, which means that the
    return value is `None`, so Jupyter displays nothing.'
  prefs: []
  type: TYPE_NORMAL
- en: As another example, here’s a version of `absolute_value` with an extra `return`
    statement at the end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If `x` is negative, the first `return` statement runs and the function ends.
    Otherwise the second `return` statement runs and the function ends. Either way,
    we never get to the third `return` statement – so it can never run.
  prefs: []
  type: TYPE_NORMAL
- en: Code that can never run is called **dead code**. In general, dead code doesn’t
    do any harm, but it often indicates a misunderstanding, and it might be confusing
    to someone trying to understand the program.
  prefs: []
  type: TYPE_NORMAL
- en: '## 6.4\. Incremental development[#](#incremental-development "Link to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: As you write larger functions, you might find yourself spending more time debugging.
    To deal with increasingly complex programs, you might want to try **incremental
    development**, which is a way of adding and testing only a small amount of code
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, suppose you want to find the distance between two points represented
    by the coordinates \((x_1, y_1)\) and \((x_2, y_2)\). By the Pythagorean theorem,
    the distance is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathrm{distance} = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\]
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to consider what a `distance` function should look like in
    Python – that is, what are the inputs (parameters) and what is the output (return
    value)?
  prefs: []
  type: TYPE_NORMAL
- en: 'For this function, the inputs are the coordinates of the points. The return
    value is the distance. Immediately you can write an outline of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This version doesn’t compute distances yet – it always returns zero. But it
    is a complete function with a return value, which means that you can test it before
    you make it more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the new function, we’ll call it with sample arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: I chose these values so that the horizontal distance is `3` and the vertical
    distance is `4`. That way, the result is `5`, the hypotenuse of a `3-4-5` right
    triangle. When testing a function, it is useful to know the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: At this point we have confirmed that the function runs and returns a value,
    and we can start adding code to the body. A good next step is to find the differences
    `x2 - x1` and `y2 - y1`. Here’s a version that stores those values in temporary
    variables and displays them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If the function is working, it should display `dx is 3` and `dy is 4`. If so,
    we know that the function is getting the right arguments and performing the first
    computation correctly. If not, there are only a few lines to check.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Good so far. Next we compute the sum of squares of `dx` and `dy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Again, we can run the function and check the output, which should be `25`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use `math.sqrt` to compute the distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: And test it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The result is correct, but this version of the function displays the result
    rather than returning it, so the return value is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: We can fix that by replacing the `print` function with a `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This version of `distance` is a pure function. If we call it like this, only
    the result is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: And if we assign the result to a variable, nothing is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `print` statements we wrote are useful for debugging, but once the function
    is working, we can remove them. Code like that is called **scaffolding** because
    it is helpful for building the program but is not part of the final product.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example demonstrates incremental development. The key aspects of this
    process are:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a working program, make small changes, and test after every change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use variables to hold intermediate values so you can display and check them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the program is working, remove the scaffolding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At any point, if there is an error, you should have a good idea where it is.
    Incremental development can save you a lot of debugging time.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5\. Boolean functions[#](#boolean-functions "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions can return the boolean values `True` and `False`, which is often convenient
    for encapsulating a complex test in a function. For example, `is_divisible` checks
    whether `x` is divisible by `y` with no remainder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here’s how we use it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Inside the function, the result of the `==` operator is a boolean, so we can
    write the function more concisely by returning it directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Boolean functions are often used in conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'It might be tempting to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: But the comparison is unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6\. Recursion with return values[#](#recursion-with-return-values "Link to
    this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we can write functions with return values, we can write recursive functions
    with return values, and with that capability, we have passed an important threshold
    – the subset of Python we have is now **Turing complete**, which means that we
    can perform any computation that can be described by an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate recursion with return values, we’ll evaluate a few recursively
    defined mathematical functions. A recursive definition is similar to a circular
    definition, in the sense that the definition refers to the thing being defined.
    A truly circular definition is not very useful:'
  prefs: []
  type: TYPE_NORMAL
- en: 'vorpal: An adjective used to describe something that is vorpal.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you saw that definition in the dictionary, you might be annoyed. On the
    other hand, if you looked up the definition of the factorial function, denoted
    with the symbol \(!\), you might get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\begin{aligned} 0! &= 1 \\ n! &= n~(n-1)! \end{aligned}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: This definition says that the factorial of \(0\) is \(1\), and the factorial
    of any other value, \(n\), is \(n\) multiplied by the factorial of \(n-1\).
  prefs: []
  type: TYPE_NORMAL
- en: If you can write a recursive definition of something, you can write a Python
    program to evaluate it. Following an incremental development process, we’ll start
    with a function that take `n` as a parameter and always returns `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s add the first part of the definition – if the argument happens to
    be `0`, all we have to do is return `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s fill in the second part – if `n` is not `0`, we have to make a recursive
    call to find the factorial of `n-1` and then multiply the result by `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The flow of execution for this program is similar to the flow of `countdown`
    in Chapter 5. If we call `factorial` with the value `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: Since `3` is not `0`, we take the second branch and calculate the factorial
    of `n-1`.…
  prefs: []
  type: TYPE_NORMAL
- en: Since `2` is not `0`, we take the second branch and calculate the factorial
    of `n-1`.…
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since `1` is not `0`, we take the second branch and calculate the factorial
    of `n-1`.…
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since `0` equals `0`, we take the first branch and return `1` without making
    any more recursive calls.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The return value, `1`, is multiplied by `n`, which is `1`, and the result is
    returned.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The return value, `1`, is multiplied by `n`, which is `2`, and the result is
    returned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The return value `2` is multiplied by `n`, which is `3`, and the result, `6`,
    becomes the return value of the function call that started the whole process.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows the stack diagram for this sequence of function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/726efd741b2b10a7e5f8789b876a18d14f2818ebbdfc92ab4c41430c6422fcfc.png](../Images/b37eb9da251407831430919397bc7f9a.png)'
  prefs: []
  type: TYPE_IMG
- en: The return values are shown being passed back up the stack. In each frame, the
    return value is the product of `n` and `recurse`.
  prefs: []
  type: TYPE_NORMAL
- en: In the last frame, the local variable `recurse` does not exist because the branch
    that creates it does not run.
  prefs: []
  type: TYPE_NORMAL
- en: 6.7\. Leap of faith[#](#leap-of-faith "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following the flow of execution is one way to read programs, but it can quickly
    become overwhelming. An alternative is what I call the “leap of faith”. When you
    come to a function call, instead of following the flow of execution, you *assume*
    that the function works correctly and returns the right result.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, you are already practicing this leap of faith when you use built-in
    functions. When you call `abs` or `math.sqrt`, you don’t examine the bodies of
    those functions – you just assume that they work.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true when you call one of your own functions. For example, earlier
    we wrote a function called `is_divisible` that determines whether one number is
    divisible by another. Once we convince ourselves that this function is correct,
    we can use it without looking at the body again.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true of recursive programs. When you get to the recursive call,
    instead of following the flow of execution, you should assume that the recursive
    call works and then ask yourself, “Assuming that I can compute the factorial of
    \(n-1\), can I compute the factorial of \(n\)?” The recursive definition of factorial
    implies that you can, by multiplying by \(n\).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it’s a bit strange to assume that the function works correctly when
    you haven’t finished writing it, but that’s why it’s called a leap of faith!
  prefs: []
  type: TYPE_NORMAL
- en: '## 6.8\. Fibonacci[#](#fibonacci "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'After `factorial`, the most common example of a recursive function is `fibonacci`,
    which has the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\begin{aligned} \mathrm{fibonacci}(0) &= 0 \\ \mathrm{fibonacci}(1)
    &= 1 \\ \mathrm{fibonacci}(n) &= \mathrm{fibonacci}(n-1) + \mathrm{fibonacci}(n-2)
    \end{aligned}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Translated into Python, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If you try to follow the flow of execution here, even for small values of \(n\),
    your head explodes. But according to the leap of faith, if you assume that the
    two recursive calls work correctly, you can be confident that the last `return`
    statement is correct.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, this way of computing Fibonacci numbers is very inefficient. In
    [Chapter 10](chap10.html#section-memos) I’ll explain why and suggest a way to
    improve it.
  prefs: []
  type: TYPE_NORMAL
- en: 6.9\. Checking types[#](#checking-types "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What happens if we call `factorial` and give it `1.5` as an argument?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: It looks like an infinite recursion. How can that be? The function has base
    cases when `n == 1` or `n == 0`. But if `n` is not an integer, we can *miss* the
    base case and recurse forever.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the initial value of `n` is `1.5`. In the first recursive call,
    the value of `n` is `0.5`. In the next, it is `-0.5`. From there, it gets smaller
    (more negative), but it will never be `0`.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid infinite recursion we can use the built-in function `isinstance` to
    check the type of the argument. Here’s how we check whether a value is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now here’s a version of `factorial` with error-checking.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: First it checks whether `n` is an integer. If not, it displays an error message
    and returns `None`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Then it checks whether `n` is negative. If so, it displays an error message
    and returns `None.`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: If we get past both checks, we know that `n` is a non-negative integer, so we
    can be confident the recursion will terminate. Checking the parameters of a function
    to make sure they have the correct types and values is called **input validation**.
  prefs: []
  type: TYPE_NORMAL
- en: '## 6.10\. Debugging[#](#debugging "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Breaking a large program into smaller functions creates natural checkpoints
    for debugging. If a function is not working, there are three possibilities to
    consider:'
  prefs: []
  type: TYPE_NORMAL
- en: There is something wrong with the arguments the function is getting – that is,
    a precondition is violated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is something wrong with the function – that is, a postcondition is violated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caller is doing something wrong with the return value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To rule out the first possibility, you can add a `print` statement at the beginning
    of the function that displays the values of the parameters (and maybe their types).
    Or you can write code that checks the preconditions explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: If the parameters look good, you can add a `print` statement before each `return`
    statement and display the return value. If possible, call the function with arguments
    that make it easy check the result.
  prefs: []
  type: TYPE_NORMAL
- en: If the function seems to be working, look at the function call to make sure
    the return value is being used correctly – or used at all!
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding `print` statements at the beginning and end of a function can help make
    the flow of execution more visible. For example, here is a version of `factorial`
    with print statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '`space` is a string of space characters that controls the indentation of the
    output. Here is the result of `factorial(3)` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: If you are confused about the flow of execution, this kind of output can be
    helpful. It takes some time to develop effective scaffolding, but a little bit
    of scaffolding can save a lot of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 6.11\. Glossary[#](#glossary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**return value:** The result of a function. If a function call is used as an
    expression, the return value is the value of the expression.'
  prefs: []
  type: TYPE_NORMAL
- en: '**pure function:** A function that does not display anything or have any other
    effect, other than returning a return value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**dead code:** Part of a program that can never run, often because it appears
    after a `return` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '**incremental development:** A program development plan intended to avoid debugging
    by adding and testing only a small amount of code at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**scaffolding:** Code that is used during program development but is not part
    of the final version.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Turing complete:** A language, or subset of a language, is Turing complete
    if it can perform any computation that can be described by an algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '**input validation:** Checking the parameters of a function to make sure they
    have the correct types and values'
  prefs: []
  type: TYPE_NORMAL
- en: 6.12\. Exercises[#](#exercises "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 6.12.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we saw an incorrect function that can end without returning
    a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: And a version of the same function that has dead code at the end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: And we saw the following example, which is correct but not idiomatic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Ask a virtual assistant what’s wrong with each of these functions and see if
    it can spot the errors or improve the style.
  prefs: []
  type: TYPE_NORMAL
- en: Then ask “Write a function that takes coordinates of two points and computes
    the distance between them.” See if the result resembles the version of `distance`
    we wrote in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 6.12.2\. Exercise[#](#exercise "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use incremental development to write a function called `hypot` that returns
    the length of the hypotenuse of a right triangle given the lengths of the other
    two legs as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: There’s a function in the math module called `hypot` that does the same
    thing, but you should not use it for this exercise!'
  prefs: []
  type: TYPE_NORMAL
- en: Even if you can write the function correctly on the first try, start with a
    function that always returns `0` and practice making small changes, testing as
    you go. When you are done, the function should only return a value – it should
    not display anything.
  prefs: []
  type: TYPE_NORMAL
- en: 6.12.3\. Exercise[#](#id1 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a boolean function, `is_between(x, y, z)`, that returns `True` if \(x
    < y < z\) or if \(z < y < x\), and`False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 6.12.4\. Exercise[#](#id2 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Ackermann function, \(A(m, n)\), is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\begin{aligned} A(m, n) = \begin{cases} n+1 & \mbox{if } m =
    0 \\ A(m-1, 1) & \mbox{if } m > 0 \mbox{ and } n = 0 \\ A(m-1, A(m, n-1)) & \mbox{if
    } m > 0 \mbox{ and } n > 0. \end{cases} \end{aligned}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Write a function named `ackermann` that evaluates the Ackermann function. What
    happens if you call `ackermann(5, 5)`?
  prefs: []
  type: TYPE_NORMAL
- en: 6.12.5\. Exercise[#](#id3 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The greatest common divisor (GCD) of \(a\) and \(b\) is the largest number that
    divides both of them with no remainder.
  prefs: []
  type: TYPE_NORMAL
- en: One way to find the GCD of two numbers is based on the observation that if \(r\)
    is the remainder when \(a\) is divided by \(b\), then \(gcd(a, b) = gcd(b, r)\).
    As a base case, we can use \(gcd(a, 0) = a\).
  prefs: []
  type: TYPE_NORMAL
- en: Write a function called `gcd` that takes parameters `a` and `b` and returns
    their greatest common divisor.
  prefs: []
  type: TYPE_NORMAL
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
