<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Getting Started with Dask"><div class="chapter" id="ch2_getting_started_with_dask">
<h1><span class="label">Chapter 2. </span>Getting Started with Dask</h1>


<p>We are so happy that you’ve decided to explore whether Dask is the system for you by trying it out. In this chapter, we will focus on getting started with Dask in its local mode. Using this, we’ll explore a few more straightforward parallel computing tasks (including everyone’s favorite, word count).<sup><a data-type="noteref" id="id330-marker" href="ch02.xhtml#id330">1</a></sup></p>






<section data-type="sect1" data-pdf-bookmark="Installing Dask Locally"><div class="sect1" id="id8">
<h1>Installing Dask Locally</h1>

<p>Installing Dask locally is reasonably <a data-type="indexterm" data-primary="Dask installation" id="id331"/><a data-type="indexterm" data-primary="conda environment" data-secondary="Dask installation" id="cdvdkt"/>straightforward. If you want to begin running on multiple machines, doing so is often easier when you start with a conda environment (or virtualenv). This lets you figure out what packages you depend on by running <code>pip freeze</code> to make <a data-type="indexterm" data-primary="pip freeze" id="id332"/>sure they’re on all of the workers when it’s time to scale.</p>

<p>While you can just run <code>pip install -U dask</code>, we prefer using a conda environment since it’s easier to match the version of Python to that on a cluster, which allows us to connect a local machine to the cluster directly.<sup><a data-type="noteref" id="id333-marker" href="ch02.xhtml#id333">2</a></sup> If you don’t already have conda on your machine, <a href="https://oreil.ly/qVDa7">Miniforge</a> is a good and quick way to get conda installed across multiple platforms. The installation of Dask into a new conda environment is shown in <a data-type="xref" href="#install_conda_env_with_dask">Example 2-1</a>.</p>
<div id="install_conda_env_with_dask" data-type="example">
<h5><span class="label">Example 2-1. </span>Installing Dask into a new conda environment</h5>

<pre data-type="programlisting" data-code-language="bash">conda<code class="w"> </code>create<code class="w"> </code>-n<code class="w"> </code>dask<code class="w"> </code><code class="nv">python</code><code class="o">=</code><code class="m">3</code>.8.6<code class="w">  </code>mamba<code class="w"> </code>-y<code class="w"/>
conda<code class="w"> </code>activate<code class="w"> </code>dask<code class="w"/>
mamba<code class="w"> </code>install<code class="w"> </code>--yes<code class="w"> </code><code class="nv">python</code><code class="o">==</code><code class="m">3</code>.8.6<code class="w"> </code>cytoolz<code class="w"> </code><code class="nv">dask</code><code class="o">==</code><code class="m">2021</code>.7.0<code class="w"> </code>numpy<code class="w"> </code><code class="se">\</code>
<code class="w">      </code><code class="nv">pandas</code><code class="o">==</code><code class="m">1</code>.3.0<code class="w"> </code>beautifulsoup4<code class="w"> </code>requests<code class="w"/></pre></div>

<p>Here we install a specific version of Dask rather than just the latest version. If you’re planning to connect to a cluster later on, it will be useful to pick the same version of Dask as is installed on the cluster.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You don’t have to install Dask locally. There is a <a href="https://oreil.ly/EK5n5">BinderHub example with Dask</a> and distributed options, including <a href="https://oreil.ly/3UEq-">one from the creators of Dask</a>, that you can use to run Dask, as well as other providers such as <a href="https://oreil.ly/_6SyV">SaturnCloud</a>. That being said, we recommend having Dask installed locally even if <a data-type="indexterm" data-primary="conda environment" data-secondary="Dask installation" data-startref="cdvdkt" id="id334"/>you end up using one of these services.</p>
</div>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id335">
<h1>Using Dask Docker Images</h1>
<p>Another way to get Dask running locally is to use <a href="https://oreil.ly/zCeHQ">example Docker images</a> maintained <a data-type="indexterm" data-primary="Docker images" id="id336"/><a data-type="indexterm" data-primary="images, Docker" id="id337"/>by the Dask project. The benefit of this approach is that the same image can then be used in a distributed cluster, each node running the same Docker image locally, thus ensuring the compatibility of all the packages. 
<span class="keep-together">Advanced users can use</span> the Dask example Docker images as <a data-type="indexterm" data-primary="Dask installation" data-startref="dksllcl" id="id338"/>a base and add 
<span class="keep-together">packages of their</span> choice before <a href="https://oreil.ly/S1ms1">committing changes and saving it as a new image</a>.</p>
</div></aside>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Hello Worlds"><div class="sect1" id="hello_worlds">
<h1>Hello Worlds</h1>

<p>Now that you have Dask installed <a data-type="indexterm" data-primary="Hello Worlds" id="id339"/>locally, it’s time to try the versions of “Hello World” available through its various APIs. There are many different options for starting Dask. For now, you should use LocalCluster, as shown in <a data-type="xref" href="#make_dask_client">Example 2-2</a>.</p>
<div id="make_dask_client" data-type="example" class="pagebreak-after">
<h5><span class="label">Example 2-2. </span>Using LocalCluster to start Dask</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">dask</code>
<code class="kn">from</code> <code class="nn">dask.distributed</code> <code class="kn">import</code> <code class="n">Client</code>
<code class="n">client</code> <code class="o">=</code> <code class="n">Client</code><code class="p">()</code> <code class="c1"># Here we could specify a cluster, defaults to local mode</code></pre></div>








<section data-type="sect2" class="less_space" data-pdf-bookmark="Task Hello World"><div class="sect2" id="id10">
<h2>Task Hello World</h2>

<p>One of the core building blocks <a data-type="indexterm" data-primary="Hello Worlds" data-secondary="task" id="id340"/><a data-type="indexterm" data-primary="task Hello World" id="id341"/><a data-type="indexterm" data-primary="delayed function" id="id342"/><a data-type="indexterm" data-primary="functions" data-secondary="delayed" id="id343"/>of Dask is <code>dask.delayed</code>, which allows you to run functions in parallel.
If you are running Dask on multiple machines, these functions can also be distributed (or spread out) on the different machines.
When you wrap a function with <code>dask.delayed</code> and call it, you get back a “delayed” object representing the desired computation.
When you created a delayed object, Dask is just making a note of what you might want it to do. As with a lazy teenager, you need to be explicit. You can force Dask to start computing the value with <code>dask.submit</code>, which produces a “future.”
You can use <code>dask.compute</code> both to start computing the delayed objects and futures and to return their values.<sup><a data-type="noteref" id="id344-marker" href="ch02.xhtml#id344">3</a></sup></p>










<section data-type="sect3" data-pdf-bookmark="Sleepy task"><div class="sect3" id="sleepy_task">
<h3>Sleepy task</h3>

<p>An easy way to see the <a data-type="indexterm" data-primary="Hello Worlds" data-secondary="task" data-tertiary="sleepy task" id="id345"/><a data-type="indexterm" data-primary="task Hello World" data-secondary="sleepy task" id="id346"/><a data-type="indexterm" data-primary="sleepy task, Hello World" id="id347"/><a data-type="indexterm" data-primary="slow_task function" id="id348"/><a data-type="indexterm" data-primary="functions" data-secondary="slow_task" id="id349"/>performance difference is by writing an intentionally slow function, like <code>slow_task</code>, which calls <code>sleep</code>. Then you can compare the performance of Dask to “regular” Python by mapping the function over a few elements with and without <code>dask.delayed</code>, as shown in <a data-type="xref" href="#sleepy_task_ch02_1688747609671">Example 2-3</a>.</p>
<div id="sleepy_task_ch02_1688747609671" data-type="example" class="pagebreak-after">
<h5><span class="label">Example 2-3. </span>Sleepy task</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">timeit</code>


<code class="k">def</code> <code class="nf">slow_task</code><code class="p">(</code><code class="n">x</code><code class="p">):</code>
    <code class="kn">import</code> <code class="nn">time</code>
    <code class="n">time</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code> <code class="c1"># Do something sciency/business</code>
    <code class="k">return</code> <code class="n">x</code>


<code class="n">things</code> <code class="o">=</code> <code class="nb">range</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>

<code class="n">very_slow_result</code> <code class="o">=</code> <code class="nb">map</code><code class="p">(</code><code class="n">slow_task</code><code class="p">,</code> <code class="n">things</code><code class="p">)</code>
<code class="n">slowish_result</code> <code class="o">=</code> <code class="nb">map</code><code class="p">(</code><code class="n">dask</code><code class="o">.</code><code class="n">delayed</code><code class="p">(</code><code class="n">slow_task</code><code class="p">),</code> <code class="n">things</code><code class="p">)</code>

<code class="n">slow_time</code> <code class="o">=</code> <code class="n">timeit</code><code class="o">.</code><code class="n">timeit</code><code class="p">(</code><code class="k">lambda</code><code class="p">:</code> <code class="nb">list</code><code class="p">(</code><code class="n">very_slow_result</code><code class="p">),</code> <code class="n">number</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>
<code class="n">fast_time</code> <code class="o">=</code> <code class="n">timeit</code><code class="o">.</code><code class="n">timeit</code><code class="p">(</code>
    <code class="k">lambda</code><code class="p">:</code> <code class="nb">list</code><code class="p">(</code>
        <code class="n">dask</code><code class="o">.</code><code class="n">compute</code><code class="p">(</code>
            <code class="o">*</code><code class="n">slowish_result</code><code class="p">)),</code>
    <code class="n">number</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>
<code class="nb">print</code><code class="p">(</code><code class="s2">"In sequence </code><code class="si">{}</code><code class="s2">, in parallel </code><code class="si">{}</code><code class="s2">"</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="n">slow_time</code><code class="p">,</code> <code class="n">fast_time</code><code class="p">))</code></pre></div>

<p>When we run this example, we get <code>In sequence 20.01662155520171, in parallel 6.259156636893749</code>, which shows that Dask can run some of the tasks in parallel, but not all of them.<sup><a data-type="noteref" id="id350-marker" href="ch02.xhtml#id350">4</a></sup></p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Nested tasks"><div class="sect3" id="nested_tasks">
<h3>Nested tasks</h3>

<p>One of the neat things about <code>dask.delayed</code> is that you <a data-type="indexterm" data-primary="Hello Worlds" data-secondary="task" data-tertiary="nested tasks" id="hwtksk"/><a data-type="indexterm" data-primary="task Hello World" data-secondary="nested tasks" id="tkwdsks"/><a data-type="indexterm" data-primary="nested tasks, Hello World" id="nskshw"/>can launch tasks inside of other tasks.<sup><a data-type="noteref" id="id351-marker" href="ch02.xhtml#id351">5</a></sup> A straightforward real-world example of this is a web crawler, with which, when you visit a web page, you want to fetch all of the links from that page, as shown in <a data-type="xref" href="#web_crawler_ch02_1688747981454">Example 2-4</a>.</p>
<div id="web_crawler_ch02_1688747981454" data-type="example">
<h5><span class="label">Example 2-4. </span>Web crawler</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@dask</code><code class="o">.</code><code class="n">delayed</code>
<code class="k">def</code> <code class="nf">crawl</code><code class="p">(</code><code class="n">url</code><code class="p">,</code> <code class="n">depth</code><code class="o">=</code><code class="mi">0</code><code class="p">,</code> <code class="n">maxdepth</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code> <code class="n">maxlinks</code><code class="o">=</code><code class="mi">4</code><code class="p">):</code>
    <code class="n">links</code> <code class="o">=</code> <code class="p">[]</code>
    <code class="n">link_futures</code> <code class="o">=</code> <code class="p">[]</code>
    <code class="k">try</code><code class="p">:</code>
        <code class="kn">import</code> <code class="nn">requests</code>
        <code class="kn">from</code> <code class="nn">bs4</code> <code class="kn">import</code> <code class="n">BeautifulSoup</code>
        <code class="n">f</code> <code class="o">=</code> <code class="n">requests</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="n">url</code><code class="p">)</code>
        <code class="n">links</code> <code class="o">+=</code> <code class="p">[(</code><code class="n">url</code><code class="p">,</code> <code class="n">f</code><code class="o">.</code><code class="n">text</code><code class="p">)]</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">depth</code> <code class="o">&gt;</code> <code class="n">maxdepth</code><code class="p">):</code>
            <code class="k">return</code> <code class="n">links</code> <code class="c1"># base case</code>
        <code class="n">soup</code> <code class="o">=</code> <code class="n">BeautifulSoup</code><code class="p">(</code><code class="n">f</code><code class="o">.</code><code class="n">text</code><code class="p">,</code> <code class="s1">'html.parser'</code><code class="p">)</code>
        <code class="n">c</code> <code class="o">=</code> <code class="mi">0</code>
        <code class="k">for</code> <code class="n">link</code> <code class="ow">in</code> <code class="n">soup</code><code class="o">.</code><code class="n">find_all</code><code class="p">(</code><code class="s1">'a'</code><code class="p">):</code>
            <code class="k">if</code> <code class="s2">"href"</code> <code class="ow">in</code> <code class="n">link</code><code class="p">:</code>
                <code class="n">c</code> <code class="o">=</code> <code class="n">c</code> <code class="o">+</code> <code class="mi">1</code>
                <code class="n">link_futures</code> <code class="o">+=</code> <code class="n">crawl</code><code class="p">(</code><code class="n">link</code><code class="p">[</code><code class="s2">"href"</code><code class="p">],</code>
                                      <code class="n">depth</code><code class="o">=</code><code class="p">(</code><code class="n">depth</code> <code class="o">+</code> <code class="mi">1</code><code class="p">),</code>
                                      <code class="n">maxdepth</code><code class="o">=</code><code class="n">maxdepth</code><code class="p">)</code>
                <code class="c1"># Don't branch too much; we're still in local mode and the web is</code>
                <code class="c1"># big</code>
                <code class="k">if</code> <code class="n">c</code> <code class="o">&gt;</code> <code class="n">maxlinks</code><code class="p">:</code>
                    <code class="k">break</code>
        <code class="k">for</code> <code class="n">r</code> <code class="ow">in</code> <code class="n">dask</code><code class="o">.</code><code class="n">compute</code><code class="p">(</code><code class="n">link_futures</code><code class="p">):</code>
            <code class="n">links</code> <code class="o">+=</code> <code class="n">r</code>
        <code class="k">return</code> <code class="n">links</code>
    <code class="k">except</code> <code class="n">requests</code><code class="o">.</code><code class="n">exceptions</code><code class="o">.</code><code class="n">InvalidSchema</code><code class="p">:</code>
        <code class="k">return</code> <code class="p">[]</code> <code class="c1"># Skip non-web links</code>


<code class="n">dask</code><code class="o">.</code><code class="n">compute</code><code class="p">(</code><code class="n">crawl</code><code class="p">(</code><code class="s2">"http://holdenkarau.com/"</code><code class="p">))</code></pre></div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In practice, some central co-ordination is still involved behind the scenes (including the scheduler), but the freedom to write your code in this nested way is quite powerful.</p>
</div>

<p>We cover other kinds of task <a data-type="indexterm" data-primary="Hello Worlds" data-secondary="task" data-tertiary="nested tasks" data-startref="hwtksk" id="id352"/><a data-type="indexterm" data-primary="task Hello World" data-secondary="nested tasks" data-startref="tkwdsks" id="id353"/><a data-type="indexterm" data-primary="nested tasks, Hello World" data-startref="nskshw" id="id354"/>dependencies in <a data-type="xref" href="ch03.xhtml#task_deps">“Task Dependencies”</a>.</p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Distributed Collections"><div class="sect2" id="id13">
<h2>Distributed Collections</h2>

<p>In addition to the low-level task APIs, Dask also has distributed collections. These collections enable you to work with data that would be too large to fit on a single machine and to naturally distribute work on it, which <a data-type="indexterm" data-primary="data parallelism" id="id355"/><a data-type="indexterm" data-primary="Hello Worlds" data-secondary="distributed collections" id="id356"/><a data-type="indexterm" data-primary="distributed collections" data-secondary="data parallelism" id="id357"/><a data-type="indexterm" data-primary="distributed collections" data-secondary="bag" id="id358"/><a data-type="indexterm" data-primary="data parallelism" data-secondary="arrays" id="id359"/>is called <em>data parallelism</em>. Dask has both an unordered collection called a <em>bag</em>, and an ordered collection called an <em>array</em>. Dask arrays aim to implement some of the ndarray interface, whereas bags focus more on functional programming (e.g., things like <code>map</code> and <code>filter</code>). You can load Dask collections from files, take local collections and distribute them, or take the results of <code>dask.delayed</code> tasks and turn them into a collection.</p>

<p>In distributed collections, Dask splits the data up using partitions. Partitions are used to decrease the scheduling cost compared to operating on individual rows, which is covered in more detail in <a data-type="xref" href="ch03.xhtml#basic_partitioning">“Partitioning/Chunking Collections”</a>.</p>










<section data-type="sect3" data-pdf-bookmark="Dask arrays"><div class="sect3" id="id14">
<h3>Dask arrays</h3>

<p>Dask arrays allow you to go <a data-type="indexterm" data-primary="Hello Worlds" data-secondary="distributed collections" data-tertiary="arrays" id="id360"/><a data-type="indexterm" data-primary="distributed collections" data-secondary="arrays" id="id361"/><a data-type="indexterm" data-primary="arrays" id="id362"/>beyond what can fit in memory, or even on disk, on a single computer. Many of the standard NumPy operations are supported out of the box, including aggregates such as average and standard deviation. The <code>from_array</code> function in Dask arrays converts a local array-like collection into a distributed collection. <a data-type="xref" href="#ex_dask_array">Example 2-5</a> shows how to create a distributed array from a local one and then compute the average.</p>
<div id="ex_dask_array" data-type="example">
<h5><span class="label">Example 2-5. </span>Creating a distributed array and computing the average</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">dask.array</code> <code class="k">as</code> <code class="nn">da</code>
<code class="n">distributed_array</code> <code class="o">=</code> <code class="n">da</code><code class="o">.</code><code class="n">from_array</code><code class="p">(</code><code class="nb">list</code><code class="p">(</code><code class="nb">range</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1000</code><code class="p">)))</code>
<code class="n">avg</code> <code class="o">=</code> <code class="n">dask</code><code class="o">.</code><code class="n">compute</code><code class="p">(</code><code class="n">da</code><code class="o">.</code><code class="n">average</code><code class="p">(</code><code class="n">distributed_array</code><code class="p">))</code></pre></div>

<p>As with all distributed collections, what is expensive on a Dask array is not the same as what is expensive on a local array. In the next chapter you’ll learn a bit more about how Dask arrays are implemented and hopefully gain a better intuition around their performance.</p>

<p class="pagebreak-before">Creating a distributed collection from a local collection uses the two fundamental building blocks of <a data-type="indexterm" data-primary="distributed collections" data-secondary="scatter-gather pattern" id="id363"/><a data-type="indexterm" data-primary="scatter-gather pattern" id="id364"/><a data-type="indexterm" data-primary="Hello Worlds" data-secondary="distributed collections" data-tertiary="scatter-gather pattern" id="id365"/>distributed computing, called the <em>scatter-gather pattern</em>. While the originating dataset must be from a local computer, fitting into a single machine, this already expands the number of processors you have at your disposal, as well as the intermediate memory you can utilize, enabling you to better exploit modern cloud infrastructure and scale.
A practical use case would be a distributed web crawler, where the list of seed URLs to crawl might be a small dataset, but the memory you need to hold while crawling might be an order of magnitude larger, requiring distributed computing.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Dask bags and a word count"><div class="sect3" id="id206">
<h3>Dask bags and a word count</h3>

<p>Dask bags implement more of the <a data-type="indexterm" data-primary="Hello Worlds" data-secondary="distributed collections" data-tertiary="bag collection" id="id366"/><a data-type="indexterm" data-primary="Hello Worlds" data-secondary="distributed collections" data-tertiary="word count" id="id367"/>functional programming interfaces than Dask arrays. The “Hello World” of big data is word count, which is easier to implement with functional programming interfaces. Since you’ve already made a crawler function, you can turn its output into a Dask bag using the <code>from_delayed</code> function in 
<span class="keep-together"><a data-type="xref" href="#make_bag_of_crawler">Example 2-6</a>.</span></p>
<div id="make_bag_of_crawler" data-type="example">
<h5><span class="label">Example 2-6. </span>Turning the crawler function’s output into a Dask bag</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">dask.bag</code> <code class="k">as</code> <code class="nn">db</code>
<code class="n">githubs</code> <code class="o">=</code> <code class="p">[</code>
    <code class="s2">"https://github.com/scalingpythonml/scalingpythonml"</code><code class="p">,</code>
    <code class="s2">"https://github.com/dask/distributed"</code><code class="p">]</code>
<code class="n">initial_bag</code> <code class="o">=</code> <code class="n">db</code><code class="o">.</code><code class="n">from_delayed</code><code class="p">(</code><code class="nb">map</code><code class="p">(</code><code class="n">crawl</code><code class="p">,</code> <code class="n">githubs</code><code class="p">))</code></pre></div>

<p>Now that you have a Dask bag collection, you can build everyone’s favorite word count example on top of it. The first step is to turn your bag of text into a bag of words, which you do by using <code>map</code> (see <a data-type="xref" href="#make_a_bag_of_words">Example 2-7</a>). Once you have the bag of words, you can either use Dask’s built-in <code>frequency</code> method (see <a data-type="xref" href="#wc_freq">Example 2-8</a>) or write your own <code>frequency</code> method using functional transformations (see 
<span class="keep-together"><a data-type="xref" href="#wc_func">Example 2-9</a>).</span></p>
<div id="make_a_bag_of_words" data-type="example">
<h5><span class="label">Example 2-7. </span>Turning a bag of text into a bag of words</h5>

<pre data-type="programlisting" data-code-language="python"><code class="n">words_bag</code> <code class="o">=</code> <code class="n">initial_bag</code><code class="o">.</code><code class="n">map</code><code class="p">(</code>
    <code class="k">lambda</code> <code class="n">url_contents</code><code class="p">:</code> <code class="n">url_contents</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="o">.</code><code class="n">split</code><code class="p">(</code><code class="s2">" "</code><code class="p">))</code><code class="o">.</code><code class="n">flatten</code><code class="p">()</code></pre></div>
<div id="wc_freq" data-type="example" class="pagebreak-after">
<h5><span class="label">Example 2-8. </span>Using Dask’s built-in <code>frequency</code> method</h5>

<pre data-type="programlisting" data-code-language="python"><code class="n">dask</code><code class="o">.</code><code class="n">compute</code><code class="p">(</code><code class="n">words_bag</code><code class="o">.</code><code class="n">frequencies</code><code class="p">())</code></pre></div>
<div id="wc_func" data-type="example" class="less_space">
<h5><span class="label">Example 2-9. </span>Using functional transformations to write a custom <code>frequency</code> method</h5>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">make_word_tuple</code><code class="p">(</code><code class="n">w</code><code class="p">):</code>
    <code class="k">return</code> <code class="p">(</code><code class="n">w</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>


<code class="k">def</code> <code class="nf">get_word</code><code class="p">(</code><code class="n">word_count</code><code class="p">):</code>
    <code class="k">return</code> <code class="n">word_count</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>


<code class="k">def</code> <code class="nf">sum_word_counts</code><code class="p">(</code><code class="n">wc1</code><code class="p">,</code> <code class="n">wc2</code><code class="p">):</code>
    <code class="k">return</code> <code class="p">(</code><code class="n">wc1</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="n">wc1</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">+</code> <code class="n">wc2</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code>


<code class="n">word_count</code> <code class="o">=</code> <code class="n">words_bag</code><code class="o">.</code><code class="n">map</code><code class="p">(</code><code class="n">make_word_tuple</code><code class="p">)</code><code class="o">.</code><code class="n">foldby</code><code class="p">(</code><code class="n">get_word</code><code class="p">,</code> <code class="n">sum_word_counts</code><code class="p">)</code></pre></div>

<p>On Dask bags, <code>foldby</code>, <code>frequency</code>, and many other reductions return a single partition bag, meaning the data after reduction needs to fit in a single computer. Dask DataFrames handle reductions differently and don’t have that same restriction.</p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Dask DataFrame (Pandas/What People Wish Big Data Was)"><div class="sect2" id="id15">
<h2>Dask DataFrame (Pandas/What People Wish Big Data Was)</h2>

<p>Pandas is one of the most <a data-type="indexterm" data-primary="Hello Worlds" data-secondary="Dask DataFrame" id="id368"/><a data-type="indexterm" data-primary="Dask DataFrames" id="id369"/><a data-type="indexterm" data-primary="pandas DataFrames" data-seealso="Dask DataFrames" id="id370"/><a data-type="indexterm" data-primary="DataFrames" data-see="Dask DataFrames; pandas DataFrames" id="id371"/>popular Python data libraries, and Dask has a DataFrame library that implements much of the pandas API.  Thanks to Python’s duck-typing, <a data-type="indexterm" data-primary="Python" data-secondary="duck-typing" id="id372"/>you can often use Dask’s distributed DataFrame library in place of pandas. Not all of the API will work exactly the same, and some parts are not implemented, so be sure you have good test coverage.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Your intuition around what’s slow and fast with pandas does not carry over. We will explore this more in <a data-type="xref" href="ch03.xhtml#dask_df">“Dask DataFrames”</a>.</p>
</div>

<p class="pagebreak-after">To illustrate how you can use Dask DataFrame, we’ll rework Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#make_bag_of_crawler">2-6</a> through <a data-type="xref" data-xrefstyle="select:labelnumber" href="#wc_freq">2-8</a> to use it. As with Dask’s other collections, you can create DataFrames from local collections, futures, or distributed files. Since you’ve already made a crawler function, you can turn its output into a Dask bag using the <code>from_delayed</code> function from <a data-type="xref" href="#make_bag_of_crawler">Example 2-6</a>. Instead of using <code>map</code> and <code>foldby</code>, you can use pandas APIs such as <code>explode</code> and <code>value_counts</code>, as shown in <a data-type="xref" href="#wc_dataframe">Example 2-10</a>.</p>
<div id="wc_dataframe" data-type="example" class="less_space">
<h5><span class="label">Example 2-10. </span>DataFrame word count</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">dask.dataframe</code> <code class="k">as</code> <code class="nn">dd</code>


<code class="nd">@dask</code><code class="o">.</code><code class="n">delayed</code>
<code class="k">def</code> <code class="nf">crawl_to_df</code><code class="p">(</code><code class="n">url</code><code class="p">,</code> <code class="n">depth</code><code class="o">=</code><code class="mi">0</code><code class="p">,</code> <code class="n">maxdepth</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code> <code class="n">maxlinks</code><code class="o">=</code><code class="mi">4</code><code class="p">):</code>
    <code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>
    <code class="n">crawled</code> <code class="o">=</code> <code class="n">crawl</code><code class="p">(</code><code class="n">url</code><code class="p">,</code> <code class="n">depth</code><code class="o">=</code><code class="n">depth</code><code class="p">,</code> <code class="n">maxdepth</code><code class="o">=</code><code class="n">maxdepth</code><code class="p">,</code> <code class="n">maxlinks</code><code class="o">=</code><code class="n">maxlinks</code><code class="p">)</code>
    <code class="k">return</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">crawled</code><code class="o">.</code><code class="n">compute</code><code class="p">(),</code> <code class="n">columns</code><code class="o">=</code><code class="p">[</code>
                        <code class="s2">"url"</code><code class="p">,</code> <code class="s2">"text"</code><code class="p">])</code><code class="o">.</code><code class="n">set_index</code><code class="p">(</code><code class="s2">"url"</code><code class="p">)</code>


<code class="n">delayed_dfs</code> <code class="o">=</code> <code class="nb">map</code><code class="p">(</code><code class="n">crawl_to_df</code><code class="p">,</code> <code class="n">githubs</code><code class="p">)</code>
<code class="n">initial_df</code> <code class="o">=</code> <code class="n">dd</code><code class="o">.</code><code class="n">from_delayed</code><code class="p">(</code><code class="n">delayed_dfs</code><code class="p">)</code>
<code class="n">wc_df</code> <code class="o">=</code> <code class="n">initial_df</code><code class="o">.</code><code class="n">text</code><code class="o">.</code><code class="n">str</code><code class="o">.</code><code class="n">split</code><code class="p">()</code><code class="o">.</code><code class="n">explode</code><code class="p">()</code><code class="o">.</code><code class="n">value_counts</code><code class="p">()</code>

<code class="n">dask</code><code class="o">.</code><code class="n">compute</code><code class="p">(</code><code class="n">wc_df</code><code class="p">)</code></pre></div>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="id253">
<h1>Conclusion</h1>

<p>In this chapter you got Dask working on your local machine, as well as had a tour of the different “Hello World” (or getting started) examples with most of Dask’s different built-in libraries. Subsequent chapters will dive into these different tools in more detail.</p>

<p>Now that you’ve got Dask working on your local machine, you might want to jump on over to <a data-type="xref" href="ch12.xhtml#ch12">Chapter 12</a> and look at the different deployment mechanisms. For the most part, you can run the examples in local mode, albeit sometimes a little slower or at a smaller scale. However, the next chapter will look at the core concepts of Dask, and one of the upcoming examples emphasizes the benefits of having Dask running on multiple machines and is also generally easier to explore on a cluster. If you don’t have a cluster available, you may wish to set up a simulated one using something like <a href="https://microk8s.io">MicroK8s</a>.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="id330"><sup><a href="ch02.xhtml#id330-marker">1</a></sup> Word count may be a somewhat tired example, but it is an important example, since it covers both work that can be done with minimal co-ordination (splitting up the text into words) and work requiring co-ordination between computers (summing the words).</p><p data-type="footnote" id="id333"><sup><a href="ch02.xhtml#id333-marker">2</a></sup> There are downsides to deploying your Dask application in this way, as discussed in <a data-type="xref" href="ch12.xhtml#ch12">Chapter 12</a>, but it can be an excellent debugging technique.</p><p data-type="footnote" id="id344"><sup><a href="ch02.xhtml#id344-marker">3</a></sup> Provided they fit in memory.</p><p data-type="footnote" id="id350"><sup><a href="ch02.xhtml#id350-marker">4</a></sup> When we run this on a cluster, we get worse performance, as there is overhead to distributing a task to a remote computer compared to the small delay.</p><p data-type="footnote" id="id351"><sup><a href="ch02.xhtml#id351-marker">5</a></sup> This is very different from Apache Spark, where only the driver/head node can launch tasks.</p></div></div></section></div></body></html>