- en: 18\. Python Extras#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18\. Python 附加功能#
- en: 原文：[https://allendowney.github.io/ThinkPython/chap18.html](https://allendowney.github.io/ThinkPython/chap18.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://allendowney.github.io/ThinkPython/chap18.html](https://allendowney.github.io/ThinkPython/chap18.html)
- en: One of my goals for this book has been to teach you as little Python as possible.
    When there were two ways to do something, I picked one and avoided mentioning
    the other. Or sometimes I put the second one into an exercise.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标之一是尽量少教你 Python。当有两种方法可以做某事时，我选择了一种并避免提到另一种。有时，我会将第二种方法放进练习中。
- en: Now I want to go back for some of the good bits that got left behind. Python
    provides a number of features that are not really necessary – you can write good
    code without them – but with them you can write code that’s more concise, readable,
    or efficient, and sometimes all three.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我想回过头去补充一些被遗忘的好点子。Python 提供了一些不是真正必要的功能——你可以不使用它们写出好的代码——但使用它们，你可以写出更简洁、可读或高效的代码，有时甚至是三者兼具。
- en: 18.1\. Sets[#](#sets "Link to this heading")
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.1\. 集合[#](#sets "跳转到此标题")
- en: Python provides a class called `set` that represents a collection of unique
    elements. To create an empty set, we can use the class object like a function.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了一个名为`set`的类，用于表示一组唯一的元素。要创建一个空集合，我们可以像使用函数一样使用类对象。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can use the `add` method to add elements.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `add` 方法添加元素。
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Or we can pass any kind of sequence to `set`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以将任何类型的序列传递给 `set`。
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An element can only appear once in a `set`. If you add an element that’s already
    there, it has no effect.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个元素在 `set` 中只能出现一次。如果你添加一个已经存在的元素，它将没有任何效果。
- en: '[PRE6]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Or if you create a set with a sequence that contains duplicates, the result
    contains only unique elements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你用一个包含重复元素的序列创建一个集合，结果将只包含唯一元素。
- en: '[PRE8]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Some of the exercises in this book can be done concisely and efficiently with
    sets. For example, here is a solution to an exercise in Chapter 11 that uses a
    dictionary to check whether there are any duplicate elements in a sequence.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的一些练习可以通过集合高效简洁地完成。例如，以下是第 11 章中的一个练习解决方案，使用字典来检查序列中是否存在重复元素。
- en: '[PRE10]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This version adds the element of `t` as keys in a dictionary, and then checks
    whether there are fewer keys than elements. Using sets, we can write the same
    function like this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本将 `t` 中的元素作为字典中的键添加，然后检查键是否比元素少。使用集合，我们可以像这样编写相同的函数。
- en: '[PRE11]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: An element can only appear in a set once, so if an element in `t` appears more
    than once, the set will be smaller than `t`. If there are no duplicates, the set
    will be the same size as `t`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个元素在集合中只能出现一次，因此，如果 `t` 中的某个元素出现多次，集合将比 `t` 小。如果没有重复元素，集合的大小将与 `t` 相同。
- en: '`set` objects provide methods that perform set operations. For example, `union`
    computes the union of two sets, which is a new set that contains all elements
    that appear in either set.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 对象提供了一些方法来执行集合操作。例如，`union` 计算两个集合的并集，它是一个包含两个集合中所有元素的新集合。'
- en: '[PRE12]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Some arithmetic operators work with sets. For example, the `-` operator performs
    set subtraction – the result is a new set that contains all elements from the
    first set that are *not* in the second set.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算术运算符可以与集合一起使用。例如，`-` 运算符执行集合差集运算——结果是一个新集合，包含第一个集合中所有*不*在第二个集合中的元素。
- en: '[PRE14]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In [Chapter 12](chap12.html#section-dictionary-subtraction) we used dictionaries
    to find the words that appear in a document but not in a word list. We used the
    following function, which takes two dictionaries and returns a new dictionary
    that contains only the keys from the first that don’t appear in the second.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 12 章](chap12.html#section-dictionary-subtraction)中，我们使用字典查找文档中出现但不在单词列表中的单词。我们使用了以下函数，它接收两个字典，并返回一个仅包含第一个字典中不出现在第二个字典中的键的新字典。
- en: '[PRE16]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With sets, we don’t have to write this function ourselves. If `word_counter`
    is a dictionary that contains the unique words in the document and `word_list`
    is a list of valid words, we can compute the set difference like this.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合，我们不必自己编写这个函数。如果 `word_counter` 是一个包含文档中唯一单词的字典，`word_list` 是一个有效单词的列表，我们可以像这样计算集合差异。
- en: '[PRE17]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The result is a set that contains the words in the document that don’t appear
    in the word list.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含文档中未出现在单词列表中的单词的集合。
- en: The relational operators work with sets. For example, `<=` checks whether one
    set is a subset of another, including the possibility that they are equal.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符可以与集合一起使用。例如，`<=` 用于检查一个集合是否是另一个集合的子集，包括它们相等的情况。
- en: '[PRE18]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With these operators, we can use sets to do some of the exercises in Chapter 7.
    For example, here’s a version of `uses_only` that uses a loop.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些运算符，我们可以利用集合来完成第7章的一些练习。例如，下面是一个使用循环的 `uses_only` 版本。
- en: '[PRE20]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`uses_only` checks whether all letters in `word` are in `available`. With sets,
    we can rewrite it like this.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`uses_only` 检查 `word` 中的所有字母是否都在 `available` 中。使用集合，我们可以像这样重写它。'
- en: '[PRE21]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the letters in `word` are a subset of the letters in `available`, that means
    that `word` uses only letters in `available`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `word` 中的字母是 `available` 中字母的子集，那么意味着 `word` 只使用了 `available` 中的字母。
- en: 18.2\. Counters[#](#counters "Link to this heading")
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.2\. Counters[#](#counters "跳转到该标题")
- en: A `Counter` is like a set, except that if an element appears more than once,
    the `Counter` keeps track of how many times it appears. If you are familiar with
    the mathematical idea of a “multiset”, a `Counter` is a natural way to represent
    a multiset.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter` 类似于集合，但如果一个元素出现多次，`Counter` 会记录该元素出现的次数。如果你熟悉数学中的“多重集”概念，那么 `Counter`
    就是表示多重集的自然方式。'
- en: The `Counter` class is defined in a module called `collections`, so you have
    to import it. Then you can use the class object as a function and pass as an argument
    a string, list, or any other kind of sequence.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter` 类定义在一个名为 `collections` 的模块中，因此你需要导入该模块。然后，你可以像使用函数一样使用类对象，并将字符串、列表或其他类型的序列作为参数传递。'
- en: '[PRE22]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A `Counter` object is like a dictionary that maps from each key to the number
    of times it appears. As in dictionaries, the keys have to be hashable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter` 对象类似于字典，它将每个键映射到该键出现的次数。与字典一样，键必须是可哈希的。'
- en: Unlike dictionaries, `Counter` objects don’t raise an exception if you access
    an element that doesn’t appear. Instead, they return `0`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与字典不同，`Counter` 对象在访问不存在的元素时不会引发异常。相反，它会返回 `0`。
- en: '[PRE26]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can use `Counter` objects to solve one of the exercises from Chapter 10,
    which asks for a function that takes two words and checks whether they are anagrams
    – that is, whether the letters from one can be rearranged to spell the other.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Counter` 对象来解决第10章的一个练习，该练习要求编写一个函数，接受两个单词并检查它们是否是字母异位词——即，一个单词的字母是否可以重新排列成另一个单词。
- en: Here’s a solution using `Counter` objects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `Counter` 对象的一个解决方案。
- en: '[PRE28]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If two words are anagrams, they contain the same letters with the same counts,
    so their `Counter` objects are equivalent.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个单词是字母异位词，它们包含相同的字母和相同的出现次数，因此它们的 `Counter` 对象是等价的。
- en: '`Counter` provides a method called `most_common` that returns a list of value-frequency
    pairs, sorted from most common to least.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter` 提供了一个名为 `most_common` 的方法，它返回一个值-频率对的列表，按出现频率从高到低排序。'
- en: '[PRE29]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: They also provide methods and operators to perform set-like operations, including
    addition, subtraction, union and intersection. For example, the `+` operator combines
    two `Counter` objects and creates a new `Counter` that contains the keys from
    both and the sums of the counts.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还提供了方法和运算符来执行类似集合的操作，包括加法、减法、并集和交集。例如，`+` 运算符可以将两个 `Counter` 对象合并，创建一个新的 `Counter`，其中包含两个对象的键以及计数的和。
- en: We can test it by making a `Counter` with the letters from `'bans'` and adding
    it to the letters from `'banana'`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `'bans'` 中的字母制作成 `Counter`，并将其添加到 `'banana'` 中的字母来进行测试。
- en: '[PRE31]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You’ll have a chance to explore other `Counter` operations in the exercises
    at the end of this chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你将有机会在本章末的练习中探索其他 `Counter` 操作。
- en: 18.3\. defaultdict[#](#defaultdict "Link to this heading")
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.3\. defaultdict[#](#defaultdict "跳转到该标题")
- en: The `collections` module also provides `defaultdict`, which is like a dictionary
    except that if you access a key that doesn’t exist, it generates a new value automatically.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections` 模块还提供了 `defaultdict`，它类似于字典，但如果访问一个不存在的键，它会自动生成一个新值。'
- en: When you create a `defaultdict`, you provide a function that’s used to create
    new values. A function that create objects is sometimes called a **factory**.
    The built-in functions that create lists, sets, and other types can be used as
    factories.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `defaultdict` 时，你提供一个函数，用于创建新值。创建对象的函数有时被称为**工厂函数**。内置的用于创建列表、集合等类型的函数可以作为工厂函数使用。
- en: For example, here’s a `defaultdict` that creates a new `list` when needed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是一个创建新 `list` 的 `defaultdict`。
- en: '[PRE33]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that the argument is `list`, which is a class object, not `list()`, which
    is a function call that creates a new list. The factory function doesn’t get called
    unless we access a key that doesn’t exist.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，参数是 `list`，它是一个类对象，而不是 `list()`，后者是一个函数调用，用来创建一个新列表。工厂函数只有在我们访问一个不存在的键时才会被调用。
- en: '[PRE35]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The new list, which we’re calling `t`, is also added to the dictionary. So
    if we modify `t`, the change appears in `d`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 新的列表，我们称之为`t`，也被添加到了字典中。因此，如果我们修改`t`，变动也会出现在`d`中：
- en: '[PRE37]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you are making a dictionary of lists, you can often write simpler code using
    `defaultdict`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建一个包含列表的字典，通常可以使用`defaultdict`编写更简洁的代码。
- en: In one of the exercises in [Chapter 11](chap11.html#chapter-tuples), I made
    a dictionary that maps from a sorted string of letters to the list of words that
    can be spelled with those letters. For example, the string `'opst'` maps to the
    list `['opts', 'post', 'pots', 'spot', 'stop', 'tops']`. Here’s the original code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 11 章](chap11.html#chapter-tuples)的一个练习中，我创建了一个字典，将已排序的字母字符串映射到可以用这些字母拼写的单词列表。例如，字符串
    `'opst'` 映射到列表 `['opts', 'post', 'pots', 'spot', 'stop', 'tops']`。这是原始代码。
- en: '[PRE39]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: And here’s a simpler version using a `defaultdict`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 `defaultdict` 的更简洁版本。
- en: '[PRE40]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the exercises at the end of the chapter, you’ll have a chance to practice
    using `defaultdict` objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在章节末尾的练习中，你将有机会练习使用`defaultdict`对象。
- en: '[PRE41]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 18.4\. Conditional expressions[#](#conditional-expressions "Link to this heading")
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.4\. 条件表达式[#](#conditional-expressions "链接到此标题")
- en: 'Conditional statements are often used to choose one of two values, like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句通常用于选择两个值中的一个，例如这样：
- en: '[PRE43]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This statement checks whether `x` is positive. If so, it computes its logarithm.
    If not, `math.log` would raise a ValueError. To avoid stopping the program, we
    generate a `NaN`, which is a special floating-point value that represents “Not
    a Number”.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句检查 `x` 是否为正数。如果是，它会计算其对数。如果不是，`math.log` 会引发一个 ValueError。为了避免程序中断，我们生成一个
    `NaN`，这是一个表示“非数字”的特殊浮点值。
- en: We can write this statement more concisely using a **conditional expression**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过**条件表达式**更简洁地编写这个语句。
- en: '[PRE44]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can almost read this line like English: “`y` gets log-`x` if `x` is greater
    than 0; otherwise it gets `NaN`”.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以像读英语一样读这行：“`y` 等于 log-`x`，如果 `x` 大于 0；否则它等于 `NaN`”。
- en: Recursive functions can sometimes be written concisely using conditional expressions.
    For example, here is a version of `factorial` with a conditional *statement*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数有时可以通过条件表达式简洁地写出来。例如，这是一个带有条件*语句*的 `factorial` 版本。
- en: '[PRE45]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And here’s a version with a conditional *expression*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有条件*表达式*的版本。
- en: '[PRE46]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Another use of conditional expressions is handling optional arguments. For example,
    here is class definition with an `__init__` method that uses a conditional statement
    to check a parameter with a default value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 条件表达式的另一个用途是处理可选参数。例如，这是一个类定义，包含一个使用条件语句来检查带有默认值的参数的 `__init__` 方法。
- en: '[PRE47]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here’s a version that uses a conditional expression.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用条件表达式的版本。
- en: '[PRE48]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In general, you can replace a conditional statement with a conditional expression
    if both branches contain a single expression and no statements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果两个分支都包含单一的表达式且没有语句，可以用条件表达式替代条件语句。
- en: 18.5\. List comprehensions[#](#list-comprehensions "Link to this heading")
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.5\. 列表推导式[#](#list-comprehensions "链接到此标题")
- en: In previous chapters, we’ve seen a few examples where we start with an empty
    list and add elements, one at a time, using the `append` method. For example,
    suppose we have a string that contains the title of a movie, and we want to capitalize
    all of the words.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们已经看到一些例子，我们从一个空列表开始，并通过 `append` 方法逐个添加元素。例如，假设我们有一个包含电影标题的字符串，我们想要将所有单词的大写字母进行转换。
- en: '[PRE49]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can split it into a list of strings, loop through the strings, capitalize
    them, and append them to a list.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其拆分成一个字符串列表，遍历这些字符串，进行大写转换，并将它们追加到一个列表中。
- en: '[PRE50]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can do the same thing more concisely using a **list comprehension**:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过**列表推导式**更简洁地做同样的事情：
- en: '[PRE52]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The bracket operators indicate that we are constructing a new list. The expression
    inside the brackets specifies the elements of the list, and the `for` clause indicates
    what sequence we are looping through.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号操作符表示我们正在构建一个新列表。括号内的表达式指定了列表的元素，`for` 子句指示我们正在循环遍历的序列。
- en: The syntax of a list comprehension might seem strange, because the loop variable
    – `word` in this example – appears in the expression before we get to its definition.
    But you get used to it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式的语法可能看起来很奇怪，因为循环变量—在这个例子中是 `word`—出现在表达式中，而我们还没有看到它的定义。但你会习惯的。
- en: As another example, in [Chapter 9](chap09.html#section-word-list) we used this
    loop to read words from a file and append them to a list.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，在[第 9 章](chap09.html#section-word-list)中，我们使用这个循环从文件中读取单词并将它们追加到列表中。
- en: '[PRE54]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here’s how we can write that as a list comprehension.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何将其写成列表推导式的方式。
- en: '[PRE55]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: A list comprehension can also have an `if` clause that determines which elements
    are included in the list. For example, here’s a `for` loop we used in [Chapter
    10](chap10.html#section-palindrome-list) to make a list of only the words in `word_list`
    that are palindromes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式也可以包含一个`if`子句，用来决定哪些元素会被包含在列表中。例如，这里是我们在[第10章](chap10.html#section-palindrome-list)中使用的一个`for`循环，用于生成`word_list`中所有回文单词的列表。
- en: '[PRE56]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here’s how we can do the same thing with an list comprehension.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何用列表推导式做同样的事情。
- en: '[PRE57]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: When a list comprehension is used as an argument to a function, we can often
    omit the brackets. For example, suppose we want to add up \(1 / 2^n\) for values
    of \(n\) from 0 to 9. We can use a list comprehension like this.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表推导式作为函数的参数时，我们通常可以省略括号。例如，假设我们想要将\(1 / 2^n\)的值加总，其中\(n\)从0到9。我们可以像这样使用列表推导式。
- en: '[PRE58]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Or we can leave out the brackets like this.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以像这样省略括号。
- en: '[PRE60]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In this example, the argument is technically a **generator expression**, not
    a list comprehension, and it never actually makes a list. But other than that,
    the behavior is the same.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，参数严格来说是一个**生成器表达式**，而不是列表推导式，它实际上并没有创建一个列表。但除此之外，行为是一样的。
- en: List comprehensions and generator expressions are concise and easy to read,
    at least for simple expressions. And they are usually faster than the equivalent
    for loops, sometimes much faster. So if you are mad at me for not mentioning them
    earlier, I understand.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式和生成器表达式简洁且易于阅读，至少对于简单的表达式是如此。它们通常比等效的`for`循环更快，有时甚至快得多。所以，如果你生气我没有早点提到它们，我理解。
- en: But, in my defense, list comprehensions are harder to debug because you can’t
    put a print statement inside the loop. I suggest you use them only if the computation
    is simple enough that you are likely to get it right the first time. Or consider
    writing and debugging a `for` loop and then converting it to a list comprehension.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了我的辩护，列表推导式更难调试，因为你不能在循环内部放置`print`语句。我建议你仅在计算足够简单、你很可能第一次就能写对的情况下使用它们。或者考虑先编写并调试一个`for`循环，再将其转换为列表推导式。
- en: 18.6\. `any` and `all`[#](#any-and-all "Link to this heading")
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.6\. `any`和`all`[#](#any-and-all "Link to this heading")
- en: Python provides a built-in function, `any`, that takes a sequence of boolean
    values and returns `True` if any of the values are `True`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一个内置函数`any`，它接受一个布尔值序列，并在其中任何一个值为`True`时返回`True`。
- en: '[PRE62]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`any` is often used with generator expressions.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`通常与生成器表达式一起使用。'
- en: '[PRE64]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: That example isn’t very useful because it does the same thing as the `in` operator.
    But we could use `any` to write concise solutions to some of the exercises in
    [Chapter 7](chap07.html#chapter-search). For example, we can write `uses_none`
    like this.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子并不是很有用，因为它与`in`运算符做的事情相同。但我们可以使用`any`来为[第7章](chap07.html#chapter-search)中的一些练习写出简洁的解法。例如，我们可以像这样编写`uses_none`。
- en: '[PRE66]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This function loops through the letters in `word` and checks whether any of
    them are in `forbidden`. Using `any` with a generator expression is efficient
    because it stops immediately if it finds a `True` value, so it doesn’t have to
    loop through the whole sequence.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数循环遍历`word`中的字母，检查其中是否有字母在`forbidden`中。使用`any`和生成器表达式的结合是高效的，因为一旦找到了`True`值，它就会立即停止，而不必遍历整个序列。
- en: Python provides another built-in function, `all`, that returns `True` if every
    element of the sequence is `True`. We can use it to write a concise version of
    `uses_all`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了另一个内置函数`all`，它会在序列中的每个元素都为`True`时返回`True`。我们可以使用它来编写`uses_all`的简洁版本。
- en: '[PRE67]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Expressions using `any` and `all` can be concise, efficient, and easy to read.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`any`和`all`表达式可以简洁、高效且易于阅读。
- en: 18.7\. Named tuples[#](#named-tuples "Link to this heading")
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.7\. 命名元组[#](#named-tuples "Link to this heading")
- en: The `collections` module provides a function called `namedtuple` that can be
    used to create simple classes. For example, the `Point` object in [Chapter 16](chap16.html#section-create-point)
    has only two attributes, `x` and `y`. Here’s how we defined it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections`模块提供了一个名为`namedtuple`的函数，可以用来创建简单的类。例如，[第16章](chap16.html#section-create-point)中的`Point`对象只有两个属性，`x`和`y`。以下是我们如何定义它的。'
- en: '[PRE68]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: That’s a lot of code to convey a small amount of information. `namedtuple` provides
    a more concise way to define classes like this.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码传达了少量信息却包含了很多代码。`namedtuple`提供了一种更简洁的方式来定义像这样的类。
- en: '[PRE69]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The first argument is the name of the class you want to create. The second is
    a list of the attributes `Point` objects should have. The result is a class object,
    which is why it is assigned to a capitalized variable name.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是你想创建的类的名称，第二个参数是`Point`对象应该拥有的属性列表。结果是一个类对象，这就是为什么它被赋值给一个首字母大写的变量名。
- en: A class created with `namedtuple` provides an `__init__` method that assigns
    values to the attributes and a `__str__` that displays the object in a readable
    form. So we can create and display a `Point` object like this.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`namedtuple`创建的类提供了一个`__init__`方法，用于将值分配给属性，还有一个`__str__`方法，用于以可读的形式显示对象。所以我们可以像这样创建并显示一个`Point`对象。
- en: '[PRE70]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`Point` also provides an `__eq__` method that checks whether two `Point` objects
    are equivalent – that is, whether their attributes are the same.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point`还提供了一个`__eq__`方法，用于检查两个`Point`对象是否相等——也就是说，它们的属性是否相同。'
- en: '[PRE72]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You can access the elements of a named tuple by name or by index.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过名称或索引访问命名元组的元素。
- en: '[PRE74]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You can also treat a named tuple as a tuple, as in this assignment.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将命名元组当作元组来使用，如下所示的赋值。
- en: '[PRE78]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: But `namedtuple` objects are immutable. After the attributes are initialized,
    they can’t be changed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但`namedtuple`对象是不可变的。属性初始化后，它们不能被更改。
- en: '[PRE80]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`namedtuple` provides a quick way to define simple classes. The drawback is
    that simple classes don’t always stay simple. You might decide later that you
    want to add methods to a named tuple. In that case, you can define a new class
    that inherits from the named tuple.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple`提供了一种快速定义简单类的方法。缺点是简单类有时并不总是保持简单。你可能会决定稍后为命名元组添加方法。在这种情况下，你可以定义一个新类，从命名元组继承。'
- en: '[PRE84]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Or at that point you could switch to a conventional class definition.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 或者到那时你可以切换到常规的类定义。
- en: 18.8\. Packing keyword arguments[#](#packing-keyword-arguments "Link to this
    heading")
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.8\. 打包关键字参数[#](#packing-keyword-arguments "Link to this heading")
- en: In [Chapter 11](chap11.html#section-argument-pack), we wrote a function that
    packs its arguments into a tuple.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](chap11.html#section-argument-pack)中，我们写了一个函数，将它的参数打包成一个元组。
- en: '[PRE85]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You can call this function with any number of arguments.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用任意数量的参数调用这个函数。
- en: '[PRE86]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: But the `*` operator doesn’t pack keyword arguments. So calling this function
    with a keyword argument causes an error.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但`*`运算符并不会打包关键字参数。因此，带有关键字参数调用此函数会导致错误。
- en: '[PRE88]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To pack keyword arguments, we can use the `**` operator:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要打包关键字参数，我们可以使用`**`运算符：
- en: '[PRE90]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The keyword-packing parameter can have any name, but `kwargs` is a common choice.
    The result is a dictionary that maps from keywords to values.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字打包参数可以使用任何名称，但`kwargs`是常见的选择。结果是一个字典，它将关键字映射到对应的值。
- en: '[PRE91]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In this example, the value of `kwargs` is printed, but otherwise is has no effect.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`kwargs`的值被打印出来，但除此之外没有任何效果。
- en: But the `**` operator can also be used in an argument list to unpack a dictionary.
    For example, here’s a version of `mean` that packs any keyword arguments it gets
    and then unpacks them as keyword arguments for `sum`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但`**`运算符也可以在参数列表中使用，用来解包字典。例如，这是一个`mean`的版本，它打包收到的任何关键字参数，然后将其解包为`sum`的关键字参数。
- en: '[PRE94]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Now if we call `mean` with `start` as a keyword argument, it gets passed along
    to sum, which uses it as the starting point of the summation. In the following
    example `start=3` adds `3` to the sum before computing the mean, so the sum is
    `6` and the result is `3`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们以`start`作为关键字参数调用`mean`，它会传递给`sum`，并作为求和的起始点。在下面的例子中，`start=3`在计算平均值之前将`3`加到总和中，所以总和是`6`，结果是`3`。
- en: '[PRE95]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: As another example, if we have a dictionary with keys `x` and `y`, we can use
    it with the unpack operator to create a `Point` object.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，如果我们有一个包含`x`和`y`键的字典，我们可以使用解包运算符来创建一个`Point`对象。
- en: '[PRE97]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Without the unpack operator, `d` is treated as a single positional argument,
    so it gets assigned to `x`, and we get a `TypeError` because there’s no second
    argument to assign to `y`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有解包运算符，`d`将被视为单个位置参数，因此它被赋值给`x`，我们会得到一个`TypeError`，因为没有第二个参数可以赋值给`y`。
- en: '[PRE99]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: When you are working with functions that have a large number of keyword arguments,
    it is often useful to create and pass around dictionaries that specify frequently
    used options.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理具有大量关键字参数的函数时，通常创建并传递指定常用选项的字典是很有用的。
- en: '[PRE101]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 18.9\. Debugging[#](#debugging "Link to this heading")
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.9\. 调试[#](#debugging "Link to this heading")
- en: In previous chapters, we used `doctest` to test functions. For example, here’s
    a function called `add` that takes two numbers and returns their sum. In includes
    a doctest that checks whether `2 + 2` is `4`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用`doctest`来测试函数。例如，这里有一个名为`add`的函数，它接受两个数字并返回它们的和。它包含一个`doctest`，检查`2
    + 2`是否等于`4`。
- en: '[PRE103]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This function takes a function object and runs its doctests.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个函数对象并运行它的`doctests`。
- en: '[PRE104]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: So we can test `add` like this.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以像这样测试`add`函数。
- en: '[PRE105]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: There’s no output, which means all tests passed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 没有输出，这意味着所有的测试都通过了。
- en: Python provides another tool for running automated tests, called `unittest`.
    It is a little more complicated to use, but here’s an example.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了另一种用于运行自动化测试的工具，称为`unittest`。它的使用稍微复杂一些，但这里有一个例子。
- en: '[PRE106]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: First we import `TestCase`, which is a class in the `unittest` module. To use
    it, we have to define a new class that inherits from `TestCase` and provides at
    least one test method. The name of the test method must begin with `test` and
    should indicate which function it tests.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`TestCase`，这是`unittest`模块中的一个类。为了使用它，我们必须定义一个继承自`TestCase`的新类，并提供至少一个测试方法。测试方法的名称必须以`test`开头，并应表明它测试的是哪个函数。
- en: In this example, `test_add` tests the `add` function by calling it, saving the
    result, and invoking `assertEqual`, which is inherited from `TestCase`. `assertEqual`
    takes two arguments and checks whether they are equal.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`test_add`通过调用`add`函数、保存结果，并调用`assertEqual`来测试`add`函数。`assertEqual`继承自`TestCase`，它接受两个参数并检查它们是否相等。
- en: In order to run this test method, we have to run a function in `unittest` called
    `main` and provide several keyword arguments. The following function shows the
    details – if you are curious, you can ask a virtual assistant to explain how it
    works.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个测试方法，我们必须运行`unittest`中的一个名为`main`的函数，并提供几个关键字参数。以下函数展示了详细信息——如果您有兴趣，可以向虚拟助手询问它是如何工作的。
- en: '[PRE107]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`run_unittest` does not take `TestExample` as an argument – instead, it searches
    for classes that inherit from `TestCase`. Then it searches for methods that begin
    with `test` and runs them. This process is called **test discovery**.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`run_unittest`不接受`TestExample`作为参数，而是查找继承自`TestCase`的类。然后，它查找以`test`开头的方法并运行它们。这个过程叫做**测试发现**。'
- en: Here’s what happens when we call `run_unittest`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们调用`run_unittest`时发生的情况。
- en: '[PRE108]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '`unittest.main` reports the number of tests it ran and the results. In this
    case `OK` indicates that the tests passed.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.main`报告它运行的测试数量和结果。在这种情况下，`OK`表示测试通过。'
- en: To see what happens when a test fails, we’ll add an incorrect test method to
    `TestExample`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看测试失败时发生了什么，我们将向`TestExample`添加一个错误的测试方法。
- en: '[PRE110]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Here’s what happens when we run the tests.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们运行测试时发生的情况。
- en: '[PRE111]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The report includes the test method that failed and an error message showing
    where. The summary indicates that two tests ran and one failed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 报告包括失败的测试方法和显示失败位置的错误信息。总结部分表明有两个测试被运行，其中一个失败了。
- en: In the exercises below, I’ll suggest some prompts you can use to ask a virtual
    assistant for more information about `unittest`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的练习中，我将建议一些提示，您可以用它们向虚拟助手询问关于`unittest`的更多信息。
- en: 18.10\. Glossary[#](#glossary "Link to this heading")
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.10\. 术语表[#](#glossary "Link to this heading")
- en: '**factory:** A function used to create objects, often passed as a parameter
    to a function.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂：** 用于创建对象的函数，通常作为参数传递给其他函数。'
- en: '**conditional expression:** An expression that uses a conditional to select
    one of two values.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件表达式：** 使用条件语句来选择两个值中的一个的表达式。'
- en: '**list comprehension:** A concise way to loop through a sequence and create
    a list.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表推导式：** 一种简洁的方式来遍历序列并创建一个列表。'
- en: '**generator expression:** Similar to a list comprehension except that it does
    not create a list.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器表达式：** 类似于列表推导式，但它不创建列表。'
- en: '**test discovery:** A process used to find and run tests.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试发现：** 一种用于查找和运行测试的过程。'
- en: 18.11\. Exercises[#](#exercises "Link to this heading")
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.11\. 练习[#](#exercises "Link to this heading")
- en: '[PRE113]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 18.11.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this
    heading")
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.11.1\. 向虚拟助手提问[#](#ask-a-virtual-assistant "Link to this heading")
- en: There are a few topics in this chapter you might want to learn about.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有一些话题可能您会想了解。
- en: “What are the methods and operators of Python’s set class?”
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Python的set类有哪些方法和操作符？”
- en: “What are the methods and operators of Python’s Counter class?”
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Python的Counter类有哪些方法和操作符？”
- en: “What is the difference between a Python list comprehension and a generator
    expression?”
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Python的列表推导式和生成器表达式有什么区别？”
- en: “When should I use Python’s `namedtuple` rather than define a new class?”
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “什么时候应该使用Python的`namedtuple`而不是定义一个新类？”
- en: “What are some uses of packing and unpacking keyword arguments?”
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “打包和解包关键字参数有什么用途？”
- en: “How does `unittest` do test discovery?”
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “`unittest`是如何进行测试发现的？”
- en: “Along with `assertEqual`, what are the most commonly used methods in `unittest.TestCase`?”
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “除了`assertEqual`，`unittest.TestCase`中最常用的方法有哪些？”
- en: “What are the pros and cons of `doctest` and `unittest`?”
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “`doctest`和`unittest`的优缺点是什么？”
- en: For the following exercises, consider asking a virtual assistant for help, but
    as always, remember to test the results.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下练习，考虑请求虚拟助手的帮助，但如同往常一样，请记得测试结果。
- en: 18.11.2\. Exercise[#](#exercise "Link to this heading")
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.11.2\. 练习[#](#exercise "链接到此标题")
- en: One of the exercises in Chapter 7 asks for a function called `uses_none` that
    takes a word and a string of forbidden letters, and returns `True` if the word
    does not use any of the letters. Here’s a solution.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章中的一个练习要求编写一个名为`uses_none`的函数，它接受一个单词和一串禁用字母，如果单词中不使用任何禁用字母，则返回`True`。以下是一个解决方案。
- en: '[PRE114]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Write a version of this function that uses `set` operations instead of a `for`
    loop. Hint: ask a VA, “How do I compute the intersection of Python sets?”'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这个函数的版本，使用`set`操作代替`for`循环。提示：询问虚拟助手，“如何计算Python集合的交集？”
- en: 18.11.3\. Exercise[#](#id1 "Link to this heading")
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.11.3\. 练习[#](#id1 "链接到此标题")
- en: Scrabble is a board game where the objective is to use letter tiles to spell
    words. For example, if we have tiles with the letters `T`, `A`, `B`, `L`, `E`,
    we can spell `BELT` and `LATE` using a subset of the tiles – but we can’t spell
    `BEET` because we don’t have two `E`s.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 拼字游戏是一种棋盘游戏，目标是使用字母瓦片拼写单词。例如，如果我们有字母瓦片`T`、`A`、`B`、`L`、`E`，我们可以拼出`BELT`和`LATE`，但是我们无法拼出`BEET`，因为我们没有两个`E`。
- en: Write a function that takes a string of letters and a word, and checks whether
    the letters can spell the word, taking into account how many times each letter
    appears.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，接受一个字母字符串和一个单词，检查这些字母是否能拼出该单词，考虑每个字母出现的次数。
- en: 18.11.4\. Exercise[#](#id2 "Link to this heading")
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.11.4\. 练习[#](#id2 "链接到此标题")
- en: In one of the exercises from [Chapter 17](chap17.html#chapter-inheritance),
    my solution to `has_straightflush` uses the following method, which partitions
    a `PokerHand` into a list of four hands, where each hand contains cards of the
    same suit.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第17章](chap17.html#chapter-inheritance)中的一个练习中，我对`has_straightflush`的解决方案使用了以下方法，它将`PokerHand`分成一个包含四手牌的列表，每手牌都包含相同花色的卡牌。
- en: '[PRE115]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Write a simplified version of this function using a `defaultdict`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这个函数的简化版本，使用`defaultdict`。
- en: 18.11.5\. Exercise[#](#id3 "Link to this heading")
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.11.5\. 练习[#](#id3 "链接到此标题")
- en: Here’s the function from Chapter 11 that computes Fibonacci numbers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自第11章的一个计算斐波那契数的函数。
- en: '[PRE116]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Write a version of this function with a single return statement that use two
    conditional expressions, one nested inside the other.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这个函数的版本，使用单个返回语句，使用两个条件表达式，其中一个嵌套在另一个内部。
- en: 18.11.6\. Exercise[#](#id4 "Link to this heading")
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.11.6\. 练习[#](#id4 "链接到此标题")
- en: The following is a function that computes the binomial coefficient recursively.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个递归计算二项式系数的函数。
- en: '[PRE117]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Rewrite the body of the function using nested conditional expressions.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌套条件表达式重写函数主体。
- en: This function is not very efficient because it ends up computing the same values
    over and over. Make it more efficient by memoizing it, as described in [Chapter
    10](chap10.html#section-memos).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的效率不高，因为它会不断计算相同的值。通过如[第10章](chap10.html#section-memos)所述的记忆化方法，使其更高效。
- en: '[PRE118]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 18.11.7\. Exercise[#](#id5 "Link to this heading")
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.11.7\. 练习[#](#id5 "链接到此标题")
- en: Here’s the `__str__` method from the `Deck` class in [Chapter 17](chap17.html#section-print-deck).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自[第17章](chap17.html#section-print-deck)中`Deck`类的`__str__`方法。
- en: '[PRE120]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Write a more concise version of this method with a list comprehension or generator
    expression.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导或生成器表达式编写这个方法的更简洁版本。
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[Think Python: 第3版](https://allendowney.github.io/ThinkPython/index.html)'
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 版权所有 2024 [Allen B. Downey](https://allendowney.com)
- en: 'Code license: [MIT License](https://mit-license.org/)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 代码许可证：[MIT许可证](https://mit-license.org/)
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 文本许可证：[知识共享署名-非商业性使用-相同方式共享 4.0 国际](https://creativecommons.org/licenses/by-nc-sa/4.0/)
