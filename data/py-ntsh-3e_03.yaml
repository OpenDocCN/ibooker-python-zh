- en: Chapter 3\. The Python Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。Python 语言
- en: 'This chapter is a guide to the Python language. To learn Python from scratch,
    we suggest you start with the appropriate links from the [online docs](https://oreil.ly/lVDFK)
    and the resources mentioned in [“Python documentation for nonprogrammers”](ch01.xhtml#python_documentation_for_nonprogrammers).
    If you already know at least one other programming language well, and just want
    to learn specifics about Python, this chapter is for you. However, we’re not trying
    to teach Python: we cover a lot of ground at a pretty fast pace. We focus on the
    rules, and only secondarily point out best practices and style; as your Python
    style guide, use [PEP 8](https://oreil.ly/biw1p) (optionally augmented by extra
    guidelines such as those of [“The Hitchhiker’s Guide to Python”](https://oreil.ly/gKFLA),
    [CKAN](https://oreil.ly/0nj5h), and [Google](https://oreil.ly/q9_k_)).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是 Python 语言的指南。如果您想从头开始学习 Python，我们建议您从[在线文档](https://oreil.ly/lVDFK)中选择合适的链接，并参考[“非程序员的
    Python 文档”](ch01.xhtml#python_documentation_for_nonprogrammers)中提到的资源。如果您已经很熟悉至少一种其他编程语言，只是想了解
    Python 的具体信息，那么本章适合您。但是，我们不打算教授 Python：我们在相当快的速度下涵盖了大量内容。我们专注于规则，只是次要地指出最佳实践和风格；作为您的
    Python 风格指南，请使用[PEP 8](https://oreil.ly/biw1p)（可以加上额外的指导，如[“Python 之旅”](https://oreil.ly/gKFLA)、[CKAN](https://oreil.ly/0nj5h)和[Google](https://oreil.ly/q9_k_)的指导）。
- en: Lexical Structure
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词法结构
- en: 'The *lexical structure* of a programming language is the set of basic rules
    that govern how you write programs in that language. It is the lowest-level syntax
    of the language, specifying such things as what variable names look like and how
    to denote comments. Each Python source file, like any other text file, is a sequence
    of characters. You can also usefully consider it a sequence of lines, tokens,
    or statements. These different lexical views complement each other. Python is
    very particular about program layout, especially lines and indentation: pay attention
    to this information if you are coming to Python from another language.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言的*词法结构*是指规定如何在该语言中编写程序的基本规则集。它是语言的最低级语法，指定诸如变量名的外观和如何表示注释等事物。每个 Python 源文件，像任何其他文本文件一样，都是一系列字符。您还可以有用地将其视为行、标记或语句的序列。这些不同的词法视图相辅相成。Python
    对程序布局非常讲究，特别是对行和缩进：如果您从其他语言来学习 Python，请注意这些信息。
- en: Lines and Indentation
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行和缩进
- en: 'A Python program is a sequence of *logical lines*, each made up of one or more
    *physical lines*. Each physical line may end with a comment. A hash sign (#) that
    is not inside a string literal starts a comment. All characters after the #, up
    to but excluding the line end, are the comment: Python ignores them. A line containing
    only whitespace, possibly with a comment, is a *blank line*: Python ignores it.
    In an interactive interpreter session, you must enter an empty physical line (without
    any whitespace or comment) to terminate a multiline statement.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序是一系列*逻辑行*，每个逻辑行由一个或多个*物理行*组成。每个物理行可能以注释结束。不在字符串字面值内的井号(#)开始注释。井号后的所有字符直到行尾（但不包括行尾）都是注释：Python
    会忽略它们。只包含空白字符，可能带有注释的行是*空白行*：Python 会忽略它。在交互式解释器会话中，您必须输入一个空的物理行（没有任何空白或注释）来结束多行语句。
- en: 'In Python, the end of a physical line marks the end of most statements. Unlike
    in other languages, you don’t normally terminate Python statements with a delimiter,
    such as a semicolon (;). When a statement is too long to fit on a physical line,
    you can join two adjacent physical lines into a logical line by ensuring that
    the first physical line does not contain a comment and ends with a backslash (\).
    More elegantly, Python also automatically joins adjacent physical lines into one
    logical line if an open parenthesis ((), bracket ([), or brace ({) has not yet
    been closed: take advantage of this mechanism to produce more readable code than
    you’d get with backslashes at line ends. Triple-quoted string literals can also
    span physical lines. Physical lines after the first one in a logical line are
    known as *continuation lines*. Indentation rules apply to the first physical line
    of each logical line, not to continuation lines.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，物理行的结束标志着大多数语句的结束。与其他语言不同，您通常不需要使用分隔符（如分号；）来终止Python语句。当语句过长无法适应物理行时，可以通过确保第一物理行不包含注释并以反斜杠（\）结尾来将两个相邻的物理行连接成一个逻辑行。更加优雅的是，如果一个开放括号（（），方括号（[），或大括号（{）尚未关闭，Python也会自动将相邻的物理行合并为一个逻辑行：利用此机制可以生成比以反斜杠结尾更易读的代码。三引号字符串文字也可以跨越物理行。在逻辑行的第一个物理行之后的物理行被称为*连续行*。缩进规则适用于每个逻辑行的第一个物理行，而不是连续行。
- en: Python uses indentation to express the block structure of a program. Python
    does not use braces, or other begin/end delimiters, around blocks of statements;
    indentation is the only way to denote blocks. Each logical line in a Python program
    is *indented* by the whitespace on its left. A *block* is a contiguous sequence
    of logical lines, all indented by the same amount; a logical line with less indentation
    ends the block. All statements in a block must have the same indentation, as must
    all clauses in a compound statement. The first statement in a source file must
    have no indentation (i.e., must not begin with any whitespace). Statements that
    you type at the interactive interpreter primary prompt, >>> (covered in [“Interactive
    Sessions”](ch02.xhtml#interactive_sessions)), must also have no indentation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用缩进来表示程序的块结构。Python不使用大括号或其他开始/结束界定符来标识语句块；缩进是唯一指定块的方法。Python程序中的每个逻辑行*左侧的空白*表示缩进。*块*是一系列连续的逻辑行，所有这些行都具有相同的缩进量；具有较少缩进的逻辑行终止该块。块中的所有语句以及复合语句中的所有子句必须具有相同的缩进，源文件中的第一条语句不得缩进（即不得以任何空白字符开头）。在交互式解释器主提示符>>>（详见[“交互式会话”](ch02.xhtml#interactive_sessions)）处键入的语句也不得缩进。
- en: Python treats each tab as if it was up to 8 spaces, so that the next character
    after the tab falls into logical column 9, 17, 25, and so on. Standard Python
    style is to use four spaces (*never* tabs) per indentation level.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python将每个制表符视为多达8个空格，因此制表符之后的下一个字符落入逻辑列9、17、25等。标准的Python风格是每个缩进级别使用四个空格（*绝对不是*制表符）。
- en: If you must use tabs, Python does not allow mixing tabs and spaces for indentation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须使用制表符，Python不允许混合使用制表符和空格进行缩进。
- en: Use Spaces, Not Tabs
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用空格而非制表符
- en: Configure your favorite editor to expand a Tab keypress to four spaces, so that
    all Python source code you write contains just spaces, not tabs. This way, all
    tools, including Python itself, are consistent in handling indentation in your
    Python source files. Optimal Python style is to indent blocks by exactly four
    spaces; use no tab characters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 配置您喜欢的编辑器，将Tab键扩展为四个空格，以便您编写的所有Python源代码都只包含空格，而不是制表符。这样，包括Python在内的所有工具在处理Python源文件的缩进时都是一致的。最佳的Python风格是每个缩进块恰好缩进四个空格；不使用制表符。
- en: Character Sets
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符集
- en: A Python source file can use any Unicode character, encoded by default as UTF-8\.
    (Characters with codes between 0 and 127, the 7-bit *ASCII characters*, encode
    in UTF-8 into the respective single bytes, so an ASCII text file is a fine Python
    source file, too.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python源文件可以使用任何Unicode字符，默认编码为UTF-8（ASCII字符是0到127之间的编码，UTF-8将这些字符编码为相应的单个字节，因此ASCII文本文件也是良好的Python源文件。）
- en: 'You may choose to tell Python that a certain source file is written in a different
    encoding. In this case, Python uses that encoding to read the file. To let Python
    know that a source file is written with a nonstandard encoding, start your source
    file with a comment whose form must be, for example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择告诉Python，某个源文件采用了不同的编码。在这种情况下，Python将使用该编码读取文件。要让Python知道源文件使用了非标准编码，请在源文件开头加上以下形式的注释：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After coding:, write the name of an ASCII-compatible codec from the codecs module,
    such as utf-8 or iso-8859-1. Note that this *coding directive* comment (also known
    as an *encoding declaration*) is taken as such only if it is at the start of a
    source file (possibly after the “shebang line” covered in [“Running Python Programs”](ch02.xhtml#running_python_programs)).
    Best practice is to use utf-8 for all of your text files, including Python source
    files.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编码后，写入来自 codecs 模块的 ASCII 兼容编解码器的名称，例如 utf-8 或 iso-8859-1。请注意，这个*coding directive*注释（也称为*encoding
    declaration*）只有在它位于源文件的开头时才被视为这样（可能在[“运行 Python 程序”](ch02.xhtml#running_python_programs)中讨论的“shebang
    行”之后）。最佳做法是对所有文本文件，包括 Python 源文件，都使用 utf-8。
- en: Tokens
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 令牌
- en: Python breaks each logical line into a sequence of elementary lexical components
    known as *tokens*. Each token corresponds to a substring of the logical line.
    The normal token types are *identifiers*, *keywords*, *operators*, *delimiters*,
    and *literals*, which we cover in the following sections. You may freely use whitespace
    between tokens to separate them. Some whitespace separation is necessary between
    logically adjacent identifiers or keywords; otherwise, Python would parse them
    as a single longer identifier. For example, ifx is a single identifier; to write
    the keyword **if** followed by the identifier x, you need to insert some whitespace
    (typically only one space character, i.e., **if** x).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python 将每个逻辑行分解为一系列称为*令牌*的基本词法组件。每个令牌对应于逻辑行的子字符串。正常的令牌类型包括*标识符*、*关键字*、*运算符*、*分隔符*
    和*字面值*，我们将在以下部分介绍。您可以在令牌之间自由使用空格将它们分开。在逻辑上相邻的标识符或关键字之间需要一些空格分隔；否则，Python 会将它们解析为一个更长的标识符。例如，ifx
    是一个单独的标识符；要写出关键字 **if** 后跟标识符 x，您需要插入一些空格（通常只有一个空格字符，即 **if** x）。
- en: Identifiers
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标识符
- en: 'An *identifier* is a name used to specify a variable, function, class, module,
    or other object. An identifier starts with a letter (that is, any character that
    Unicode classifies as a letter) or an underscore (_), followed by zero or more
    letters, underscores, digits, or other characters that Unicode classifies as letters,
    digits, or combining marks (as defined in [Unicode Standard Annex #31](https://oreil.ly/iL3qY)).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*标识符*是用于指定变量、函数、类、模块或其他对象的名称。标识符以字母开头（即任何 Unicode 分类为字母的字符）或下划线(_)开头，后跟零个或多个字母、下划线、数字或其他
    Unicode 分类为字母、数字或组合标记的字符（如[Unicode 标准附录#31](https://oreil.ly/iL3qY)定义）。'
- en: 'For example, in the Unicode Latin-1 character range, the valid leading characters
    for an identifier are:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Unicode Latin-1 字符范围内，标识符的有效前导字符是：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After the leading character, the valid identifier body characters are just
    the same, plus the digits and · (Unicode MIDDLE DOT) character:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在领先字符之后，有效的标识符主体字符与之前相同，加上数字和·（Unicode 中间点）字符：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Case is significant: lowercase and uppercase letters are distinct. Punctuation
    characters such as @, $, and ! are not allowed in identifiers.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大小写有区分：小写和大写字母是不同的。不允许在标识符中使用@、$ 和 ! 等标点符号字符。
- en: Beware of Using Unicode Characters That Are Homoglyphs
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小心使用同形字符的 Unicode 字符
- en: 'Some Unicode characters look very similar to, if not indistinguishable from,
    other characters. Such character pairs are called *homoglyphs*. For instance,
    compare the capital letter A and the capital Greek letter alpha (Α). These are
    actually two different letters that just look very similar (or identical) in most
    fonts. In Python, they define two different variables:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Unicode 字符与其他字符非常相似，甚至难以区分。这种字符对称为*同形字符*。例如，比较大写字母 A 和大写希腊字母 alpha (Α)。这实际上是两个不同的字母，在大多数字体中看起来非常相似（或相同）。在
    Python 中，它们定义了两个不同的变量：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you want to make your Python code widely usable, we recommend a policy that
    all identifiers, comments, and documentation are written in English, avoiding,
    in particular, non-English homoglyph characters. For more information, see [PEP
    3131](https://oreil.ly/jVK5H).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使您的 Python 代码广泛可用，我们建议制定一个所有标识符、注释和文档均使用英文书写的政策，特别是避免使用非英文同形字符。有关更多信息，请参阅
    [PEP 3131](https://oreil.ly/jVK5H)。
- en: Unicode normalization strategies add further complexities (Python uses [NFKC
    normalization](https://oreil.ly/q944n) when parsing identifiers containing Unicode
    characters). See Jukka K. Korpela’s [*Unicode Explained*](https://learning.oreilly.com/library/view/unicode-explained/059610121X)
    (O’Reilly) and other technical information provided on the [Unicode website](https://unicode.org)
    and in the [books that site references](https://oreil.ly/92fm2) for more information.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 归一化策略增加了更多复杂性（Python 在解析包含 Unicode 字符的标识符时使用 [NFKC 归一化](https://oreil.ly/q944n)）。有关更多信息，请参阅
    Jukka K. Korpela 的《*Unicode Explained*》（O’Reilly）和 Unicode 网站上提供的其他技术信息及该网站引用的书籍。
- en: Avoid Normalizable Unicode Characters in Identifiers
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免在标识符中使用可归一化的 Unicode 字符
- en: 'Python may create unintended aliases between variables when names contain certain
    Unicode characters, by internally converting the name as shown in the Python script
    to one using normalized characters. For example, the letters ª and º normalize
    to the ASCII lowercase letters a and o, so variables using these letters could
    clash with other variables:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当名字包含特定 Unicode 字符时，Python 可能会在变量之间创建意外的别名，通过内部将名字转换为使用归一化字符的名字。例如，字母 ª 和 º
    归一化为 ASCII 小写字母 a 和 o，因此使用这些字母的变量可能与其他变量冲突：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is best to avoid using normalizable Unicode characters in your Python identifiers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最好避免在 Python 标识符中使用可归一化的 Unicode 字符。
- en: Normal Python style is to start class names with an uppercase letter, and most^([1](ch03.xhtml#ch01fn20))
    other identifiers with a lowercase letter. Starting an identifier with a single
    leading underscore indicates by convention that the identifier is meant to be
    private. Starting an identifier with two leading underscores indicates a *strongly
    private* identifier; if the identifier also *ends* with two trailing underscores,
    however, this means that it’s a language-defined special name. Identifiers composed
    of multiple words should be all lowercase with underscores between words, as in
    login_password. This is sometimes referred to as *snake case*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的正常风格是类名以大写字母开头，大多数^([1](ch03.xhtml#ch01fn20))其他标识符以小写字母开头。以单个前导下划线开头的标识符表明按照惯例该标识符应为私有。以两个前导下划线开头的标识符表示为*强制私有*标识符；然而，如果标识符同时以两个尾随下划线结尾，则意味着它是语言定义的特殊名称。由多个单词组成的标识符应全部小写，并在单词之间使用下划线，例如
    login_password。有时这被称为*蛇形命名法*。
- en: The Single Underscore (_) in the Interactive Interpreter
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式解释器中的单个下划线 (_)
- en: 'The identifier **_** (a single underscore) is special in interactive interpreter
    sessions: the interpreter binds **_** to the result of the last expression statement
    it has evaluated interactively, if any.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符 **_**（一个单下划线）在交互式解释器会话中是特殊的：如果有的话，解释器将 **_** 绑定到其最后评估的表达式语句的结果。
- en: Keywords
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键字
- en: 'Python has 35 *keywords*, or identifiers that it reserves for special syntactic
    uses. Like identifiers, keywords are case-sensitive. You cannot use keywords as
    regular identifiers (thus, they’re sometimes known as “reserved words”). Some
    keywords begin simple statements or clauses of compound statements, while other
    keywords are operators. We cover all the keywords in detail in this book, either
    in this chapter or in Chapters [4](ch04.xhtml#object_oriented_python), [6](ch06.xhtml#exceptions),
    and [7](ch07.xhtml#modules_and_packages). The keywords in Python are:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有 35 个*关键字*，或者说保留给特殊语法用途的标识符。与标识符一样，关键字是区分大小写的。你不能将关键字用作普通标识符（因此有时也称为“保留字”）。一些关键字用于开始简单语句或复合语句的子句，而其他关键字是运算符。我们在本书中详细介绍所有
    Python 的关键字，要么在本章节，要么在第 [4](ch04.xhtml#object_oriented_python)、[6](ch06.xhtml#exceptions)
    和 [7](ch07.xhtml#modules_and_packages) 章节。Python 中的关键字包括：
- en: '| **and** | **break** | **elif** | **from** | **is** | **pass** | **with**
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **and** | **break** | **elif** | **from** | **is** | **pass** | **with**
    |'
- en: '| **as** | **class** | **else** | **global** | **lambda** | **raise** | **yield**
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **as** | **class** | **else** | **global** | **lambda** | **raise** | **yield**
    |'
- en: '| **assert** | **continue** | **except** | **if** | **nonlocal** | **return**
    | **False** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **assert** | **continue** | **except** | **if** | **nonlocal** | **return**
    | **False** |'
- en: '| **async** | **def** | **finally** | **import** | **not** | **try** | **None**
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **async** | **def** | **finally** | **import** | **not** | **try** | **None**
    |'
- en: '| **await** | **del** | **for** | **in** | **or** | **while** | **True** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **await** | **del** | **for** | **in** | **or** | **while** | **True** |'
- en: You can list them by importing the keyword module and printing keyword.kwlist.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过导入 keyword 模块并打印 keyword.kwlist 来列出它们。
- en: '3.9+ In addition, Python 3.9 introduced the concept of *soft keywords*, which
    are keywords that are context sensitive. That is, they are language keywords for
    some specific syntax constructs, but outside of those constructs they may be used
    as variable or function names, so they are not *reserved* words. No soft keywords
    were defined in Python 3.9, but Python 3.10 introduced the following soft keywords:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 3.9+ 此外，Python 3.9 引入了*软关键字*的概念，这些关键字是上下文敏感的。也就是说，它们是某些特定语法结构的语言关键字，但在这些结构之外，它们可以用作变量或函数名，因此它们不是*保留*字。在
    Python 3.9 中没有定义软关键字，但 Python 3.10 引入了以下软关键字：
- en: '| **_** | **case** | **match** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **_** | **case** | **match** |'
- en: You can list them from the keyword module by printing keyword.softkwlist.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打印 keyword.softkwlist 模块来列出它们。
- en: Operators
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运算符
- en: 'Python uses nonalphanumeric characters and character combinations as operators.
    Python recognizes the following operators, which are covered in detail in [“Expressions
    and Operators”](#expressions_and_operators):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用非字母数字字符和字符组合作为运算符。 Python 识别以下运算符，这些运算符在[“表达式和运算符”](#expressions_and_operators)中有详细介绍：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can use @ as an operator (in matrix multiplication, covered in [Chapter 16](ch16.xhtml#numeric_processing)),
    although (pedantically speaking!) the character is actually a delimiter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 @ 作为运算符（在矩阵乘法中使用，详见[第 16 章](ch16.xhtml#numeric_processing)），尽管（从学术角度讲！）该字符实际上是一个分隔符。
- en: Delimiters
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分隔符
- en: 'Python uses the following characters and combinations as delimiters in various
    statements, expressions, and list, dictionary, and set literals and comprehensions,
    among other purposes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在各种语句、表达式和列表、字典和集合字面量以及推导中使用以下字符和组合作为分隔符，还有其他用途：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The period (.) can also appear in floating-point literals (e.g., 2.3) and imaginary
    literals (e.g., 2.3j). The last two rows are the augmented assignment operators,
    which are delimiters but also perform operations. We discuss the syntax for the
    various delimiters when we introduce the objects or statements using them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 句点 (.) 也可以出现在浮点文字中（例如，2.3）和虚数文字中（例如，2.3j）。最后两行是增强赋值运算符，它们是分隔符，但也执行操作。我们在介绍使用它们的对象或语句时讨论各种分隔符的语法。
- en: 'The following characters have special meanings as part of other tokens:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字符在其他标记中具有特殊含义：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ''' and " surround string literals. # outside of a string starts a comment,
    which ends at the end of the current line. \ at the end of a physical line joins
    the following physical line with it into one logical line; \ is also an escape
    character in strings. The characters $ and ?, and all control characters^([2](ch03.xhtml#ch01fn21))
    except whitespace, can never be part of the text of a Python program, except in
    comments or string literals.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ''' 和 " 括字符串文字。 # 在字符串外部开始注释，该注释在当前行结束。 \ 在物理行末尾将其后的物理行连接到其后形成一个逻辑行; \ 在字符串中也是一个转义字符。字符
    $ 和 ?，以及所有控制字符^([2](ch03.xhtml#ch01fn21)) 除了空白字符，永远不能成为 Python 程序文本的一部分，除非在注释或字符串文字中。'
- en: Literals
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字面值
- en: 'A *literal* is the direct denotation in a program of a data value (a number,
    string, or container). The following are number and string literals in Python:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*字面量*是程序中数据值（数字、字符串或容器）的直接表示。以下是 Python 中的数字和字符串字面量：'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Combining number and string literals with the appropriate delimiters, you can
    directly build many container types with those literals as values:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 结合适当的分隔符，可以直接使用数字和字符串字面值构建许多容器类型：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We cover the syntax for such container literals^([3](ch03.xhtml#ch01fn22)) in
    detail in [“Data Types”](#data_types), when we discuss the various data types
    Python supports. We refer to these expressions as literals throughout this book,
    as they describe literal (i.e., not requiring additional evaluation) values in
    the source code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“数据类型”](#data_types)详细讨论此类容器字面量^([3](ch03.xhtml#ch01fn22)) 的语法，当我们讨论 Python
    支持的各种数据类型时。在本书中，我们将这些表达式称为字面量，因为它们描述源代码中的字面（即不需要额外评估）值。
- en: Statements
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句
- en: You can look at a Python source file as a sequence of simple and compound statements.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 Python 源文件视为简单和复合语句的序列。
- en: Simple statements
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单语句
- en: A *simple statement* is one that contains no other statements. A simple statement
    lies entirely within a logical line. As in many other languages, you may place
    more than one simple statement on a single logical line, with a semicolon (;)
    as the separator. However, using one statement per line is the usual and recommended
    Python style, and it makes programs more readable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单语句*是不包含其他语句的语句。简单语句完全位于一个逻辑行内。与许多其他语言一样，你可以在单个逻辑行上放置多个简单语句，分号（;）作为分隔符。然而，使用每行一个语句是通常和推荐的
    Python 风格，它使程序更易读。'
- en: Any *expression* can stand on its own as a simple statement (we discuss expressions
    in [“Expressions and Operators”](#expressions_and_operators)). When you’re working
    interactively, the interpreter shows the result of an expression statement you
    enter at the prompt (>>>) and binds the result to a global variable named _ (underscore).
    Apart from interactive sessions, expression statements are useful only to call
    functions (and other *callables*) that have side effects (e.g., perform output,
    change arguments or global variables, or raise exceptions).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 任何*表达式*都可以作为一个独立的简单语句存在（我们在[“表达式和运算符”](#expressions_and_operators)中讨论表达式）。当你在交互式环境中工作时，解释器会显示你在提示符（>>>）下输入的表达式语句的结果，并将结果绑定到名为
    _（下划线）的全局变量中。除了交互式会话外，表达式语句仅用于调用具有副作用的函数（和其他*可调用对象*）（例如执行输出、更改参数或全局变量，或引发异常）。
- en: An *assignment* is a simple statement that assigns values to variables, as we
    discuss in [“Assignment Statements”](#assignment_statements). An assignment in
    Python using the = operator is a statement and can never be part of an expression.
    To perform an assignment as part of an expression, you must use the := (known
    as the “walrus”) operator. You’ll see some examples of using := in [“Assignment
    Expressions”](#assignment_expressions).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*赋值语句*是将值分配给变量的简单语句，正如我们在[“赋值语句”](#assignment_statements)中讨论的那样。在 Python 中，使用
    = 运算符进行赋值是一种语句，永远不能作为表达式的一部分。要作为表达式的一部分执行赋值，必须使用 :=（被称为“海象”）运算符。你将在[“赋值表达式”](#assignment_expressions)中看到一些使用
    := 的例子。'
- en: Compound statements
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复合语句
- en: 'A *compound statement* contains one or more other statements and controls their
    execution. A compound statement has one or more *clauses*, aligned at the same
    indentation. Each clause has a *header* starting with a keyword and ending with
    a colon (:), followed by a *body*, which is a sequence of one or more statements.
    Normally, these statements, also known as a *block*, are on separate logical lines
    after the header line, indented four spaces rightward. The block lexically ends
    when the indentation returns to that of the clause header (or further left from
    there, to the indentation of some enclosing compound statement). Alternatively,
    the body can be a single simple statement following the : on the same logical
    line as the header. The body may also consist of several simple statements on
    the same line with semicolons between them, but, as we’ve already mentioned, this
    is not good Python style.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*复合语句*包含一个或多个其他语句并控制它们的执行。复合语句有一个或多个*子句*，这些子句在相同的缩进级别上对齐。每个子句有一个以关键字开头并以冒号结尾的*头部*，后面跟着一个*体*，即一个或多个语句的序列。通常，这些语句，也称为*块*，在头部行之后的单独逻辑行上缩进四个空格。块在缩进返回到子句头部的缩进级别时（或者进一步向左到某个封闭复合语句的缩进级别时）在词法上结束。或者，体可以是跟在头部冒号后同一逻辑行上的单个简单语句。体也可以由几个简单语句组成，这些语句之间用分号隔开，但正如我们已经提到的，这不是良好的
    Python 风格。'
- en: Data Types
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: The operation of a Python program hinges on the data it handles. Data values
    in Python are known as *objects*; each object, aka *value*, has a *type*. An object’s
    type determines which operations the object supports (in other words, which operations
    you can perform on the value). The type also determines the object’s *attributes*
    and *items* (if any) and whether the object can be altered. An object that can
    be altered is known as a *mutable object*, while one that cannot be altered is
    an *immutable object*. We cover object attributes and items in [“Object attributes
    and items”](#object_attributes_and_items).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序的运行依赖于它处理的数据。Python 中的数据值称为*对象*；每个对象，又称*值*，都有一个*类型*。对象的类型决定了对象支持哪些操作（换句话说，你可以在值上执行哪些操作）。类型还决定了对象的*属性*和*项*（如果有的话），以及对象是否可以被修改。可以修改的对象称为*可变对象*，而不可修改的对象称为*不可变对象*。我们在[“对象属性和项”](#object_attributes_and_items)中涵盖对象的属性和项。
- en: The built-in type(*obj*) function accepts any object as its argument and returns
    the type object that is the type of *obj*. The built-in function isinstance(*obj*,
    *type*) returns **True** when object *obj* has type *type* (or any subclass thereof);
    otherwise, it returns **False**. The *type* argument of isinstance may also be
    a tuple of types (3.10+ or multiple types joined with the | operator), in which
    case it returns **True** if the type of *obj* matches any of the given types,
    or any subclasses of those types.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 内建函数 type(*obj*) 接受任何对象作为其参数，并返回对象 *obj* 的类型对象。 内建函数 isinstance(*obj*, *type*)
    在对象 *obj* 的类型是 *type*（或其任何子类）时返回 **True**；否则返回 **False**。 isinstance 的 *type*
    参数也可以是类型元组（3.10+ 或使用 | 操作符连接的多个类型），在这种情况下，如果 *obj* 的类型与给定类型的任何一个匹配，或其子类，则返回 **True**。
- en: Python has built-in types for fundamental data types such as numbers, strings,
    tuples, lists, dictionaries, and sets, as covered in the following sections. You
    can also create user-defined types, known as *classes*, as discussed in [“Classes
    and Instances”](ch04.xhtml#classes_and_instances).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python 具有用于基本数据类型（如数字、字符串、元组、列表、字典和集合）的内建类型，如下一节所述。 您还可以创建用户定义的类型，称为 *类*，如 [“类和实例”](ch04.xhtml#classes_and_instances)
    中所述。
- en: Numbers
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: The built-in numeric types in Python include integers, floating-point numbers,
    and complex numbers. The standard library also offers decimal floating-point numbers,
    covered in [“The decimal Module”](ch16.xhtml#the_decimal_module), and fractions,
    covered in [“The fractions Module”](ch16.xhtml#the_fractions_module). All numbers
    in Python are immutable objects; therefore, when you perform an operation on a
    number object, you produce a new number object. We cover operations on numbers,
    also known as arithmetic operations, in [“Numeric Operations”](#numeric_operations).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的内建数值类型包括整数、浮点数和复数。 标准库还提供了十进制浮点数（在 [“decimal 模块”](ch16.xhtml#the_decimal_module)
    中介绍）和分数（在 [“fractions 模块”](ch16.xhtml#the_fractions_module) 中介绍）。 Python 中的所有数字都是不可变对象；因此，当您对数字对象执行操作时，将产生新的数字对象。
    我们在 [“数值操作”](#numeric_operations) 中涵盖了数字操作，也称为算术操作。
- en: 'Numeric literals do not include a sign: a leading + or -, if present, is a
    separate operator, as discussed in [“Arithmetic Operations”](#arithmetic_operations).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 数值字面量不包括符号：如果存在，前导 + 或 - 是单独的运算符，如 [“算术运算”](#arithmetic_operations) 中所讨论的。
- en: Integer numbers
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数数字
- en: 'Integer literals can be decimal, binary, octal, or hexadecimal. A decimal literal
    is a sequence of digits in which the first digit is nonzero. A binary literal
    is 0b followed by a sequence of binary digits (0 or 1). An octal literal is 0o
    followed by a sequence of octal digits (0 to 7). A hexadecimal literal is 0x followed
    by a sequence of hexadecimal digits (0 to 9 and A to F, in either upper- or lowercase).
    For example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 整数字面量可以是十进制、二进制、八进制或十六进制。 十进制字面量是以非零开头的数字序列。 二进制字面量是 0b 后跟一系列二进制数字（0 或 1）。 八进制字面量是
    0o 后跟一系列八进制数字（0 到 7）。 十六进制字面量是 0x 后跟一系列十六进制数字（0 到 9 和 A 到 F，大小写不限）。 例如：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Integers can represent values in the range ±2**sys.maxsize, or roughly ±10^(2.8e18).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 整数可以表示范围在 ±2**sys.maxsize，或大约 ±10^(2.8e18) 内的值。
- en: '[Table 3-1](#int_methods) lists the methods supported by an int object *i*.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-1](#int_methods) 列出了整数对象 *i* 支持的方法。'
- en: Table 3-1\. int methods
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. 整数方法
- en: '| as_inte⁠g⁠e⁠r⁠_​r⁠a⁠t⁠i⁠o | *i*.as_integer_ratio() 3.8+ Returns a tuple of
    two ints, whose exact ratio is the original integer value. (Since *i* is always
    int, the tuple is always (*i*, 1); compare with float.as_integer_ratio.) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| as_inte⁠g⁠e⁠r⁠_​r⁠a⁠t⁠i⁠o | *i*.as_integer_ratio() 3.8+ 返回一个由两个整数构成的元组，其精确比例是原始整数值。（由于
    *i* 总是 int，因此元组始终是 (*i*, 1)；与 float.as_integer_ratio 进行比较。）|'
- en: '| bit_count | *i*.bit_count() 3.10+ Returns the number of ones in the binary
    representation of abs(*i*). |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| bit_count | *i*.bit_count() 3.10+ 返回 abs(*i*) 二进制表示中 1 的个数。|'
- en: '| bit_length | *i*.bit_length() Returns the minimum number of bits needed to
    represent *i*. Equivalent to the length of the binary representation of abs(*i*),
    after removing ''b'' and all leading zeros. (0).bit_length() returns 0. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| bit_length | *i*.bit_length() 返回表示 *i* 所需的最小位数。 相当于 abs(*i*) 的二进制表示的长度，在去除
    ''b'' 和所有前导零后。（0).bit_length() 返回 0。|'
- en: '| from_bytes | int.from_bytes(*bytes_value*, *byteorder*, *, *signed*=**False**)
    Returns an int from the bytes in *bytes_value* following the same argument usage
    as in to_bytes. (Note that from_bytes is a class method of int.) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| from_bytes | int.from_bytes(*bytes_value*, *byteorder*, *, *signed*=**False**)
    从 *bytes_value* 中的字节返回一个整数，参数使用与 to_bytes 相同。（注意，from_bytes 是 int 的类方法。）|'
- en: '| to_bytes | *i*.to_bytes(*length*, *byteorder*, *, *signed*=**False**) Returns
    a bytes value *length* bytes in size representing the binary value of *i*. *byteorder*
    must be the str value ''big'' or ''little'', indicating whether the return value
    should be big-endian (most significant byte first) or little-endian (least significant
    byte first). For example, (258).to_bytes(2, ''big'') returns b''\x01\x02'', and
    (258).to_bytes(2, ''little'') returns b''\x02\x01''. When *i* < 0 and *signed*
    is **True**, to_bytes returns the bytes of *i* represented in two’s complement.
    When *i* < 0 and *signed* is **False**, to_bytes raises OverflowError. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| to_bytes | *i*.to_bytes(*length*, *byteorder*, *, *signed*=**False**) 返回一个大小为*length*字节的bytes值，表示*i*的二进制值。*byteorder*必须是''str''值''big''或''little''，表示返回值应该是大端（最高有效字节优先）或小端（最低有效字节优先）。例如，(258).to_bytes(2,
    ''big'') 返回 b''\x01\x02''，而(258).to_bytes(2, ''little'') 返回 b''\x02\x01''。当*i*
    < 0且*signed*为**True**时，to_bytes返回*i*的二进制补码表示。当*i* < 0且*signed*为**False**时，to_bytes引发OverflowError。
    |'
- en: Floating-point numbers
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数
- en: 'A floating-point literal is a sequence of decimal digits that includes a decimal
    point (.), an exponent suffix (e or E, optionally followed by + or -, followed
    by one or more digits), or both. The leading character of a floating-point literal
    cannot be e or E; it may be any digit or a period (.) followed by a digit. For
    example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数文字是一个包含十进制数字序列的字面量，包括小数点(.)，指数后缀(e或E，可选地跟着+或-)，或两者。浮点文字的前导字符不能是e或E；它可以是任何数字或小数点(.)后跟一个数字。例如：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A Python floating-point value corresponds to a C double and shares its limits
    of range and precision: typically 53 bits—about 15 digits—of precision on modern
    platforms. (For the exact range and precision of floating-point values on the
    platform where the code is running, and many other details, see the online documentation
    on [sys.float_info](https://oreil.ly/kEa6H).)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Python浮点数值对应于C双精度浮点数，并共享其范围和精度的限制：通常是53位——大约15位数字——在现代平台上的精度。 (关于代码运行平台上浮点数值的确切范围和精度以及许多其他细节，请参见[sys.float_info](https://oreil.ly/kEa6H)的在线文档。)
- en: '[Table 3-2](#float_methods) lists the methods supported by a float object *f*.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 3-2](#float_methods) 列出了浮点对象*f*支持的方法。'
- en: Table 3-2\. float methods
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 3-2\. 浮点方法
- en: '| as_inte⁠g⁠e⁠r⁠_​r⁠a⁠t⁠i⁠o | *f*.as_integer_ratio() Returns a tuple of two
    ints, a numerator and a denominator, whose exact ratio is the original float value,
    *f*. For example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '| as_inte⁠g⁠e⁠r⁠_​r⁠a⁠t⁠i⁠o | *f*.as_integer_ratio() 返回一个由两个整数组成的元组，分子和分母，其精确比值是原始浮点值*f*。例如：'
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| from_hex | float.from_hex(*s*) Returns a float value from the hexadecimal
    str value *s*. *s* can be of the form returned by f.hex(), or simply a string
    of hexadecimal digits. When the latter is the case, from_hex returns float(int(*s*,
    16)). |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| from_hex | float.from_hex(*s*) 从十六进制字符串值*s*返回一个浮点值。*s*可以是f.hex()返回的形式，或者只是一个十六进制数字字符串。当后者是这种情况时，from_hex返回float(int(*s*,
    16))。 |'
- en: '| hex | *f*.hex() Returns a hexadecimal representation of *f*, with leading
    0x and trailing p and exponent. For example, (99.0).hex() returns ''0x1.8c00000000000p+6''.
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| hex | *f*.hex() 返回一个十六进制表示的*f*，包括前缀0x和尾随的p和指数。例如，(99.0).hex() 返回 ''0x1.8c00000000000p+6''。
    |'
- en: '| is_integer | *f*.is_integer() Returns a bool value indicating if *f* is an
    integer value. Equivalent to int(*f*) == *f*. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| is_integer | *f*.is_integer() 返回一个布尔值，指示*f*是否为整数值。等同于int(*f*) == *f*。'
- en: Complex numbers
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复数
- en: 'A complex number is made up of two floating-point values, one each for the
    real and imaginary parts. You can access the parts of a complex object *z* as
    read-only attributes *z*.real and *z*.imag. You can specify an imaginary literal
    as any floating-point or integer decimal literal followed by a j or J:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 复数由两个浮点值组成，分别用于实部和虚部。您可以访问复数对象*z*的部分作为只读属性*z*.real和*z*.imag。您可以将虚数文字指定为任何浮点或整数十进制文字，后跟j或J：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The j at the end of the literal indicates the square root of -1, as commonly
    used in electrical engineering (some other disciplines use i for this purpose,
    but Python uses j). There are no other complex literals. To denote any constant
    complex number, add or subtract a floating-point (or integer) literal and an imaginary
    one. For example, to denote the complex number that equals 1, use expressions
    like 1+0j or 1.0+0.0j. Python performs the addition at compile time, so there’s
    no need to worry about overhead.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 文字文字末尾的 j 表示负一的平方根，如在电气工程中通常使用的（其他学科使用 i，但 Python 使用 j）。没有其他复数文字。要表示任何常数复数，请加或减一个浮点数（或整数）文字和一个虚数。例如，要表示等于
    1 的复数，请使用表达式如 1+0j 或 1.0+0.0j。Python 在编译时执行加法，因此不必担心开销。
- en: 'A complex object *c* supports a single method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 复数对象 *c* 支持一个单一方法：
- en: '| conjugate | *c*.conjugate() Returns a new complex number complex(*c*.real,
    -*c*.imag) (i.e., the return value has *c*’s imag attribute with a sign change).
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 共轭 | *c*.conjugate() 返回一个新的复数 complex(*c*.real, -*c*.imag)（即返回值具有 *c* 的 imag
    属性，带有符号变化）。 |'
- en: See [“The math and cmath Modules”](ch16.xhtml#the_math_and_cmath_modules) for
    several other functions that use floats and complex numbers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 [“数学和 cmath 模块”](ch16.xhtml#the_math_and_cmath_modules) 以及使用浮点数和复数的其他函数。
- en: Underscores in numeric literals
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字文字中的下划线
- en: 'To aid with visual assessment of the magnitude of a number, numeric literals
    can include single underscore (_) characters between digits or after any base
    specifier. It’s not only decimal numeric constants that can benefit from this
    notational freedom, however, as these examples show:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助直观评估数字的大小，数字文字可以在数字之间或任何基数指定符号后包括单个下划线 (_)。然而，并不仅仅是十进制数字常量可以从这种符号自由中获益，正如以下示例所示：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is no enforcement of location of the underscores (except that two may
    not occur consecutively), so 123_456 and 12_34_56 both represent the same int
    value as 123456.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线的位置规定并无强制要求（除了不能连续出现两个），因此 123_456 和 12_34_56 都表示相同的整数值为 123456。
- en: Sequences
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列
- en: A *sequence* is an ordered container of items, indexed by integers. Python has
    built-in sequence types known as strings (bytes or str), tuples, and lists. Library
    and extension modules provide other sequence types, and you can write others yourself
    (as discussed in [“Sequences”](#sequence)”). You can manipulate sequences in a
    variety of ways, as discussed in [“Sequence Operations”](#sequence_operations).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列* 是一种按整数索引的有序项容器。Python 具有称为字符串（bytes 或 str）、元组和列表的内置序列类型。库和扩展模块提供其他序列类型，您也可以自己编写（如在
    [“序列”](#sequence) 中讨论的）。您可以以多种方式操作序列，如在 [“序列操作”](#sequence_operations) 中讨论的。'
- en: Iterables
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可迭代对象
- en: 'A Python concept that captures in abstract the iteration behavior of sequences
    is that of *iterables*, covered in [“The for Statement”](#the_for_statement).
    All sequences are iterable: whenever we say you can use an iterable, you can use
    a sequence (for example, a list).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中一个抽象概念是 *可迭代对象*，捕捉序列的迭代行为，详细讨论在 [“for 语句”](#the_for_statement) 中涵盖。所有序列都是可迭代的：每当我们说可以使用可迭代对象时，都可以使用序列（例如列表）。
- en: 'Also, when we say that you can use an iterable we usually mean a *bounded*
    iterable: an iterable that eventually stops yielding items. In general, sequences
    are bounded. Iterables can be unbounded, but if you try to use an unbounded iterable
    without special precautions, you could produce a program that never terminates,
    or one that exhausts all available memory.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们说可以使用可迭代对象时，通常意味着一个 *有界* 的可迭代对象：一个最终停止产生项的可迭代对象。一般来说，序列是有界的。可迭代对象可以是无界的，但如果您尝试使用无界可迭代对象而不采取特殊预防措施，可能会导致程序永远不会终止，或者耗尽所有可用内存。
- en: Strings
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Python has two built-in string types, str and bytes.^([4](ch03.xhtml#ch01fn23))
    A str object is a sequence of characters used to store and represent text-based
    information. A bytes object stores and represents arbitrary sequences of binary
    bytes. Strings of both types in Python are *immutable*: when you perform an operation
    on strings, you always produce a new string object of the same type, rather than
    mutating an existing string. String objects provide many methods, as discussed
    in detail in [“Methods of String Objects”](ch09.xhtml#methods_of_string_objects).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有两种内置的字符串类型，str 和 bytes。^([4](ch03.xhtml#ch01fn23)) str 对象是一系列字符，用于存储和表示基于文本的信息。bytes
    对象存储和表示任意二进制字节序列。Python 中的这两种字符串都是 *不可变的*：当您对字符串执行操作时，总是产生同一类型的新字符串对象，而不是变异现有字符串。字符串对象提供许多方法，如在
    [“字符串对象的方法”](ch09.xhtml#methods_of_string_objects) 中详细讨论的。
- en: 'A string literal can be quoted or triple-quoted. A quoted string is a sequence
    of zero or more characters within matching quotes, single ('') or double (").
    For example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量可以用引号或三引号括起来。一个被引号括起来的字符串是一个在匹配的引号之间的零个或多个字符序列，单引号（'）或双引号（"）。例如：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The two different kinds of quotes function identically; having both lets you
    include one kind of quote inside of a string specified with the other kind, with
    no need to escape quote characters with the backslash character (\):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 两种不同的引号功能相同；拥有这两者可以让你在指定的字符串中包含另一种引号，而无需使用反斜杠字符(\)进行转义：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Many (but far from all) style guides that pronounce on the subject suggest that
    you use single quotes when the choice is otherwise indifferent. The popular code
    formatter black prefers double quotes; this choice is controversial enough to
    have been the main inspiration for a “fork,” blue, whose main difference from
    black is to prefer single quotes instead, as most of this book’s authors do.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 许多（但远非所有）有关此主题的风格指南建议，当选择无关紧要时，使用单引号。流行的代码格式化工具 black 更喜欢使用双引号；这个选择足够有争议，足以成为“分支”
    blue 的主要灵感，其与 black 的主要区别在于更喜欢使用单引号，就像本书的大多数作者一样。
- en: 'To have a string literal span multiple physical lines, you can use a \ as the
    last character of a line to indicate that the next line is a continuation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让字符串字面量跨越多个物理行，你可以在行的最后一个字符使用 \，以表示下一行是续行：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can also embed a newline in the string to make it contain two lines rather
    than just one:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在字符串中嵌入换行符，使其包含两行而不仅仅是一行：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A better approach, however, is to use a triple-quoted string, enclosed by matching
    triplets of quote characters ('''''', or better, as mandated by [PEP 8](https://oreil.ly/RmvLN),
    """). In a triple-quoted string literal, line breaks in the literal remain as
    newline characters in the resulting string object:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更好的方法是使用三引号字符串，由匹配的三重引号字符（'''，或者更好的是根据[PEP 8](https://oreil.ly/RmvLN)规定的"""）包围。在三引号字符串字面量中，字面量中的换行符保持为结果字符串对象中的换行符：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can start a triple-quoted literal with an escaped newline, to avoid having
    the first line of the literal string’s content at a different indentation level
    from the rest. For example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用一个转义换行符开始一个三引号字面量，以避免字面量字符串内容的第一行与其余内容的缩进级别不同。例如：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The only character that cannot be part of a triple-quoted string literal is
    an unescaped backslash, while a single-quoted string literal cannot contain unescaped
    backslashes, nor line ends, nor the quote character that encloses it. The backslash
    character starts an *escape sequence*, which lets you introduce any character
    in either kind of string literal. See [Table 3-3](#string_escape_sequences) for
    a list of all of Python’s string escape sequences.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一不能成为三引号字符串字面量一部分的字符是未转义的反斜杠，而单引号字符串字面量不能包含未转义的反斜杠，也不能包含封闭它的引号字符。反斜杠字符开始一个*转义序列*，它让你在任意类型的字符串字面量中引入任何字符。请参见[表
    3-3](#string_escape_sequences)以获取 Python 所有字符串转义序列的列表。
- en: Table 3-3\. String escape sequences
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-3\. 字符串转义序列
- en: '| Sequence | Meaning | ASCII / ISO code |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 序列 | 含义 | ASCII / ISO 代码 |'
- en: '| --- | --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| \*<newline>* | Ignore end of line | None |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|   | \*<newline>* | 忽略行尾 | 无 |'
- en: '| \\ | Backslash | 0x5c |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| \\ | 反斜杠 | 0x5c |'
- en: '| \'' | Single quote | 0x27 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| \'' | 单引号 | 0x27 |'
- en: '| \" | Double quote | 0x22 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| \" | 双引号 | 0x22 |'
- en: '| \a | Bell | 0x07 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| \a | 响铃 | 0x07 |'
- en: '| \b | Backspace | 0x08 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| \b | 退格符 | 0x08 |'
- en: '| \f | Form feed | 0x0c |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| \f | 换页符 | 0x0c |'
- en: '| \n | Newline | 0x0a |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| \n | 换行符 | 0x0a |'
- en: '| \r | Carriage return | 0x0d |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| \r | 回车符 | 0x0d |'
- en: '| \t | Tab | 0x09 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| \t | 制表符 | 0x09 |'
- en: '| \v | Vertical tab | 0x0b |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| \v | 垂直制表符 | 0x0b |'
- en: '| \ *DDD* | Octal value *DDD* | As given |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| \ *DDD* | 八进制值 *DDD* | 如给定 |'
- en: '| \x *XX* | Hexadecimal value *XX* | As given |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| \x *XX* | 十六进制值 *XX* | 如给定 |'
- en: '| \N{*name*} | Unicode character | As given |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| \N{*name*} | Unicode 字符 | 如给定 |'
- en: '| \ *o* | Any other character *o*: a two-character string | 0x5c + as given
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| \ *o* | 任何其他字符 *o*：一个由两字符组成的字符串 | 0x5c + 如给定 |'
- en: 'A variant of a string literal is a *raw string literal*. The syntax is the
    same as for quoted or triple-quoted string literals, except that an r or R immediately
    precedes the leading quote. In raw string literals, escape sequences are not interpreted
    as in [Table 3-3](#string_escape_sequences), but are literally copied into the
    string, including backslashes and newline characters. Raw string literal syntax
    is handy for strings that include many backslashes, especially regular expression
    patterns (see [“Pattern String Syntax”](ch10.xhtml#pattern_string_syntax)) and
    Windows absolute filenames (which use backslashes as directory separators). A
    raw string literal cannot end with an odd number of backslashes: the last one
    would be taken as escaping the terminating quote.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串文字的一种变体是*原始字符串文字*。语法与带引号或三重引号字符串文字相同，只是在开头引号之前立即加上 r 或 R。在原始字符串文字中，转义序列不会像在[表 3-3](#string_escape_sequences)中那样被解释，而是直接复制到字符串中，包括反斜杠和换行符。原始字符串文字的语法对包含许多反斜杠的字符串特别方便，特别是正则表达式模式（参见[“模式字符串语法”](ch10.xhtml#pattern_string_syntax)）和Windows绝对文件名（这些文件名使用反斜杠作为目录分隔符）。原始字符串文字不能以奇数个反斜杠结尾：最后一个反斜杠将被视为转义终止引号。
- en: Raw and Triple-Quoted String Literals Are Not Different Types
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始字符串和三重引号字符串文字并非不同类型
- en: Raw and triple-quoted string literals are *not* types different from other strings;
    they are just alternative syntaxes for literals of the usual two string types,
    bytes and str.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串和三重引号字符串文字*并非*与其他字符串类型不同；它们只是通常的两种字符串类型（bytes 和 str）的文字的替代语法。
- en: In str literals, you can use \u followed by four hex digits, or \U followed
    by eight hex digits, to denote Unicode characters; you can also include the escape
    sequences listed in [Table 3-3](#string_escape_sequences). str literals can also
    include Unicode characters using the escape sequence \N{*name*}, where *name*
    is a standard [Unicode name](http://www.unicode.org/charts). For example, \N{Copyright
    Sign} indicates a Unicode copyright sign character (©).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 str 文字中，您可以使用\u后跟四个十六进制数字，或者\U后跟八个十六进制数字来表示 Unicode 字符；您还可以使用在[表 3-3](#string_escape_sequences)中列出的转义序列。str
    文字还可以使用转义序列\N{*name*}来包含Unicode字符，其中*name*是标准的[Unicode名称](http://www.unicode.org/charts)。例如，\N{Copyright
    Sign}表示一个Unicode版权符号字符（©）。
- en: '*Formatted string literals* (commonly called *f-strings*) let you inject formatted
    expressions into your string “literals,” which are therefore no longer constant,
    but rather are subject to evaluation at execution time. The formatting process
    is described in [“String Formatting”](ch09.xhtml#string_formatting). From a purely
    syntactic point of view, these new literals can be regarded as just another kind
    of string literal.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*格式化字符串文字*（通常称为*f-strings*）允许您将格式化表达式注入到您的字符串“文字”中，因此它们不再是常量，而是在执行时进行评估。格式化过程在[“字符串格式化”](ch09.xhtml#string_formatting)中描述。从纯语法的角度来看，这些新的文字可以被视为另一种字符串文字。'
- en: 'Multiple string literals of any kind—quoted, triple-quoted, raw, bytes, formatted—can
    be adjacent, with optional whitespace in between (as long as you do not mix strings
    containing text and bytes). The compiler concatenates such adjacent string literals
    into a single string object. Writing a long string literal in this way lets you
    present it readably across multiple physical lines and gives you an opportunity
    to insert comments about parts of the string. For example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的多个字符串文字（引号、三重引号、原始、bytes、格式化）可以相邻，中间可以有可选的空白（只要不混合包含文本和字节的字符串）。编译器将这些相邻的字符串文字连接成一个单一的字符串对象。以这种方式编写长字符串文字使您可以在多个物理行上可读地呈现它，并且可以在字符串的各个部分插入评论。例如：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The string assigned to marypop is a single word of 34 characters.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给 marypop 的字符串是一个包含 34 个字符的单词。
- en: bytes objects
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bytes 对象
- en: A bytes object is an ordered sequence of ints from 0 to 255. bytes objects are
    usually encountered when reading data from or writing data to a binary source
    (e.g, a file, a socket, or a network resource).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: bytes 对象是从 0 到 255 的整数的有序序列。通常在从二进制源（例如文件、套接字或网络资源）读取数据或写入数据时遇到 bytes 对象。
- en: 'A bytes object can be initialized from a list of ints or from a string of characters.
    A bytes literal has the same syntax as a str literal, prefixed with ''b'':'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从整数列表或字符字符串初始化 bytes 对象。bytes 文字具有与 str 文字相同的语法，前缀为 'b'：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To convert a bytes object to a str, use the bytes.decode method. To convert
    a str object to a bytes object, use the str.encode method, as described in detail
    in [Chapter 9](ch09.xhtml#strings_and_things).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字节对象转换为字符串，使用bytes.decode方法。要将字符串对象转换为字节对象，使用str.encode方法，如[第九章](ch09.xhtml#strings_and_things)中详细描述的那样。
- en: bytearray objects
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字节数组对象
- en: 'A bytearray is a *mutable* ordered sequence of ints from 0 to 255; like a bytes
    object, you can construct it from a sequence of ints or characters. In fact, apart
    from mutability, it is just like a bytes object. As they are mutable, bytearray
    objects support methods and operators that modify elements within the array of
    byte values:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 字节数组是一个从0到255的*可变*有序整数序列；像字节对象一样，你可以用整数或字符的序列构造它。实际上，除了可变性外，它与字节对象完全相同。由于它们是可变的，字节数组对象支持修改数组中字节值的方法和运算符：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Chapter 9](ch09.xhtml#strings_and_things) has additional material on creating
    and working with bytearray objects.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[第九章](ch09.xhtml#strings_and_things)包含有关创建和使用字节数组对象的其他材料。'
- en: Tuples
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: A *tuple* is an immutable ordered sequence of items. The items of a tuple are
    arbitrary objects and may be of different types. You can use mutable objects (such
    as lists) as tuple items, but best practice is generally to avoid doing so.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*元组*是一个不可变的有序项序列。元组的项是任意对象，可以是不同类型的。你可以使用可变对象（如列表）作为元组的项，但通常最好避免这样做。
- en: 'To denote a tuple, use a series of expressions (the items of the tuple) separated
    by commas (,);^([5](ch03.xhtml#ch01fn24)) if every item is a literal, the whole
    construct is a *tuple literal*. You may optionally place a redundant comma after
    the last item. You can group tuple items within parentheses, but the parentheses
    are necessary only where the commas would otherwise have another meaning (e.g.,
    in function calls), or to denote empty or nested tuples. A tuple with exactly
    two items is also known as a *pair*. To create a tuple of one item, add a comma
    to the end of the expression. To denote an empty tuple, use an empty pair of parentheses.
    Here are some tuple literals, the second of which uses optional parentheses:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示元组，使用一系列用逗号（,）分隔的表达式（元组的项）；^([5](ch03.xhtml#ch01fn24))如果每个项都是字面值，整个结构就是一个*元组字面值*。你可以选择在最后一项后面加一个多余的逗号。你可以用括号将元组项分组，但只有在逗号在其他情况下会有另一种含义（例如，在函数调用中）或者表示空或嵌套元组时才需要括号。恰好有两个项的元组也称为*对*。要创建一个只有一个项的元组，在表达式末尾加一个逗号。要表示一个空元组，使用一个空的括号对。以下是一些元组字面值的例子，第二个例子使用了可选的括号：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can also call the built-in type tuple to create a tuple. For example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以调用内置类型元组来创建一个元组。例如：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This builds a tuple equal to that denoted by the tuple literal:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建一个等同于元组字面值所示的元组：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: tuple() without arguments creates and returns an empty tuple, like (). When
    *x* is iterable, tuple(*x*) returns a tuple whose items are the same as those
    in *x*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: tuple()没有参数时创建并返回一个空元组，就像()一样。当*x*可迭代时，tuple(*x*)返回一个与*x*中的项相同的元组。
- en: Lists
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: 'A *list* is a mutable ordered sequence of items. The items of a list are arbitrary
    objects and may be of different types. To denote a list, use a series of expressions
    (the items of the list) separated by commas (,), within brackets ([]);^([6](ch03.xhtml#ch01fn25))
    if every item is a literal, the whole construct is a *list literal*. You may optionally
    place a redundant comma after the last item. To denote an empty list, use an empty
    pair of brackets. Here are some examples of list literals:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*列表*是一个可变的有序项序列。列表的项是任意对象，可以是不同类型的。要表示一个列表，使用方括号([])内的逗号（,）分隔的表达式（列表的项）；^([6](ch03.xhtml#ch01fn25))如果每个项都是字面值，整个结构就是一个*列表字面值*。你可以选择在最后一项后面加一个多余的逗号。要表示一个空列表，使用一个空的方括号对。以下是一些列表字面值的例子：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also call the built-in type list to create a list. For example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以调用内置类型列表来创建一个列表。例如：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This builds a list equal to that denoted by the list literal:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建一个等同于列表字面值所示的列表：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: list() without arguments creates and returns an empty list, like []. When *x*
    is iterable, list(*x*) returns a list whose items are the same as those in *x*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: list()没有参数时创建并返回一个空列表，就像[]一样。当*x*可迭代时，list(*x*)返回一个与*x*中的项相同的列表。
- en: You can also build lists with list comprehensions, covered in [“List comprehensions”](#list_comprehensions).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用列表推导式构建列表，详见[“列表推导式”](#list_comprehensions)。
- en: Sets
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: Python has two built-in set types, set and frozenset, to represent arbitrarily
    ordered collections of unique items. Items in a set may be of different types,
    but they must all be *hashable* (see hash in [Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)).
    Instances of type set are mutable, and thus not hashable; instances of type frozenset
    are immutable and hashable. You can’t have a set whose items are sets, but you
    can have a set (or frozenset) whose items are frozensets. Sets and frozensets
    are *not* ordered.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有两种内置的集合类型，set 和 frozenset，用来表示任意顺序的唯一项目集合。集合中的项目可以是不同类型的，但它们都必须是*可散列*的（参见
    [表 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio) 中的 hash）。set 类型的实例是可变的，因此不可散列；frozenset
    类型的实例是不可变的且可散列的。你不能有其项目为集合的集合，但可以有其项目为冻结集合的集合（或 frozenset）。集合和冻结集合是*无序*的。
- en: To create a set, you can call the built-in type set with no argument (this means
    an empty set) or one argument that is iterable (this means a set whose items are
    those of the iterable). You can similarly build a frozenset by calling frozenset.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个集合，可以调用没有参数的内置类型 set（这意味着一个空集）或一个可迭代的参数（这意味着集合的项目是可迭代对象的项目）。类似地，通过调用 frozenset
    可以构建一个 frozenset。
- en: 'Alternatively, to denote a (nonfrozen, nonempty) set, use a series of expressions
    (the items of the set) separated by commas (,) within braces ({});^([7](ch03.xhtml#ch01fn26))
    if every item is a literal, the whole assembly is a *set literal*. You may optionally
    place a redundant comma after the last item. Here are some example sets (two literals,
    one not):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，要表示一个（非冻结、非空）集合，使用一系列用逗号（,）分隔的表达式（集合的项目），这些表达式位于大括号（{}）内；^([7](ch03.xhtml#ch01fn26))
    如果每个项目都是字面值，则整个集合是一个*集合字面量*。可以在最后一个项目之后可选地放置冗余逗号。以下是一些示例集合（两个字面值，一个不是）：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can also build nonfrozen sets with set comprehensions, as discussed in [“Set
    comprehensions”](#set_comprehensions).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用集合推导式构建非冻结集合，如在 [“Set comprehensions”](#set_comprehensions) 中讨论的那样。
- en: Note that two sets or frozensets (or a set and a frozenset) may compare as equal,
    but since they are unordered, iterating over them can return their contents in
    differing order.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，两个集合或冻结集合（或一个集合和一个冻结集合）可能比较相等，但由于它们是无序的，迭代它们可能以不同的顺序返回它们的内容。
- en: Dictionaries
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典
- en: A *mapping* is an arbitrary collection of objects indexed by nearly^([8](ch03.xhtml#ch01fn27))
    arbitrary values called *keys*. Mappings are mutable and, like sets but unlike
    sequences, are *not* (necessarily) ordered.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*映射*是一个由几乎任意值（称为*键*）索引的任意对象集合。映射是可变的，并且像集合一样（但不像序列一样）*不*（一定）有序。'
- en: 'Python provides a single built-in mapping type: the dictionary type dict. Library
    and extension modules provide other mapping types, and you can write others yourself
    (as discussed in [“Mappings”](ch04.xhtml#mappings)). Keys in a dictionary may
    be of different types, but they must be *hashable* (see hash in [Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)).
    Values in a dictionary are arbitrary objects and may be of any type. An item in
    a dictionary is a key/value pair. You can think of a dictionary as an associative
    array (known in some other languages as a “map,” “hash table,” or “hash”).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了一种内置的映射类型：字典类型 dict。库和扩展模块提供了其他映射类型，你也可以自己编写（如在 [“Mappings”](ch04.xhtml#mappings)
    中讨论的那样）。字典中的键可以是不同类型的，但它们必须是*可散列*的（参见 [表 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)
    中的 hash）。字典中的值是任意对象，可以是任何类型。字典中的一个项是一个键/值对。你可以把字典看作是一个关联数组（在其他一些语言中称为“映射”、“哈希表”或“散列表”）。
- en: 'To denote a dictionary, you can use a series of colon-separated pairs of expressions
    (the pairs are the items of the dictionary) separated by commas (,) within braces
    ({});^([9](ch03.xhtml#ch01fn28)) if every expression is a literal, the whole construct
    is a *dictionary literal*. You may optionally place a redundant comma after the
    last item. Each item in a dictionary is written as *key*:*value*, where *key*
    is an expression giving the item’s key and *value* is an expression giving the
    item’s value. If a key’s value appears more than once in a dictionary expression,
    only an arbitrary one of the items with that key is kept in the resulting dictionary
    object—dictionaries do not support duplicate keys. For example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示一个字典，可以使用一系列用冒号（:）分隔的表达式（字典的项）对，这些表达式位于大括号（{}）内；^([9](ch03.xhtml#ch01fn28))
    如果每个表达式都是字面值，则整个构造是一个*字典字面量*。可以在最后一个项目之后可选地放置冗余逗号。字典中的每个项都写成 *key*:*value*，其中
    *key* 是给出项键的表达式，*value* 是给出项值的表达式。如果一个键的值在字典表达式中出现多次，则在生成的字典对象中只保留其中任意一个项目的值——字典不支持重复键。例如：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To denote an empty dictionary, use an empty pair of braces.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示一个空字典，请使用一对空大括号。
- en: 'Here are some dictionary literals:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些字典字面值：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can also call the built-in type dict to create a dictionary in a way that,
    while less concise, can sometimes be more readable. For example, the dicts in
    the preceding snippet can also be written as:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以调用内置类型dict以一种不那么简洁但有时更易读的方式创建字典。例如，前面片段中的字典也可以写成：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: dict() without arguments creates and returns an empty dictionary, like {}. When
    the argument *x* to dict is a mapping, dict returns a new dictionary object with
    the same keys and values as *x*. When *x* is iterable, the items in *x* must be
    pairs, and dict(*x*) returns a dictionary whose items (key/value pairs) are the
    same as the items in *x*. If a key value appears more than once in *x*, only the
    *last* item from *x* with that key value is kept in the resulting dictionary.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: dict()没有参数时创建并返回一个空字典，就像{}一样。当dict的参数*x*是一个映射时，dict返回一个新的字典对象，其键和值与*x*相同。当*x*是可迭代时，*x*中的项必须是成对的，dict(*x*)返回一个其项（键/值对）与*x*中项相同的字典。如果在*x*中一个键值出现多次，则结果字典中只保留最后一个*x*中具有该键值的项。
- en: When you call dict in addition to or instead of the positional argument *x*,
    you may pass *named arguments*, each with the syntax *name=value*, where *name*
    is an identifier to use as an item’s key and *value* is an expression giving the
    item’s value. When you call dict and pass both a positional argument and one or
    more named arguments, if a key appears both in the positional argument and as
    a named argument, Python associates to that key the named argument’s value (i.e.,
    the named argument “wins”).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用dict时，除了或者代替位置参数*x*，你可以传递*命名参数*，每个参数的语法为*name=value*，其中*name*是用作项键的标识符，*value*是给出项值的表达式。当你调用dict并同时传递一个位置参数和一个或多个命名参数时，如果一个键同时出现在位置参数和命名参数中，Python将将该键关联到命名参数的值（即命名参数“胜出”）。
- en: You can unpack a dict’s contents into another dict using the ** operator.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用**操作符将字典的内容解包到另一个字典中。
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 3.9+ As of Python 3.9, this same operation can be performed using the | operator.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 3.9+ 自Python 3.9起，可以使用|运算符执行相同的操作。
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can also create a dictionary by calling dict.fromkeys. The first argument
    is an iterable whose items become the keys of the dictionary; the second argument
    is the value that corresponds to each and every key (all keys initially map to
    the same value). If you omit the second argument, it defaults to **None**. For
    example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过调用dict.fromkeys来创建一个字典。第一个参数是一个可迭代对象，其项成为字典的键；第二个参数是对应于每个键的值（所有键最初映射到相同的值）。如果省略第二个参数，则默认为**None**。例如：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can also build a dict using a dictionary comprehension, as discussed in
    [“Dictionary comprehensions”](#dictionary_comprehensions).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用字典推导式来构建字典，如在[“字典推导式”](#dictionary_comprehensions)中讨论的那样。
- en: When comparing two dicts for equality, they will evaluate as equal if they have
    the same keys and corresponding values, even if the keys are not in the same order.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较两个字典是否相等时，如果它们具有相同的键和对应的值，则它们将被视为相等，即使键的顺序不同。
- en: None
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: None
- en: The built-in **None** denotes a null object. **None** has no methods or other
    attributes. You can use **None** as a placeholder when you need a reference but
    you don’t care what object you refer to, or when you need to indicate that no
    object is there. Functions return **None** as their result unless they have specific
    **return** statements coded to return other values. **None** is hashable and can
    be used as a dict key.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的**None**表示一个空对象。**None**没有方法或其他属性。当你需要一个引用但不关心引用的对象时，或者需要指示没有对象时，你可以使用**None**作为占位符。函数作为它们的结果返回**None**，除非它们具有返回其他值的特定**return**语句。**None**是可哈希的，可以用作字典的键。
- en: Ellipsis (...)
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 省略号（...）
- en: 'The Ellipsis, written as three periods with no intervening spaces, ..., is
    a special object in Python used in numerical applications,^([10](ch03.xhtml#ch01fn29))
    or as an alternative to **None** when **None** is a valid entry. For instance,
    to initialize a dict that may take **None** as a legitimate value, you can initialize
    it with ... as an indicator of “no value supplied, not even **None**.” Ellipsis
    is hashable and so can be used as a dict key:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 省略号（...）在Python中被写作三个不加间隔的句点，是在数值应用中使用的特殊对象^([10](ch03.xhtml#ch01fn29))，或者在**None**是有效输入时作为**None**的替代。例如，要初始化一个可能接受**None**作为合法值的字典，可以用...作为指示“没有提供值，甚至不是**None**”。省略号是可哈希的，因此可以用作字典的键：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Callables
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可调用对象
- en: 'In Python, callable types are those whose instances support the function call
    operation (see [“Calling Functions”](#calling_functions)). Functions are callable.
    Python provides numerous built-in functions (see [“Built-in Functions”](ch08.xhtml#built_in_functions))
    and supports user-defined functions (see [“Defining Functions: The def Statement”](#defining_functions_the_def_statement)).
    Generators are also callable (see [“Generators”](#generators)).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，可调用类型是那些支持函数调用操作的实例（见[“调用函数”](#calling_functions)）。函数是可调用的。Python提供了许多内置函数（见[“内置函数”](ch08.xhtml#built_in_functions)）并支持用户定义的函数（见[“定义函数：def语句”](#defining_functions_the_def_statement)）。生成器也是可调用的（见[“生成器”](#generators)）。
- en: Types are callable too, as we saw for the dict, list, set, and tuple built-in
    types. (See [“Built-in Types”](ch08.xhtml#built_in_types) for a complete list
    of built-in types.) As we discuss in [“Python Classes”](ch04.xhtml#python_classes),
    **class** objects (user-defined types) are also callable. Calling a type usually
    creates and returns a new instance of that type.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 类型本身也是可调用的，正如我们对内置类型dict、list、set和tuple所见。 （请参阅[“内置类型”](ch08.xhtml#built_in_types)以获取完整的内置类型列表。）正如我们在[“Python类”](ch04.xhtml#python_classes)中讨论的那样，**类**对象（用户定义的类型）也是可调用的。通常调用一个类型会创建并返回该类型的新实例。
- en: Other callables include *methods*, which are functions bound as class attributes,
    and instances of classes that supply a special method named __call__.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可调用对象包括*方法*，即绑定为类属性的函数，以及提供名为__call__的特殊方法的类的实例。
- en: Boolean Values
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'Any^([11](ch03.xhtml#ch01fn30)) data value in Python can be used as a truth
    value: true or false. Any nonzero number or nonempty container (e.g., string,
    tuple, list, set, or dictionary) is true. Zero (0, of any numeric type), **None**,
    and empty containers are false. You may see the terms “truthy” and “falsy” used
    to indicate values that evaluate as either true or false.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，任何数据值都可以用作真值或假值。 任何非零数或非空容器（例如字符串，元组，列表，集合或字典）为真。 零（任何数值类型的0），**None**和空容器为假。
    您可能会看到“真值”和“假值”这两个术语用来表示评估为真或假的值。
- en: Beware Using a Float as a Truth Value
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谨慎使用浮点数作为真值
- en: 'Be careful about using a floating-point number as a truth value: that’s like
    comparing the number for exact equality with zero, and floating-point numbers
    should almost never be compared for exact equality.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心使用浮点数作为真值：这就像将该数字与零进行精确比较，而浮点数几乎永远不应该进行精确比较。
- en: The built-in type bool is a subclass of int. The only two values of type bool
    are **True** and **False**, which have string representations of **'True'** and
    **'False'**, but also numerical values of 1 and 0, respectively. Several built-in
    functions return bool results, as do comparison operators.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 内置类型bool是int的子类。 类型bool的唯二值为**True**和**False**，它们的字符串表示分别为**'True'**和**'False'**，但数值上分别为1和0。
    几个内置函数返回bool结果，如比较运算符。
- en: 'You can call bool(*x*) with any^([12](ch03.xhtml#ch01fn31)) *x* as the argument.
    The result is **True** when *x* is true and **False** when *x* is false. Good
    Python style is not to use such calls when they are redundant, as they most often
    are: *always* write **if** *x*:, *never* any of **if** bool(*x*):, **if** *x*
    **is** **True**:, **if** *x* == **True**:, or **if** bool(*x*) == **True**:. However,
    you *can* use bool(*x*) to count the number of true items in a sequence. For example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何*x*作为参数调用bool(*x*)。 当*x*为真时结果为**True**，当*x*为假时结果为**False**。 良好的Python风格不是在这些调用多余时使用它们，因为它们通常是这样的：*始终*编写**if**
    *x*：，*从不*使用**if** bool(*x*)：，**if** *x* **is** **True**：，**if** *x* == **True**：或**if**
    bool(*x*) == **True**：。 但是，您可以使用bool(*x*)来计算序列中真实项目的数量。 例如：
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this example, the bool call ensures each item of *seq* is counted as 0 (if
    false) or 1 (if true), so count_trues is more general than sum(*seq*) would be.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，bool调用确保*seq*的每个项被计为0（如果为假）或1（如果为真），因此count_trues比sum(*seq*)更通用。
- en: When we say “*expression* is true” we mean that bool(*expression*) would return
    **True**. As we mentioned, this is also known as “*expression* being *truthy”*
    (the other possibility is that “*expression* is *falsy”*).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说“*表达式*是真时”，我们指的是bool(*表达式*)会返回**True**。 如前所述，这也被称为“*表达式*为*真值*”（另一种可能性是“*表达式*为*假值*”）。
- en: Variables and Other References
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和其他引用
- en: A Python program accesses data values through *references*. A reference is a
    “name” that refers to a value (object). References take the form of variables,
    attributes, and items. In Python, a variable or other reference has no intrinsic
    type. The object to which a reference is bound at a given time always has a type,
    but a given reference may be bound to objects of various types in the course of
    the program’s execution.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序通过*引用*访问数据值。引用是指向值（对象）的“名称”。引用以变量、属性和项的形式存在。在Python中，变量或其他引用没有固有类型。在程序执行过程中，给定时间点上引用绑定到的对象始终有一个类型，但给定的引用可能绑定到程序执行过程中各种类型的对象。
- en: Variables
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: In Python, there are no “declarations.” The existence of a variable begins with
    a statement that *binds* the variable (in other words, sets a name to hold a reference
    to some object). You can also *unbind* a variable, resetting the name so it no
    longer holds a reference. Assignment statements are the usual way to bind variables
    and other references. The **del** statement unbinds a variable reference, although
    doing so is rare.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，没有“声明”。变量的存在始于绑定变量的语句（换句话说，设置一个名称来保存对某个对象的引用）。你也可以*解绑*一个变量，重置名称，使其不再保存引用。赋值语句是绑定变量和其他引用的常见方式。**del**语句解除变量引用，尽管这种操作很少见。
- en: Binding a reference that was already bound is also known as *rebinding* it.
    Whenever we mention binding, we implicitly include rebinding (except where we
    explicitly exclude it). Rebinding or unbinding a reference has no effect on the
    object to which the reference was bound, except that an object goes away when
    nothing refers to it. The cleanup of objects with no references is known as *garbage
    collection*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定已经绑定的引用也称为*重新绑定*。每当提到绑定时，我们隐含地包括重新绑定（除非我们明确排除它）。重新绑定或解绑引用对引用的对象没有影响，除非没有任何引用指向它时对象会消失。清理没有引用的对象称为*垃圾收集*。
- en: You can name a variable with any identifier except the 30-plus that are reserved
    as Python’s keywords (see [“Keywords”](#keywords)). A variable can be global or
    local. A *global variable* is an attribute of a module object (see [Chapter 7](ch07.xhtml#modules_and_packages)).
    A *local variable* lives in a function’s local namespace (see [“Namespaces”](#namespaces)).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用任何标识符命名一个变量，除了Python关键字中的30多个（参见[“关键字”](#keywords)）。变量可以是全局的或局部的。*全局变量*是模块对象的一个属性（参见[第7章](ch07.xhtml#modules_and_packages)）。*局部变量*存在于函数的局部命名空间中（参见[“命名空间”](#namespaces)）。
- en: Object attributes and items
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象属性和项
- en: The main distinction between the attributes and items of an object is in the
    syntax you use to access them. To denote an *attribute* of an object, use a reference
    to the object, followed by a period (.), followed by an identifier known as the
    *attribute name*. For example, *x.y* refers to one of the attributes of the object
    bound to name *x*; specifically, that attribute whose name is '*y*'.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象属性和项的主要区别在于访问它们的语法。要表示一个对象的*属性*，使用对对象的引用，后面跟一个句点（.），后面跟一个称为*属性名*的标识符。例如，*x.y*指的是绑定到名称*x*的对象的一个属性；具体来说，该属性的名称是'*y*'。
- en: To denote an *item* of an object, use a reference to the object, followed by
    an expression within brackets []. The expression in brackets is known as the item’s
    *index* or *key*, and the object is known as the item’s *container*. For example,
    *x*[*y*] refers to the item at the key or index bound to name *y*, within the
    container object bound to name *x*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示对象的*项*，使用对对象的引用，后跟方括号内的表达式[]。方括号内的表达式称为项的*索引*或*键*，对象称为项的*容器*。例如，*x*[*y*]指的是绑定到名称*y*的键或索引处的项，位于绑定到名称*x*的容器对象内。
- en: Attributes that are callable are also known as *methods*. Python draws no strong
    distinctions between callable and noncallable attributes, as some other languages
    do. All general rules about attributes also apply to callable attributes (methods).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用的属性也称为*方法*。Python不像其他一些语言那样对可调用和不可调用的属性做出明确区分。所有关于属性的一般规则也适用于可调用的属性（方法）。
- en: Accessing nonexistent references
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问不存在的引用
- en: A common programming error is to access a reference that does not exist. For
    example, a variable may be unbound, or an attribute name or item index may not
    be valid for the object to which you apply it. The Python compiler, when it analyzes
    and compiles source code, diagnoses only syntax errors. Compilation does not diagnose
    semantic errors, such as trying to access an unbound attribute, item, or variable.
    Python diagnoses semantic errors only when the errant code executes—that is, *at
    runtime*. When an operation is a Python semantic error, attempting it raises an
    exception (see [Chapter 6](ch06.xhtml#exceptions)). Accessing a nonexistent variable,
    attribute, or item—just like any other semantic error—raises an exception.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的编程错误是访问不存在的引用。例如，变量可能未绑定，或者属性名或项索引可能对所应用的对象无效。Python 编译器在分析和编译源代码时仅诊断语法错误。编译不会诊断语义错误，例如尝试访问未绑定的属性、项或变量。Python
    仅在错误代码执行时诊断语义错误，即 *在运行时*。尝试Python语义错误操作会引发异常（参见[第6章](ch06.xhtml#exceptions)）。访问不存在的变量、属性或项——与其他语义错误一样——会引发异常。
- en: Assignment Statements
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值语句
- en: Assignment statements can be plain or augmented. Plain assignment to a variable
    (e.g., *name = value*) is how you create a new variable or rebind an existing
    variable to a new value. Plain assignment to an object attribute (e.g., *x.attr*
    = *value*) is a request to object *x* to create or rebind the attribute named
    '*attr*'. Plain assignment to an item in a container (e.g., *x*[*k*] *= value*)
    is a request to container *x* to create or rebind the item with index or key *k*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值语句可以是普通的或增强的。对变量进行普通赋值（例如 *name = value*）是创建新变量或重新绑定现有变量到新值的方式。对对象属性进行普通赋值（例如
    *x.attr* = *value*）是请求对象 *x* 创建或重新绑定名为 '*attr*' 的属性。对容器中的项目进行普通赋值（例如 *x*[*k*]
    *= value*）是请求容器 *x* 创建或重新绑定索引或键 *k* 的项目。
- en: Augmented assignment (e.g., *name* += *value*) cannot, per se, create new references.
    Augmented assignment can rebind a variable, ask an object to rebind one of its
    existing attributes or items, or request the target object to modify itself. When
    you make any kind of request to an object, it is up to the object to decide whether
    and how to honor the request, and whether to raise an exception.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 增强赋值（例如 *name* += *value*）本身不能创建新引用。增强赋值可以重新绑定变量，请求对象重新绑定其现有属性或项，或请求目标对象修改自身。当您向对象发出任何请求时，取决于对象是否以及如何响应请求，以及是否引发异常。
- en: Plain assignment
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 普通赋值
- en: 'A plain assignment statement in the simplest form has the syntax:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单形式的普通赋值语句的语法是：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The target is known as the lefthand side (LHS), and the expression is the righthand
    side (RHS). When the assignment executes, Python evaluates the RHS expression,
    then binds the expression’s value to the LHS target. The binding never depends
    on the type of the value. In particular, Python draws no strong distinction between
    callable and noncallable objects, as some other languages do, so you can bind
    functions, methods, types, and other callables to variables, just as you can numbers,
    strings, lists, and so on. This is part of functions and other callables being
    *first-class objects*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 目标称为左侧（LHS），表达式为右侧（RHS）。当执行赋值时，Python 评估 RHS 表达式，然后将表达式的值绑定到 LHS 目标。绑定永远不依赖于值的类型。特别是，Python
    不像其他一些语言那样对可调用和不可调用对象有明显区分，因此您可以像绑定数字、字符串、列表等一样绑定函数、方法、类型和其他可调用对象。这是函数和其他可调用对象作为
    *一等公民对象* 的一部分。
- en: 'Details of the binding do depend on the kind of target. The target in an assignment
    may be an identifier, an attribute reference, an indexing, or a slicing, where:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定的细节取决于目标的种类。赋值语句中的目标可以是标识符、属性引用、索引或切片，其中：
- en: An identifier
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标识符
- en: Is a variable name. Assigning to an identifier binds the variable with this
    name.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个变量名。将值分配给标识符会将变量绑定到此名称。
- en: An attribute reference
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个属性引用
- en: Has the syntax *obj.name*. *obj* is an arbitrary expression, and *name* is an
    identifier, known as an *attribute name* of the object. Assigning to an attribute
    reference asks the object *obj* to bind its attribute named '*name*'.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 具有形式 *obj.name*。*obj* 是任意表达式，*name* 是标识符，称为对象的 *属性名*。将值分配给属性引用会请求对象 *obj* 绑定其名为
    '*name*' 的属性。
- en: An indexing
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一个索引
- en: Has the syntax *obj*[*expr*]. *obj* and *expr* are arbitrary expressions. Assigning
    to an indexing asks the container *obj* to bind its item indicated by the value
    of *expr*, also known as the index or key of the item in the container (an *indexing*
    is an index *applied to* a container).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 具有*obj*[*expr*]的语法。*obj*和*expr*都是任意表达式。对索引进行赋值会要求容器*obj*绑定其由*expr*的值指示的项，也称为容器中项的索引或键（*索引*是应用于*容器*的一个索引）。
- en: A slicing
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 切片操作
- en: Has the syntax *obj*[*start*:*stop*] or *obj*[*start*:*stop*:*stride*]. *obj*,
    *start*, *stop*, and *stride* are arbitrary expressions. *start*, *stop*, and
    *stride* are all optional (i.e., *obj*[:*stop*:] and *obj*[:*stop*] are also syntactically
    correct slicings, each being equivalent to *obj*[**None**:*stop*:**None**]). Assigning
    to a slicing asks the container *obj* to bind or unbind some of its items. Assigning
    to a slicing such as *obj*[*start*:*stop*:*stride*] is equivalent to assigning
    to the indexing *obj*[slice(*start*, *stop*, *stride*)]. See Python’s built-in
    type slice in ([Table 8-1](ch08.xhtml#pythonapostrophes_core_built_in_types)),
    whose instances represent slices (a *slicing* is a slice *applied to* a container).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 具有*obj*[*start*:*stop*]或*obj*[*start*:*stop*:*stride*]的语法。*obj*、*start*、*stop*和*stride*都是任意表达式。*start*、*stop*和*stride*都是可选的（即*obj*[:*stop*:]和*obj*[:*stop*]也是语法上正确的切片，每个切片都等同于*obj*[**None**:*stop*:**None**]）。对切片进行赋值会要求容器*obj*绑定或解绑其一些项。将这样的切片赋值给*obj*[*start*:*stop*:*stride*]等同于对索引*obj*[slice(*start*,
    *stop*, *stride*)]进行赋值。参见Python的内置类型slice（[表 8-1](ch08.xhtml#pythonapostrophes_core_built_in_types)），其实例表示切片（*切片*是应用于*容器*的一个切片）。
- en: We’ll get back to indexing and slicing targets when we discuss operations on
    lists in [“Modifying a list”](#modifying_a_list), and on dictionaries in [“Indexing
    a Dictionary”](#indexing_a_dictionary).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论列表操作时，我们将回到索引和切片目标的问题，详见[“修改列表”](#modifying_a_list)，以及字典操作时，详见[“字典索引”](#indexing_a_dictionary)。
- en: 'When the target of the assignment is an identifier, the assignment statement
    specifies the binding of a variable. This is *never* disallowed: when you request
    it, it takes place. In all other cases, the assignment statement denotes a request
    to an object to bind one or more of its attributes or items. An object may refuse
    to create or rebind some (or all) attributes or items, raising an exception if
    you attempt a disallowed creation or rebinding (see also __setattr__ in [Table 4-1](ch04.xhtml#general_purpose_special_methods)
    and __setitem__ in [“Container methods”](ch04.xhtml#container_method)).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当赋值的目标是标识符时，赋值语句指定了变量的绑定。这是*绝对不会*被禁止的：当您请求时，它会发生。在所有其他情况下，赋值语句表示请求对象绑定一个或多个其属性或项。对象可能会拒绝创建或重新绑定一些（或全部）属性或项，在您尝试禁止创建或重新绑定时引发异常（另请参阅[表 4-1](ch04.xhtml#general_purpose_special_methods)中的__setattr__和[“容器方法”](ch04.xhtml#container_method)中的__setitem__）。
- en: 'A plain assignment can use multiple targets and equals signs (=). For example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 简单赋值语句可以使用多个目标和等号（=）。例如：
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: binds variables a, b, and c to the same value, 0. Each time the statement executes,
    the RHS expression evaluates just once, no matter how many targets are in the
    statement. Each target, left to right, is bound to the one object returned by
    the expression, just as if several simple assignments executed one after the other.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量a、b和c绑定到相同的值0。每次执行该语句时，右侧表达式只计算一次，无论语句中有多少目标。每个目标从左到右绑定到由表达式返回的一个对象，就像依次执行多个简单赋值一样。
- en: 'The target in a plain assignment can list two or more references separated
    by commas, optionally enclosed in parentheses or brackets. For example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 简单赋值语句中的目标可以是两个或多个引用，用逗号分隔，可选地用括号或方括号括起来。例如：
- en: '[PRE45]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This statement requires x to be an iterable with exactly three items, and binds
    a to the first item, b to the second, and c to the third. This kind of assignment
    is known as an *unpacking assignment*. The RHS expression must be an iterable
    with exactly as many items as there are references in the target; otherwise, Python
    raises an exception. Python binds each reference in the target to the corresponding
    item in the RHS. You can use an unpacking assignment, for example, to swap references:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句要求x是一个具有三个项目的可迭代对象，并将a绑定到第一个项目，b绑定到第二个项目，c绑定到第三个项目。这种赋值称为*解包赋值*。右侧表达式必须是一个具有与目标引用数量相同数量的项目的可迭代对象；否则，Python会引发异常。Python将目标中的每个引用绑定到右侧表达式中相应的项目。例如，您可以使用解包赋值交换引用：
- en: '[PRE46]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This assignment statement rebinds name a to what name b was bound to, and vice
    versa. Exactly one of the multiple targets of an unpacking assignment may be preceded
    by *. That *starred* target, if present, is bound to a list of all items, if any,
    that were not assigned to other targets. For example, when x is a list, this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个赋值语句重新将名字a绑定到名字b曾经绑定的内容上，反之亦然。拆包赋值的多个目标中只能有一个目标前面有*。如果有，那个*星号*目标将绑定到所有未分配给其他目标的项目（如果有的话）的列表上。例如，当x是一个列表时，这样：
- en: '[PRE47]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'is the same as (but more concise, clearer, more general, and faster than) this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 和这个（但更简洁，更清晰，更一般，更快）是一样的：
- en: '[PRE48]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Each of these forms requires x to have at least two items. This feature is known
    as *extended unpacking*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这些形式中的每一个都要求x至少有两个项目。这个特性被称为*扩展拆包*。
- en: Augmented assignment
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强赋值
- en: An *augmented assignment* (sometimes called an *in-place assignment*) differs
    from a plain assignment in that, instead of an equals sign (=) between the target
    and the expression, it uses an *augmented operator*, which is a binary operator
    followed by =. The augmented operators are +=, -=, *=, /=, //=, %=, **=, |=, >>=,
    <<=, &=, ^=, and @=. An augmented assignment can have only one target on the LHS;
    augmented assignment does not support multiple targets.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*增强赋值*（有时被称为*就地赋值*）与普通赋值的不同之处在于，目标和表达式之间不是等号（=），而是一个*增强运算符*，它是一个二元运算符后跟=。增强运算符包括+=、-=、*=、/=、//=、%=、**=、|=、>>=、<<=、&=、^=
    和@=。增强赋值只能在LHS上有一个目标；增强赋值不支持多个目标。'
- en: In an augmented assignment, like in a plain one, Python first evaluates the
    RHS expression. Then, when the LHS refers to an object that has a special method
    for the appropriate *in-place* version of the operator, Python calls the method
    with the RHS value as its argument (it is up to the method to modify the LHS object
    appropriately and return the modified object; [“Special Methods”](ch04.xhtml#special_methods)
    covers special methods). When the LHS object has no applicable in-place special
    method, Python uses the corresponding binary operator on the LHS and RHS objects,
    then rebinds the target to the result. For example, *x* += *y* is like *x* = *x*.__iadd_(*y*)
    when *x* has the special method __iadd__ for “in-place addition”; otherwise, *x*
    += *y* is like *x* = *x* + *y*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在增强赋值中，就像在普通赋值中一样，Python首先评估RHS表达式。然后，当LHS引用具有适当的*就地*版本运算符的对象时，Python调用该方法并将RHS值作为其参数（由方法适当地修改LHS对象并返回修改后的对象；[“特殊方法”](ch04.xhtml#special_methods)介绍了特殊方法）。当LHS对象没有适用的就地特殊方法时，Python在LHS和RHS对象上使用相应的二元运算符，然后重新绑定目标到结果上。例如，*x*
    += *y* 就像 *x* = *x*.__iadd_(*y*) 当*x*具有特殊方法__iadd__用于“就地加法”时；否则，*x* += *y* 就像
    *x* = *x* + *y*。
- en: Augmented assignment never creates its target reference; the target must already
    be bound when augmented assignment executes. Augmented assignment can rebind the
    target reference to a new object, or modify the same object to which the target
    reference was already bound. Plain assignment, in contrast, can create or rebind
    the LHS target reference, but it never modifies the object, if any, to which the
    target reference was previously bound. The distinction between objects and references
    to objects is crucial here. For example, *x* = *x* + *y* never modifies the object
    to which *x* was originally bound, if any. Rather, it rebinds *x* to refer to
    a new object. *x* += *y*, in contrast, modifies the object to which the name *x*
    is bound, when that object has the special method __iadd__; otherwise, *x* +=
    *y* rebinds *x* to a new object, just like *x* = *x* + *y*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 增强赋值从不创建其目标引用；在增强赋值执行时，目标必须已经被绑定。增强赋值可以将目标引用重新绑定到一个新对象，或者修改目标引用已经绑定的相同对象。相比之下，普通赋值可以创建或重新绑定LHS目标引用，但它永远不会修改目标引用先前绑定的对象（如果有的话）。这里对象和对象引用之间的区别至关重要。例如，*x*
    = *x* + *y* 从不修改*x*最初绑定的对象（如果有的话）。相反，它将*x*重新绑定到引用一个新对象的地方。*x* += *y* 相反，修改了名称*x*绑定的对象，当该对象具有特殊方法__iadd__时；否则，*x*
    += *y* 就像*x* = *x* + *y* 一样，重新绑定*x*到一个新对象。
- en: del Statements
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: del语句
- en: Despite its name, a **del** statement *unbinds references*—it does *not*, per
    se, *delete* objects. Object deletion may automatically follow, by garbage collection,
    when no more references to an object exist.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它的名字是这样，一个**del**语句会*解除引用*——它*不会*直接*删除*对象。对象的删除可能会在没有对对象的更多引用存在时通过垃圾回收自动发生。
- en: A **del** statement consists of the keyword **del**, followed by one or more
    target references separated by commas (,). Each target can be a variable, attribute
    reference, indexing, or slicing, just like for assignment statements, and must
    be bound at the time **del** executes. When a **del** target is an identifier,
    the **del** statement means to unbind the variable. If the identifier was bound,
    unbinding it is never disallowed; when requested, it takes place.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**del** 语句由关键字 **del** 开始，后跟一个或多个由逗号（,）分隔的目标引用。每个目标可以是变量、属性引用、索引或切片，就像赋值语句一样，在
    **del** 执行时必须绑定。当 **del** 的目标是标识符时，**del** 语句意味着取消绑定该变量。如果标识符已绑定，则取消绑定是可以的；一旦请求，它就会发生。'
- en: In all other cases, the **del** statement specifies a request to an object to
    unbind one or more of its attributes or items. An object may refuse to unbind
    some (or all) attributes or items, raising an exception if you attempt a disallowed
    unbinding (see also __delattr__ in [“General-Purpose Special Methods”](ch04.xhtml#general_purpose_special_method)
    and __delitem__ in [“Container methods”](ch04.xhtml#container_method)). Unbinding
    a slicing normally has the same effect as assigning an empty sequence to that
    slicing, but it is up to the container object to implement this equivalence.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有其他情况下，**del** 语句指定了向对象请求解绑一个或多个其属性或项。对象可能会拒绝解绑一些（或全部）属性或项，如果尝试不允许的解绑，则会引发异常（参见
    [“通用特殊方法”](ch04.xhtml#general_purpose_special_method) 中的 __delattr__ 和 [“容器方法”](ch04.xhtml#container_method)
    中的 __delitem__）。解绑切片通常具有将空序列分配给该切片的相同效果，但由容器对象实现此等价性。
- en: Containers are also allowed to have **del** cause side effects. For example,
    assuming **del** *C*[2] succeeds, when *C* is a dictionary, this makes future
    references to *C*[2] invalid (raising KeyError) until and unless you assign to
    *C*[2] again; but when *C* is a list, **del** *C*[2] implies that every following
    item of *C* “shifts left by one”—so, if *C* is long enough, future references
    to *C*[2] are still valid, but denote a different item than they did before the
    **del** (generally, what you’d have used *C*[3] to refer to, before the **del**
    statement).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 容器还允许 **del** 导致副作用。例如，假设 **del** *C*[2] 成功，当 *C* 是字典时，这将使得对 *C*[2] 的未来引用无效（引发
    KeyError），直到你再次对 *C*[2] 进行赋值；但是当 *C* 是列表时，**del** *C*[2] 意味着 *C* 的每个后续项“向左移动一位”——因此，如果
    *C* 足够长，对 *C*[2] 的未来引用仍然有效，但它们表示的是 **del** 之前所用 *C*[3] 的不同项（通常是你在 **del** 语句之前用
    *C*[3] 来引用的项）。
- en: Expressions and Operators
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式和运算符
- en: 'An expression is a “phrase” of code, which Python evaluates to produce a value.
    The simplest expressions are literals and identifiers. You build other expressions
    by joining subexpressions with the operators and/or delimiters listed in [Table 3-4](#operator_precedence_in_expressions).
    This table lists operators in decreasing order of precedence, higher precedence
    before lower. Operators listed together have the same precedence. The third column
    lists the associativity of the operator: L (left-to-right), R (right-to-left),
    or NA (nonassociative).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式是代码的“短语”，Python 评估它以生成一个值。最简单的表达式是文字和标识符。你可以通过使用 [表 3-4](#operator_precedence_in_expressions)
    中列出的运算符和/或分隔符连接子表达式来构建其他表达式。该表按降序列出优先级，优先级高于低。并排列出的运算符具有相同的优先级。第三列列出了运算符的结合性：L（从左到右）、R（从右到左）或
    NA（非关联）。
- en: Table 3-4\. Operator precedence in expressions
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-4\. 表达式中的运算符优先级
- en: '| Operator | Description | Associativity |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 描述 | 结合性 |'
- en: '| --- | --- | --- |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| { *key* : *expr*, ... } | Dictionary creation | NA |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| { *key* : *expr*, ... } | 字典创建 | NA |'
- en: '| { *expr*, ... } | Set creation | NA |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| { *expr*, ... } | 集合创建 | NA |'
- en: '| [ *expr*, ... ] | List creation | NA |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| [ *expr*, ... ] | 列表创建 | NA |'
- en: '| ( *expr*, ... ) | Tuple creation (parentheses recommended, but not always
    required; at least one comma required), or just parentheses | NA |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| ( *expr*, ... ) | 元组创建（推荐使用括号，但不一定要求；至少需要一个逗号），或者只是括号 | NA |'
- en: '| *f* ( *expr*, ... ) | Function call | L |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| *f* ( *expr*, ... ) | 函数调用 | L |'
- en: '| *x* [ *index*: *index: step* ] | Slicing | L |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| *x* [ *index*: *index: step* ] | 切片 | L |'
- en: '| *x* [ *index* ] | Indexing | L |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| *x* [ *index* ] | 索引 | L |'
- en: '| *x* . *attr* | Attribute reference | L |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| *x* . *attr* | 属性引用 | L |'
- en: '| *x* ** y | Exponentiation (*x* to the *y*th power) | R |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| *x* ** y | 指数运算（*x* 的 *y* 次方） | R |'
- en: '| ~ *x*, + *x*, - *x* | Bitwise NOT, unary plus and minus | NA |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| ~ *x*, + *x*, - *x* | 按位非、一元加和减 | NA |'
- en: '| *x* * *y*, *x* @ *y*, *x* / *y*, *x* // *y*, *x* % *y* | Multiplication,
    matrix multiplication, division, floor division, remainder | L |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| *x* * *y*, *x* @ *y*, *x* / *y*, *x* // *y*, *x* % *y* | 乘法，矩阵乘法，除法，地板除法，取余
    | L |'
- en: '| *x* + *y*, *x* - *y* | Addition, subtraction | L |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| *x* + *y*, *x* - *y* | 加法，减法 | L |'
- en: '| *x* << *y*, *x* >> *y* | Left-shift, right-shift | L |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| *x* << *y*, *x* >> *y* | 左移，右移 | L |'
- en: '| *x* & *y* | Bitwise AND | L |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| *x* & *y* | 按位与 | L |'
- en: '| *x* ^ *y* | Bitwise XOR | L |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| *x* ^ *y* | 按位异或 | L |'
- en: '| *x* &#124; *y* | Bitwise OR | L |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| *x* &#124; *y* | 按位或 | L |'
- en: '| *x* < *y*, *x* <= *y*, *x* > *y*, *x* >= *y*, *x* != *y*, *x* == *y* | Comparisons
    (less than, less than or equal, greater than, greater than or equal, inequality,
    equality) | NA |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| *x* < *y*, *x* <= *y*, *x* > *y*, *x* >= *y*, *x* != *y*, *x* == *y* | 比较运算符（小于，小于等于，大于，大于等于，不等于，等于）
    | NA |'
- en: '| *x* **is** *y*, *x* **is not** *y* | Identity tests | NA |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| *x* **is** *y*, *x* **is not** *y* | 身份测试 | NA |'
- en: '| *x* **in** *y*, *x* **not in** *y* | Membership tests | NA |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| *x* **in** *y*, *x* **not in** *y* | 成员测试 | NA |'
- en: '| **not** *x* | Boolean NOT | NA |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| **not** *x* | 布尔非 | NA |'
- en: '| *x* **and** *y* | Boolean AND | L |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| *x* **and** *y* | 布尔与 | L |'
- en: '| *x* **or** *y* | Boolean OR | L |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| *x* **or** *y* | 布尔或 | L |'
- en: '| *x* **if** *expr* **else** *y* | Conditional expression (or ternary operator)
    | NA |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| *x* **if** *expr* **else** *y* | 条件表达式（或三元操作符） | NA |'
- en: '| **lambda** *arg*, ...: *expr* | Anonymous simple function | NA |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| **lambda** *arg*, ...: *expr* | 匿名简单函数 | NA |'
- en: '| ( *ident* := *expr* ) | Assignment expression (parentheses recommended, but
    not always required) | NA |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| ( *ident* := *expr* ) | 赋值表达式（建议使用括号，但不总是必需） | NA |'
- en: In this table, *expr*, *key*, *f*, *index*, *x*, and *y* mean any expression,
    while *attr*, *arg*, and *ident* mean any identifier. The notation *, ...* means
    commas join zero or more repetitions; in such cases, a trailing comma is optional
    and innocuous.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本表中，*expr*，*key*，*f*，*index*，*x* 和 *y* 表示任意表达式，而 *attr*，*arg* 和 *ident* 表示任何标识符。记号
    *, ...* 表示逗号连接零个或多个重复项；在这种情况下，尾随逗号是可选且无害的。
- en: Comparison Chaining
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较链
- en: 'You can chain comparisons, implying a logical **and**. For example:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以链式比较，隐含逻辑**and**。例如：
- en: '[PRE49]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'where *a*, *b*, *c*, and *d* are arbitrary expressions, has (in the absence
    of evaluation side effects) the same value as:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *a*，*b*，*c* 和 *d* 是任意表达式，在没有副作用的情况下，其值与以下表达式相同：
- en: '[PRE50]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The chained form is more readable, and evaluates each subexpression at most
    once.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这种链式形式更易读，并且每个子表达式最多评估一次。
- en: Short-Circuiting Operators
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短路运算符
- en: 'The **and** and **or** operators *short-circuit* their operands’ evaluation:
    the righthand operand evaluates only when its value is needed to get the truth
    value of the entire **and** or **or** operation.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**and** 和 **or** 操作符会 *短路* 其操作数的评估：仅当需要其值以获取整个 **and** 或 **or** 操作的真值时，才会评估右操作数。'
- en: In other words, *x* **and** *y* first evaluates *x*. When *x* is false, the
    result is *x*; otherwise, the result is *y*. Similarly, *x* **or** *y* first evaluates
    *x*. When *x* is true, the result is *x*; otherwise, the result is *y*.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*x* **and** *y* 首先评估 *x*。当 *x* 为假时，结果为 *x*；否则，结果为 *y*。类似地，*x* **or** *y*
    首先评估 *x*。当 *x* 为真时，结果为 *x*；否则，结果为 *y*。
- en: '**and** and **or** don’t force their results to be **True** or **False**, but
    rather return one or the other of their operands. This lets you use these operators
    more generally, not just in Boolean contexts. **and** and **or**, because of their
    short-circuiting semantics, differ from other operators, which fully evaluate
    all operands before performing the operation. **and** and **or** let the left
    operand act as a *guard* for the right operand.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**and** 和 **or** 不强制其结果为 **True** 或 **False**，而是返回它们的操作数之一。这让你可以更广泛地使用这些操作符，不仅限于布尔上下文。由于其短路语义，**and**
    和 **or** 与其他操作符不同，其他操作符在执行操作之前会完全评估所有操作数。**and** 和 **or** 让左操作数作为右操作数的 *守卫*。'
- en: The conditional operator
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件操作符
- en: 'Another short-circuiting operator is the conditional^([13](ch03.xhtml#ch01fn32))
    operator **if**/**else**:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个短路运算符是条件操作符 **if**/**else**：
- en: '[PRE51]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Each of *when_true*, *when_false*, and *condition* is an arbitrary expression.
    *condition* evaluates first. When *condition* is true, the result is *when_true*;
    otherwise, the result is *when_false*. Only one of the subexpressions *when_true*
    and *when_false* evaluates, depending on the truth value of *condition*.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*when_true*，*when_false* 和 *condition* 都是任意表达式。首先评估 *condition*。当 *condition*
    为真时，结果为 *when_true*；否则，结果为 *when_false*。只有 *when_true* 和 *when_false* 中的一个会评估，取决于
    *condition* 的真值。'
- en: The order of the subexpressions in this conditional operator may be a bit confusing.
    The recommended style is to always place parentheses around the whole expression.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件运算符中子表达式的顺序可能有点令人困惑。建议的风格是始终将整个表达式放在括号中。
- en: Assignment Expressions
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值表达式
- en: 3.8+ You can combine evaluation of an expression and the assignment of its result
    using the := operator. There are several common cases where this is useful.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 3.8+ 你可以使用 := 运算符结合表达式的评估和其结果的赋值。有几种常见情况下这是有用的。
- en: := in an if/elif statement
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 if/elif 语句中的 :=
- en: 'Code that assigns a value and then checks it can be collapsed using :=:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 := 折叠分配值然后检查它的代码：
- en: '[PRE52]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is especially helpful when writing a sequence of **if**/**elif** blocks
    (you’ll find a more extended example in [Chapter 10](ch10.xhtml#regular_expressions)).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写一系列 **if**/**elif** 块时特别有帮助（你会在 [Chapter 10](ch10.xhtml#regular_expressions)
    中找到一个更详细的例子）。
- en: := in a while statement
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 while 语句中的 :=
- en: 'Use := to simplify code that uses a variable as its **while** condition. Consider
    this code that works with a sequence of values returned by some function get_next_value,
    which returns **None** when there are no more values to process:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 := 简化以变量作为 **while** 条件的代码。考虑以下代码，它使用某个函数 `get_next_value` 返回的一系列值进行操作，当没有更多值需要处理时，返回
    **None**：
- en: '[PRE53]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This code has a couple of problems. First, there is the duplicated call to
    get_next_value, which carries extra maintenance costs when get_next_value changes.
    But more seriously, there is a bug when an early exiting filter is added: the
    **continue** statement jumps directly back to the **while** statement without
    advancing to the next value, creating an infinite loop.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有几个问题。首先，有重复调用 `get_next_value`，当 `get_next_value` 发生变化时，会带来额外的维护成本。但更严重的是，在添加了早期退出过滤器后会出现错误：**continue**
    语句直接跳回 **while** 语句而不前进到下一个值，创建了一个无限循环。
- en: 'When we use := to incorporate the assignment into the **while** statement itself,
    we fix the duplication problem, and calling **continue** does not cause an infinite
    loop:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 := 将赋值合并到 **while** 语句本身时，我们解决了重复问题，并且调用 **continue** 不会导致无限循环：
- en: '[PRE54]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: := in a list comprehension filter
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在列表推导式的过滤器中的 :=
- en: 'A list comprehension that converts an input item but must filter out some items
    based on their converted values can use := to do the conversion only once. In
    this example, a function to convert strs to ints returns **None** for invalid
    values. Without :=, the list comprehension must call safe_int twice for valid
    values, once to check for **None** and then again to add the actual int value
    to the list:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式可以根据转换后的值过滤掉某些项目，但必须使用 := 仅进行一次转换。在这个例子中，一个将 strs 转换为 ints 的函数对无效值返回 **None**。没有
    :=，列表推导式必须两次调用 `safe_int`，一次检查 **None**，然后再次将实际的 int 值添加到列表中：
- en: '[PRE55]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we use an assignment expression in the condition part of the list comprehension,
    safe_int only gets called once for each value in input_strings:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在列表推导式的条件部分使用赋值表达式，对于输入字符串中的每个值，`safe_int` 只会被调用一次：
- en: '[PRE56]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can find more examples in the original PEP for this feature, [PEP 572](https://oreil.ly/1YhRm).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此功能的原始 PEP 中找到更多示例，[PEP 572](https://oreil.ly/1YhRm)。
- en: Numeric Operations
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值操作
- en: 'Python offers the usual numeric operations, as we’ve just seen in [Table 3-4](#operator_precedence_in_expressions).
    Numbers are immutable objects: when you perform operations on number objects,
    you always produce new objects and never modify existing ones. You can access
    the parts of a complex object *z* as read-only attributes *z.*real and *z.*imag.
    Trying to rebind these attributes raises an exception.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了通常的数值操作，正如我们刚刚在 [Table 3-4](#operator_precedence_in_expressions) 中看到的那样。数字是不可变对象：当你在数字对象上执行操作时，总是产生新的对象，而不是修改现有的对象。你可以作为只读属性访问复杂对象
    *z* 的部分，例如 *z.*real 和 *z.*imag。试图重新绑定这些属性会引发异常。
- en: 'A number’s optional + or - sign, and the + or - that joins a floating-point
    literal to an imaginary one to make a complex number, are not part of the literals’
    syntax. They are ordinary operators, subject to normal operator precedence rules
    (see [Table 3-4](#operator_precedence_in_expressions)). For example, -2 ** 2 evaluates
    to -4: exponentiation has higher precedence than unary minus, so the whole expression
    parses as -(2 ** 2), not as (-2) ** 2. (Again, parentheses are recommended, to
    avoid confusing a reader of the code.)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 数字的可选 `+` 或 `-` 符号，以及将浮点数文字与虚部连接以制作复数的 `+` 或 `-` 不是文字语法的一部分。它们是普通的运算符，受正常运算符优先规则的约束（见[表 3-4](#operator_precedence_in_expressions)）。例如，`-2
    ** 2` 计算结果为 `-4`：乘方比一元减号具有更高的优先级，因此整个表达式解析为 `-(2 ** 2)`，而不是 `(-2) ** 2`。（再次强调，建议使用括号，以避免混淆代码读者。）
- en: Numeric Conversions
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值转换
- en: You can perform arithmetic operations and comparisons between any two numbers
    of Python built-in types (integers, floating-point numbers, and complex numbers).
    If the operands’ types differ, Python converts the operand with the “narrower”
    type to the “wider” type.^([14](ch03.xhtml#ch01fn33)) The built-in numeric types,
    in order from narrowest to widest, are int, float, and complex. You can request
    an explicit conversion by passing a noncomplex numeric argument to any of these
    types. int drops its argument’s fractional part, if any (e.g., int(9.8) is 9).
    You can also call complex with two numeric arguments, giving real and imaginary
    parts. You cannot convert a complex to another numeric type in this way, because
    there is no single unambiguous way to convert a complex number into, for example,
    a float.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Python内置类型（整数、浮点数和复数）之间执行算术操作和比较。如果操作数的类型不同，Python将操作数转换为“更宽”的类型。^([14](ch03.xhtml#ch01fn33))
    内置数值类型按从最窄到最宽的顺序是：int、float和complex。您可以通过将非复数数值参数传递给这些类型中的任何一个来请求显式转换。int 丢弃其参数的小数部分（如果有的话）（例如，`int(9.8)`
    是 `9`）。您还可以使用两个数值参数调用complex，给出实部和虚部。您不能以这种方式将复数转换为另一种数值类型，因为没有单一明确的方法将复数转换为例如浮点数。
- en: 'You can also call each built-in numeric type with a string argument with the
    syntax of an appropriate numeric literal, with small extensions: the argument
    string may have leading and/or trailing whitespace, may start with a sign, and—for
    complex numbers—may sum or subtract a real part and an imaginary one. int can
    also be called with two arguments: the first one a string to convert, and the
    second the *radix*, an integer between 2 and 36 to use as the base for the conversion
    (e.g., int(''101'', 2) returns 5, the value of ''101'' in base 2). For radices
    larger than 10, the appropriate subset of ASCII letters from the start of the
    alphabet (in either lower- or uppercase) are the extra needed “digits.”^([15](ch03.xhtml#ch01fn34))'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用适当的数值文本语法调用每个内置数值类型，并带有字符串参数，具有小的扩展功能：参数字符串可以包含前导和/或尾随空格，可以以符号开头，并且对于复数数字，可以加和减去实部和虚部。int
    还可以用两个参数调用：第一个是要转换的字符串，第二个是*基数*，一个介于2和36之间的整数，用作转换的基数（例如，`int('101', 2)` 返回5，即在二进制中的'101'的值）。对于大于10的基数，ASCII字母表中的适当子集（无论是小写还是大写）是所需的额外“数字”。^([15](ch03.xhtml#ch01fn34))
- en: Arithmetic Operations
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算
- en: Arithmetic operations in Python behave in rather obvious ways, with the possible
    exception of division and exponentiation.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的算术操作通常表现得非常明显，除了除法和乘方可能有例外。
- en: Division
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除法
- en: When the right operand of /, //, or % is 0, Python raises an exception at runtime.
    Otherwise, the / operator performs *true* division, returning the floating-point
    result of division of the two operands (or a complex result if either operand
    is a complex number). In contrast, the // operator performs *floor* division,
    which means it returns an integer result (converted to the same type as the wider
    operand) that’s the largest integer less than or equal to the true division result
    (ignoring the remainder, if any); e.g., 5.0 // 2 = 2.0 (not 2). The % operator
    returns the remainder of the (floor) division, i.e., the integer such that (x
    // y) * y + (x % y) == x.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 当除法运算符 `/`, `//`, 或 `%` 的右操作数为0时，Python 在运行时会引发异常。否则，除法运算符 `/` 执行*真*除法，返回两个操作数的浮点数结果（如果任一操作数是复数，则返回复数结果）。相比之下，除法运算符
    `//` 执行*地板*除法，即返回整数结果（转换为更广泛操作数的相同类型），该结果是小于或等于真除法结果的最大整数（忽略余数，如果有的话）；例如，`5.0
    // 2 = 2.0`（而不是2）。运算符 `%` 返回（地板）除法的余数，即整数 `x // y` * y + `x % y` == `x` 的整数。
- en: –x // y Is Not the Same as int(–x / y)
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`–x // y` 不同于 `int(–x / y)`'
- en: Take care not to think of // as a truncating or integer form of division; this
    is only the case for operands of the same sign. When operands are of different
    signs, the largest integer less than or equal to the true division result will
    actually be a more negative value than the result from true division (for example,
    -5 / 2 returns -2.5, so -5 // 2 returns -3, not -2).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**//** 不是截断或整数除法的形式；这仅适用于操作数具有相同符号的情况。当操作数的符号不同时，最接近真实除法结果且小于等于它的整数实际上会比真实除法结果更负（例如，-5
    / 2 返回 -2.5，因此 -5 // 2 返回 -3，而不是 -2）。
- en: The built-in divmod function takes two numeric arguments and returns a pair
    whose items are the quotient and remainder, so you don’t have to use both // for
    the quotient and % for the remainder.^([16](ch03.xhtml#ch01fn35))
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 divmod 函数接受两个数值参数，并返回一个包含商和余数的对，因此你不必同时使用 // 得到商和 % 得到余数。^([16](ch03.xhtml#ch01fn35))
- en: Exponentiation
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指数运算
- en: 'The exponentiation (“raise to power”) operation, when *a* is less than zero
    and *b* is a floating-point value with a nonzero fractional part, returns a complex
    number. The built-in pow(*a*, *b*) function returns the same result as *a* **
    *b*. With three arguments, pow(*a*, *b*, *c*) returns the same result as (*a*
    ** *b*) % *c* but may sometimes be faster. Note that, unlike other arithmetic
    operations, exponentiation evaluates right to left: in other words, *a* ** *b*
    ** *c* evaluates as *a* ** (*b* ** *c*).'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *a* 小于零且 *b* 是具有非零小数部分的浮点数时，“乘方”运算将返回一个复数。内置的 pow(*a*, *b*) 函数返回与 *a* ** *b*
    相同的结果。带有三个参数的 pow(*a*, *b*, *c*) 返回与 (*a* ** *b*) % *c* 相同的结果，但有时可能更快。请注意，与其他算术运算不同，乘方运算从右向左求值：换句话说，*a*
    ** *b* ** *c* 的求值结果为 *a* ** (*b* ** *c*)。
- en: Comparisons
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较
- en: All objects, including numbers, can be compared for equality (==) and inequality
    (!=). Comparisons requiring order (<, <=, >, >=) may be used between any two numbers
    unless either operand is complex, in which case they raise exceptions at runtime.
    All these operators return Boolean values (**True** or **False**). Be careful
    when comparing floating-point numbers for equality, however, as discussed in [Chapter 16](ch16.xhtml#numeric_processing)
    and the [online tutorial on floating-point arithmetic](https://oreil.ly/TSWCX).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象，包括数字，都可以进行相等性（==）和不等性（!=）比较。需要顺序比较（<、<=、>、>=）的比较可以用于任何两个数字，除非其中一个操作数是复数，在这种情况下会在运行时引发异常。所有这些操作符都返回布尔值（**True**
    或 **False**）。但是，在比较浮点数是否相等时要小心，如 [第16章](ch16.xhtml#numeric_processing) 和 [关于浮点数算术的在线教程](https://oreil.ly/TSWCX)
    中所讨论的。
- en: Bitwise Operations on Integers
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数的位操作
- en: ints can be interpreted as strings of bits and used with the bitwise operations
    shown in [Table 3-4](#operator_precedence_in_expressions). Bitwise operators have
    lower priority than arithmetic operators. Positive ints are conceptually extended
    by an unbounded string of bits on the left, each bit being 0. Negative ints, as
    they’re held in two’s complement representation, are conceptually extended by
    an unbounded string of bits on the left, each bit being 1.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 整数可以被解释为比特字符串，并与 [表格 3-4](#operator_precedence_in_expressions) 中显示的位运算符一起使用。位运算符的优先级低于算术运算符。正整数在概念上通过左侧无限长度的比特字符串扩展，每个比特为
    0。负整数则采用二进制补码表示，概念上通过左侧无限长度的比特字符串扩展，每个比特为 1。
- en: Sequence Operations
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列操作
- en: Python supports a variety of operations applicable to all sequences, including
    strings, lists, and tuples. Some sequence operations apply to all containers (including
    sets and dictionaries, which are not sequences); some apply to all iterables (meaning
    “any object over which you can loop”—all containers, be they sequences or not,
    are iterable, and so are many objects that are not containers, such as files,
    covered in [“The io Module”](ch11.xhtml#the_io_module), and generators, covered
    in [“Generators”](#generators)). In the following we use the terms *sequence*,
    *container*, and *iterable* quite precisely, to indicate exactly which operations
    apply to each category.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持多种操作，适用于所有序列，包括字符串、列表和元组。一些序列操作适用于所有容器（包括非序列的集合和字典）；一些适用于所有可迭代对象（即“任何你可以循环遍历的对象”——所有容器，无论它们是否是序列，都是可迭代的，包括一些不是容器的对象，如文件，在
    [“The io Module”](ch11.xhtml#the_io_module) 中介绍，以及生成器，在 [“Generators”](#generators)
    中介绍）。在接下来的内容中，我们非常精确地使用术语 *sequence*、*container* 和 *iterable*，以准确指示每个类别适用的操作。
- en: Sequences in General
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般序列
- en: Sequences are ordered containers with items that are accessible by indexing
    and slicing.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 序列是有序容器，其项可通过索引和切片访问。
- en: The built-in len function takes any container as an argument and returns the
    number of items in the container.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的len函数接受任何容器作为参数，并返回容器中的项目数。
- en: The built-in min and max functions take one argument, an iterable whose items
    are comparable, and return the smallest and largest items, respectively. You can
    also call min and max with multiple arguments, in which case they return the smallest
    and largest arguments, respectively.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的min和max函数接受一个参数，该参数是可比较的项的可迭代对象，并分别返回最小和最大的项。您还可以使用多个参数调用min和max函数，此时它们将分别返回最小和最大的参数。
- en: 'min and max also accept two keyword-only optional arguments: key, a callable
    to apply to each item (the comparisons are then performed on the callable’s results
    rather than on the items themselves); and default, the value to return when the
    iterable is empty (when the iterable is empty and you supply no default argument,
    the function raises ValueError). For example, max(''who'', ''why'', ''what'',
    key=len) returns ''what''.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: min和max还接受两个仅限关键字的可选参数：key，一个应用于每个项目的可调用函数（然后比较将根据可调用函数的结果而不是项目本身进行）；以及default，当可迭代对象为空时返回的值（当可迭代对象为空且您未提供默认参数时，函数会引发ValueError异常）。例如，max('who',
    'why', 'what', key=len) 返回 'what'。
- en: The built-in sum function takes one argument, an iterable whose items are numbers,
    and returns the sum of the numbers.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的sum函数接受一个参数，该参数是数字的可迭代对象，并返回数字的总和。
- en: Sequence conversions
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列转换
- en: There is no implicit conversion between different sequence types. You can call
    the built-ins tuple and list with a single argument (any iterable) to get a new
    instance of the type you’re calling, with the same items, in the same order, as
    in the argument.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 不同序列类型之间没有隐式转换。您可以使用内置的tuple和list函数并传入单个参数（任何可迭代对象），以获取与参数中相同顺序的相同项目的新实例。
- en: Concatenation and repetition
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接和重复
- en: You can concatenate sequences of the same type with the + operator. You can
    multiply a sequence *S* by an integer *n* with the * operator. *S***n* is the
    concatenation of *n* copies of *S*. When *n* <= 0, *S* * *n* is an empty sequence
    of the same type as *S*.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用+运算符连接相同类型的序列。您可以使用整数*n*将序列*S*乘以*运算符。*S***n* 是*S*的*n*个副本的连接。当*n* <= 0时，*S*
    * *n* 是与*S*相同类型的空序列。
- en: Membership testing
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 成员测试
- en: The *x* **in** *S* operator tests to check whether the object *x* equals any
    item in the sequence (or other kind of container or iterable) *S*. It returns
    **True** when it does and **False** when it doesn’t. The *x* **not in** *S* operator
    is equivalent to **not** (*x* **in** *S*). For dictionaries, *x* **in** *S* tests
    for the presence of *x* as a key. In the specific case of strings, *x* **in**
    *S* may match more than expected; in this case, *x* **in** *S* tests whether *x*
    equals any *substring* of *S*, not just any single character.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* **in** *S* 运算符用于检查对象*x*是否等于序列（或其他类型的容器或可迭代对象）*S*中的任何项。当匹配时返回**True**，否则返回**False**。*x*
    **not in** *S* 运算符等效于**not** (*x* **in** *S*)。对于字典，*x* **in** *S* 用于测试*x*是否作为键存在。在字符串的特定情况下，*x*
    **in** *S* 可能匹配多个预期外的项；在这种情况下，*x* **in** *S* 测试的是*x*是否等于*S*的任何*子字符串*，而不仅仅是单个字符。'
- en: Indexing a sequence
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引序列
- en: 'To denote the *n*th item of a sequence *S*, use indexing: *S*[*n*]. Indexing
    is zero-based: *S*’s first item is *S*[0]. If *S* has *L* items, the index *n*
    may be 0, 1… up to and including *L*-1, but no larger. *n* may also be –1, –2…
    down to and including *-L*, but no smaller. A negative *n* (e.g., –1) denotes
    the same item in *S* as *L*+*n* (e.g., *L*-1) does. In other words, *S*[-1], like
    S[*L*-1], is the last element of *S*, *S*[-2] is the next-to-last one, and so
    on. For example:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示序列*S*的第*n*个项，请使用索引：*S*[*n*]。索引是从零开始的：*S*的第一个项是*S*[0]。如果*S*有*L*个项，则索引*n*可以是0、1……直到*L*-1，但不能更大。*n*也可以是-1、-2……直到*-L*，但不能更小。负*n*（例如，-1）表示*S*中与*L*+*n*（例如，*L*-1）相同的项。换句话说，*S*[-1]，如*S*[*L*-1]，是*S*的最后一个元素，*S*[-2]是倒数第二个元素，依此类推。例如：
- en: '[PRE57]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Using an index >=*L* or <-*L* raises an exception. Assigning to an item with
    an invalid index also raises an exception. You can add elements to a list, but
    to do so you assign to a slice, not to an item, as we’ll discuss shortly.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大于等于*L*或小于等于*-L*的索引会引发异常。对具有无效索引的项进行赋值也会引发异常。您可以向列表添加元素，但要这样做，您需要对切片进行赋值，而不是对项进行赋值，我们将很快讨论这一点。
- en: Slicing a sequence
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对序列进行切片
- en: 'To indicate a subsequence of *S*, you can use slicing, with the syntax S[*i*:*j*],
    where *i* and *j* are integers. S[*i*:*j*] is the subsequence of *S* from the
    *i*th item, included, to the *j*th item, excluded (in Python, ranges always include
    the lower bound and exclude the upper bound). A slice is an empty subsequence
    when *j* is less than or equal to *i*, or when *i* is greater than or equal to
    *L*, the length of *S*. You can omit *i* when it is equal to 0, so that the slice
    begins from the start of *S*. You can omit *j* when it is greater than or equal
    to *L*, so that the slice extends all the way to the end of *S*. You can even
    omit both indices, to mean a shallow copy of the entire sequence: *S*[:]. Either
    or both indices may be less than zero. Here are some examples:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 要指示 *S* 的子序列，可以使用切片，其语法为 S[*i*:*j*]，其中 *i* 和 *j* 是整数。*S*[*i*:*j*] 是从第 *i* 个项（包括）到第
    *j* 个项（不包括）的 *S* 的子序列（在 Python 中，范围始终包括下限且不包括上限）。当 *j* 小于或等于 *i* 或 *i* 大于或等于 *L*（*S*
    的长度）时，切片是空子序列。当 *i* 等于 0 时，可以省略 *i*，使切片从 *S* 的开头开始。当 *j* 大于或等于 *L* 时，可以省略 *j*，使切片延伸到
    *S* 的末尾。可以同时省略两个索引，以表示整个序列的浅拷贝：*S*[:]。任何一个或两个索引都可能为负数。以下是一些示例：
- en: '[PRE58]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: A negative index *n* in slicing indicates the same spot in *S* as *L*+*n*, just
    like it does in indexing. An index greater than or equal to *L* means the end
    of *S*, while a negative index less than or equal to *-L* means the start of *S*.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 切片中的负索引 *n* 表示与 *S* 中的 *L*+*n* 相同的位置，就像在索引中一样。大于或等于 *L* 的索引表示 *S* 的末尾，而小于或等于
    *-L* 的负索引表示 *S* 的开头。
- en: 'Slicing can use the extended syntax *S*[*i*:*j*:*k*]. *k* is the *stride* of
    the slice, meaning the distance between successive indices. *S*[*i*:*j*] is equivalent
    to *S*[*i*:*j*:*1*], *S*[::2] is the subsequence of *S* that includes all items
    that have an even index in *S*, and *S*[::-1] is a slicing, also whimsically known
    as “the Martian smiley,” with the same items as *S* but in reverse order. With
    a negative stride, in order to have a nonempty slice, the second (“stop”) index
    needs to be *smaller* than the first (“start”) one—the reverse of the condition
    that must hold when the stride is positive. A stride of 0 raises an exception.
    Here are some examples:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 切片可以使用扩展语法 *S*[*i*:*j*:*k*]。*k* 是切片的步长，表示连续索引之间的距离。*S*[*i*:*j*] 相当于 *S*[*i*:*j*:*1*]，*S*[::2]
    是包含 *S* 中所有偶数索引项的子序列，*S*[::-1] 是切片，也以“火星笑脸”闻名，包含与 *S* 相同的项，但顺序相反。使用负步长时，为了得到非空切片，第二个（“停止”）索引必须小于第一个（“开始”）索引——这与步长为正时必须满足的条件相反。步长为
    0 会引发异常。以下是一些示例：
- en: '[PRE59]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Strings
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'String objects (both str and bytes) are immutable: attempting to rebind or
    delete an item or slice of a string raises an exception. (Python also has a built-in
    type that is mutable but otherwise equivalent to bytes: bytearray (see [“bytearray
    objects”](#bytearray_objects)). The items of a text string (each of the characters
    in the string) are themselves text strings, each of length 1—Python has no special
    data type for “single characters” (the items of a bytes or bytearray object are
    ints). All slices of a string are strings of the same kind. String objects have
    many methods, covered in [“Methods of String Objects”](ch09.xhtml#methods_of_string_objects).'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串对象（包括 str 和 bytes）是不可变的：试图重新绑定或删除字符串的项或切片会引发异常。（Python 还有一种内置类型是可变的但在其他方面等同于
    bytes 的：bytearray（参见[“bytearray objects”](#bytearray_objects)）。文本字符串的项（字符串中的每个字符）本身也是文本字符串，每个长度为
    1 — Python 没有“单字符”的特殊数据类型（bytes 或 bytearray 对象的项是整数）。字符串的所有切片都是相同类型的字符串。字符串对象有许多方法，在[“String
    Objects的方法”](ch09.xhtml#methods_of_string_objects)中介绍。
- en: Tuples
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuple objects are immutable: therefore, attempting to rebind or delete an item
    or slice of a tuple raises an exception. The items of a tuple are arbitrary objects
    and may be of different types; tuple items may be mutable, but we recommend not
    mutating them, as doing so can be confusing. The slices of a tuple are also tuples.
    Tuples have no normal (nonspecial) methods, except count and index, with the same
    meanings as for lists; they do have many of the special methods covered in [“Special
    Methods”](ch04.xhtml#special_methods).'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 元组对象是不可变的：因此，试图重新绑定或删除元组的项或切片会引发异常。元组的项可以是任意对象，并且可以是不同类型；元组的项可以是可变的，但我们建议不要变更它们，因为这样做会令人困惑。元组的切片也是元组。元组没有普通（非特殊）方法，除了
    count 和 index，其含义与列表相同；它们有许多特殊方法，在[“特殊方法”](ch04.xhtml#special_methods)中介绍。
- en: Lists
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'List objects are mutable: you may rebind or delete items and slices of a list.
    Items of a list are arbitrary objects and may be of different types. Slices of
    a list are lists.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 列表对象是可变的：可以重新绑定或删除列表的项和切片。列表的项是任意对象，可以是不同类型的。列表的切片是列表。
- en: Modifying a list
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改列表
- en: 'You can modify (rebind) a single item in a list by assigning to an indexing.
    For instance:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对索引进行赋值可以修改（重新绑定）列表中的单个项。例如：
- en: '[PRE69]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Another way to modify a list object *L* is to use a slice of *L* as the target
    (LHS) of an assignment statement. The RHS of the assignment must be an iterable.
    When the LHS slice is in extended form (i.e., the slicing specifies a stride other
    than 1), then the RHS must have just as many items as the number of items in the
    LHS slice. When the LHS slicing does not specify a stride, or explicitly specifies
    a stride of 1, the LHS slice and the RHS may each be of any length; assigning
    to such a slice of a list can make the list longer or shorter. For example:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 修改列表对象 *L* 的另一种方法是将 *L* 的切片用作赋值语句的目标（LHS）。赋值语句的 RHS 必须是可迭代对象。当 LHS 切片是扩展形式（即切片指定除
    1 以外的步长）时，RHS 必须有与 LHS 切片中项数相同的项数。当 LHS 切片未指定步长，或显式指定步长为 1 时，LHS 切片和 RHS 可以是任何长度；向列表的这种切片赋值可以使列表变长或变短。例如：
- en: '[PRE70]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'There are some important special cases of assignment to slices:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些对切片赋值的重要特例：
- en: Using the empty list [] as the RHS expression removes the target slice from
    *L*. In other words, *L*[*i*:*j*] = [] has the same effect as **del** *L*[*i*:*j*]
    (or the peculiar statement *L*[*i*:*j*] *= 0).
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空列表 [] 作为 RHS 表达式可以从 *L* 中移除目标切片。换句话说，*L*[*i*:*j*] = [] 的效果与 **del** *L*[*i*:*j*]（或特殊语句
    *L*[*i*:*j*] *= 0）相同。
- en: Using an empty slice of *L* as the LHS target inserts the items of the RHS at
    the appropriate spot in *L*. For example, *L*[*i*:*i*] = ['a', 'b'] inserts 'a'
    and 'b' before the item that was at index *i* in *L* prior to the assignment.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空切片 *L* 作为 LHS 目标将 RHS 的项插入到 *L* 中适当的位置。例如，*L*[*i*:*i*] = ['a', 'b'] 将 'a'
    和 'b' 插入到在赋值之前索引 *i* 处的 *L* 中。
- en: Using a slice that covers the entire list object, *L*[:], as the LHS target
    totally replaces the contents of *L*.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用覆盖整个列表对象的切片 *L*[:] 作为左手边的目标会完全替换 *L* 的内容。
- en: 'You can delete an item or a slice from a list with **del**. For instance:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 **del** 从列表中删除一个项或一个切片。例如：
- en: '[PRE71]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In-place operations on a list
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表的原位操作
- en: List objects define in-place versions of the + and * operators, which you can
    use via augmented assignment statements. The augmented assignment statement *L*
    += *L1* has the effect of adding the items of the iterable *L1* to the end of
    *L*, just like *L*.extend(*L1*). *L* *= *n* has the effect of adding *n*-1 copies
    of *L* to the end of *L*; if *n* <= 0, *L* *= *n* makes *L* empty, like *L*[:]
    = [] or **del** *L*[:].
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 列表对象定义了 + 和 * 操作符的原位版本，可以通过增强赋值语句使用。增强赋值语句 *L* += *L1* 的效果是将可迭代对象 *L1* 的项添加到
    *L* 的末尾，就像 *L*.extend(*L1*) 一样。*L* *= *n* 的效果是将 *L* 添加 *n*-1 个副本到 *L* 的末尾；如果 *n*
    <= 0，则 *L* *= *n* 会使 *L* 变为空，类似于 *L*[:] = [] 或 **del** *L*[:]。
- en: List methods
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表方法
- en: List objects provide several methods, as shown in [Table 3-5](#list_object_methods).
    Nonmutating methods return a result without altering the object to which they
    apply, while mutating methods may alter the object to which they apply. Many of
    a list’s mutating methods behave like assignments to appropriate slices of the
    list. In this table, *L* indicates any list object, *i* any valid index in *L*,
    *s* any iterable, and *x* any object.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 列表对象提供了多种方法，如 [表格 3-5](#list_object_methods) 所示。非变异方法返回结果而不改变它们应用的对象，而变异方法可能会改变它们应用的对象。许多列表的变异方法的行为类似于对列表适当切片的赋值。在本表中，*L*
    表示任何列表对象，*i* 表示 *L* 中任何有效的索引，*s* 表示任何可迭代对象，*x* 表示任何对象。
- en: Table 3-5\. List object methods
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 3-5\. 列表对象方法
- en: '| **Nonmutating** |   |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| **非变异的** |   |'
- en: '| count | *L*.count(*x*) Returns the number of items of *L* that are equal
    to *x*. |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| count | *L*.count(*x*) 返回 *L* 中等于 *x* 的项的数量。 |'
- en: '| index | *L*.index(*x*) Returns the index of the first occurrence of an item
    in *L* that is equal to *x*, or raises an exception if *L* has no such item. |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| index | *L*.index(*x*) 返回 *L* 中第一次出现的等于 *x* 的项的索引，如果 *L* 中没有这样的项则引发异常。 |'
- en: '| **Mutating** |   |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| **变异的** |   |'
- en: '| append | *L.*append(*x*) Appends item *x* to the end of *L* ; like *L*[len(*L*):]
    = [x]. |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| append | *L.*append(*x*) 将项 *x* 追加到 *L* 的末尾；类似于 *L*[len(*L*):] = [x]。 |'
- en: '| clear | *L.*clear() Removes all items from *L*, leaving *L* empty. |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| clear | *L.*clear() 移除 *L* 中的所有项，使 *L* 变为空列表。 |'
- en: '| extend | *L.*extend(*s*) Appends all the items of iterable *s* to the end
    of *L*; like *L*[len(*L*):] = *s* or *L* += *s*. |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| extend | *L.*extend(*s*) 将可迭代对象*s*的所有项目附加到*L*的末尾；类似于*L*[len(*L*):] = *s*或*L*
    += *s*。 |'
- en: '| insert | *L.*insert(*i*, *x*) Inserts item *x* in *L* before the item at
    index *i*, moving following items of *L* (if any) “rightward” to make space (increases
    len(*L*) by one, does not replace any item, does not raise exceptions; acts just
    like *L*[*i*:*i*]=[*x*]). |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| insert | *L.*insert(*i*, *x*) 在索引*i*之前将项目*x*插入*L*中，将*L*中的后续项目（如果有）向“右移”，以腾出空间（增加len(*L*)一次，不替换任何项目，不引发异常；表现就像*L*[*i*:*i*]=[*x*]一样）。
    |'
- en: '| pop | *L.*pop(*i*=-1) Returns the value of the item at index *i* and removes
    it from *L*; when you omit *i*, removes and returns the last item; raises an exception
    when *L* is empty or *i* is an invalid index in *L*. |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| pop | *L.*pop(*i*=-1) 返回索引*i*处项目的值并将其从*L*中移除；当省略*i*时，移除并返回最后一个项目；当*L*为空或*i*是*L*中的无效索引时，引发异常。
    |'
- en: '| remove | *L.*remove(*x*) Removes from *L* the first occurrence of an item
    in *L* that is equal to *x*, or raises an exception when *L* has no such item.
    |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| remove | *L.*remove(*x*) 从*L*中移除第一个等于*x*的项目，如果*L*中没有这样的项目，则引发异常。 |'
- en: '| reverse | *L.*reverse() Reverses, in place, the items of *L*. |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| reverse | *L.*reverse() 就地反转*L*的项目。 |'
- en: '| sort | *L.*sort*(*key*=***None**, reverse*=***False**) Sorts, in place, the
    items of *L* (in ascending order, by default; in descending order, if the argument
    reverse is **True**). When the argument key is not **None**, what gets compared
    for each item *x* is key(*x*), not *x* itself. For more details, see the following
    section. |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| sort | *L.*sort*(*key*=***None**, reverse*=***False**) 就地对*L*的项目进行排序（默认按升序排序；如果参数reverse为**True**，则按降序排序）。当参数key不是**None**时，每个项目*x*的比较对象是key(*x*)，而不是*x*本身。有关更多详细信息，请参阅以下章节。
    |'
- en: All mutating methods of list objects, except pop, return **None**.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 列表对象的所有突变方法，除了pop，都返回**None**。
- en: Sorting a list
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对列表进行排序
- en: A list’s sort method causes the list to be sorted in place (reordering items
    to place them in increasing order) in a way that is guaranteed to be stable (elements
    that compare equal are not exchanged). In practice, sort is extremely fast—often
    *preternaturally* fast, as it can exploit any order or reverse order that may
    be present in any sublist (the advanced algorithm sort uses, known as *timsort*^([17](ch03.xhtml#ch01fn36))
    to honor its inventor, great Pythonista [Tim Peters](https://oreil.ly/Cbu-F),
    is a “non-recursive adaptive stable natural mergesort/binary insertion sort hybrid”—now
    *there’s* a mouthful for you!).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的sort方法会就地排序列表（重新排列项目以按升序放置），并保证排序是稳定的（相等的元素不会交换位置）。在实践中，sort方法非常快速——通常是*异常*快，因为它可以利用任何子列表中可能存在的顺序或逆序（高级算法sort使用的是*timsort*，以其发明者、伟大的Pythonista
    [Tim Peters](https://oreil.ly/Cbu-F)来命名，这是一种“非递归自适应稳定的自然合并排序/二进制插入排序混合体”——这真是一个难以启齿的名字！）。
- en: 'The sort method takes two optional arguments, which may be passed with either
    positional or named-argument syntax. The argument key, if not **None**, must be
    a function that can be called with any list item as its only argument. In this
    case, to compare any two items *x* and *y*, Python compares key(*x*) and key(*y*)
    rather than *x* and *y* (internally, Python implements this in the same way as
    the decorate–sort–undecorate idiom presented in [“Searching and sorting”](ch17.xhtml#searching_and_sorting),
    but it’s much faster). The argument reverse, if **True**, causes the result of
    each comparison to be reversed; this is not exactly the same thing as reversing
    *L* after sorting, because the sort is stable (elements that compare equal are
    never exchanged) whether the argument reverse is **True** or **False**. In other
    words, Python sorts the list in ascending order by default, or in descending order
    if reverse is **True**:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: sort方法接受两个可选参数，可以使用位置参数或命名参数语法传递。如果参数key不是**None**，则必须是一个可调用的函数，该函数以任何列表项作为其唯一参数进行调用。在这种情况下，为了比较任意两个项目*x*和*y*，Python比较key(*x*)和key(*y*)而不是*x*和*y*本身（在内部，Python实现了与“搜索和排序”章节中介绍的decorate–sort–undecorate惯用法相同的方式，但速度要快得多）。如果参数reverse为**True**，则导致每次比较的结果被颠倒；这与在排序后反转*L*不完全相同，因为排序是稳定的（相等的元素永远不会交换位置），无论参数reverse是**True**还是**False**。换句话说，默认情况下，Python按升序对列表进行排序，如果reverse为**True**，则按降序排序：
- en: '[PRE72]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Python also provides the built-in function sorted (covered in [Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio))
    to produce a sorted list from any input iterable. sorted, after the first argument
    (which is the iterable supplying the items), accepts the same two optional arguments
    as a list’s sort method.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还提供了内置函数 sorted（见 [表 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)）来生成任意输入可迭代对象的排序列表。sorted
    函数除了第一个参数（即提供项目的可迭代对象）外，还接受与列表的 sort 方法相同的两个可选参数。
- en: The standard library module operator (covered in [“The operator Module”](ch16.xhtml#the_operator_module))
    supplies higher-order functions attrgetter, itemgetter, and methodcaller, which
    produce functions particularly suitable for the optional key argument of the list’s
    sort method and the built-in function sorted. This optional argument also exists,
    with exactly the same meaning, for the built-in functions min and max, as well
    as for the functions nsmallest, nlargest, and merge in the standard library module
    heapq (covered in [“The heapq Module”](ch08.xhtml#the_heapq_module)) and the class
    groupby in the standard library module itertools (covered in [“The itertools Module”](ch08.xhtml#the_itertools_module)).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库模块 operator（见 [“operator 模块”](ch16.xhtml#the_operator_module)）提供了高阶函数 attrgetter、itemgetter
    和 methodcaller，它们生成适用于列表 sort 方法和内置函数 sorted 的可选 key 参数的函数。这个可选参数也以完全相同的含义存在于内置函数
    min 和 max，以及标准库模块 heapq 中的函数 nsmallest、nlargest 和 merge（见 [“heapq 模块”](ch08.xhtml#the_heapq_module)）以及标准库模块
    itertools 中的类 groupby（见 [“itertools 模块”](ch08.xhtml#the_itertools_module)）。
- en: Set Operations
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合操作
- en: Python provides a variety of operations applicable to sets (both plain and frozen).
    Since sets are containers, the built-in len function can take a set as its single
    argument and return the number of items in the set. A set is iterable, so you
    can pass it to any function or method that takes an iterable argument. In this
    case, iteration yields the items of the set in some arbitrary order. For example,
    for any set *S*, min(*S*) returns the smallest item in *S*, since min with a single
    argument iterates on that argument (the order does not matter, because the implied
    comparisons are transitive).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了适用于集合（普通集合和冻结集合）的多种操作。由于集合是容器，内置函数 len 可以接受一个集合作为其唯一参数并返回集合中的项数。集合是可迭代的，因此可以将其传递给任何接受可迭代参数的函数或方法。在这种情况下，迭代以任意顺序生成集合的项。例如，对于任何集合
    *S*，min(*S*) 返回 *S* 中的最小项，因为具有单个参数的 min 会迭代该参数（顺序无关紧要，因为隐含的比较是传递的）。
- en: Set Membership
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合成员关系
- en: The *k* **in** *S* operator checks whether the object *k* equals one of the
    items in the set *S*. It returns **True** when the set contains *k*, and **False**
    when it doesn’t. *k* **not** **in** *S* is like **not** (*k* **in** *S*).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '*k* **in** *S* 操作符检查对象 *k* 是否等于集合 *S* 中的任一项。当集合包含 *k* 时返回 **True**，不包含时返回 **False**。*k*
    **not** **in** *S* 类似于 **not** (*k* **in** *S*)。'
- en: Set Methods
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合方法
- en: Set objects provide several methods, as shown in [Table 3-6](#set_object_methods).
    Nonmutating methods return a result without altering the object to which they
    apply, and can also be called on instances of frozenset; mutating methods may
    alter the object to which they apply, and can be called only on instances of set.
    In this table, *s* denotes any set object, *s1* any iterable with hashable items
    (often but not necessarily a set or frozenset), and *x* any hashable object.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 集合对象提供多个方法，如 [表 3-6](#set_object_methods) 所示。非变异方法返回结果而不更改其应用对象，并且也可以用于 frozenset
    的实例；变异方法可能会更改其应用对象，并且只能用于 set 的实例。在本表中，*s* 表示任何集合对象，*s1* 表示任何可哈希项的可迭代对象（通常但不一定是集合或冻结集合），*x*
    表示任何可哈希对象。
- en: Table 3-6\. Set object methods
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-6\. 集合对象方法
- en: '| **Nonmutating** |   |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| **非变异** |   |'
- en: '| copy | *s*.copy() Returns a shallow copy of *s* (a copy whose items are the
    same objects as *s*’s, not copies thereof); like set(*s*) |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| 复制 | *s*.copy() 返回 *s* 的浅拷贝（其项与 *s* 的相同对象，而不是副本）；类似于 set(*s*) |'
- en: '| difference | *s*.difference(*s1*) Returns the set of all items of *s* that
    aren’t in *s1*; can be written as *s* - *s1* |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| 差集 | *s*.difference(*s1*) 返回集合 *s* 中不在 *s1* 中的所有项；可写作 *s* - *s1* |'
- en: '| intersection | *s*.intersection(*s1*) Returns the set of all items of *s*
    that are also in *s1*; can be written as *s* & *s1* |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| 交集 | *s*.intersection(*s1*) 返回集合 *s* 中同时也在 *s1* 中的所有项；可写作 *s* & *s1* |'
- en: '| isdisjoint | *s*.isdisjoint(*s1*) Returns **True** if the intersection of
    *s* and *s1* is the empty set (they have no items in common), and otherwise returns
    **False** |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| isdisjoint | *s*.isdisjoint(*s1*) 如果 *s* 和 *s1* 的交集为空集（它们没有共同项），则返回 **True**，否则返回
    **False** |'
- en: '| issubset | *s*.issubset(*s1*) Returns **True** when all items of *s* are
    also in *s1*, and otherwise returns **False**; can be written as *s* <= *s1* |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| issubset | *s*.issubset(*s1*) 当 *s* 的所有项也都在 *s1* 中时返回 **True**，否则返回 **False**；可以写成
    *s* <= *s1* |'
- en: '| issuperset | *s*.issuperset(*s1*) Returns **True** when all items of *s1*
    are also in *s*, and otherwise returns **False** (like *s1*.issubset(*s*)); can
    be written as *s* >= *s1* |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| issuperset | *s*.issuperset(*s1*) 当 *s* 包含 *s1* 的所有项时返回 **True**，否则返回 **False**（类似于
    *s1*.issubset(*s*)）；可以写成 *s* >= *s1* |'
- en: '| symmet⁠r⁠i⁠c⁠_​d⁠i⁠f⁠ference | *s*.symmetric_difference(*s1*) Returns the
    set of all items that are in either *s* or *s1*, but not both; can be written
    *s ^ s1* |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| symmet⁠r⁠i⁠c⁠_​d⁠i⁠f⁠ference | *s*.symmetric_difference(*s1*) 返回所有在 *s* 或
    *s1* 中的项，但不同时在 *s* 和 *s1* 中；可以写成 *s ^ s1* |'
- en: '| union | *s*.union(*s1*) Returns the set of all items that are in *s*, *s1*,
    or both; can be written as *s* &#124; *s1* |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| union | *s*.union(*s1*) 返回所有在 *s*、*s1* 或两者中的项的集合；可以写成 *s* &#124; *s1* |'
- en: '| **Mutating** |   |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| **Mutating** |   |'
- en: '| add | *s*.add(*x*) Adds *x* as an item to *s*; no effect if *x* was already
    an item in *s* |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| add | *s*.add(*x*) 将 *x* 作为一个项添加到 *s*；如果 *x* 已经是 *s* 的项，则无效果 |'
- en: '| clear | *s*.clear() Removes all items from *s*, leaving *s* empty |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| clear | *s*.clear() 清空 *s* 中的所有项，使 *s* 变为空集 |'
- en: '| discard | *s*.discard(*x*) Removes *x* as an item of *s*; no effect when
    *x* was not an item of *s* |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| discard | *s*.discard(*x*) 从 *s* 中移除 *x* 作为一个项；如果 *x* 不是 *s* 的项，则无效果 |'
- en: '| pop | *s*.pop() Removes and returns an arbitrary item of *s* |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| pop | *s*.pop() 移除并返回 *s* 中的一个任意项 |'
- en: '| remove | *s*.remove(*x*) Removes *x* as an item of *s*; raises a KeyError
    exception when *x* was not an item of *s* |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| remove | *s*.remove(*x*) 从 *s* 中移除 *x* 作为一个项；如果 *x* 不是 *s* 的项，则引发 KeyError
    异常 |'
- en: All mutating methods of set objects, except pop, return **None**.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合对象的变异方法，除了 pop，都返回 **None**。
- en: 'The pop method can be used for destructive iteration on a set, consuming little
    extra memory. The memory savings make pop usable for a loop on a huge set, when
    what you want is to “consume” the set in the course of the loop. Besides saving
    memory, a potential advantage of a destructive loop such as this:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: pop 方法可以用于集合的破坏性迭代，消耗少量额外内存。这种节约内存的方式使得 pop 方法在处理大型集合时非常有用，特别是当你希望在循环过程中“消耗”集合时。除了节省内存之外，这种破坏性循环的潜在优势还包括：
- en: '[PRE73]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'in comparison to a nondestructive loop such as this:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于这样的非破坏性循环：
- en: '[PRE74]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: is that in the body of the destructive loop you’re allowed to modify *S* (adding
    and/or removing items), which is not allowed in the nondestructive loop.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在破坏性循环的主体中，你被允许修改 *S*（添加和/或移除项），而在非破坏性循环中则不允许。
- en: Sets also have mutating methods named difference_update, intersection_update,
    symmetric_difference_update, and update (corresponding to the nonmutating method
    union). Each such mutating method performs the same operation as the corresponding
    nonmutating method, but it performs the operation in place, altering the set on
    which you call it, and returns **None**.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 集合还具有名为 difference_update、intersection_update、symmetric_difference_update 和
    update 的变异方法（对应于非变异方法 union）。每个这样的变异方法执行与对应的非变异方法相同的操作，但它会直接在调用它的集合上执行操作，改变集合，并返回
    **None**。
- en: 'The four corresponding nonmutating methods are also accessible with operator
    syntax (where *S2* is a set or frozenset, respectively, *S* - *S2*, *S* & *S2*,
    *S* ^ *S2*, and *S* | *S2*) and the mutating methods are accessible with augmented
    assignment syntax (respectively, *S* -= *S2*, *S* &= *S2*, *S* ^= *S2*, and *S*
    |= *S2*). In addition, sets and frozensets also support comparison operators:
    == (the sets have the same items; that is, they’re “equal” sets), != (the reverse
    of ==), >= (issuperset), <= (issubset), < (issubset and not equal), and > (issuperset
    and not equal).'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 四个对应的非变异方法也可以通过运算符语法访问（其中 *S2* 是一个集合或不可变集合，分别为 *S* - *S2*、*S* & *S2*、*S* ^ *S2*
    和 *S* | *S2*），而变异方法可以通过增强赋值语法访问（分别为 *S* -= *S2*、*S* &= *S2*、*S* ^= *S2* 和 *S*
    |= *S2*）。此外，集合和不可变集合还支持比较运算符：==（集合具有相同的项；即它们是“相等”的集合）、!=（与 == 相反）、>=（issuperset）、<=（issubset）、<（issubset
    且不相等）、>（issuperset 且不相等）。
- en: When you use operator or augmented assignment syntax, both operands must be
    sets or frozensets; however, when you call named methods, argument *S1* can be
    any iterable with hashable items, and it works just as if the argument you passed
    was set(*S1*).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用运算符或增强赋值语法时，两个操作数必须是集合或不可变集合；然而，当您调用命名方法时，参数 *S1* 可以是任何具有可哈希项的可迭代对象，并且它的工作方式就像您传递的参数是
    set(*S1*) 一样。
- en: Dictionary Operations
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典操作
- en: Python provides a variety of operations applicable to dictionaries. Since dictionaries
    are containers, the built-in len function can take a dictionary as its argument
    and return the number of items (key/value pairs) in the dictionary. A dictionary
    is iterable, so you can pass it to any function that takes an iterable argument.
    In this case, iteration yields only the keys of the dictionary, in insertion order.
    For example, for any dictionary *D*, min(*D*) returns the smallest key in *D*
    (the order of keys in the iteration doesn’t matter here).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了许多适用于字典的操作。由于字典是容器，内置的 len 函数可以接受字典作为参数，并返回字典中条目（键/值对）的数量。字典是可迭代的，因此您可以将其传递给任何接受可迭代参数的函数。在这种情况下，迭代按插入顺序仅生成字典的键。例如，对于任何字典
    *D*，min(*D*) 返回字典中最小的键（迭代中的键顺序在此处无关紧要）。
- en: Dictionary Membership
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典成员资格
- en: The *k* **in** *D* operator checks whether the object *k* is a key in the dictionary
    *D*. It returns **True** if the key is present, and **False** otherwise. *k* **not
    in** *D* is like **not** (*k* **in** *D*).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '*k* **in** *D* 运算符检查对象 *k* 是否是字典 *D* 的键。如果键存在，则返回 **True**，否则返回 **False**。*k*
    **not in** *D* 类似于 **not** (*k* **in** *D*)。'
- en: Indexing a Dictionary
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典索引
- en: 'To denote the value in a dictionary *D* currently associated with the key *k*,
    use an indexing: *D*[*k*]. Indexing with a key that is not present in the dictionary
    raises an exception. For example:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示字典 *D* 中当前与键 *k* 关联的值，请使用索引：*D*[*k*]。使用不在字典中的键进行索引会引发异常。例如：
- en: '[PRE75]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Plain assignment to a dictionary indexed with a key that is not yet in the
    dictionary (e.g., *D*[*newkey*]=*value*) is a valid operation and adds the key
    and value as a new item in the dictionary. For instance:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 用尚未存在于字典中的键进行简单赋值（例如，*D*[*newkey*]=*value*）是一个有效的操作，并将键和值作为字典中的新条目添加进去。例如：
- en: '[PRE76]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The **del** statement, in the form **del** *D*[*k*], removes from the dictionary
    the item whose key is *k*. When *k* is not a key in dictionary *D*, **del** *D*[*k*]
    raises a KeyError exception.​
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '**del** 语句，以形式 **del** *D*[*k*]，从字典中移除键为 *k* 的条目。当 *k* 不是字典 *D* 的键时，**del**
    *D*[*k*] 引发 KeyError 异常。'
- en: Dictionary Methods
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典方法
- en: Dictionary objects provide several methods, as shown in [Table 3-7](#dictionary_object_methods).
    Nonmutating methods return a result without altering the object to which they
    apply, while mutating methods may alter the object to which they apply. In this
    table, *d* and *d1* indicate any dictionary objects, *k* any hashable object,
    and *x* any object.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 字典对象提供了几种方法，如[表 3-7](#dictionary_object_methods)所示。非变动方法返回结果而不更改其应用对象，而变动方法可能会更改其应用对象。在此表中，*d*
    和 *d1* 表示任意字典对象，*k* 表示任何可哈希对象，*x* 表示任何对象。
- en: Table 3-7\. Dictionary object methods
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-7\. 字典对象方法
- en: '| **Nonmutating** |   |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| **非变动** |   |'
- en: '| copy | *d.*copy() Returns a shallow copy of the dictionary (a copy whose
    items are the same objects as *D*’s, not copies thereof, just like dict(*d*))
    |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| copy | *d.*copy() 返回字典的浅拷贝（一个与 *D* 相同对象的拷贝，而不是它们的副本，就像 dict(*d*) 一样） |'
- en: '| get | *d.*get(*k*[, *x*]) Returns *d*[*k*] when *k* is a key in *d*; otherwise,
    returns *x* (or **None**, when you don’t pass *x*) |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| get | *d.*get(*k*[, *x*]) 当 *k* 是 *d* 的键时，返回 *d*[*k*]；否则返回 *x*（或者当您不传递 *x*
    时，返回 **None**） |'
- en: '| items | *d*.items() Returns an iterable view object whose items are all current
    items (key/value pairs) in *d* |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| items | *d*.items() 返回一个可迭代的视图对象，其条目是 *d* 中所有当前的条目（键/值对） |'
- en: '| keys | *d*.keys() Returns an iterable view object whose items are all current
    keys in *d* |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| keys | *d*.keys() 返回一个可迭代的视图对象，其条目是 *d* 中所有当前的键 |'
- en: '| values | *d*.values() Returns an iterable view object whose items are all
    current values in *d* |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| values | *d*.values() 返回一个可迭代的视图对象，其条目是 *d* 中所有当前的值 |'
- en: '| **Mutating** |   |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| **变动** |   |'
- en: '| clear | *d*.clear() Removes all items from *d*, leaving *d* empty |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| clear | *d*.clear() 移除 *d* 中的所有条目，使 *d* 变为空字典 |'
- en: '| pop | *d.*pop(*k*[, *x*]) Removes and returns *d*[*k*] when *k* is a key
    in *d*; otherwise, returns *x* (or raises a KeyError exception when you don’t
    pass *x*) |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| pop | *d.*pop(*k*[, *x*]) 当 *k* 是 *d* 的键时，移除并返回 *d*[*k*]；否则返回 *x*（或者当您不传递
    *x* 时，引发 KeyError 异常） |'
- en: '| popitem | *d*.popitem() Removes and returns the items from *d* in last-in,
    first-out order |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| popitem | *d*.popitem() 按后进先出顺序从 *d* 中移除并返回项目。'
- en: '| setdefault | *d*.setdefault(*k*, *x*) Returns *d*[*k*] when *k* is a key
    in *d*; otherwise, sets *d*[*k*] equal to *x* (or **None**, when you don’t pass
    *x*), then returns *d*[*k*] |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| setdefault | *d*.setdefault(*k*, *x*) 当 *k* 是 *d* 的一个键时返回 *d*[*k*]；否则，设置
    *d*[*k*] 等于 *x*（或 **None**，当未传递 *x* 时），然后返回 *d*[*k*]。'
- en: '| update | *d*.update(*d1*) For each *k* in mapping *d1*, sets *d*[*k*]equal
    to *d1*[*k*] |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| update | *d*.update(*d1*) 对于映射 *d1* 中的每个 *k*，设置 *d*[*k*] 等于 *d1*[*k*]。'
- en: The items, keys, and values methods return values known as *view objects*. If
    the underlying dict changes, the retrieved view also changes; Python doesn’t allow
    you to alter the set of keys in the underlying dict while using a **for** loop
    on any of its view objects.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: items、keys 和 values 方法返回称为 *视图对象* 的值。如果底层字典发生更改，则检索的视图也会更改；Python 不允许在使用 **for**
    循环遍历其任何视图对象时修改底层字典的键集。
- en: Iterating on any of the view objects yields values in insertion order. In particular,
    when you call more than one of these methods without any intervening change to
    the dict, the order of the results is the same for all of them.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何视图对象进行迭代时，按插入顺序产生值。特别是当在没有任何中间更改字典的情况下调用多个这些方法时，结果的顺序对所有方法都是相同的。
- en: Dictionaries also support the class method fromkeys(*seq*, *value*), which returns
    a dictionary containing all the keys of the given iterable *seq*, each identically
    initialized with *value*.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 字典还支持类方法 fromkeys(*seq*, *value*)，它返回一个包含给定可迭代序列 *seq* 中所有键的字典，每个键都以 *value*
    初始化。
- en: Never Modify a dict’s Keys While Iterating on It
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在迭代字典时永远不要修改其键。
- en: Don’t ever modify the set of keys in a dict (i.e., add or remove keys) while
    iterating over that dict or any of the iterable views returned by its methods.
    If you need to avoid such constraints against mutation during iteration, iterate
    instead on a list explicitly built from the dict or view (i.e., on list(*D*)).
    Iterating directly on a dict *D* is exactly like iterating on *D*.keys().
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代字典或其方法返回的任何可迭代视图时，不要修改字典的键集（即添加或删除键）。如果需要避免在迭代过程中对字典进行变更，建议明确地在从字典或视图构建的列表上进行迭代（即在
    list(*D*) 上）。直接在字典 *D* 上进行迭代与在 *D*.keys() 上进行迭代完全相同。
- en: The return values of the items and keys methods also implement set nonmutating
    methods and behave much like frozensets; the return value of the method values
    doesn’t, since, in contrast to the others (and to sets), it may contain duplicates.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: items 和 keys 方法的返回值还实现了集合非变异方法，并且行为类似于 frozensets；而 values 方法的返回值不是，因为与其他方法（以及集合）不同，它可能包含重复项。
- en: The popitem method can be used for destructive iteration on a dictionary. Both
    items and popitem return dictionary items as key/value pairs. popitem is usable
    for a loop on a huge dictionary, when what you want is to “consume” the dictionary
    in the course of the loop.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: popitem 方法可用于对字典进行破坏性迭代。items 和 popitem 都返回字典项作为键/值对。在处理大型字典时，popitem 可用于在循环过程中“消耗”字典。
- en: '*D*.setdefault(*k*, *x*) returns the same result as *D*.get(*k*, *x*); but,
    when *k* is not a key in *D*, setdefault also has the side effect of binding *D*[*k*]
    to the value *x*. (In modern Python, setdefault is not often used, since the type
    collections.defaultdict, covered in [“defaultdict”](ch08.xhtml#defaultdict), often
    offers similar, faster, clearer functionality.)'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '*D*.setdefault(*k*, *x*) 返回与 *D*.get(*k*, *x*) 相同的结果；但当 *k* 不是 *D* 的一个键时，setdefault
    还具有将 *D*[*k*] 绑定到值 *x* 的副作用（在现代 Python 中，setdefault 不经常使用，因为类型 collections.defaultdict，详见
    [“defaultdict”](ch08.xhtml#defaultdict)，通常提供类似、更快、更清晰的功能）。'
- en: The pop method returns the same result as get, but when *k* is a key in *D*,
    pop also has the side effect of removing *D*[*k*] (when *x* is not specified,
    and *k* is not a key in *D*, get returns **None**, but pop raises an exception).
    *d*.pop(*key*, **None**) is a useful shortcut for removing a key from a dict without
    having to first check if the key is present, much like *s*.discard(*x*) (as opposed
    to *s*.remove(*x*)) when *s* is a set.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: pop 方法与 get 方法返回相同的结果，但当 *k* 是 *D* 中的一个键时，pop 方法还具有移除 *D*[*k*] 的副作用（当未指定 *x*
    且 *k* 不是 *D* 的键时，get 返回 **None**，但 pop 会引发异常）。*d*.pop(*key*, **None**) 是从字典中删除键的一个有用快捷方式，无需先检查键是否存在，类似于
    *s*.discard(*x*)（与 *s*.remove(*x*) 相对应，*s* 是一个集合）。
- en: '3.9+ The update method is accessible with augmented assignment syntax: where
    *D2* is a dict, *D* |= *D2* is the same as *D*.update(*D2*). Operator syntax,
    *D* | *D2*, mutates neither dictionary: rather, it returns a new dictionary result,
    such that *D3* = *D* | *D2* is equivalent to *D3* = *D*.copy(); *D3*.update(*D2*).'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 3.9+ 更新方法可以通过增强赋值语法进行访问：其中 *D2* 是一个字典，*D* |= *D2* 与 *D*.update(*D2*) 相同。操作符语法，*D*
    | *D2*，不会改变任何字典：相反，它返回一个新的字典结果，使得 *D3* = *D* | *D2* 等同于 *D3* = *D*.copy(); *D3*.update(*D2*)。
- en: The update method (but not the | and |= operators) can also accept an iterable
    of key/value pairs as an alternative argument instead of a mapping, and can accept
    named arguments instead of—or in addition to—its positional argument; the semantics
    are the same as for passing such arguments when calling the built-in dict type,
    as covered in [“Dictionaries”](#dictionaries).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 更新方法（但不包括 | 和 |= 操作符）还可以接受键/值对的可迭代对象作为替代参数，而不是映射，并且可以接受命名参数而不是或者除了它的位置参数；当调用内置的
    dict 类型时，传递这些参数的语义与[“字典”](#dictionaries)中涵盖的相同。
- en: Control Flow Statements
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流程语句
- en: A program’s *control flow* regulates the order in which the program’s code executes.
    The control flow of a Python program mostly depends on conditional statements,
    loops, and function calls. (This section covers the **if** and **match** conditional
    statements, and **for** and **while** loops; we cover functions in the following
    section.) Raising and handling exceptions also affects control flow (via the **try**
    and **with** statements); we cover exceptions in [Chapter 6](ch06.xhtml#exceptions).
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的*控制流*调节了程序代码执行的顺序。Python 程序的控制流主要取决于条件语句、循环和函数调用。（本节涵盖了 **if** 和 **match**
    条件语句，以及 **for** 和 **while** 循环；我们在接下来的章节中介绍了异常的引发和处理方式（通过 **try** 和 **with** 语句）；异常在
    [第 6 章](ch06.xhtml#exceptions)中介绍。
- en: The if Statement
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if 语句
- en: 'Often, you’ll need to execute some statements only when some condition holds,
    or choose statements to execute depending on mutually exclusive conditions. The
    compound statement **if**—comprising **if**, **elif**, and **else** clauses—lets
    you conditionally execute blocks of statements. The syntax for the **if** statement
    is:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，您需要仅当某些条件成立时执行某些语句，或者根据互斥条件选择要执行的语句。由 **if**、**elif** 和 **else** 子句组成的复合语句可让您有条件地执行语句块。
    **if** 语句的语法如下：
- en: '[PRE77]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The **elif** and **else** clauses are optional. Before the introduction of the
    **match** construct, which we’ll look at next, using **if**, **elif**, and **else**
    was the most common approach for all conditional processing (although at times
    a dict with callables as values might provide a good alternative).
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**elif** 和 **else** 子句是可选的。在引入我们接下来将要查看的 **match** 构造之前，使用 **if**、**elif**
    和 **else** 是所有条件处理的最常见方法（尽管有时使用具有可调用值的字典可能会提供一个很好的替代方法）。'
- en: 'Here’s a typical **if** statement with all three kinds of clauses:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的 **if** 语句，包含了所有三种子句：
- en: '[PRE78]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Each clause controls one or more statements (known as a block): place the block’s
    statements on separate logical lines after the line containing the clause’s keyword
    (known as the *header line* of the clause), indented four spaces past the header
    line. The block terminates when the indentation returns to the level of the clause
    header, or further left from there (this is the style mandated by [PEP 8](https://oreil.ly/O3SO-)).'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子句控制一个或多个语句（称为一个块）：在包含子句关键字的行（称为子句的*头行*）之后，将块的语句放在单独的逻辑行上，缩进四个空格。当缩进返回到子句头的级别时，或者从那里进一步向左移动时，块终止（这是由
    [PEP 8](https://oreil.ly/O3SO-) 规定的风格）。
- en: 'You can use any Python expression^([18](ch03.xhtml#ch01fn37)) as the condition
    in an **if** or **elif** clause. Using an expression this way is known as using
    it *in a Boolean context*. In this context, any value is taken as being either
    true or false. As mentioned earlier, any nonzero number or nonempty container
    (string, tuple, list, dictionary, set, etc.) evaluates as true, while zero (0,
    of any numeric type), **None**, and empty containers evaluate as false. To test
    a value *x* in a Boolean context, use the following coding style:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 **if** 或 **elif** 子句中使用任何 Python 表达式^([18](ch03.xhtml#ch01fn37)) 作为条件。以这种方式使用表达式称为在*布尔上下文*中使用它。在此上下文中，任何值都被视为真或假。如前所述，任何非零数字或非空容器（字符串、元组、列表、字典、集合等）都会评估为
    true，而零（0，任何数字类型）、**None** 和空容器则会评估为 false。要在布尔上下文中测试值 *x*，请使用以下编码样式：
- en: '[PRE79]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This is the clearest and most Pythonic form.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最清晰和最符合 Python 风格的形式。
- en: 'Do *not* use any of the following:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用以下任何内容：
- en: '[PRE80]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: There is a crucial difference between saying that an expression *returns* **True**
    (meaning the expression returns the value 1 with the bool type) and saying that
    an expression *evaluates as* true (meaning the expression returns any result that
    is true in a Boolean context). When testing an expression, for example in an **if**
    clause, you only care about what it *evaluates as*, not what, precisely, it *returns*.
    As we previously mentioned, “evaluates as true” is often expressed informally
    as “is truthy,” and “evaluated as false” as “is falsy.”
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 说一个表达式*返回* **True**（表示该表达式以bool类型返回值1），与说一个表达式*评估为* true（表示该表达式返回在布尔上下文中为真的任何结果）之间存在重要区别。例如，在**if**子句中测试表达式时，你只关心它*评估为*什么，而不是它*返回*什么。正如我们先前提到的，“评估为真”通常非正式表达为“是真的”，而“评估为假”则为“是假的”。
- en: When the **if** clause’s condition evaluates as true, the statements within
    the **if** clause execute, then the entire **if** statement ends. Otherwise, Python
    evaluates each **elif** clause’s condition, in order. The statements within the
    first **elif** clause whose condition evaluates as true, if any, execute, and
    the entire **if** statement ends. Otherwise, when an **else** clause exists, it
    executes. In any case, statements following the entire **if** construct, at the
    same level, execute next.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 当**if**子句的条件评估为真时，执行**if**子句内的语句，然后整个**if**语句结束。否则，Python按顺序评估每个**elif**子句的条件。如果任何**elif**子句的条件评估为真，则执行该子句内的语句，并且整个**if**语句结束。否则，当存在**else**子句时执行其内的语句。在任何情况下，执行在整个**if**结构后面，同一级别的语句会接着执行。
- en: The match Statement
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**match**语句'
- en: '**3.10+** The **match** statement brings *structural pattern matching* to the
    Python language. You might think of this as doing for other Python types something
    similar to what the re module (see [“Regular Expressions and the re Module”](ch10.xhtml#regular_expressions_and_the_re_module))
    does for strings: it allows easy testing of the structure and contents of Python
    objects.^([19](ch03.xhtml#ch01fn38)) Resist the temptation to use **match** unless
    there is a need to analyze the *structure* of an object.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.10+** **match**语句将*结构化模式匹配*引入Python语言。你可以将其视为对Python类型执行与re模块（参见[“正则表达式和re模块”](ch10.xhtml#regular_expressions_and_the_re_module)）类似的操作：它允许轻松测试Python对象的结构和内容。^([19](ch03.xhtml#ch01fn38))
    除非需要分析对象的*结构*，否则应抵制使用**match**的诱惑。'
- en: 'The overall syntactic structure of the statement is the new (soft) keyword
    **match** followed by an expression whose value becomes the *matching subject*.
    This is followed by one or more indented **case** clauses, each of which controls
    the execution of the indented code block it contains:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句的整体语法结构是新的（软）关键字**match**，后跟一个表达式，其值成为*匹配主题*。然后是一个或多个缩进的**case**子句，每个控制它包含的缩进代码块的执行：
- en: '[PRE81]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In execution, Python first evaluates the *expression*, then tests the resulting
    subject value against the *pattern* in each **case** in turn, in order from first
    to last, until one matches: then, the block indented within the matching **case**
    clause evaluates. A pattern can do two things:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，Python首先评估*表达式*，然后按顺序测试每个**case**中的*模式*与生成的主题值是否匹配，直到找到一个匹配的为止：然后，执行与匹配的**case**子句缩进的块。模式可以执行两个操作：
- en: Verify that the subject is an object with a particular structure.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证主语是否是具有特定结构的对象。
- en: Bind matched components to names for further use (usually within the associated
    **case** clause).
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将匹配的组件绑定到名称以供进一步使用（通常在相关的**case**子句内）。
- en: When a pattern matches the subject, the *guard* allows a final check before
    selection of the case for execution. All the pattern’s name bindings have occurred,
    and you can use them in the guard. When there is no guard, or when the guard evaluates
    as true, the case’s indented code block executes, after which the **match** statement’s
    execution is complete and no further cases are checked.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 当模式与主题匹配时，*守卫*允许在选择执行用例之前进行最终检查。所有模式的名称绑定已经发生，你可以在守卫中使用它们。当没有守卫，或者守卫评估为真时，执行案例的缩进代码块，之后**match**语句的执行完成，不再检查进一步的用例。
- en: The **match** statement, per se, provides no default action. If one is needed,
    the last **case** clause must specify a *wildcard* pattern—one whose syntax ensures
    it matches any subject value. It is a SyntaxError to follow a **case** clause
    having such a wildcard pattern with any further **case** clauses.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**match**语句本身不提供默认操作。如果需要一个，默认情况下**case**子句必须指定一个通配符模式——确保它匹配任何主题值的语法。在具有这种通配符模式的**case**子句之后跟随任何进一步**case**子句是SyntaxError。'
- en: Pattern elements cannot be created in advance, bound to variables, and (for
    example) reused in multiple places. Pattern syntax is only valid immediately following
    the (soft) keyword **case**, so there is no way to perform such an assignment.
    For each execution of a **match** statement, the interpreter is free to cache
    pattern expressions that repeat inside the cases, but the cache starts empty for
    each new execution.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 模式元素不能预先创建，绑定到变量，并且（例如）在多个位置重复使用。模式语法仅在（软）关键字**case**之后立即有效，因此没有办法执行这样的赋值。对于每个**match**语句的执行，解释器可以自由地缓存重复出现在案例中的模式表达式，但缓存对于每次新执行都是空的。
- en: We’ll first describe the various types of pattern expressions, before discussing
    guards and providing some more complex examples.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先描述各种类型的模式表达式，然后讨论守卫并提供一些更复杂的示例。
- en: Pattern Expressions Have Their Own Semantics
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式表达式具有自己的语义
- en: The syntax of pattern expressions might seem familiar, but their *interpretation*
    is sometimes quite different from that of nonpattern expressions, which could
    mislead readers unaware of those differences. Specific syntactic forms are used
    in the **case** clause to indicate matching of particular structures. A complete
    summary of this syntax would require more than the simplified notation we use
    in this book;^([20](ch03.xhtml#ch01fn39)) we therefore prefer to explain this
    new feature in plain language, with examples. For more detailed examples, refer
    to the Python [documentation](https://oreil.ly/UlgQF).
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 模式表达式的语法可能看起来很熟悉，但它们的*解释*有时与非模式表达式完全不同，这可能会误导不了解这些差异的读者。特定的语法形式在**case**子句中用于指示特定结构的匹配。在本书中，我们使用的简化表示法不足以完整总结此语法的概述；^([20](ch03.xhtml#ch01fn39))
    因此，我们更喜欢用简单的语言和示例来解释这一新特性。有关更详细的示例，请参阅Python [文档](https://oreil.ly/UlgQF)。
- en: Building patterns
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建模式
- en: Patterns are expressions, though with a syntax specific to the **case** clause,
    so familiar grammatical rules apply even though certain features are interpreted
    differently. They can be enclosed in parentheses to let elements of a pattern
    be treated as a single expression unit. Like other expressions, patterns have
    a recursive syntax and can be combined to form more complex patterns. Let’s start
    with the simplest patterns first.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是表达式，尽管具有与**case**子句特定的语法，因此即使某些特性被不同解释，也适用熟悉的语法规则。它们可以用括号括起来，以便将模式的元素视为单个表达式单元。与其他表达式一样，模式具有递归语法，并可组合形成更复杂的模式。让我们从最简单的模式开始。
- en: Literal patterns
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字面模式
- en: 'Most literal values are valid patterns. Integer, float, complex number, and
    string literals (but *not* formatted string literals) are all permissible,^([21](ch03.xhtml#ch01fn40))
    and all succeed in matching subjects of the same type and value:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数字面值都是有效的模式。整数、浮点数、复数和字符串字面值（但*不是*格式化字符串字面值）都是允许的，^([21](ch03.xhtml#ch01fn40))
    并且在匹配相同类型和值的主题时都成功：
- en: '[PRE82]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: For most matches, the interpreter checks for equality without type checking,
    which is why 42.0 matches integer 42. If the distinction is important, consider
    using class matching (see [“Class patterns”](#class_patterns)) rather than literal
    matching. **True**, **False**, and **None** being singleton objects, each matches
    itself.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数匹配项，解释器在没有类型检查的情况下检查相等性，这就是为什么42.0与整数42匹配。如果区分很重要，请考虑使用类匹配（参见[“类模式”](#class_patterns)）而不是字面匹配。**True**、**False**和**None**作为单例对象，每个都与自身匹配。
- en: The wildcard pattern
  id: totrans-549
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通配符模式
- en: 'In pattern syntax, the underscore (**_**) plays the role of a wildcard expression.
    As the simplest wildcard pattern, **_** matches any value at all:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式语法中，下划线（**_**）扮演通配符表达式的角色。作为最简单的通配符模式，**_**可以匹配任何值：
- en: '[PRE84]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Capture patterns
  id: totrans-553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获模式
- en: The use of unqualified names (names with no dots in them) is so different in
    patterns that we feel it necessary to begin this section with a warning.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式中使用未限定名称（没有点的名称）与非模式中的使用方式非常不同，因此我们觉得有必要在本节开始时发出警告。
- en: Simple Names Bind to Matched Elements Inside Patterns
  id: totrans-555
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单名称绑定到模式内部匹配的元素
- en: Unqualified names—simple identifiers (e.g., *color*) rather than attribute references
    (e.g., *name.attr*)—do not necessarily have their usual meaning in pattern expressions.
    Some names, rather than being references to values, are instead bound to elements
    of the subject value during pattern matching.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 未限定名称—简单标识符（例如*color*）而不是属性引用（例如*name.attr*）—在模式表达式中不一定具有它们通常的含义。某些名称不是值的引用，而是在模式匹配期间绑定到主体值的元素。
- en: 'Unqualified names, except _, are *capture patterns*. They’re wildcards, matching
    anything, but with a side effect: the name, in the current local namespace, gets
    bound to the object matched by the pattern. Bindings created by matching remain
    after the statement has executed, allowing the statements in the **case** clause
    and subsequent code to process extracted portions of the subject value.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 除了_之外，未限定名称是*捕获模式*。它们是通配符，匹配任何内容，但有一个副作用：在当前局部命名空间中，名称绑定到模式匹配的对象。匹配创建的绑定在语句执行后保留，允许**case**子句和随后的代码处理主体值的提取部分。
- en: 'The following example is similar to the preceding one, except that the name
    x, instead of the underscore, matches the subject. The absence of exceptions shows
    that the name captures the whole subject in each case:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例与前面的示例类似，但名称x而不是下划线在主体中进行匹配。没有异常显示名称在每种情况下捕获整个主体：
- en: '[PRE86]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Value patterns
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值模式
- en: This section, too, begins with a reminder to readers that simple names can’t
    be used to inject their bindings into pattern values to be matched.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节也从一个提醒开始，指出简单名称不能用于将它们的绑定注入到要匹配的模式值中。
- en: Represent Variable Values in Patterns with Qualified Names
  id: totrans-562
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用限定名称在模式中表示变量值
- en: Because simple names capture values during pattern matching, you *must* use
    attribute references (qualified names like *name.attr*) to express values that
    may change between different executions of the same **match** statement.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 因为简单名称在模式匹配期间捕获值，您*必须*使用属性引用（如*name.attr*这样的限定名称）来表示在同一**match**语句的不同执行之间可能变化的值。
- en: 'Though this feature is useful, it means you can’t reference values directly
    with simple names. Therefore, in patterns, values must be represented by qualified
    names, which are known as *value patterns*—they *represent* values, rather than
    *capturing* them as simple names do. While slightly inconvenient, to use qualified
    names you can just set attribute values on an otherwise empty class.^([22](ch03.xhtml#ch01fn41))
    For example:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个特性很有用，但意味着您不能直接使用简单名称引用值。因此，在模式中，值必须由限定名称表示，这些被称为*值模式*—它们*表示*值，而不像简单名称那样*捕获*它们。虽然有些许不便，但使用限定名称，您只需在一个否则为空的类上设置属性值。^([22](ch03.xhtml#ch01fn41))
    例如：
- en: '[PRE87]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'It is easy to give yourself access to the current module’s “global” namespace,
    like this:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问当前模块的“全局”命名空间非常容易，像这样：
- en: '[PRE89]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: OR patterns
  id: totrans-570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OR模式
- en: 'When *P1* and *P2* are patterns, the expression *P1 | P2* is an *OR pattern*,
    matching anything that matches either *P1* or *P2*, as shown in the following
    example. Any number of alternate patterns can be used, and matches are attempted
    from left to right:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 当*P1*和*P2*是模式时，表达式*P1 | P2*是一个*OR模式*，匹配与*P1*或*P2*中任一模式匹配的任何内容，如下例所示。可以使用任意数量的替代模式，匹配从左到右尝试：
- en: '[PRE91]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: It is a syntax error to follow a wildcard pattern with further alternatives,
    however, since they can never be activated. While our initial examples are simple,
    remember that the syntax is recursive, so patterns of arbitrary complexity can
    replace any of the subpatterns in these examples.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在通配符模式后面跟随更多的替代是语法错误，因为它们永远不会被激活。尽管我们的初始示例很简单，但请记住语法是递归的，因此任何复杂度的模式都可以替换这些示例中的任何子模式。
- en: Group patterns
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分组模式
- en: If *P1* is a pattern, then (*P1*) is also a pattern that matches the same values.
    This addition of “grouping” parentheses is useful when patterns become complicated,
    just as it is with standard expressions. Like in other expressions, take care
    to distinguish between (*P1*), a simple grouped pattern matching *P1*, and (*P1*,),
    a sequence pattern (described next) matching a sequence with a single element
    matching *P1*.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*P1*是一个模式，则（*P1*）也是一个匹配相同值的模式。当模式变得复杂时，添加“分组”括号非常有用，就像标准表达式一样。像其他表达式一样，务必区分（*P1*），一个简单的分组模式匹配*P1*，和（*P1*，），一个序列模式（稍后描述）匹配具有匹配*P1*的单个元素的序列。
- en: Sequence patterns
  id: totrans-577
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列模式
- en: A list or tuple of patterns, optionally with a single starred wildcard (*_)
    or starred capture pattern (**name*), is a *sequence pattern*. When the starred
    pattern is absent, the pattern matches a fixed-length sequence of values of the
    same length as the pattern. Elements of the sequence are matched one at a time,
    until all elements have matched (then matching succeeds) or an element fails to
    match (then matching fails).
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模式的列表或元组，可选地带有一个星号通配符 (*_) 或星号捕获模式 (**name*)，是 *序列模式*。当星号模式不存在时，模式匹配长度固定的值序列，与模式长度相同。序列的元素逐个匹配，直到所有元素都匹配成功（匹配成功）或某个元素无法匹配（匹配失败）。
- en: When the sequence pattern includes a starred pattern, that subpattern matches
    a sequence of elements sufficiently long to allow the remaining unstarred patterns
    to match the final elements of the sequence. When the starred pattern is of the
    form **name*, *name* is bound to the (possibly empty) list of the elements in
    the middle that don’t correspond to individual patterns at the beginning or end.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 当序列模式包括一个星号模式时，该子模式匹配足够长的元素序列，以允许其余的未星号化模式匹配序列的最后元素。当星号模式为 **name* 形式时，*name*
    绑定到中间元素列表（可能为空），这些元素不对应开始或结束的各个模式。
- en: 'You can match a sequence with patterns that look like tuples or lists—it makes
    no difference to the matching process. The next example shows an unnecessarily
    complicated way to extract the first, middle, and last elements of a sequence:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用看起来像元组或列表的模式来匹配序列——这对匹配过程没有影响。下一个示例展示了从序列中提取第一个、中间和最后一个元素的不必要复杂方式：
- en: '[PRE93]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: as patterns
  id: totrans-583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: as 模式
- en: You can use so-called ***as*** *patterns* to capture values matched by more
    complex patterns, or components of a pattern, that simple capture patterns (see
    [“Capture patterns”](#capture_patterns)) cannot.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用所谓的 ***as*** *patterns* 捕获由更复杂的模式匹配或模式的组成部分匹配的值，这是简单捕获模式（请参阅 [“捕获模式”](#capture_patterns)）所不能做到的。
- en: 'When *P1* is a pattern, then *P1* **as** *name* is also a pattern; when *P1*
    succeeds, Python binds the matched value to the name *name* in the local namespace.
    The interpreter tries to ensure that, even with complicated patterns, the same
    bindings always take place when a match occurs. Therefore, each of the next two
    examples raises SyntaxError, because the constraint cannot be guaranteed:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *P1* 是一个模式时，*P1* **as** *name* 也是一个模式；当 *P1* 成功时，Python 将匹配的值绑定到本地命名空间中的名称
    *name*。解释器尝试确保，即使模式复杂，当匹配发生时也始终进行相同的绑定。因此，接下来的两个例子每个都会引发 SyntaxError，因为无法保证约束：
- en: '[PRE95]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'But this one works:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个可以工作：
- en: '[PRE99]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Mapping patterns
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射模式
- en: '*Mapping patterns* match mapping objects, usually dictionaries, that associate
    keys with values. The syntax of mapping patterns uses *key*: *pattern* pairs.
    The keys must be either literal or value patterns.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '*映射模式* 匹配映射对象，通常是字典，它们将键与值关联起来。映射模式的语法使用 *key*: *pattern* 对。键必须是文字或值模式。'
- en: 'The interpreter iterates over the keys in the mapping pattern, processing each
    as follows:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器迭代处理映射模式中的键，每个键的处理方式如下：
- en: Python looks up the key in the subject mapping; a lookup failure causes an immediate
    match failure.
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 在主题映射中查找键；查找失败会立即导致匹配失败。
- en: Python then matches the extracted value against the pattern associated with
    the key; if the value fails to match the pattern, then the whole match fails.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后 Python 将提取的值与键关联的模式进行匹配；如果值不能匹配模式，则整个匹配失败。
- en: 'When all keys (and associated values) in the mapping pattern match, the whole
    match succeeds:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 当映射模式中的所有键（及其关联的值）匹配时，整个匹配成功：
- en: '[PRE101]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'You can also use a mapping pattern together with an **as** clause:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将映射模式与 **as** 子句一起使用：
- en: '[PRE103]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The **as** pattern in the second example binds *v2* to the whole subject dictionary,
    not just the matched keys.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例中的 **as** 模式将 *v2* 绑定到整个主题字典，而不仅仅是匹配的键。
- en: 'The final element of the pattern may optionally be a double-starred capture
    pattern such as ***name*. When that is the case, Python binds *name* to a possibly
    empty dictionary whose items are the (*key*, *value*) pairs from the subject mapping
    whose keys were *not* present in the pattern:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的最后一个元素可以选择是一个双星捕获模式，例如 ***name*。在这种情况下，Python 绑定 *name* 到一个可能为空的字典，其条目是主题映射中的
    (*key*, *value*) 对，这些键不在模式中出现：
- en: '[PRE105]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Class patterns
  id: totrans-608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类模式
- en: The final and maybe the most versatile kind of pattern is the *class pattern*,
    offering the ability to match instances of particular classes and their attributes.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 最后也可能是最多用途的一种模式是*类模式*，提供了匹配特定类及其属性实例的能力。
- en: 'A class pattern is of the general form:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 类模式的一般形式如下：
- en: '[PRE107]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: where *name_or_attr* is a simple or qualified name bound to a class—specifically,
    an instance of the built-in type type (or of a subclass thereof, but no super-fancy
    metaclasses need apply!)—and *patterns* is a (possibly empty) comma-separated
    list of pattern specifications. When no pattern specifications are present in
    a class pattern, the match succeeds whenever the subject is an instance of the
    given class, so for example the pattern int() matches *any* integer.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*name_or_attr*是绑定到类的简单或合格名称，具体来说，是内置类型type的实例（或其子类，但不需要超级花哨的元类！），而*patterns*是一个（可能为空的）逗号分隔的模式规范列表。当类模式中没有模式规范时，只要主题是给定类的实例，匹配就成功，因此例如模式int()匹配*任何*整数。
- en: Like function arguments and parameters, the pattern specifications can be positional
    (like *pattern*) or named (like *name*=*pattern*). If a class pattern has positional
    pattern specifications, they must all precede the first named pattern specification.
    User-defined classes cannot use positional patterns without setting the class’s
    *__match_args__* attribute (see [“Configuring classes for positional matching”](#configuring_classes_for_positional_matc)).
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于函数参数和参数，模式规范可以是位置的（如*pattern*）或命名的（如*name*=*pattern*）。如果类模式具有位置模式规范，则它们必须全部位于第一个命名模式规范之前。未设置类的*__match_args__*属性的用户定义类不能使用位置模式（请参见[“配置类以进行位置匹配”](#configuring_classes_for_positional_matc)）。
- en: The built-in types bool, bytearray, bytes, dict,^([23](ch03.xhtml#ch01fn42))
    float, frozenset, int, list, set, str, and tuple, as well as any namedtuple and
    any dataclass, are all configured to take a single positional pattern, which is
    matched against the instance value. For example, the pattern str(*x*) matches
    any string and binds its value to *x* by matching the string’s value against the
    capture pattern—as does str() **as** *x*.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 内置类型bool、bytearray、bytes、dict、float、frozenset、int、list、set、str和tuple，以及任何命名元组和任何数据类都配置为接受单个位置模式，该模式与实例值匹配。例如，模式str(*x*)匹配任何字符串，并通过将字符串的值与捕获模式进行匹配来绑定其值到*x*，就像str()
    **as** *x*一样。
- en: 'You may remember a literal pattern example we presented earlier, showing that
    literal matching could not discriminate between the integer 42 and the float 42.0
    because 42 == 42.0. You can use class matching to overcome that issue:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得我们之前介绍的文字模式示例，显示文字匹配不能区分整数42和浮点数42.0，因为42 == 42.0。你可以使用类匹配来解决这个问题：
- en: '[PRE108]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Once the type of the subject value has matched, for each of the named patterns
    *name*=*pattern*, Python retrieves the attribute *name* from the instance and
    matches its value against *pattern*. If all named pattern matches succeed, the
    whole match succeeds. Python handles positional patterns by converting them to
    named patterns, as you’ll see momentarily.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦主题值的类型匹配成功，对于每个命名模式*name*=*pattern*，Python从实例中检索属性*name*并将其值与*pattern*进行匹配。如果所有命名模式匹配成功，则整体匹配成功。Python通过将位置模式转换为命名模式来处理位置模式，你很快就会看到。
- en: Guards
  id: totrans-619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Guards
- en: 'When a **case** clause’s pattern succeeds, it is often convenient to determine
    on the basis of values extracted from the match whether this **case** should execute.
    When a guard is present, it executes after a successful match. If the guard expression
    evaluates as false, Python abandons the current **case**, despite the match, and
    moves on to consider the next case. This example uses a guard to exclude odd integers
    by checking the value bound in the match:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 当**case**子句的模式成功时，通常方便根据从匹配中提取的值来确定是否应执行此**case**。如果存在守卫，则在成功匹配后执行它。如果守卫表达式评估为false，则Python放弃当前**case**，尽管匹配成功，并继续考虑下一个case。本示例使用守卫通过检查匹配中绑定的值来排除奇数整数：
- en: '[PRE110]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Configuring classes for positional matching
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置类以进行位置匹配
- en: 'When you want your own classes to handle positional patterns in matching, you
    have to tell the interpreter which *attribute of the instance* (not which *argument
    to* *__init__*) each positional pattern corresponds to. You do this by setting
    the class’s __match_args__ attribute to a sequence of names. The interpreter raises
    a TypeError exception if you attempt to use more positional patterns than you
    defined:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望自己的类处理匹配中的位置模式时，必须告诉解释器实例的哪个*属性*（而不是*__init__*的哪个*参数*）对应于每个位置模式。您可以通过将类的__match_args__属性设置为名称序列来实现这一点。如果尝试使用超过您定义的位置模式数量，则解释器会引发TypeError异常：
- en: '[PRE112]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The while Statement
  id: totrans-629
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**while** 语句'
- en: 'The **while** statement repeats execution of a statement or block of statements
    for as long as a conditional expression evaluates as true. Here’s the syntax of
    the **while** statement:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '**while** 语句重复执行由条件表达式评估为true的语句或语句块。以下是**while**语句的语法：'
- en: '[PRE116]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: A **while** statement can also include an **else** clause and **break** and
    **continue** statements, all of which we’ll discuss after we look at the **for**
    statement.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '**while** 语句也可以包含**else**子句以及**break**和**continue**语句，我们在讨论**for**语句之后会详细讨论这些内容。'
- en: 'Here’s a typical **while** statement:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的**while**语句：
- en: '[PRE117]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: First Python evaluates *expression*, which is known as the *loop condition*,
    in a Boolean context. When the condition evaluates as false, the **while** statement
    ends. When the loop condition evaluates as true, the statement or block of statements
    that make up the *loop body* executes. Once the loop body finishes executing,
    Python evaluates the loop condition again, to check whether another iteration
    should execute. This process continues until the loop condition evaluates as false,
    at which point the **while** statement ends.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Python会在布尔上下文中评估*expression*，这被称为*循环条件*。当条件评估为false时，**while**语句结束。当循环条件评估为true时，执行组成*循环体*的语句或语句块。一旦循环体执行完毕，Python会再次评估循环条件，以检查是否应执行另一次迭代。这个过程会持续进行，直到循环条件评估为false，此时**while**语句结束。
- en: The loop body should contain code that eventually makes the loop condition false,
    since otherwise the loop never ends (unless the body raises an exception or executes
    a **break** statement). A loop within a function’s body also ends if the loop
    body executes a **return** statement, since in this case the whole function ends.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 循环体应包含最终使循环条件为false的代码，否则循环永远不会结束（除非循环体引发异常或执行**break**语句）。如果循环体执行**return**语句，函数体内的循环也会结束，因为此时整个函数结束。
- en: The for Statement
  id: totrans-637
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**for** 语句'
- en: 'The **for** statement repeats execution of a statement or block of statements
    controlled by an iterable expression. Here’s the syntax:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '**for** 语句重复执行由可迭代表达式控制的语句或语句块。以下是语法：'
- en: '[PRE118]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The **in** keyword is part of the syntax of the **for** statement; its purpose
    here is distinct from the **in** operator, which tests membership.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '**in**关键字是**for**语句语法的一部分；在此处的目的与测试成员身份的**in**运算符不同。'
- en: 'Here’s a rather typical **for** statement:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当典型的**for**语句：
- en: '[PRE119]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: A **for** statement can also include an **else** clause and **break** and **continue**
    statements; we’ll discuss all of these shortly, starting with [“The else Clause
    on Loop Statements”](#the_else_clause_on_loop_statements). As mentioned previously,
    *iterable* may be any iterable Python expression. In particular, any sequence
    is iterable. The interpreter implicitly calls the built-in iter on the iterable,
    producing an *iterator* (discussed in the following subsection), which it then
    iterates over.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '**for** 语句也可以包含**else**子句以及**break**和**continue**语句；我们将很快讨论所有这些内容，从[“循环语句上的else子句”](https://wiki.example.org/the_else_clause_on_loop_statements)开始。如前所述，*iterable*可以是任何可迭代的Python表达式。特别地，任何序列都是可迭代的。解释器隐式调用可迭代对象的内置iter函数，生成一个*iterator*（在下一小节中讨论），然后迭代它。'
- en: '*target* is normally an identifier naming the *control variable* of the loop;
    the **for** statement successively rebinds this variable to each item of the iterator,
    in order. The statement or statements that make up the *loop body* execute once
    for each item in *iterable* (unless the loop ends because of an exception or a
    **break** or **return** statement). Since the loop body may terminate before the
    iterator is exhausted, this is one case in which you may use an *unbounded* iterable—one
    that, per se, would never cease yielding items.'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '*target*通常是一个标识符，用于命名循环的*控制变量*；**for**语句按顺序将该变量逐个重新绑定为迭代器的每个项。组成*循环体*的语句或语句为*iterable*中的每个项执行一次（除非由于异常、**break**或**return**语句而结束循环）。由于循环体可能在迭代器耗尽之前终止，因此这是可以使用*无界*可迭代对象的一种情况——即本身永远不会停止产生项的对象。'
- en: 'You can also use a target with multiple identifiers, as in an unpacking assignment.
    In this case, the iterator’s items must themselves be iterables, each with exactly
    as many items as there are identifiers in the target. For example, when *d* is
    a dictionary, this is a typical way to loop on the items (key/value pairs) in
    *d*:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用带有多个标识符的目标，例如解包赋值。在这种情况下，迭代器的items本身必须是可迭代对象，并且每个对象中的项数量必须与目标中的标识符数量完全相同。例如，当*d*是一个字典时，这是循环遍历*d*中的项（键/值对）的典型方式：
- en: '[PRE120]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The items method returns another kind of iterable (a *view*), whose items are
    key/value pairs; so, we use a **for** loop with two identifiers in the target
    to unpack each item into key and value.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: items方法返回另一种类型的可迭代对象（*视图*），其项是键/值对；因此，我们使用带有两个标识符的**for**循环来解包每个项为键和值。
- en: 'Precisely *one* of the identifiers may be preceded by a star, in which case
    the starred identifier is bound to a list of all items not assigned to other targets.
    Although components of a target are commonly identifiers, values can be bound
    to any acceptable LHS expression, as covered in [“Assignment Statements”](#assignment_statements)—so,
    the following is correct, although not the most readable style:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 目标中可以有精确的*一个*标识符前带有星号，此时星号标识符将绑定到未分配给其他目标的所有项的列表。虽然目标的组成通常是标识符，但是值可以绑定到任何符合左侧表达式的可接受的LHS表达式中，如在[“赋值语句”](#assignment_statements)中所述——因此，以下写法是正确的，尽管不是最可读的样式：
- en: '[PRE121]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Don’t Alter Mutable Objects While Looping on Them
  id: totrans-650
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在循环时不要改变可变对象
- en: 'When an iterator has a mutable underlying iterable, don’t alter that underlying
    object during the execution of a **for** loop on the iterable. For example, the
    preceding key/value printing example cannot alter *d*. The items method returns
    a “view” iterable whose underlying object is *d*, so the loop body cannot mutate
    the set of keys in *d* (e.g., by executing **del** *d*[*key*]). To ensure that
    *d* is not the underlying object of the iterable, you may, for example, iterate
    over list(*d*.items()) to allow the loop body to mutate *d*. Specifically:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 当迭代器具有可变的基础可迭代对象时，在对可迭代对象进行**for**循环执行期间不要更改该基础对象。例如，上述的键/值打印示例不能改变*d*。items方法返回一个“视图”可迭代对象，其基础对象是*d*，因此循环体不能改变*d*中的键集（例如通过执行**del**
    *d*[*key*]）。为确保*d*不是可迭代对象的基础对象，可以例如迭代list(*d*.items())来允许循环体改变*d*。具体来说：
- en: When looping on a list, do not insert, append, or delete items (rebinding an
    item at an existing index is OK).
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表上循环时，不要插入、追加或删除项（重新绑定现有索引处的项是可以的）。
- en: When looping on a dictionary, do not add or delete items (rebinding the value
    for an existing key is OK).
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环字典时，不要添加或删除项（重新绑定现有键的值是可以的）。
- en: When looping on a set, do not add or delete items (no alteration is permitted).
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环集合时，不要添加或删除项（不允许进行任何更改）。
- en: 'The loop body may rebind the control target variable(s), but the next iteration
    of the loop always rebinds them again. If the iterator yields no items, the loop
    body does not execute at all. In this case, the **for** statement does not bind
    or rebind its control variable in any way. If the iterator yields at least one
    item, however, then when the loop statement ends, the control variable remains
    bound to the last value to which the loop statement bound it. The following code
    is therefore correct *only* when someseq is not empty:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 循环体可能会重新绑定控制目标变量，但是循环的下一次迭代总会再次重新绑定它们。如果迭代器不产生任何项，则根本不会执行循环体。在这种情况下，**for**语句不以任何方式绑定或重新绑定其控制变量。然而，如果迭代器至少产生一项，则当循环语句结束时，控制变量仍绑定到循环语句绑定它的最后一个值。因此，以下代码仅在someseq不为空时才正确：
- en: '[PRE122]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Iterators
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代器
- en: An *iterator* is an object *i* such that you can call next(*i*), which returns
    the next item of iterator *i* or, when exhausted, raises a StopIteration exception.
    Alternatively, you can call next(*i*, *default*), in which case, when iterator
    *i* has no more items, the call returns *default*.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '*迭代器*是一个对象*i*，使得您可以调用next(*i*)，它返回迭代器*i*的下一个项目，或者在耗尽时引发StopIteration异常。或者，您可以调用next(*i*,
    *default*)，在这种情况下，当迭代器*i*没有更多项目时，调用将返回*default*。'
- en: When you write a class (see [“Classes and Instances”](ch04.xhtml#classes_and_instances)),
    you can let instances of the class be iterators by defining a special method __next__
    that takes no argument except self, and returns the next item or raises StopIteration.
    Most iterators are built by implicit or explicit calls to the built-in function
    iter, covered in [Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio).
    Calling a generator also returns an iterator, as we discuss in [“Generators”](#generators).
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写一个类（参见[“类和实例”](ch04.xhtml#classes_and_instances)）时，您可以通过定义一个特殊方法__next__来让该类的实例成为迭代器，该方法不接受除self之外的参数，并返回下一个项目或引发StopIteration。大多数迭代器是通过隐式或显式调用内置函数iter构建的，见[表8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)。调用生成器也会返回一个迭代器，我们将在[“生成器”](#generators)中讨论。
- en: 'As pointed out previously, the **for** statement implicitly calls iter on its
    iterable to get an iterator. The statement:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**for** 语句在其可迭代对象上隐式调用iter以获取一个迭代器。该语句：
- en: '[PRE123]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'is exactly equivalent to:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 是完全等价于：
- en: '[PRE124]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: where *_temporary_iterator* is an arbitrary name not used elsewhere in the current
    scope.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*_temporary_iterator*是当前范围内未使用的任意名称。
- en: Thus, when iter(*c*) returns an iterator *i* such that next(*i*) never raises
    StopIteration (an *unbounded iterator*), the loop **for** *x* **in** *c* continues
    indefinitely unless the loop body includes suitable **break** or **return** statements,
    or raises or propagates exceptions. iter(*c*), in turn, calls the special method
    *c*.__iter__() to obtain and return an iterator on *c*. We’ll talk more about
    __iter__ in the following subsection and in [“Container methods”](ch04.xhtml#container_method).
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当iter(*c*)返回一个迭代器*i*，使得next(*i*)永远不会引发StopIteration（一个*无界迭代器*）时，循环 **for**
    *x* **in** *c* 将无限继续，除非循环体包含适当的 **break** 或 **return** 语句，或引发或传播异常。iter(*c*)，依次调用特殊方法*c*.__iter__()
    来获取并返回*c*上的迭代器。我们将在下一小节和[“容器方法”](ch04.xhtml#container_method)中更多地讨论 __iter__。
- en: Many of the best ways to build and manipulate iterators are found in the standard
    library module itertools, covered in [“The itertools Module”](ch08.xhtml#the_itertools_module).
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 许多构建和操作迭代器的最佳方法都可以在标准库模块itertools中找到，见[“itertools模块”](ch08.xhtml#the_itertools_module)。
- en: Iterables versus iterators
  id: totrans-667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可迭代对象与迭代器
- en: 'Python’s built-in sequences, like all iterables, implement an __iter__ method,
    which the interpreter calls to produce an iterator over the iterable. Because
    each call to the built-in’s __iter__ method produces a new iterator, it is possible
    to nest multiple iterations over the same iterable:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: Python的内置序列，像所有可迭代对象一样，实现了一个__iter__方法，解释器调用该方法来在可迭代对象上生成一个迭代器。因为每次调用内置的__iter__方法都会产生一个新的迭代器，所以可以在同一可迭代对象上嵌套多个迭代：
- en: '[PRE125]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Iterators also implement an __iter__ method, but it always returns self, so
    nesting iterations over an iterator doesn’t work as you might expect:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器还实现了一个__iter__方法，但它总是返回self，因此对迭代器进行嵌套迭代不起作用，就像你可能期望的那样：
- en: '[PRE127]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Here, both the inner and outer loops are iterating over the same iterator. By
    the time the inner loop first gets control, the first value from the iterator
    has already been consumed. The first iteration of the inner loop then exhausts
    the iterator, making both loops end upon attempting the next iteration.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内部循环和外部循环都在同一个迭代器上进行迭代。当内部循环第一次获得控制权时，迭代器的第一个值已经被消耗掉。内部循环的第一次迭代然后耗尽了迭代器，使得两个循环在尝试下一次迭代时结束。
- en: range
  id: totrans-675
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: range
- en: 'Looping over a sequence of integers is a common task, so Python provides the
    built-in function range to generate an iterable over integers. The simplest way
    to loop *n* times in Python is:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 循环遍历一系列整数是一种常见的任务，因此Python提供了内置函数range来生成一个整数的可迭代对象。在Python中循环 *n* 次的最简单方法是：
- en: '[PRE129]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: range(*x*) generates the consecutive integers from 0 (included) up to *x* (excluded).
    range(*x*, *y*) generates a list whose items are consecutive integers from *x*
    (included) up to *y* (excluded). range(*x*, *y*, *stride*) generates a list of
    integers from *x* (included) up to *y* (excluded), such that the difference between
    each two adjacent items is *stride*. If *stride* < 0, range counts down from *x*
    to *y*.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: range(*x*) 生成从 0（包括）到 *x*（不包括）的连续整数。range(*x*, *y*) 生成一个列表，其项是从 *x*（包括）到 *y*（不包括）的连续整数。range(*x*,
    *y*, *stride*) 生成一个整数列表，其项从 *x*（包括）到 *y*（不包括），使得每两个相邻项之间的差异为 *stride*。如果 *stride*
    < 0，则 range 从 *x* 到 *y* 递减。
- en: range generates an empty iterator when *x* >= *y* and *stride* >0, or when *x*
    <= *y* and *stride* <0. When *stride* ==0, range raises an exception.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *x* >= *y* 且 *stride* >0，或者当 *x* <= *y* 且 *stride* <0 时，range 生成一个空的迭代器。当
    *stride* ==0 时，range 抛出一个异常。
- en: range returns a special-purpose object, intended just for use in iterations
    like the **for** statement shown previously. Note that range returns an iterable,
    not an iterator; you can easily obtain such an iterator, should you need one,
    by calling iter(range(...)). The special-purpose object returned by range consumes
    less memory (for wide ranges, *much* less memory) than the equivalent list object
    would. If you really need a list that’s an arithmetic progression of ints, call
    list(range(...)). You will most often find that you don’t, in fact, need such
    a complete list to be fully built in memory.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: range 返回一个专用对象，仅用于像前面所示的 **for** 语句中的迭代。注意，range 返回一个可迭代对象，而不是迭代器；如果需要，您可以通过调用
    iter(range(...)) 轻松获取这样的迭代器。range 返回的专用对象消耗的内存比相应的列表对象少（对于宽范围，内存少得多）。如果您真的需要一个是整数等差级数的列表，请调用
    list(range(...))。您会发现，事实上，您并不需要完全构建在内存中的这样一个完整列表。
- en: List comprehensions
  id: totrans-681
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表解析
- en: A common use of a **for** loop is to inspect each item in an iterable and build
    a new list by appending the results of an expression computed on some or all of
    the items. The expression form known as a *list comprehension* or *listcomp* lets
    you code this common idiom concisely and directly. Since a list comprehension
    is an expression (rather than a block of statements), you can use it wherever
    you need an expression (e.g., as an argument in a function call, in a **return**
    statement, or as a subexpression of some other expression).
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '**for** 循环的一个常见用法是检查可迭代对象中的每个项目，并通过附加在某些或所有项目上计算的表达式的结果来构建新列表。称为 *列表解析* 或 *listcomp*
    的表达式形式让您可以简洁直接地编码这种常见习语。由于列表解析是一个表达式（而不是一组语句块），您可以在需要表达式的任何地方使用它（例如，在函数调用中作为参数，在
    **return** 语句中，或者作为某些其他表达式的子表达式）。'
- en: 'A list comprehension has the following syntax:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 列表解析具有以下语法：
- en: '[PRE130]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '*target* and *iterable* in each **for** clause of a list comprehension have
    the same syntax and meaning as those in a regular **for** statement, and the *expression*
    in each **if** clause of a list comprehension has the same syntax and meaning
    as the *expression* in a regular **if** statement. When *expression* denotes a
    tuple, you must enclose it in parentheses.'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 列表解析中的每个 **for** 子句中的 *target* 和 *iterable* 与常规 **for** 语句中的相同语法和含义，并且列表解析中的每个
    **if** 子句中的 *expression* 具有与常规 **if** 语句中的 *expression* 相同的语法和含义。当 *expression*
    表示元组时，您必须将其括在括号中。
- en: '*lc-clauses * is a series of zero or more clauses, each with either this form:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '*lc-clauses* 是一系列零个或多个子句，每个子句都有这种形式之一：'
- en: '[PRE131]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'or this form:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这种形式：
- en: '[PRE132]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'A list comprehension is equivalent to a **for** loop that builds the same list
    by repeated calls to the resulting list’s append method.^([24](ch03.xhtml#ch01fn43))
    For example (assigning the list comprehension result to a variable for clarity),
    this:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 列表解析等效于通过重复调用结果列表的 append 方法构建相同列表的 **for** 循环^([24](ch03.xhtml#ch01fn43))。例如（将列表解析结果赋给一个变量以便清晰），这样：
- en: '[PRE133]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'is just the same as the **for** loop:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 就是和 **for** 循环一样：
- en: '[PRE134]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Don’t Build a List Unless You Need To
  id: totrans-694
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要构建列表，除非你需要
- en: 'If you are just going to loop once over the items, you don’t need an actual
    indexable list: use a generator expression instead (covered in [“Generator expressions”](#generator_expressions)).
    This avoids list creation and uses less memory. In particular, resist the temptation
    to use a list comprehension as a not particularly readable “single-line loop,”
    like this:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是要对项进行一次循环，你不需要一个真正的可索引的列表：而是使用生成器表达式（在[“生成器表达式”](#generator_expressions)中讨论）。这样可以避免列表创建并且使用更少的内存。特别地，抵制使用列表解析作为不是特别可读的“单行循环”的诱惑，像这样：
- en: '[PRE135]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: and then ignore the resulting list—just use a normal **for** loop instead!
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 然后忽略生成的列表——而是使用普通的**for**循环！
- en: 'Here’s a list comprehension that uses an **if** clause:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用**if**子句的列表推导式：
- en: '[PRE136]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'This list comprehension is the same as a **for** loop that contains an **if**
    statement:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表推导式与包含**if**语句的**for**循环相同：
- en: '[PRE137]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Here’s a list comprehension using a nested **for** clause to flatten a “list
    of lists” into a single list of items:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用嵌套**for**子句的列表推导式，用于将“列表的列表”扁平化为单个项目列表：
- en: '[PRE138]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'This is the same as a **for** loop with another **for** loop nested inside:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 这与嵌套另一个**for**循环的**for**循环相同：
- en: '[PRE139]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: As these examples show, the order of **for** and **if** in a list comprehension,
    is the same as in the equivalent loop, but, in the list comprehension the nesting
    remains implicit. If you remember “order **for** clauses as in a nested loop,”
    that can help you get the ordering of the list comprehension’s clauses right.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这些示例所示，列表推导式中**for**和**if**的顺序与等价循环中的顺序相同，但是，在列表推导式中，嵌套保持隐式。如果您记住“按照嵌套循环中的顺序**for**子句”，那么可以帮助您正确设置列表推导式子句的顺序。
- en: List Comprehensions and Variable Scope
  id: totrans-707
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表推导式和变量作用域
- en: A list comprehension expression evaluates in its own scope (as do set and dictionary
    comprehensions, described in the following sections, and generator expressions,
    discussed toward the end of this chapter). When a *target* component in the **for**
    statement is a name, the name is defined solely within the expression scope and
    is not available outside it.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式表达式在自己的作用域内评估（与后面描述的集合和字典推导式以及本章末尾讨论的生成器表达式相同）。当**for**语句中的*目标*组件是一个名称时，该名称仅在表达式作用域内定义，并且在其外部不可用。
- en: Set comprehensions
  id: totrans-709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合推导式
- en: 'A *set comprehension* has exactly the same syntax and semantics as a list comprehension,
    except that you enclose it in braces ({}) rather than in brackets ([]). The result
    is a set; for example:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合推导式*与列表推导式具有完全相同的语法和语义，只是将其包含在大括号（{}）中而不是方括号（[]）中。结果是一个集合；例如：'
- en: '[PRE140]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: A similar list comprehension would have each item repeated twice, but building
    a set removes duplicates.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的列表推导式将使每个项目重复两次，但是构建集合会删除重复项。
- en: Dictionary comprehensions
  id: totrans-713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典推导式
- en: 'A *dictionary comprehension* has the same syntax as a set comprehension, except
    that instead of a single expression before the **for** clause, you use two expressions
    with a colon (:) between them: *key*:*value*. The result is a dict, which retains
    insertion order. For example:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典推导式*与集合推导式具有相同的语法，只是在**for**子句之前使用两个表达式，并在两者之间使用冒号（:）：*key*:*value*。结果是一个dict，它保留插入顺序。例如：'
- en: '[PRE141]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The break Statement
  id: totrans-716
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中断语句
- en: You can use a **break** statement *only* within a loop body. When **break**
    executes, the loop terminates *without executing any* ***else*** *clause on the
    loop*. When loops are nested, a **break** terminates only the innermost nested
    loop. In practice, a **break** is typically within a clause of an **if** (or,
    occasionally, **match**) statement in the loop body, so that **break** executes
    conditionally.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能在循环体内使用**break**语句。当**break**执行时，循环终止，*而不执行循环上的任何* ***else*** *子句*。当循环嵌套时，**break**仅终止最内部的嵌套循环。在实践中，**break**通常位于循环体中的**if**（或偶尔是**match**）语句的子句中，因此**break**有条件地执行。
- en: 'One common use of **break** is to implement a loop that decides whether it
    should keep looping only in the middle of each loop iteration (what Donald Knuth
    called the “loop and a half” structure in his great 1974 paper [“Structured Programming
    with go to Statements”](https://oreil.ly/8aebY)^([25](ch03.xhtml#ch01fn44))).
    For example:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '**break**的一个常见用途是实现一个决定是否应该保持循环的循环，仅在每个循环迭代的中间（这是唐纳德·克努特在他1974年的伟大论文[“带有go
    to语句的结构化编程”](https://oreil.ly/8aebY)^（[25](ch03.xhtml#ch01fn44)）中所说的“半循环”结构）。例如：'
- en: '[PRE142]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The continue Statement
  id: totrans-720
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续语句
- en: Like **break**, the **continue** statement can exist only within a loop body.
    It causes the current iteration of the loop body to terminate, and execution continues
    with the next iteration of the loop. In practice, a **continue** is usually within
    a clause of an **if** (or, occasionally, a **match**) statement in the loop body,
    so that **continue** executes conditionally.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 与**break**一样，**continue**语句只能存在于循环体内。它导致循环体的当前迭代终止，并继续下一次循环的迭代。在实践中，**continue**通常位于循环体中的**if**（或偶尔是**match**）语句的子句中，因此**continue**有条件地执行。
- en: 'Sometimes, a **continue** statement can take the place of nested **if** statements
    within a loop. For example, here each x has to pass multiple tests before being
    completely processed:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，**continue**语句可以取代循环内嵌的**if**语句。例如，每个x在被完全处理之前必须通过多个测试：
- en: '[PRE143]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Nesting increases with the number of conditions. Equivalent code with **continue**
    “flattens” the logic:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 条件数量增加时嵌套也会增加。使用**continue**的等效代码“扁平化”逻辑：
- en: '[PRE144]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Flat Is Better Than Nested
  id: totrans-726
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flat Is Better Than Nested
- en: Both versions work the same way, so which one you use is a matter of personal
    preference and style. One of the principles of [The Zen of Python](https://oreil.ly/luTv7)
    (which you can see at any time by typing **import this** at an interactive Python
    interpreter prompt) is “Flat is better than nested.” The **continue** statement
    is just one way Python helps you move toward the goal of a less-nested structure
    in a loop, when you choose to follow this tip.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 两个版本的工作方式相同，因此使用哪个是个人偏好和风格问题。[Python之禅](https://oreil.ly/luTv7) 的原则之一（可以通过在交互式Python解释器提示符下键入**import
    this**随时查看）是“Flat is better than nested.” **continue**语句只是Python在您选择遵循此提示时帮助您在循环中向较少嵌套的结构迈进的一种方式。
- en: The else Clause on Loop Statements
  id: totrans-728
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环语句的**else**子句
- en: '**while** and **for** statements may optionally have a trailing **else** clause.
    The statement or block under that clause executes when the loop terminates *naturally*
    (at the end of the **for** iterator, or when the **while** loop condition becomes
    false), but not when the loop terminates *prematurely* (via **break**, **return**,
    or an exception). When a loop contains one or more **break** statements, you’ll
    often want to check whether it terminates naturally or prematurely. You can use
    an **else** clause on the loop for this purpose:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '**while** 和 **for** 语句可以选择带有尾部的**else**子句。该子句下的语句或块在循环自然终止时执行（在**for**迭代器结束时或**while**循环条件变为false时），但不会在循环过早终止时执行（通过**break**、**return**或异常）。当循环包含一个或多个**break**语句时，通常希望检查它是否自然或过早终止。您可以在循环上使用一个**else**子句来达到此目的：'
- en: '[PRE145]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The pass Statement
  id: totrans-731
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**pass**语句'
- en: 'The body of a Python compound statement cannot be empty; it must always contain
    at least one statement. You can use a **pass** statement, which performs no action,
    as an explicit placeholder when a statement is syntactically required but you
    have nothing to do. Here’s an example of using **pass** in a conditional statement
    as a part of some rather convoluted logic to test mutually exclusive conditions:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: Python 复合语句的主体不能是空的；它必须始终包含至少一条语句。当语法上需要语句但你无事可做时，可以使用一个**pass**语句，它不执行任何操作，作为一个显式的占位符。下面是一个在条件语句中使用**pass**作为一种相当复杂逻辑的一部分来测试互斥条件的示例：
- en: '[PRE146]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Empty def or class Statements: Use a Docstring, Not pass'
  id: totrans-734
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空的**def**或**class**语句：使用文档字符串而非**pass**
- en: You can also use a docstring, covered in [“Docstrings”](#docstrings), as the
    body of an otherwise empty **def** or **class** statement. When you do this, you
    do not need to also add a **pass** statement (you can do so if you wish, but it’s
    not optimal Python style).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用文档字符串，在其他情况下空的**def**或**class**语句的主体。这样做时，您不需要额外添加**pass**语句（如果愿意可以添加，但这不是最佳Python风格）。
- en: The try and raise Statements
  id: totrans-736
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**try** 和 **raise** 语句'
- en: Python supports exception handling with the **try** statement, which includes
    **try**, **except**, **finally**, and **else** clauses. Your code can also explicitly
    raise an exception with the **raise** statement. When code raises an exception,
    normal control flow of the program stops and Python looks for a suitable exception
    handler. We discuss all of this in detail in [“Exception Propagation”](ch06.xhtml#exception_propagation).
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过**try**语句支持异常处理，其中包括**try**、**except**、**finally**和**else**子句。您的代码还可以使用**raise**语句显式引发异常。当代码引发异常时，程序的正常控制流将停止，并且Python会寻找适当的异常处理程序。我们在
    [“Exception Propagation”](ch06.xhtml#exception_propagation) 中详细讨论所有这些内容。
- en: The with Statement
  id: totrans-738
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**with** 语句'
- en: A **with** statement can often be a more readable, useful alternative to the
    **try**/**finally** statement. We discuss it in detail in [“The with Statement
    and Context Managers”](ch06.xhtml#the_with_statement_and_context_managers). A
    good grasp of context managers can often help you structure your code more clearly
    without compromising efficiency.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '**with**语句通常可以作为**try**/**finally**语句的更可读、更有用的替代方案。我们在 [“The with Statement
    and Context Managers”](ch06.xhtml#the_with_statement_and_context_managers) 中详细讨论它。对上下文管理器的良好掌握通常可以帮助您更清晰地组织代码而不会影响效率。'
- en: Functions
  id: totrans-740
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Most statements in a typical Python program are part of some function. Code
    in a function body may be faster than at a module’s top level, as covered in [“Avoid
    exec and from ... import *”](ch17.xhtml#avoid_exec_and_from_dotdotdot_import_as),
    so there are excellent practical reasons to put most of your code into functions—and
    there are no disadvantages: clarity, readability and code reusability all improve
    when you avoid having any substantial chunks of module-level code.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数典型的 Python 程序语句都是某些函数的一部分。代码放在函数体中可能比放在模块顶层要快，如在[“避免使用 exec 和 from ... import
    *”](ch17.xhtml#avoid_exec_and_from_dotdotdot_import_as)中讨论的那样，因此在大多数情况下将大部分代码放入函数中是有很好的实际理由的，并且没有任何缺点：当你避免大量模块级代码时，清晰度、可读性和代码重用性都会提高。
- en: 'A *function* is a group of statements that execute upon request. Python provides
    many built-in functions and lets programmers define their own functions. A request
    to execute a function is known as a *function call*. When you call a function,
    you can pass arguments that specify data upon which the function performs its
    computation. In Python, a function always returns a result: either **None** or
    a value, the result of the computation. Functions defined within **class** statements
    are also known as *methods*. We cover issues specific to methods in [“Bound and
    Unbound Methods”](ch04.xhtml#bound_and_unbound_methods); the general coverage
    of functions in this section, however, also applies to methods.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*是按请求执行的一组语句。Python 提供了许多内置函数，并允许程序员定义自己的函数。调用函数的请求称为*函数调用*。当你调用一个函数时，可以传递参数来指定函数执行计算的数据。在
    Python 中，函数总是返回一个结果：要么是**None**，要么是计算的结果值。在**class**语句中定义的函数也称为*方法*。我们在[“绑定和非绑定方法”](ch04.xhtml#bound_and_unbound_methods)中介绍了特定于方法的问题；然而，在本节中一般函数的覆盖同样适用于方法。'
- en: Python is somewhat unusual in the flexibility it affords the programmer in defining
    and calling functions. This flexibility does mean that some constraints are not
    adequately expressed solely by the syntax. In Python, functions are objects (values),
    handled just like other objects. Thus, you can pass a function as an argument
    in a call to another function, and a function can return another function as the
    result of a call. A function, just like any other object, can be bound to a variable,
    can be an item in a container, and can be an attribute of an object. Functions
    can also be keys in a dictionary. The fact that functions are ordinary objects
    in Python is often expressed by saying that functions are *first-class* objects.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在定义和调用函数方面为程序员提供了相当灵活的机会，这种灵活性意味着某些约束条件不能仅通过语法充分表达。在 Python 中，函数是对象（值），可以像处理其他对象一样处理。因此，你可以将一个函数作为参数传递给另一个函数的调用，并且一个函数可以作为调用的结果返回另一个函数。一个函数就像任何其他对象一样，可以绑定到一个变量上，可以是容器中的一个项，也可以是对象的属性。函数还可以作为字典中的键。在
    Python 中，函数是普通对象的事实常常被称为函数是*一等对象*。
- en: 'For example, given a dict keyed by functions, with the values being each function’s
    inverse, you could make the dictionary bidirectional by adding the inverse values
    as keys, with their corresponding keys as values. Here’s a small example of this
    idea, using some functions from the module math (covered in [“The math and cmath
    Modules”](ch16.xhtml#the_math_and_cmath_modules)), that takes a one-way mapping
    of inverse pairs and then adds the inverse of each entry to complete the mapping:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定一个以函数为键的字典，并且其值是每个函数的逆，你可以通过将逆值作为键添加到字典中，并将其对应的键作为值来使字典双向化。以下是这个想法的一个小例子，使用了来自
    math 模块中的一些函数（在[“math 和 cmath 模块”](ch16.xhtml#the_math_and_cmath_modules)中有介绍），该例子将一个单向映射的逆对添加到完整映射中：
- en: '[PRE147]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Note that in this case the function mutates its argument (whence its need to
    use a list call for looping). In Python, the usual convention is for such functions
    not to return a value (see [“The return Statement”](#the_return_statement)).
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，函数改变了它的参数（因此需要使用列表调用进行循环）。在 Python 中，通常约定这种函数不返回值（参见[“return 语句”](#the_return_statement)）。
- en: 'Defining Functions: The def Statement'
  id: totrans-747
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义函数：def 语句
- en: 'The **def** statement is the usual way to create a function. **def** is a single-clause
    compound statement with the following syntax:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '**def** 语句是创建函数的常见方式。**def** 是一个单子句复合语句，具有以下语法：'
- en: '[PRE148]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '*function_name* is an identifier, and the nonempty indented *statement(s)*
    are the *function body*. When the interpreter encounters a **def** statement,
    it compiles the function body, creating a function object, and binds (or rebinds,
    if there was an existing binding) *function_name* to the compiled function object
    in the containing namespace (typically the module namespace, or a class namespace
    when defining methods).'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '*function_name*是一个标识符，缩进的 *statement(s)* 是 *function body*。当解释器遇到 **def** 语句时，它会编译函数体，创建函数对象，并将（或重新绑定，如果存在绑定）*function_name*绑定到包含命名空间中的编译函数对象（通常是模块命名空间，或者定义方法时的类命名空间）。'
- en: '*parameters* is an optional list specifying the identifiers that will be bound
    to values that each function call provides. We distinguish between those identifiers,
    and the values provided for them in calls, as usual in computer science by referring
    to the former as *parameters* and the latter as *arguments*.'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '*parameters*是一个可选列表，指定每个函数调用提供的将绑定到的标识符。我们通过将前者称为 *parameters* 后者称为 *arguments*，通常在计算机科学中区分它们。'
- en: In the simplest case, a function defines no parameters, meaning the function
    won’t accept any arguments when you call it. In this case, the **def** statement
    has empty parentheses after *function_name*, as must all calls. Otherwise, *parameters*
    will be a list of specifications (see [“Parameters”](#parameters)). The function
    body does not execute when the **def** statement executes; rather, Python compiles
    it into bytecode, saves it as the function object’s __code__ attribute, and executes
    it later on each call to the function. The function body can contain zero or more
    occurrences of the **return** statement, as we’ll discuss shortly.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，函数不定义任何参数，这意味着在调用时函数不接受任何参数。在这种情况下，*function_name*后的 **def** 语句括号为空，所有的调用也必须如此。否则，*parameters*将是一个规范的列表（参见[“参数”](#parameters)）。当
    **def** 语句执行时，函数体不会执行；相反，Python将其编译为字节码，保存为函数对象的 __code__ 属性，并在每次调用函数时稍后执行。函数体可以包含零个或多个
    **return** 语句，我们稍后会讨论。
- en: Each call to the function supplies argument expressions corresponding to parameters
    in the function definition. The interpreter evaluates the argument expressions
    from left to right and creates a new namespace in which it binds the argument
    values to the parameter names as local variables of the function call (as we discuss
    in [“Calling Functions”](#calling_functions)). Then Python executes the function
    body, with the function call namespace as the local namespace.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 对函数的每次调用都提供了与函数定义中的参数对应的参数表达式。解释器从左到右评估参数表达式，并创建一个新的命名空间，在其中将参数值绑定到参数名作为函数调用的局部变量（我们在[“调用函数”](#calling_functions)中讨论）。然后Python执行函数体，将函数调用命名空间作为局部命名空间。
- en: 'Here’s a simple function that returns a value that is twice the value passed
    to it each time it’s called:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数，每次调用时都返回传递给它的值的两倍的值：
- en: '[PRE149]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The argument can be anything that you can multiply by two, so you could call
    the function with a number, string, list, or tuple as an argument. Each call returns
    a new value of the same type as the argument: twice(''ciao''), for example, returns
    ''ciaociao''.'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以是任何可以乘以二的东西，因此您可以使用数字、字符串、列表或元组作为参数调用函数。每次调用都会返回与参数相同类型的新值：例如，twice('ciao')返回'ciaociao'。
- en: The number of parameters of a function, together with the parameters’ names,
    the number of mandatory parameters, and the information on whether and where unmatched
    arguments should be collected, are a specification known as the function’s *signature*.
    A signature defines how you can call the function.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数数量以及参数的名称、必须参数的数量以及是否以及如何收集未匹配的参数的信息构成了函数的 *signature*。签名定义了如何调用函数。
- en: Parameters
  id: totrans-758
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数
- en: Parameters (pedantically, *formal parameters*) name the values passed into a
    function call, and may specify default values for them. Each time you call the
    function, the call binds each parameter name to the corresponding argument value
    in a new local namespace, which Python later destroys on function exit.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 参数（严谨地说，*形式参数*）指的是传递给函数调用的值，并且可以为它们指定默认值。每次调用函数时，调用会将每个参数名绑定到新的局部命名空间中相应的参数值，Python稍后会在函数退出时销毁该命名空间。
- en: Besides letting you name individual arguments, Python also lets you collect
    argument values not matched by individual parameters, and lets you specifically
    require that some arguments be positional, or be named.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许您命名单个参数外，Python还允许您收集未与单个参数匹配的参数值，并允许您特别要求某些参数是位置的或命名的。
- en: Positional parameters
  id: totrans-761
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置参数
- en: A positional parameter is an identifier, *name*, which names the parameter.
    You use these names inside the function body to access the argument values to
    the call. Callers can normally provide values for these parameters with either
    positional or named arguments (see [“Matching arguments to parameters”](#matching_arguments_to_parameters)).
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数是一个标识符，*name*，用于命名参数。在函数体内使用这些名称访问调用的参数值。调用者通常可以使用位置或命名参数为这些参数提供值（请参阅[“将参数匹配到参数”](#matching_arguments_to_parameters)）。
- en: Named parameters
  id: totrans-763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名参数
- en: 'Named parameters normally take the form *name*=*expression* (3.8+ or come after
    a positional argument collector, often just *, as discussed shortly). They are
    also often known (when written in the traditional *name*=*expression* form) as
    *default*, *optional*, and even—confusingly, since they do not involve any Python
    keywords—*keyword* parameters. When it executes a **def** statement, the interpreter
    evaluates each such *expression* and saves the resulting value, known as the *default
    value* for the parameter, among the attributes of the function object. A function
    call thus need not provide an argument value for a named parameter written in
    the traditional form: the call uses the default value given as the *expression*.
    You may provide positional arguments as values for some named parameters (3.8+
    except for parameters that are identified as named ones by appearing after a positional
    argument collector; see also [“Matching arguments to parameters”](#matching_arguments_to_parameters)).'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数通常采用*name*=*expression*的形式（3.8+或在位置参数收集器之后，通常只是*，如稍后讨论的那样）。它们通常被称为*默认*、*可选*甚至（令人困惑的是，因为它们不涉及任何Python关键字）*关键字*参数。当解释器执行**def**语句时，会评估每个这样的*expression*并保存结果值，称为参数的*默认值*，保存在函数对象的属性中。因此，在传统形式上写的命名参数不需要提供参数值：调用使用给定的*expression*作为默认值。对于某些命名参数，您可以提供位置参数作为值（3.8+，除了那些通过出现在位置参数收集器之后标识为命名参数的参数；另请参见[“将参数匹配到参数”](#matching_arguments_to_parameters)）。
- en: Python computes each default value *exactly once*, when the **def** statement
    executes, *not* each time you call the resulting function. In particular, this
    means that Python binds exactly the *same* object, the default value, to the named
    parameter whenever the caller does not supply a corresponding argument.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: Python在**def**语句执行时*仅一次*计算每个默认值*一次*，而不是每次调用生成的函数。特别是这意味着当调用者不提供相应参数时，Python将*相同*对象即默认值绑定到命名参数。
- en: Avoid Mutable Default Values
  id: totrans-766
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免可变默认值
- en: A function can alter a mutable default value, such as a list, each time you
    call the function without an argument corresponding to the respective parameter.
    This is usually not the behavior you want; for details, see [“Mutable default
    parameter values”](#mutable_default_parameter_values).
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以更改可变默认值，例如列表，在每次调用该函数时没有对应参数时。这通常不是您想要的行为；详情请参阅[“可变默认参数值”](#mutable_default_parameter_values)。
- en: Positional-only marker
  id: totrans-768
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅位置标记符
- en: 3.8+ A function’s signature may contain a single *positional-only marker* (/)
    as a dummy parameter. The parameters preceding the marker are known as *positional-only
    parameters*, and *must* be provided as positional arguments, *not* named arguments,
    when calling the function; using named arguments for these parameters raises a
    TypeError exception.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 3.8+ 函数的签名可以包含单个*仅位置*标记符（/）作为虚拟参数。标记符之前的参数称为*仅位置参数*，在调用函数时必须作为位置参数提供，不能作为命名参数提供；对这些参数使用命名参数会引发TypeError异常。
- en: 'The built-in int type, for example, has the following signature:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，内置的int类型具有以下签名：
- en: '[PRE150]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: When calling int, you must pass a value for x and you must pass it positionally.
    base (used when x is a string to be converted to int) is optional, and you may
    pass it either positionally or as a named argument (it’s an error to pass x as
    a number and also pass base, but the notation cannot capture that quirk).
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 调用int时，必须为x传递一个值，并且必须按位置传递。base（当x是要转换为int的字符串时使用）是可选的，可以按位置或作为命名参数传递（如果将x作为数字传递并且也传递base，这是一个错误，但是表示法无法捕获该怪癖）。
- en: Positional argument collector
  id: totrans-773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置参数收集器
- en: The positional argument collector can take one of two forms, either **name*
    or 3.8+ just *. In the former case, *name* is bound at call time to a tuple of
    unmatched positional arguments (when all positional arguments are matched, the
    tuple is empty). In the latter case (the * is a dummy parameter), a call with
    unmatched positional arguments raises a TypeError exception.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数收集器可以采用两种形式之一，即*name*或3.8+的*。在前一种情况下，调用时*name*绑定到一个未匹配位置参数的元组（当所有位置参数匹配时，元组为空）。在后一种情况下（*是一个虚拟参数），使用未匹配的位置参数调用会引发TypeError异常。
- en: 'When a function’s signature has either kind of positional argument collector,
    no call can provide a positional argument for a named parameter coming after the
    collector: the collector prohibits (in the * form) or gives a destination for
    (in the **name* form) positional arguments that do not correspond to parameters
    coming before it.'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数签名具有任一种类的位置参数收集器时，没有调用可以为收集器后来的命名参数提供位置参数：收集器禁止（在*形式中）或为不对应前面参数的位置参数提供目标（在**name*形式中）。
- en: 'For example, consider this function from the random module:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑random模块中的这个函数：
- en: '[PRE151]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: When calling sample, values for population and k are required, and may be passed
    positionally or by name. counts is optional; if you do pass it, you must pass
    it as a named argument.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用sample时，需要为population和k传递值，可以按位置或按名称传递。counts是可选的；如果传递它，则必须将其作为命名参数传递。
- en: Named argument collector
  id: totrans-779
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名参数收集器
- en: This final, optional parameter specification has the form ***name*. When the
    function is called, *name* is bound to a dictionary whose items are the (*key*,
    *value*) pairs of any unmatched named arguments, or an empty dictionary if there
    are no such arguments.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最终的可选参数规范的形式为***name*。当调用函数时，*name*被绑定到一个字典，其项为任何未匹配命名参数的(*key*, *value*)对，如果没有这样的参数，则为空字典。
- en: Parameter sequence
  id: totrans-781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数序列
- en: Generally speaking, positional parameters are followed by named parameters,
    with the positional and named argument collectors (if present) last. The positional-only
    marker, however, may appear at any position in the list of parameters.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，位置参数后跟命名参数，如果有的话，位置和命名参数收集器最后。但是，位置仅限标记可以出现在参数列表的任何位置。
- en: Mutable default parameter values
  id: totrans-783
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变默认参数值
- en: 'When a named parameter’s default value is a mutable object, and the function
    body alters the parameter, things get tricky. For example:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 当命名参数的默认值是可变对象，并且函数体改变了该参数时，情况变得复杂。例如：
- en: '[PRE152]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The second print prints [23, 42] because the first call to f altered the default
    value of y, originally an empty list [], by appending 23 to it. The id values
    (always equal to each other, although otherwise arbitrary) confirm that both calls
    return the same object. If you want y to be a new, empty list object, each time
    you call f with a single argument (a far more frequent need!), use the following
    idiom instead:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个打印输出[23, 42]，因为对f的第一次调用通过将23附加到它改变了y的默认值，最初是一个空列表[]。id值（始终相等，尽管在其他方面是任意的）确认两次调用返回相同的对象。如果希望y在每次使用单个参数（这种情况更频繁！）调用f时是一个新的空列表对象，请改用以下习惯用法：
- en: '[PRE153]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'There may be cases in which you explicitly want a mutable default parameter
    value that is preserved across multiple function calls, most often for caching
    purposes, as in the following example:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有情况需要显式使用可变的默认参数值，以便在多次函数调用之间保留，通常是为了缓存目的，如下例所示：
- en: '[PRE154]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Such caching behavior (also known as *memoization*) is usually best obtained
    by decorating the underlying costly_computation function with functools.lru_cache,
    covered in [Table 8-7](ch08.xhtml#functions_and_attributes_of_the_functoo) and
    discussed in detail in [Chapter 17](ch17.xhtml#testingcomma_debuggingcomma_and_optimiz).
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缓存行为（也称为*记忆化*）通常通过使用functools.lru_cache装饰底层的costly_computation函数来实现，详见[表 8-7](ch08.xhtml#functions_and_attributes_of_the_functoo)，并在[第17章](ch17.xhtml#testingcomma_debuggingcomma_and_optimiz)中详细讨论。
- en: Argument collector parameters
  id: totrans-791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数收集器参数
- en: The presence of argument collectors (the special forms *, **name*, or ***name*)
    in a function’s signature allows a function to prohibit (*) or collect positional
    (**name*) or named (***name*) arguments that do not match any parameters (see
    [“Matching arguments to parameters”](#matching_arguments_to_parameters)). There
    is no requirement to use specific names—you can use any identifier you want in
    each special form. *args and **kwds or **kwargs, as well as *a and **k, are popular
    choices.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数签名中存在参数收集器（特殊形式 *、**name* 或 ***name*）允许函数禁止（*）或收集位置参数（**name*）或命名参数（***name*）的参数，这些参数与任何参数都不匹配（参见[“匹配参数到参数”](#matching_arguments_to_parameters)）。不需要使用特定的名称
    - 您可以在每个特殊形式中使用任何标识符。*args 和 **kwds 或 **kwargs，以及 *a 和 **k，是流行的选择。
- en: The presence of the special form * causes calls with unmatched positional arguments
    to raise a TypeError exception.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊形式 * 的存在会导致具有未匹配位置参数的调用引发 TypeError 异常。
- en: '*args specifies that any extra positional arguments to a call (i.e., positional
    arguments not matching positional parameters in the function signature) get collected
    into a (possibly empty) tuple, bound in the call’s local namespace to the name
    args. Without a positional argument collector, unmatched positional arguments
    raise a TypeError exception.'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '*args 指定任何额外的位置参数（即，在函数签名中未匹配到位置参数的位置参数）将被收集到一个（可能为空的）元组中，并绑定到名为 args 的调用本地命名空间中。没有位置参数收集器，未匹配的位置参数将引发
    TypeError 异常。'
- en: 'For example, here’s a function that accepts any number of positional arguments
    and returns their sum (and demonstrates the use of an identifier other than *args):'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个接受任意数量位置参数并返回它们总和的函数（并演示了除 *args 之外的标识符的使用）：
- en: '[PRE155]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Similarly, ***kwds  * specifies that any extra named arguments (i.e., those
    named arguments not explicitly specified in the signature) get collected into
    a (possibly empty) dictionary whose items are the names and values of those arguments,
    bound to the name *kwds* in the function call namespace.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，***kwds  * 指定任何额外命名的参数（即，那些在签名中未明确指定的命名参数）将被收集到一个（可能为空的）字典中，其条目为这些参数的名称和值，并绑定到函数调用命名空间中的名称
    *kwds* 中。
- en: 'For example, the following function takes a dictionary whose keys are strings
    and whose values are numeric, and adds given amounts to certain values:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下函数接受一个字典作为参数，其键为字符串，值为数字，并对某些值添加指定的数量：
- en: '[PRE156]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Without a named argument collector, unmatched named arguments raise a T⁠y⁠p⁠e​E⁠r⁠r⁠o⁠r
    exception.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 没有命名参数收集器，未匹配的命名参数将引发 T⁠y⁠p⁠e​E⁠r⁠r⁠o⁠r 异常。
- en: Attributes of Function Objects
  id: totrans-801
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数对象的属性
- en: The **def** statement sets some attributes of a function object *f*. The string
    attribute *f*.__name__ is the identifier that **def** uses as the function’s name.
    You may rebind __name__ to any string value, but trying to unbind it raises a
    TypeError exception. *f*.__defaults__, which you may freely rebind or unbind,
    is the tuple of default values for named parameters (empty, if the function has
    no named parameters).
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '**def** 语句设置函数对象 *f* 的一些属性。字符串属性 *f*.__name__ 是标识符，**def** 用作函数的名称。您可以将 __name__
    重新绑定为任何字符串值，但尝试取消绑定会引发 TypeError 异常。*f*.__defaults__ 是命名参数的默认值元组（如果函数没有命名参数，则为空）。'
- en: Docstrings
  id: totrans-803
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档字符串
- en: 'Another function attribute is the *documentation string*, or *docstring*. You
    may use or rebind a function *f*’s docstring attribute as *f*.__doc__. When the
    first statement in the function body is a string literal, the compiler binds that
    string as the function’s docstring attribute. A similar rule applies to classes
    and modules (see [“Class documentation strings”](ch04.xhtml#class_documentation_strings)
    and [“Module documentation strings”](ch07.xhtml#module_documentation_strings)).
    Docstrings can span multiple physical lines, so it’s best to specify them in triple-quoted
    string literal form. For example:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数属性是*文档字符串*或*docstring*。您可以使用或重新绑定函数 *f* 的 docstring 属性作为 *f*.__doc__。当函数体中的第一条语句是字符串文字时，编译器将该字符串绑定为函数的
    docstring 属性。类和模块也适用类似的规则（参见[“类文档字符串”](ch04.xhtml#class_documentation_strings)
    和 [“模块文档字符串”](ch07.xhtml#module_documentation_strings)）。文档字符串可以跨多个物理行，因此最好以三引号字符串文字的形式指定它们。例如：
- en: '[PRE157]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Documentation strings should be part of any Python code you write. They play
    a role similar to that of comments, but they are even more useful, since they
    remain available at runtime (unless you run your program with **python -OO**,
    as covered in [“Command-Line Syntax and Options”](ch02.xhtml#command_line_syntax_and_options)).
    Python’s help function (see [“Interactive Sessions”](ch02.xhtml#interactive_sessions)),
    development environments, and other tools can use the docstrings from function,
    class, and module objects to remind the programmer how to use those objects. The
    doctest module (covered in [“The doctest Module”](ch17.xhtml#the_doctest_module))
    makes it easy to check that sample code present in docstrings, if any, is accurate
    and correct, and remains so as the code and docs get edited and maintained.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串应该是你编写的任何 Python 代码的一部分。它们起到与注释类似的作用，但它们更加有用，因为它们在运行时仍然可用（除非你使用 **python
    -OO** 运行程序，详见[“命令行语法和选项”](ch02.xhtml#command_line_syntax_and_options)）。Python
    的帮助函数（参见[“交互会话”](ch02.xhtml#interactive_sessions)）、开发环境和其他工具可以使用函数、类和模块对象的文档字符串来提醒程序员如何使用这些对象。doctest
    模块（详见[“doctest 模块”](ch17.xhtml#the_doctest_module)）使得检查文档字符串中存在的示例代码是否准确和正确，并且随着代码和文档的编辑和维护而保持如此变得容易。
- en: 'To make your docstrings as useful as possible, respect a few simple conventions,
    as detailed in [PEP 257](https://oreil.ly/CVF7t). The first line of a docstring
    should be a concise summary of the function’s purpose, starting with an uppercase
    letter and ending with a period. It should not mention the function’s name, unless
    the name happens to be a natural-language word that comes naturally as part of
    a good, concise summary of the function’s operation. Use imperative rather than
    descriptive form: e.g., say “Return xyz…” rather than “Returns xyz…” If the docstring
    is multiline, the second line should be empty, and the following lines should
    form one or more paragraphs, separated by empty lines, describing the function’s
    parameters, preconditions, return value, and side effects (if any). Further explanations,
    bibliographical references, and usage examples—which you should always check with
    doctest—can optionally (and often very usefully!) follow toward the end of the
    docstring.'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的文档字符串尽可能有用，请遵守一些简单的约定，详见 [PEP 257](https://oreil.ly/CVF7t)。文档字符串的第一行应该是函数目的的简明摘要，以大写字母开头，并以句点结尾。它不应该提到函数的名称，除非名称恰好是自然语言中与函数操作的一个好、简明摘要相关的词语。使用命令式而不是描述性的形式：例如，说“Return
    xyz…” 而不是 “Returns xyz…” 如果文档字符串是多行的，则第二行应为空白行，接下来的行应形成一个或多个段落，段落之间用空行分隔，描述函数的参数、前提条件、返回值和副作用（如果有）。进一步的解释、文献引用和使用示例（你应该始终使用
    doctest 进行检查）可以选择性地（通常非常有用地！）放在文档字符串的末尾。
- en: Other attributes of function objects
  id: totrans-808
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数对象的其他属性
- en: 'In addition to its predefined attributes, a function object may have other
    arbitrary attributes. To create an attribute of a function object, bind a value
    to the appropriate attribute reference in an assignment statement after the **def**
    statement executes. For example, a function could count how many times it gets
    called:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其预定义的属性外，函数对象可能还有其他任意属性。要创建函数对象的属性，请在 **def** 语句执行后的赋值语句中将一个值绑定到相应的属性引用。例如，一个函数可以统计自己被调用的次数：
- en: '[PRE158]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Note that this is *not* common usage. More often, when you want to group together
    some state (data) and some behavior (code), you should use the object-oriented
    mechanisms covered in [Chapter 4](ch04.xhtml#object_oriented_python). However,
    the ability to associate arbitrary attributes with a function can sometimes come
    in handy.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种用法*并不*常见。更常见的情况是，当你想要将一些状态（数据）和一些行为（代码）组合在一起时，你应该使用[第 4 章](ch04.xhtml#object_oriented_python)
    中介绍的面向对象机制。然而，有时候将任意属性与函数关联起来的能力确实会派上用场。
- en: Function Annotations
  id: totrans-812
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数注释
- en: Every parameter in a **def** clause can be *annotated* with an arbitrary expression—that
    is, wherever within the **def**’s parameter list you can use an identifier, you
    can alternatively use the form *identifier*:*expression*, and the expression’s
    value becomes the *annotation* for that parameter.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '**def** 子句中的每个参数都可以用任意表达式进行*注释*，也就是说，在 **def** 的参数列表中任何可以使用标识符的地方，你都可以使用 *标识符*:*表达式*
    的形式，表达式的值将成为该参数的*注释*。'
- en: 'You can also annotate the return value of the function, using the form *->expression*
    between the ) of the **def** clause and the : that ends the **def** clause; the
    expression’s value becomes the annotation for the name ''return''. For example:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用形式*->表达式*在**def**子句的)和结束**def**子句的:之间注释函数的返回值；表达式的值成为名称'return'的注释。例如：
- en: '[PRE159]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: As shown in this example, the __annotations__ attribute of the function object
    is a dict mapping each annotated identifier to the respective annotation.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 如本示例所示，函数对象的__annotations__属性是一个字典，将每个带注释的标识符映射到相应的注释。
- en: 'You can currently, in theory, use annotations for whatever purpose you wish:
    Python itself does nothing with them, except construct the __annotations__ attribute.
    For detailed information about annotations used for type hinting, which is now
    normally considered their key use, see [Chapter 5](ch05.xhtml#type_annotations).'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，理论上你可以为任何目的使用注释：Python本身除了构造__annotations__属性外不做任何处理。关于用于类型提示的注释的详细信息，通常认为它们是关键用途，请参阅[第5章](ch05.xhtml#type_annotations)。
- en: The return Statement
  id: totrans-819
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**return**语句'
- en: You can use the **return** keyword in Python only inside a function body, and
    you can optionally follow it with an expression. When **return** executes, the
    function terminates, and the value of the expression is the function’s result.
    A function returns **None** when it terminates by reaching the end of its body,
    or by executing a **return** statement with no expression (or by explicitly executing
    **return** **None**).
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你只能在函数体内使用**return**关键字，并且可选择跟随一个表达式。当**return**执行时，函数终止，并且表达式的值是函数的结果。当函数通过到达其体的末尾或执行没有表达式的**return**语句（或明确执行**return**
    **None**）终止时，函数返回**None**。
- en: Good Style in return Statements
  id: totrans-821
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回语句的良好风格
- en: As a matter of good style, when some **return** statements in a function have
    an expression, then *all* **return** statements in the function should have an
    expression. **return** **None** should only ever be written explicitly to meet
    this style requirement. *Never* write a **return** statement without an expression
    at the end of a function body. Python does not enforce these stylistic conventions,
    but your code is clearer and more readable when you follow them.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好风格的一部分，当函数中的某些**return**语句有表达式时，函数中的所有**return**语句都应该有表达式。只有为了满足这种风格要求才明确写出**return**
    **None**。*永远*不要在函数体末尾写出没有表达式的**return**语句。Python不强制执行这些风格约定，但是当你遵循它们时，你的代码更清晰、更可读。
- en: Calling Functions
  id: totrans-823
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'A function call is an expression with the following syntax:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用是带有以下语法的表达式：
- en: '[PRE161]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '*function_object* may be any reference to a function (or other callable) object;
    most often, it’s just the function’s name. The parentheses denote the function
    call operation itself. *arguments*, in the simplest case, is a series of zero
    or more expressions separated by commas (,), giving values for the function’s
    corresponding parameters. When the function call executes, the parameters are
    bound to the argument values in a new namespace, the function body executes, and
    the value of the function call expression is whatever the function returns. Objects
    created inside and returned by the function are liable to garbage collection unless
    the caller retains a reference to them.'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '*function_object*可以是对函数（或其他可调用）对象的任何引用；最常见的是函数的名称。括号表示函数调用操作本身。*arguments*在最简单的情况下是一系列由逗号（,）分隔的零个或多个表达式，给出了函数对应参数的值。当函数调用执行时，参数绑定到新的命名空间中的参数值，函数体执行，并且函数调用表达式的值是函数返回的任何内容。在函数内创建并返回的对象可能会被垃圾回收，除非调用者保留对它们的引用。'
- en: Don’t Forget the Trailing () to Call a Function
  id: totrans-827
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要忘记在调用函数时加上尾随的()。
- en: Just *mentioning* a function (or other callable object) does *not*, per se,
    call it. To *call* a function (or other object) without arguments, you *must*
    use () after the function’s name (or other reference to the callable object).
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅*提及*一个函数（或其他可调用对象）*本身不会*调用它。要调用一个函数（或其他对象）而不带参数，必须在函数名（或对可调用对象的其他引用）后面加上()。
- en: Positional and named arguments
  id: totrans-829
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置参数和命名参数
- en: 'Arguments can be of two types. *Positional* arguments are simple expressions;
    *named* (also known, alas, as *keyword*^([26](ch03.xhtml#ch01fn45))) arguments
    take the form:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以有两种类型。*位置*参数是简单的表达式；*命名*参数（也被遗憾地称为*关键字*^([26](ch03.xhtml#ch01fn45)))参数采用以下形式：
- en: '[PRE162]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'It is a syntax error for named arguments to precede positional ones in a function
    call. Zero or more positional arguments may be followed by zero or more named
    arguments. Each positional argument supplies the value for the parameter that
    corresponds to it by position (order) in the function definition. There is no
    requirement for positional arguments to match positional parameters, or vice versa—if
    there are more positional arguments than positional parameters, the additional
    arguments are bound by position to named parameters, if any, for all parameters
    preceding an argument collector in the signature. For example:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用中，命名参数位于位置参数之前是语法错误。可以在零个或多个位置参数后跟零个或多个命名参数。每个位置参数通过函数定义中的位置（顺序）对应于相应的参数提供值。没有要求位置参数必须匹配位置参数，反之亦然——如果位置参数多于位置参数，则附加参数将按位置绑定到签名中的所有参数之前的命名参数（如果有）。例如：
- en: '[PRE163]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Note that it matters where in the function signature the argument collector
    appears (see [“Matching arguments to parameters”](#matching_arguments_to_parameters)
    for all the gory details):'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，参数收集器出现在函数签名中的位置很重要（有关“将参数与参数匹配”的所有细节，请参见 [“Matching arguments to parameters”](#matching_arguments_to_parameters)）：
- en: '[PRE164]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'In the absence of any named argument collector (***name*) parameter, each argument’s
    name must be one of the parameter names used in the function’s signature.^([27](ch03.xhtml#ch01fn46))
    The *expression* supplies the value for the parameter of that name. Many built-in
    functions do not accept named arguments: you must call such functions with positional
    arguments only. However, functions coded in Python usually accept named as well
    as positional arguments, so you may call them in different ways. Positional parameters
    can be matched by named arguments, in the absence of matching positional arguments.'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有任何命名参数收集器（***name*）参数的情况下，每个参数的名称必须是函数签名中使用的参数名称之一。^([27](ch03.xhtml#ch01fn46))
    *expression* 提供该名称参数的值。许多内置函数不接受命名参数：您必须仅使用位置参数调用这些函数。但是，使用 Python 编写的函数通常接受命名参数和位置参数，因此可以以不同的方式调用它们。在没有匹配位置参数的情况下，可以通过命名参数匹配位置参数。
- en: 'A function call must supply, via a positional or a named argument, exactly
    one value for each mandatory parameter, and zero or one value for each optional
    parameter.^([28](ch03.xhtml#ch01fn47)) For example:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用必须通过位置参数或命名参数提供每个必需参数的一个值，并为每个可选参数提供零个或一个值。^([28](ch03.xhtml#ch01fn47))
    例如：
- en: '[PRE165]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: As you can see, the four calls to divide here are equivalent. You can pass named
    arguments for readability purposes whenever you think that identifying the role
    of each argument and controlling the order of arguments enhances your code’s clarity.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，在此处对 divide 的四次调用是等效的。在代码更易读的情况下，您可以传递命名参数，以便于识别每个参数的角色并控制参数顺序，增强代码的清晰度。
- en: 'A common use of named arguments is to bind some optional parameters to specific
    values, while letting other optional parameters take default values:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数的常见用法是将某些可选参数绑定到特定值，同时让其他可选参数采用默认值：
- en: '[PRE166]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'With the named argument end='''', the caller specifies a value (the empty string
    '''') for f’s third parameter, end, and still lets *f*’s second parameter, begin,
    use its default value, the string ''init''. You may pass the arguments as positional
    even when parameters are named; for example, with the preceding function:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名参数 end='' 时，调用者为 f 的第三个参数 end 指定一个值（空字符串 ''），同时让 *f* 的第二个参数 begin 使用其默认值
    'init'。即使参数是命名的，也可以按位置传递参数；例如，对于上述函数：
- en: '[PRE167]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: At the end of the arguments in a function call, you may optionally use either
    or both of the special forms **seq* and ***dct*. If both forms are present, the
    form with two asterisks must be last. **seq* passes the items of iterable *seq*
    to the function as positional arguments (after the normal positional arguments,
    if any, that the call gives with the usual syntax). *seq* may be any iterable.
    ***dct* passes the items of *dct* to the function as named arguments, where *dct*
    must be a mapping whose keys are all strings. Each item’s key is a parameter name,
    and the item’s value is the argument’s value.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用的参数末尾，您可以选择使用特殊形式 **seq* 和 ***dct* 中的一个或两个。如果两种形式同时出现，则必须将带有两个星号的形式放在最后。
    **seq* 将 iterable *seq* 的项作为位置参数传递给函数（在调用使用常规语法给出的任何正常位置参数之后）。 *seq* 可以是任何可迭代对象。
    ***dct* 将 *dct* 的项作为命名参数传递给函数，其中 *dct* 必须是其所有键都为字符串的映射。每个项的键是参数名，项的值是参数的值。
- en: 'You may want to pass an argument of the form **seq* or ***dct* when the parameters
    use similar forms, as discussed in [“Parameters”](#parameters). For example, using
    the function sum_sequence defined in that section (and shown again here), you
    may want to print the sum of all the values in the dictionary *d*. This is easy
    with **seq*:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数使用类似形式时，您可能希望传递一个**seq*或***dct*的参数，如[“参数”](#parameters)中所讨论的。例如，在该部分定义的sum_sequence函数（并在此处再次显示）中，您可能希望打印字典*d*中所有值的总和。这在使用**seq*时很容易：
- en: '[PRE168]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: (Of course, print(sum(d.values())) would be simpler and more direct.)
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: （当然，print(sum(d.values()))会更简单和更直接。）
- en: A function call may have zero or more occurrences of **seq* and/or ***dct*,
    as specified in [PEP 448](https://oreil.ly/6lHq_). You may even pass **seq* or
    ***dct* when calling a function that does not use the corresponding form in its
    signature. In that case, you must ensure that the iterable *seq* has the right
    number of items, or that the dictionary *dct* uses the right identifier strings
    as keys; otherwise, the call raises an exception. As noted in the following section,
    a positional argument *cannot* match a “keyword-only” parameter; only a named
    argument, explicit or passed via ***kwargs*, can do that.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[PEP 448](https://oreil.ly/6lHq_)的规定，函数调用可能包含零个或多个**seq*和/或***dct*。即使在调用一个签名中没有使用对应形式的函数时，也可以传递**seq*或***dct*。在这种情况下，您必须确保可迭代对象*seq*具有正确数量的项，或者字典*dct*使用正确的标识符字符串作为键；否则，调用将引发异常。如下一节所述，位置参数*不能*匹配“仅关键字”参数；只有显式的或通过***kwargs*传递的命名参数才能做到这一点。
- en: “Keyword-only” parameters
  id: totrans-849
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “仅关键字”参数
- en: 'Parameters after a positional argument collector (**name* or 3.8+ *) in the
    function’s signature are known as *keyword-only parameters*: the corresponding
    arguments, if any, *must* be named arguments. In the absence of any match by name,
    such a parameter is bound to its default value, as set at function definition
    time.'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数签名中的位置参数收集器（**name*或3.8+ *）后面的参数被称为“仅关键字”参数：如果有的话，*必须*作为命名参数传递。在没有任何名称匹配的情况下，这样的参数将绑定到其在函数定义时设置的默认值。
- en: Keyword-only parameters can be either positional or named. However, you *must*
    pass them as named arguments, not as positional ones. It’s more usual and readable
    to have simple identifiers, if any, at the start of the keyword-only parameter
    specifications, and *identifier*=*default* forms, if any, following them, though
    this is not a requirement of the Python language.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: “仅关键字”参数可以是位置的也可以是命名的。然而，您*必须*将它们作为命名参数传递，而不是作为位置参数。通常和可读性更强的做法是，在“仅关键字”参数规范的开始处（如果有的话）有简单的标识符，而在其后的*identifier*=*default*形式，尽管这不是Python语言的要求。
- en: 'Functions requiring keyword-only parameter specifications *without* collecting
    “surplus” positional arguments indicate the start of the keyword-only parameter
    specifications with a dummy parameter consisting solely of an asterisk (*), to
    which no argument corresponds. For example:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 需要没有收集“多余”位置参数规范的函数在关键字参数规范的开始处使用一个仅包含星号(*)的虚拟参数，这个参数没有对应的实参。例如：
- en: '[PRE169]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'If you also specify the special form ***kwds*, it must come at the end of the
    parameter list (after the keyword-only parameter specifications, if any). For
    example:'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还指定了特殊形式***kwds*，它必须位于参数列表的末尾（在有的话之后的仅关键字参数规范）。例如：
- en: '[PRE170]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Matching arguments to parameters
  id: totrans-856
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将参数与参数匹配
- en: A call *must* provide an argument for all positional parameters, and *may* do
    so for named parameters that are not keyword only.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用*必须*为所有位置参数提供一个参数，并且*可以*为非仅关键字参数提供参数。
- en: 'The matching proceeds as follows:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配过程如下所示：
- en: Arguments of the form **expression* are internally replaced by a sequence of
    positional arguments obtained by iterating over *expression*.
  id: totrans-859
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 形式为**expression*的参数在内部被替换为一系列通过*expression*迭代获得的位置参数。
- en: Arguments of the form ***expression* are internally replaced by a sequence of
    keyword arguments whose names and values are obtained by iterating over *expression*’s
    items().
  id: totrans-860
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 形式为***expression*的参数在内部被替换为一系列关键字参数，其名称和值通过迭代*expression*的items()获得。
- en: 'Say that the function has *N* positional parameters and the call has *M* positional
    arguments:'
  id: totrans-861
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设函数有*N*个位置参数，并且调用有*M*个位置参数：
- en: When *M*≤*N*, bind all the positional arguments to the first *M* positional
    parameter names; the remaining positional parameters, if any, *must* be matched
    by named arguments.
  id: totrans-862
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当*M*≤*N*时，将所有位置参数绑定到前*M*个位置参数名称；如果有剩余的位置参数，*必须*通过命名参数匹配。
- en: 'When *M*>*N*, bind the remaining positional arguments to named parameters *in
    the order in which they appear in the signature*. This process terminates in one
    of three ways:'
  id: totrans-863
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当*M*>*N*时，将剩余的位置参数按照它们在签名中出现的顺序绑定到命名参数。此过程以以下三种方式之一终止：
- en: All positional arguments have been bound.
  id: totrans-864
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有位置参数都已绑定。
- en: 'The next item in the signature is a * argument collector: the interpreter raises
    a TypeError exception.'
  id: totrans-865
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 签名中的下一个项是一个*参数收集器：解释器会引发 TypeError 异常。
- en: 'The next item in the signature is a **name* argument collector: the remaining
    positional arguments are collected in a tuple that is then bound to *name* in
    the function call namespace.'
  id: totrans-866
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 签名中的下一个项是一个**name*参数收集器：剩余的位置参数将被收集到一个元组中，然后绑定到函数调用命名空间中的*name*。
- en: The named arguments are then matched, in the order of the arguments’ occurrences
    in the call, by name with the parameters—both positional and named. Attempts to
    rebind an already bound parameter name raise a TypeError exception.
  id: totrans-867
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 则按照参数在调用中出现的顺序，按名称与参数（包括位置和命名参数）匹配。尝试重新绑定已绑定的参数名称会引发 TypeError 异常。
- en: 'If unmatched named arguments remain at this stage:'
  id: totrans-868
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在此阶段有未匹配的命名参数：
- en: When the function signature includes a ***name* collector, the interpreter creates
    a dictionary with key/value pairs (*argument's_name, argument's_value*), and binds
    it to *name* in the function call namespace.
  id: totrans-869
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当函数签名包含一个***name*收集器时，解释器会创建一个字典，其中包含键/值对（*argument's_name, argument's_value*），并将其绑定到函数调用命名空间中的*name*。
- en: In the absence of such an argument collector, Python raises a TypeError exception.
  id: totrans-870
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有这种参数收集器的情况下，Python 会引发 TypeError 异常。
- en: Any remaining unmatched named parameters are bound to their default values.
  id: totrans-871
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何剩余的未匹配命名参数都将绑定到其默认值。
- en: At this point, the function call namespace is fully populated, and the interpreter
    executes the function’s body using that “call namespace” as the local namespace
    for the function.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，函数调用命名空间已经完全填充，解释器使用该“调用命名空间”作为函数的本地命名空间执行函数体。
- en: The semantics of argument passing
  id: totrans-873
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数传递的语义
- en: 'In traditional terms, all argument passing in Python is *by value* (although,
    in modern terminology, to say that argument passing is *by object reference* is
    more precise and accurate; check out the synonym [*call by sharing*](https://oreil.ly/kst2h)).
    When you pass a variable as an argument, Python passes to the function the object
    (value) to which the variable currently refers (not “the variable itself”!), binding
    this object to the parameter name in the function call namespace. Thus, a function
    *cannot* rebind the caller’s variables. Passing a mutable object as an argument,
    however, allows the function to make changes to that object, because Python passes
    a reference to the object itself, not a copy. Rebinding a variable and mutating
    an object are totally disjoint concepts. For example:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，Python 中的所有参数传递都是*按值*进行的（尽管在现代术语中，说参数传递是*按对象引用*更加精确和准确；请查看同义词[*按共享调用*](https://oreil.ly/kst2h)）。当您将一个变量作为参数传递给函数时，Python
    会将变量当前引用的对象（值）传递给函数，并将该对象绑定到函数调用命名空间中的参数名称。因此，函数*不能*重新绑定调用者的变量。但是，将可变对象作为参数传递允许函数对该对象进行更改，因为
    Python 传递的是对象本身的引用，而不是副本。重新绑定变量和变异对象是完全不同的概念。例如：
- en: '[PRE171]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: print shows that a is still bound to 77. Function f’s rebinding of its parameter
    x to 23 has no effect on f’s caller, nor, in particular, on the binding of the
    caller’s variable that happened to be used to pass 77 as the parameter’s value.
    However, print also shows that b is now bound to [99, 42]. b is still bound to
    the same list object as before the call, but f has appended 42 to that list object,
    mutating it. In neither case has f altered the caller’s bindings, nor can f alter
    the number 77, since numbers are immutable. f can alter a list object, though,
    since list objects are mutable.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: print 显示，a 仍绑定到 77。函数 f 对其参数 x 的重新绑定为 23 不会影响 f 的调用者，特别是不会影响用于传递 77 作为参数值的调用者变量的绑定。然而，print
    还显示，b 现在绑定到 [99, 42]。b 仍绑定到调用之前的同一个列表对象，但是 f 已向该列表对象附加了 42，从而使其发生了变异。在这两种情况下，f
    都没有改变调用者的绑定，也不能改变数字 77，因为数字是不可变的。不过，f 可以改变列表对象，因为列表对象是可变的。
- en: Namespaces
  id: totrans-877
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: A function’s parameters, plus any names that are bound (by assignment or by
    other binding statements, such as **def**) in the function body, make up the function’s
    *local namespace*, also known as its *local scope*. Each of these variables is
    known as a *local variable* of the function.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数加上在函数体中绑定（通过赋值或其他绑定语句，如**def**）的任何名称构成函数的*局部命名空间*，也称为其*局部作用域*。其中的每个变量被称为函数的局部变量。
- en: Variables that are not local are known as *global variables* (in the absence
    of nested function definitions, which we’ll discuss shortly). Global variables
    are attributes of the module object, as covered in [“Attributes of module objects”](ch07.xhtml#attributes_of_module_objects).
    Whenever a function’s local variable has the same name as a global variable, that
    name, within the function body, refers to the local variable, not the global one.
    We express this by saying that the local variable *hides* the global variable
    of the same name throughout the function body.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 非局部的变量称为*全局变量*（在没有嵌套函数定义的情况下，我们将很快讨论）。全局变量是模块对象的属性，如[“模块对象的属性”](ch07.xhtml#attributes_of_module_objects)所述。每当函数的局部变量与全局变量同名时，在函数体内，该名称指代的是局部变量，而不是全局变量。我们通过说局部变量*隐藏*了整个函数体中同名的全局变量来表示这一点。
- en: The global statement
  id: totrans-880
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: global语句
- en: 'By default, any variable bound in a function body is local to the function.
    If a function needs to bind or rebind some global variables (*not* best practice!),
    the first statement of the function’s body must be:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，函数体中绑定的任何变量都是局部变量。如果函数需要绑定或重新绑定一些全局变量（*不*是最佳实践！），函数体的第一个语句必须是：
- en: '[PRE172]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'where *identifiers* is one or more identifiers separated by commas (,). The
    identifiers listed in a **global** statement refer to the global variables (i.e.,
    attributes of the module object) that the function needs to bind or rebind. For
    example, the function counter that we saw in [“Other attributes of function objects”](#other_attributes_of_function_objects)
    could be implemented using **global** and a global variable, rather than an attribute
    of the function object:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 其   *标识符*是一个或多个用逗号（,）分隔的标识符。全局语句中列出的标识符指的是函数需要绑定或重新绑定的全局变量（即模块对象的属性）。例如，我们在[“函数对象的其他属性”](#other_attributes_of_function_objects)中看到的函数计数器可以使用**global**和一个全局变量来实现，而不是函数对象的属性：
- en: '[PRE173]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Without the **global** statement, the counter function would raise an UnboundLocalError
    exception when called, because _count would then be an uninitialized (unbound)
    local variable. While the **global** statement enables this kind of programming,
    this style is inelegant and ill-advised. As we mentioned earlier, when you want
    to group together some state and some behavior, the object-oriented mechanisms
    covered in [Chapter 4](ch04.xhtml#object_oriented_python) are usually best.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 没有**global**语句，计数器函数在调用时会引发UnboundLocalError异常，因为_count将是一个未初始化（未绑定）的局部变量。虽然**global**语句使这种编程成为可能，但这种风格不够优雅，也不可取。正如我们之前提到的，当你想要将一些状态和行为组合在一起时，通常最好使用[第四章](ch04.xhtml#object_oriented_python)中涵盖的面向对象机制。
- en: Eschew global
  id: totrans-886
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用global
- en: Never use **global** if the function body just *uses* a global variable (including
    mutating the object bound to that variable, when the object is mutable). Use a
    **global** statement only if the function body *rebinds* a global variable (generally
    by assigning to the variable’s name). As a matter of style, don’t use **global**
    unless it’s strictly necessary, as its presence causes readers of your program
    to assume the statement is there for some useful purpose. Never use **global**
    except as the first statement in a function body.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数体只是*使用*全局变量（包括对该变量绑定的对象进行变异，当对象是可变的时），则不要使用**global**。只有当函数体*重新绑定*全局变量（通常通过给变量名赋值）时才使用**global**语句。就风格而言，除非绝对必要，否则不要使用**global**，因为它的存在会导致你的程序的读者认为该语句有某种有用的目的。除非作为函数体的第一个语句，否则永远不要使用**global**。
- en: Nested functions and nested scopes
  id: totrans-888
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套函数和嵌套作用域
- en: A **def** statement within a function body defines a *nested function*, and
    the function whose body includes the **def** is known as an *outer function* to
    the nested one. Code in a nested function’s body may access (but *not* rebind)
    local variables of an outer function, also known as *free variables* of the nested
    function.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体内的**def**语句定义了一个*嵌套函数*，包含**def**的函数被称为嵌套函数的*外部函数*。嵌套函数体中的代码可以访问（但*不*重新绑定）外部函数的局部变量，也称为嵌套函数的*自由变量*。
- en: 'The simplest way to let a nested function access a value is often not to rely
    on nested scopes, but rather to pass that value explicitly as one of the function’s
    arguments. If need be, you can bind the argument’s value at nested-function **def**
    time: just use the value as the default for an optional argument. For example:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 让嵌套函数访问一个值的最简单方法通常不是依赖于嵌套作用域，而是将该值显式地作为函数的一个参数传递。如果需要，可以在嵌套函数的**def**时间绑定参数值：只需将该值用作可选参数的默认值。例如：
- en: '[PRE174]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Here’s the same functionality using nested scopes:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用嵌套作用域的相同功能：
- en: '[PRE175]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'In this specific case, percent1 has one tiny advantage: the computation of
    a+b+c happens only once, while percent2’s inner function pc repeats the computation
    three times. However, when the outer function rebinds local variables between
    calls to the nested function, repeating the computation can be necessary: be aware
    of both approaches, and choose the appropriate one on a case-by-case basis.'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定案例中，percent1 有微小的优势：计算 a+b+c 只发生一次，而 percent2 的内部函数 pc 会重复计算三次。然而，当外部函数在调用嵌套函数之间重新绑定局部变量时，重复计算可能是必要的：要注意这两种方法，并根据具体情况选择适当的方法。
- en: 'A nested function that accesses values from local variables of “outer” (containing)
    functions is also known as a *closure*. The following example shows how to build
    a closure:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 一个访问“外部”（包含的）函数的局部变量值的嵌套函数也被称为*闭包*。下面的例子展示了如何构建一个闭包：
- en: '[PRE176]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Closures are sometimes an exception to the general rule that the object-oriented
    mechanisms covered in the next chapter are the best way to bundle together data
    and code. When you specifically need to construct callable objects, with some
    parameters fixed at object construction time, closures can be simpler and more
    direct than classes. For example, the result of make_adder(7) is a function that
    accepts a single argument and returns 7 plus that argument. An outer function
    that returns a closure is a “factory” for members of a family of functions distinguished
    by some parameters, such as the value of the argument augend in the previous example,
    which may often help you avoid code duplication.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包有时是一个例外，与下一章介绍的面向对象机制作为捆绑数据和代码的最佳方式的一般规则不同。当您需要特别构造可调用对象，并在对象构造时固定一些参数时，闭包可能比类更简单和更直接。例如，make_adder(7)
    的结果是一个函数，接受一个参数并返回 7 加上该参数的值。一个返回闭包的外部函数是“工厂”，用于生成一组由某些参数（例如前面示例中的 augend 参数的值）区分的函数成员，这通常有助于避免代码重复。
- en: The **nonlocal** keyword acts similarly to **global**, but it refers to a name
    in the namespace of some lexically surrounding function. When it occurs in a function
    definition nested several levels deep (a rarely needed structure!), the compiler
    searches the namespace of the most deeply nested containing function, then the
    function containing that one, and so on, until the name is found or there are
    no further containing functions, in which case the compiler raises an error (a
    global name, if any, does not match).
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '**nonlocal** 关键字类似于 **global**，但它引用的是某个词法上包围函数的命名空间中的名称。当它出现在几层深的函数定义中（这是一个很少需要的结构！），编译器会在最深层的包含函数的命名空间中搜索，然后是包含该函数的函数，依此类推，直到找到名称或没有更进一步的包含函数为止，此时编译器会引发错误（如果有全局名称则不匹配）。'
- en: 'Here’s a nested functions approach to the “counter” functionality we implemented
    in previous sections using a function attribute, then a global variable:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们在之前章节中使用函数属性、然后是全局变量实现的“计数器”功能的嵌套函数方法：
- en: '[PRE177]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: A key advantage of this approach versus the previous ones is that these two
    nested functions, just like an object-oriented approach would, let you make independent
    counters—here c1 and c2. Each closure keeps its own state and doesn’t interfere
    with the other one.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与之前的方法相比的一个关键优势是，这两个嵌套函数，就像面向对象的方法一样，允许您创建独立的计数器 —— 这里是 c1 和 c2。每个闭包都保留其自己的状态，不会干扰另一个。
- en: lambda Expressions
  id: totrans-902
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lambda 表达式
- en: 'If a function body is a single **return** *expression* statement, you may (*very*
    optionally!) choose to replace the function with the special **lambda** expression
    form:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数体只是一个单一的 **return** *表达式* 语句，您可以（非常可选地！）选择使用特殊的 **lambda** 表达式形式替换该函数：
- en: '[PRE178]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: A **lambda** expression is the anonymous equivalent of a normal function whose
    body is a single **return** statement. The **lambda** syntax does not use the
    **return** keyword. You can use a **lambda** expression wherever you could use
    a reference to a function. **lambda** can sometimes be handy when you want to
    use an *extremely simple* function as an argument or return value.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '**lambda**表达式是普通函数的匿名等价物，其体是一个单一的**return**语句。**lambda**语法不使用**return**关键字。你可以在任何需要函数引用的地方使用**lambda**表达式。当你想要将一个*极其简单*的函数作为参数或返回值时，**lambda**有时会很方便。'
- en: 'Here’s an example that uses a **lambda** expression as an argument to the built-in
    sorted function (covered in [Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)):'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用**lambda**表达式作为内置sorted函数参数的示例（详见[表 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)）：
- en: '[PRE179]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Alternatively, you can always use a local **def** statement to give the function
    object a name, then use this name as an argument or return value. Here’s the same
    sorted example using a local **def** statement:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以总是使用本地**def**语句给函数对象一个名称，然后将这个名称作为参数或返回值。下面是使用本地**def**语句的相同sorted示例：
- en: '[PRE180]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'While **lambda** can at times be handy, **def** is usually better: it’s more
    general and helps you make your code more readable, since you can choose a clear
    name for the function.'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**lambda**有时候很方便，但**def**通常更好：它更通用，帮助你使代码更易读，因为你可以为函数选择一个清晰的名称。
- en: Generators
  id: totrans-911
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: When the body of a function contains one or more occurrences of the keyword
    **yield**, the function is known as a *generator*, or more precisely a *generator
    function*. When you call a generator, the function body does not execute. Instead,
    the generator function returns a special iterator object, known as a *generator
    object* (sometimes, quite confusingly, also called just “a generator”), wrapping
    the function body, its local variables (including parameters), and the current
    point of execution (initially, the start of the function).
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数体中包含一个或多个关键字**yield**的时候，该函数被称为*生成器*，或者更精确地称为*生成器函数*。当你调用一个生成器时，函数体不会执行。相反，生成器函数返回一个特殊的迭代器对象，称为*生成器对象*（有时候，令人困惑地，也称为“生成器”），包装函数体、其局部变量（包括参数）和当前执行点（最初在函数的起始点）。
- en: 'When you (implicitly or explicitly) call next on a generator object, the function
    body executes from the current point up to the next **yield**, which takes the
    form:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 当你（隐式或显式地）在一个生成器对象上调用next时，函数体从当前点开始执行，直到下一个**yield**，它的形式如下：
- en: '[PRE181]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: A bare **yield** without the expression is also legal, and equivalent to **yield**
    **None**. When **yield** executes, the function execution is “frozen,” preserving
    the current point of execution and local variables, and the expression following
    **yield** becomes the result of next. When you call next again, execution of the
    function body resumes where it left off, again up to the next **yield**. When
    the function body ends, or executes a **return** statement, the iterator raises
    a StopIteration exception to indicate that the iteration is finished. The expression
    after **return**, if any, is the argument to the StopIteration exception.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 一个裸的**yield**没有表达式也是合法的，并且等价于**yield** **None**。当**yield**执行时，函数的执行被“冻结”，保留当前执行点和局部变量，并且**yield**后面的表达式成为next的结果。当再次调用next时，函数体会从上次停止的地方继续执行，直到下一个**yield**。当函数体结束或执行**return**语句时，迭代器会抛出StopIteration异常以指示迭代结束。如果有的话，**return**后面的表达式是StopIteration异常的参数。
- en: '**yield** is an expression, not a statement. When you call *g*.send(*value*)
    on a generator object *g*, the value of **yield** is *value*; when you call next(*g*),
    the value of **yield** is **None**. We’ll talk more about this shortly: it’s an
    elementary building block for implementing [coroutines](https://oreil.ly/KI68p)
    in Python.'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '**yield**是一个表达式，而不是一个语句。当你在生成器对象*g*上调用*g*.send(*value*)时，**yield**的值是*value*；当你调用next(*g*)时，**yield**的值是**None**。我们稍后会详细讨论这一点：它是在Python中实现[协程](https://oreil.ly/KI68p)的基本构建块。'
- en: 'A generator function is often a handy way to build an iterator. Since the most
    common way to use an iterator is to loop on it with a **for** statement, you typically
    call a generator like this (with the call to next being implicit in the **for**
    statement):'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数通常是构建迭代器的一种便捷方式。由于最常见的使用迭代器的方式是使用**for**语句进行循环，你通常会像这样调用一个生成器（在**for**语句中隐式地调用next）：
- en: '[PRE182]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'For example, say that you want a sequence of numbers counting up from 1 to
    *N* and then down to 1 again. A generator can help:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您想要一个从1到*N*递增再递减到1的数字序列。一个生成器可以帮助实现：
- en: '[PRE183]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Here is a generator that works somewhat like built-in range, but returns an
    iterator on floating-point values rather than on integers:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个生成器，与内置的range函数有些相似，但返回浮点值的迭代器而不是整数：
- en: '[PRE184]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: This example is only *somewhat* like range because, for simplicity, it makes
    the arguments start and stop mandatory, and assumes that stride is positive.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例仅*部分*类似于range，因为为简单起见，假定了开始和停止参数是必需的，并且假定步长为正。
- en: 'Generator functions are more flexible than functions that return lists. A generator
    function may return an unbounded iterator, meaning one that yields an infinite
    stream of results (to use only in loops that terminate by other means, e.g., via
    a conditionally executed **break** statement). Further, a generator object iterator
    performs *lazy evaluation*: the iterator can compute each successive item only
    when and if needed, “just in time,” while the equivalent function does all computations
    in advance and may require large amounts of memory to hold the results list. Therefore,
    if all you need is the ability to iterate on a computed sequence, it is usually
    best to compute the sequence in a generator object, rather than in a function
    returning a list. If the caller needs a list of all the items produced by some
    bounded generator object built by *g*(*arguments*), the caller can simply use
    the following code to explicitly request that Python build a list:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数比返回列表的函数更灵活。生成器函数可以返回一个无限迭代器，即一个产生无限流结果的迭代器（仅在通过其他方式终止循环，例如通过有条件执行的**break**语句时使用）。此外，生成器对象迭代器执行*惰性评估*：迭代器只能在需要时计算每个后续项，“及时而不是提前”，而等效的函数则提前进行所有计算，并可能需要大量内存来保存结果列表。因此，如果您只需要能够迭代计算的序列，通常最好在生成器对象中计算序列，而不是在返回列表的函数中计算。如果调用者需要一个由*g*(*arguments*)构建的有界生成器对象产生的所有项目的列表，则调用者可以简单地使用以下代码显式请求Python构建列表：
- en: '[PRE185]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: yield from
  id: totrans-926
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: yield from
- en: 'To improve execution efficiency and clarity when multiple levels of iteration
    are yielding values, you can use the form **yield from** *expression*, where *expression*
    is iterable. This yields the values from *expression* one at a time into the calling
    environment, avoiding the need to **yield** repeatedly. We can thus simplify the
    updown generator we defined earlier:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 当多级迭代需要产生值时，为了提高执行效率和清晰度，可以使用形式**yield from** *expression*，其中*expression*是可迭代的。这将*expression*中的值逐个地传递到调用环境中，避免了重复使用**yield**的需要。因此，我们可以简化先前定义的updown生成器：
- en: '[PRE186]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Moreover, using **yield from** lets you use generators as *coroutines*, discussed
    next.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用**yield from**允许您将生成器用作*协程*，接下来将讨论。
- en: Generators as near-coroutines
  id: totrans-930
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 几乎是协程的生成器
- en: Generators are further enhanced with the possibility of receiving a value (or
    an exception) back from the caller as each **yield** executes. This lets generators
    implement [coroutines](https://oreil.ly/KI68p), as explained in [PEP 342](https://oreil.ly/ih77Z).
    When a generator object resumes (i.e., you call next on it), the corresponding
    **yield**’s value is **None**. To pass a value *x* into some generator object
    *g* (so that *g* receives *x* as the value of the **yield** on which it’s suspended),
    instead of calling next(*g*), call *g*.send(*x*) (*g*.send(**None**) is just like
    next(*g*)).
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器还进一步增强，可以在每次**yield**执行时从调用者那里接收一个值（或异常）。这使得生成器可以实现[协程](https://oreil.ly/KI68p)，详见[PEP
    342](https://oreil.ly/ih77Z)。当生成器对象恢复时（即在其上调用next），相应的**yield**的值为**None**。要将值*x*传递给某个生成器对象*g*（使*g*接收*x*作为其暂停的**yield**的值），而不是调用next(*g*)，可以调用*g*.send(*x*)（*g*.send(**None**)等同于next(*g*)）。
- en: 'Other enhancements to generators regard exceptions: we cover them in [“Generators
    and Exceptions”](ch06.xhtml#generators_and_exceptions).'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 其他增强生成器的方面涉及异常处理：我们在[“生成器和异常”](ch06.xhtml#generators_and_exceptions)中进行了介绍。
- en: Generator expressions
  id: totrans-933
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: 'Python offers an even simpler way to code particularly simple generators: *generator
    expressions*, commonly known as *genexps*. The syntax of a genexp is just like
    that of a list comprehension (as covered in [“List comprehensions”](#list_comprehensions)),
    except that a genexp is within parentheses (()) instead of brackets ([]). The
    semantics of a genexp are the same as those of the corresponding list comprehension,
    except that a genexp produces an iterator yielding one item at a time, while a
    list comprehension produces a list of all results in memory (therefore, using
    a genexp, when appropriate, saves memory). For example, to sum the squares of
    all single-digit integers, you could code sum([x*x **for** x **in** range(10)]),
    but you can express this better as sum(x*x **for** x **in** range(10)) (just the
    same, but omitting the brackets): you get the same result but consume less memory.
    The parentheses that indicate the function call also do “double duty” and enclose
    the genexp. Parentheses are, however, required when the genexp is not the sole
    argument. Additional parentheses don’t hurt, but are usually best omitted, for
    clarity.'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一个更简单的方式来编写特别简单的生成器：*生成器表达式*，通常称为*genexps*。genexp的语法与列表推导（如[“列表推导”](#list_comprehensions)中所述）完全相同，只是genexp在括号（()）内而不是方括号（[]）内。genexp的语义与对应的列表推导相同，只是genexp生成一个一次产生一个项目的迭代器，而列表推导则在内存中生成所有结果的列表（因此，在适当时使用genexp可以节省内存）。例如，要计算所有单个数字整数的平方和，你可以编写sum([x*x
    **for** x **in** range(10)])，但你可以更好地表达为sum(x*x **for** x **in** range(10))（完全相同，但省略了方括号）：你可以获得相同的结果但消耗更少的内存。指示函数调用的括号也“双重服务”并包含genexp。但是，当genexp不是唯一参数时，括号是必需的。额外的括号不会有害，但通常最好省略，以提高清晰度。
- en: Recursion
  id: totrans-935
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归
- en: Python supports recursion (i.e., a Python function can call itself, directly
    or indirectly), but there is a limit to how deep the recursion can go. By default,
    Python interrupts recursion and raises a RecursionLimitExceeded exception (covered
    in [“Standard Exception Classes”](ch06.xhtml#standard_exception_classe)) when
    it detects that recursion has exceeded a depth of 1,000\. You can change this
    default recursion limit by calling the setrecursionlimit function in the module
    sys, covered in [Table 8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod).
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持递归（即Python函数可以直接或间接地调用自身），但递归的深度有限制。默认情况下，Python在检测到递归深度超过1,000时中断递归并引发RecursionLimitExceeded异常（在[“标准异常类”](ch06.xhtml#standard_exception_classe)中介绍）。你可以通过在sys模块中调用setrecursionlimit函数来更改这个默认递归限制，如[表8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod)所述。
- en: Note that changing the recursion limit does not give you unlimited recursion.
    The absolute maximum limit depends on the platform on which your program is running,
    and particularly on the underlying operating system and C runtime library, but
    it’s typically a few thousand levels. If recursive calls get too deep, your program
    crashes. Such runaway recursion, after a call to setrecursionlimit that exceeds
    the platform’s capabilities, is one of the few things that can cause a Python
    program to crash—really crash, hard, without the usual safety net of Python’s
    exception mechanism. Therefore, beware of “fixing” a program that is getting RecursionLimitExceeded
    exceptions by raising the recursion limit with setrecursionlimit. While this *is*
    a valid technique, most often you’re better advised to look for ways to remove
    the recursion unless you are confident you’ve been able to limit the depth of
    recursion that your program needs.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 注意更改递归限制并不会让你无限递归。绝对最大限制取决于你的程序运行平台，特别是底层操作系统和C运行库，但通常是几千层。如果递归调用太深，你的程序会崩溃。当调用setrecursionlimit超出平台能力后，这种失控的递归是少数几个可以导致Python程序崩溃——真正的崩溃，没有Python异常机制的安全网之一。因此，小心通过提高递归限制来“修复”出现RecursionLimitExceeded异常的程序。虽然这*是*一种有效的技术，但通常建议你寻找方法消除递归，除非你确信已经能够限制程序所需的递归深度。
- en: 'Readers who are familiar with Lisp, Scheme, or functional programming languages
    must in particular be aware that Python does *not* implement the optimization
    of *tail-call elimination*, which is so crucial in those languages. In Python,
    any call, recursive or not, has the same “cost” in terms of both time and memory
    space, dependent only on the number of arguments: the cost does not change, whether
    the call is a “tail call” (meaning that it’s the last operation that the caller
    executes) or not. This makes recursion removal even more important.'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉 Lisp、Scheme 或函数式编程语言的读者特别需要注意，Python **不** 实现*尾递归消除*的优化，这在这些语言中非常关键。在 Python
    中，无论是递归调用还是非递归调用，都具有相同的时间和内存空间“成本”，仅依赖于参数的数量：调用是否是“尾调用”（即它是调用者执行的最后操作）并不会改变成本。这使得递归消除变得更加重要。
- en: 'For example, consider a classic use for recursion: walking a binary tree. Suppose
    you represent a binary tree structure as nodes, where each node is a three-item
    tuple (payload, left, right), and left and right are either similar tuples or
    **None**, representing the left-side and right-side descendants. A simple example
    might be (23, (42, (5, **None**, **None**), (55, **None**, **None**)), (94, **None**,
    **None**)) to represent the tree shown in [Figure 3-1](#an_example_of_a_binary_tree).'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑递归的经典用法：遍历二叉树。假设你将二叉树结构表示为节点，其中每个节点都是一个三项元组（有效载荷，左侧，右侧），左侧和右侧是类似的元组或**None**，表示左侧和右侧的后代。一个简单的示例可能是
    (23, (42, (5, **None**, **None**), (55, **None**, **None**)), (94, **None**, **None**))，用于表示图
    3-1 中显示的树。
- en: '![An example of a binary tree](assets/pns4_0301.png)'
  id: totrans-940
  prefs: []
  type: TYPE_IMG
  zh: '![一个二叉树的示例](assets/pns4_0301.png)'
- en: Figure 3-1\. An example of a binary tree
  id: totrans-941
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. 一个二叉树的示例
- en: 'To write a generator function that, given the root of such a tree, “walks”
    the tree, yielding each payload in top-down order, the simplest approach is recursion:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个生成器函数，给定这样一个树的根，逐步“遍历”树，按照自顶向下的顺序产生每个有效载荷，最简单的方法是递归：
- en: '[PRE187]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'But if a tree is very deep, recursion can become a problem. To remove recursion,
    we can handle our own stack—a list used in last-in, first-out (LIFO) fashion,
    thanks to its append and pop methods. To wit:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果树非常深，递归可能会成为一个问题。为了消除递归，我们可以处理自己的堆栈——一个按照后进先出（LIFO）方式使用的列表，感谢其附加和弹出方法。例如：
- en: '[PRE188]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: The only small issue to be careful about, to keep exactly the same order of
    **yield**s as rec, is switching the (1, 2) index order in which to examine descendants
    to (2, 1), adjusting to the “reversed” (last-in, first-out) behavior of stack.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意的唯一小问题是，为了保持与 rec 相同的**yield**顺序，需要调整 (1, 2) 索引顺序以检查后代，改为 (2, 1)，以适应堆栈的“反向”（后进先出）行为。
- en: ^([1](ch03.xhtml#ch01fn20-marker)) Identifiers referring to constants are all
    uppercase, by convention.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.xhtml#ch01fn20-marker)) 常规上，指向常量的标识符都是大写。
- en: ^([2](ch03.xhtml#ch01fn21-marker)) Control characters include nonprinting characters
    such as \t (tab) and \n (newline), both of which count as whitespace, and others
    such as \a (alarm, aka “beep”) and \b (backspace), which are not whitespace.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.xhtml#ch01fn21-marker)) 控制字符包括非打印字符，如 \t（制表符）和 \n（换行符），两者都算作空白字符，以及诸如
    \a（警告，也称“哔哔声”）和 \b（退格键），它们不是空白字符。
- en: ^([3](ch03.xhtml#ch01fn22-marker)) “Container displays,” per the [online docs](https://oreil.ly/mN_gv)
    (e.g., list_display), but specifically ones with literal items.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.xhtml#ch01fn22-marker)) 根据[在线文档](https://oreil.ly/mN_gv)中的描述，“容器显示”（例如
    list_display），但具体指包含字面项的显示。
- en: ^([4](ch03.xhtml#ch01fn23-marker)) There’s also a bytearray object, covered
    shortly, which is a bytes-like “string” that *is* mutable.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch03.xhtml#ch01fn23-marker)) 还有一个不久会涉及的 bytearray 对象，这是一个类似于字节的“字符串”，**是**可变的。
- en: ^([5](ch03.xhtml#ch01fn24-marker)) This syntax is sometimes called a “tuple
    display.”
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch03.xhtml#ch01fn24-marker)) 有时被称为“元组显示”的语法。
- en: ^([6](ch03.xhtml#ch01fn25-marker)) This syntax is sometimes called a “list display.”
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch03.xhtml#ch01fn25-marker)) 有时被称为“列表显示”的语法。
- en: ^([7](ch03.xhtml#ch01fn26-marker)) This syntax is sometimes called a “set display.”
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch03.xhtml#ch01fn26-marker)) 有时被称为“集合显示”的语法。
- en: '^([8](ch03.xhtml#ch01fn27-marker)) Each specific mapping type may put some
    constraints on the type of keys it accepts: in particular, dictionaries only accept
    hashable keys.'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch03.xhtml#ch01fn27-marker)) 每种特定的映射类型可能对其接受的键的类型有一些限制：特别是，字典仅接受可散列的键。
- en: ^([9](ch03.xhtml#ch01fn28-marker)) This syntax is sometimes called a “dictionary
    display.”
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch03.xhtml#ch01fn28-marker)) 有时被称为“字典显示”的语法。
- en: ^([10](ch03.xhtml#ch01fn29-marker)) See [“Shape, indexing, and slicing”](ch16.xhtml#shapecomma_indexingcomma_and_slicing).
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch03.xhtml#ch01fn29-marker)) 参见[“形状、索引和切片”](ch16.xhtml#shapecomma_indexingcomma_and_slicing)。
- en: '^([11](ch03.xhtml#ch01fn30-marker)) Strictly speaking, *almost* any: NumPy
    arrays, covered in [Chapter 16](ch16.xhtml#numeric_processing), are an exception.'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch03.xhtml#ch01fn30-marker)) 严格来说，*几乎*任何：NumPy数组，在[第16章](ch16.xhtml#numeric_processing)中有例外。
- en: ^([12](ch03.xhtml#ch01fn31-marker)) With exactly the same exception of NumPy
    arrays.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch03.xhtml#ch01fn31-marker)) 与NumPy数组完全相同的例外。
- en: ^([13](ch03.xhtml#ch01fn32-marker)) Sometimes referred to as the *ternary* operator,
    as it is so called in C (Python’s original implementation language).
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch03.xhtml#ch01fn32-marker)) 有时被称为*三元*操作符，在C语言（Python的原始实现语言）中也是如此称呼。
- en: ^([14](ch03.xhtml#ch01fn33-marker)) This is not, strictly speaking, the “coercion”
    you observe in other languages; however, among built-in numeric types, it produces
    pretty much the same effect.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch03.xhtml#ch01fn33-marker)) 严格来说，这不是您在其他语言中观察到的“强制转换”；然而，在内置的数字类型中，它产生几乎相同的效果。
- en: '^([15](ch03.xhtml#ch01fn34-marker)) Hence the upper limit of 36 for the radix:
    10 numeric digits plus 26 alphabetic characters.'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch03.xhtml#ch01fn34-marker)) 因此，36是基数的上限：10个数字加上26个字母字符。
- en: ^([16](ch03.xhtml#ch01fn35-marker)) The second item of divmod’s result, just
    like the result of %, is the *remainder*, not the *modulo*, despite the function’s
    misleading name. The difference matters when the divisor is negative. In some
    other languages, such as C# and JavaScript, the result of a % operator is, in
    fact, the modulo; in others yet, such as C and C++, it is machine-dependent whether
    the result is the modulo or the remainder when either operand is negative. In
    Python, it’s the remainder.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch03.xhtml#ch01fn35-marker)) divmod结果的第二项，就像%的结果一样，是*余数*，而不是*模*，尽管函数的命名可能会误导。这种差异在除数为负数时很重要。在一些其他语言中，如C#和JavaScript，%运算符的结果实际上是模；在其他语言中，如C和C++，当任一操作数为负时，结果是机器相关的。在Python中，是余数。
- en: ^([17](ch03.xhtml#ch01fn36-marker)) Timsort has the distinction of being the
    only sorting algorithm mentioned by the US Supreme Court, specifically in the
    case of [Oracle v. Google](https://oreil.ly/m-2JQ).
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch03.xhtml#ch01fn36-marker)) Timsort有一个独特之处，它是唯一被美国最高法院提及的排序算法，具体来说是在[Oracle
    v. Google](https://oreil.ly/m-2JQ)案件中。
- en: ^([18](ch03.xhtml#ch01fn37-marker)) Except, as already noted, a NumPy array
    with more than one element.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch03.xhtml#ch01fn37-marker)) 除了，正如已经指出的，具有多于一个元素的NumPy数组。
- en: ^([19](ch03.xhtml#ch01fn38-marker)) It is notable that the **match** statement
    specifically excludes matching values of type str, bytes, and bytearray with *sequence*
    patterns.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch03.xhtml#ch01fn38-marker)) 值得注意的是，**match**语句明确排除了与*序列*模式匹配的类型为str、bytes和bytearray的值。
- en: ^([20](ch03.xhtml#ch01fn39-marker)) Indeed, the syntax notation used in the
    Python online documentation required, and got, updates to concisely describe some
    of Python’s more recent syntax additions.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch03.xhtml#ch01fn39-marker)) 实际上，Python在线文档中使用的语法符号需要并且已经更新，以简洁地描述Python的一些较新的语法添加。
- en: ^([21](ch03.xhtml#ch01fn40-marker)) Although comparing float or complex numbers
    for exact equality is often dubious practice.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: ^([21](ch03.xhtml#ch01fn40-marker)) 尽管对于精确相等比较浮点数或复数通常是可疑的实践。
- en: ^([22](ch03.xhtml#ch01fn41-marker)) For this unique use case, it’s common to
    break the normal style conventions about starting class names with an uppercase
    letter and avoiding using semicolons to stash multiple assignments within one
    line; however, the authors haven’t yet found a style guide that blesses this peculiar,
    rather new usage.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: ^([22](ch03.xhtml#ch01fn41-marker)) 对于这种独特的使用情况，打破了关于以大写字母开头的类名和避免在一行中使用分号存储多个赋值的正常风格约定是常见的；然而，作者们尚未找到支持这种奇特且相对新的用法的风格指南。
- en: ^([23](ch03.xhtml#ch01fn42-marker)) And its subclasses, for example, collections.defaultdict.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: ^([23](ch03.xhtml#ch01fn42-marker)) 以及它的子类，例如collections.defaultdict。
- en: ^([24](ch03.xhtml#ch01fn43-marker)) Except that the loop variables’ scope is
    within the comprehension only, different from the way scoping works in a **for**
    statement.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: ^([24](ch03.xhtml#ch01fn43-marker)) 除了循环变量的作用域仅限于推导式内部，这与在**for**语句中作用域工作方式不同。
- en: ^([25](ch03.xhtml#ch01fn44-marker)) In that paper, Knuth also first proposed
    using “devices like indentation, rather than delimiters” to express program structure—just
    as Python does!
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: ^([25](ch03.xhtml#ch01fn44-marker)) 在那篇论文中，Knuth还首次提出使用“像缩进这样的设备，而不是分隔符”来表达程序结构——正如Python所做的！
- en: ^([26](ch03.xhtml#ch01fn45-marker)) “Alas” because they have nothing to do with
    Python keywords, so the terminology is confusing; if you use an actual Python
    keyword to name a named parameter, that raises SyntaxError.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: ^([26](ch03.xhtml#ch01fn45-marker)) “哎哟”，因为它们与Python关键字无关，所以术语很混乱；如果您使用实际的Python关键字来命名命名参数，会引发SyntaxError。
- en: ^([27](ch03.xhtml#ch01fn46-marker)) Python developers introduced positional-only
    arguments when they realized that parameters to many built-in functions effectively
    had no valid names as far as the interpreter was concerned.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: ^([27](ch03.xhtml#ch01fn46-marker)) 当Python开发人员意识到许多内置函数的参数在解释器看来实际上没有有效的名称时，他们引入了位置参数。
- en: ^([28](ch03.xhtml#ch01fn47-marker)) An “optional parameter” being one for which
    the function’s signature supplies a default value.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: ^([28](ch03.xhtml#ch01fn47-marker)) “可选参数”是指函数签名提供默认值的参数之一。
