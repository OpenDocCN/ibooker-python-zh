# 第一章：介绍健壮的 Python

这本书的重点是让你的 Python 代码更易管理。随着代码库的增长，你需要一套特定的技巧、诀窍和策略来构建可维护的代码。这本书将指导你减少 bug，让开发者更快乐。你将深入探讨自己编写代码的方式，并了解你的决策所带来的影响。在讨论代码编写方式时，我想起了 C.A.R. Hoare 的这些明智的话：

> 有两种构建软件设计的方法：一种是使它非常简单，以至于显然没有缺陷，另一种是使它非常复杂，以至于显然没有缺陷。第一种方法要困难得多。¹

这本书讨论的是第一种方式开发系统。是的，这会更加困难，但不要害怕。我将成为你在提升 Python 水平旅程中的向导，确保如 C.A.R. Hoare 所说，你的代码中显然没有缺陷。归根结底，这是一本关于编写*健壮*Python 的书籍。

在本章中，我们将讨论*健壮性*的含义以及你为何应关注它。我们将介绍你的沟通方式如何暗示某些利弊，并探讨最佳表示意图的方法。["Python 之禅"](https://oreil.ly/SHq8i)提到，在开发代码时，“应该有一种——最好只有一种——显而易见的方法来做到这一点。”你将学会如何评估你的代码是否以显而易见的方式编写，以及如何修复它。首先，我们需要解决基础问题。首先，*健壮性*究竟是什么？

# 健壮性

每本书至少需要一个字典定义，所以我会早早地把这个解决掉。Merriam-Webster 为[*健壮性*](https://oreil.ly/2skKO)提供了许多定义：

1.  具有力量或健壮的表现

1.  具有或显示活力、力量或坚定

1.  强壮的或建造的

1.  能够在广泛的条件下无故障运行

这些都是我们的目标的精彩描述。我们希望一个*健康*的系统，一个能够满足多年期望的系统。我们希望我们的软件*表现出力量*；显然，这段代码将经得起时间的考验。我们希望一个*坚固构建*的系统，一个建立在坚实基础上的系统。关键是，我们希望一个能够在没有故障的情况下运行的系统；随着变更的引入，系统不应变得脆弱。

人们通常把软件比作摩天大楼，一种伟大的结构，挺过所有变化，成为不朽的典范。不幸的是，事实更为复杂。软件系统不断演化。错误被修复，用户界面被调整，功能被添加、移除，然后重新添加。框架转变，组件过时，安全漏洞出现。软件在变化。开发软件更像是处理城市规划中的蔓延，而不是建造静态建筑。面对不断变化的代码库，如何使你的代码健壮？如何构建一个能抵御错误的坚固基础？

事实是，你必须接受变化。你的代码将被拆分，重新组合和重构。新的用例将改变大片代码——这是可以接受的。拥抱变化。明白你的代码可以轻易改变是不够的；最好的情况可能是它被删除并重写，因为它过时了。这并不会减少其价值；它仍然可以在聚光灯下有很长的寿命。你的任务是使系统的部分易于重写。一旦你开始接受你的代码的短暂性，你就开始意识到，为现在编写无 BUG 的代码是不够的；你需要让代码库的未来所有者能够有信心地修改你的代码。这就是本书的内容所在。

你将学会构建强大的系统。这种强度不是来自于铁块那种僵化的展示。它来自于灵活性。你的代码需要像一棵高大的柳树一样强壮，能在风中摇曳，灵活但不易折断。你的软件需要处理你从未梦到的情况。你的代码库需要能够适应新的环境，因为不总是你来维护它。未来的维护者需要知道他们在一个健康的代码库中工作。你的代码库需要传达其强度。你必须以一种方式编写 Python 代码，以减少失败，即使未来的维护者在拆解和重构它。

写健壮的代码意味着深思熟虑未来。你希望未来的维护者看着你的代码能轻松理解你的意图，而不是在深夜调试时咒骂你的名字。你必须传达你的思想、推理和警告。未来的开发者需要把你的代码弯成新的形状，并且希望这样做时不用担心每次修改都可能像摇摇欲坠的纸牌房屋一样崩溃。

简而言之，你不希望系统失败，尤其是在发生意外情况时。测试和质量保证在其中占据重要地位，但它们都不能完全保证质量。它们更适合揭示期望中的差距并提供安全网。相反，你必须让你的软件经得起时间的考验。为了做到这一点，你必须编写*清晰且易于维护*的代码。

清晰的代码按照顺序清晰而简洁地表达其意图。当你看着一行代码对自己说，“啊，这完全讲得通”，这就是清晰代码的指标。你越要通过调试器逐步执行，越要查看大量其他代码以弄清发生了什么，越要停下来盯着代码看，代码就越不清晰。清晰的代码不会因为巧妙的技巧而使其他开发人员无法阅读。就像 C.A.R. Hoare 之前说的那样，你不希望使你的代码如此晦涩，以至于仅凭视觉检查就难以理解。

可维护的代码是能够轻松维护的代码。维护从第一个提交开始，并持续到没有一个开发人员再看项目为止。开发人员将修复错误，添加功能，阅读代码，提取代码以供在其他库中使用等。可维护的代码使这些任务变得无摩擦。软件生命周期长达数年，甚至数十年。今天就专注于您的可维护性吧。

无论你是积极参与工作还是不参与，你都不希望成为系统失败的原因。你需要积极主动地让你的系统经得起时间的考验。你需要一个测试策略来作为你的安全网，但你也需要能够在第一时间避免掉入。因此，考虑到这一切，我提出了我对代码库稳健性的定义：

> 稳健的代码库在不断变化中仍然是弹性和无错误的。

## 为什么健壮性很重要？

让软件按照预期运行需要花费大量精力，但是很难确定何时才算完成。开发里程碑不容易预测。人为因素，如用户体验、可访问性和文档，只会增加复杂性。现在加入测试以确保您覆盖了已知和未知行为的片段，您将面临漫长的开发周期。

软件的目的是提供价值。每个利益相关者都有兴趣尽早交付这些价值。鉴于某些开发进度的不确定性，往往会增加满足期望的压力。我们都曾经历过不切实际的进度表或截止日期的反面。不幸的是，许多增强软件健壮性的工具只会在短期内增加我们的开发周期。

的确，在即时交付价值和编写健壮代码之间存在固有的紧张关系。如果你的软件“足够好”，为什么还要增加更多复杂性呢？为了回答这个问题，考虑那段软件将被迭代多少次。提供软件价值通常不是一个静态的过程；一个系统提供价值且永不修改的情况是罕见的。软件本质上是不断发展的。代码库需要准备好在长时间内频繁地提供价值。这就是健壮软件工程实践发挥作用的地方。如果你无法快速无损地交付功能，你需要重新评估技术，使你的代码更易维护。

如果你推迟或破坏你的系统，你会产生实时成本。仔细思考你的代码库。问问自己，如果你的代码一年后由于有人无法理解而出现问题会怎么样。你会损失多少价值？你的价值可能以金钱、时间，甚至生命来衡量。问问自己，如果价值不能按时交付会发生什么？会有什么后果？如果这些问题的答案让人感到害怕，好消息是，你正在做有价值的工作。但这也强调了消除未来错误的重要性。

多个开发人员同时在同一代码库上工作。许多软件项目将超过大多数开发人员的寿命。你需要找到一种方式与现在和未来的开发人员沟通，而不依赖于当面解释的好处。未来的开发人员将根据*你*的决策进行构建。每一个错误的路径，每一个兔子洞，以及每一个 Yak-shaving²冒险都会减慢他们的速度，从而阻碍价值的实现。你需要为那些接替你工作的人们感到同情。你需要站在他们的角度思考。这本书是你思考协作者和维护者的入口。你需要考虑可持续的工程实践。你需要编写持久的代码。制造持久代码的第一步是通过你的代码进行沟通。你需要确保未来的开发人员理解你的意图。

# 你的意图是什么？

为什么你应该努力编写清晰和可维护的代码？为什么你应该如此关注健壮性？这些答案的核心在于沟通。你不是在交付静态系统。代码将继续变化。你还必须考虑维护者随时间变化。在编写代码时，你的目标是提供价值。你还要以一种能让其他开发人员同样快速提供价值的方式编写代码。为了做到这一点，你需要能够在未来维护者没有见面的情况下沟通推理和意图。

让我们看看一个在假设的传统系统中找到的代码块。我希望你估计一下你理解这段代码所需的时间。如果你对这里的所有概念不熟悉，或者觉得这段代码很复杂（这是有意的！），也没关系。

```py
# Take a meal recipe and change the number of servings
# by adjusting each ingredient
# A recipe's first element is the number of servings, and the remainder
# of elements is (name, amount, unit), such as ("flour", 1.5, "cup")
def adjust_recipe(recipe, servings):
    new_recipe = [servings]
    old_servings = recipe[0]
    factor = servings / old_servings
    recipe.pop(0)
    while recipe:
        ingredient, amount, unit = recipe.pop(0)
        # please only use numbers that will be easily measurable
        new_recipe.append((ingredient, amount * factor, unit))
    return new_recipe
```

此函数接受一个食谱，并调整每个成分以处理新的份数。然而，这段代码引发了许多问题。

+   `pop`是干什么用的？

+   `recipe[0]`代表什么？为什么是旧的分量？

+   为什么我需要为可轻松测量的数字添加注释？

这确实是有些值得商榷的 Python 代码。如果你觉得有必要重写它，我不会责怪你。像这样写起来看起来好多了：

```py
def adjust_recipe(recipe, servings):
    old_servings = recipe.pop(0)
    factor = servings / old_servings
    new_recipe = {ingredient: (amount*factor, unit)
                  for ingredient, amount, unit in recipe}
    new_recipe["servings"] = servings
    return new_recipe
```

喜欢整洁代码的人可能更喜欢第二个版本（我肯定是这样）。没有原始循环。变量不变异。我返回一个字典而不是元组列表。根据情况，所有这些变化都可以看作是积极的。但我可能刚刚引入了三个微妙的错误。

+   在原始代码片段中，我清理了原始食谱。现在我没有了。即使只有一个区域的调用代码依赖于这种行为，我也破坏了该调用代码的假设。

+   通过返回一个字典，我已经删除了在列表中具有重复成分的能力。这可能会影响那些使用同一成分的多个部分（如主菜和酱料）的食谱。

+   如果任何成分都被命名为“servings”，我刚刚引入了与命名冲突。

这些是否是错误取决于两个相互关联的事情：原始作者的意图和调用代码。作者打算解决一个问题，但我不确定他们为什么以这种方式编写代码。他们为什么弹出元素？为什么“servings”是列表内的元组？为什么使用列表？据推测，原始作者知道原因，并在本地向同事传达了。他们的同事根据这些假设编写了调用代码，但随着时间的推移，这种意图变得模糊了。在没有向未来传达信息的情况下，我只能有两种选择来维护这段代码：

+   查看所有调用代码，并确认在实施之前，这种行为并不依赖于它。如果这是一个带有外部调用者的库的公共 API，祝你好运。我会花很多时间来做这件事情，这会让我很沮丧。

+   进行更改并等待看看结果如何（客户投诉、测试失败等）。如果我幸运的话，不会发生什么不好的事情。如果不幸的话，我会花很多时间来修复用例，这会让我很沮丧。

在维护设置中，这两种选项都不太高效（尤其是如果我必须修改这段代码）。我不想浪费时间；我希望快速处理当前任务并继续下一个任务。如果考虑如何调用这段代码，情况会变得更糟。想想你如何与之前从未见过的代码互动。你可能看到其他调用代码的示例，将它们复制以适应你的用例，并且从未意识到你需要将一个名为“servings”的特定字符串作为列表的第一个元素传递。

这些是会让你感到困惑的决策。我们在更大的代码库中都见过它们。它们并非出于恶意编写，而是随着时间的推移和多个开发者的贡献而有机地形成。函数起初很简单，但随着用例的增长，那些代码往往会变形并且遮蔽原始意图。这明显表明可维护性正在受到影响。你需要在代码开发初期表达出你的意图。

那么，如果原始作者使用了更好的命名模式和更好的类型使用，那么代码会是什么样子呢？

```py
def adjust_recipe(recipe, servings):
    """
 Take a meal recipe and change the number of servings
 :param recipe: a `Recipe` indicating what needs to be adusted
 :param servings: the number of servings
 :return Recipe: a recipe with serving size and ingredients adjusted
 for the new servings
 """
    # create a copy of the ingredients
    new_ingredients = list(recipe.get_ingredients())
    recipe.clear_ingredients()

    for ingredient in new_ingredients:
            ingredient.adjust_propoprtion(Fraction(servings, recipe.servings))
    return Recipe(servings, new_ingredients)
```

这看起来好多了，文档化更好，明确表达了原始意图。原始开发者直接将他们的想法编码到了代码中。从这段代码片段中，你知道以下内容是正确的：

+   我正在使用 `Recipe` 类。这使我能够抽象出某些操作。可以假定，在类内部有一个不变量，允许存在重复的成分。（关于类和不变量，我会在第十章详细讲解。）这提供了一个通用词汇，使函数的行为更加明确。

+   现在，份量已经成为 `Recipe` 类的显式部分，而不需要作为列表的第一个元素处理，这作为一种特殊情况。这大大简化了调用代码，并防止了意外冲突。

+   很明显，我想要清除旧食谱上的成分。没有模棱两可的原因，我需要执行 `.pop(0)`。

+   成分是一个单独的类，并且处理 [fractions](https://oreil.ly/YxUHK) 而不是显式的 `float`。这对所有参与者更清晰，我在处理分数单位时可以轻松执行 `limit_denominator()`，当人们想要限制计量单位时可以调用该方法（而不是依赖于注释）。

我已经用类型替换了变量，比如食谱类型和成分类型。我还定义了操作（`clear_ingredients`，`adjust_proportion`）来传达我的意图。通过做出这些改变，我已经让代码的行为对未来的读者非常清晰。他们不再需要来找我以理解这段代码。相反，他们理解我在做什么而不必与我交流。这就是*异步通信*的最佳体现。

## 异步通信

在 Python 书中写关于异步通信而不提及`async`和`await`感觉有些奇怪。但我不得不在一个更复杂的地方——*现实世界*中讨论异步通信。

异步沟通意味着生产信息和消费信息是相互独立的。在生产和消费之间存在时间间隔。这可能是几小时，就像处于不同时区的合作者的情况。或者可能是多年，未来的维护者试图深入了解代码的内部工作原理。你无法预测某人何时需要理解你的逻辑。甚至在他们消费信息时，你可能已经不再从事那个代码库（或那家公司）的工作。

与之形成对比的是*同步沟通*。同步沟通是实时交换想法。这种直接沟通是表达思想的最佳方式之一，但不幸的是，它缺乏可扩展性，你并不总是能在那儿回答问题。

为了评估每种沟通方法在试图理解意图时的适用性，让我们看看两个轴：亲近度和成本。

*亲近度*是沟通者在时间上需要多么接近才能使沟通富有成效。某些沟通方法在实时传递信息方面表现出色，而其他方法则在多年后传播信息方面表现出色。

*成本*是沟通所需的努力的度量。你必须权衡花费时间和金钱来沟通所提供的价值。然后，你的未来消费者必须权衡消费信息的成本与他们试图提供的价值。编写代码并没有提供任何其他沟通渠道是你的基准；你必须这样做来产生价值。为了评估额外沟通渠道的成本，我考虑以下因素：

可发现性

在正常工作流程之外查找这些信息有多容易？知识有多短暂？搜索信息容易吗？

维护成本

信息的准确性如何？更新频率如何？如果信息过时会出现什么问题？

生产成本

制作沟通所花费的时间和金钱有多少？

在图 1-1 中，我根据自己的经验绘制了一些常见沟通方法的成本和所需亲近度。

###### 图 1-1\. 绘制沟通方法的成本和亲近度

组成成本/亲近度图的四个象限。

低成本，高亲近度需求

这些虽然便宜易于生产和消费，但在时间上不具有可扩展性。直接沟通和即时通讯是这些方法的典型例子。把它们视为时间点上的信息快照；只有用户在积极倾听时，它们才有价值。不要依赖这些方法来传达给未来。

高成本，高亲近度需求

这些是昂贵的事件，并且通常只发生一次（如会议或会议）。这些事件在沟通时应提供大量价值，因为它们对未来的价值贡献不大。你参加过多少次觉得浪费时间的会议？你正在感受到直接的价值损失。每个参与者都需要支付多重成本（时间花费、主办空间、后勤等）。代码审查完成后很少被查看。

成本高，所需接近度低

这些是昂贵的，但随着时间的推移，可以通过提供的价值来回报成本，因为所需的接近度较低。电子邮件和敏捷看板包含大量信息，但他人无法发现。这些适合不需要经常更新的大概念。试图筛选出你寻找的信息之前必须经历噪音的噩梦。视频录像和设计文档适合了解某一时刻的快照，但更新成本高昂。不要依赖这些沟通方法来理解日常决策。

成本低，所需接近度低

这些内容易于创建，并且易于消费。代码注释、版本控制历史和项目 README 都属于此类，因为它们与我们编写的源代码相邻。用户可以在数年后查看这些通信内容。开发者在日常工作流程中遇到的任何内容都是可以发现的。这些沟通方法自然适合作为源代码之后某人首先查看的地方。然而，你的代码是你最好的文档工具之一，因为它是系统的生动记录和唯一真相来源。

# 讨论主题

这个图表在图 1-1 中基于一般化的使用案例创建。考虑你和你的组织使用的沟通路径。你会在图表上的哪个位置标出它们？消费准确信息有多容易？制造信息有多昂贵？这些问题的答案可能导致略有不同的图表，但真相的单一来源将在您交付的可执行软件中。

成本低，所需接近度低的沟通方法是向未来沟通的最佳工具。你应该努力将生产成本和沟通消费成本最小化。无论如何，你都必须编写软件来提供价值，因此最低成本的选项是将你的代码作为主要沟通工具。你的代码库成为清晰表达你的决策、观点和解决方法的最佳选择。

然而，为了使这个断言成立，代码也必须很容易消耗。你的意图必须清晰地在你的代码中表达出来。你的目标是尽量减少读者理解代码所需的时间。理想情况下，读者不需要阅读你的实现，只需阅读你的函数签名。通过使用良好的类型、注释和变量名，你的代码应该清晰地表明你的代码是做什么的。

# Python 中的意图示例

现在我已经讲解了意图是什么以及它的重要性，让我们通过 Python 的视角看一些示例。你如何确保你正确地表达了你的意图？我将看两个不同的决策如何影响意图的示例：集合和迭代。

## 集合

当你选择一个集合时，你正在传达特定的信息。你必须为手头的任务选择正确的集合。否则，维护人员将从你的代码中推断出错误的意图。

考虑这段代码，它接受一系列烹饪书，并提供了作者和书籍数量之间的映射：

```py
def create_author_count_mapping(cookbooks: list[Cookbook]):
    counter = {}
    for cookbook in cookbooks:
        if cookbook.author not in counter:
            counter[cookbook.author] = 0
        counter[cookbook.author] += 1
    return counter
```

我对集合的使用告诉了你什么？为什么我不传递一个字典或一个集合？为什么我不返回一个列表？根据我对集合的当前使用，你可以假设：

+   我传入了一系列烹饪书。这个列表中可能有重复的烹饪书（我可能正在数一家商店里有多本副本的烹饪书架）。

+   我正在返回一个字典。用户可以查找特定的作者，或者遍历整个字典。我不必担心返回集合中的重复作者。

如果我想传达的是这个函数不应该传入重复的内容怎么办？一个列表传达了错误的意图。相反，我应该选择一个集合来表明这段代码绝对不会处理重复项。

选择一个集合告诉读者你的具体意图。下面是一些常见集合类型及其传达的意图的列表：

列表

这是一个可迭代的集合。它是*可变*的：可以随时更改。你几乎不会指望从列表中间检索特定的元素（使用静态列表索引）。可能会有重复的元素。书架上的烹饪书可能会被存储在一个列表中。

字符串

一个不可变的字符集合。一本烹饪书的名称将是一个字符串。

生成器

一个可迭代的集合，永远不会被索引。每个元素访问都是惰性执行的，所以每次循环迭代可能需要时间和/或资源。它们非常适合计算昂贵或无限的集合。一个在线的菜谱数据库可能会被返回为生成器；当用户只查看搜索结果的前 10 个结果时，你不希望获取世界上所有的菜谱。

元组

一个不可变的集合。你不希望它改变，因此更有可能从元组的中间提取特定元素（通过索引或解包）。很少会迭代它。关于特定菜谱的信息可能以元组的形式表示，如`(cookbook_name, author, pagecount)`。

集合

一个可迭代的集合，不包含重复项。您不能依赖元素的顺序。菜谱中的食材可能以集合的形式存储。

字典

从键到值的映射。字典中的键在整个字典中是唯一的。通常会迭代字典，或者使用动态键索引进入。菜谱索引是一个很好的键到值映射的例子（从主题到页码）。

不要为你的目的使用错误的集合。我太多次看到应该没有重复项的列表或者实际上并没有被用来映射键值对的字典。每当你的意图与代码不一致时，你就会创建维护负担。维护者必须停下来，弄清楚你实际上想表达的是什么，然后围绕他们错误的假设（还有你的错误假设）进行工作。

这些是基本集合，但还有更多表达意图的方法。以下是一些特殊的集合类型，它们在向未来传达意图方面更具表现力：

`frozenset`

一个不可变的集合。

`OrderedDict`

一个根据插入时间保留元素顺序的字典。截至到 CPython 3.6 和 Python 3.7，内置字典也会根据插入时间保留元素的顺序。

`defaultdict`

一个字典，如果键缺失则提供默认值。例如，我可以将我之前的例子重写如下：

```py
from collections import defaultdict
def create_author_count_mapping(cookbooks: List[Cookbook]):
    counter = defaultdict(lambda: 0)
    for cookbook in cookbooks:
        counter[cookbook.author] += 1
    return counter
```

这为最终用户引入了一种新的行为 —— 如果他们查询字典中不存在的值，他们将收到一个 0。这在某些情况下可能是有益的，但如果不是的话，你可以只返回`dict(counter)`。

`Counter`

一种特殊的字典类型，用于计算元素出现的次数。这极大地简化了我们上面的代码为以下形式：

```py
from collections import Counter
def create_author_count_mapping(cookbooks: List[Cookbook]):
    return Counter(book.author for book in cookbooks)
```

花点时间反思一下最后一个例子。注意使用`Counter`如何使我们的代码更加简洁，而不会牺牲可读性。如果读者熟悉`Counter`，这个函数的含义（以及实现方式）就会立即显而易见。这是通过更好地选择集合类型向未来传达意图的一个很好的例子。我将在第五章进一步探讨集合。

还有许多其他类型可以探索，包括`array`、`bytes`和`range`。无论何时遇到一个新的集合类型，无论是内置的还是其他类型，都要问问自己它与其他集合有何不同，以及它向未来的读者传达了什么。

## 迭代

迭代是另一个例子，抽象你选择的决定了你传达的意图。

你多少次见过这样的代码？

```py
text = "This is some generic text"
index = 0
while index < len(text):
    print(text[index])
    index += 1
```

这段简单的代码将每个字符打印在单独的一行上。对于这个问题的 Python 初步解决方案来说，这是完全可以接受的，但解决方案很快就会演变为更*Pythonic*（用惯用风格编写的代码，旨在强调简洁并且对大多数 Python 开发人员来说是可识别的）：

```py
for character in text:
    print(character)
```

请花一点时间思考为什么这个选项更可取。`for`循环是一个更合适的选择；它更清晰地传达了意图。就像集合类型一样，您选择的循环结构明确地传达了不同的概念。以下是一些常见的循环结构及其传达的概念：

`for` 循环

`for` 循环用于遍历集合或范围中的每个元素，并执行操作/副作用。

```py
for cookbook in cookbooks:
    print(cookbook)
```

`while` 循环

`while` 循环用于在某个条件为真时进行迭代。

```py
while is_cookbook_open(cookbook):
    narrate(cookbook)
```

推导式

推导式用于将一个集合转换为另一个集合（通常情况下，这不会产生副作用，特别是如果推导是惰性的）。

```py
authors = [cookbook.author for cookbook in cookbooks]
```

递归

当集合的子结构与集合的结构相同时（例如，树的每个子节点也是一棵树），就会使用递归。

```py
def list_ingredients(item):
    if isinstance(item, PreparedIngredient):
        list_ingredients(item)
    else:
        print(ingredient)
```

您希望代码库的每一行都能提供价值。此外，您希望每一行都能清晰地向未来的开发人员传达这个价值是什么。这驱使我们需要尽量减少任何样板代码、脚手架和多余的代码。在上面的示例中，我正在遍历每个元素并执行一个副作用（打印一个元素），这使得`for`循环成为一个理想的循环结构。我没有浪费代码。相比之下，`while`循环要求我们明确跟踪循环，直到某个特定条件发生为止。换句话说，我需要追踪一个特定的条件，并在每次迭代时改变一个变量。这会分散注意力，增加不必要的认知负担。

## 最小惊奇法则

从意图中分散注意力是不好的，但有一类通信更糟糕：当代码主动让您未来的协作者感到惊讶时。您希望遵循*最小惊奇法则*；当某人阅读代码库时，他们几乎不应该对行为或实现感到惊讶（当他们感到惊讶时，附近应该有一个很好的注释来解释为什么是这样）。这就是为什么传达意图至关重要。清晰、干净的代码降低了误传的可能性。

###### 注意

*最小惊奇法则*，也称为*最小惊讶法则*，规定程序应该以最少让用户惊讶的方式响应用户。令人惊讶的行为会导致混淆。混淆会导致错误的假设。错误的假设会导致错误。这就是如何得到不可靠的软件。

请记住，您可以编写完全正确的代码，但将来仍会令某人感到惊讶。在我职业生涯早期，我曾经追踪过一个由于内存损坏而导致崩溃的恶心错误。通过调试器或添加太多打印语句会影响时序，使得错误不会显现出来（真正的“海森堡”现象）。⁴ 与此问题相关的代码行数多达数千行。

因此，我不得不手动进行二分，将代码一分为二，看看哪一半实际上有崩溃，通过删除另一半再次执行此操作。在抓狂两周之后，我最终决定检查一个听起来无害的函数 `getEvent`。结果发现，这个函数实际上是在用无效数据 *设置* 一个事件。毫无疑问，我感到非常惊讶。这个函数在执行它的功能时完全正确，但因为我忽视了代码的意图，至少有三天我都没有注意到这个错误。惊讶会浪费您协作者的时间。

这种惊讶大多来自复杂性。复杂性有两种类型：*必要复杂性* 和 *偶发复杂性*。必要复杂性是您领域内在的复杂性。深度学习模型必然复杂；不是您能在几分钟内浏览其内部工作原理就能理解的东西。优化对象关系映射（ORM）必然复杂；必须考虑大量可能的用户输入。您无法消除必要复杂性，所以最好的选择是试图将其限制在一定范围内，以免蔓延到代码库中，最终变成偶发复杂性。

相反，偶发复杂性是代码中产生多余、浪费或混淆语句的复杂性。这种情况发生在系统随时间演变，开发者不断添加功能而不重新评估旧代码是否仍然有效时。我曾经参与过一个项目，其中添加一个单一的命令行选项（及其相关的程序设置）影响到了至少 10 个文件。为什么添加一个简单的值需要在整个代码库中进行更改呢？

如果您曾经经历以下情况，则说明您有偶发复杂性：

+   看起来简单的事情（例如添加用户、更改 UI 控件等）实际上并不容易实现。

+   难以使新开发者理解您的代码库入职困难。项目中的新开发者是评估当前代码可维护性的最佳指标 —— 无需等待多年。

+   添加功能的估算总是很高，然而您仍然会超时。

尽可能消除意外复杂性，并将必要的复杂性隔离开来。这些将成为未来合作者的绊脚石。这些复杂性的来源会加剧沟通不畅，因为它们会在代码库中模糊和扩散意图。

# 讨论主题

在你的代码库中有哪些意外复杂性？如果你被丢到没有与其他开发者沟通的代码库中，理解简单的概念会有多大挑战？在本练习中，你能做些什么来简化识别出的复杂性（特别是它们经常变化的代码中）？

在本书的其余部分，我将探讨在 Python 中传达意图的不同技术。

# 结语

强大的代码很重要。清晰的代码很重要。你的代码需要在整个代码库的生命周期内都能够维护，为了确保这一点，你需要在你所传达的内容和方式上投入积极的前瞻性。你需要尽可能清晰地体现你的知识。不断朝前看可能会感到负担，但通过实践，这会变得自然，并且你开始在自己的代码库中享受成果。

每当你将现实世界的概念映射到代码时，你都在创建一个抽象，无论是通过使用集合还是决定保持函数分离。每个抽象都是一个选择，每个选择都传达着某种信息，无论是有意还是无意的。我鼓励你思考每一行代码你正在写的内容，并问自己，“未来的开发者会从中学到什么？”你有责任让未来的维护者能够以与你今天相同的速度交付价值。否则，你的代码库将变得臃肿，进度将滑坡，复杂性将增加。作为开发者，你的工作就是减少这种风险。

寻找潜在的热点，比如不正确的抽象（如集合或迭代），或意外的复杂性。这些是随着时间推移可能导致沟通中断的主要区域。如果这些热点位于经常变化的区域，现在就应该优先处理。

在下一章中，你将会将本章学到的内容应用到一个基本的 Python 概念中：类型。你选择的类型表达了你对未来开发者的意图，选择正确的类型将有助于提高可维护性。

¹ 查尔斯·安东尼·理查德·霍尔。"皇帝的旧衣服"。*Commun. ACM* 24, 2 (1981 年 2 月), 75–83\. [*https://doi.org/10.1145/358549.358561*](https://doi.org/10.1145/358549.358561)。

² "Yak-shaving" 描述了一种情况，即在解决原始问题之前，你经常不得不解决不相关的问题。你可以在 [*https://oreil.ly/4iZm7*](https://oreil.ly/4iZm7) 了解这个术语的起源。

³ Geoffrey James。*程序设计之道*。[*https://oreil.ly/NcKNK*](https://oreil.ly/NcKNK)。

⁴ 当被观察时显示不同行为的一个 bug。*SIGSOFT ’83: ACM SIGSOFT/SIGPLAN 软件工程高级调试研讨会论文集*。
