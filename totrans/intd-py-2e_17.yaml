- en: 'Chapter 15\. Data in Time: Processes and Concurrency'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章\. 时间上的数据：进程与并发
- en: One thing a computer can do that most humans can’t is be sealed up in a cardboard
    box and sit in a warehouse.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算机可以做的一件事情是被密封在纸板箱中并坐在仓库里，这是大多数人类做不到的。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Jack Handey
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Jack Handey
- en: This chapter and the next two are a bit more challenging than earlier ones.
    In this one we cover data in time (sequential and concurrent access on a single
    computer), and following that we look at data in a box (storage and retrieval
    with special files and databases) in [Chapter 16](ch16.html#ch_databases) and
    then data in space (networking) in [Chapter 17](ch17.html#ch_networks).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章和接下来的两章比之前的内容稍微有些挑战。在这一章中，我们涵盖了时间上的数据（在单台计算机上的顺序访问和并发访问），接着我们将在[第16章](ch16.html#ch_databases)中讨论盒子中的数据（特殊文件和数据库的存储和检索），然后在[第17章](ch17.html#ch_networks)中讨论空间中的数据（网络）。
- en: Programs and Processes
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序与进程
- en: When you run an individual program, your operating system creates a single *process*.
    It uses system resources (CPU, memory, disk space) and data structures in the
    operating system’s *kernel* (file and network connections, usage statistics, and
    so on). A process is isolated from other processes—it can’t see what other processes
    are doing or interfere with them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行一个单独的程序时，操作系统会创建一个单独的*进程*。它使用系统资源（CPU、内存、磁盘空间）和操作系统内核中的数据结构（文件和网络连接、使用统计等）。进程与其他进程隔离——它不能看到其他进程在做什么或者干扰它们。
- en: The operating system keeps track of all the running processes, giving each a
    little time to run and then switching to another, with the twin goals of spreading
    the work around fairly and being responsive to the user. You can see the state
    of your processes with graphical interfaces such as the Mac’s Activity Monitor
    (macOS), Task Manager on Windows-based computers, or the `top` command in Linux.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统会跟踪所有正在运行的进程，为每个进程分配一点运行时间，然后切换到另一个进程，以实现公平地分配工作和对用户响应迅速的双重目标。您可以通过图形界面（如
    macOS 的活动监视器、Windows 计算机上的任务管理器或 Linux 中的`top`命令）查看进程的状态。
- en: 'You can also access process data from your own programs. The standard library’s
    `os` module provides a common way of accessing some system information. For instance,
    the following functions get the *process ID* and the *current working directory*
    of the running Python interpreter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从自己的程序中访问进程数据。标准库的`os`模块提供了一种常见的访问某些系统信息的方式。例如，以下函数获取运行中 Python 解释器的*进程
    ID*和*当前工作目录*：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And these get my *user ID* and *group ID*:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些获取*用户 ID*和*组 ID*：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create a Process with subprocess
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用子进程创建进程
- en: 'All of the programs that you’ve seen here so far have been individual processes.
    You can start and stop other existing programs from Python by using the standard
    library’s `subprocess` module. If you just want to run another program in a shell
    and grab whatever output it created (both standard output and standard error output),
    use the `getoutput()` function. Here, we get the output of the Unix `date` program:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你所见过的所有程序都是单独的进程。您可以使用标准库的`subprocess`模块从 Python 启动和停止其他已经存在的程序。如果只想在
    shell 中运行另一个程序并获取其生成的所有输出（标准输出和标准错误输出），请使用`getoutput()`函数。在这里，我们获取 Unix 的`date`程序的输出：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You won’t get anything back until the process ends. If you need to call something
    that might take a lot of time, see the discussion on *concurrency* in [“Concurrency”](#concurrency).
    Because the argument to `getoutput()` is a string representing a complete shell
    command, you can include arguments, pipes, `<` and `>` I/O redirection, and so
    on:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程结束之前，您将得不到任何返回。如果需要调用可能需要很多时间的内容，请参阅[“并发”](#concurrency)中关于*并发*的讨论。由于`getoutput()`的参数是表示完整
    shell 命令的字符串，因此可以包括参数、管道、`<` 和 `>` 的 I/O 重定向等：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Piping that output string to the `wc` command counts one line, six “words,”
    and 29 characters:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将该输出字符串管道传递给`wc`命令计数一行、六个“单词”和29个字符：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A variant method called `check_output()` takes a list of the command and arguments.
    By default it returns standard output only as type bytes rather than a string,
    and does not use the shell:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 变体方法称为`check_output()`接受命令和参数列表。默认情况下，它只返回标准输出作为字节类型而不是字符串，并且不使用 shell：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To show the exit status of the other program, `getstatusoutput()` returns a
    tuple with the status code and output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示其他程序的退出状态，`getstatusoutput()`返回一个包含状态代码和输出的元组：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you don’t want to capture the output but might want to know its exit status,
    use `call()`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想捕获输出但可能想知道其退出状态，请使用`call()`：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: (In Unix-like systems, `0` is usually the exit status for success.)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: （在类 Unix 系统中，`0` 通常是成功的退出状态。）
- en: That date and time was printed to output but not captured within our program.
    So, we saved the return code as `ret`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那个日期和时间被打印到输出中，但没有在我们的程序中捕获。因此，我们将返回代码保存为 `ret`。
- en: 'You can run programs with arguments in two ways. The first is to specify them
    in a single string. Our sample command is `date -u`, which prints the current
    date and time in UTC:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以两种方式运行带参数的程序。第一种是在一个字符串中指定它们。我们的示例命令是 `date -u`，它会打印当前的日期和时间（协调世界时）：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You need that `shell=True` to recognize the command line `date -u`, splitting
    it into separate strings and possibly expanding any wildcard characters such as
    `*` (we didn’t use any in this example).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要 `shell=True` 来识别命令行 `date -u`，将其拆分为单独的字符串，并可能扩展任何通配符字符，比如 `*`（在这个示例中我们没有使用任何通配符）。
- en: 'The second method makes a list of the arguments, so it doesn’t need to call
    the shell:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是将参数列表化，因此不需要调用 shell：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create a Process with multiprocessing
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 multiprocessing 创建一个进程
- en: 'You can run a Python function as a separate process, or even create multiple
    independent processes with the `multiprocessing` module. The sample code in [Example 15-1](#ch15_ex01)
    is short and simple; save it as *mp.py* and then run it by typing `python mp.py`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将一个 Python 函数作为一个独立的进程运行，甚至使用 `multiprocessing` 模块创建多个独立的进程。[示例 15-1](#ch15_ex01)
    中的示例代码简短而简单；将其保存为 *mp.py*，然后通过输入 `python mp.py` 运行它：
- en: Example 15-1\. mp.py
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-1\. mp.py
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When I run this, my output looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这个时，我的输出看起来像这样：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Process()` function spawned a new process and ran the `do_this()` function
    in it. Because we did this in a loop that had four passes, we generated four new
    processes that executed `do_this()` and then exited.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Process()` 函数生成了一个新进程，并在其中运行 `do_this()` 函数。因为我们在一个有四次循环的循环中执行了这个操作，所以我们生成了四个执行
    `do_this()` 然后退出的新进程。'
- en: The `multiprocessing` module has more bells and whistles than a clown on a calliope.
    It’s really intended for those times when you need to farm out some task to multiple
    processes to save overall time; for example, downloading web pages for scraping,
    resizing images, and so on. It includes ways to queue tasks, enable intercommunication
    among processes, and wait for all the processes to finish. [“Concurrency”](#concurrency)
    delves into some of these details.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing` 模块比一个喜剧团的小丑还要多。它真的是为那些需要将某些任务分配给多个进程以节省总体时间的时候而设计的；例如，下载网页进行爬取，调整图像大小等。它包括了排队任务、启用进程间通信以及等待所有进程完成的方法。[“并发性”](#concurrency)
    探讨了其中的一些细节。'
- en: Kill a Process with terminate()
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 terminate() 杀死一个进程
- en: If you created one or more processes and want to terminate one for some reason
    (perhaps it’s stuck in a loop, or maybe you’re bored, or you want to be an evil
    overlord), use `terminate()`. In [Example 15-2](#ch15_ex1), our process would
    count to a million, sleeping at each step for a second, and printing an irritating
    message. However, our main program runs out of patience in five seconds and nukes
    it from orbit.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个或多个进程，并且想出于某种原因终止其中一个（也许它陷入了循环，或者你感到无聊，或者你想成为一个邪恶的霸主），使用 `terminate()`。在
    [示例 15-2](#ch15_ex1) 中，我们的进程会计数到一百万，每一步都会睡眠一秒，并打印一个恼人的消息。然而，我们的主程序在五秒内失去耐心，然后将其从轨道上摧毁。
- en: Example 15-2\. mp2.py
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-2\. mp2.py
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When I run this program, I get the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这个程序时，我得到了以下输出：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Get System Info with os
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 os 获取系统信息
- en: 'The standard `os` package provides a lot of details on your system, and lets
    you control some of it if you run your Python script as a privileged user (root
    or administrator). Besides file and directory functions that are covered in [Chapter 14](ch14.html#ch_files),
    it has informational functions like these (run on an iMac):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 `os` 包提供了关于你的系统的许多详细信息，并且如果以特权用户（root 或管理员）身份运行你的 Python 脚本，还可以控制其中的一些内容。除了在
    [第 14 章](ch14.html#ch_files) 中介绍的文件和目录函数外，它还有像这样的信息函数（在 iMac 上运行）：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A useful function is `system()`, which executes a command string as though
    you typed it at a terminal:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的函数是 `system()`，它会执行一个命令字符串，就像你在终端上输入一样：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It’s a grab bag. See the [docs](https://oreil.ly/3r6xN) for interesting tidbits.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个大杂烩。查看 [文档](https://oreil.ly/3r6xN) 以获取有趣的小知识。
- en: Get Process Info with psutil
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 psutil 获取进程信息
- en: The third-party package [psutil](https://oreil.ly/pHpJD) also provides system
    and process information for Linux, Unix, macOS, and Windows systems.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方包 [psutil](https://oreil.ly/pHpJD) 还为 Linux、Unix、macOS 和 Windows 系统提供了系统和进程信息。
- en: 'You can guess how to install it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以猜测如何安装它：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Coverage includes the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖范围包括以下内容：
- en: System
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 系统
- en: CPU, memory, disk, network, sensors
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CPU、内存、磁盘、网络、传感器
- en: Processes
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 进程
- en: id, parent id, CPU, memory, open files, threads
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ID、父ID、CPU、内存、打开的文件、线程
- en: We already saw (in the previous `os` discussion) that my computer has four CPUs.
    How much time (in seconds) have they been using?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的`os`讨论中看到，我的计算机有四个CPU。它们已经使用了多少时间（以秒为单位）？
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And how busy are they now?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它们现在有多忙？
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You might never need this kind of data, but it’s good to know where to look
    if you do.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你永远不需要这种类型的数据，但知道在哪里查找是很好的。
- en: Command Automation
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令自动化
- en: You often run commands from the shell (either with manually typed commands or
    shell scripts), but Python has more than one good third-party management tool.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常从shell中运行命令（要么手动输入命令，要么使用shell脚本），但Python有多个良好的第三方管理工具。
- en: A related topic, *task queues*, is discussed in [“Queues”](#queues).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的主题，*任务队列*，在[“队列”](#queues)中讨论。
- en: Invoke
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Invoke
- en: Version 1 of the `fabric` tool let you define local and remote (networked) tasks
    with Python code. The developers split this original package into `fabric2` (remote)
    and `invoke` (local).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`fabric`工具的第一个版本允许您使用Python代码定义本地和远程（网络）任务。开发人员将此原始包拆分为`fabric2`（远程）和`invoke`（本地）。'
- en: 'Install `invoke` by running the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装`invoke`：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: One use of `invoke` is to make functions available as command-line arguments.
    Let’s make a *tasks.py* file with the lines shown in [Example 15-3](#ex1503).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`invoke`的一个用途是将函数作为命令行参数提供。让我们创建一个*tasks.py*文件，其中包含[示例15-3](#ex1503)中显示的行。'
- en: Example 15-3\. tasks.py
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例15-3\. tasks.py
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: (That `ctx` argument is the first argument for each task function, but it’s
    used only internally by `invoke`. It doesn’t matter what you call it, but an argument
    needs to be there.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: （那个`ctx`参数是每个任务函数的第一个参数，但它仅在`invoke`内部使用。你可以随意命名它，但必须有一个参数在那里。）
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Use the argument `-l` or `--list` to see what tasks are available:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数`-l`或`--list`来查看可用的任务：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tasks can have arguments, and you can invoke multiple tasks at one time from
    the command line (similar to `&&` use in shell scripts).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以有参数，你可以从命令行同时调用多个任务（类似于shell脚本中的`&&`使用）。
- en: 'Other uses include:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其他用途包括：
- en: Running local shell commands with the `run()` function
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`run()`函数运行本地shell命令
- en: Responding to string output patterns of programs
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应程序的字符串输出模式
- en: This was a brief glimpse. See the [docs](http://docs.pyinvoke.org) for all the
    details.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简短的一瞥。详细信息请参阅[文档](http://docs.pyinvoke.org)。
- en: Other Command Helpers
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他命令助手
- en: 'These Python packages have some similarity to `invoke`, but one or another
    may be a better fit when you need it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Python包在某种程度上类似于`invoke`，但在需要时可能有一个或多个更适合：
- en: '[`click`](https://click.palletsprojects.com)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`click`](https://click.palletsprojects.com)'
- en: '[`doit`](http://pydoit.org)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`doit`](http://pydoit.org)'
- en: '[`sh`](http://amoffat.github.io/sh)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`sh`](http://amoffat.github.io/sh)'
- en: '[`delegator`](https://github.com/kennethreitz/delegator.py)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`delegator`](https://github.com/kennethreitz/delegator.py)'
- en: '[`pypeln`](https://cgarciae.github.io/pypeln)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`pypeln`](https://cgarciae.github.io/pypeln)'
- en: Concurrency
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: The official Python site discusses concurrency in general and [in the standard
    library](http://bit.ly/concur-lib). Those pages have many links to various packages
    and techniques; in this chapter, we show the most useful ones.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 官方Python网站总结了一般的并发概念以及标准库中的[并发](http://bit.ly/concur-lib)。这些页面包含许多链接到各种包和技术；在本章中，我们展示了最有用的一些链接。
- en: 'In computers, if you’re waiting for something, it’s usually for one of two
    reasons:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机中，如果你在等待什么东西，通常是有两个原因：
- en: I/O bound
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: I/O绑定
- en: This is by far the most common. Computer CPUs are ridiculously fast—hundreds
    of times faster than computer memory and many thousands of times faster than disks
    or networks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是目前最常见的情况。计算机CPU速度非常快 - 比计算机内存快数百倍，比磁盘或网络快数千倍。
- en: CPU bound
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CPU绑定
- en: The CPU keeps busy. This happens with *number crunching* tasks such as scientific
    or graphic calculations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: CPU保持繁忙。这发生在像科学或图形计算这样的*数字计算*任务中。
- en: 'Two more terms are related to concurrency:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个与并发相关的术语是：
- en: Synchronous
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 同步
- en: One thing follows the other, like a line of goslings behind their parents.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 事物紧随其后，就像一行幼鹅跟随它们的父母。
- en: Asynchronous
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 异步
- en: Tasks are independent, like random geese splashing down in a pond.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是独立的，就像随机的鹅在池塘里溅水一样。
- en: As you progress from simple systems and tasks to real-life problems, you’ll
    need at some point to deal with concurrency. Consider a website, for example.
    You can usually provide static and dynamic pages to web clients fairly quickly.
    A fraction of a second is considered interactive, but if the display or interaction
    takes longer people become impatient. Tests by companies such as Google and Amazon
    showed that traffic drops off quickly if the page loads even a little slower.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您从简单系统和任务逐渐过渡到现实生活中的问题，您在某个时候将需要处理并发性。以网站为例。您通常可以相当快地为 web 客户端提供静态和动态页面。一秒钟的时间被认为是交互式的，但如果显示或交互需要更长时间，人们会变得不耐烦。像
    Google 和 Amazon 这样的公司进行的测试表明，如果页面加载速度稍慢，流量会迅速下降。
- en: But what if you can’t help it when something takes a long time, such as uploading
    a file, resizing an image, or querying a database? You can’t do it within your
    synchronous web server code anymore, because someone’s waiting.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果有些事情花费很长时间，比如上传文件、调整图像大小或查询数据库，你又无能为力怎么办？你不能再在同步的 web 服务器代码中做了，因为有人在等待。
- en: On a single machine, if you want to perform multiple tasks as fast as possible,
    you want to make them independent. Slow tasks shouldn’t block all the others.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在单台计算机上，如果要尽可能快地执行多个任务，就需要使它们相互独立。慢任务不应该阻塞其他所有任务。
- en: This chapter showed earlier how multiprocessing can be used to overlap work
    on a single machine. If you needed to resize an image, your web server code could
    call a separate, dedicated-image resizing process to run asynchronously and concurrently.
    It could scale your application horizontally by invoking multiple resizing processes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面展示了如何利用多进程在单台计算机上重叠工作。如果您需要调整图像大小，您的 web 服务器代码可以调用一个单独的、专用的图像调整进程来异步和并发地运行。它可以通过调用多个调整大小的进程来扩展您的应用程序。
- en: The trick is getting them all to work with one another. Any shared control or
    state means that there will be bottlenecks. An even bigger trick is dealing with
    failures, because concurrent computing is harder than regular computing. Many
    more things can go wrong, and your odds of end-to-end success are lower.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍在于让它们彼此协同工作。任何共享的控制或状态意味着会有瓶颈。更大的诀窍是处理故障，因为并发计算比常规计算更难。许多事情可能会出错，你成功的几率会更低。
- en: 'All right. What methods can help you to deal with these complexities? Let’s
    begin with a good way to manage multiple tasks: *queues*.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。什么方法可以帮助您应对这些复杂性？让我们从管理多个任务的好方法开始：*队列*。
- en: Queues
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列
- en: 'A queue is like a list: things are added at one end and taken away from the
    other. The most common is referred to as *FIFO* (first in, first out).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 队列类似于列表：东西从一端添加，从另一端取走。最常见的是所谓的*FIFO*（先进先出）。
- en: Suppose that you’re washing dishes. If you’re stuck with the entire job, you
    need to wash each dish, dry it, and put it away. You can do this in a number of
    ways. You might wash the first dish, dry it, and then put it away. You then repeat
    with the second dish, and so on. Or, you might *batch* operations and wash all
    the dishes, dry them all, and then put them away; this assumes you have space
    in your sink and drainer for all the dishes that accumulate at each step. These
    are all synchronous approaches—one worker, one thing at a time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在洗盘子。如果你被困在整个工作中，你需要洗每个盘子，擦干它，并把它收起来。你可以用多种方式做到这一点。你可能先洗第一只盘子，然后擦干，然后把它收起来。然后你重复第二只盘子，依此类推。或者，您可以批量操作，洗所有的盘子，擦干它们，然后把它们收起来；这意味着您在水槽和沥干架上有足够的空间来存放每一步积累的所有盘子。这些都是同步方法——一个工人，一次做一件事。
- en: As an alternative, you could get a helper or two. If you’re the washer, you
    can hand each cleaned dish to the dryer, who hands each dried dish to the put-away-er.
    As long as each of you works at the same pace, you should finish much faster than
    by yourself.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，您可以找一个或两个帮手。如果您是洗碗工，您可以把每个洗净的盘子交给擦干工，擦干工再把每个擦干的盘子交给收拾工。只要每个人的工作速度一样，你们应该比一个人做快得多。
- en: However, what if you wash faster than the dryer dries? Wet dishes either fall
    on the floor, or you pile them up between you and the dryer, or you just whistle
    off-key until the dryer is ready. And if the last person is slower than the dryer,
    dry dishes can end up falling on the floor, or piling up, or the dryer does the
    whistling. You have multiple workers, but the overall task is still synchronous
    and can proceed only as fast as the slowest worker.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你洗碗比烘干快怎么办？湿碟子要么掉在地上，要么堆在你和烘干机之间，或者你只是走音哼着歌等待烘干机准备好。如果最后一个人比烘干机慢，干燥好的碟子最终可能会掉在地上，或者堆在一起，或者烘干机开始哼歌。你有多个工人，但整体任务仍然是同步的，只能按照最慢的工人的速度进行。
- en: '*Many hands make light work*, goes the old saying (I always thought it was
    Amish, because it makes me think of barn building). Adding workers can build a
    barn or do the dishes, faster. This involves *queues*.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*众人拾柴火焰高*，古语如是说（我一直以为这是阿米什人的，因为它让我想到了建造谷仓）。增加工人可以建造谷仓或者更快地洗碗。这涉及到*队列*。'
- en: In general, queues transport *messages*, which can be any kind of information.
    In this case, we’re interested in queues for distributed task management, also
    known as *work queues*, *job queues*, or *task queues*. Each dish in the sink
    is given to an available washer, who washes and hands it off to the first available
    dryer, who dries and hands it to a put-away-er. This can be synchronous (workers
    wait for a dish to handle and another worker to whom to give it), or asynchronous
    (dishes are stacked between workers with different paces). As long as you have
    enough workers, and they keep up with the dishes, things move a lot faster.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，队列传输*消息*，可以是任何类型的信息。在这种情况下，我们对分布式任务管理的队列感兴趣，也称为*工作队列*、*作业队列*或*任务队列*。水池中的每个碟子都交给一个可用的洗碗机，洗碗机洗完后交给第一个可用的烘干机，烘干机烘干后交给一个放置者。这可以是同步的（工人等待处理一个碟子和另一个工人来接收它），也可以是异步的（碟子在不同速度的工人之间堆积）。只要你有足够的工人，并且他们跟得上碟子的速度，事情就会快得多。
- en: Processes
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程
- en: You can implement queues in many ways. For a single machine, the standard library’s
    `multiprocessing` module (which you saw earlier) contains a `Queue` function.
    Let’s simulate just a single washer and multiple dryer processes (someone can
    put the dishes away later) and an intermediate `dish_queue`. Call this program
    *dishes.py* ([Example 15-4](#ex1504)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用许多方法实现队列。对于单台机器，标准库的 `multiprocessing` 模块（前面你见过）包含一个 `Queue` 函数。让我们模拟只有一个洗碗机和多个烘干进程（稍后有人会把碟子放好），以及一个中间的
    `dish_queue`。将这个程序称为 *dishes.py*（[Example 15-4](#ex1504)）。
- en: Example 15-4\. dishes.py
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 15-4\. dishes.py
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run your new program, thusly:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的新程序，像这样：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This queue looked a lot like a simple Python iterator, producing a series of
    dishes. It actually started up separate processes along with the communication
    between the washer and dryer. I used a `JoinableQueue` and the final `join()`
    method to let the washer know that all the dishes have been dried. There are other
    queue types in the `multiprocessing` module, and you can read the [documentation](http://bit.ly/multi-docs)
    for more examples.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个队列看起来很像一个简单的 Python 迭代器，产生一系列的碟子。实际上，它启动了独立的进程以及洗碗机和烘干机之间的通信。我使用了 `JoinableQueue`
    和最终的 `join()` 方法来告诉洗碗机所有的碟子已经干燥好了。在 `multiprocessing` 模块中还有其他的队列类型，你可以阅读 [文档](http://bit.ly/multi-docs)
    获取更多例子。
- en: Threads
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程
- en: A *thread* runs within a process with access to everything in the process, similar
    to a multiple personality. The `multiprocessing` module has a cousin called `threading`
    that uses threads instead of processes (actually, `multiprocessing` was designed
    later as its process-based counterpart). Let’s redo our process example with threads,
    as shown in [Example 15-5](#ex1505).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程*在一个进程中运行，并可以访问进程中的所有内容，类似于多重人格。`multiprocessing` 模块有一个名为 `threading` 的表兄弟，它使用线程而不是进程（实际上，`multiprocessing`
    是它基于进程的对应物）。让我们用线程重新做我们的进程示例，如 [Example 15-5](#ex1505) 所示。'
- en: Example 15-5\. thread1.py
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 15-5\. thread1.py
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s what prints for me:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的打印输出：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can reproduce our process-based dish example by using threads, as shown in
    [Example 15-6](#ex1506).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过线程重新复制我们基于进程的洗碟子示例，如 [Example 15-6](#ex1506) 所示。
- en: Example 15-6\. thread_dishes.py
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 15-6\. thread_dishes.py
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: One difference between `multiprocessing` and `threading` is that `threading`
    does not have a `terminate()` function. There’s no easy way to terminate a running
    thread, because it can cause all sorts of problems in your code, and possibly
    in the space-time continuum itself.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`和`threading`之间的一个区别是，`threading`没有`terminate()`函数。没有简单的方法来终止运行中的线程，因为它可能会在您的代码中引发各种问题，甚至可能影响时空连续体本身。'
- en: Threads can be dangerous. Like manual memory management in languages such as
    C and C++, they can cause bugs that are extremely hard to find, let alone fix.
    To use threads, all the code in the program (and in external libraries that it
    uses) must be *thread safe*. In the preceding example code, the threads didn’t
    share any global variables, so they could run independently without breaking anything.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可能是危险的。就像C和C++等语言中的手动内存管理一样，它们可能会导致极难发现，更不用说修复的错误。要使用线程，程序中的所有代码（以及它使用的外部库中的代码）都必须是*线程安全*的。在前面的示例代码中，线程没有共享任何全局变量，因此它们可以独立运行而不会出错。
- en: Imagine that you’re a paranormal investigator in a haunted house. Ghosts roam
    the halls, but none are aware of the others, and at any time, any of them can
    view, add, remove, or move any of the house’s contents.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一个在闹鬼的房子里进行超自然调查的调查员。鬼魂在走廊里游荡，但彼此并不知道对方的存在，随时都可以查看、添加、删除或移动房子里的任何物品。
- en: You’re walking apprehensively through the house, taking readings with your impressive
    instruments. Suddenly you notice that the candlestick you passed seconds ago is
    now missing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你戒备地穿过房子，用你那令人印象深刻的仪器进行测量。突然间，你注意到你刚刚走过的烛台不见了。
- en: The contents of the house are like the variables in a program. The ghosts are
    threads in a process (the house). If the ghosts only cast spectral glances at
    the house’s contents, there would be no problem. It’s like a thread reading the
    value of a constant or variable without trying to change it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 房子里的内容就像程序中的变量一样。鬼魂是进程（房子）中的线程。如果鬼魂只是偶尔瞥一眼房子的内容，那就没有问题。就像一个线程读取常量或变量的值而不试图改变它一样。
- en: Yet, some unseen entity could grab your flashlight, blow cold air down your
    neck, put marbles on the stairs, or make the fireplace come ablaze. The *really*
    subtle ghosts would change things in other rooms that you might never notice.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，某些看不见的实体可能会拿走你的手电筒，往你的脖子上吹冷风，把弹珠放在楼梯上，或点燃壁炉。*真正*微妙的鬼魂会改变你可能永远不会注意到的其他房间里的东西。
- en: Despite your fancy instruments, you’d have a very hard time figuring out who
    did what, how, when, and where.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你有花哨的仪器，但你要弄清楚谁做了什么，怎么做的，什么时候做的，以及在哪里做的，是非常困难的。
- en: If you used multiple processes instead of threads, it would be like having a
    number of houses but with only one (living) person in each. If you put your brandy
    in front of the fireplace, it would still be there an hour later—some lost to
    evaporation, but in the same place.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用多个进程而不是线程，那就像每个房子只有一个（活着的）人一样。如果您把白兰地放在壁炉前，一个小时后它仍会在那里——有些会因蒸发而丢失，但位置不变。
- en: Threads can be useful and safe when global data is not involved. In particular,
    threads are useful for saving time while waiting for some I/O operation to complete.
    In these cases, they don’t have to fight over data, because each has completely
    separate variables.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当不涉及全局数据时，线程可能是有用且安全的。特别是，在等待某些I/O操作完成时，线程可节省时间。在这些情况下，它们不必争夺数据，因为每个线程都有完全独立的变量。
- en: But threads do sometimes have good reasons to change global data. In fact, one
    common reason to launch multiple threads is to let them divide up the work on
    some data, so a certain degree of change to the data is expected.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但线程有时确实有充分理由更改全局数据。事实上，启动多个线程的一个常见原因是让它们分配某些数据的工作，因此预期对数据进行一定程度的更改。
- en: 'The usual way to share data safely is to apply a software *lock* before modifying
    a variable in a thread. This keeps the other threads out while the change is made.
    It’s like having a Ghostbuster guard the room you want to remain unhaunted. The
    trick, though, is that you need to remember to unlock it. Plus, locks can be nested:
    what if another Ghostbuster is also watching the same room, or the house itself?
    The use of locks is traditional but hard to get right.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 安全共享数据的通常方法是在修改线程中的变量之前应用软件*锁定*。这样在进行更改时可以阻止其他线程进入。这就像让一个捉鬼者守卫你想保持清静的房间一样。不过，诀窍在于你需要记得解锁它。而且，锁定可以嵌套：如果另一个捉鬼者也在监视同一个房间，或者是房子本身呢？锁的使用是传统的但难以做到完全正确。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注：
- en: In Python, threads do not speed up CPU-bound tasks because of an implementation
    detail in the standard Python system called the *Global Interpreter Lock* (GIL).
    This exists to avoid threading problems in the Python interpreter, and can actually
    make a multithreaded program slower than its single-threaded counterpart, or even
    a multi-process version.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，由于标准 Python 系统中的一个实现细节，线程不会加速 CPU 密集型任务，这称为*全局解释器锁*（GIL）。这存在是为了避免
    Python 解释器中的线程问题，但实际上可能使多线程程序比其单线程版本或甚至多进程版本更慢。
- en: 'So for Python, the recommendations are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于 Python，建议如下：
- en: Use threads for I/O-bound problems
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 I/O 密集型问题，请使用线程
- en: Use processes, networking, or events (discussed in the next section) for CPU-bound
    problems
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 CPU 密集型问题，请使用进程、网络或事件（在下一节中讨论）
- en: concurrent.futures
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: concurrent.futures
- en: As you’ve just seen, using threads or multiple processes involves a number of
    details. The `concurrent.futures` module was added to the Python 3.2 standard
    library to simplify these. It lets you schedule an asynchronous pool of workers,
    using threads (when I/O-bound) or processes (when CPU-bound). You get back a *future*
    to track their state and collect the results.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您刚刚看到的，使用线程或多进程涉及许多细节。`concurrent.futures` 模块已添加到 Python 3.2 标准库中，以简化这些操作。它允许您调度异步工人池，使用线程（当
    I/O 密集型时）或进程（当 CPU 密集型时）。您将得到一个 *future* 来跟踪它们的状态并收集结果。
- en: '[Example 15-7](#ex1507) contains a test program that you can save as *cf.py*.
    The task function `calc()` sleeps for one second (our way of faking being busy
    with something), calculates the square root of its argument, and returns it. The
    program takes an optional command-line argument of the number of workers to use,
    which defaults to 3. It starts this number of workers in a thread pool, then a
    process pool, and then prints the elapsed times. The `values` list contains five
    numbers, sent to `calc()` one at time in a worker thread or process.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-7](#ex1507) 包含一个测试程序，您可以将其保存为 *cf.py*。任务函数 `calc()` 睡眠一秒钟（我们模拟忙于某事），计算其参数的平方根，并返回它。程序可以接受一个可选的命令行参数，表示要使用的工人数，默认为
    3。它在线程池中启动此数量的工人，然后在进程池中启动，然后打印经过的时间。`values` 列表包含五个数字，逐个发送给 `calc()` 在工人线程或进程中。'
- en: Example 15-7\. cf.py
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-7\. cf.py
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here are some results that I got:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我得到的一些结果：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That one-second `sleep()` forced each worker to take a second for each calculation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 那一秒钟的 `sleep()` 强制每个工人对每个计算都花费一秒钟：
- en: With only one worker at a time, everything was serial, and the total time was
    more than five seconds.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个工人同时工作，一切都是串行的，总时间超过五秒。
- en: Five workers matched the size of the values being tested, so we had an elapsed
    time just more than a second.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 五个工人与被测试值的大小匹配，所以经过的时间略多于一秒。
- en: With three workers, we needed two runs to handle all five values, so two seconds
    elapsed.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用三个工人，我们需要两次运行来处理所有五个值，所以经过了两秒。
- en: In the program, I ignored the actual `results` (the square roots that we calculated)
    to emphasize the elapsed times. Also, using `map()` to define the pool causes
    us to wait for all workers to finish before returning `results`. If you wanted
    to get each result as it completed, let’s try another test (call it *cf2.py*)
    in which each worker returns the value and its square root as soon as it calculates
    it ([Example 15-8](#ex1508)).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，我忽略了实际的 `results`（我们计算的平方根），以突出显示经过的时间。此外，使用 `map()` 来定义池会导致我们在返回 `results`
    之前等待所有工人完成。如果您希望在每次完成时获取每个结果，让我们尝试另一个测试（称为 *cf2.py*），在该测试中，每个工人在计算完值及其平方根后立即返回该值（[示例 15-8](#ex1508)）。
- en: Example 15-8\. cf2.py
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-8\. cf2.py
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our `use_threads()` and `use_processes()` functions are now generator functions
    that call `yield` to return on each iteration. From one run on my machine, you
    can see how the workers don’t always finish `1` through `5` in order:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `use_threads()` 和 `use_processes()` 函数现在是生成器函数，每次迭代调用 `yield` 返回。在我的机器上运行一次，您可以看到工人不总是按顺序完成
    `1` 到 `5`：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can use `concurrent.futures` any time you want to launch a bunch of concurrent
    tasks, such as the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何时候使用 `concurrent.futures` 启动一堆并发任务，例如以下内容：
- en: Crawling URLs on the web
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爬取网页上的 URL
- en: Processing files, such as resizing images
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文件，如调整图像大小
- en: Calling service APIs
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用服务 API
- en: As usual, the [docs](https://oreil.ly/dDdF-) provide additional details, but
    are much more technical.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，[文档](https://oreil.ly/dDdF-) 提供了额外的详细信息，但更加技术性。
- en: Green Threads and gevent
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绿色线程和 gevent
- en: As you’ve seen, developers traditionally avoid slow spots in programs by running
    them in separate threads or processes. The Apache web server is an example of
    this design.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，开发者传统上通过将程序中的慢点运行在单独的线程或进程中来避免慢点。Apache网络服务器就是这种设计的一个例子。
- en: One alternative is *event-based* programming. An event-based program runs a
    central *event loop*, doles out any tasks, and repeats the loop. The NGINX web
    server follows this design, and is generally faster than Apache.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个替代方案是*基于事件*的编程。一个基于事件的程序运行一个中央*事件循环*，分发任何任务，并重复该循环。NGINX网络服务器遵循这种设计，并且通常比Apache更快。
- en: 'The `gevent` library is event-based and accomplishes a neat trick: you write
    normal imperative code, and it magically converts pieces to *coroutines*. These
    are like generators that can communicate with one another and keep track of where
    they are. `gevent` modifies many of Python’s standard objects such as `socket`
    to use its mechanism instead of blocking. This does not work with Python add-in
    code that was written in C, as some database drivers are.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`gevent`库是基于事件的，并完成了一个巧妙的技巧：你编写普通的命令式代码，它会神奇地将部分代码转换为*协程*。这些协程类似于可以相互通信并跟踪其位置的生成器。`gevent`修改了Python许多标准对象如`socket`，以使用其机制而不是阻塞。这不能与Python中用C编写的插件代码一起工作，比如一些数据库驱动。'
- en: 'You install `gevent` by using `pip`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`pip`安装`gevent`：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here’s a variation of [sample code at the `gevent` website](http://www.gevent.org).
    You’ll see the `socket` module’s `gethostbyname()` function in the upcoming DNS
    section. This function is synchronous, so you wait (possibly many seconds) while
    it chases name servers around the world to look up that address. But you could
    use the `gevent` version to look up multiple sites independently. Save this as
    *gevent_test.py* ([Example 15-9](#ex1509)).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是[在`gevent`网站的示例代码的变体](http://www.gevent.org)。在即将到来的DNS部分中，你会看到`socket`模块的`gethostbyname()`函数。这个函数是同步的，所以你要等待（可能很多秒），而它在世界各地的名称服务器中查找地址。但你可以使用`gevent`版本来独立查找多个站点。将其保存为*gevent_test.py*（[示例 15-9](#ex1509)）。
- en: Example 15-9\. gevent_test.py
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-9\. gevent_test.py
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There’s a one-line for-loop in the preceding example. Each hostname is submitted
    in turn to a `gethostbyname()` call, but they can run asynchronously because it’s
    the `gevent` version of `gethostbyname()`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中有一个单行的for循环。每个主机名依次提交给`gethostbyname()`调用，但它们可以异步运行，因为这是`gevent`版本的`gethostbyname()`。
- en: 'Run *gevent_test.py*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 运行*gevent_test.py*：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`gevent.spawn()` creates a *greenlet* (also known sometimes as a *green thread*
    or a *microthread*) to execute each `gevent.socket.gethostbyname(url)`.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`gevent.spawn()`创建一个*greenlet*（有时也称为*绿色线程*或*微线程*）来执行每个`gevent.socket.gethostbyname(url)`。'
- en: The difference from a normal thread is that it doesn’t block. If something occurred
    that would have blocked a normal thread, `gevent` switches control to one of the
    other greenlets.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通线程的区别在于它不会阻塞。如果发生了本应该阻塞普通线程的事件，`gevent`会切换控制到其他的greenlet。
- en: The `gevent.joinall()` method waits for all the spawned jobs to finish. Finally,
    we dump the IP addresses that we got for these hostnames.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`gevent.joinall()`方法等待所有生成的作业完成。最后，我们会输出这些主机名对应的IP地址。'
- en: Instead of the `gevent` version of `socket`, you can use its evocatively named
    *monkey-patching* functions. These modify standard modules such as `socket` to
    use greenlets rather than calling the `gevent` version of the module. This is
    useful when you want `gevent` to be applied all the way down, even into code that
    you might not be able to access.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用它的富有表现力的名为*monkey-patching*的函数，而不是`gevent`版本的`socket`。这些函数修改标准模块如`socket`，以使用绿色线程而不是调用模块的`gevent`版本。当你希望`gevent`被应用到所有代码，甚至是无法访问的代码时，这是非常有用的。
- en: 'At the top of your program, add the following call:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序顶部添加以下调用：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This inserts the `gevent` socket everywhere the normal `socket` is called, anywhere
    in your program, even in the standard library. Again, this works only for Python
    code, not libraries written in C.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将`gevent`套接字插入到任何地方普通的`socket`被调用的地方，即使是在你的程序中的标准库中。再次强调，这仅适用于Python代码，而不适用于用C编写的库。
- en: 'Another function monkey-patches even more standard library modules:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数monkey-patches更多的标准库模块：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Use this at the top of your program to get as many `gevent` speedups as possible.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序顶部使用这个来获取尽可能多的`gevent`加速。
- en: Save this program as *gevent_monkey.py* ([Example 15-9](#ex1509)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将此程序保存为*gevent_monkey.py*（[示例 15-9](#ex1509)）。
- en: Example 15-10\. gevent_monkey.py
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-10\. gevent_monkey.py
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Again, run the program:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行程序：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There are potential dangers when using `gevent`. As with any event-based system,
    each chunk of code that you execute should be relatively quick. Although it’s
    nonblocking, code that does a lot of work is still slow.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gevent`存在潜在风险。与任何基于事件的系统一样，每段执行的代码应该相对迅速。虽然它是非阻塞的，但执行大量工作的代码仍然慢。
- en: The very idea of monkey-patching makes some people nervous. Yet, many large
    sites such as Pinterest use `gevent` to speed up their sites significantly. Like
    the fine print on a bottle of pills, use `gevent` as directed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: monkey-patching 的概念使一些人感到不安。然而，像Pinterest这样的大型网站使用`gevent`显著加速他们的网站。就像药瓶上的小字一样，请按照指示使用`gevent`。
- en: For more examples, see this thorough gevent [tutorial](https://oreil.ly/BWR_q).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 欲知更多示例，请参阅这个详尽的`gevent`[教程](https://oreil.ly/BWR_q)。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You might also want to consider [`tornado`](http://www.tornadoweb.org) or [`gunicorn`](http://gunicorn.org),
    two other popular event-driven frameworks. They provide both the low-level event
    handling and a fast web server. They’re worth a look if you’d like to build a
    fast website without messing with a traditional web server such as Apache.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也考虑使用[`tornado`](http://www.tornadoweb.org)或者[`gunicorn`](http://gunicorn.org)，这两个流行的事件驱动框架提供了低级事件处理和快速的Web服务器。如果你想构建一个快速的网站而不想麻烦传统的Web服务器如Apache，它们值得一试。
- en: twisted
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: twisted
- en: '[`twisted`](http://twistedmatrix.com/trac) is an asynchronous, event-driven
    networking framework. You connect functions to events such as data received or
    connection closed, and those functions are called when those events occur. This
    is a *callback* design, and if you’ve written anything in JavaScript, it might
    seem familiar. If it’s new to you, it can seem backwards. For some developers,
    callback-based code becomes harder to manage as the application grows.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[`twisted`](http://twistedmatrix.com/trac)是一个异步的、事件驱动的网络框架。你可以将函数连接到诸如数据接收或连接关闭等事件，当这些事件发生时，这些函数就会被调用。这是一种*回调*设计，如果你之前写过JavaScript代码，这种方式可能很熟悉。如果你还不熟悉，它可能看起来有些反直觉。对于一些开发者来说，基于回调的代码在应用程序增长时变得更难管理。'
- en: 'You install it by running the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令安装它：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`twisted` is a large package, with support for many internet protocols on top
    of TCP and UDP. To be short and simple, we show a little knock-knock server and
    client, adapted from [twisted examples](http://bit.ly/twisted-ex). First, let’s
    look at the server, *knock_server.py*: ([Example 15-11](#ex1511)).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`twisted`是一个庞大的包，支持多种基于TCP和UDP的互联网协议。简单说，我们展示了一个从[twisted 示例](http://bit.ly/twisted-ex)改编的小小的“敲门”服务器和客户端。首先，让我们看看服务器，*knock_server.py*：([示例
    15-11](#ex1511))。'
- en: Example 15-11\. knock_server.py
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-11\. knock_server.py
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now let’s take a glance at its trusty companion, *knock_client.py* ([Example 15-12](#ex1512)).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们快速浏览它的可靠伴侣，*knock_client.py*（[示例 15-12](#ex1512)）。
- en: Example 15-12\. knock_client.py
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-12\. knock_client.py
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Start the server first:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先启动服务器：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, start the client:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启动客户端：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The server and client exchange messages, and the server prints the conversation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和客户端交换消息，服务器打印对话：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Our trickster client then ends, keeping the server waiting for the punch line.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的恶作剧客户端然后结束，让服务器等待笑话的结尾。
- en: If you’d like to enter the `twisted` passages, try some of the other examples
    from its documentation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进入`twisted`的世界，请尝试一些它文档中的其他示例。
- en: asyncio
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: asyncio
- en: Python added the `asyncio` library in version 3.4. It’s a way of defining concurrent
    code using the new `async` and `await` capabilities. It’s a big topic with many
    details. To avoid overstuffing this chapter, I’ve moved the discussion of `asyncio`
    and related topics to [Appendix C](app03.html#app_async).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Python在3.4版本中加入了`asyncio`库。它是使用新的`async`和`await`功能定义并发代码的一种方式。这是一个涉及许多细节的大课题。为了避免在本章节中过多涉及，我已将有关`asyncio`和相关主题的讨论移至[附录
    C](app03.html#app_async)。
- en: Redis
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redis
- en: Our earlier dishwashing code examples, using processes or threads, were run
    on a single machine. Let’s take another approach to queues that can run on a single
    machine or across a network. Even with multiple singing processes and dancing
    threads, sometimes one machine isn’t enough, You can treat this section as a bridge
    between single-box (one machine) and multiple-box concurrency.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前关于洗碗的代码示例，使用进程或线程，在单台机器上运行。让我们再来看一种可以在单台机器或跨网络运行的队列方法。即使有多个歌唱进程和跳舞线程，有时一台机器还不够，你可以把这一节当作单台（一台机器）和多台并发之间的桥梁。
- en: To try the examples in this section, you’ll need a Redis server and its Python
    module. You can see where to get them in [“Redis”](ch16.html#redis). In that chapter,
    Redis’s role is that of a database. Here, we’re featuring its concurrency personality.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试本节中的示例，您需要一个Redis服务器及其Python模块。您可以在[“Redis”](ch16.html#redis)中找到获取它们的位置。在那一章中，Redis的角色是数据库。在这里，我们展示它的并发性格。
- en: A quick way to make a queue is with a Redis list. A Redis server runs on one
    machine; this can be the same one as its clients, or another that the clients
    can access through a network. In either case, clients talk to the server via TCP,
    so they’re networking. One or more provider clients pushes messages onto one end
    of the list. One or more client workers watches this list with a *blocking pop*
    operation. If the list is empty, they all just sit around playing cards. As soon
    as a message arrives, the first eager worker gets it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Redis列表是快速创建队列的方法。Redis服务器运行在一台机器上；这可以是与其客户端相同的机器，或者是客户端通过网络访问的另一台机器。无论哪种情况，客户端通过TCP与服务器通信，因此它们是网络化的。一个或多个提供者客户端将消息推送到列表的一端。一个或多个客户端工作进程使用*阻塞弹出*操作监视此列表。如果列表为空，它们就会坐在那里打牌。一旦有消息到达，第一个渴望的工作进程就会获取到它。
- en: Like our earlier process- and thread-based examples, *redis_washer.py* generates
    a sequence of dishes ([Example 15-13](#ex1513)).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们早期基于进程和线程的示例一样，*redis_washer.py*生成一系列的菜品（[示例 15-13](#ex1513)）。
- en: Example 15-13\. redis_washer.py
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-13\. redis_washer.py
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The loop generates four messages containing a dish name, followed by a final
    message that says “quit.” It appends each message to a list called `dishes` in
    the Redis server, similar to appending to a Python list.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 循环生成四条包含菜品名称的消息，然后是一条说“quit”的最终消息。它将每条消息追加到Redis服务器中的名为`dishes`的列表中，类似于追加到Python列表中。
- en: And as soon as the first dish is ready, *redis_dryer.py* does its work ([Example 15-14](#ex1514)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦第一道菜准备好，*redis_dryer.py*就开始工作（[示例 15-14](#ex1514)）。
- en: Example 15-14\. redis_dryer.py
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-14\. redis_dryer.py
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This code waits for messages whose first token is “dishes” and prints that each
    one is dried. It obeys the *quit* message by ending the loop.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码等待第一个令牌为“dishes”的消息，并打印每一个干燥。它通过结束循环遵循*quit*消息。
- en: 'Start the dryer and then the washer. Using the `&` at the end puts the first
    program in the *background*; it keeps running, but doesn’t listen to the keyboard
    anymore. This works on Linux, macOS, and Windows, although you might see different
    output on the next line. In this case (macOS), it’s some information about the
    background dryer process. Then, we start the washer process normally (in the *foreground*).
    You’ll see the mingled output of the two processes:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 先启动烘干机，然后启动洗碗机。在命令末尾使用`&`将第一个程序置于*后台*；它会继续运行，但不再接受键盘输入。这适用于Linux、macOS和Windows，尽管您可能在下一行看到不同的输出。在这种情况下（macOS），它是关于后台烘干机进程的一些信息。然后，我们正常启动洗碗机进程（*前台*）。您将看到两个进程的混合输出：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As soon as dish IDs started arriving at Redis from the washer process, our
    hard-working dryer process started pulling them back out. Each dish ID was a number,
    except the final *sentinel* value, the string `''quit''`. When the dryer process
    read that `quit` dish ID, it quit, and some more background process information
    printed to the terminal (also system dependent). You can use a sentinel (an otherwise
    invalid value) to indicate something special from the data stream itself—in this
    case, that we’re done. Otherwise, we’d need to add a lot more program logic, such
    as the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从洗碗机进程到达Redis的菜品ID开始，我们勤劳的烘干机进程就开始将它们取回。每个菜品ID都是一个数字，除了最后的*sentinel*值，即字符串`'quit'`。当烘干机进程读取到`quit`菜品ID时，它就会退出，并且一些更多的后台进程信息会打印到终端（同样依赖系统）。您可以使用一个标志（一个否则无效的值）来指示数据流本身的某些特殊情况，例如，我们已经完成了。否则，我们需要添加更多的程序逻辑，比如以下内容：
- en: Agreeing ahead of time on some maximum dish number, which would kind of be a
    sentinel anyway.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预先同意一些最大的菜品编号，这实际上会成为一个标志。
- en: Doing some special *out-of-band* (not in the data stream) interprocess communication.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行一些特殊的*out-of-band*（不在数据流中的）进程间通信。
- en: Timing out after some interval with no new data.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一段时间内没有新数据时，设置超时。
- en: 'Let’s make a few last changes:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一些最后的更改：
- en: Create multiple `dryer` processes.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多个`dryer`进程。
- en: Add a timeout to each dryer rather than looking for a sentinel.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给每个烘干机添加超时，而不是寻找一个标志。
- en: The new *redis_dryer2.py* is shown in [Example 15-15](#ex1515).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 新的*redis_dryer2.py*显示在[示例 15-15](#ex1515)中。
- en: Example 15-15\. redis_dryer2.py
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-15\. redis_dryer2.py
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Start the dryer processes in the background and then the washer process in
    the foreground:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台启动烘干进程，然后在前台启动洗碗机进程：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'One dryer process reads the `quit` ID and quits:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更干燥的过程读取`quit` ID并退出：
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After 20 seconds, the other dryer processes get a return value of `None` from
    their `blpop` calls, indicating that they’ve timed out. They say their last words
    and exit:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 20秒后，其他烘干程序从它们的`blpop`调用中获取到`None`的返回值，表示它们已超时。它们说出它们的最后一句话并退出：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After the last dryer subprocess quits, the main dryer program ends:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个烘干子进程退出后，主要的烘干程序就结束了：
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Beyond Queues
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越队列
- en: With more moving parts, there are more possibilities for our lovely assembly
    lines to be disrupted. If we need to wash the dishes from a banquet, do we have
    enough workers? What if the dryers get drunk? What if the sink clogs? Worries,
    worries!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 随着更多的零部件移动，我们可爱的装配线被打断的可能性也更多。如果我们需要洗一顿宴会的盘子，我们有足够的工人吗？如果烘干机喝醉了怎么办？如果水槽堵塞了怎么办？担心，担心！
- en: 'How will you cope with it all? Common techniques include these:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如何应对这一切？常见的技术包括以下几种：
- en: Fire and forget
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 火而忘
- en: Just pass things on and don’t worry about the consequences, even if no one is
    there. That’s the dishes-on-the-floor approach.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 只需传递事物，不要担心后果，即使没有人在那里。这就是盘子掉在地上的方法。
- en: Request-reply
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请求-响应
- en: The washer receives an acknowledgment from the dryer, and the dryer from the
    put-away-er, for each dish in the pipeline.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 洗碗机收到烘干机的确认，烘干机收到收拾碗盘者的确认，每个管道中的盘子都会这样。
- en: Back pressure or throttling
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 回压或节流
- en: This technique directs a fast worker to take it easy if someone downstream can’t
    keep up.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下游的某个人跟不上，这种技术会让快速工人放松点。
- en: 'In real systems, you need to be careful that workers are keeping up with the
    demand; otherwise, you hear the dishes hitting the floor. You might add new tasks
    to a *pending* list, while some worker process pops the latest message and adds
    it to a *working* list. When the message is done, it’s removed from the working
    list and added to a *completed* list. This lets you know what tasks have failed
    or are taking too long. You can do this with Redis yourself, or use a system that
    someone else has already written and tested. Some Python-based queue packages
    that add this extra level of management include:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际系统中，您需要确保工人们能够跟上需求；否则，您会听到盘子掉在地上的声音。您可以将新任务添加到*待处理*列表中，而某些工作进程则会弹出最新消息并将其添加到*正在处理*列表中。当消息完成时，它将从正在处理列表中删除，并添加到*已完成*列表中。这让您知道哪些任务失败或花费太长时间。您可以自己使用Redis来完成这一过程，或者使用已经编写和测试过的系统。一些基于Python的队列包可以增加这种额外的管理水平，包括：
- en: '[`celery`](http://www.celeryproject.org) can execute distributed tasks synchronously
    or asynchronously, using the methods we’ve discussed: `multiprocessing`, `gevent`,
    and others.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`celery`](http://www.celeryproject.org)可以使用我们讨论过的方法（`multiprocessing`、`gevent`等）同步或异步地执行分布式任务。'
- en: '[rq](http://python-rq.org) is a Python library for job queues, also based on
    Redis.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[rq](http://python-rq.org)是一个基于Redis的Python作业队列库。'
- en: '[Queues](http://queues.io) offers a discussion of queuing software, Python-based
    and otherwise.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[队列](http://queues.io)讨论了队列软件，基于Python和其他语言。'
- en: Coming Up
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将到来
- en: In this chapter, we flowed data through processes. In the next chapter, you’ll
    see how to store and retrieve data in various file formats and databases.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将数据流经过程。在下一章中，您将看到如何在各种文件格式和数据库中存储和检索数据。
- en: Things to Do
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要做的事情
- en: 15.1 Use `multiprocessing` to create three separate processes. Make each one
    wait a random number of seconds between zero and one, print the current time,
    and then exit.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 15.1 使用`multiprocessing`创建三个单独的进程。使每个进程在零到一秒之间等待一个随机数，打印当前时间，然后退出。
