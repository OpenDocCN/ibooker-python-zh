- en: Chapter 1\. The Python Data Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 Python数据模型
- en: Guido’s sense of the aesthetics of language design is amazing. I’ve met many
    fine language designers who could build theoretically beautiful languages that
    no one would ever use, but Guido is one of those rare people who can build a language
    that is just slightly less theoretically beautiful but thereby is a joy to write
    programs in.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Guido在语言设计美学方面的感觉令人惊叹。我遇到过许多优秀的语言设计师，他们能构建理论上漂亮但无人会使用的语言，但Guido是为数不多的能够构建一门理论上略微欠缺但编写程序时充满乐趣的语言的人。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Jim Hugunin, creator of Jython, cocreator of AspectJ, and architect of the .Net
    DLR^([1](ch01.html#idm46582510883648))
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Jim Hugunin，Jython的创建者，AspectJ的联合创建者，以及.Net DLR^([1](ch01.html#idm46582510883648))的架构师
- en: One of the best qualities of Python is its consistency. After working with Python
    for a while, you are able to start making informed, correct guesses about features
    that are new to you.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python最大的优点之一是其一致性。使用Python一段时间后，你能够开始对新接触到的特性做出有根据的、正确的猜测。
- en: However, if you learned another object-oriented language before Python, you
    may find it strange to use `len(collection)` instead of `collection.len()`. This
    apparent oddity is the tip of an iceberg that, when properly understood, is the
    key to everything we call *Pythonic*. The iceberg is called the Python Data Model,
    and it is the API that we use to make our own objects play well with the most
    idiomatic language features.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在学Python之前学过其他面向对象语言，你可能会觉得使用`len(collection)`而不是`collection.len()`很奇怪。这个明显的奇怪之处只是冰山一角，一旦正确理解，它就是我们称之为*Pythonic*的一切的关键。这个冰山被称为Python数据模型，它是我们用来使自己的对象与最符合语言习惯的特性很好地配合的API。
- en: You can think of the data model as a description of Python as a framework. It
    formalizes the interfaces of the building blocks of the language itself, such
    as sequences, functions, iterators, coroutines, classes, context managers, and
    so on.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将数据模型视为对Python作为框架的描述。它规范了语言本身的构建块的接口，例如序列、函数、迭代器、协程、类、上下文管理器等。
- en: When using a framework, we spend a lot of time coding methods that are called
    by the framework. The same happens when we leverage the Python Data Model to build
    new classes. The Python interpreter invokes special methods to perform basic object
    operations, often triggered by special syntax. The special method names are always
    written with leading and trailing double underscores. For example, the syntax
    `obj[key]` is supported by the `__getitem__` special method. In order to evaluate
    `my_collection[key]`, the interpreter calls `my_collection.__getitem__(key)`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用框架时，我们会花费大量时间编写被框架调用的方法。在利用Python数据模型构建新类时也会发生同样的情况。Python解释器调用特殊方法来执行基本的对象操作，通常由特殊语法触发。特殊方法名总是以双下划线开头和结尾。例如，语法`obj[key]`由`__getitem__`特殊方法支持。为了计算`my_collection[key]`，解释器会调用`my_collection.__getitem__(key)`。
- en: 'We implement special methods when we want our objects to support and interact
    with fundamental language constructs such as:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望对象支持并与基本语言结构交互时，我们会实现特殊方法，例如：
- en: Collections
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Attribute access
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性访问
- en: Iteration (including asynchronous iteration using `async for`)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代（包括使用`async for`进行的异步迭代）
- en: Operator overloading
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符重载
- en: Function and method invocation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和方法调用
- en: String representation and formatting
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串表示和格式化
- en: Asynchronous programming using `await`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`await`进行异步编程
- en: Object creation and destruction
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的创建和销毁
- en: Managed contexts using the `with` or `async with` statements
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`with`或`async with`语句管理上下文
- en: Magic and Dunder
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Magic和Dunder
- en: The term *magic method* is slang for special method, but how do we talk about
    a specific method like `__getitem__`? I learned to say “dunder-getitem” from author
    and teacher Steve Holden. “Dunder” is a shortcut for “double underscore before
    and after.” That’s why the special methods are also known as *dunder methods*.
    The [“Lexical Analysis”](https://fpy.li/1-3) chapter of *The Python Language Reference*
    warns that “*Any* use of `__*__` names, in any context, that does not follow explicitly
    documented use, is subject to breakage without warning.”
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '"魔术方法"是特殊方法的俚语，但我们如何谈论像`__getitem__`这样的特定方法呢？我从作者和教师Steve Holden那里学会了说"dunder-getitem"。"Dunder"是"前后双下划线"的缩写。这就是为什么特殊方法也被称为*dunder方法*。*Python语言参考*的["词法分析"](https://fpy.li/1-3)章节警告说，"在任何上下文中，任何不遵循明确记录的`__*__`名称的使用都可能在没有警告的情况下被破坏。" '
- en: What’s New in This Chapter
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的新内容
- en: 'This chapter had few changes from the first edition because it is an introduction
    to the Python Data Model, which is quite stable. The most significant changes
    are:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与第一版相比变化不大，因为它是对Python数据模型的介绍，而数据模型相当稳定。最重要的变化是：
- en: Special methods supporting asynchronous programming and other new features,
    added to the tables in [“Overview of Special Methods”](#overview_special_methods).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持异步编程和其他新特性的特殊方法，已添加到["特殊方法概述"](#overview_special_methods)的表格中。
- en: '[Figure 1-2](#collection_uml) showing the use of special methods in [“Collection
    API”](#collection_api), including the `collections.abc.Collection` abstract base
    class introduced in Python 3.6.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[图1-2](#collection_uml)展示了在["集合API"](#collection_api)中特殊方法的使用，包括Python 3.6中引入的`collections.abc.Collection`抽象基类。'
- en: 'Also, here and throughout this second edition I adopted the *f-string* syntax
    introduced in Python 3.6, which is more readable and often more convenient than
    the older string formatting notations: the `str.format()` method and the `%` operator.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在第二版中，我采用了Python 3.6引入的*f-string*语法，它比旧的字符串格式化表示法（`str.format()`方法和`%`运算符）更具可读性，通常也更方便。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: One reason to still use `my_fmt.format()` is when the definition of `my_fmt`
    must be in a different place in the code than where the formatting operation needs
    to happen. For instance, when `my_fmt` has multiple lines and is better defined
    in a constant, or when it must come from a configuration file, or from the database.
    Those are real needs, but don’t happen very often.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然使用 `my_fmt.format()` 的一个原因是，当 `my_fmt` 的定义必须在代码中与格式化操作需要发生的地方不同的位置时。例如，当 `my_fmt`
    有多行并且最好在常量中定义时，或者当它必须来自配置文件或数据库时。这些都是真正的需求，但不会经常发生。
- en: A Pythonic Card Deck
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 风格的纸牌
- en: '[Example 1-1](#ex_pythonic_deck) is simple, but it demonstrates the power of
    implementing just two special methods, `__getitem__` and `__len__`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-1](#ex_pythonic_deck) 很简单，但它展示了仅实现两个特殊方法 `__getitem__` 和 `__len__` 的强大功能。'
- en: Example 1-1\. A deck as a sequence of playing cards
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-1\. 一副扑克牌序列
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first thing to note is the use of `collections.namedtuple` to construct
    a simple class to represent individual cards. We use `namedtuple` to build classes
    of objects that are just bundles of attributes with no custom methods, like a
    database record. In the example, we use it to provide a nice representation for
    the cards in the deck, as shown in the console session:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是使用 `collections.namedtuple` 构造一个简单的类来表示单个牌。我们使用`namedtuple` 来构建只有属性而没有自定义方法的对象类，就像数据库记录一样。在示例中，我们使用它为牌组中的牌提供了一个很好的表示，如控制台会话所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But the point of this example is the `FrenchDeck` class. It’s short, but it
    packs a punch. First, like any standard Python collection, a deck responds to
    the `len()` function by returning the number of cards in it:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个例子的重点是 `FrenchDeck` 类。它很短，但却很有冲击力。首先，像任何标准 Python 集合一样，牌组响应 `len()` 函数并返回其中的牌数：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Reading specific cards from the deck—say, the first or the last—is easy, thanks
    to the `__getitem__` method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 读取牌组中的特定牌（例如第一张或最后一张）很容易，这要归功于 `__getitem__` 方法：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Should we create a method to pick a random card? No need. Python already has
    a function to get a random item from a sequence: `random.choice`. We can use it
    on a deck instance:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该创建一个方法来随机抽取一张牌吗？没有必要。Python 已经有一个从序列中获取随机项的函数：`random.choice`。我们可以在一个 deck
    实例上使用它：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We’ve just seen two advantages of using special methods to leverage the Python
    Data Model:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了利用 Python 数据模型使用特殊方法的两个优点：
- en: Users of your classes don’t have to memorize arbitrary method names for standard
    operations. (“How to get the number of items? Is it `.size()`, `.length()`, or
    what?”)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的类的用户不必记住标准操作的任意方法名称。（"如何获得项目数？是 `.size()`、`.length()` 还是什么？"）
- en: It’s easier to benefit from the rich Python standard library and avoid reinventing
    the wheel, like the `random.choice` function.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从丰富的 Python 标准库中受益并避免重新发明轮子更容易，比如 `random.choice` 函数。
- en: But it gets better.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但它变得更好了。
- en: 'Because our `__getitem__` delegates to the `[]` operator of `self._cards`,
    our deck automatically supports slicing. Here’s how we look at the top three cards
    from a brand-new deck, and then pick just the aces by starting at index 12 and
    skipping 13 cards at a time:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的 `__getitem__` 将工作委托给 `self._cards` 的 `[]` 运算符，所以我们的牌组自动支持切片。以下是我们如何查看全新牌组中的前三张牌，然后从索引
    12 开始每次跳过 13 张牌来选出四张 A：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Just by implementing the `__getitem__` special method, our deck is also iterable:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 只需实现 `__getitem__` 特殊方法，我们的牌组也是可迭代的：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also iterate over the deck in reverse:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以反向迭代牌组：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ellipsis in doctests
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: doctest 中的省略号
- en: 'Whenever possible, I extracted the Python console listings in this book from
    [`doctest`](https://fpy.li/doctest) to ensure accuracy. When the output was too
    long, the elided part is marked by an ellipsis (`...`), like in the last line
    in the preceding code. In such cases, I used the `# doctest: +ELLIPSIS` directive
    to make the doctest pass. If you are trying these examples in the interactive
    console, you may omit the doctest comments altogether.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '只要有可能，我就会从 [`doctest`](https://fpy.li/doctest) 中提取本书中的 Python 控制台列表以确保准确性。当输出太长时，省略部分用省略号（`...`）标记，就像前面代码中的最后一行。在这种情况下，我使用
    `# doctest: +ELLIPSIS` 指令来使 doctest 通过。如果你在交互式控制台中尝试这些示例，你可以完全忽略 doctest 注释。'
- en: 'Iteration is often implicit. If a collection has no `__contains__` method,
    the `in` operator does a sequential scan. Case in point: `in` works with our `FrenchDeck`
    class because it is iterable. Check it out:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代通常是隐式的。如果一个集合没有 `__contains__` 方法，`in` 运算符会进行顺序扫描。恰好：`in` 适用于我们的 `FrenchDeck`
    类，因为它是可迭代的。看看这个：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'How about sorting? A common system of ranking cards is by rank (with aces being
    highest), then by suit in the order of spades (highest), hearts, diamonds, and
    clubs (lowest). Here is a function that ranks cards by that rule, returning `0`
    for the 2 of clubs and `51` for the ace of spades:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 那么排序呢？一个常见的牌的排名系统是先按点数（A最高），然后按花色顺序：黑桃（最高）、红心、方块和梅花（最低）。这是一个函数，它根据该规则对牌进行排名，梅花2返回`0`，黑桃A返回`51`：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Given `spades_high`, we can now list our deck in order of increasing rank:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有了 `spades_high`，我们现在可以按点数递增的顺序列出我们的牌组：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Although `FrenchDeck` implicitly inherits from the `object` class, most of its
    functionality is not inherited, but comes from leveraging the data model and composition.
    By implementing the special methods `__len__` and `__getitem__`, our `FrenchDeck`
    behaves like a standard Python sequence, allowing it to benefit from core language
    features (e.g., iteration and slicing) and from the standard library, as shown
    by the examples using `random.choice`, `reversed`, and `sorted`. Thanks to composition,
    the `__len__` and `__getitem__` implementations can delegate all the work to a
    `list` object, `self._cards`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `FrenchDeck` 隐式继承自 `object` 类，但其大部分功能不是继承而来的，而是通过利用数据模型和组合来实现的。通过实现特殊方法 `__len__`
    和 `__getitem__`，我们的 `FrenchDeck` 表现得像一个标准的 Python 序列，允许它从核心语言特性（例如迭代和切片）和标准库中受益，如使用
    `random.choice`、`reversed` 和 `sorted` 的示例所示。得益于组合，`__len__` 和 `__getitem__` 实现可以将所有工作委托给一个
    `list` 对象 `self._cards`。
- en: How About Shuffling?
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么洗牌呢？
- en: 'As implemented so far, a `FrenchDeck` cannot be shuffled because it is *immutable*:
    the cards and their positions cannot be changed, except by violating encapsulation
    and handling the `_cards` attribute directly. In [Chapter 13](ch13.html#ifaces_prot_abc),
    we will fix that by adding a one-line `__setitem__` method.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`FrenchDeck`无法被洗牌，因为它是*不可变的*：卡片及其位置不能被改变，除非违反封装并直接处理`_cards`属性。在[第 13
    章](ch13.html#ifaces_prot_abc)中，我们将通过添加一行`__setitem__`方法来解决这个问题。
- en: How Special Methods Are Used
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊方法的使用方式
- en: The first thing to know about special methods is that they are meant to be called
    by the Python interpreter, and not by you. You don’t write `my_object.__len__()`.
    You write `len(my_object)` and, if `my_object` is an instance of a user-defined
    class, then Python calls the `__len__` method you implemented.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关于特殊方法需要知道的第一件事是，它们是由 Python 解释器调用的，而不是由你调用的。你不会写`my_object.__len__()`。你写的是`len(my_object)`，如果`my_object`是一个用户定义类的实例，那么
    Python 会调用你实现的`__len__`方法。
- en: But the interpreter takes a shortcut when dealing for built-in types like `list`,
    `str`, `bytearray`, or extensions like the NumPy arrays. Python variable-sized
    collections written in C include a struct^([2](ch01.html#idm46582509922000)) called
    `PyVarObject`, which has an `ob_size` field holding the number of items in the
    collection. So, if `my_object` is an instance of one of those built-ins, then
    `len(my_object)` retrieves the value of the `ob_size` field, and this is much
    faster than calling a method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当处理内置类型如`list`、`str`、`bytearray`，或者像 NumPy 数组这样的扩展类型时，解释器会采取一种快捷方式。用 C 语言编写的可变长度
    Python 集合包括一个名为`PyVarObject`的结构体^([2](ch01.html#idm46582509922000))，其中有一个`ob_size`字段，用于保存集合中的项数。因此，如果`my_object`是这些内置类型之一的实例，那么`len(my_object)`会直接获取`ob_size`字段的值，这比调用一个方法要快得多。
- en: More often than not, the special method call is implicit. For example, the statement
    `for i in x:` actually causes the invocation of `iter(x)`, which in turn may call
    `x.__iter__()` if that is available, or use `x.__getitem__()`, as in the `FrenchDeck`
    example.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，特殊方法的调用是隐式的。例如，语句`for i in x:`实际上会调用`iter(x)`，如果`x`有`__iter__()`方法，则会调用它，否则会像`FrenchDeck`示例那样使用`x.__getitem__()`。
- en: Normally, your code should not have many direct calls to special methods. Unless
    you are doing a lot of metaprogramming, you should be implementing special methods
    more often than invoking them explicitly. The only special method that is frequently
    called by user code directly is `__init__` to invoke the initializer of the superclass
    in your own `__init__` implementation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你的代码不应该有太多直接调用特殊方法的地方。除非你在做大量的元编程，否则你应该更多地实现特殊方法，而不是显式地调用它们。唯一经常被用户代码直接调用的特殊方法是`__init__`，用于在你自己的`__init__`实现中调用超类的初始化方法。
- en: If you need to invoke a special method, it is usually better to call the related
    built-in function (e.g., `len`, `iter`, `str`, etc.). These built-ins call the
    corresponding special method, but often provide other services and—for built-in
    types—are faster than method calls. See, for example, [“Using iter with a Callable”](ch17.html#iter_closer_look)
    in [Chapter 17](ch17.html#iterables2generators).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要调用一个特殊方法，通常最好调用相关的内置函数（例如`len`、`iter`、`str`等）。这些内置函数会调用相应的特殊方法，但通常还提供其他服务，并且对于内置类型来说，比方法调用更快。例如，参见[第
    17 章](ch17.html#iterables2generators)中的["与可调用对象一起使用 iter"](ch17.html#iter_closer_look)。
- en: 'In the next sections, we’ll see some of the most important uses of special
    methods:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到特殊方法的一些最重要的用途：
- en: Emulating numeric types
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟数值类型
- en: String representation of objects
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的字符串表示
- en: Boolean value of an object
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的布尔值
- en: Implementing collections
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现集合类
- en: Emulating Numeric Types
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟数值类型
- en: Several special methods allow user objects to respond to operators such as `+`.
    We will cover that in more detail in [Chapter 16](ch16.html#operator_overloading),
    but here our goal is to further illustrate the use of special methods through
    another simple example.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 几个特殊方法允许用户对象响应诸如`+`之类的运算符。我们将在[第 16 章](ch16.html#operator_overloading)中更详细地介绍这一点，但这里我们的目标是通过另一个简单的例子来进一步说明特殊方法的使用。
- en: We will implement a class to represent two-dimensional vectors—that is, Euclidean
    vectors like those used in math and physics (see [Figure 1-1](#vectors_fig)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个类来表示二维向量——即数学和物理中使用的欧几里得向量（参见[图 1-1](#vectors_fig)）。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The built-in `complex` type can be used to represent two-dimensional vectors,
    but our class can be extended to represent *n*-dimensional vectors. We will do
    that in [Chapter 17](ch17.html#iterables2generators).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`complex`类型可以用来表示二维向量，但我们的类可以扩展为表示*n*维向量。我们将在[第 17 章](ch17.html#iterables2generators)中实现这一点。
- en: '![2D vectors](assets/flpy_0101.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![二维向量](assets/flpy_0101.png)'
- en: Figure 1-1\. Example of two-dimensional vector addition; Vector(2, 4) + Vector(2,
    1) results in Vector(4, 5).
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 二维向量加法示例；Vector(2, 4) + Vector(2, 1) 的结果是 Vector(4, 5)。
- en: 'We will start designing the API for such a class by writing a simulated console
    session that we can use later as a doctest. The following snippet tests the vector
    addition pictured in [Figure 1-1](#vectors_fig):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过编写一个模拟控制台会话来开始设计这个类的 API，稍后我们可以将其用作文档测试。下面的代码片段测试了[图 1-1](#vectors_fig)
    中所示的向量加法：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note how the `+` operator results in a new `Vector`, displayed in a friendly
    format at the console.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`+`运算符如何生成一个新的`Vector`，并以友好的格式显示在控制台上。
- en: 'The `abs` built-in function returns the absolute value of integers and floats,
    and the magnitude of `complex` numbers, so to be consistent, our API also uses
    `abs` to calculate the magnitude of a vector:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数`abs`返回整数和浮点数的绝对值，以及`complex`数的模，所以为了保持一致，我们的 API 也使用`abs`来计算向量的模：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also implement the `*` operator to perform scalar multiplication (i.e.,
    multiplying a vector by a number to make a new vector with the same direction
    and a multiplied magnitude):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以实现`*`运算符来执行标量乘法（即，将一个向量乘以一个数来得到一个新的向量，其方向相同，但大小被乘以该数）：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Example 1-2](#ex_vector2d) is a `Vector` class implementing the operations
    just described, through the use of the special methods `__repr__`, `__abs__`,
    `__add__`, and `__mul__`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例1-2](#ex_vector2d)是一个`Vector`类，通过使用特殊方法`__repr__`、`__abs__`、`__add__`和`__mul__`实现了刚才描述的操作。'
- en: Example 1-2\. A simple two-dimensional vector class
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-2\. 一个简单的二维向量类
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We implemented five special methods in addition to the familiar `__init__`.
    Note that none of them is directly called within the class or in the typical usage
    of the class illustrated by the doctests. As mentioned before, the Python interpreter
    is the only frequent caller of most special methods.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了熟悉的`__init__`之外，我们还实现了五个特殊方法。请注意，在类中或doctests所说明的类的典型用法中，没有一个方法是直接调用的。如前所述，Python解释器是大多数特殊方法的唯一频繁调用者。
- en: '[Example 1-2](#ex_vector2d) implements two operators: `+` and `*`, to show
    basic usage of `__add__` and `__mul__`. In both cases, the methods create and
    return a new instance of `Vector`, and do not modify either operand—`self` or
    `other` are merely read. This is the expected behavior of infix operators: to
    create new objects and not touch their operands. I will have a lot more to say
    about that in [Chapter 16](ch16.html#operator_overloading).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例1-2](#ex_vector2d)实现了两个操作符：`+`和`*`，以展示`__add__`和`__mul__`的基本用法。在这两种情况下，方法都会创建并返回`Vector`的新实例，而不会修改任何一个操作数——`self`或`other`只是被读取。这是中缀操作符的预期行为：创建新对象而不接触其操作数。我将在[第16章](ch16.html#operator_overloading)中对此有更多说明。'
- en: Warning
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As implemented, [Example 1-2](#ex_vector2d) allows multiplying a `Vector` by
    a number, but not a number by a `Vector`, which violates the commutative property
    of scalar multiplication. We will fix that with the special method `__rmul__`
    in [Chapter 16](ch16.html#operator_overloading).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 按照实现，[示例1-2](#ex_vector2d)允许`Vector`乘以一个数，但不允许数乘以`Vector`，这违反了标量乘法的交换律。我们将在[第16章](ch16.html#operator_overloading)中用特殊方法`__rmul__`来解决这个问题。
- en: In the following sections, we discuss the other special methods in `Vector`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将讨论`Vector`中的其他特殊方法。
- en: String Representation
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串表示
- en: The `__repr__` special method is called by the `repr` built-in to get the string
    representation of the object for inspection. Without a custom `__repr__`, Python’s
    console would display a `Vector` instance `<Vector object at 0x10e100070>`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`repr`函数会调用特殊方法`__repr__`来获取对象的字符串表示，以便检查。如果没有自定义`__repr__`，Python控制台会显示`Vector`实例`<Vector
    object at 0x10e100070>`。
- en: The interactive console and debugger call `repr` on the results of the expressions
    evaluated, as does the `%r` placeholder in classic formatting with the `%` operator,
    and the `!r` conversion field in the new [format string syntax](https://fpy.li/1-4)
    used in *f-strings* the `str.format` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式控制台和调试器对计算结果调用`repr`，经典的`%`操作符格式化中的`%r`占位符以及*f-strings*中新的[格式字符串语法](https://fpy.li/1-4)使用的`!r`转换字段中的`str.format`方法也是如此。
- en: Note that the *f-string* in our `__repr__` uses `!r` to get the standard representation
    of the attributes to be displayed. This is good practice, because it shows the
    crucial difference between `Vector(1, 2)` and `Vector('1', '2')`—the latter would
    not work in the context of this example, because the constructor’s arguments should
    be numbers, not `str`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们`__repr__`中的*f-string*使用`!r`来获取要显示的属性的标准表示。这是个好习惯，因为它展示了`Vector(1, 2)`和`Vector('1',
    '2')`之间的关键区别——在这个例子中，后者不起作用，因为构造函数的参数应该是数字，而不是`str`。
- en: The string returned by `__repr__` should be unambiguous and, if possible, match
    the source code necessary to re-create the represented object. That is why our
    `Vector` representation looks like calling the constructor of the class (e.g.,
    `Vector(3, 4)`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`__repr__`返回的字符串应该是明确的，如果可能的话，应该与重新创建所表示对象所需的源代码相匹配。这就是为什么我们的`Vector`表示看起来像调用类的构造函数（例如`Vector(3,
    4)`）。'
- en: In contrast, `__str__` is called by the `str()` built-in and implicitly used
    by the `print` function. It should return a string suitable for display to end
    users.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，内置的`str()`函数会调用`__str__`，`print`函数也会隐式地使用它。它应该返回一个适合向终端用户显示的字符串。
- en: Sometimes same string returned by `__repr__` is user-friendly, and you don’t
    need to code `__str__` because the implementation inherited from the `object`
    class calls `__repr__` as a fallback. [Example 5-2](ch05.html#coord_tuple_ex)
    is one of several examples in this book with a custom `__str__`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时`__repr__`返回的相同字符串对用户友好，你不需要编写`__str__`，因为从`object`类继承的实现会调用`__repr__`作为后备。[示例5-2](ch05.html#coord_tuple_ex)是本书中有自定义`__str__`的几个示例之一。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Programmers with prior experience in languages with a `toString` method tend
    to implement `__str__` and not `__repr__`. If you only implement one of these
    special methods in Python, choose `__repr__`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他语言`toString`方法使用经验的程序员倾向于实现`__str__`而不是`__repr__`。如果你在Python中只实现这两个特殊方法之一，选择`__repr__`。
- en: '[“What is the difference between `__str__` and `__repr__` in Python?”](https://fpy.li/1-5)
    is a Stack Overflow question with excellent contributions from Pythonistas Alex
    Martelli and Martijn Pieters.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '["Python中`__str__`和`__repr__`有什么区别？"](https://fpy.li/1-5)是一个Stack Overflow的问题，Python专家Alex
    Martelli和Martijn Pieters对此做出了精彩的贡献。'
- en: Boolean Value of a Custom Type
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义类型的布尔值
- en: Although Python has a `bool` type, it accepts any object in a Boolean context,
    such as the expression controlling an `if` or `while` statement, or as operands
    to `and`, `or`, and `not`. To determine whether a value `x` is *truthy* or *falsy*,
    Python applies `bool(x)`, which returns either `True` or `False`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Python有`bool`类型，但它在布尔上下文中接受任何对象，例如控制`if`或`while`语句的表达式，或者作为`and`、`or`和`not`的操作数。为了确定一个值`x`是*truthy*还是*falsy*，Python会应用`bool(x)`，它返回`True`或`False`。
- en: By default, instances of user-defined classes are considered truthy, unless
    either `__bool__` or `__len__` is implemented. Basically, `bool(x)` calls `x.__bool__()`
    and uses the result. If `__bool__` is not implemented, Python tries to invoke
    `x.__len__()`, and if that returns zero, `bool` returns `False`. Otherwise `bool`
    returns `True`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，用户定义类的实例被视为真值，除非实现了`__bool__`或`__len__`。基本上，`bool(x)`调用`x.__bool__()`并使用结果。如果没有实现`__bool__`，Python会尝试调用`x.__len__()`，如果返回零，`bool`返回`False`。否则`bool`返回`True`。
- en: 'Our implementation of `__bool__` is conceptually simple: it returns `False`
    if the magnitude of the vector is zero, `True` otherwise. We convert the magnitude
    to a Boolean using `bool(abs(self))` because `__bool__` is expected to return
    a Boolean. Outside of `__bool__` methods, it is rarely necessary to call `bool()`
    explicitly, because any object can be used in a Boolean context.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`__bool__`的实现在概念上很简单：如果向量的大小为零，则返回`False`，否则返回`True`。我们使用`bool(abs(self))`将大小转换为布尔值，因为`__bool__`期望返回布尔值。在`__bool__`方法之外，很少需要显式调用`bool()`，因为任何对象都可以用在布尔上下文中。
- en: Note how the special method `__bool__` allows your objects to follow the truth
    value testing rules defined in the [“Built-in Types” chapter](https://fpy.li/1-6)
    of *The Python Standard Library* documentation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意特殊方法`__bool__`如何允许你的对象遵循*Python标准库*文档的["内置类型"章节](https://fpy.li/1-6)中定义的真值测试规则。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'A faster implementation of `Vector.__bool__` is this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector.__bool__`的更快实现是：'
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is harder to read, but avoids the trip through `abs`, `__abs__`, the squares,
    and square root. The explicit conversion to `bool` is needed because `__bool__`
    must return a Boolean, and `or` returns either operand as is: `x or y` evaluates
    to `x` if that is truthy, otherwise the result is `y`, whatever that is.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这更难阅读，但避免了通过`abs`、`__abs__`、平方和平方根的旅程。需要显式转换为`bool`，因为`__bool__`必须返回布尔值，而`or`会原样返回任一操作数：如果`x`为真值，则`x
    or y`求值为`x`，否则结果为`y`，无论是什么。
- en: Collection API
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Collection API
- en: '[Figure 1-2](#collection_uml) documents the interfaces of the essential collection
    types in the language. All the classes in the diagram are ABCs—*abstract base
    classes*. ABCs and the `collections.abc` module are covered in [Chapter 13](ch13.html#ifaces_prot_abc).
    The goal of this brief section is to give a panoramic view of Python’s most important
    collection interfaces, showing how they are built from special methods.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-2](#collection_uml)展示了该语言中基本集合类型的接口。图中所有的类都是*抽象基类*（ABC）。[第13章](ch13.html#ifaces_prot_abc)涵盖了ABC和`collections.abc`模块。本节的目标是全面概览Python最重要的集合接口，展示它们是如何由特殊方法构建而成的。'
- en: '![UML class diagram with all superclasses and some subclasses of `abc.Collection`](assets/flpy_0102.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![`abc.Collection`的所有超类和一些子类的UML类图](assets/flpy_0102.png)  '
- en: Figure 1-2\. UML class diagram with fundamental collection types. Method names
    in *italic* are abstract, so they must be implemented by concrete subclasses such
    as `list` and `dict`. The remaining methods have concrete implementations, therefore
    subclasses can inherit them.
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2. 包含基本集合类型的UML类图。*斜体*方法名是抽象的，因此必须由具体子类如`list`和`dict`实现。其余方法有具体实现，因此子类可以继承它们。
- en: 'Each of the top ABCs has a single special method. The `Collection` ABC (new
    in Python 3.6) unifies the three essential interfaces that every collection should
    implement:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个顶层ABC都有一个单独的特殊方法。`Collection` ABC（Python 3.6新增）统一了每个集合应该实现的三个基本接口：
- en: '`Iterable` to support `for`, [unpacking](https://fpy.li/1-7), and other forms
    of iteration'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterable`支持`for`、[解包](https://fpy.li/1-7)和其他形式的迭代'
- en: '`Sized` to support the `len` built-in function'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sized`支持内置函数`len`'
- en: '`Container` to support the `in` operator'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Container`支持`in`运算符'
- en: Python does not require concrete classes to actually inherit from any of these
    ABCs. Any class that implements `__len__` satisfies the `Sized` interface.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Python并不要求具体类实际继承任何这些ABC。任何实现了`__len__`的类都满足`Sized`接口。
- en: 'Three very important specializations of `Collection` are:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`的三个非常重要的特化是：'
- en: '`Sequence`, formalizing the interface of built-ins like `list` and `str`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sequence`，形式化了`list`和`str`等内置类型的接口'
- en: '`Mapping`, implemented by `dict`, `collections.defaultdict`, etc.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mapping`，由`dict`、`collections.defaultdict`等实现。'
- en: '`Set`, the interface of the `set` and `frozenset` built-in types'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set`，内置类型`set`和`frozenset`的接口'
- en: Only `Sequence` is `Reversible`, because sequences support arbitrary ordering
    of their contents, while mappings and sets do not.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`Sequence`是`Reversible`的，因为序列支持任意顺序的内容，而映射和集合则不支持。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Since Python 3.7, the `dict` type is officially “ordered,” but that only means
    that the key insertion order is preserved. You cannot rearrange the keys in a
    `dict` however you like.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.7开始，`dict`类型正式"有序"，但这只意味着保留了键的插入顺序。你不能随意重新排列`dict`中的键。
- en: All the special methods in the `Set` ABC implement infix operators. For example,
    `a & b` computes the intersection of sets `a` and `b`, and is implemented in the
    `__and__` special method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set` ABC中的所有特殊方法都实现了中缀运算符。例如，`a & b`计算集合`a`和`b`的交集，在`__and__`特殊方法中实现。'
- en: The next two chapters will cover standard library sequences, mappings, and sets
    in detail.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来两章将详细介绍标准库序列、映射和集合。
- en: Now let’s consider the major categories of special methods defined in the Python
    Data Model.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑Python数据模型中定义的主要特殊方法类别。
- en: Overview of Special Methods
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊方法概览
- en: The [“Data Model” chapter](https://fpy.li/dtmodel) of *The Python Language Reference*
    lists more than 80 special method names. More than half of them implement arithmetic,
    bitwise, and comparison operators. As an overview of what is available, see the
    following tables.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python语言参考*的["数据模型"章节](https://fpy.li/dtmodel)列出了80多个特殊方法名。其中一半以上实现了算术、位运算和比较运算符。关于可用内容的概览，请参见下表。'
- en: '[Table 1-1](#special_names_tbl) shows special method names, excluding those
    used to implement infix operators or core math functions like `abs`. Most of these
    methods will be covered throughout the book, including the most recent additions:
    asynchronous special methods such as `__anext__` (added in Python 3.5), and the
    class customization hook, `__init_subclass__` (from Python 3.6).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-1](#special_names_tbl) 展示了特殊方法名，不包括用于实现中缀运算符或核心数学函数（如`abs`）的方法名。本书将涵盖其中大部分方法，包括最新增加的：异步特殊方法如
    `__anext__`（Python 3.5 新增），以及类定制钩子 `__init_subclass__`（Python 3.6 新增）。'
- en: Table 1-1\. Special method names (operators excluded)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-1. 特殊方法名（不包括运算符）
- en: '| Category | Method names |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 方法名 |'
- en: '| --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| String/bytes representation | `__repr__ __str__ __format__ __bytes__ __fspath__`
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 字符串/字节表示 | `__repr__ __str__ __format__ __bytes__ __fspath__` |'
- en: '| Conversion to number | `__bool__ __complex__ __int__ __float__ __hash__ __index__`
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 转换为数字 | `__bool__ __complex__ __int__ __float__ __hash__ __index__` |'
- en: '| Emulating collections | `__len__ __getitem__ __setitem__ __delitem__` `__contains__`
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 模拟集合 | `__len__ __getitem__ __setitem__ __delitem__` `__contains__` |'
- en: '| Iteration | `__iter__ __aiter__ __next__ __anext__ __reversed__` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 迭代 | `__iter__ __aiter__ __next__ __anext__ __reversed__` |'
- en: '| Callable or coroutine execution | `__call__ __await__` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 可调用对象或协程执行 | `__call__ __await__` |'
- en: '| Context management | `__enter__ __exit__ __aexit__ __aenter__` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 上下文管理 | `__enter__ __exit__ __aexit__ __aenter__` |'
- en: '| Instance creation and destruction | `__new__ __init__ __del__` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 实例创建和销毁 | `__new__ __init__ __del__` |'
- en: '| Attribute management | `__getattr__ __getattribute__ __setattr__ __delattr__
    __dir__` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 属性管理 | `__getattr__ __getattribute__ __setattr__ __delattr__ __dir__` |'
- en: '| Attribute descriptors | `__get__ __set__ __delete__ __set_name__` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 属性描述符 | `__get__ __set__ __delete__ __set_name__` |'
- en: '| Abstract base classes | `__instancecheck__ __subclasscheck__` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 抽象基类 | `__instancecheck__ __subclasscheck__` |'
- en: '| Class metaprogramming | `__prepare__ __init_subclass__ __class_getitem__
    __mro_entries__` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 类元编程 | `__prepare__ __init_subclass__ __class_getitem__ __mro_entries__`
    |'
- en: Infix and numerical operators are supported by the special methods listed in
    [Table 1-2](#special_operators_tbl). Here the most recent names are `__matmul__`,
    `__rmatmul__`, and `__imatmul__`, added in Python 3.5 to support the use of `@`
    as an infix operator for matrix multiplication, as we’ll see in [Chapter 16](ch16.html#operator_overloading).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-2](#special_operators_tbl) 列出了中缀和数值运算符支持的特殊方法。其中最新的名称是 `__matmul__`、`__rmatmul__`
    和 `__imatmul__`，于 Python 3.5 新增，用于支持 `@` 作为矩阵乘法的中缀运算符，我们将在[第 16 章](ch16.html#operator_overloading)看到。'
- en: Table 1-2\. Special method names and symbols for operators
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-2. 运算符的特殊方法名和符号
- en: '| Operator category | Symbols | Method names |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 运算符类别 | 符号 | 方法名 |'
- en: '| --- | --- | --- |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Unary numeric | `- + abs()` | `__neg__ __pos__ __abs__` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 一元数值运算 | `- + abs()` | `__neg__ __pos__ __abs__` |'
- en: '| Rich comparison | `< <= == != > >=` | `__lt__ __le__ __eq__ __ne__ __gt__
    __ge__` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 富比较 | `< <= == != > >=` | `__lt__ __le__ __eq__ __ne__ __gt__ __ge__` |'
- en: '| Arithmetic | `+ - * / // % @ divmod() round() ** pow()` | `__add__ __sub__
    __mul__` `__truediv__` `__floordiv__ __mod__` `__matmul__` `__divmod__ __round__
    __pow__` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 算术运算 | `+ - * / // % @ divmod() round() ** pow()` | `__add__ __sub__ __mul__`
    `__truediv__` `__floordiv__ __mod__` `__matmul__` `__divmod__ __round__ __pow__`
    |'
- en: '| Reversed arithmetic | (arithmetic operators with swapped operands) | `__radd__
    __rsub__ __rmul__ __rtruediv__ __rfloordiv__ __rmod__ __rmatmul__ __rdivmod__
    __rpow__` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 反向算术运算 | （交换运算数的算术运算符） | `__radd__ __rsub__ __rmul__ __rtruediv__ __rfloordiv__
    __rmod__ __rmatmul__ __rdivmod__ __rpow__` |'
- en: '| Augmented assignment arithmetic | `+= -= *= /= //= %= @= **=` | `__iadd__
    __isub__ __imul__ __itruediv__ __ifloordiv__ __imod__ __imatmul__ __ipow__` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 增强赋值算术运算 | `+= -= *= /= //= %= @= **=` | `__iadd__ __isub__ __imul__ __itruediv__
    __ifloordiv__ __imod__ __imatmul__ __ipow__` |'
- en: '| Bitwise | `& &#124; ^ << >> ~` | `__and__ __or__ __xor__ __lshift__ __rshift__
    __invert__` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 位运算 | `& &#124; ^ << >> ~` | `__and__ __or__ __xor__ __lshift__ __rshift__
    __invert__` |'
- en: '| Reversed bitwise | (bitwise operators with swapped operands) | `__rand__
    __ror__ __rxor__ __rlshift__ __rrshift__` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 反向位运算 | （交换运算数的位运算符） | `__rand__ __ror__ __rxor__ __rlshift__ __rrshift__`
    |'
- en: '| Augmented assignment bitwise | `&= &#124;= ^= <<= >>=` | `__iand__ __ior__
    __ixor__ __ilshift__ __irshift__` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 增强赋值位运算 | `&= &#124;= ^= <<= >>=` | `__iand__ __ior__ __ixor__ __ilshift__
    __irshift__` |'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Python calls a reversed operator special method on the second operand when the
    corresponding special method on the first operand cannot be used. Augmented assignments
    are shortcuts combining an infix operator with variable assignment, e.g., `a +=
    b`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一个操作数的相应特殊方法无法使用时，Python 会在第二个操作数上调用反向运算符特殊方法。增强赋值是将中缀运算符与变量赋值组合的简写形式，例如 `a
    += b`。
- en: '[Chapter 16](ch16.html#operator_overloading) explains reversed operators and
    augmented assignment in detail.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 16 章](ch16.html#operator_overloading)详细解释了反向运算符和增强赋值。'
- en: Why len Is Not a Method
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么 len 不是一个方法
- en: 'I asked this question to core developer Raymond Hettinger in 2013, and the
    key to his answer was a quote from [“The Zen of Python”](https://fpy.li/1-8):
    “practicality beats purity.” In [“How Special Methods Are Used”](#how_special_used),
    I described how `len(x)` runs very fast when `x` is an instance of a built-in
    type. No method is called for the built-in objects of CPython: the length is simply
    read from a field in a C struct. Getting the number of items in a collection is
    a common operation and must work efficiently for such basic and diverse types
    as `str`, `list`, `memoryview`, and so on.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 2013 年向核心开发者 Raymond Hettinger 提出了这个问题，他回答的关键是引用了["Python之禅"](https://fpy.li/1-8)中的一句话："实用性胜过纯粹性。"在["特殊方法的使用方式"](#how_special_used)中，我描述了当
    `x` 是内置类型的实例时，`len(x)` 的运行速度非常快。对于 CPython 的内置对象，不调用任何方法：长度直接从 C 结构体中的一个字段读取。获取集合中的项数是一种常见操作，必须为
    `str`、`list`、`memoryview` 等基本且多样的类型高效地工作。
- en: 'In other words, `len` is not called as a method because it gets special treatment
    as part of the Python Data Model, just like `abs`. But thanks to the special method
    `__len__`, you can also make `len` work with your own custom objects. This is
    a fair compromise between the need for efficient built-in objects and the consistency
    of the language. Also from “The Zen of Python”: “Special cases aren’t special
    enough to break the rules.”'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`len` 之所以不作为方法调用，是因为它作为 Python 数据模型的一部分，与 `abs` 一样得到特殊对待。但是，借助特殊方法 `__len__`，你也可以让
    `len` 适用于你自己的自定义对象。这在内置对象的效率需求和语言的一致性之间取得了合理的平衡。正如"Python之禅"所言："特例不足以打破规则。"
- en: Note
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you think of `abs` and `len` as unary operators, you may be more inclined
    to forgive their functional look and feel, as opposed to the method call syntax
    one might expect in an object-oriented language. In fact, the ABC language—a direct
    ancestor of Python that pioneered many of its features—had an `#` operator that
    was the equivalent of `len` (you’d write `#s`). When used as an infix operator,
    written `x#s`, it counted the occurrences of `x` in `s`, which in Python you get
    as `s.count(x)`, for any sequence `s`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为 `abs` 和 `len` 是一元运算符，那么相比于在面向对象语言中期望的方法调用语法，你可能更倾向于原谅它们的函数外观和感觉。事实上，ABC
    语言（Python 的直接祖先，开创了其许多特性）有一个相当于 `len` 的 `#` 运算符（你会写成 `#s`）。当用作中缀运算符时，写作 `x#s`，它会计算
    `x` 在 `s` 中出现的次数，在 Python 中，对于任何序列 `s`，都可以用 `s.count(x)` 获得。
- en: Chapter Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: By implementing special methods, your objects can behave like the built-in types,
    enabling the expressive coding style the community considers Pythonic.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现特殊方法，你的对象可以表现得像内置类型一样，从而实现社区认为 Pythonic 的表达性编码风格。
- en: A basic requirement for a Python object is to provide usable string representations
    of itself, one used for debugging and logging, another for presentation to end
    users. That is why the special methods `__repr__` and `__str__` exist in the data
    model.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对象的一个基本要求是提供自身的可用字符串表示，一个用于调试和日志记录，另一个用于呈现给终端用户。这就是为什么数据模型中存在特殊方法 `__repr__`
    和 `__str__` 的原因。
- en: Emulating sequences, as shown with the `FrenchDeck` example, is one of the most
    common uses of the special methods. For example, database libraries often return
    query results wrapped in sequence-like collections. Making the most of existing
    sequence types is the subject of [Chapter 2](ch02.html#sequences). Implementing
    your own sequences will be covered in [Chapter 12](ch12.html#user_defined_sequences),
    when we create a multidimensional extension of the `Vector` class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `FrenchDeck` 示例所展示的，模拟序列是特殊方法最常见的用途之一。例如，数据库库通常以类序列集合的形式返回查询结果。[第 2 章](ch02.html#sequences)的主题是充分利用现有的序列类型。[第
    12 章](ch12.html#user_defined_sequences)将介绍如何实现自己的序列，届时我们将创建 `Vector` 类的多维扩展。
- en: Thanks to operator overloading, Python offers a rich selection of numeric types,
    from the built-ins to `decimal.Decimal` and `fractions.Fraction`, all supporting
    infix arithmetic operators. The *NumPy* data science libraries support infix operators
    with matrices and tensors. Implementing operators—including reversed operators
    and augmented assignment—will be shown in [Chapter 16](ch16.html#operator_overloading)
    via enhancements of the `Vector` example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '得益于运算符重载，Python 提供了丰富的数值类型选择，从内置类型到 `decimal.Decimal`、`fractions.Fraction`，都支持中缀算术运算符。*NumPy*
    数据科学库支持对矩阵和张量使用中缀运算符。[第 16 章](ch16.html#operator_overloading)将通过增强 `Vector` 示例来演示如何实现运算符，包括反向运算符和增强赋值。 '
- en: The use and implementation of the majority of the remaining special methods
    of the Python Data Model are covered throughout this book.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本书贯穿始终介绍了 Python 数据模型中大多数剩余特殊方法的使用和实现。
- en: Further Reading
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延伸阅读
- en: The [“Data Model” chapter](https://fpy.li/dtmodel) of *The Python Language Reference*
    is the canonical source for the subject of this chapter and much of this book.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '["数据模型"一章](https://fpy.li/dtmodel)，摘自*Python 语言参考手册*，是本章以及本书大部分内容的权威来源。'
- en: '[*Python in a Nutshell*, 3rd ed.](https://fpy.li/pynut3) by Alex Martelli,
    Anna Ravenscroft, and Steve Holden (O’Reilly) has excellent coverage of the data
    model. Their description of the mechanics of attribute access is the most authoritative
    I’ve seen apart from the actual C source code of CPython. Martelli is also a prolific
    contributor to Stack Overflow, with more than 6,200 answers posted. See his user
    profile at [Stack Overflow](https://fpy.li/1-9).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Alex Martelli、Anna Ravenscroft 和 Steve Holden 合著的[*Python in a Nutshell*, 3rd
    ed.](https://fpy.li/pynut3)（O'Reilly 出版）对数据模型有极佳的阐述。除了实际的 CPython C 源代码外，他们对属性访问机制的描述是我所见过最权威的。Martelli
    也是 Stack Overflow 上的高产贡献者，贴出了超过 6,200 个答案。可以在 [Stack Overflow](https://fpy.li/1-9)
    上看到他的用户资料。
- en: 'David Beazley has two books covering the data model in detail in the context
    of Python 3: [*Python Essential Reference*](https://dabeaz.com/per.html), 4th
    ed. (Addison-Wesley), and [*Python Cookbook*, 3rd ed.](https://fpy.li/pycook3)
    (O’Reilly), coauthored with Brian K. Jones.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: David Beazley 有两本书在 Python 3 的背景下详细介绍了数据模型：[*Python Essential Reference*](https://dabeaz.com/per.html)，第4版（Addison-Wesley
    出版），以及与 Brian K. Jones 合著的[*Python Cookbook*，第3版](https://fpy.li/pycook3)（O'Reilly
    出版）。
- en: '[*The Art of the Metaobject Protocol*](https://mitpress.mit.edu/books/art-metaobject-protocol)
    (MIT Press) by Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow explains
    the concept of a metaobject protocol, of which the Python Data Model is one example.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Gregor Kiczales、Jim des Rivieres 和 Daniel G. Bobrow 合著的[*The Art of the Metaobject
    Protocol*](https://mitpress.mit.edu/books/art-metaobject-protocol)（MIT 出版社）解释了元对象协议的概念，Python
    数据模型就是其中一个例子。
- en: ^([1](ch01.html#idm46582510883648-marker)) [“Story of Jython”](https://fpy.li/1-1),
    written as a foreword to [*Jython Essentials*](https://fpy.li/1-2) by Samuele
    Pedroni and Noel Rappin (O’Reilly).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.html#idm46582510883648-marker)) ["Jython 的故事"](https://fpy.li/1-1)，作为
    Samuele Pedroni 和 Noel Rappin 合著的 [*Jython Essentials*](https://fpy.li/1-2)（O'Reilly
    出版）的前言。
- en: ^([2](ch01.html#idm46582509922000-marker)) A C struct is a record type with
    named fields.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.html#idm46582509922000-marker)) C 结构体是一种带有命名字段的记录类型。
