- en: 'Chapter 15\. Concurrency: Threads and Processes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。并发：线程和进程
- en: '*Processes* are instances of running programs that the operating system protects
    from one another. Processes that want to communicate must explicitly arrange to
    do so via *interprocess communication* (IPC) mechanisms, and/or via files (covered
    in [Chapter 11](ch11.xhtml#file_and_text_operations)), databases (covered in [Chapter 12](ch12.xhtml#persistence_and_databases)),
    or network interfaces (covered in [Chapter 18](ch18.xhtml#networking_basics)).
    The general way in which processes communicate using data storage mechanisms such
    as files and databases is that one process writes data, and another process later
    reads that data back. This chapter covers programming with processes, including
    the Python standard library modules subprocess and multiprocessing; the process-related
    parts of the module os, including simple IPC by means of *pipes*; a cross-platform
    IPC mechanism known as *memory-mapped files*, available in the module mmap; 3.8+
    and the multiprocessing.shared_memory module.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程*是操作系统中彼此保护的运行程序的实例。想要通信的进程必须明确通过*进程间通信*（IPC）机制，以及/或通过文件（在[第11章](ch11.xhtml#file_and_text_operations)讨论）、数据库（在[第12章](ch12.xhtml#persistence_and_databases)讨论）、或网络接口（在[第18章](ch18.xhtml#networking_basics)讨论）来安排通信。进程之间使用文件和数据库等数据存储机制通信的一般方式是一个进程写入数据，另一个进程稍后读取该数据。本章介绍了处理进程的编程，包括Python标准库模块subprocess和multiprocessing；模块os中与进程相关的部分，包括通过*管道*进行简单IPC；一种称为*内存映射文件*的跨平台IPC机制，在模块mmap中可用；以及3.8+及multiprocessing.shared_memory模块。'
- en: A *thread* (originally called a “lightweight process”) is a flow of control
    that shares global state (memory) with other threads inside a single process;
    all threads appear to execute simultaneously, although they may in fact be “taking
    turns” on one or more processors/cores. Threads are far from easy to master, and
    multithreaded programs are often hard to test and to debug; however, as covered
    in [“Threading, Multiprocessing, or Async Programming?”](#should_you_use_threadingcomma_multiproc),
    when used appropriately, multithreading may improve performance in comparison
    to single-threaded programming. This chapter covers various facilities Python
    provides for dealing with threads, including the threading, queue, and concurrent.futures
    modules.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程*（最初称为“轻量级进程”）是与单个进程内的其他线程共享全局状态（内存）的控制流；所有线程看起来同时执行，尽管它们实际上可能在一个或多个处理器/核心上“轮流”执行。线程远非易于掌握，而多线程程序通常难以测试和调试；然而，如[“线程、多进程还是异步编程？”](#should_you_use_threadingcomma_multiproc)所述，适当使用多线程时，与单线程编程相比性能可能会提高。本章介绍了Python提供的处理线程的各种功能，包括线程、队列和concurrent.futures模块。'
- en: Another mechanism for sharing control among multiple activities within a single
    process is what has become known as *asynchronous* (or *async*) programming. When
    you are reading Python code, the presence of the keywords **async** and **await**
    indicate it is asynchronous. Such code depends on an *event loop*, which is, broadly
    speaking, the equivalent of the thread switcher used within a process. When the
    event loop is the scheduler, each execution of an asynchronous function becomes
    a *task*, which roughly corresponds with a *thread* in a multithreaded program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个进程内共享控制的另一种机制是所谓的*异步*（或*async*）编程。当你阅读Python代码时，关键字**async**和**await**的存在表明它是异步的。这样的代码依赖于*事件循环*，它大致相当于进程内部使用的线程切换器。当事件循环是调度器时，每次执行异步函数变成一个*任务*，与多线程程序中的*线程*大致对应。
- en: 'Both process scheduling and thread switching are *preemptive*, which is to
    say that the scheduler or switcher has control of the CPU and determines when
    any particular piece of code gets to run. Asynchronous programming, however, is
    *cooperative*: each task, once execution begins, can run for as long as it chooses
    before indicating to the event loop that it is prepared to give up control (usually
    because it is awaiting the completion of some other asynchronous task, most often
    an I/O-focused one).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 进程调度和线程切换都是*抢占式*的，这意味着调度器或切换器控制CPU，并确定何时运行任何特定的代码。然而，异步编程是*协作式*的：每个任务一旦开始执行，可以在选择放弃控制之前运行多长时间（通常是因为正在等待完成某些其他异步任务，通常是面向I/O的任务）。
- en: 'Although async programming offers great flexibility to optimize certain classes
    of problems, it is a programming paradigm that many programmers are unfamiliar
    with. Because of its cooperative nature, incautious async programming can lead
    to *deadlocks*, and infinite loops can starve other tasks of processor time: figuring
    out how to avoid deadlocks creates significant extra cognitive load for the average
    programmer. We do not cover asynchronous programming, including the module [asyncio](https://oreil.ly/zRZKX),
    further in this volume, feeling that it is a complex enough topic to be well worth
    a book on its own.^([1](ch15.xhtml#ch01fn116))'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管异步编程提供了优化某些问题类别的灵活性，但这是许多程序员不熟悉的编程范例。由于其协作性质，不慎的异步编程可能导致*死锁*，而无限循环则可能使其他任务被剥夺处理器时间：弄清楚如何避免死锁为普通程序员增加了显著的认知负担。我们在本卷中不进一步讨论异步编程，包括模块[asyncio](https://oreil.ly/zRZKX)，认为这是一个足够复杂的主题，值得单独撰写一本书进行探讨。^([1](ch15.xhtml#ch01fn116))
- en: Network mechanisms are well suited for IPC, and work just as effectively between
    processes running on different nodes of a network as between ones that run on
    the same node. The multiprocessing module supplies some mechanisms that are suitable
    for IPC over a network; [Chapter 18](ch18.xhtml#networking_basics) covers low-level
    network mechanisms that provide a basis for IPC. Other, higher-level mechanisms
    for *distributed computing* ([CORBA](https://www.ibm.com/docs/en/integration-bus/9.0.0?topic=corba-common-object-request-broker-architecture),
    [DCOM/COM+](https://whatis.techtarget.com/definition/DCOM-Distributed-Component-Object-Model#:~:text=DCOM%20(Distributed%20Component%20Object%20Model)%20is%20a%20set%20of%20Microsoft,other%20computers%20in%20a%20network.),
    [EJB](https://en.wikipedia.org/wiki/Jakarta_Enterprise_Beans#:~:text=EJB%20is%20a%20server%2Dside,processing%2C%20and%20other%20web%20services),
    [SOAP](https://en.wikipedia.org/wiki/SOAP), [XML-RPC](http://xmlrpc.com), [.NET](https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet),
    [gRPC](https://grpc.io), etc.) can make IPC a bit easier, whether locally or remotely;
    however, we do not cover distributed computing in this book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 网络机制非常适合IPC，并且在网络的不同节点上运行的进程之间，以及在同一节点上运行的进程之间同样有效。multiprocessing 模块提供了一些适合在网络上进行IPC的机制；[第18章](ch18.xhtml#networking_basics)涵盖了提供IPC基础的低级网络机制。其他更高级的*分布式计算*机制（如[CORBA](https://www.ibm.com/docs/en/integration-bus/9.0.0?topic=corba-common-object-request-broker-architecture)、[DCOM/COM+](https://whatis.techtarget.com/definition/DCOM-Distributed-Component-Object-Model#:~:text=DCOM%20(Distributed%20Component%20Object%20Model)%20is%20a%20set%20of%20Microsoft,other%20computers%20in%20a%20network.)、[EJB](https://en.wikipedia.org/wiki/Jakarta_Enterprise_Beans#:~:text=EJB%20is%20a%20server%2Dside,processing%2C%20and%20other%20web%20services)、[SOAP](https://en.wikipedia.org/wiki/SOAP)、[XML-RPC](http://xmlrpc.com)、[.NET](https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet)、[gRPC](https://grpc.io)等）可以使IPC变得更加容易，无论是本地还是远程；然而，本书不涵盖分布式计算。
- en: When multiprocessor computers arrived, the OS had to deal with more complex
    scheduling problems, and programmers who wanted maximum performance had to write
    their applications so that code could truly be executed in parallel, on different
    processors or cores (from the programming point of view, cores are simply processors
    implemented on the same piece of silicon). This requires both knowledge and discipline.
    The CPython implementation simplifies these issues by implementing a *global interpreter
    lock* (GIL). In the absence of any action by the Python programmer, on CPython
    only the thread that holds the GIL is allowed access to the processor, effectively
    barring CPython processes from taking full advantage of multiprocessor hardware.
    Libraries such as [NumPy](https://numpy.org), which are typically required to
    undertake lengthy computations of compiled code that uses none of the interpreter’s
    facilities, arrange for their code to release the GIL during such computations.
    This allows effective use of multiple processors, but it isn’t a technique that
    you can use if all your code is in pure Python.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当多处理器计算机出现时，操作系统必须处理更复杂的调度问题，而希望获得最大性能的程序员必须编写他们的应用程序，以便代码可以真正并行执行，即在不同的处理器或核心上（从编程角度看，核心只是在同一块硅片上实现的处理器）。这需要知识和纪律。CPython
    实现通过实现*全局解释器锁*（GIL）简化了这些问题。在没有任何Python程序员的操作下，在CPython中只有持有GIL的线程被允许访问处理器，有效地阻止了CPython进程充分利用多处理器硬件。诸如[NumPy](https://numpy.org)这样的库通常需要进行长时间的计算，使用的是不使用解释器设施的编译代码，这些库在这些计算期间释放GIL。这允许有效地使用多个处理器，但如果您的所有代码都是纯Python，则不能使用这种技术。
- en: Threads in Python
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的线程
- en: Python supports multithreading on platforms that support threads, such as Windows,
    Linux, and just about all variants of Unix (including macOS). An action is known
    as *atomic* when it’s guaranteed that no thread switching occurs between the start
    and the end of the action. In practice, in CPython, operations that *look* atomic
    (e.g., simple assignments and accesses) mostly *are* atomic, but only when executed
    on built-in types (augmented and multiple assignments, however, aren’t atomic).
    Mostly, though, it’s *not* a good idea to rely on such “atomicity.” You might
    be dealing with an instance of a user-coded class rather than of a built-in type,
    in which there might be implicit calls to Python code that invalidate assumptions
    of atomicity. Further, relying on implementation-dependent atomicity may lock
    your code into a specific implementation, hampering future changes. You’re better-advised
    to use the synchronization facilities covered in the rest of this chapter, rather
    than relying on atomicity assumptions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持在支持线程的平台上进行多线程操作，如 Windows、Linux 和几乎所有 Unix 变体（包括 macOS）。当动作在开始和结束之间保证没有线程切换时，该动作被称为*原子*。在实践中，在
    CPython 中，看起来是原子的操作（例如，简单赋值和访问）大多数情况下确实是原子的，但只适用于内置类型（但增强和多重赋值不是原子的）。尽管如此，依赖于这种“原子性”通常*不*是一个好主意。您可能正在处理用户编写的类的实例，而不是内置类型的实例，在这种情况下，可能会有隐式调用
    Python 代码的情况，这些调用会使原子性假设失效。此外，依赖于实现相关的原子性可能会将您的代码锁定到特定的实现中，从而阻碍未来的更改。建议您在本章的其余部分使用同步设施，而不是依赖于原子性假设。
- en: 'The key design issue in multithreading systems is how best to coordinate multiple
    threads. The threading module, covered in the following section, supplies several
    synchronization objects. The queue module (discussed in [“The queue Module”](#the_queue_module))
    is also very useful for thread synchronization: it supplies synchronized, thread-safe
    queue types, handy for communication and coordination between threads. The package
    concurrent (covered in [“The concurrent.futures Module”](#the_concurrentdotfutures_module))
    supplies a unified interface for communication and coordination that can be implemented
    by pools of either threads or processes.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程系统中的关键设计问题是如何最好地协调多个线程。线程模块在下一节中介绍，提供了几种同步对象。队列模块（在[“队列模块”](#the_queue_module)中讨论）对于线程同步也非常有用：它提供了同步的、线程安全的队列类型，方便线程间的通信和协调。concurrent
    包（在[“concurrent.futures 模块”](#the_concurrentdotfutures_module)中讨论）提供了一个统一的通信和协调接口，可以由线程池或进程池实现。
- en: The threading Module
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程模块
- en: The threading module supplies multithreading functionality. The approach of
    threading is to model locks and conditions as separate objects (in Java, for example,
    such functionality is part of every object), and threads cannot be directly controlled
    from the outside (thus, no priorities, groups, destruction, or stopping). All
    methods of objects supplied by threading are atomic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 线程模块提供了多线程功能。线程的方法是将锁和条件建模为单独的对象（例如，在 Java 中，此类功能是每个对象的一部分），并且线程不能直接从外部控制（因此没有优先级、组、销毁或停止）。线程模块提供的所有对象的方法都是原子的。
- en: 'threading supplies the following thread-focused classes, all of which we’ll
    explore in this section: Thread, Condition, Lock, RLock, Event, Semaphore, BoundedSemaphore,
    Timer, and Barrier.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 线程模块提供了以下专注于线程的类，我们将在本节中探讨所有这些类：Thread、Condition、Lock、RLock、Event、Semaphore、BoundedSemaphore、Timer
    和 Barrier。
- en: threading also supplies a number of useful functions, including those listed
    in [Table 15-1](#functions_of_the_threading_module).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: threading 还提供了许多有用的函数，包括在[表 15-1](#functions_of_the_threading_module)中列出的函数。
- en: Table 15-1\. Functions of the threading module
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-1\. 线程模块的函数
- en: '| active_count | active_count() Returns an int, the number of Thread objects
    currently alive (not ones that have terminated or not yet started). |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| active_count | active_count() 返回一个整数，表示当前存活的线程对象数量（不包括已终止或尚未启动的线程）。'
- en: '| c⁠u⁠r⁠r⁠e⁠n⁠t⁠_​t⁠h⁠r⁠e⁠a⁠d | current_thread() Returns a Thread object for
    the calling thread. If the calling thread was not created by threading, current_thread
    creates and returns a semi-dummy Thread object with limited functionality. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| c⁠u⁠r⁠r⁠e⁠n⁠t⁠_​t⁠h⁠r⁠e⁠a⁠d | current_thread() 返回调用线程的 Thread 对象。如果调用线程不是由
    threading 创建的，则 current_thread 创建并返回一个具有有限功能的半虚拟 Thread 对象。'
- en: '| enumerate | enumerate() Returns a list of all Thread objects currently alive
    (not ones that have terminated or not yet started). |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| enumerate | enumerate() 返回当前存活的所有 Thread 对象的列表（不包括已终止或尚未启动的线程）。'
- en: '| excepthook | excepthook(args) 3.8+ Override this function to determine how
    in-thread exceptions are handled; see the [online docs](https://oreil.ly/ylw7S)
    for details. The args argument has attributes that allow you to access exception
    and thread details. 3.10+ threading.__excepthook__ holds the module’s original
    threadhook value. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| excepthook | excepthook(args) 3.8+ 重写此函数以确定如何处理线程内的异常；有关详细信息，请参阅[在线文档](https://oreil.ly/ylw7S)。args
    参数具有属性，允许您访问异常和线程详细信息。3.10+ threading.__excepthook__ 保存了模块的原始线程钩子值。 |'
- en: '| get_ident | get_ident() Returns a nonzero int as a unique identifier among
    all current threads. Useful to manage and track data by thread. Thread identifiers
    may be reused as threads exit and new threads are created. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| get_ident | get_ident() 返回一个非零整数作为所有当前线程中唯一的标识符。用于管理和跟踪线程数据。线程标识符可能会在线程退出并创建新线程时重复使用。
    |'
- en: '| get_native_id | get_native_id() 3.8+ Returns the native integer ID of the
    current thread as assigned by the operating system kernel. Available on most common
    operating systems. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| get_native_id | get_native_id() 3.8+ 返回由操作系统内核分配的当前线程的本机整数 ID。适用于大多数常见操作系统。
    |'
- en: '| stack_size | stack_size([*size*]) Returns the current stack size, in bytes,
    used for new threads, and (when *size* is provided) establishes the value for
    new threads. Acceptable values for *size* are subject to platform-specific constraints,
    such as being at least 32768 (or an even higher minimum, on some platforms), and
    (on some platforms) being a multiple of 4096. Passing *size* as 0 is always acceptable
    and means “use the system’s default.” When you pass a value for *size* that is
    not acceptable on the current platform, stack_size raises a ValueError exception.
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| stack_size | stack_size([*size*]) 返回用于新线程的当前堆栈大小（以字节为单位），并（如果提供 *size*）为新线程设定值。*size*
    的可接受值受到平台特定约束的限制，例如至少为 32768（或某些平台上更高的最小值），并且（在某些平台上）必须是 4096 的倍数。传递值为 0 总是可接受的，表示“使用系统的默认值”。当您传递一个在当前平台上不可接受的
    *size* 值时，stack_size 会引发 ValueError 异常。 |'
- en: Thread Objects
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Thread 对象
- en: A Thread instance *t* models a thread. You can pass a function to be used as
    *t*’s main function as the *target* argument when you create *t*, or you can subclass
    Thread and override its run method (you may also override __init__, but you should
    not override other methods). *t* is not yet ready to run when you create it; to
    make *t* ready (active), call *t*.start. Once *t* is active, it terminates when
    its main function ends, either normally or by propagating an exception. A Thread
    *t* can be a *daemon*, meaning that Python can terminate even if *t* is still
    active, while a normal (nondaemon) thread keeps Python alive until the thread
    terminates. The Thread class supplies the constructor, properties, and methods
    detailed in [Table 15-2](#constructorcomma_methodscomma_and_prop).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 线程实例 *t* 模拟一个线程。在创建 *t* 时，您可以将一个函数作为 *t* 的主函数传递给 *target* 参数，或者您可以子类化 Thread
    并重写其 run 方法（您还可以重写 __init__，但不应重写其他方法）。在创建时，*t* 还未准备好运行；要使 *t* 准备就绪（活动），请调用 *t*.start。一旦
    *t* 处于活动状态，它将在其主函数正常结束或通过传播异常时终止。线程 *t* 可以是 *daemon*，这意味着即使 *t* 仍然活动，Python 也可以终止，而普通（非守护）线程则会一直保持
    Python 运行，直到线程终止。Thread 类提供了在[Table 15-2](#constructorcomma_methodscomma_and_prop)中详细描述的构造函数、属性和方法。
- en: Table 15-2\. Constructor, methods, and properties of the Thread class
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Table 15-2\. Thread 类的构造函数、方法和属性
- en: '| Thread | **class** Thread(name=**None**, target=**None**, args=(), kwargs={},
    *, daemon=**None**)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '| Thread | **class** Thread(name=**None**, target=**None**, args=(), kwargs={},
    *, daemon=**None**)'
- en: '*Always call* *Thread* *with named arguments*: the number and order of parameters
    is not guaranteed by the specification, but the parameter names are. You have
    two options when constructing a Thread:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*始终*使用命名参数调用 *Thread*：虽然参数的数量和顺序不受规范保证，但参数名是固定的。在构造 Thread 时有两个选项：'
- en: Instantiate the class Thread itself with a target function (*t*.run then calls
    *target*(**args*, ***kwargs*) when the thread is started).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用目标函数（*t*.run 在线程启动时调用 *target*(**args*, ***kwargs*））来实例化 Thread 类本身。
- en: Extend the Thread class and override its run method.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 Thread 类并重写其 run 方法。
- en: In either case, execution will begin only when you call *t*.start. name becomes
    *t*’s name. If name is **None**, Thread generates a unique name for *t*. If a
    subclass *T* of Thread overrides __init__, *T*.__init__ *must* call Thread.__init__
    on self (usually via the super built-in function) before any other Thread method.
    daemon can be assigned a Boolean value or, if **None**, will take this value from
    the daemon attribute of the creating thread. |
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，仅当调用 *t*.start 时执行将开始。name 成为 *t* 的名称。如果 name 是 **None**，Thread 为 *t*
    生成一个唯一名称。如果 Thread 的子类 *T* 重写 __init__，*T*.__init__ *必须* 在调用任何其他 Thread 方法之前调用
    Thread.__init__（通常通过 super 内置函数）。daemon 可以分配布尔值，或者如果为 **None**，则将从创建线程的 daemon
    属性获取此值。 |
- en: '| daemon | daemon is a writable Boolean property that indicates whether *t*
    is a daemon (i.e., the process can terminate even when *t* is still active; such
    a termination also ends *t*). You can assign to *t*.daemon only before calling
    *t*.start; assigning a true value sets *t* to be a daemon. Threads created by
    a daemon thread have *t*.daemon set to **True** by default. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| daemon | daemon 是一个可写的布尔属性，指示 *t* 是否为守护线程（即使 *t* 仍然活动，进程也可以终止；这样的终止也会结束 *t*）。只能在调用
    *t*.start 之前对 *t*.daemon 赋值；将 true 值赋给 *t* 将其设置为守护线程。守护线程创建的线程的 *t*.daemon 默认为
    **True**。 |'
- en: '| is_alive | *t*.is_alive() is_alive returns **True** when *t* is active (i.e.,
    when *t*.start has executed and *t*.run has not yet terminated); otherwise, returns
    **False**. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| is_alive | *t*.is_alive() 当 *t* 处于活动状态时（即 *t*.start 已执行且 *t*.run 尚未终止），is_alive
    返回 **True**；否则返回 **False**。 |'
- en: '| join | *t*.join(timeout=**None**) join suspends the calling thread (which
    must not be *t*) until *t* terminates (when *t* is already terminated, the calling
    thread does not suspend). timeout is covered in [“Timeout parameters”](#timeout_parameters).
    You can call *t*.join only after *t*.start. It’s OK to call join more than once.
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| join | *t*.join(timeout=**None**) join 暂停调用线程（不能是 *t*）直到 *t* 终止（当 *t* 已经终止时，调用线程不会暂停）。timeout
    在 [“超时参数”](#timeout_parameters) 中讨论。只能在 *t*.start 之后调用 *t*.join。可以多次调用 join。 |'
- en: '| name | *t*.name name is a property returning *t*’s name; assigning name rebinds
    *t*’s name (name exists only to help you debug; name need not be unique among
    threads). If omitted, the thread will receive a generated name Thread-*n*, where
    *n* is an incrementing integer (3.10+ and if target is specified, (target.__name__)
    will be appended). |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| name | *t*.name name 是返回 *t* 名称的属性；分配 name 重新绑定 *t* 的名称（名称仅用于调试帮助；名称在线程中无需唯一）。如果省略，则线程将接收生成的名称
    Thread-*n*，其中 *n* 是递增的整数（3.10+ 并且如果指定了 target，则将附加 (target.__name__)）。 |'
- en: '| run | *t*.run() run is the method called by *t*.start that executes *t*’s
    main function. Subclasses of Thread can override run. Unless overridden, run calls
    the *target* callable passed on *t*’s creation. Do *not* call *t*.run directly;
    calling *t*.run is the job of *t*.start! |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| run | *t*.run() 是由 *t*.start 调用的方法，执行 *t* 的主函数。Thread 的子类可以重写 run 方法。如果未重写，则
    run 方法调用 *t* 创建时传递的 *target* 可调用对象。不要直接调用 *t*.run；调用 *t*.run 的工作由 *t*.start 完成！
    |'
- en: '| start | *t*.start() start makes *t* active and arranges for *t*.run to execute
    in a separate thread. You must call *t*.start only once for any given Thread object
    *t*; calling it again raises an exception. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| start | *t*.start() 使 *t* 变为活动状态，并安排 *t*.run 在单独的线程中执行。对于任何给定的 Thread 对象
    *t*，只能调用一次 *t*.start；再次调用会引发异常。 |'
- en: Thread Synchronization Objects
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程同步对象
- en: The threading module supplies several synchronization primitives (types that
    let threads communicate and coordinate). Each primitive type has specialized uses,
    discussed in the following sections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: threading 模块提供了几种同步原语（允许线程通信和协调的类型）。每种原语类型都有专门的用途，将在以下部分讨论。
- en: You May Not Need Thread Synchronization Primitives
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 也许你不需要线程同步原语
- en: As long as you avoid having (nonqueue) global variables that change and which
    several threads access, queue (covered in [“The queue Module”](#the_queue_module))
    can often provide all the coordination you need, as can concurrent (covered in
    [“The concurrent.futures Module”](#the_concurrentdotfutures_module)). [“Threaded
    Program Architecture”](#threaded_program_architecture) shows how to use Queue
    objects to give your multithreaded programs simple and effective architectures,
    often without needing any explicit use of synchronization primitives.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 只要避免有（非队列）全局变量，这些变量会发生变化，多个线程可以访问，队列（在[“队列模块”](#the_queue_module)中介绍）通常可以提供所需的所有协调工作，同时并发（在[“concurrent.futures
    模块”](#the_concurrentdotfutures_module)中介绍）也可以。[“线程化程序架构”](#threaded_program_architecture)展示了如何使用队列对象为您的多线程程序提供简单而有效的架构，通常无需显式使用同步原语。
- en: Timeout parameters
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超时参数
- en: 'The synchronization primitives Condition and Event supply wait methods that
    accept an optional timeout argument. A Thread object’s join method also accepts
    an optional timeout argument (see [Table 15-2](#constructorcomma_methodscomma_and_prop)).
    Using the default timeout value of **None** results in normal blocking behavior
    (the calling thread suspends and waits until the desired condition is met). When
    it is not **None**, a timeout argument is a floating-point value that indicates
    an interval of time, in seconds (timeout can have a fractional part, so it can
    indicate any time interval, even a very short one). When timeout seconds elapse,
    the calling thread becomes ready again, even if the desired condition has not
    been met; in this case, the waiting method returns **False** (otherwise, the method
    returns **True**). timeout lets you design systems that are able to overcome occasional
    anomalies in a few threads, and thus are more robust. However, using timeout may
    slow your program down: when that matters, be sure to measure your code’s speed
    accurately.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 同步原语 Condition 和 Event 提供接受可选超时参数的 wait 方法。线程对象的 join 方法也接受可选的超时参数（参见[表 15-2](#constructorcomma_methodscomma_and_prop)）。使用默认的超时值
    **None** 会导致正常的阻塞行为（调用线程挂起并等待，直到满足所需条件）。当超时值不是 **None** 时，超时参数是一个浮点值，表示时间间隔，单位为秒（超时可以有小数部分，因此可以指示任何时间间隔，甚至非常短的间隔）。当超过超时秒数时，调用线程再次准备好，即使所需条件尚未满足；在这种情况下，等待方法返回
    **False**（否则，方法返回 **True**）。超时让您设计能够处理少数线程偶发异常的系统，从而使系统更加健壮。但是，使用超时可能会降低程序的运行速度：在这种情况下，请务必准确测量您代码的速度。
- en: Lock and RLock objects
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锁和重入锁对象
- en: Lock and RLock objects supply the same three methods, described in [Table 15-3](#methods_of_an_instance_l_of_lock).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 锁和重入锁对象提供相同的三种方法，详见[表 15-3](#methods_of_an_instance_l_of_lock)。
- en: Table 15-3\. Methods of an instance L of Lock
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-3\. 锁实例 L 的方法
- en: '| acquire | *L*.acquire(blocking=**True**, timeout=-1) When *L* is unlocked,
    or if *L* is an RLock acquired by the same thread that’s calling acquire, this
    thread immediately locks it (incrementing the internal counter if *L* is an RLock,
    as described shortly) and returns **True**.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '| acquire | *L*.acquire(blocking=**True**, timeout=-1) 当 *L* 未锁定时，或者如果 *L*
    是由同一个线程获取的重入锁，该线程立即锁定它（如果 *L* 是重入锁，则会增加内部计数器，如后面所述），并返回 **True**。'
- en: 'When *L* is already locked and blocking is **False**, acquire immediately returns
    **False**. When blocking is **True**, the calling thread is suspended until either:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *L* 已经被锁定且 blocking 为 **False** 时，acquire 立即返回 **False**。当 blocking 为 **True**
    时，调用线程将被挂起，直到以下情况发生之一：
- en: Another thread releases the lock, in which case this thread locks it and returns
    **True**.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个线程释放了锁，则该线程锁定它并返回 **True**。
- en: The operation times out before the lock can be acquired, in which case acquire
    returns **False**. The default -1 value never times out.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在锁被获取之前操作超时，此时 acquire 返回 **False**。默认的 -1 值永不超时。
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| locked | *L*.locked() Returns **True** when *L* is locked; otherwise, returns
    **False**. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| locked | *L*.locked() 当 *L* 被锁定时返回 **True**；否则返回 **False**。 |'
- en: '| release | *L.*release() Unlocks *L*, which must be locked (for an RLock,
    this means to decrement the lock count, which cannot go below zero—the lock can
    only be acquired by a new thread when the lock count is zero). When *L* is locked,
    any thread may call *L*.release, not just the thread that locked *L*. When more
    than one thread is blocked on *L* (i.e., has called *L*.acquire, found *L* locked,
    and is waiting for *L* to be unlocked), release wakes up an arbitrary one of the
    waiting threads. The thread calling release does not suspend: it remains ready
    and continues to execute. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| release | `L.release()` 解锁 `L`，必须已锁定（对于 `RLock`，这意味着减少锁计数，锁计数不得低于零——只有当锁计数为零时才能由新线程获取）。当
    `L` 被锁定时，任何线程都可以调用 `L.release`，不仅仅是锁定 `L` 的线程。当多个线程被阻塞在 `L` 上时（即调用了 `L.acquire`，发现
    `L` 被锁定，并等待 `L` 解锁），`release` 将唤醒其中任意一个等待的线程。调用 `release` 的线程不会挂起：它仍然准备好并继续执行。'
- en: 'The following console session illustrates the automatic acquire/release done
    on locks when they are used as a context manager (as well as other data Python
    maintains for the lock, such as the owner thread ID and the number of times the
    lock’s acquire method has been called):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的控制台会话示例说明了当锁被用作上下文管理器时（以及Python在锁的使用过程中维护的其他数据，例如所有者线程ID和锁的获取方法被调用的次数）自动获取/释放锁的情况：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The semantics of an RLock object *r* are often more convenient (except in peculiar
    architectures where you need threads to be able to release locks that a different
    thread has acquired). RLock is a *reentrant* lock, meaning that when *r* is locked,
    it keeps track of the *owning* thread (i.e., the thread that locked it, which
    for an RLock is also the only thread that can release it—when any other thread
    tries to release an RLock, this raises a RuntimeError exception). The owning thread
    can call *r*.acquire again without blocking; *r* then just increments an internal
    count. In a similar situation involving a Lock object, the thread would block
    until some other thread releases the lock. For example, consider the following
    code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`RLock` 对象 `r` 的语义通常更为方便（除非在需要线程能够释放不同线程已获取的锁的特殊体系结构中）。 `RLock` 是一个可重入锁，意味着当
    `r` 被锁定时，它会跟踪*拥有*它的线程（即锁定它的线程，对于 `RLock` 来说也是唯一能够释放它的线程——当任何其他线程尝试释放 `RLock` 时，会引发
    `RuntimeError` 异常）。拥有它的线程可以再次调用 `r.acquire` 而不会阻塞；然后 `r` 只是增加一个内部计数。在涉及 `Lock`
    对象的类似情况下，线程会阻塞直到某个其他线程释放该锁。例如，考虑以下代码片段：'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If lock was an instance of threading.Lock, recursive_function would block its
    calling thread when it calls itself recursively: the **with** statement, finding
    that the lock has already been acquired (even though that was done by the same
    thread), would block and wait…and wait. With a threading.RLock, no such problem
    occurs: in this case, since the lock has already been acquired *by the same thread*,
    on getting acquired again it just increments its internal count and proceeds.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁是 `threading.Lock` 的一个实例，当 `recursive_function` 递归调用自身时，会阻塞其调用线程：`with` 语句会发现锁已经被获取（尽管是同一个线程获取的），然后会阻塞并等待……等待。而使用
    `threading.RLock` 则不会出现这样的问题：在这种情况下，由于锁已经被同一线程获取，再次获取时只是增加其内部计数然后继续。
- en: An RLock object *r* is unlocked only when it has been released as many times
    as it has been acquired. An RLock is useful to ensure exclusive access to an object
    when the object’s methods call each other; each method can acquire at the start,
    and release at the end, the same RLock instance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `RLock` 对象 `r` 只有在释放次数与获取次数相同的情况下才会解锁。当对象的方法相互调用时，`RLock` 对象非常有用；每个方法在开始时可以获取，并在结束时释放同一个
    `RLock` 实例。
- en: Use with Statements to Automatically Acquire and Release Synchronization Objects
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `with` 语句自动获取和释放同步对象
- en: 'Using a **try**/**finally** statement (covered in [“try/finally”](ch06.xhtml#trysolidusfinally))
    is one way to ensure that an acquired lock is indeed released. Using a **with**
    statement, covered in [“The with Statement and Context Managers”](ch06.xhtml#the_with_statement_and_context_managers),
    is usually better: all locks, conditions, and semaphores are context managers,
    so an instance of any of these types can be used directly in a **with** clause
    to acquire it (implicitly with blocking) and ensure it is released at the end
    of the **with** block.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**try**/**finally**语句（在[“try/finally”](ch06.xhtml#trysolidusfinally)中介绍）是确保已获取的锁确实被释放的一种方法。使用**with**语句，通常更好，因为所有的锁、条件和信号量都是上下文管理器，所以这些类型的实例可以直接在**with**子句中使用，以获取它（隐式地带有阻塞）并确保在**with**块的末尾释放它。
- en: Condition objects
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件对象
- en: A Condition object *c* wraps a Lock or RLock object *L*. The class Condition
    exposes the constructor and methods described in [Table 15-4](#constructor_and_methods_of_the_conditio).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 条件对象*c*封装了锁或者递归锁对象*L*。Condition类公开了在[表 15-4](#constructor_and_methods_of_the_conditio)中描述的构造函数和方法。
- en: Table 15-4\. Constructor and methods of the Condition class
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-4\. Condition类的构造函数和方法
- en: '| Condition | **class** Condition(lock=**None**) Creates and returns a new
    Condition object *c* with the lock *L* set to lock. If lock is **None**, *L* is
    set to a newly created RLock object. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| Condition | **class** Condition(lock=**None**) 创建并返回一个新的Condition对象*c*，并使用锁*L*设置为lock。如果lock为**None**，则*L*设置为新创建的RLock对象。
    |'
- en: '| acquire, release | *c*.acquire(blocking=**True**), *c*.release() These methods
    just call *L*’s corresponding methods. A thread must never call any other method
    on *c* unless the thread holds (i.e., has acquired) lock *L*. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| acquire, release | *c*.acquire(blocking=**True**), *c*.release() 这些方法只是调用*L*的相应方法。线程除了持有（即已获取）锁*L*之外，绝不应调用*c*的任何其他方法。'
- en: '| notify, notify_all | *c*.notify(),  *c*.notify_all() notify wakes up an arbitrary
    one of the threads waiting on *c*. The calling thread must hold *L* before it
    calls *c*.notify, and notify does not release *L*. The awakened thread does not
    become ready until it can acquire *L* again. Therefore, the calling thread normally
    calls release after calling notify. notify_all is like notify, but wakes up *all*
    waiting threads, not just one. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| notify, notify_all | *c*.notify(), *c*.notify_all() notify唤醒在*c*上等待的任意一个线程。在调用*c*.notify之前，调用线程必须持有*L*，并且notify不会释放*L*。被唤醒的线程直到再次可以获取*L*时才变为就绪。因此，通常调用线程在调用notify后调用release。notify_all类似于notify，但唤醒*所有*等待的线程，而不仅仅是一个。'
- en: '| wait | *c*.wait(timeout=**None**) wait releases *L*, then suspends the calling
    thread until some other thread calls notify or notify_all on *c*. The calling
    thread must hold *L* before it calls *c*.wait. timeout is covered in [“Timeout
    parameters”](#timeout_parameters). After a thread wakes up, either by notification
    or timeout, the thread becomes ready when it acquires *L* again. When wait returns
    **True** (meaning it has exited normally, not by timeout), the calling thread
    is always holding *L* again. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| wait | *c*.wait(timeout=**None**) wait释放*L*，然后挂起调用线程，直到其他线程在*c*上调用notify或notify_all。在调用*c*.wait之前，调用线程必须持有*L*。timeout在[“超时参数”](#timeout_parameters)中有描述。线程通过通知或超时唤醒后，当再次获取*L*时，线程变为就绪。当wait返回**True**（表示正常退出，而不是超时退出）时，调用线程总是再次持有*L*。'
- en: 'Usually, a Condition object *c* regulates access to some global state *s* shared
    among threads. When a thread must wait for *s* to change, the thread loops:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Condition对象*c*调节一些在线程间共享的全局状态*s*的访问。当一个线程必须等待*s*改变时，线程循环：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Meanwhile, each thread that modifies *s* calls notify (or notify_all if it
    needs to wake up all waiting threads, not just one) each time *s* changes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，每个修改*s*的线程在每次*s*变化时调用notify（或者如果需要唤醒所有等待的线程而不仅仅是一个，则调用notify_all）：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You must always acquire and release *c* around each use of *c*’s methods: doing
    so via a **with** statement makes using Condition instances less error prone.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须始终在每次使用*c*的方法周围获取和释放*c*：通过**with**语句这样做使得使用Condition实例更不容易出错。
- en: Event objects
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件对象
- en: Event objects let any number of threads suspend and wait. All threads waiting
    on Event object *e* become ready when any other thread calls *e*.set. *e* has
    a flag that records whether the event happened; it is initially **False** when
    *e* is created. Event is thus a bit like a simplified Condition. Event objects
    are useful to signal one-shot changes, but brittle for more general use; in particular,
    relying on calls to *e*.clear is error prone. The Event class exposes the constructor
    and methods in [Table 15-5](#constructor_and_methods_of_the_event_cl).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 事件对象允许任意数量的线程挂起和等待。当任何其他线程调用 *e*.set 时，所有等待事件对象 *e* 的线程都变为就绪状态。*e* 有一个标志记录事件是否发生；在
    *e* 创建时，该标志最初为 **False**。因此，事件类似于简化版的条件变量。事件对象适用于一次性的信号传递，但对于更一般的用途而言，可能不够灵活；特别是依赖于调用
    *e*.clear 很容易出错。事件类公开了 [表 15-5](#constructor_and_methods_of_the_event_cl) 中的构造函数和方法。
- en: Table 15-5\. Constructor and methods of the Event class
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-5\. 事件类的构造函数和方法
- en: '| Event | **class** Event() Creates and returns a new Event object *e*, with
    *e*’s flag set to **False**. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| Event | **class** Event() 创建并返回一个新的事件对象 *e*，并将 *e* 的标志设置为 **False**。 |'
- en: '| clear | *e*.clear() Sets *e*’s flag to **False**. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| clear | *e*.clear() 将 *e* 的标志设置为 **False**。 |'
- en: '| is_set | *e*.is_set() Returns the value of *e*’s flag: **True** or **False**.
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| is_set | *e*.is_set() 返回 *e* 的标志值：**True** 或 **False**。 |'
- en: '| set | *e*.set() Sets *e*’s flag to **True**. All threads waiting on *e*,
    if any, become ready to run. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| set | *e*.set() 将 *e* 的标志设置为 **True**。所有等待 *e* 的线程（如果有）都将变为就绪状态。 |'
- en: '| wait | *e*.wait(timeout=**None**) Returns immediately if *e*’s flag is **True**;
    otherwise, suspends the calling thread until some other thread calls set. timeout
    is covered in [“Timeout parameters”](#timeout_parameters). |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| wait | *e*.wait(timeout=**None**) 如果 *e* 的标志为 **True**，则立即返回；否则，挂起调用线程，直到其他线程调用
    set。timeout 参见 [“超时参数”](#timeout_parameters)。 |'
- en: 'The following code shows how Event objects explicitly synchronize processing
    across multiple threads:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码显示了如何显式同步多个线程之间的处理过程使用事件对象：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Semaphore and BoundedSemaphore objects
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号量和有界信号量对象
- en: '*Semaphores* (also known as *counting semaphores*) are a generalization of
    locks. The state of a Lock can be seen as **True** or **False**; the state of
    a Semaphore *s* is a number between 0 and some *n* set when *s* is created (both
    bounds included). Semaphores can be useful to manage a fixed pool of resources—e.g.,
    4 printers or 20 sockets—although it’s often more robust to use Queues (described
    later in this chapter) for such purposes. The class BoundedSemaphore is very similar,
    but raises ValueError if the state ever becomes higher than the initial value:
    in many cases, such behavior can be a useful indicator of a bug. [Table 15-6](#constructors_and_methods_of_the_semapho)
    shows the constructors of the Semaphore and BoundedSemaphore classes and the methods
    exposed by an object *s* of either class.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*信号量*（也称为*计数信号量*）是锁的一种泛化形式。锁的状态可以看作是 **True** 或 **False**；信号量 *s* 的状态是一个在创建
    *s* 时设置的介于 0 和某个 *n* 之间的数值（两个边界都包括）。信号量可以用来管理一组固定的资源，例如 4 台打印机或 20 个套接字，尽管对于这种目的，使用队列（本章后面描述）通常更为健壮。有界信号量类与此非常相似，但是如果状态超过初始值，则会引发
    ValueError：在许多情况下，这种行为可以作为错误的有用指示器。 [表 15-6](#constructors_and_methods_of_the_semapho)
    显示了信号量和有界信号量类的构造函数以及任何一类对象 *s* 所暴露的方法。'
- en: Table 15-6\. Constructors and methods of the Semaphore and BoundedSemaphore
    classes
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-6\. 信号量和有界信号量类的构造函数和方法
- en: '| Semaphore, Boun⁠d⁠e⁠d​S⁠e⁠m⁠aphore | **class** Semaphore(n=1), **class**
    BoundedSemaphore(n=1)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '| Semaphore, Boun⁠d⁠e⁠d​S⁠e⁠m⁠aphore | **class** Semaphore(n=1), **class**
    BoundedSemaphore(n=1)'
- en: Semaphore creates and returns a Semaphore object *s* with the state set to n;
    BoundedSemaphore is very similar, except that *s*.release raises ValueError if
    the state becomes higher than n. |
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量使用指定状态 *n* 创建并返回一个信号量对象 *s*；有界信号量类似，但如果状态高于 *n*，则 *s*.release 会引发 ValueError。
    |
- en: '| acquire | *s*.acquire(blocking=**True**) When *s*’s state is >0, acquire
    decrements the state by 1 and returns **True**. When *s*’s state is 0 and blocking
    is **True**, acquire suspends the calling thread and waits until some other thread
    calls *s*.release. When *s*’s state is 0 and blocking is **False**, acquire immediately
    returns **False**. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| acquire | *s*.acquire(blocking=**True**) 当 *s* 的状态 >0 时，acquire 将状态减 1 并返回
    **True**。当 *s* 的状态为 0 且 blocking 为 **True** 时，acquire 暂停调用线程并等待，直到其他线程调用 *s*.release。当
    *s* 的状态为 0 且 blocking 为 **False** 时，acquire 立即返回 **False**。 |'
- en: '| release | *s*.release() When *s*’s state is >0, or when the state is 0 but
    no thread is waiting on *s*, release increments the state by 1. When *s*’s state
    is 0 and some threads are waiting on *s*, release leaves *s*’s state at 0 and
    wakes up an arbitrary one of the waiting threads. The thread that calls release
    does not suspend; it remains ready and continues to execute normally. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| release | *s*.release() 当 *s* 的状态大于 0 时，或者状态为 0 但没有线程在等待 *s* 时，release 将状态增加
    1。当 *s* 的状态为 0 且有线程在等待 *s* 时，release 将保持 *s* 的状态为 0，并唤醒其中一个等待的线程。调用 release 的线程不会挂起；它保持就绪状态并继续正常执行。
    |'
- en: Timer objects
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Timer 对象
- en: A Timer object calls a specified callable, in a newly made thread, after a given
    delay. The class Timer exposes the constructor and methods in [Table 15-7](#constructor_and_methods_of_the_timer_cl).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Timer 对象在给定延迟后，在新创建的线程中调用指定的可调用对象。Timer 类公开了构造函数和 [Table 15-7](#constructor_and_methods_of_the_timer_cl)
    中的方法。
- en: Table 15-7\. Constructor and methods of the Timer class
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Table 15-7\. Timer 类的构造函数和方法
- en: '| Timer | **class** Timer(*interval*, *callback*, args=**None**, kwargs=**None**)
    Creates an object *t* that calls *callback**,* *interval* seconds after starting
    (*interval* is a floating-point number of seconds). |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| Timer | **class** Timer(*interval*, *callback*, args=**None**, kwargs=**None**)
    创建一个对象 *t*，在启动后 *interval* 秒调用 *callback*（*interval* 是一个浮点秒数）。 |'
- en: '| cancel | *t*.cancel() Stops the timer and cancels the execution of its action,
    as long as *t* is still waiting (hasn’t called its callback yet) when you call
    cancel. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| cancel | *t*.cancel() 停止定时器并取消其动作的执行，只要在调用 cancel 时 *t* 仍在等待（尚未调用其回调）。 |'
- en: '| start | *t*.start() Starts *t*. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| start | *t*.start() 启动 *t*。 |'
- en: Timer extends Thread and adds the attributes function, interval, args, and kwargs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Timer 继承自 Thread 并添加了属性 function、interval、args 和 kwargs。
- en: 'A Timer is “one-shot”: *t* calls its callback only once. To call *callback*
    periodically, every *interval* seconds, here’s a simple recipe—the Periodic timer
    runs *callback* every *interval* seconds, stopping only when *callback* raises
    an exception:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Timer 是“一次性”的：*t* 仅调用其回调一次。要周期性地每隔 *interval* 秒调用 *callback*，这里是一个简单的方法——周期性定时器每隔
    *interval* 秒运行 *callback*，只有在 *callback* 引发异常时才停止：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Barrier objects
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Barrier 对象
- en: A Barrier is a synchronization primitive allowing a certain number of threads
    to wait until they’ve all reached a certain point in their execution, at which
    point they all resume. Specifically, when a thread calls *b*.wait, it blocks until
    the specified number of threads have made the same call on *b*; at that time,
    all the threads blocked on *b* are allowed to resume.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Barrier 是一种同步原语，允许一定数量的线程等待，直到它们都达到执行中的某一点，然后它们全部恢复。具体来说，当线程调用 *b*.wait 时，它会阻塞，直到指定数量的线程在
    *b* 上做出相同的调用；此时，所有在 *b* 上阻塞的线程都被允许恢复。
- en: The Barrier class exposes the constructor, methods, and properties listed in
    [Table 15-8](#constructorcomma_methodscomma_and_prope).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Barrier 类公开了构造函数、方法和 [Table 15-8](#constructorcomma_methodscomma_and_prope)
    中列出的属性。
- en: Table 15-8\. Constructor, methods, and properties of the Barrier class
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Table 15-8\. Barrier 类的构造函数、方法和属性
- en: '| Barrier | **class** Barrier(*num_threads*, action=**None**, timeout=**None**)
    Creates a Barrier object *b* for *num_threads* threads. action is a callable without
    arguments: if you pass this argument, it executes on any single one of the blocked
    threads when they are all unblocked. timeout is covered in [“Timeout parameters”](#timeout_parameters).
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Barrier | **class** Barrier(*num_threads*, action=**None**, timeout=**None**)
    为 *num_threads* 个线程创建一个 Barrier 对象 *b*。action 是一个没有参数的可调用对象：如果传递了此参数，则它会在所有阻塞线程中的任何一个被解除阻塞时执行。timeout
    在 [“Timeout parameters”](#timeout_parameters) 中有说明。 |'
- en: '| abort | *b.*abort() Puts Barrier *b* in the *broken* state, meaning that
    any thread currently waiting resumes with a threading.BrokenBarrierException (the
    same exception also gets raised on any subsequent call to *b*.wait). This is an
    emergency action typically used when a waiting thread is suffering some abnormal
    termination, to avoid deadlocking the whole program. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| abort | *b*.abort() 将 Barrier *b* 置于 *broken* 状态，这意味着当前等待的任何线程都会恢复，并抛出 threading.BrokenBarrierException（在任何后续调用
    *b*.wait 时也会引发相同的异常）。这是一种紧急操作，通常用于当等待线程遭遇异常终止时，以避免整个程序死锁。 |'
- en: '| broken | *b.*broken **True** when *b* is in the broken state; otherwise,
    **False**. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| broken | *b*.broken 当 *b* 处于 *broken* 状态时为 **True**；否则为 **False**。 |'
- en: '| n_waiting | *b.*n_waiting The number of threads currently waiting on *b*.
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| n_waiting | *b.*n_waiting 当前正在等待 *b* 的线程数。 |'
- en: '| parties | parties The value passed as *num_threads* in the constructor of
    *b*. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| parties | parties 在 *b* 构造函数中作为 *num_threads* 传递的值。 |'
- en: '| reset | *b.*reset() Returns *b* to the initial empty, nonbroken state; any
    thread currently waiting on *b*, however, resumes with a threading.BrokenBarrierException.
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 重置 | *b.*reset() 将*b*重置为初始的空、未损坏状态；但是，当前正在*b*上等待的任何线程都将恢复，带有threading.BrokenBarrierException异常。
    |'
- en: '| wait | *b.*wait() The first *b*.parties-1 threads calling *b*.wait block;
    when the number of threads blocked on *b* is *b*.parties-1 and one more thread
    calls *b*.wait, all the threads blocked on *b* resume. *b*.wait returns an int
    to each resuming thread, all distinct and in range(*b*.parties), in unspecified
    order; threads can use this return value to determine which one should do what
    next (though passing action in the Barrier’s constructor is simpler and often
    sufficient). |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 等待 | *b.*wait() 第一个*b*.parties-1个调用*b*.wait的线程会阻塞；当阻塞在*b*上的线程数为*b*.parties-1时，再有一个线程调用*b*.wait，所有阻塞在*b*上的线程都会恢复。*b*.wait向每个恢复的线程返回一个int，所有返回值都是不同的且在range(*b*.parties)范围内，顺序不确定；线程可以使用这个返回值来确定接下来应该做什么（尽管在Barrier的构造函数中传递action更简单且通常足够）。
    |'
- en: 'The following code shows how Barrier objects synchronize processing across
    multiple threads (contrast this with the example code shown earlier for Event
    objects):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了Barrier对象如何在多个线程之间同步处理（与之前展示的Event对象的示例代码进行对比）：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Thread Local Storage
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程本地存储
- en: 'The threading module supplies the class local, which a thread can use to obtain
    *thread-local storage*, also known as *per-thread data*. An instance *L* of local
    has arbitrary named attributes that you can set and get, stored in a dictionary
    *L*.__dict__ that you can also access. *L* is fully thread-safe, meaning there
    is no problem if multiple threads simultaneously set and get attributes on *L*.
    Each thread that accesses *L* sees a disjoint set of attributes: any changes made
    in one thread have no effect in other threads. For example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: threading模块提供了类local，线程可以使用它来获取*线程本地存储*，也称为*每个线程的数据*。local的一个实例*L*有任意命名的属性，你可以设置和获取，存储在字典*L*.__dict__中，也可以直接访问。*L*是完全线程安全的，这意味着多个线程同时设置和获取*L*上的属性没有问题。每个访问*L*的线程看到的属性集合是独立的：在一个线程中进行的任何更改对其他线程没有影响。例如：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Thread-local storage makes it easier to write code meant to run in multiple
    threads, since you can use the same namespace (an instance of threading.local)
    in multiple threads without the separate threads interfering with each other.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 线程本地存储使得编写多线程代码更加容易，因为你可以在多个线程中使用相同的命名空间（即threading.local的一个实例），而不会相互干扰。
- en: The queue Module
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列模块
- en: The queue module supplies queue types supporting multithreaded access, with
    one main class Queue, one simplified class SimpleQueue, two subclasses of the
    main class (LifoQueue and PriorityQueue), and two exception classes (Empty and
    Full), described in [Table 15-9](#classes_of_the_queue_module). The methods exposed
    by instances of the main class and its subclasses are detailed in [Table 15-10](#methods_of_an_instance_q_of_class_queue).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 队列模块提供支持多线程访问的队列类型，主要类是Queue，还有一个简化的类SimpleQueue，主类的两个子类（LifoQueue和PriorityQueue），以及两个异常类（Empty和Full），在[表15-9](#classes_of_the_queue_module)中描述。主类及其子类实例暴露的方法详见[表15-10](#methods_of_an_instance_q_of_class_queue)。
- en: Table 15-9\. Classes of the queue module
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 表15-9\. 队列模块的类
- en: '| Queue | **class** Queue(maxsize=0) Queue, the main class in the module queue,
    implements a first-in, first-out (FIFO) queue: the item retrieved each time is
    the one that was added earliest.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '| 队列 | **类** Queue(maxsize=0) Queue是queue模块中的主要类，实现先进先出（FIFO）队列：每次检索的项是最早添加的项。'
- en: When maxsize > 0, the new Queue instance *q* is considered full when *q* has
    maxsize items. When *q* is full, a thread inserting an item with block=**True**
    suspends until another thread extracts an item. When maxsize <= 0, *q* is never
    considered full and is limited in size only by available memory, like most Python
    containers. |
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当maxsize > 0时，新的Queue实例*q*在*q*达到maxsize项时被视为已满。当*q*已满时，插入带有block=**True**的项的线程将暂停，直到另一个线程提取一个项。当maxsize
    <= 0时，*q*永远不会被视为满，仅受可用内存限制，与大多数Python容器一样。 |
- en: '| SimpleQueue | **class** SimpleQueue SimpleQueue is a simplified Queue: an
    unbounded FIFO queue lacking the methods full, task_done, and join (see [Table 15-10](#methods_of_an_instance_q_of_class_queue))
    and with the method put ignoring its optional arguments but guaranteeing reentrancy
    (which makes it usable in __del__ methods and weakref callbacks, where Queue.put
    would not be). |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| SimpleQueue | **class** SimpleQueue SimpleQueue 是一个简化的 Queue：一个无界的 FIFO 队列，缺少
    full、task_done 和 join 方法（请参见 [Table 15-10](#methods_of_an_instance_q_of_class_queue)），并且
    put 方法忽略其可选参数但保证可重入性（这使其可在 __del__ 方法和 weakref 回调中使用，而 Queue.put 则不能）。 |'
- en: '| LifoQueue | **class** LifoQueue(maxsize=0) LifoQueue is a subclass of Queue;
    the only difference is that LifoQueue implements a last-in, first-out (LIFO) queue,
    meaning the item retrieved each time is the most recently added one (often called
    a *stack*). |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| LifoQueue | **class** LifoQueue(maxsize=0) LifoQueue 是 Queue 的子类；唯一的区别是 LifoQueue
    实现了后进先出（LIFO）队列，意味着每次检索到的项是最近添加的项（通常称为 *stack*）。 |'
- en: '| PriorityQueue | **class** PriorityQueue(maxsize=0) PriorityQueue is a subclass
    of Queue; the only difference is that PriorityQueue implements a *priority* queue,
    meaning the item retrieved each time is the smallest one currently in the queue.
    Since there is no way to specify ordering, you’ll typically use (*priority*, *payload*)
    pairs as items, with low values of *priority* meaning earlier retrieval. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| PriorityQueue | **class** PriorityQueue(maxsize=0) PriorityQueue 是 Queue
    的子类；唯一的区别是 PriorityQueue 实现了一个 *priority* 队列，意味着每次检索到的项是当前队列中最小的项。由于没有指定排序的方法，通常会使用
    (*priority*, *payload*) 对作为项，其中 *priority* 的值较低表示较早的检索。 |'
- en: '| Empty | Empty is the exception that *q*.get(block=**False**) raises when
    *q* is empty. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| Empty | Empty 是当 *q* 为空时 *q*.get(block=**False**) 抛出的异常。 |'
- en: '| Full | Full is the exception that *q*.put(*x*, block=**False**) raises when
    *q* is full. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| Full | Full 是当 *q* 满时 *q*.put(*x*, block=**False**) 抛出的异常。 |'
- en: An instance *q* of the class Queue (or either of its subclasses) supplies the
    methods listed in [Table 15-10](#methods_of_an_instance_q_of_class_queue), all
    thread-safe and guaranteed to be atomic. For details on the methods exposed by
    an instance of SimpleQueue, see [Table 15-9](#classes_of_the_queue_module).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实例 *q* 为 Queue 类（或其子类之一）的一个实例，提供了 [Table 15-10](#methods_of_an_instance_q_of_class_queue)
    中列出的方法，所有方法都是线程安全的，并且保证是原子操作。有关 SimpleQueue 实例公开的方法的详细信息，请参见 [Table 15-9](#classes_of_the_queue_module)。
    |
- en: Table 15-10\. Methods of an instance q of class Queue, LifoQueue, or PriorityQueue
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Table 15-10\. 类 Queue、LifoQueue 或 PriorityQueue 的实例 *q* 的方法
- en: '| empty | *q*.empty() Returns **True** when *q* is empty; otherwise, returns
    **False**. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| empty | *q*.empty() 返回 **True** 当 *q* 为空时；否则返回 **False**。 |'
- en: '| full | *q*.full() Returns **True** when *q* is full; otherwise, returns **False**.
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| full | *q*.full() 返回 **True** 当 *q* 满时；否则返回 **False**。 |'
- en: '| get, get_nowait | *q*.get(block=**True**, timeout=**None**), *q*.get_nowait()'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '| get, get_nowait | *q*.get(block=**True**, timeout=**None**), *q*.get_nowait()
    |'
- en: 'When block is **False**, get removes and returns an item from *q* if one is
    available; otherwise, get raises Empty. When block is **True** and timeout is
    **None**, get removes and returns an item from *q*, suspending the calling thread,
    if need be, until an item is available. When block is **True** and timeout is
    not **None**, timeout must be a number >=0 (which may include a fractional part
    to specify a fraction of a second), and get waits for no longer than timeout seconds
    (if no item is yet available by then, get raises Empty). *q*.get_nowait() is like
    *q*.get(**False**), which is also like *q*.get(timeout=0.0). get removes and returns
    items: in the same order as put inserted them (FIFO) if *q* is a direct instance
    of Queue itself, in LIFO order if *q* is an instance of LifoQueue, or in smallest-first
    order if *q* is an instance of PriorityQueue. |'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当 block 为 **False** 时，如果 *q* 中有可用项，则 get 移除并返回一个项；否则 get 抛出 Empty 异常。当 block
    为 **True** 且 timeout 为 **None** 时，如果需要，get 移除并返回 *q* 中的一个项，挂起调用线程，直到有可用项。当 block
    为 **True** 且 timeout 不为 **None** 时，timeout 必须是 >=0 的数字（可能包括用于指定秒的小数部分），get 等待不超过
    timeout 秒（如果到达超时时间仍然没有可用项，则 get 抛出 Empty）。*q*.get_nowait() 类似于 *q*.get(**False**)，也类似于
    *q*.get(timeout=0.0)。get 移除并返回项：如果 *q* 是 Queue 的直接实例，则按照 put 插入它们的顺序（FIFO），如果
    *q* 是 LifoQueue 的实例，则按 LIFO 顺序，如果 *q* 是 PriorityQueue 的实例，则按最小优先顺序。 |
- en: '| put, put_nowait | *q*.put(*item*, block=**True**, timeout=**None**) *q*.put_nowait(*item*)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '| put, put_nowait | *q*.put(*item*, block=**True**, timeout=**None**) *q*.put_nowait(*item*)
    |'
- en: When block is **False**, put adds *item* to *q* if *q* is not full; otherwise,
    put raises Full. When block is **True** and timeout is **None**, put adds *item*
    to *q*, suspending the calling thread, if need be, until *q* is not full. When
    block is **True** and timeout is not **None**, timeout must be a number >=0 (which
    may include a fractional part to specify a fraction of a second), and put waits
    for no longer than timeout seconds (if *q* is still full by then, put raises Full).
    *q*.put_nowait(*item*) is like *q*.put(*item*, **False**), which is also like
    *q*.put(*item*, timeout=0.0). |
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当block为**False**时，如果*q*不满，则put将*item*添加到*q*中；否则，put会引发Full异常。当block为**True**且timeout为**None**时，如果需要，put将*item*添加到*q*，挂起调用线程，直到*q*不再满为止。当block为**True**且timeout不为**None**时，timeout必须是>=0的数字（可能包括指定秒的小数部分），put等待不超过timeout秒（如果到时*q*仍然满，则put引发Full异常）。*q*.put_nowait(*item*)类似于*q*.put(*item*,
    **False**)，也类似于*q*.put(*item*, timeout=0.0)。
- en: '| qsize | *q*.qsize() Returns the number of items that are currently in *q*.
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| qsize | *q*.qsize() 返回当前在*q*中的项目数。 |'
- en: '*q* maintains an internal, hidden count of *unfinished tasks*, which starts
    at zero. Each call to put increments the count by one. To decrement the count
    by one, when a worker thread has finished processing a task, it calls *q*.task_done.
    To synchronize on “all tasks done,” call *q*.join: when the count of unfinished
    tasks is nonzero, *q*.join blocks the calling thread, unblocking later when the
    count goes to zero; when the count of unfinished tasks is zero, *q*.join continues
    the calling thread.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*q*维护一个内部的、隐藏的“未完成任务”计数，起始为零。每次调用put都会将计数增加一。要将计数减少一，当工作线程完成处理任务时，它调用*q*.task_done。为了同步“所有任务完成”，调用*q*.join：当未完成任务的计数非零时，*q*.join阻塞调用线程，稍后当计数变为零时解除阻塞；当未完成任务的计数为零时，*q*.join继续调用线程。'
- en: You don’t have to use join and task_done if you prefer to coordinate threads
    in other ways, but they provide a simple, useful approach when you need to coordinate
    systems of threads using a Queue.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢以其他方式协调线程，不必使用join和task_done，但是当需要使用队列协调线程系统时，它们提供了一种简单实用的方法。
- en: 'Queue offers a good example of the idiom “It’s easier to ask forgiveness than
    permission” (EAFP), covered in [“Error-Checking Strategies”](ch06.xhtml#error_checking_strategies).
    Due to multithreading, each nonmutating method of *q* (empty, full, qsize) can
    only be advisory. When some other thread mutates *q*, things can change between
    the instant a thread gets information from a nonmutating method and the very next
    moment, when the thread acts on the information. Relying on the “look before you
    leap” (LBYL) idiom is therefore futile, and fiddling with locks to try to fix
    things is a substantial waste of effort. Avoid fragile LBYL code, such as:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 队列提供了“宁可请求宽恕，不要请求许可”（EAFP）的典型例子，见[“错误检查策略”](ch06.xhtml#error_checking_strategies)。由于多线程，*q*的每个非变异方法（empty、full、qsize）只能是建议性的。当其他线程变异*q*时，线程从非变异方法获取信息的瞬间和线程根据该信息采取行动的下一瞬间之间可能发生变化。因此，依赖“先看再跳”（LBYL）的习惯是徒劳的，而为了修复问题而摆弄锁定则是大量浪费精力。避免脆弱的LBYL代码，例如：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'and instead use the simpler and more robust EAFP approach:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 而是采用更简单和更健壮的EAFP方法：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The multiprocessing Module
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多进程模块
- en: 'The multiprocessing module supplies functions and classes to code pretty much
    as you would for multithreading, but distributing work across processes, rather
    than across threads: these include the class Process (analogous to threading.Thread)
    and classes for synchronization primitives (Lock, RLock, Condition, Event, Semaphore,
    BoundedSemaphore, and Barrier—each similar to the class with the same name in
    the threading module—as well as Queue and JoinableQueue, both similar to queue.Queue).
    These classes make it easy to take code written to use threading and port it to
    a version using multiprocessing instead; just pay attention to the differences
    we cover in the following subsection.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 多进程模块提供了函数和类，几乎可以像多线程一样编写代码，但是将工作分布到进程而不是线程中：这些包括类Process（类似于threading.Thread）和用于同步原语的类（Lock、RLock、Condition、Event、Semaphore、BoundedSemaphore和Barrier，每个类似于线程模块中同名的类，以及Queue和JoinableQueue，这两者类似于queue.Queue）。这些类使得将用于线程的代码转换为使用多进程的版本变得简单；只需注意我们在下一小节中涵盖的差异即可。
- en: 'It’s usually best to avoid sharing state among processes: use queues, instead,
    to explicitly pass messages among them. However, for those rare occasions in which
    you do need to share some state, multiprocessing supplies classes to access shared
    memory (Value and Array), and—more flexibly (including coordination among different
    computers on a network) though with more overhead—a Process subclass, Manager,
    designed to hold arbitrary data and let other processes manipulate that data via
    *proxy* objects. We cover state sharing in [“Sharing State: Classes Value, Array,
    and Manager”](#sharing_state_classes_valuecomma_arrayc).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好避免在进程之间共享状态：而是使用队列来显式地在它们之间传递消息。然而，在确实需要共享一些状态的罕见情况下，multiprocessing提供了访问共享内存的类（Value和Array），以及更灵活的（包括在网络上不同计算机之间的协调）但带有更多开销的过程子类Manager，设计用于保存任意数据并让其他进程通过*代理*对象操作该数据。我们在[“共享状态：类Value、Array和Manager”](#sharing_state_classes_valuecomma_arrayc)中介绍状态共享。
- en: When you’re writing new code, rather than porting code originally written to
    use threading, you can often use different approaches supplied by multiprocessing.
    The Pool class, in particular (covered in [“Process Pools”](#process_pools)),
    can often simplify your code. The simplest and highest-level way to do multiprocessing
    is to use the concurrent.futures module (covered in [“The concurrent.futures Module”](#the_concurrentdotfutures_module))
    along with the ProcessPoolExecutor.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写新代码时，与其移植最初使用线程编写的代码，通常可以使用multiprocessing提供的不同方法。特别是Pool类（在[“进程池”](#process_pools)中介绍）通常可以简化您的代码。进行多进程处理的最简单和最高级的方式是与ProcessPoolExecutor一起使用的concurrent.futures模块（在[“concurrent.futures模块”](#the_concurrentdotfutures_module)中介绍）。
- en: Other highly advanced approaches, based on Connection objects built by the Pipe
    factory function or wrapped in Client and Listener objects, are even more flexible,
    but quite a bit more complex; we do not cover them further in this book. For more
    in-depth coverage of multiprocessing, refer to the [online docs](https://oreil.ly/mq8d1)^([2](ch15.xhtml#ch01fn117))
    and third-party online tutorials like in [PyMOTW](https://oreil.ly/ApoV0).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 基于由Pipe工厂函数构建或包装在Client和Listener对象中的Connection对象的其他高级方法，甚至更加灵活，但也更加复杂；我们在本书中不再进一步讨论它们。有关更详尽的multiprocessing覆盖，请参阅[在线文档](https://oreil.ly/mq8d1)^([2](ch15.xhtml#ch01fn117))以及像[PyMOTW](https://oreil.ly/ApoV0)中的第三方在线教程。
- en: Differences Between multiprocessing and threading
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: multiprocessing与线程之间的区别
- en: You can pretty easily port code written to use threading into a variant using
    multiprocessing instead—however, there are several differences you must consider.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以相对容易地将使用线程编写的代码移植为使用multiprocessing的变体，但是您必须考虑几个不同之处。
- en: Structural differences
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构差异
- en: All objects that you exchange between processes (for example, via a queue, or
    an argument to a Process’s target function) are serialized via pickle, covered
    in [“The pickle Module”](ch12.xhtml#the_pickle_module). Therefore, you can only
    exchange objects that can be thus serialized. Moreover, the serialized bytestring
    cannot exceed about 32 MB (depending on the platform), or else an exception is
    raised; therefore, there are limits to the size of objects you can exchange.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您在进程之间交换的所有对象（例如通过队列或作为进程目标函数参数）都是通过pickle序列化的，详见[“pickle模块”](ch12.xhtml#the_pickle_module)。因此，您只能交换可以这样序列化的对象。此外，序列化的字节串不能超过约32
    MB（取决于平台），否则会引发异常；因此，您可以交换的对象大小存在限制。
- en: Especially in Windows, child processes *must* be able to import as a module
    the main script that’s spawning them. Therefore, be sure to guard all top-level
    code in the main script (meaning code that must not be executed again by child
    processes) with the usual **if** __name__ == '__main__' idiom, covered in [“The
    Main Program”](ch07.xhtml#the_main_program).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在Windows系统中，子进程*必须*能够将启动它们的主脚本作为模块导入。因此，请确保将主脚本中的所有顶级代码（指不应由子进程再次执行的代码）用通常的**if**
    __name__ == '__main__'惯用语包围起来，详见[“主程序”](ch07.xhtml#the_main_program)。
- en: If a process is abruptly killed (for example, via a signal) while using a queue
    or holding a synchronization primitive, it won’t be able to perform proper cleanup
    on that queue or primitive. As a result, the queue or primitive may get corrupted,
    causing errors in all other processes trying to use it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进程在使用队列或持有同步原语时被突然终止（例如通过信号），它将无法对该队列或原语执行适当的清理。因此，队列或原语可能会损坏，导致所有尝试使用它的其他进程出现错误。
- en: The Process class
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程类
- en: 'The class multiprocessing.Process is very similar to threading.Thread; it supplies
    all the same attributes and methods (see [Table 15-2](#constructorcomma_methodscomma_and_prop)),
    plus a few more, listed in [Table 15-11](#additional_attributes_and_methods_of_th).
    Its constructor has the following signature:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 类 multiprocessing.Process 与 threading.Thread 非常相似；它提供了所有相同的属性和方法（参见[表 15-2](#constructorcomma_methodscomma_and_prop)），以及一些额外的方法，在[表
    15-11](#additional_attributes_and_methods_of_th)中列出。它的构造函数具有以下签名：
- en: '| Process | **class** Process(name=**None**, target=**None**, args=(), kwargs={})
    *Always call* *Process* *with named arguments*: the number and order of parameters
    is not guaranteed by the specification, but the parameter names are. Either instantiate
    the class Process itself, passing a target function (*p*.run then calls *target*(**args*,
    ***kwargs*) when the thread is started); or, instead of passing target, extend
    the Process class and override its run method. In either case, execution will
    begin only when you call *p*.start. name becomes *p*’s name. If name is **None**,
    Process generates a unique name for *p*. If a subclass *P* of Process overrides
    __init__, *P*.__init__ *must* call Process.__init__ on self (usually via the super
    built-in function) before any other Process method. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 进程 | **类** Process(name=**None**, target=**None**, args=(), kwargs={}) *始终*
    *使用命名参数* *调用* *Process*：参数的数量和顺序不受规范保证，但参数名是固定的。要么实例化 Process 类本身，传递一个目标函数（*p*.run
    在线程启动时调用 *target*(*args*, ***kwargs*)）；或者，而不是传递目标，扩展 Process 类并覆盖其 run 方法。在任一情况下，只有在调用
    *p*.start 时执行将开始。name 成为 *p* 的名称。如果 name 为 **None**，Process 为 *p* 生成唯一名称。如果 Process
    的子类 *P* 覆盖 __init__，*P*.__init__ *必须* 在任何其他 Process 方法之前在 self 上调用 Process.__init__（通常通过
    super 内置函数）。 |'
- en: Table 15-11\. Additional attributes and methods of the Process class
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-11\. Process 类的附加属性和方法
- en: '| authkey | The process’s authorization key, a bytestring. This is initialized
    to random bytes supplied by os.urandom, but you can reassign it later if you wish.
    Used in the authorization handshake for advanced uses we do not cover in this
    book. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| authkey | 进程的授权密钥，一个字节串。这是由 os.urandom 提供的随机字节初始化的，但如果需要，您可以稍后重新分配它。用于授权握手的高级用途我们在本书中没有涵盖。
    |'
- en: '| close | close() Closes a Process instance and releases all resources associated
    with it. If the underlying process is still running, raises ValueError. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| close | close() 关闭进程实例并释放所有与之关联的资源。如果底层进程仍在运行，则引发 ValueError。 |'
- en: '| exitcode | **None** when the process has not exited yet; otherwise, the process’s
    exit code. This is an int: 0 for success, >0 for failure, <0 when the process
    was killed. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| exitcode | **None** 当进程尚未退出时；否则，进程的退出码。这是一个整数：成功为 0，失败为 >0，进程被杀死为 <0。 |'
- en: '| kill | kill() Same as terminate, but on Unix sends a SIGKILL signal. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| kill | kill() 与 terminate 相同，但在 Unix 上发送 SIGKILL 信号。 |'
- en: '| pid | **None** when the process has not started yet; otherwise, the process’s
    identifier as set by the operating system. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| pid | **None** 当进程尚未启动时；否则，进程的标识符由操作系统设置。 |'
- en: '| terminate | terminate() Kills the process (without giving it a chance to
    execute termination code, such as cleanup of queues and synchronization primitives;
    beware of the likelihood of causing errors when the process is using a queue or
    holding a synchronization primitive!). |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| terminate | terminate() 终止进程（不给予其执行终止代码的机会，如清理队列和同步原语；当进程正在使用队列或持有同步原语时，可能会引发错误！）。
    |'
- en: Differences in queues
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 队列的区别
- en: The class multiprocessing.Queue is very similar to queue.Queue, except that
    an instance *q* of multiprocessing.Queue does *not* supply the methods join and
    task_done (described in [“The queue Module”](#the_queue_module)). When methods
    of *q* raise exceptions due to timeouts, they raise instances of queue.Empty or
    queue.Full. multiprocessing has no equivalents to queue’s LifoQueue and PriorityQueue
    classes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 类 multiprocessing.Queue 与 queue.Queue 非常相似，不同之处在于 multiprocessing.Queue 的实例
    *q* 不提供方法 join 和 task_done（在[“队列模块”](#the_queue_module)中描述）。当 *q* 的方法由于超时而引发异常时，它们会引发
    queue.Empty 或 queue.Full 的实例。multiprocessing 没有 queue 的 LifoQueue 和 PriorityQueue
    类的等效物。
- en: 'The class multiprocessing.JoinableQueue does supply the methods join and task_done,
    but with a semantic difference compared to queue.Queue: with an instance *q* of
    multiprocessing.JoinableQueue, the process that calls *q*.get *must* call *q*.task_done
    when it’s done processing that unit of work (it’s not optional, as it is when
    using queue.Queue).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 类 multiprocessing.JoinableQueue 确实提供了方法 join 和 task_done，但与 queue.Queue 相比有语义上的区别：对于
    multiprocessing.JoinableQueue 的实例 *q*，调用 *q*.get 的进程在处理完工作单元后 *必须* 调用 *q*.task_done（这不是可选的，就像使用
    queue.Queue 时那样）。
- en: All objects you put in multiprocessing queues must be serializable by pickle.
    There may be a delay between the time you execute q.put and the time the object
    is available from q.get. Lastly, remember that an abrupt exit (crash or signal)
    of a process using *q* may leave *q* unusable for any other process.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您放入 multiprocessing 队列的所有对象必须能够通过 pickle 进行序列化。在执行 q.put 和对象从 q.get 可用之间可能会有延迟。最后，请记住，进程使用
    *q* 的突然退出（崩溃或信号）可能会使 *q* 对于任何其他进程不可用。
- en: 'Sharing State: Classes Value, Array, and Manager'
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享状态：类 Value、Array 和 Manager
- en: To use shared memory to hold a single primitive value in common among two or
    more processes, multiprocessing supplies the class Value, and for a fixed-length
    array of primitive values, it provides the class Array. For more flexibility (including
    sharing nonprimitive values and “sharing” among different systems joined by a
    network but sharing no memory), at the cost of higher overhead, multiprocessing
    supplies the class Manager, which is a subclass of Process. We’ll look at each
    of these in the following subsections.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在两个或多个进程之间共享单个原始值，multiprocessing 提供了类 Value，并且对于固定长度的原始值数组，它提供了类 Array。为了获得更大的灵活性（包括共享非原始值和在网络连接的不同系统之间“共享”但不共享内存的情况），multiprocessing
    提供了 Manager 类，它是 Process 的子类，但开销较高。我们将在以下小节中详细看看这些类。
- en: The Value class
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Value 类
- en: 'The constructor for the class Value has the signature:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 类 Value 的构造函数具有以下签名：
- en: '| Value | **class** Value(*typecode*, **args*, ***, lock=**True**) *typecode*
    is a string defining the primitive type of the value, just like for the array
    module, covered in [“The array Module”](ch16.xhtml#the_array_module). (Alternatively,
    *typecode* can be a type from the module ctypes, discussed in [“ctypes” in Chapter
    25](https://oreil.ly/python-nutshell-25), but this is rarely necessary.) *args*
    is passed on to the type’s constructor: therefore, *args* is either absent (in
    which case the primitive is initialized as per its default, typically 0) or a
    single value, which is used to initialize the primitive.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '| Value | **class** Value(*typecode*, **args*, ***, lock=**True**) *typecode*
    是一个字符串，定义值的基本类型，就像在 [“数组模块”](ch16.xhtml#the_array_module) 中所讨论的 array 模块一样。（另外，*typecode*
    可以是来自 ctypes 模块的类型，这在 [第 25 章“ctypes”](https://oreil.ly/python-nutshell-25) 中讨论过，但这很少需要。）*args*
    被传递到类型的构造函数中：因此，*args* 要么不存在（在这种情况下，基本类型会按其默认值初始化，通常为 0），要么是一个单一的值，用于初始化该基本类型。'
- en: 'When lock is **True** (the default), Value makes and uses a new lock to guard
    the instance. Alternatively, you can pass as lock an existing Lock or RLock instance.
    You can even pass lock=**False**, but that is rarely advisable: when you do, the
    instance is not guarded (thus, it is not synchronized among processes) and is
    missing the method get_lock. If you do pass lock, you *must* pass it as a named
    argument, using lock=*something*. |'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当 lock 为 **True**（默认情况下），Value 将创建并使用一个新的锁来保护实例。或者，您可以将现有的 Lock 或 RLock 实例作为锁传递。甚至可以传递
    lock=**False**，但这很少是明智的选择：当您这样做时，实例不受保护（因此在进程之间不同步），并且缺少方法 get_lock。如果传递 lock，则必须将其作为命名参数，使用
    lock=*something*。
- en: An instance *v* of the class Value supplies the method get_lock, which returns
    (but neither acquires nor releases) the lock guarding *v*, and the read/write
    attribute value, used to set and get *v*’s underlying primitive value.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类值的实例 *v* 提供了方法 get_lock，该方法返回（但不获取也不释放）保护 *v* 的锁，并且具有读/写属性 value，用于设置和获取
    *v* 的基本原始值。
- en: 'To ensure atomicity of operations on *v*’s underlying primitive value, guard
    the operation in a **with** *v*.get_lock(): statement. A typical example of such
    usage might be for augmented assignment, as in:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '为了确保对 *v* 的基本原始值的操作是原子性的，请在 **with** *v*.get_lock(): 语句中保护该操作。一个典型的使用例子可能是增强赋值，如下所示：'
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If any other process does an unguarded operation on that same primitive value,
    however—even an atomic one such as a simple assignment like *v*.value = *x*—all
    bets are off: the guarded operation and the unguarded one can get your system
    into a *race condition*.^([3](ch15.xhtml#ch01fn118)) Play it safe: if *any* operation
    at all on *v*.value is not atomic (and thus needs to be guarded by being within
    a **with** *v*.get_lock(): block), guard *all* operations on *v*.value by placing
    them within such blocks.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果任何其他进程对相同的原始值执行了不受保护的操作——甚至是原子操作，比如简单的赋值操作，如 *v*.value = *x*——那么一切都不确定：受保护的操作和不受保护的操作可能导致系统出现
    *竞态条件*。[^3] 为了安全起见：如果 *v*.value 上的 *任何* 操作都不是原子的（因此需要通过位于 `with v.get_lock():`
    块中的保护），那么通过将它们放在这些块中来保护 *v*.value 上的 *所有* 操作。
- en: The Array class
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Array` 类'
- en: 'A multiprocessing.Array is a fixed-length array of primitive values, with all
    items of the same primitive type. The constructor for the class Array has the
    signature:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing.Array` 是一个固定长度的原始值数组，所有项都是相同的原始类型。`Array` 类的构造函数具有如下签名：'
- en: '| Array | **class** Array(*typecode*, *size_or_initializer*, ***, lock=**True**)
    *typecode* is a string defining the primitive type of the value, just like for
    the module array, as covered in [“The array Module”](ch16.xhtml#the_array_module).
    (Alternatively, *typecode* can be a type from the module ctypes, discussed in
    [“ctypes” in Chapter 25](https://oreil.ly/python-nutshell-25), but this is rarely
    necessary.) *size_or_initializer* can be an iterable, used to initialize the array,
    or an integer used as the length of the array, in which case each item of the
    array is initialized to 0.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Array` | **class** `Array`(*typecode*, *size_or_initializer*, ***, lock=**True**)
    *typecode* 是定义值的原始类型的字符串，就像在 [“数组模块”](ch16.xhtml#the_array_module) 中所介绍的那样，与模块
    `array` 中的处理方式相同。（另外，*typecode* 可以是模块 `ctypes` 中的类型，讨论在 [第25章“ctypes”](https://oreil.ly/python-nutshell-25)
    中，但这很少是必要的。）*size_or_initializer* 可以是可迭代对象，用于初始化数组，或者是用作数组长度的整数，在这种情况下，数组的每个项都初始化为
    0。'
- en: 'When lock is **True** (the default), Array makes and uses a new lock to guard
    the instance. Alternatively, you can pass as lock an existing Lock or RLock instance.
    You can even pass lock=**False**, but that is rarely advisable: when you do, the
    instance is not guarded (thus it is not synchronized among processes) and is missing
    the method get_lock. If you do pass lock, you *must* pass it as a named argument,
    using lock=*something*. |'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `lock` 为 **True**（默认值）时，`Array` 会创建并使用一个新的锁来保护实例。或者，您可以将现有的 `Lock` 或 `RLock`
    实例作为锁传递给 `lock`。您甚至可以传递 `lock=False`，但这很少是明智的：当您这样做时，实例不受保护（因此在进程之间不同步），并且缺少 `get_lock`
    方法。如果您传递 `lock`，则*必须*将其作为命名参数传递，使用 `lock=*something*`。 |
- en: An instance *a* of the class Array supplies the method get_lock, which returns
    (but neither acquires nor releases) the lock guarding *a*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array` 类的实例 *a* 提供了方法 `get_lock`，该方法返回（但不获取也不释放）保护 *a* 的锁。'
- en: '*a* is accessed by indexing and slicing, and modified by assigning to an indexing
    or to a slice. *a* is fixed length: therefore, when you assign to a slice, you
    must assign an iterable of exactly the same length as the slice you’re assigning
    to. *a* is also iterable.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* 通过索引和切片访问，并通过对索引或切片赋值来修改。*a* 是固定长度的：因此，当您对切片赋值时，您必须将一个与您要赋值的切片完全相同长度的可迭代对象赋值给它。*a*
    也是可迭代的。'
- en: 'In the special case where *a* was built with a *typecode* of ''c'', you can
    also access *a*.value to get *a*’s contents as a bytestring, and you can assign
    to *a*.value any bytestring no longer than len(*a*). When *s* is a bytestring
    with len(*s*) < len(*a*), *a*.value = *s* means *a*[:len(*s*)+1] = *s* + b''\0'';
    this mirrors the representation of char strings in the C language, terminated
    with a 0 byte. For example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在特殊情况下，当 *a* 使用 `'c'` 类型码构建时，您还可以访问 *a*.value 以获取 *a* 的内容作为字节串，并且您可以将任何长度不超过
    len(*a*) 的字节串分配给 *a*.value。当 *s* 是长度小于 len(*a*) 的字节串时，*a*.value = *s* 意味着 *a*[:len(*s*)+1]
    = *s* + b'\0'；这反映了 C 语言中字符串的表示，以 0 字节终止。例如：
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Manager class
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Manager` 类'
- en: multiprocessing.Manager is a subclass of multiprocessing.Process, with the same
    methods and attributes. In addition, it supplies methods to build an instance
    of any of the multiprocessing synchronization primitives, plus Queue, dict, list,
    and Namespace, the latter being a class that just lets you set and get arbitrary
    named attributes. Each of the methods has the name of the class whose instances
    it builds, and returns a *proxy* to such an instance, which any process can use
    to call methods (including special methods, such as indexing of instances of dict
    or list) on the instance held in the manager process.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: multiprocessing.Manager 是 multiprocessing.Process 的子类，具有相同的方法和属性。此外，它还提供方法来构建任何
    multiprocessing 同步原语的实例，包括 Queue、dict、list 和 Namespace。Namespace 是一个类，允许您设置和获取任意命名属性。每个方法都以它所构建实例的类名命名，并返回一个*代理*到这样一个实例，任何进程都可以使用它来调用方法（包括
    dict 或 list 实例的索引等特殊方法）。
- en: 'Proxy objects pass most operators, and accesses to methods and attributes,
    on to the instance they proxy for; however, they don’t pass on *comparison* operators—if
    you need a comparison, you need to take a local copy of the proxied object. For
    example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 代理对象大多数操作符、方法和属性访问都会传递给它们代理的实例；但是，它们不会传递*比较*操作符 —— 如果你需要比较，就需要获取代理对象的本地副本。例如：
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The constructor of Manager takes no arguments. There are advanced ways to customize
    Manager subclasses to allow connections from unrelated processes (including ones
    on different computers connected via a network) and to supply a different set
    of building methods, but we do not cover them in this book. Rather, one simple,
    often-sufficient approach to using Manager is to explicitly transfer to other
    processes the proxies it produces, typically via queues, or as arguments to a
    Process’s *target* function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Manager 的构造函数不接受任何参数。有高级方法来定制 Manager 子类，以允许来自无关进程的连接（包括通过网络连接的不同计算机上的进程），并提供不同的构建方法集，但这些内容不在本书的讨论范围之内。使用
    Manager 的一个简单而通常足够的方法是显式地将它生成的代理传输给其他进程，通常通过队列或作为进程的*目标*函数的参数。
- en: For example, suppose there is a long-running, CPU-bound function *f* that, given
    a string as an argument, eventually returns a corresponding result; given a set
    of strings, we want to produce a dict with the strings as keys and the corresponding
    results as values. To be able to follow on which processes *f* runs, we also print
    the process ID just before calling *f*. [Example 15-1](#example_onefive_onedot_distributing_wor)
    shows one way to do this.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设有一个长时间运行的 CPU 绑定函数 *f*，给定一个字符串作为参数，最终返回对应的结果；给定一组字符串，我们希望生成一个字典，其键为字符串，值为相应的结果。为了能够跟踪
    *f* 运行在哪些进程上，我们在调用 *f* 前还打印进程 ID。[示例 15-1](#example_onefive_onedot_distributing_wor)
    展示了如何实现这一点。
- en: Example 15-1\. Distributing work to multiple worker processes
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-1\. 将工作分配给多个工作进程
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Process Pools
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程池
- en: In real life, you should always avoid creating an unbounded number of worker
    processes, as we did in [Example 15-1](#example_onefive_onedot_distributing_wor).
    Performance benefits accrue only up to the number of cores in your machine (available
    by calling multiprocessing.cpu_count), or a number just below or just above this,
    depending on such minutiae as your platform, how CPU-bound or I/O-bound your code
    is, other tasks running on your computer, etc. Making many more worker processes
    than such an optimal number incurs substantial extra overhead without any compensating
    benefit.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，应始终避免创建无限数量的工作进程，就像我们在[示例 15-1](#example_onefive_onedot_distributing_wor)中所做的那样。性能的提升仅限于您计算机上的核心数（可通过调用
    multiprocessing.cpu_count 获取），或者略高于或略低于此数，具体取决于您的平台、代码是 CPU 绑定还是 I/O 绑定，计算机上运行的其他任务等微小差异。创建比这个最佳数量多得多的工作进程会带来大量额外的开销，却没有任何补偿性的好处。
- en: As a consequence, it’s a common design pattern to start a *pool* with a limited
    number of worker processes, and farm out work to them. The class multiprocessing.Pool
    lets you orchestrate this pattern.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个常见的设计模式是启动一个带有有限数量工作进程的*池*，并将工作分配给它们。multiprocessing.Pool 类允许您编排这种模式。
- en: The Pool class
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 池类
- en: 'The constructor for the class Pool has the signature:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 类 Pool 的构造函数签名为：
- en: '| Pool | **class** Pool(processes=None, initializer=**None**, initargs=(),
    maxtasksperchild=**None**)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '| 池 | **类** Pool(processes=None, initializer=**None**, initargs=(), maxtasksperchild=**None**)'
- en: processes is the number of processes in the pool; it defaults to the value returned
    by cpu_count. When initializer is not **None**, it’s a function, called at the
    start of each process in the pool, with initargs as arguments, like initializer(**initargs*).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: processes 是池中的进程数；默认值为 cpu_count 返回的值。当 initializer 不为 **None** 时，它是一个函数，在池中每个进程开始时调用，带有
    initargs 作为参数，例如 initializer(**initargs*)。
- en: When maxtasksperchild is not **None**, it’s the maximum number of tasks that
    can be executed in each process in the pool. When a process in the pool has executed
    that many tasks, it terminates, then a new process starts and joins the pool.
    When maxtasksperchild is **None** (the default), each process lives as long as
    the pool. |
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当 maxtasksperchild 不为 **None** 时，它是池中每个进程可以执行的最大任务数。当池中的进程执行了这么多任务后，它终止，然后一个新的进程启动并加入池。当
    maxtasksperchild 为 **None**（默认值）时，每个进程的生命周期与池一样长。
- en: An instance *p* of the class Pool supplies the methods listed in [Table 15-12](#methods_of_an_instance_p_of_class_pool)
    (each of them must be called only in the process that built instance *p*).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 类 Pool 的实例 *p* 提供了 [表 15-12](#methods_of_an_instance_p_of_class_pool) 中列出的方法（每个方法只能在构建实例
    *p* 的进程中调用）。
- en: Table 15-12\. Methods of an instance p of class Pool
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-12\. 类 Pool 的实例 p 的方法
- en: '| apply | apply(*func*, args=(), kwds={}) In an arbitrary one of the worker
    processes, runs *func*(**args*, ***kwds*), waits for it to finish, and returns
    *func*’s result. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| apply | apply(*func*, args=(), kwds={}) 在工作进程中的任意一个，运行 *func*(**args*, ***kwds*），等待其完成，并返回
    *func* 的结果。 |'
- en: '| apply_async | apply_async(*func*, args=(), kwds={}, callback=**None**) In
    an arbitrary one of the worker processes, starts running *func*(**args*, ***kwds*)
    and, without waiting for it to finish, immediately returns an AsyncResult instance,
    which eventually gives *func*’s result, when that result is ready. (The AsyncResult
    class is discussed in the following section.) When callback is not **None**, it’s
    a function to call (in a new, separate thread in the process that calls apply_async),
    with *func*’s result as the only argument, when that result is ready; callback
    should execute rapidly, because otherwise it blocks the calling process. callback
    may mutate its argument if that argument is mutable; callback’s return value is
    irrelevant (so, the best, clearest style is to have it return **None**). |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| apply_async | apply_async(*func*, args=(), kwds={}, callback=**None**) 在工作进程中的任意一个，开始运行
    *func*(**args*, ***kwds*），并且不等待其完成，立即返回一个 AsyncResult 实例，该实例最终提供 *func* 的结果，当结果准备就绪时。
    （AsyncResult 类在下一节中讨论。）当 callback 不为 **None** 时，它是一个函数，用 *func* 的结果作为唯一参数调用（在调用
    apply_async 的进程中的新线程中），当结果准备就绪时；callback 应该快速执行，因为否则会阻塞调用进程。如果参数是可变的，则 callback
    可以改变其参数；callback 的返回值是无关紧要的（因此，最佳、最清晰的风格是让它返回 **None**）。 |'
- en: '| close | close() Sets a flag prohibiting further submissions to the pool.
    Worker processes terminate when they’re done with all outstanding tasks. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| close | close() 设置一个标志，禁止进一步向池提交任务。工作进程在完成所有未完成的任务后终止。 |'
- en: '| imap | imap(*func*, *iterable*, chunksize=1) Returns an iterator calling
    *func* on each item of *iterable*, in order. chunksize determines how many consecutive
    items are sent to each process; on a very long *iterable*, a large chunksize can
    improve performance. When chunksize is 1 (the default), the returned iterator
    has a method next (even though the canonical name of the iterator’s method is
    __next__), accepting an optional *timeout* argument (a floating-point value, in
    seconds) and raising multiprocessing.TimeoutError should the result not yet be
    ready after *timeout* seconds. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| imap | imap(*func*, *iterable*, chunksize=1) 返回一个迭代器，在每个 *iterable* 的项上调用
    *func*，顺序执行。chunksize 确定连续发送给每个进程的项数；在非常长的 *iterable* 上，较大的 chunksize 可以提高性能。当
    chunksize 为 1（默认值）时，返回的迭代器有一个方法 next（即使迭代器方法的规范名称是 __next__），接受一个可选的 *timeout*
    参数（浮点数值，单位秒），在 *timeout* 秒后仍未准备就绪时引发 multiprocessing.TimeoutError。'
- en: '| im⁠a⁠p⁠_​u⁠n⁠o⁠rdered | imap_unordered(*func*, *iterable*, chunksize=1) Same
    as imap, but the ordering of the results is arbitrary (this can sometimes improve
    performance when the order of iteration is unimportant). It is usually helpful
    if the function’s return value includes enough information to allow the results
    to be associated with the values from the iterable used to generate them. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| im⁠a⁠p⁠_​u⁠n⁠o⁠r⁠d⁠e⁠r⁠e⁠d | imap_unordered(*func*, *iterable*, chunksize=1)
    与 imap 相同，但结果的顺序是任意的（在迭代顺序不重要时，有时可以提高性能）。如果函数的返回值包含足够的信息，以允许将结果与用于生成它们的 iterable
    的值关联，则通常很有帮助。'
- en: '| join | join() Waits for all worker processes to exit. You must call close
    or terminate before you call join. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| join | join() 等待所有工作进程退出。您必须在调用 join 之前调用 close 或 terminate。|'
- en: '| map | map(*func*, *iterable*, chunksize=1) Calls *func* on each item of *iterable*,
    in order, in worker processes in the pool; waits for them all to finish, and returns
    the list of results. chunksize determines how many consecutive items are sent
    to each process; on a very long *iterable*, a large chunksize can improve performance.
    |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| map | map(*func*, *iterable*, chunksize=1) 在池中的工作进程上按顺序对 *iterable* 中的每个项目调用
    *func*；等待它们全部完成，并返回结果列表。chunksize 确定每个进程发送多少连续项目；在非常长的 *iterable* 上，较大的 chunksize
    可以提高性能。|'
- en: '| map_async | map_async(*func*, *iterable*, chunksize=1, callback=**None**)
    Arranges for *func* to be called on each item of *iterable* in worker processes
    in the pool; without waiting for any of this to finish, immediately returns an
    AsyncResult instance (described in the following section), which eventually gives
    the list of *func*’s results, when that list is ready.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '| map_async | map_async(*func*, *iterable*, chunksize=1, callback=**None**)
    安排在池中的工作进程上对可迭代对象 *iterable* 中的每个项目调用 *func*；在等待任何操作完成之前，立即返回一个 AsyncResult 实例（在下一节中描述），该实例最终提供
    *func* 的结果列表，当该列表准备就绪时。'
- en: When callback is not **None**, it’s a function to call (in a separate thread
    in the process that calls map_async) with the list of *func*’s results, in order,
    as the only argument, when that list is ready; callback should execute rapidly,
    since otherwise it blocks the process. callback may mutate its list argument;
    callback’s return value is irrelevant (so, best, clearest style is to have it
    return **None**). |
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当 callback 不为 **None** 时，它是一个函数（在调用 map_async 的进程的单独线程中调用），其参数是按顺序排列的 *func*
    的结果列表，当该列表准备就绪时。callback 应该快速执行，否则会阻塞进程。callback 可能会改变其列表参数；callback 的返回值是无关紧要的（因此，最好、最清晰的风格是让其返回
    **None**）。|
- en: '| terminate | terminate() Terminates all worker processes at once, without
    waiting for them to complete work. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| terminate | terminate() 一次性终止所有工作进程，而无需等待它们完成工作。|'
- en: 'For example, here’s a Pool-based approach to perform the same task as the code
    in [Example 15-1](#example_onefive_onedot_distributing_wor):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一种基于池的方法来执行与 [Example 15-1](#example_onefive_onedot_distributing_wor) 中代码相同的任务：
- en: '[PRE19]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The AsyncResult class
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步结果类
- en: The methods apply_async and map_async of the class Pool return an instance of
    the class AsyncResult. An instance *r* of the class AsyncResult supplies the methods
    listed in [Table 15-13](#methods_of_an_instance_r_of_class_async).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 类 Pool 的方法 apply_async 和 map_async 返回类 AsyncResult 的一个实例。类 AsyncResult 的一个实例
    *r* 提供了 [Table 15-13](#methods_of_an_instance_r_of_class_async) 中列出的方法。
- en: Table 15-13\. Methods of an instance r of class AsyncResult
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-13\. 类 AsyncResult 实例 r 的方法
- en: '| get | get(timeout=**None**) Blocks and returns the result when ready, or
    re-raises the exception raised while computing the result. When timeout is not
    **None**, it’s a floating-point value in seconds; get raises multiprocessing.TimeoutError
    should the result not yet be ready after timeout seconds. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| get | get(timeout=**None**) 阻塞并在结果准备就绪时返回结果，或在计算结果时重新引发引发的异常。当 timeout 不为
    **None** 时，它是以秒为单位的浮点值；如果在超时秒后结果尚未准备就绪，则 get 会引发 multiprocessing.TimeoutError。|'
- en: '| ready | ready() Does not block; returns **True** if the call has completed
    with a result or has raised an exception; otherwise, returns **False**. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| ready | ready() 不阻塞；如果调用已完成并返回结果或已引发异常，则返回 **True**；否则返回 **False**。|'
- en: '| successful | successful() Does not block; returns **True** if the result
    is ready and the computation did not raise an exception, or returns **False**
    if the computation raised an exception. If the result is not yet ready, successful
    raises AssertionError. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| successful | successful() 不阻塞；如果结果已准备就绪且计算未引发异常，则返回 **True**；如果计算引发异常，则返回
    **False**。如果结果尚未准备就绪，successful 将引发 AssertionError。|'
- en: '| wait | wait(timeout=**None**) Blocks and waits until the result is ready.
    When timeout is not **None**, it’s a floating-point value in seconds: wait raises
    multiprocessing.TimeoutError should the result not yet be ready after timeout
    seconds. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| wait | wait(timeout=**None**) 阻塞并等待结果准备就绪。当 timeout 不为 **None** 时，它是以秒为单位的浮点值：如果在超时秒后结果尚未准备就绪，则
    wait 会引发 multiprocessing.TimeoutError。|'
- en: The ThreadPool class
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程池类
- en: 'The multiprocessing.pool module also offers a class called ThreadPool, with
    exactly the same interface as Pool, implemented with multiple threads within a
    single process (not with multiple processes, despite the module’s name). The equivalent
    make_dict code to [Example 15-1](#example_onefive_onedot_distributing_wor) using
    a ThreadPool would be:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: multiprocessing.pool 模块还提供了一个名为 ThreadPool 的类，其接口与 Pool 完全相同，但在单个进程中使用多个线程实现（而不是多个进程，尽管模块的名称如此）。使用
    ThreadPool 的等效 make_dict 代码，与 [示例 15-1](#example_onefive_onedot_distributing_wor)
    中使用 ThreadPoolExecutor 的代码类似：
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since a ThreadPool uses multiple threads but is limited to running in a single
    process, it is most suitable for applications where the separate threads are performing
    overlapping I/O. As stated previously, Python threading offers little advantage
    when the work is primarily CPU-bound.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ThreadPool 使用多个线程但限于在单个进程中运行，因此最适合于其各个线程执行重叠 I/O 的应用程序。正如前面所述，当工作主要受 CPU
    限制时，Python 线程提供的优势很小。
- en: In modern Python, you should generally prefer the Executor abstract class from
    the module concurrent.futures, covered in next section, and its two implementations,
    ThreadPoolExecutor and ProcessPoolExecutor. In particular, the Future objects
    returned by submit methods of the executor classes implemented by concurrent.futures
    are compatible with the asyncio module (which, as previously mentioned, we do
    not cover in this book, but which is nevertheless a crucial part of much concurrent
    processing in recent versions of Python). The AsyncResult objects returned by
    the methods apply_async and map_async of the pool classes implemented by multiprocessing
    are not asyncio compatible.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 Python 中，您通常应优先使用模块 concurrent.futures 中的抽象类 Executor（下一节将介绍），以及其两个实现，ThreadPoolExecutor
    和 ProcessPoolExecutor。特别是，由 concurrent.futures 实现的执行器类的 submit 方法返回的 Future 对象与
    asyncio 模块兼容（正如前面提到的，我们不在本书中涵盖 asyncio，但它仍然是 Python 最近版本中许多并发处理的重要部分）。由 multiprocessing
    实现的池类的 apply_async 和 map_async 方法返回的 AsyncResult 对象不兼容 asyncio。
- en: The concurrent.futures Module
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发.futures 模块
- en: The concurrent package supplies a single module, futures. concurrent.futures
    provides two classes, ThreadPoolExecutor (using threads as workers) and ProcessPoolExecutor
    (using processes as workers), which implement the same abstract interface, Executor.
    Instantiate either kind of pool by calling the class with one argument, max_workers,
    specifying how many threads or processes the pool should contain. You can omit
    max_workers to let the system pick the number of workers.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 并发包提供了一个单一模块，即 futures。concurrent.futures 提供了两个类，ThreadPoolExecutor（使用线程作为工作者）和
    ProcessPoolExecutor（使用进程作为工作者），它们实现了相同的抽象接口 Executor。通过调用该类并指定一个参数 max_workers
    来实例化任何一种池，该参数指定池应包含的线程或进程数。您可以省略 max_workers，让系统选择工作者数。
- en: An instance *e* of the Executor class supports the methods in [Table 15-14](#methods_of_an_instance_e_of_class_execu).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Executor 类的实例 *e* 支持 [表 15-14](#methods_of_an_instance_e_of_class_execu) 中的方法。
- en: Table 15-14\. Methods of an instance *e* of class Executor
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-14。类 Executor 的实例 *e* 的方法
- en: '| map | map(*func*, **iterables*, timeout=**None**, chunksize=1) Returns an
    iterator *it* whose items are the results of *func* called with one argument from
    each of the *iterables*, in order (using multiple worker threads or processes
    to execute *func* in parallel). When *timeout* is not **None**, it’s a float number
    of seconds: should next(*it*) not produce any result in timeout seconds, raises
    concurrent.futures.TimeoutError.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '| map | map(*func*, **iterables*, timeout=**None**, chunksize=1) 返回一个迭代器 *it*，其项是按顺序使用多个工作线程或进程并行执行
    *func* 的结果。当 *timeout* 不为 **None** 时，它是一个浮点秒数：如果在 timeout 秒内 next(*it*) 未产生任何结果，则引发
    concurrent.futures.TimeoutError。'
- en: 'You may also optionally specify (by name, only) argument chunksize: ignored
    for a ThreadPoolExecutor; for a ProcessPoolExecutor it sets how many items of
    each iterable in *iterables* are passed to each worker process. |'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以选择（仅按名称）指定参数 chunksize：对于 ThreadPoolExecutor 无效；对于 ProcessPoolExecutor，它设置每个可迭代项中的每个项目传递给每个工作进程的数量。
    |
- en: '| shutdown | shutdown(wait=**True**) No more calls to map or submit allowed.
    When wait is **True**, shutdown blocks until all pending futures are done; when
    **False**, shutdown returns immediately. In either case, the process does not
    terminate until all pending futures are done. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| shutdown | shutdown(wait=**True**) 禁止进一步调用 map 或 submit。当 wait 为 **True**
    时，shutdown 阻塞直到所有待处理的 Future 完成；当 **False** 时，shutdown 立即返回。在任何情况下，进程直到所有待处理的
    Future 完成后才终止。 |'
- en: '| submit | submit(*func*, **a*, ***k*) Ensures *func*(**a*, ***k*) executes
    on an arbitrary one of the pool’s processes or threads. Does not block, but rather
    immediately returns a Future instance. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| submit | `submit(*func*, **a*, ***k*)` 确保 *func*(**a*, ***k*) 在线程池的任一进程或线程中执行。不会阻塞，立即返回一个
    Future 实例。'
- en: Any instance of an Executor is also a context manager, and therefore suitable
    for use on a **with** statement (__exit__ being like shutdown(wait=**True**)).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Executor 实例也是上下文管理器，因此适合在 **with** 语句中使用（__exit__ 行为类似于 shutdown(wait=**True**))。
- en: 'For example, here’s a concurrent-based approach to perform the same task as
    in [Example 15-1](#example_onefive_onedot_distributing_wor):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个基于并发的方法来执行与 [示例 15-1](#example_onefive_onedot_distributing_wor) 中相同任务的方法：
- en: '[PRE21]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The submit method of an Executor returns a Future instance. A Future instance
    *f* supplies the methods described in [Table 15-15](#methods_of_an_instance_f_of_class_futur).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Executor 的 submit 方法返回一个 Future 实例。Future 实例 *f* 提供了表 15-15 中描述的方法。
- en: Table 15-15\. Methods of an instance f of class Future
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-15\. Future 类实例 *f* 的方法
- en: '| add_do⁠n⁠e⁠_​c⁠a⁠l⁠lback | add_done_callback(*func*) Adds callable *func*
    to *f*; *func* gets called, with *f* as the only argument, when *f* completes
    (i.e., is canceled, or finishes). |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| add_do⁠n⁠e⁠_​c⁠a⁠l⁠lback | `add_done_callback(*func*)` 将可调用对象 *func* 添加到
    *f* 上；当 *f* 完成（即取消或完成）时，会调用 *func*，并以 *f* 作为唯一参数。'
- en: '| cancel | cancel() Tries canceling the call. Returns **False** when the call
    is being executed and cannot be canceled; otherwise, returns **True**. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| cancel | `cancel()` 尝试取消调用。当调用正在执行且无法被取消时，返回 **False**；否则返回 **True**。'
- en: '| cancelled | cancelled() Returns **True** if the call was successfully canceled;
    otherwise, returns **False**. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| cancelled | `cancelled()` 返回 **True** 如果调用成功取消；否则返回 **False**。'
- en: '| done | done() Returns **True** when the call is completed (i.e., finished,
    or successfully canceled). |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| done | `done()` 返回 **True** 当调用完成（即已完成或成功取消）。'
- en: '| exception | exception(timeout=**None**) Returns the exception raised by the
    call, or **None** if the call raised no exception. When timeout is not **None**,
    it’s a float number of seconds to wait. If the call hasn’t completed after timeout
    seconds, exception raises concurrent.futures.TimeoutError; if the call is canceled,
    exception raises concurrent.futures.CancelledError. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| exception | `exception(timeout=**None**)` 返回调用引发的异常，如果调用没有引发异常则返回 **None**。当
    timeout 不为 **None** 时，它是一个浮点数秒数。如果调用在 timeout 秒内未完成，exception 抛出 concurrent.futures.TimeoutError；如果调用被取消，exception
    抛出 concurrent.futures.CancelledError。'
- en: '| result | result(timeout=**None**) Returns the call’s result. When timeout
    is not **None**, it’s a float number of seconds. If the call hasn’t completed
    within timeout seconds, result raises concurrent.futures.TimeoutError; if the
    call is canceled, result raises concurrent.futures.CancelledError. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| result | `result(timeout=**None**)` 返回调用的结果。当 timeout 不为 **None** 时，它是一个浮点数秒数。如果调用在
    timeout 秒内未完成，result 抛出 concurrent.futures.TimeoutError；如果调用被取消，result 抛出 concurrent.futures.CancelledError。'
- en: '| running | running() Returns **True** when the call is executing and cannot
    be canceled; otherwise, returns **False**. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| running | `running()` 返回 **True** 当调用正在执行且无法被取消；否则返回 **False**。'
- en: The concurrent.futures module also supplies two functions, detailed in [Table 15-16](#functions_of_the_concurrentdotfutures_m).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: concurrent.futures 模块还提供了两个函数，详见 [表 15-16](#functions_of_the_concurrentdotfutures_m)。
- en: Table 15-16\. Functions of the concurrent.futures module
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-16\. concurrent.futures 模块的函数
- en: '| a⁠s⁠_​c⁠o⁠m⁠pleted | as_completed(*fs*, timeout=**None**) Returns an iterator
    *it* over the Future instances that are the items of iterable *fs*. If there are
    duplicates in *fs*, each gets yielded just once. *it* yields one completed future
    at a time, in order, as they complete. If timeout is not **None**, it’s a float
    number of seconds; should it ever happen that no new future can yet be yielded
    within timeout seconds from the previous one, as_completed raises concurrent.futures.Timeout.
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| a⁠s⁠_​c⁠o⁠m⁠pleted | `as_completed(*fs*, timeout=**None**)` 返回一个迭代器 *it*，迭代
    Future 实例，这些实例是可迭代对象 *fs* 的项。如果 *fs* 中有重复项，则每个项只返回一次。*it* 按顺序逐个返回已完成的 Future 实例。如果
    timeout 不为 **None**，它是一个浮点数秒数；如果在 timeout 秒内从上一个已完成实例之后尚未返回新的实例，则 as_completed
    抛出 concurrent.futures.Timeout。'
- en: '| wait | wait(*fs*, timeout=**None**, return_when=ALL_COMPLETED) Waits for
    the Future instances that are the items of iterable *fs*. Returns a named 2-tuple
    of sets: the first set, named done, contains the futures that completed (meaning
    that they either finished or were canceled) before wait returned; the second set,
    named not_done, contains as-yet-uncompleted futures.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '| wait | wait(*fs*, timeout=**None**, return_when=ALL_COMPLETED) 等待iterable
    *fs*中作为项目的未来实例。返回一个命名的2元组集合：第一个集合名为done，包含在wait返回之前已完成（意味着它们已经完成或被取消）的未来实例；第二个集合名为not_done，包含尚未完成的未来实例。'
- en: timeout, if not **None**, is a float number of seconds, the maximum time wait
    lets elapse before returning (when timeout is **None**, wait returns only when
    return_when is satisfied, no matter how much time elapses before that happens).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果timeout不为**None**，则timeout是一个浮点数秒数，表示在返回之前允许等待的最长时间（当timeout为**None**时，wait仅在满足return_when时返回，不管之前经过了多少时间）。
- en: 'return_when controls when, exactly, wait returns; it must be one of three constants
    supplied by the module concurrent.futures:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: return_when控制wait何时返回；它必须是concurrent.futures模块提供的三个常量之一：
- en: ALL_COMPLETED
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ALL_COMPLETED
- en: Return when all futures finish or are canceled.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有未来实例完成或被取消时返回。
- en: FIRST_COMPLETED
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: FIRST_COMPLETED
- en: Return when any future finishes or is canceled.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何一个未来完成或被取消时返回。
- en: FIRST_EXCEPTION
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: FIRST_EXCEPTION
- en: Return when any future raises an exception; should no future raise an exception,
    becomes equivalent to ALL_COMPLETED.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何未来引发异常时返回；如果没有未来引发异常，则变成等价于ALL_COMPLETED。
- en: '|'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'This version of make_dict illustrates how to use concurrent.futures.as_completed
    to process each task as it finishes (in contrast with the previous example using
    Executor.map, which always returns the tasks in the order in which they were submitted):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的make_dict演示了如何使用concurrent.futures.as_completed来在每个任务完成时处理它（与使用Executor.map的前一个示例形成对比，后者总是按照提交顺序返回任务）：
- en: '[PRE22]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Threaded Program Architecture
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程程序架构
- en: A threaded program should always try to arrange for a *single* thread to “own”
    any object or subsystem that is external to the program (such as a file, a database,
    a GUI, or a network connection). Having multiple threads that deal with the same
    external object is possible, but can often create intractable problems.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程程序应该总是尽量安排一个*单一*线程“拥有”任何外部于程序的对象或子系统（如文件、数据库、GUI或网络连接）。虽然有多个处理同一外部对象的线程是可能的，但通常会造成难以解决的问题。
- en: 'When your threaded program must deal with some external object, devote a dedicated
    thread to just such dealings, and use a Queue object from which the external-interfacing
    thread gets work requests that other threads post. The external-interfacing thread
    returns results by putting them on one or more other Queue objects. The following
    example shows how to package this architecture into a general, reusable class,
    assuming that each unit of work on the external subsystem can be represented by
    a callable object:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的线程程序必须处理某些外部对象时，为这类交互专门分配一个线程，并使用一个队列对象，从中外部交互线程获取其他线程提交的工作请求。外部交互线程通过将结果放在一个或多个其他队列对象中来返回结果。以下示例展示了如何将此架构打包成一个通用的可重用类，假设外部子系统上的每个工作单元可以用可调用对象表示：
- en: '[PRE23]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once some ExternalInterfacing object *ei* is instantiated, any other thread
    may call *ei*.request just as it would call external_callable absent such a mechanism
    (with or without arguments, as appropriate). The advantage of ExternalInterfacing
    is that calls to external_callable are *serialized*. This means that just one
    thread (the Thread object bound to *ei*) performs them, in some defined sequential
    order, without overlap, race conditions (hard-to-debug errors that depend on which
    thread just happens to “get there” first), or other anomalies that might otherwise
    result.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例化了某个ExternalInterfacing对象*ei*，任何其他线程都可以调用*ei*.request，就像在缺乏这种机制的情况下调用external_callable一样（根据需要带有或不带参数）。ExternalInterfacing的优点在于对external_callable的调用是*串行化*的。这意味着仅有一个线程（绑定到*ei*的Thread对象）按照某个定义好的顺序顺序执行它们，没有重叠、竞争条件（依赖于哪个线程“恰好先到达”）或其他可能导致异常情况的问题。
- en: 'If you need to serialize several callables together, you can pass the callable
    as part of the work request, rather than passing it at the initialization of the
    class ExternalInterfacing, for greater generality. The following example shows
    this more general approach:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要将多个可调用对象串行化在一起，可以将可调用对象作为工作请求的一部分传递，而不是在类ExternalInterfacing的初始化时传递它，以获得更大的通用性。以下示例展示了这种更通用的方法：
- en: '[PRE24]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once a Serializer object *ser* has been instantiated, any other thread may call
    *ser*.apply(external_callable) just as it would call external_callable without
    such a mechanism (with or without further arguments, as appropriate). The Serializer
    mechanism has the same advantages as ExternalInterfacing, except that all calls
    to the same or different callables wrapped by a single *ser* instance are now
    serialized.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例化了一个Serializer对象*ser*，任何其他线程都可以调用*ser*.apply(external_callable)，就像没有这种机制时会调用external_callable一样（根据需要可能带有或不带有进一步的参数）。Serializer机制与ExternalInterfacing具有相同的优点，不同之处在于，所有调用由同一个或不同的可调用对象包装在单个*ser*实例中的调用现在都是串行化的。
- en: 'The user interface of the whole program is an external subsystem, and thus
    should be dealt with by a single thread—specifically, the main thread of the program
    (this is mandatory for some user interface toolkits, and advisable even when using
    other toolkits that don’t mandate it). A Serializer thread is therefore inappropriate.
    Rather, the program’s main thread should deal only with user-interface issues,
    and farm out all actual work to worker threads that accept work requests on a
    Queue object and return results on another. A set of worker threads is generally
    known as a *thread pool*. As shown in the following example, all worker threads
    should share a single queue of requests and a single queue of results, since the
    main thread is the only one to post work requests and harvest results:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 整个程序的用户界面是一个外部子系统，因此应该由一个单独的线程来处理——具体来说，是程序的主线程（对于某些用户界面工具包，这是强制性的，即使使用其他不强制的工具包，这样做也是建议的）。因此，Serializer线程是不合适的。相反，程序的主线程应仅处理用户界面问题，并将所有实际工作委派给接受工作请求的工作线程，这些工作线程在一个队列对象上接受工作请求，并在另一个队列上返回结果。一组工作线程通常被称为*线程池*。正如下面的示例所示，所有工作线程应共享一个请求队列和一个结果队列，因为只有主线程才会发布工作请求并获取结果：
- en: '[PRE25]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The main thread creates the two queues, then instantiates worker threads, as
    follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 主线程创建两个队列，然后实例化工作线程，如下所示：
- en: '[PRE26]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Whenever the main thread needs to farm out work (execute some callable object
    that may take substantial time to produce results), the main thread calls *worker*.perform_work(*callable*),
    much as it would call *callable* without such a mechanism (with or without further
    arguments, as appropriate). However, perform_work does not return the result of
    the call. Instead of the results, the main thread gets an ID that identifies the
    work request. When the main thread needs the results, it can keep track of that
    ID, since the request’s results are tagged with the ID when they appear. The advantage
    of this mechanism is that the main thread never blocks waiting for the callable’s
    execution to complete, but rather becomes ready again at once and can immediately
    return to its main business of dealing with the user interface.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 每当主线程需要委派工作（执行可能需要较长时间来生成结果的可调用对象），主线程调用*worker*.perform_work(*callable*)，就像没有这种机制时会调用*callable*一样（根据需要可能带有或不带有进一步的参数）。然而，perform_work并不返回调用的结果。主线程得到的是一个标识工作请求的ID。当主线程需要结果时，它可以跟踪该ID，因为请求的结果在出现时都标有该ID。这种机制的优点在于，主线程不会阻塞等待可调用的执行完成，而是立即变为可用状态，可以立即回到处理用户界面的主要业务上。
- en: The main thread must arrange to check the results_queue, since the result of
    each work request eventually appears there, tagged with the request’s ID, when
    the worker thread that took that request from the queue finishes computing the
    result. How the main thread arranges to check for both user interface events and
    the results coming back from worker threads onto the results queue depends on
    what user interface toolkit is used, or—if the user interface is text-based—on
    the platform on which the program runs.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 主线程必须安排检查results_queue，因为每个工作请求的结果最终会出现在那里，标记有请求的ID，当从队列中取出该请求的工作线程计算出结果时。主线程如何安排检查用户界面事件和从工作线程返回到结果队列的结果，取决于使用的用户界面工具包，或者——如果用户界面是基于文本的——取决于程序运行的平台。
- en: 'A widely applicable, though not always optimal, general strategy is for the
    main thread to *poll* (check the state of the results queue periodically). On
    most Unix-like platforms, the function alarm of the module signal allows polling.
    The tkinter GUI toolkit supplies an after method that is usable for polling. Some
    toolkits and platforms afford more effective strategies (such as letting a worker
    thread alert the main thread when it places some result on the results queue),
    but there is no generally available, cross-platform, cross-toolkit way to arrange
    for this. Therefore, the following artificial example ignores user interface events
    and just simulates work by evaluating random expressions, with random delays,
    on several worker threads, thus completing the previous example:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一个广泛适用但并非始终最佳的一般策略是让主线程*轮询*（定期检查结果队列的状态）。在大多数类Unix平台上，模块signal的alarm函数允许轮询。tkinter
    GUI工具包提供了一个after方法，可用于轮询。某些工具包和平台提供了更有效的策略（例如，让工作线程在将某些结果放入结果队列时警告主线程），但没有通用的、跨平台、跨工具包的方法可以安排这样的操作。因此，以下人工示例忽略了用户界面事件，只是通过在几个工作线程上评估随机表达式并引入随机延迟来模拟工作，从而完成了前面的示例：
- en: '[PRE27]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Process Environment
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程环境
- en: The operating system supplies each process *P* with an *environment*, a set
    of variables whose names are strings (most often, by convention, uppercase identifiers)
    and whose values are also strings. In [“Environment Variables”](ch02.xhtml#environment_variables),
    we cover environment variables that affect Python’s operations. Operating system
    shells offer ways to examine and modify the environment via shell commands and
    other means mentioned in that section.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统为每个进程*P*提供一个*环境*，即一组变量，变量名为字符串（通常按约定为大写标识符），其值也为字符串。在[“环境变量”](ch02.xhtml#environment_variables)中，我们讨论了影响Python操作的环境变量。操作系统shell通过shell命令和其他在该部分提到的方法提供了检查和修改环境的方式。
- en: Process Environments Are Self-Contained
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程环境是自包含的
- en: 'The environment of any process *P* is determined when *P* starts. After startup,
    only *P* itself can change *P*’s environment. Changes to *P*’s environment affect
    only *P*: the environment is *not* a means of interprocess communication. Nothing
    that *P* does affects the environment of *P*’s parent process (the process that
    started *P*), nor that of any child process *previously* started from *P* and
    now running, or of any process unrelated to *P*. Child processes of *P* normally
    get a copy of *P*’s environment as it stands at the time *P* creates that process
    as a starting environment. In this narrow sense, changes to *P*’s environment
    do affect child processes that *P* starts *after* such changes.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 任何进程*P*的环境在*P*启动时确定。启动后，只有*P*自己能够改变*P*的环境。对*P*环境的更改仅影响*P*本身：环境*不是*进程间通信的手段。*P*的任何操作都不会影响*P*的父进程（启动*P*的进程）的环境，也不会影响任何*P*之前启动的子进程现在正在运行的环境，或者与*P*无关的任何进程。*P*的子进程通常会在*P*创建该进程时获取一个*P*环境的副本作为启动环境。从这个狭义的意义上说，对*P*环境的更改确实会影响在此类更改之后由*P*启动的子进程。
- en: 'The module os supplies the attribute environ, a mapping that represents the
    current process’s environment. When Python starts, it initializes os.environ from
    the process environment. Changes to os.environ update the current process’s environment
    if the platform supports such updates. Keys and values in os.environ must be strings.
    On Windows (but not on Unix-like platforms), keys into os.environ are implicitly
    uppercased. For example, here’s how to try to determine which shell or command
    processor you’re running under:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 模块os提供了属性environ，这是一个映射，表示当前进程的环境。当Python启动时，它从进程环境初始化os.environ。如果平台支持此类更新，对os.environ的更改将更新当前进程的环境。os.environ中的键和值必须是字符串。在Windows上（但在类Unix平台上不是这样），os.environ中的键隐式转换为大写。例如，以下是如何尝试确定您正在运行的shell或命令处理器：
- en: '[PRE28]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When a Python program changes its environment (e.g., via os.environ['X'] = 'Y'),
    this does not affect the environment of the shell or command processor that started
    the program. As already explained—and for **all** programming languages, including
    Python—changes to a process’s environment affect only the process itself, not
    other processes that are currently running.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python程序改变其环境（例如通过`os.environ['X'] = 'Y'`），这不会影响启动该程序的shell或命令处理器的环境。正如已经解释过的，对于**所有**编程语言，包括Python，进程环境的更改仅影响进程本身，而不影响当前正在运行的其他进程。
- en: Running Other Programs
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行其他程序
- en: You can run other programs via low-level functions in the os module, or (at
    a higher and usually preferable level of abstraction) with the subprocess module.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过os模块中的低级函数运行其他程序，或者（在更高且通常更可取的抽象级别上）使用subprocess模块。
- en: Using the Subprocess Module
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用子进程模块
- en: 'The subprocess module supplies one very broad class: Popen, which supports
    many diverse ways for your program to run another program. The constructor for
    Popen has the signature:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: subprocess模块提供了一个非常广泛的类：Popen，支持许多不同的方式来运行另一个程序。Popen的构造函数签名如下：
- en: '| Popen | **class** Popen(*args*, bufsize=0, executable=**None**, capture_output=**False**,
    stdin=**None**, stdout=**None**, stderr=**None**, preexec_fn=**None**, close_fds=**False**,
    shell=**False**, cwd=**None**, env=**None**, text=**None**, universal_newlines=**False**,
    startupinfo=**None**, creationflags=0) Popen starts a subprocess to run a distinct
    program, and creates and returns an object *p*, representing that subprocess.
    The *args* mandatory argument and the many optional named arguments control all
    details of how the subprocess is to run.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '| Popen | **class** Popen(*args*, bufsize=0, executable=**None**, capture_output=**False**,
    stdin=**None**, stdout=**None**, stderr=**None**, preexec_fn=**None**, close_fds=**False**,
    shell=**False**, cwd=**None**, env=**None**, text=**None**, universal_newlines=**False**,
    startupinfo=**None**, creationflags=0) Popen启动一个子进程来运行一个独立的程序，并创建并返回一个对象*p*，代表该子进程。*args*是必需的参数，而许多可选的命名参数控制子进程运行的所有细节。'
- en: When any exception occurs during the subprocess creation (before the distinct
    program starts), Popen re-raises that exception in the calling process with the
    addition of an attribute named child_traceback, which is the Python traceback
    object for the subprocess. Such an exception would normally be an instance of
    OSError (or possibly TypeError or ValueError to indicate that you’ve passed to
    Popen an argument that’s invalid in type or value). |
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当在子进程创建过程中发生任何异常（在明确程序启动之前），Popen会将该异常与名为child_traceback的属性一起重新引发到调用过程中，child_traceback是子进程的Python
    traceback对象。这样的异常通常是OSError的一个实例（或者可能是TypeError或ValueError，表示您传递给Popen的参数在类型或值上是无效的）。
- en: subprocess.run() is a Convenience Wrapper Function for Popen
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: subprocess.run()是Popen的一个便捷包装函数。
- en: The subprocess module includes the run function that encapsulates a Popen instance
    and executes the most common processing flow on it. run accepts the same arguments
    as Popen’s constructor, runs the given command, waits for completion or timeout,
    and returns a CompletedProcess instance with attributes for the return code and
    stdout and stderr contents.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: subprocess模块包括run函数，该函数封装了一个Popen实例，并在其上执行最常见的处理流程。run接受与Popen构造函数相同的参数，运行给定的命令，等待完成或超时，并返回一个CompletedProcess实例，其中包含返回码以及stdout和stderr的内容。
- en: If the output of the command needs to be captured, the most common argument
    values would be to set the capture_output and text arguments to **True**.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要捕获命令的输出，则最常见的参数值将是将capture_output和text参数设置为**True**。
- en: What to run, and how
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 要运行什么，以及如何运行
- en: '*args* is a sequence of strings: the first item is the path to the program
    to execute, and the following items, if any, are arguments to pass to the program
    (*args* can also be just a string, when you don’t need to pass arguments). executable,
    when not **None**, overrides *args* in determining which program to execute. When
    shell is **True**, executable specifies which shell to use to run the subprocess;
    when shell is **True** and executable is **None**, the shell used is */bin/sh*
    on Unix-like systems (on Windows, it’s os.environ[''COMSPEC'']).'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*args*是一个字符串序列：第一项是要执行的程序的路径，后续的项（如果有）是要传递给程序的参数（当不需要传递参数时，*args*也可以只是一个字符串）。当executable不为**None**时，它将覆盖*args*以确定要执行的程序。当shell为**True**时，executable指定要用来运行子进程的shell；当shell为**True**且executable为**None**时，在类Unix系统上使用的shell是*/bin/sh*（在Windows上，它是os.environ[''COMSPEC'']）。'
- en: Subprocess files
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子进程文件
- en: 'stdin, stdout, and stderr specify the subprocess’s standard input, output,
    and error files, respectively. Each may be PIPE, which creates a new pipe to/from
    the subprocess; **None**, meaning that the subprocess is to use the same file
    as this (“parent”) process; or a file object (or file descriptor) that’s already
    suitably open (for reading, for standard input; for writing, for standard output
    and standard error). stderr may also be subprocess.STDOUT, meaning that the subprocess’s
    standard error must use the same file as its standard output.^([4](ch15.xhtml#ch01fn119))
    When capture_output is true, you can not specify stdout, nor stderr: rather, behavior
    is just as if each was specified as PIPE. bufsize controls the buffering of these
    files (unless they’re already open), with the same semantics as the same argument
    to the open function covered in [“Creating a File Object with open”](ch11.xhtml#creating_a_file_object_with_open)
    (the default, 0, means “unbuffered”). When text (or its synonym universal_newlines,
    provided for backward compatibility) is true, stdout and stderr (unless they are
    already open) are opened as text files; otherwise, they’re opened as binary files.
    When close_fds is true, all other files (apart from standard input, output, and
    error) are closed in the subprocess before the subprocess’s program or shell executes.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: stdin、stdout 和 stderr 分别指定了子进程的标准输入、输出和错误文件。每个可以是 PIPE，这会创建一个到/从子进程的新管道；**None**，意味着子进程要使用与此（“父”）进程相同的文件；或者是已经适当打开的文件对象（或文件描述符）（对于读取，用于标准输入；对于写入，用于标准输出和标准错误）。stderr
    还可以是 subprocess.STDOUT，这意味着子进程的标准错误必须使用与其标准输出相同的文件。^([4](ch15.xhtml#ch01fn119))
    当 capture_output 为 true 时，不能指定 stdout 或 stderr：行为就像每个都指定为 PIPE 一样。bufsize 控制这些文件的缓冲（除非它们已经打开），其语义与
    open 函数中的相同参数的语义相同（默认为 0，表示“无缓冲”）。当 text（或其同义词 universal_newlines，提供向后兼容性）为 true
    时，stdout 和 stderr（除非它们已经打开）将被打开为文本文件；否则，它们将被打开为二进制文件。当 close_fds 为 true 时，在子进程执行其程序或
    shell 之前，所有其他文件（除了标准输入、输出和错误）将被关闭。
- en: Other, advanced arguments
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他，高级参数
- en: When preexec_fn is not **None**, it must be a function or other callable object,
    and it gets called in the subprocess before the subprocess’s program or shell
    is executed (only on Unix-like systems, where the call happens after fork and
    before exec).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当 preexec_fn 不为 **None** 时，必须是一个函数或其他可调用对象，并且在子进程执行其程序或 shell 之前调用它（仅适用于类 Unix
    系统，其中调用发生在 fork 之后和 exec 之前）。
- en: When cwd is not **None**, it must be a string that gives the full path to an
    existing directory; the current directory gets changed to cwd in the subprocess
    before the subprocess’s program or shell executes.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当 cwd 不为 **None** 时，必须是一个给出现有目录的完整路径的字符串；在子进程执行其程序或 shell 之前，当前目录会切换到 cwd。
- en: When env is not **None**, it must be a mapping with strings as both keys and
    values, and fully defines the environment for the new process; otherwise, the
    new process’s environment is a copy of the environment currently active in the
    parent process.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当 env 不为 **None** 时，必须是一个映射，其中键和值都是字符串，并完全定义了新进程的环境；否则，新进程的环境是当前父进程中活动环境的副本。
- en: startupinfo and creationflags are Windows-only arguments passed to the CreateProcess
    Win32 API call used to create the subprocess, for Windows-specific purposes (we
    do not cover them further in this book, which focuses almost exclusively on cross-platform
    uses of Python).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: startupinfo 和 creationflags 是传递给 CreateProcess Win32 API 调用的 Windows-only 参数，用于创建子进程，用于特定于
    Windows 的目的（本书不进一步涵盖它们，因为本书几乎完全专注于 Python 的跨平台使用）。
- en: Attributes of subprocess.Popen instances
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: subprocess.Popen 实例的属性
- en: An instance *p* of the class Popen supplies the attributes listed in [Table 15-17](#attributes_of_an_instance_p_of_class_po).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 类 Popen 的实例 *p* 提供了 [Table 15-17](#attributes_of_an_instance_p_of_class_po)
    中列出的属性。
- en: Table 15-17\. Attributes of an instance *p* of class Popen
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Table 15-17\. 类 Popen 的实例 *p* 的属性
- en: '| args | Popen’s *args* argument (string or sequence of strings). |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| args | Popen 的 *args* 参数（字符串或字符串序列）。 |'
- en: '| pid | The process ID of the subprocess. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| pid | 子进程的进程 ID。 |'
- en: '| returncode | None to indicate that the subprocess has not yet exited; otherwise,
    an integer: 0 for successful termination, >0 for termination with an error code,
    or <0 if the subprocess was killed by a signal. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| returncode | None 表示子进程尚未退出；否则，是一个整数：0 表示成功终止，>0 表示以错误代码终止，或 <0 如果子进程被信号杀死。
    |'
- en: '| stderr, stdin, stdout | When the corresponding argument to Popen was subprocess.PIPE,
    each of these attributes is a file object wrapping the corresponding pipe; otherwise,
    each of these attributes is **None**. Use the communicate method of *p*, rather
    than reading and writing to/from these file objects, to avoid possible deadlocks.
    |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| stderr, stdin, stdout | 当 Popen 的相应参数是 subprocess.PIPE 时，这些属性中的每一个都是包装相应管道的文件对象；否则，这些属性中的每一个都是
    **None**。使用 *p* 的 communicate 方法，而不是从这些文件对象读取和写入，以避免可能的死锁。 |'
- en: Methods of subprocess.Popen instances
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: subprocess.Popen 实例的方法
- en: An instance *p* of the class Popen supplies the methods listed in [Table 15-18](#methods_of_an_instance_p_of_class_popen).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 类 Popen 的实例 *p* 提供了[表15-18](#methods_of_an_instance_p_of_class_popen)中列出的方法。
- en: Table 15-18\. Methods of an instance *p* of class Popen
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-18\. 类 Popen 的实例 *p* 的方法
- en: '| communicate | *p*.communicate(input=**None**, timeout=**None**) Sends the
    string input as the subprocess’s standard input (when input is not **None**),
    then reads the subprocess’s standard output and error files into in-memory strings
    *so* and *se* until both files are finished, and finally waits for the subprocess
    to terminate and returns the pair (two-item tuple) (*so*, *se*). |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| communicate | *p*.communicate(input=**None**, timeout=**None**) 将字符串 input
    作为子进程的标准输入（当 input 不为 **None** 时），然后将子进程的标准输出和错误文件读入内存中的字符串 *so* 和 *se*，直到两个文件都完成，最后等待子进程终止并返回对（两项元组）（*so*，*se*）。
    |'
- en: '| poll | *p*.poll() Checks if the subprocess has terminated; returns *p*.returncode
    if it has; otherwise, returns **None**. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| poll | *p*.poll() 检查子进程是否已终止；如果已终止，则返回 *p*.returncode；否则返回 **None**。 |'
- en: '| wait | *p*.wait(timeout=**None**) Waits for the subprocess to terminate,
    then returns *p*.returncode. Should the subprocess not terminate within timeout
    seconds, raises TimeoutExpired. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| wait | *p*.wait(timeout=**None**) 等待子进程终止，然后返回 *p*.returncode。如果子进程在 timeout
    秒内未终止，则引发 TimeoutExpired 异常。 |'
- en: Running Other Programs with the os Module
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 os 模块运行其他程序
- en: The best way for your program to run other processes is usually with the subprocess
    module, covered in the previous section. However, the os module (introduced in
    [Chapter 11](ch11.xhtml#file_and_text_operations)) also offers several lower-level
    ways to do this, which, in some cases, may be simpler to use.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序通常运行其他进程的最佳方式是使用前一节介绍的 subprocess 模块。然而，os 模块（在[第11章](ch11.xhtml#file_and_text_operations)介绍）也提供了几种较低级别的方式来实现这一点，在某些情况下可能更简单。
- en: 'The simplest way to run another program is through the function os.system,
    although this offers no way to *control* the external program. The os module also
    provides a number of functions whose names start with exec. These functions offer
    fine-grained control. A program run by one of the exec functions replaces the
    current program (i.e., the Python interpreter) in the same process. In practice,
    therefore, you use the exec functions mostly on platforms that let a process duplicate
    itself using fork (i.e., Unix-like platforms). os functions whose names start
    with spawn and popen offer intermediate simplicity and power: they are cross-platform
    and not quite as simple as system, but simple enough for many purposes.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 运行另一个程序的最简单方法是通过 os.system 函数，尽管这种方法没有办法*控制*外部程序。os 模块还提供了几个以 exec 开头的函数，这些函数提供了精细的控制。由
    exec 函数之一运行的程序会替换当前程序（即 Python 解释器）在同一进程中。因此，在实践中，您主要在支持使用 fork 的平台上使用 exec 函数（即类
    Unix 平台）。以 spawn 和 popen 开头的 os 函数提供了中间简单性和强大性：它们是跨平台的，并且不像 system 那样简单，但对于许多目的来说足够简单。
- en: The exec and spawn functions run a given executable file, given the executable
    file’s path, arguments to pass to it, and optionally an environment mapping. The
    system and popen functions execute a command, which is a string passed to a new
    instance of the platform’s default shell (typically */bin/sh* on Unix, *cmd.exe*
    on Windows). A *command* is a more general concept than an *executable file*,
    as it can include shell functionality (pipes, redirection, and built-in shell
    commands) using the shell syntax specific to the current platform.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: exec 和 spawn 函数运行给定的可执行文件，给定可执行文件的路径、传递给它的参数，以及可选的环境映射。system 和 popen 函数执行一个命令，这是一个字符串传递给平台的默认
    shell 的新实例（通常在 Unix 上是 */bin/sh*，在 Windows 上是 *cmd.exe*）。*命令*是一个比*可执行文件*更一般的概念，因为它可以包含特定于当前平台的
    shell 功能（管道、重定向和内置 shell 命令）使用的 shell 语法。
- en: os provides the functions listed in [Table 15-19](#functions_of_the_os_module_related_to_p).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: os 提供了[表15-19](#functions_of_the_os_module_related_to_p)列出的函数。
- en: Table 15-19\. Functions of the os module related to processes
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-19\. 与进程相关的 os 模块的函数
- en: '| execl, execle,'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '| execl, execle,'
- en: execlp,
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: execlp,
- en: execv,
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: execv,
- en: execve,
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: execve,
- en: execvp,
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: execvp,
- en: execvpe | execl(*path*, **args*), execle(*path*, **args*),
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: execvpe | execl(*path*, **args*), execle(*path*, **args*),
- en: execlp(*path*,**args*),
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: execlp(*path*,**args*),
- en: execv(*path*, *args*),
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: execv(*path*, *args*),
- en: execve(*path*, *args*, *env*),
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: execve(*path*, *args*, *env*),
- en: execvp(*path*, *args*),
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: execvp(*path*, *args*),
- en: execvpe(*path*, *args*, *env*)
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: execvpe(*path*, *args*, *env*)
- en: 'Run the executable file (program) indicated by string *path*, replacing the
    current program (i.e., the Python interpreter) in the current process. The distinctions
    encoded in the function names (after the prefix exec) control three aspects of
    how the new program is found and run:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 运行由字符串 *path* 指示的可执行文件（程序），替换当前进程中的当前程序（即 Python 解释器）。函数名中编码的区别（在前缀 exec 之后）控制新程序的发现和运行的三个方面：
- en: Does *path* have to be a complete path to the program’s executable file, or
    can the function accept a name as the *path* argument and search for the executable
    in several directories, as operating system shells do? execlp, execvp, and execvpe
    can accept a *path* argument that is just a filename rather than a complete path.
    In this case, the functions search for an executable file of that name in the
    directories listed in os.environ['PATH']. The other functions require *path* to
    be a complete path to the executable file.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*path* 是否必须是程序可执行文件的完整路径，还是该函数可以接受一个名称作为 *path* 参数并在多个目录中搜索可执行文件，就像操作系统 shell
    一样？execlp、execvp 和 execvpe 可以接受一个 *path* 参数，该参数只是一个文件名而不是完整路径。在这种情况下，函数将在 os.environ[''PATH'']
    中列出的目录中搜索具有该名称的可执行文件。其他函数要求 *path* 是可执行文件的完整路径。'
- en: Does the function accept arguments for the new program as a single sequence
    argument *args*, or as separate arguments to the function? Functions whose names
    start with execv take a single argument *args* that is the sequence of arguments
    to use for the new program. Functions whose names start with execl take the new
    program’s arguments as separate arguments (execle, in particular, uses its last
    argument as the environment for the new program).
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是否接受新程序的参数作为单个序列参数 *args*，还是作为函数的单独参数？以 execv 开头的函数接受一个参数 *args*，该参数是要用于新程序的参数序列。以
    execl 开头的函数将新程序的参数作为单独的参数（特别是 execle，它使用其最后一个参数作为新程序的环境）。
- en: Does the function accept the new program’s environment as an explicit mapping
    argument *env*, or implicitly use os.environ? execle, execve, and execvpe take
    an argument *env* that is a mapping to use as the new program’s environment (keys
    and values must be strings), while the other functions use os.environ for this
    purpose.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是否接受新程序的环境作为显式映射参数 *env*，或者隐式使用 os.environ？execle、execve 和 execvpe 接受一个参数
    *env*，该参数是要用作新程序环境的映射（键和值必须是字符串），而其他函数则使用 os.environ 用于此目的。
- en: Each exec function uses the first item in *args* as the name under which the
    new program is told it’s running (for example, argv[0] in a C program’s main);
    only args[1:] are arguments proper to the new program.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个 exec 函数使用 *args* 中的第一个项作为告知新程序其正在运行的名称（例如，在 C 程序的 main 中的 argv[0]）；只有 args[1:]
    是新程序的真正参数。
- en: '|'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| popen | popen(*cmd*, mode=''r'', buffering=-1) Runs the string command *cmd*
    in a new process *P* and returns a file-like object *f* that wraps a pipe to *P*’s
    standard input or from *P*’s standard output (depending on mode); *f* uses text
    streams in both directions rather than raw bytes. mode and buffering have the
    same meaning as for Python’s open function, covered in [“Creating a File Object
    with open”](ch11.xhtml#creating_a_file_object_with_open). When mode is ''r'' (the
    default), *f* is read-only and wraps *P*’s standard output. When mode is ''w'',
    *f* is write-only and wraps *P*’s standard input.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '| popen | popen(*cmd*, mode=''r'', buffering=-1) 运行字符串命令 *cmd* 在一个新进程 *P* 中，并返回一个文件对象
    *f*，该对象包装了与 *P* 的标准输入或来自 *P* 的标准输出的管道（取决于模式）；*f* 使用文本流而不是原始字节。模式和缓冲区的含义与 Python
    的 open 函数相同，见 [“使用 open 创建文件对象”](ch11.xhtml#creating_a_file_object_with_open)。当模式为
    ''r''（默认）时，*f* 是只读的，并包装 *P* 的标准输出。当模式为 ''w'' 时，*f* 是只写的，并包装 *P* 的标准输入。'
- en: The key difference of *f* from other file-like objects is the behavior of method
    *f*.close. *f*.close waits for *P* to terminate and returns **None**, as close
    methods of file-like objects normally do, when *P*’s termination is successful.
    However, if the operating system associates an integer error code *c* with *P*’s
    termination, indicating that *P*’s termination was unsuccessful, *f*.close returns
    *c*. On Windows systems, c is a signed integer return code from the child process.
    |
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*f* 与其他类似文件的主要区别在于方法 *f*.close 的行为。 *f*.close 等待 *P* 终止并返回 **None**，正如文件类对象的关闭方法通常所做的那样，当
    *P* 成功终止时。然而，如果操作系统将整数错误码 *c* 与 *P* 的终止关联起来，表示 *P* 的终止失败，*f*.close 返回 *c*。在 Windows
    系统上，*c* 是子进程的有符号整数返回码。 |'
- en: '| spawnv, spawnve | spawnv(*mode*, *path*, *args*), spawnve(*mode*, *path*,
    *args*, *env*)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '| spawnv, spawnve | spawnv(*mode*, *path*, *args*), spawnve(*mode*, *path*,
    *args*, *env*)'
- en: These functions run the program indicated by *path* in a new process *P*, with
    the arguments passed as sequence *args*. spawnve uses mapping *env* as *P*’s environment
    (both keys and values must be strings), while spawnv uses os.environ for this
    purpose. On Unix-like platforms only, there are other variations of os.spawn,
    corresponding to variations of os.exec, but spawnv and spawnve are the only two
    that also exist on Windows.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在新进程 *P* 中运行由 *path* 指示的程序，参数作为序列 *args* 传递。spawnve 使用映射 *env* 作为 *P* 的环境（键和值必须是字符串），而
    spawnv 则使用 os.environ 来实现。仅在 Unix-like 平台上，还有其他 os.spawn 的变体，对应于 os.exec 的变体，但
    spawnv 和 spawnve 是 Windows 上唯一存在的两个。
- en: '*mode* must be one of two attributes supplied by the os module: os.P_WAIT indicates
    that the calling process waits until the new process terminates, while os.P_NOWAIT
    indicates that the calling process continues executing simultaneously with the
    new process. When *mode* is os.P_WAIT, the function returns the termination code
    *c* of *P*: 0 indicates successful termination, *c* < 0 indicates *P* was killed
    by a *signal*, and *c* > 0 indicates normal but unsuccessful termination. When
    *mode* is os.P_NOWAIT, the function returns *P*’s process ID (or, on Windows,
    *P*’s process handle). There is no cross-platform way to use *P*’s ID or handle;
    platform-specific ways (not covered further in this book) include os.waitpid on
    Unix-like platforms, and third-party extension package [pywin32](https://oreil.ly/dsHxn)
    on Windows.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '*mode* 必须是 os 模块提供的两个属性之一：os.P_WAIT 表示调用进程等待新进程终止，而 os.P_NOWAIT 表示调用进程继续与新进程同时执行。当
    *mode* 是 os.P_WAIT 时，函数返回 *P* 的终止码 *c*：0 表示成功终止，*c* < 0 表示 *P* 被 *信号* 杀死，*c* >
    0 表示正常但终止失败。当 *mode* 是 os.P_NOWAIT 时，函数返回 *P* 的进程 ID（或在 Windows 上是 *P* 的进程句柄）。没有跨平台的方法来使用
    *P* 的 ID 或句柄；Unix-like 平台上的平台特定方法包括 os.waitpid，而在 Windows 上则包括第三方扩展包 [pywin32](https://oreil.ly/dsHxn)。'
- en: 'For example, suppose you want your interactive program to give the user a chance
    to edit a text file that your program is about to read and use. You must have
    previously determined the full path to the user’s favorite text editor, such as
    *c:\\windows\\notepad.exe* on Windows or */usr/bin/vim* on a Unix-like platform.
    Say that this path string is bound to the variable editor, and the path of the
    text file you want to let the user edit is bound to textfile:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您希望交互式程序给用户一个机会编辑一个即将读取和使用的文本文件。您必须事先确定用户喜欢的文本编辑器的完整路径，例如在 Windows 上为 *c:\\windows\\notepad.exe*
    或在类 Unix 平台上为 */usr/bin/vim*。假设这个路径字符串绑定到变量 editor，并且您要让用户编辑的文本文件的路径绑定到 textfile：
- en: '[PRE29]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first item of the argument *args* is passed to the program being spawned
    as “the name under which the program is being invoked.” Most programs don’t look
    at this, so you can usually place just about any string here. Just in case the
    editor program does look at this special first argument (some versions of Vim,
    for example, do), passing the same string editor that is used as the second argument
    to os.spawnv is the simplest and most effective approach. |
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 *args* 的第一项作为“调用程序的名称”传递给被生成的程序。大多数程序不关心这一点，因此通常可以放置任何字符串。以防编辑程序确实查看这个特殊的第一个参数（例如某些版本的
    Vim），最简单和最有效的方法是将与 os.spawnv 的第二个参数相同的字符串 editor 传递给它。
- en: '| system | system(*cmd*) Runs the string command *cmd* in a new process and
    returns 0 when the new process terminates successfully. When the new process terminates
    unsuccessfully, system returns an integer error code not equal to 0. (Exactly
    what error codes may be returned depends on the command you’re running: there’s
    no widely accepted standard for this.) |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 系统 | 系统(*cmd*) 在新进程中运行字符串命令 *cmd*，当新进程成功终止时返回 0。当新进程终止失败时，系统返回一个非零整数错误代码（具体的错误代码依赖于你运行的命令：这方面没有广泛接受的标准）。
    |'
- en: The mmap Module
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mmap 模块
- en: 'The mmap module supplies memory-mapped file objects. An mmap object behaves
    similarly to a bytestring, so you can often pass an mmap object where a bytestring
    is expected. However, there are differences:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: mmap 模块提供了内存映射文件对象。mmap 对象的行为类似于字节串，因此通常可以在需要字节串的地方传递 mmap 对象。然而，它们也有一些区别：
- en: An mmap object does not supply the methods of a string object.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mmap 对象不提供字符串对象的方法。
- en: An mmap object is mutable, like a bytearray, while bytes objects are immutable.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mmap 对象是可变的，类似于 bytearray，而字节对象是不可变的。
- en: An mmap object also corresponds to an open file, and behaves polymorphically
    to a Python file object (as covered in [“File-Like Objects and Polymorphism”](ch11.xhtml#file_like_objects_and_polymorphism)).
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mmap 对象也对应于一个打开的文件，并且在多态性方面表现为 Python 文件对象（如[“类似文件对象和多态性”](ch11.xhtml#file_like_objects_and_polymorphism)中所述）。
- en: An mmap object *m* can be indexed or sliced, yielding bytestrings. Since *m*
    is mutable, you can also assign to an indexing or slicing of *m*. However, when
    you assign to a slice of *m*, the righthand side of the assignment statement must
    be a bytestring of exactly the same length as the slice you’re assigning to. Therefore,
    many of the useful tricks available with list slice assignment (covered in [“Modifying
    a list”](ch03.xhtml#modifying_a_list)) do not apply to mmap slice assignment.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: mmap 对象 *m* 可以进行索引或切片操作，产生字节串。由于 *m* 是可变的，你也可以对 *m* 的索引或切片进行赋值。然而，当你对 *m* 的切片赋值时，赋值语句的右侧必须是与你要赋值的切片具有完全相同长度的字节串。因此，许多在列表切片赋值中可用的有用技巧（如[“修改列表”](ch03.xhtml#modifying_a_list)中所述）不适用于
    mmap 切片赋值。
- en: 'The mmap module supplies a factory function, slightly different on Unix-like
    systems and on Windows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: mmap 模块在 Unix-like 系统和 Windows 上提供了稍有不同的工厂函数：
- en: '| mmap | *Windows:* mmap(*filedesc*, *length*, tagname='''', access=**None**,
    offset=**None**) *Unix:* mmap(*filedesc*, *length*, flags=MAP_SHARED, prot=PROT_READ&#124;PROT_WRITE,
    access=**None**, offset=0)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '| mmap | *Windows:* mmap(*filedesc*, *length*, tagname='''', access=**None**,
    offset=**None**) *Unix:* mmap(*filedesc*, *length*, flags=MAP_SHARED, prot=PROT_READ&#124;PROT_WRITE,
    access=**None**, offset=0)'
- en: Creates and returns an mmap object *m* that maps into memory the first *length*
    bytes of the file indicated by file descriptor *filedesc*. *filedesc* must be
    a file descriptor opened for both reading and writing, except, on Unix-like platforms,
    when the argument prot requests only reading or only writing. (File descriptors
    are covered in [“File descriptor operations”](ch11.xhtml#file_descriptor_operations).)
    To get an mmap object *m* for a Python file object *f*, use *m*=mmap.mmap(*f*.fileno(),
    *length*). *filedesc* can be -1 to map anonymous memory.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并返回一个 mmap 对象 *m*，它映射到内存中文件描述符 *filedesc* 指示的文件的前 *length* 字节。*filedesc* 必须是一个同时打开读写的文件描述符，除非在类
    Unix 平台上，参数 prot 仅请求读或仅请求写。（文件描述符在[“文件描述符操作”](ch11.xhtml#file_descriptor_operations)中有介绍。）要为
    Python 文件对象 *f* 获取 mmap 对象 *m*，可以使用 *m*=mmap.mmap(*f*.fileno(), *length*)。*filedesc*
    可以为 -1，以映射匿名内存。
- en: On Windows, all memory mappings are readable and writable, and shared among
    processes, so all processes with a memory mapping on a file can see changes made
    by other processes. On Windows only, you can pass a string tagname to give an
    explicit *tag name* for the memory mapping. This tag name lets you have several
    separate memory mappings on the same file, but this is rarely necessary. Calling
    mmap with only two arguments has the advantage of keeping your code portable between
    Windows and Unix-like platforms. |
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，所有内存映射都是可读写的，并在进程之间共享，因此所有在文件上有内存映射的进程都可以看到其他进程所做的更改。仅在 Windows
    上，你可以传递一个字符串 tagname 来为内存映射指定显式的 *标签名*。这个标签名允许你在同一个文件上拥有几个独立的内存映射，但这很少是必需的。仅使用两个参数调用
    mmap 的优点是在 Windows 和 Unix-like 平台之间保持代码的可移植性。 |
- en: '| mmap *(cont.)* | On Unix-like platforms only, you can pass mmap.MAP_PRIVATE
    as flags to get a mapping that is private to your process and copy-on-write. mmap.MAP_SHARED,
    the default, gets a mapping that is shared with other processes so that all processes
    mapping the file can see changes made by one process (the same as on Windows).
    You can pass mmap.PROT_READ as the prot argument to get a mapping that you can
    only read, not write. Passing mmap.PROT_WRITE gets a mapping that you can only
    write, not read. The default, the bitwise OR mmap.PROT_READ&#124;mmap.PROT_WRITE,
    gets a mapping you can both read and write. You can pass the named argument access
    instead of flags and prot (it’s an error to pass both access and either or both
    of the other two arguments). The value for access can be one of ACCESS_READ (read-only),
    ACCESS_WRITE (write-through, the default on Windows), or ACCESS_COPY (copy-on-write).'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '| mmap *(续)* | 仅在类 Unix 平台上，您可以传递 mmap.MAP_PRIVATE 作为标志以获得一个对您的进程私有并且写时复制的映射。mmap.MAP_SHARED
    是默认值，它获取一个与其他进程共享的映射，以便所有映射文件的进程都可以看到一个进程（与 Windows 上相同）所做的更改。您可以将 mmap.PROT_READ
    作为 prot 参数传递，以获取仅可读而不可写的映射。传递 mmap.PROT_WRITE 获取仅可写而不可读的映射。默认值，位或 mmap.PROT_READ&#124;mmap.PROT_WRITE，获取一个既可读又可写的映射。您可以传递命名参数
    access 而不是标志和 prot（传递 access 和其他两个参数中的一个或两个是错误的）。access 的值可以是 ACCESS_READ（只读），ACCESS_WRITE（写透传，Windows
    上的默认值）或 ACCESS_COPY（写时复制）。'
- en: You can pass the named argument offset to start the mapping after the beginning
    of the file; offset must be an int >= 0, a multiple of ALLOCATIONGRANULARITY (or,
    on Unix, of PAGESIZE). |
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以传递命名参数 offset 以在文件开始后开始映射；offset 必须是大于等于 0 的整数，是 ALLOCATIONGRANULARITY 的倍数（或者在
    Unix 上是 PAGESIZE 的倍数）。
- en: Methods of mmap Objects
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*mmap* 对象的方法'
- en: An mmap object *m* supplies the methods detailed in [Table 15-20](#methods_of_an_instance_m_of_mmap).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*mmap* 对象 *m* 提供了详细方法，参见 [Table 15-20](#methods_of_an_instance_m_of_mmap)。'
- en: Table 15-20\. Methods of an instance m of mmap
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Table 15-20\. *mmap* 实例 *m* 的方法
- en: '| close | *m*.close() Closes *m*’s file. |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| close | *m*.close() 关闭 *m* 的文件。'
- en: '| find | *m*.find(*sub*, start=0, end=**None**) Returns the lowest *i* >= start
    such that *sub* == *m*[*i*:*i*+len(*sub*)] (and *i*+len(*sub*)-1 <= end, when
    you pass end). If no such *i* exists, *m*.find returns -1. This is the same behavior
    as the find method of str, covered in [Table 9-1](ch09.xhtml#significant_str_and_bytes_methods).
    |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| find | *m*.find(*sub*, start=0, end=**None**) 返回大于等于 start 的最低 *i*，使得 *sub*
    == *m*[*i*:*i*+len(*sub*)]（并且当您传递 end 时，*i*+len(*sub*)-1 <= end）。如果没有这样的 *i*，*m*.find
    返回 -1。这与 str 的 find 方法的行为相同，该方法在 [Table 9-1](ch09.xhtml#significant_str_and_bytes_methods)
    中介绍。'
- en: '| flush | *m*.flush([*offset*, *n*]) Ensures that all changes made to *m* exist
    in *m*’s file. Until you call *m*.flush, it’s unsure if the file reflects the
    current state of *m*. You can pass a starting byte offset *offset* and a byte
    count *n* to limit the flushing effect’s guarantee to a slice of *m*. Pass both
    arguments, or neither: it’s an error to call *m*.flush with just one argument.
    |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| flush | *m*.flush([*offset*, *n*]) 确保所有对 *m* 所做的更改都存在于 *m* 的文件中。在调用 *m*.flush
    之前，文件是否反映了 *m* 的当前状态是不确定的。您可以传递起始字节偏移量 *offset* 和字节计数 *n* 来将刷新效果的保证限制为 *m* 的一个切片。传递这两个参数，或者两者都不传递：仅传递一个参数调用
    *m*.flush 是错误的。'
- en: '| move | *m*.move(*dstoff*, *srcoff*, *n*) Like the slice assignment *m*[*dstoff*:*dstoff*+*n*]
    = *m*[*srcoff*:*srcoff*+*n*], but potentially faster. The source and destination
    slices can overlap. Apart from such potential overlap, move does not affect the
    source slice (i.e., the move method *copies* bytes but does not *move* them, despite
    the method’s name). |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| move | *m*.move(*dstoff*, *srcoff*, *n*) 类似于切片赋值 *m*[*dstoff*:*dstoff*+*n*]
    = *m*[*srcoff*:*srcoff*+*n*]，但可能更快。源切片和目标切片可以重叠。除了可能的重叠外，move 方法不会影响源切片（即，move
    方法*复制*字节但不*移动*它们，尽管该方法的名称为“移动”）。'
- en: '| read | *m*.read(*n*) Reads and returns a byte string *s* containing up to
    *n* bytes starting from *m*’s file pointer, then advances *m*’s file pointer by
    len(*s*). If there are fewer than *n* bytes between *m*’s file pointer and *m*’s
    length, returns the bytes available. In particular, if *m*’s file pointer is at
    the end of *m*, returns the empty bytestring b''''. |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| read | *m*.read(*n*) 读取并返回一个字节字符串 *s*，包含从 *m* 的文件指针开始的最多 *n* 个字节，然后将 *m*
    的文件指针前进 *s* 的长度。如果 *m* 的文件指针和 *m* 的长度之间的字节数少于 *n*，则返回可用的字节。特别是，如果 *m* 的文件指针在 *m*
    的末尾，则返回空字节串 b''''。'
- en: '| read_byte | *m*.read_byte() Returns a byte string of length 1 containing
    the byte at *m*’s file pointer, then advances *m*’s file pointer by 1. *m*.read_byte()
    is similar to *m*.read(1). However, if *m*’s file pointer is at the end of *m*,
    *m*.read(1) returns the empty string b'''' and doesn’t advance, while *m*.read_byte()
    raises a ValueError exception. |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| read_byte | *m*.read_byte() 返回包含*m*的文件指针处的字节的长度为1的字节字符串，然后将*m*的文件指针推进1。*m*.read_byte()类似于*m*.read(1)。但是，如果*m*的文件指针在*m*的末尾，则*m*.read(1)返回空字符串b''''且不推进，而*m*.read_byte()会引发ValueError异常。'
- en: '| readline | *m*.readline() Reads and returns, as a bytestring, one line from
    *m*’s file, from *m*’s current file pointer up to the next ''\n'', included (or
    up to the end of *m* if there is no ''\n''), then advances *m*’s file pointer
    to point just past the bytes just read. If *m*’s file pointer is at the end of
    *m*, readline returns the empty string b''''. |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| readline | *m*.readline() 从*m*文件的当前文件指针读取并返回一个字节字符串，直到下一个''\n''（包括''\n''），然后将*m*的文件指针推进到刚刚读取的字节之后。如果*m*的文件指针在*m*的末尾，则readline返回空字符串b''''。'
- en: '| resize | *m*.resize(*n*) Changes the length of *m* so that len(*m*) becomes
    *n*. Does not affect the size of *m*’s file. *m*’s length and the file’s size
    are independent. To set *m*’s length to be equal to the file’s size, call *m*.resize(*m*.size()).
    If *m*’s length is larger than the file’s size, *m* is padded with null bytes
    (\x00). |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| resize | *m*.resize(*n*) 改变*m*的长度，使得len(*m*)变为*n*。不影响*m*的文件大小。*m*的长度和文件大小是独立的。要将*m*的长度设置为文件的大小，请调用*m*.resize(*m*.size())。如果*m*的长度大于文件的大小，则*m*将填充空字节（\x00）。'
- en: '| rfind | rfind(sub, start=0, end=**None**) Returns the highest *i* >= start
    such that *sub* == *m*[*i*:*i*+len(*sub*)] (and *i*+len(*sub*)-1 <= end, when
    you pass end). If no such *i* exists, *m*.rfind returns -1. This is the same as
    the rfind method of string objects, covered in [Table 9-1](ch09.xhtml#significant_str_and_bytes_methods).
    |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| rfind | rfind(sub, start=0, end=**None**) 返回大于等于start的最高*i*，使得*sub* == *m*[*i*:*i*+len(*sub*)]（当你传递end时，*i*+len(*sub*)-1
    <= end）。如果不存在这样的*i*，*m*.rfind返回-1。这与字符串对象的rfind方法相同，详见[Table 9-1](ch09.xhtml#significant_str_and_bytes_methods)。'
- en: '| seek | *m*.seek(*pos,* how=0) Sets *m*’s file pointer to the integer byte
    offset *pos*, relative to the position indicated by how:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '| seek | *m*.seek(*pos,* how=0) 将*m*的文件指针设置为整数字节偏移量*pos*，相对于由how指示的位置：'
- en: 0 *or* os.SEEK_SET
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 0 *or* os.SEEK_SET
- en: Offset is relative to start of *m*
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量相对于*m*的起始位置
- en: 1 *or* os.SEEK_CUR
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 1 *or* os.SEEK_CUR
- en: Offset is relative to *m*’s current file pointer
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量相对于*m*的当前文件指针
- en: 2 *or* os.SEEK_END
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 2 *or* os.SEEK_END
- en: Offset is relative to end of *m*
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量相对于*m*的末尾
- en: A seek trying to set *m*’s file pointer to a negative offset, or to an offset
    beyond *m*’s length, raises a ValueError exception. |
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 试图将*m*的文件指针设置为负偏移量或超出*m*长度的偏移量会引发ValueError异常。
- en: '| size | *m*.size() Returns the length (number of bytes) of *m*’s file (not
    the length of *m* itself). To get the length of *m*, use len(*m*). |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| size | *m*.size() 返回*m*文件的长度（以字节为单位），而不是*m*本身的长度。要获取*m*的长度，使用len(*m*)。'
- en: '| tell | *m*.tell() Returns the current position of *m*’s file pointer, a byte
    offset within *m*’s file. |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| tell | *m*.tell() 返回*m*的当前文件指针位置，即*m*文件中的字节偏移量。'
- en: '| write | *m*.write(*b*) Writes the bytes in bytestring *b* into *m* at the
    current position of *m*’s file pointer, overwriting the bytes that were there,
    and then advances *m*’s file pointer by len(*b*). If there aren’t at least len(*b*)
    bytes between *m*’s file pointer and the length of *m*, write raises a ValueError
    exception. |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| write | *m*.write(*b*) 将字节串*b*写入*m*的当前文件指针位置，覆盖已有的字节，然后将*m*的文件指针推进len(*b*)。如果*m*的文件指针与*m*的长度之间的字节数少于len(*b*)，write会引发ValueError异常。'
- en: '| write_byte | *m*.write_byte(*byte*) Writes *byte*, which must be an int,
    into mapping *m* at the current position of *m*’s file pointer, overwriting the
    byte that was there, and then advances *m*’s file pointer by 1. *m*.write_byte(*x*)
    is similar to *m*.write(*x*.to_bytes(1, ''little'')). However, if *m*’s file pointer
    is at the end of *m*, *m*.write_byte(*x*) silently does nothing, while *m*.write(*x*.to_bytes(1,
    ''little'')) raises a ValueError exception. Note that this is the reverse of the
    relationship between read and read_byte at end-of-file: write and read_byte may
    raise ValueError, while read and write_byte never do. |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| write_byte | *m*.write_byte(*byte*) 向映射 *m* 的当前位置写入必须是整数的 *byte*，覆盖原有的字节，然后将
    *m* 的文件指针前移 1。 *m*.write_byte(*x*) 与 *m*.write(*x*.to_bytes(1, ''little'')) 类似。然而，如果
    *m* 的文件指针位于 *m* 的末尾，则 *m*.write_byte(*x*) 静默不做任何操作，而 *m*.write(*x*.to_bytes(1,
    ''little'')) 会引发 ValueError 异常。请注意，这与文件末尾的 read 和 read_byte 之间的关系相反：write 和 read_byte
    可能会引发 ValueError，而 read 和 write_byte 则从不会。'
- en: Using mmap Objects for IPC
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 mmap 对象进行 IPC
- en: 'Processes communicate using mmap pretty much the same way they communicate
    using files: one process writes data, and another process later reads the same
    data back. Since an mmap object has an underlying file, you can have some processes
    doing I/O on the file (as covered in [“The io Module”](ch11.xhtml#the_io_module)),
    while others use mmap on the same file. Choose between mmap and I/O on file objects
    on the basis of convenience: functionality is the same, performance is roughly
    equivalent. For example, here is a simple program that repeatedly uses file I/O
    to make the contents of a file equal to the last line interactively typed by the
    user:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 进程使用 mmap 通信的方式与它们使用文件基本相同：一个进程写入数据，另一个进程稍后读取相同的数据。由于 mmap 对象有一个底层文件，因此可以有一些进程在文件上进行
    I/O（如在 [“The io Module”](ch11.xhtml#the_io_module) 中介绍的），而其他进程在同一个文件上使用 mmap。在便利性和功能性之间选择
    mmap 和文件对象的 I/O，性能大致相当。例如，这里是一个简单的程序，反复使用文件 I/O，使文件的内容等于用户交互式输入的最后一行：
- en: '[PRE30]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And here is another simple program that, when run in the same directory as
    the former, uses mmap (and the time.sleep function, covered in [Table 13-2](ch13.xhtml#functions_and_attributes_of_the_time_mo))
    to check every second for changes to the file and print out the file’s new contents,
    if there have been any changes:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这里有另一个简单的程序，当在与前者相同的目录中运行时，使用 mmap（以及在 [Table 13-2](ch13.xhtml#functions_and_attributes_of_the_time_mo)
    中涵盖的 time.sleep 函数）每秒钟检查文件的变化，并打印出文件的新内容（如果有任何变化的话）：
- en: '[PRE31]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ^([1](ch15.xhtml#ch01fn116-marker)) The best introductory work on async programming
    we have come across, though sadly now dated (as the async approach in Python keeps
    improving), is [*Using Asyncio in Python*](https://www.oreilly.com/library/view/using-asyncio-in/9781492075325/),
    by Caleb Hattingh (O’Reilly). We recommend you also study [Brad Solomon’s Asyncio
    walkthrough](https://oreil.ly/HkGpJ) on Real Python.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch15.xhtml#ch01fn116-marker)) 我们遇到的最好的关于异步编程的入门工作，尽管现在已经过时（因为 Python 中的异步方法不断改进），是
    [*Using Asyncio in Python*](https://www.oreilly.com/library/view/using-asyncio-in/9781492075325/)，作者是
    Caleb Hattingh（O’Reilly）。我们建议你也学习 [Brad Solomon 的 Asyncio 演示](https://oreil.ly/HkGpJ)
    在 Real Python 上。
- en: ^([2](ch15.xhtml#ch01fn117-marker)) The online docs include an especially helpful
    [“Programming Guidelines” section](https://oreil.ly/6EqPh) that lists a number
    of additional practical recommendations when using the multiprocessing module.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch15.xhtml#ch01fn117-marker)) 在线文档包括一个特别有用的 [“编程指南”部分](https://oreil.ly/6EqPh)，列出了使用
    multiprocessing 模块时的许多额外实用建议。
- en: ^([3](ch15.xhtml#ch01fn118-marker)) A race condition is a situation in which
    the relative timings of different events, which are usually unpredictable, can
    affect the outcome of a computation…never a good thing!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch15.xhtml#ch01fn118-marker)) 竞争条件是一种情况，其中不同事件的相对时间通常是不可预测的，可能会影响计算的结果...
    这从来都不是一件好事！
- en: ^([4](ch15.xhtml#ch01fn119-marker)) Just like **2>&1** would specify in a Unix-y
    shell command line.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch15.xhtml#ch01fn119-marker)) 就像在 Unix 风格的 shell 命令行中指定 **2>&1** 一样。
