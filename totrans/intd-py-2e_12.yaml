- en: Chapter 11\. Modules, Packages, and Goodies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。模块、包和好东西
- en: During your bottom-up climb, you’ve progressed from built-in data types to constructing
    ever-larger data and code structures. In this chapter, you finally learn how to
    write realistic whole programs in Python. You’ll write your own *modules* and
    learn how to use others from Python’s *standard library* and other sources.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在您从底层向上攀登的过程中，您已经从内置数据类型进展到构建越来越大的数据和代码结构。在本章中，您终于学会如何在Python中编写现实的完整程序。您将编写自己的*模块*，并学习如何使用来自Python标准库和其他来源的模块。
- en: 'The text of this book is organized in a hierarchy: words, sentences, paragraphs,
    and chapters. Otherwise, it would be unreadable pretty quickly.^([1](ch11.html#idm45794994198296))
    Code has a roughly similar bottom-up organization: data types are like words;
    expressions and statements are like sentences; functions are like paragraphs;
    and modules are like chapters. To continue the analogy, in this book, when I say
    that something will be explained in [Chapter 8](ch08.html#ch_dicts), in programming
    that’s like referring to code in another module.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的文本是按层次结构组织的：单词、句子、段落和章节。否则，它会很快变得难以阅读。^([1](ch11.html#idm45794994198296))
    代码的组织原则大致相同：数据类型类似于单词；表达式和语句类似于句子；函数类似于段落；模块类似于章节。继续这个类比，在本书中，当我说某些内容将在[第8章](ch08.html#ch_dicts)中解释时，在编程中这就像是引用另一个模块中的代码。
- en: Modules and the import Statement
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和import语句
- en: We’ll create and use Python code in more than one file. A *module* is just a
    file of any Python code. You don’t need to do anything special—any Python code
    can be used as a module by others.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在多个文件中创建和使用Python代码。*模块*只是包含任何Python代码的文件。您不需要做任何特殊处理——任何Python代码都可以被其他人用作模块。
- en: We refer to code of other modules by using the Python `import` statement. This
    makes the code and variables in the imported module available to your program.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用Python的`import`语句引用其他模块的代码。这使得导入模块中的代码和变量对您的程序可用。
- en: Import a Module
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入一个模块
- en: The simplest use of the `import` statement is `import` *`module`*, where *`module`*
    is the name of another Python file, without the *.py* extension.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句的最简单用法是`import` *`module`*，其中*`module`*是另一个Python文件的名称，不带*.py*扩展名。'
- en: Let’s say you and a few others want something fast for lunch, but don’t want
    a long discussion, and you always end up picking what the loudest person wants
    anyhow. Let the computer decide! Let’s write a module with a single function that
    returns a random fast-food choice, and a main program that calls it and prints
    the choice.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你和几个人想要快速解决午餐问题，但又不想进行长时间的讨论，最后总是由最吵闹的那个人决定。让电脑来决定吧！让我们编写一个单一函数的模块，返回一个随机的快餐选择，以及调用该函数并打印选择的主程序。
- en: The module (*fast.py*) is shown in [Example 11-1](#ch11_ex1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 模块（*fast.py*）显示在[示例 11-1](#ch11_ex1)中。
- en: Example 11-1\. fast.py
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-1。fast.py
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And [Example 11-2](#ch11_ex2) shows the main program that imports it (call it
    *lunch.py*).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 并且[示例 11-2](#ch11_ex2)展示了导入它的主程序（称为*lunch.py*）。
- en: Example 11-2\. lunch.py
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-2。lunch.py
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you have these two files in the same directory and instruct Python to run
    *lunch.py* as the main program, it will access the `fast` module and run its `pick()`
    function. We wrote this version of `pick()` to return a random result from a list
    of strings, so that’s what the main program will get back and print:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将这两个文件放在同一个目录中，并指示Python将*lunch.py*作为主程序运行，它将访问`fast`模块并运行其`pick()`函数。我们编写了`pick()`的这个版本，以从字符串列表中返回一个随机结果，因此主程序将获得并打印出这个结果：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We used imports in two different places:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两个不同的地方使用了导入：
- en: The main program *lunch.py* imported our new module `fast`.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主程序*lunch.py*导入了我们的新模块`fast`。
- en: The module file *fast.py* imported the `choice` function from Python’s standard
    library module named `random`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块文件*fast.py*从Python的标准库模块`random`中导入了`choice`函数。
- en: 'We also used imports in two different ways in our main program and our module:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在主程序和模块中以两种不同的方式使用了导入：
- en: In the first case, we imported the entire `fast` module but needed to use `fast`
    as a prefix to `pick()`. After this `import` statement, everything in *fast.py*
    is available to the main program, as long as we tack `fast.` before its name.
    By *qualifying* the contents of a module with the module’s name, we avoid any
    nasty naming conflicts. There could be a `pick()` function in some other module,
    and we would not call it by mistake.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们导入了整个 `fast` 模块，但需要使用 `fast` 作为 `pick()` 的前缀。在这个 `import` 语句之后，只要我们在名称前加上
    `fast.`，*fast.py* 中的所有内容对主程序都是可用的。通过用模块的名称*限定*模块的内容，我们避免了任何糟糕的命名冲突。其他模块可能有一个 `pick()`
    函数，我们不会误调用它。
- en: In the second case, we’re within a module and know that nothing else named `choice`
    is here, so we imported the `choice()` function from the `random` module directly.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们在一个模块内部，并且知道这里没有其他名为 `choice` 的内容，因此直接从 `random` 模块中导入了 `choice()`
    函数。
- en: We could have written *fast.py*, as shown in [Example 11-3](#ch11_ex3), importing
    `random` within the `pick()` function instead of at the top of the file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以像[示例 11-3](#ch11_ex3)中所示那样编写 *fast.py*，在 `pick()` 函数内部导入 `random` 而不是在文件顶部。
- en: Example 11-3\. fast2.py
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-3\. fast2.py
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Like many aspects of programming, use the style that seems the most clear to
    you. The module-qualified name (`random.choice`) is safer but requires a little
    more typing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 像编程的许多方面一样，使用最清晰的风格。使用模块限定的名称（`random.choice`）更安全，但需要稍微多输入一些字。
- en: Consider importing from outside the function if the imported code might be used
    in more than one place, and from inside if you know its use will be limited. Some
    people prefer to put all their imports at the top of the file, just to make all
    the dependencies of their code explicit. Either way works.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导入的代码可能在多个地方使用，请考虑从函数外部导入；如果知道其使用将受限制，请从函数内部导入。有些人喜欢将所有导入都放在文件顶部，以明确代码的所有依赖关系。无论哪种方式都可以。
- en: Import a Module with Another Name
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用另一个名称导入模块
- en: 'In our main *lunch.py* program, we called `import fast`. But what if you:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主 *lunch.py* 程序中，我们调用了 `import fast`。但如果你：
- en: Have another module named `fast` somewhere?
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有另一个名为 `fast` 的模块吗？
- en: Want to use a name that is more mnemonic?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想使用一个更易记的名称吗？
- en: Caught your fingers in a door and want to minimize typing?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门夹到手指想减少打字？
- en: In these cases, you can import using an *alias*, as shown in [Example 11-4](#ch11_ex4).
    Let’s use the alias `f`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，你可以使用一个*别名*导入，如[示例 11-4](#ch11_ex4)所示。让我们使用别名 `f`。
- en: Example 11-4\. fast3.py
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-4\. fast3.py
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Import Only What You Want from a Module
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从一个模块中仅导入你想要的内容
- en: 'You can import a whole module or just parts of it. You just saw the latter:
    we only wanted the `choice()` function from the `random` module.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以导入整个模块，也可以只导入部分。你刚刚看到了后者：我们只想要 `random` 模块中的 `choice()` 函数。
- en: Like the module itself, you can use an alias for each thing that you import.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 像模块本身一样，你可以为每个导入的东西使用别名。
- en: Let’s redo *lunch.py* a few more times. First, import `pick()` from the `fast`
    module with its original name ([Example 11-5](#ch11_ex5)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再重新做几次 *lunch.py*。首先，从 `fast` 模块中以其原始名称导入 `pick()`（[示例 11-5](#ch11_ex5)）。
- en: Example 11-5\. fast4.py
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-5\. fast4.py
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now import it as `who_cares`([Example 11-6](#ch11_ex6)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将其导入为 `who_cares`（[示例 11-6](#ch11_ex6)）。
- en: Example 11-6\. fast5.py
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-6\. fast5.py
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Packages
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包
- en: We went from single lines of code, to multiline functions, to standalone programs,
    to multiple modules in the same directory. If you don’t have many modules, the
    same directory works fine.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从单行代码、到多行函数、到独立程序、再到同一目录中的多个模块。如果你没有很多模块，同一目录也可以正常工作。
- en: To allow Python applications to scale even more, you can organize modules into
    file and module hierarchies called *packages*. A package is just a subdirectory
    that contains *.py* files. And you can go more than one level deep, with directories
    inside those.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 Python 应用程序能够更好地扩展，你可以将模块组织成称为*包*的文件和模块层次结构。一个包只是包含 *.py* 文件的子目录。而且你可以进行多层次的组织，有目录在其中。
- en: We just wrote a module that chooses a fast-food place. Let’s add a similar module
    to dispense life advice. We’ll make one new main program called *questions.py*
    in our current directory. Now make a subdirectory named *choices* and put two
    modules in it—*fast.py* and *advice.py*. Each module has a function that returns
    a string.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚写了一个选择快餐的模块。让我们再添加一个类似的模块来提供人生建议。我们将在当前目录中创建一个名为 *questions.py* 的新主程序。现在在其中创建一个名为
    *choices* 的子目录，并将两个模块放入其中——*fast.py* 和 *advice.py*。每个模块都有一个返回字符串的函数。
- en: The main program (*questions.py*) has an extra import and line ([Example 11-7](#ch11_ex7)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序（*questions.py*）有额外的导入和行（[示例 11-7](#ch11_ex7)）。
- en: Example 11-7\. questions.py
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-7\. questions.py
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That `from sources` makes Python look for a directory named *sources*, starting
    under your current directory. Inside *sources* it looks for the files *fast.py*
    and *advice.py*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`from sources`让Python在当前目录下查找名为*sources*的目录。在*sources*内部，它查找*fast.py*和*advice.py*文件。
- en: The first module (*choices/fast.py*) is the same code as before, just moved
    into the *choices* directory ([Example 11-8](#ch11_ex8)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模块（*choices/fast.py*）与以前相同的代码，只是移动到了*choices*目录中（[示例 11-8](#ch11_ex8)）。
- en: Example 11-8\. choices/fast.py
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-8\. choices/fast.py
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The second module (*choices/advice.py*) is new, but it works a lot like its
    fast-food relative ([Example 11-9](#ch11_ex9)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个模块（*choices/advice.py*）是新的，但功能与快餐相似（[示例 11-9](#ch11_ex9)）。
- en: Example 11-9\. choices/advice.py
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-9\. choices/advice.py
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If your version of Python is earlier than 3.3, you’ll need one more thing in
    the *sources* subdirectory to make it a Python package: a file named *__init__.py*.
    This can be an empty file, but pre-3.3 Python needs it to treat the directory
    containing it as a package. (This is another common Python interview question.)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的Python版本早于3.3，那么在*sources*子目录中还需要一件事才能使其成为Python包：一个名为*\_\_init\_\_.py*的文件。这可以是一个空文件，但是在3.3之前的Python中，需要这样做才能将包含它的目录视为包。（这是另一个常见的Python面试问题。）
- en: 'Run the main *questions.py* program (from your current directory, not in *sources*)
    to see what happens:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运行主程序*questions.py*（从当前目录，而不是*sources*中）来看看会发生什么：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Module Search Path
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块搜索路径
- en: I just said that Python looks under your current directory for the subdirectory
    *choices* and its modules. Actually, it looks in other places, as well, and you
    can control this.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚才说过，Python会在当前目录下查找子目录*choices*及其模块。实际上，它还会在其他地方查找，并且你可以控制这一过程。
- en: Earlier, we imported the function `choice()` from the standard library’s `random`
    module. That wasn’t in your current directory, so Python needed to look elsewhere
    also.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们从标准库的`random`模块导入了函数`choice()`。这不在你的当前目录中，因此Python还需要在其他地方查找。
- en: To see all the places that your Python interpreter looks, import the standard
    `sys` module and use its `path` list. This is a list of directory names and ZIP
    archive files that Python searches in order to find modules to import.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Python解释器查找的所有位置，导入标准的`sys`模块并使用它的`path`列表。这是一个目录名称和ZIP存档文件列表，Python按顺序搜索以找到要导入的模块。
- en: 'You can access and modify this list. Here’s the value of `sys.path` for Python
    3.7 on my Mac:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问并修改这个列表。这是我Mac上Python 3.7的`sys.path`值：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That initial blank output line is the empty string `''''`, which stands for
    the current directory. If `''''` is first in `sys.path`, Python looks in the current
    directory first when you try to import something: `import fast` looks for *fast.py*.
    This is Python’s usual setup. Also, when we made that subdirectory called *sources*
    and put Python files in it, they could be imported with `import sources` or `from
    sources import fast`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 那个初始的空输出行是空字符串`''`，它表示当前目录。如果`''`在`sys.path`的第一位，当你尝试导入某些东西时，Python首先查找当前目录：`import
    fast`会寻找*fast.py*。这是Python的常规设置。此外，当我们创建名为*sources*的子目录并在其中放置Python文件时，它们可以通过`import
    sources`或`from sources import fast`来导入。
- en: The first match will be used. This means that if you define a module named `random`
    and it’s in the search path before the standard library, you won’t be able to
    access the standard library’s `random` now.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用第一个匹配项。这意味着如果你定义了一个名为`random`的模块，并且它在标准库之前的搜索路径中，那么现在就无法访问标准库的`random`了。
- en: 'You can modify the search path within your code. Let’s say you want Python
    to look in the */my/modules* directory before any other:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中修改搜索路径。假设你希望Python在其他任何位置之前查找*/my/modules*目录：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Relative and Absolute Imports
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相对和绝对导入
- en: 'In our examples so far, we imported our own modules from:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的示例中，我们从以下位置导入了我们自己的模块：
- en: The current directory
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前目录
- en: The subdirectory *choices*
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子目录*choices*
- en: The Python standard library
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python标准库
- en: This works well until you have a local module with the same name as a standard
    one. Which do you want?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这在你有与标准模块同名的本地模块时效果很好。你想要哪一个？
- en: Python supports *absolute* or *relative* imports. The examples that you’ve seen
    so far are absolute imports. If you typed `import rougarou`, for each directory
    in the search path, Python will look for a file named *rougarou.py* (a module)
    or a directory named *rougarou* (a package).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持*绝对*或*相对*导入。到目前为止你看到的例子都是绝对导入。如果你键入`import rougarou`，对于搜索路径中的每个目录，Python会查找名为*rougarou.py*（一个模块）或名为*rougarou*（一个包）的文件。
- en: If *rougarou.py* is in the same directory as your calling problem, you can import
    it *relative* to your location with `from . import rougarou`.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*rougarou.py*与你调用问题的同一目录中，你可以用`from . import rougarou`来相对于你所在位置导入它。
- en: 'If it’s in the directory above you: `from .. import rougarou`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它位于你的上一级目录中：`from .. import rougarou`。
- en: 'If it’s under a sibling directory called `creatures`: `from ..creatures import`
    `rougarou`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它位于名为`creatures`的同级目录下：`from ..creatures import rougarou`。
- en: The `.` and `..` notation was borrowed from Unix’s shorthand for *current directory*
    and *parent directory*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`.`和`..`的符号借鉴于Unix对*当前目录*和*父目录*的简写。'
- en: For a good discussion of Python import problems that you may run into, see [Traps
    for the Unwary in Python’s Import System](https://oreil.ly/QMWHY).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python导入系统中可能遇到的问题的深入讨论，请参阅[Python导入系统的陷阱](https://oreil.ly/QMWHY)。
- en: Namespace Packages
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间包
- en: 'You’ve seen that you can package Python modules as:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到可以将Python模块打包为：
- en: A single *module* (*.py* file)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单一的*模块*（*.py* 文件）
- en: A *package* (directory containing modules, and possibly other packages)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*包*（包含模块及可能其他包的目录）'
- en: 'You can also split a package across directories with *namespace packages*.
    Say you want a package called *critters* that will contain a Python module for
    each dangerous creature (real or imagined, supposedly with background info and
    protective hints). This might get large over time, and you’d like to subdivide
    these by geographic location. One option is to add location subpackages under
    *critters* and move the existing *.py* module files under them, but this would
    break things for other modules that import them. Instead, we can go *up* and do
    the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过*命名空间包*在多个目录中分割一个包。假设你想要一个名为*critters*的包，其中包含每种危险生物（真实或想象中，据说具有背景信息和防护提示）的Python模块。随着时间的推移，这可能会变得很庞大，你可能希望按地理位置细分。一种选择是在*critters*下添加位置子包，并将现有的*.py*模块文件移到它们下面，但这会打破其他导入它们的模块。相反，我们可以向*上*进行如下操作：
- en: Make new location directories above *critters*
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*critters*上创建新的位置目录
- en: Make cousin *critters* directories under these new parents
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这些新父目录下创建表兄弟目录*critters*
- en: Move existing modules to their respective directories.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有模块移动到它们各自的目录中。
- en: 'This needs some illustration. Say we started with this file layout:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一些说明。假设我们从这样的文件布局开始：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Normal imports of these modules would look like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块的正常导入看起来像这样：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now if we decided on US locations *north* and *south*, the files and directories
    would look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们决定在美国的*北*和*南*地点，文件和目录看起来会像这样：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If both *north* and *south* are in your module search path, you can import
    the modules as though they were still cohabiting a single-directory package:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*north*和*south*都在你的模块搜索路径中，你可以像它们仍然共存于单目录包一样导入这些模块：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Modules Versus Objects
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块与对象
- en: When should you put your code into a module, and when into an object?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该把你的代码放入一个模块中，还是放入一个对象中？什么时候适合？
- en: They look similar in many ways. An object or module called `thing` with an internal
    data value called `stuff` would let you access the value as `thing.stuff`. `stuff`
    may have been defined when the module or class was created, or it may have been
    assigned later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在许多方面看起来很相似。一个名为`thing`的对象或模块，具有称为`stuff`的内部数据值，让你可以像`thing.stuff`那样访问该值。`stuff`可能在创建模块或类时已经定义，也可能是后来分配的。
- en: All the classes, functions, and global variables in a module are available to
    the outside. Objects can use properties and “dunder” (`__` …) naming to hide or
    control access to their data attributes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 模块中的所有类、函数和全局变量对外部都是可用的。对象可以使用属性和“dunder”（`__` …）命名来隐藏或控制对它们数据属性的访问。
- en: 'This means you can do this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以这样做：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Did you just ruin calculations for everyone on this computer? Yes! No, I’m kidding.^([2](ch11.html#idm45794993539736))
    This did not affect the Python `math` module. You only changed the value of `pi`
    for the copy of the `math` module code imported by your calling program, and all
    evidence of your crimes will disappear when it finishes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚搞砸了这台计算机上每个人的计算吗？是的！不，开玩笑的。^([2](ch11.html#idm45794993539736)) 这并未影响 Python
    的 `math` 模块。你只是改变了你调用程序导入的 `math` 模块代码的副本中 `pi` 的值，并且所有关于你罪行的证据将在程序结束时消失。
- en: There’s only one copy of any module imported by your program, even if you import
    it more than once. You can use it to save global things, of interest to any code
    that imports it. This is similar to a class, which also has only one copy, although
    you can have many objects created from it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序导入的任何模块只有一个副本，即使你多次导入它。你可以用它保存对任何导入代码感兴趣的全局事物。这与类似，尽管你可以从中创建许多对象，但类也只有一个副本。
- en: Goodies in the Python Standard Library
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 标准库中的好东西
- en: One of Python’s prominent claims is that it has “batteries included”—a large
    standard library of modules that perform many useful tasks. They are kept separate
    to avoid bloating the core language. When you’re about to write some Python code,
    it’s often worthwhile to first check whether there’s a standard module that already
    does what you want. It’s surprising how often you encounter little gems in the
    standard library. Python also provides authoritative [documentation](http://docs.python.org/3/library)
    for the modules, along with a [tutorial](http://bit.ly/library-tour). Doug Hellmann’s
    website [Python Module of the Week](http://bit.ly/py-motw) and book [*The Python
    Standard Library by Example*](http://bit.ly/py-libex) (Addison-Wesley Professional)
    are also very useful guides.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的一个显著特点是其“即插即用”——一个包含许多有用任务的大型标准库模块。它们被保持分开，以避免膨胀核心语言。当你打算写一些 Python
    代码时，经常值得先检查是否已经有标准模块实现了你想要的功能。令人惊讶的是，你会经常遇到标准库中的一些小宝石。Python 还为这些模块提供了权威的 [文档](http://docs.python.org/3/library)，以及一个
    [教程](http://bit.ly/library-tour)。Doug Hellmann 的网站 [Python Module of the Week](http://bit.ly/py-motw)
    和书籍 [*The Python Standard Library by Example*](http://bit.ly/py-libex)（Addison-Wesley
    Professional）也是非常有用的指南。
- en: Upcoming chapters in this book feature many of the standard modules that are
    specific to the web, systems, databases, and so on. In this section, I talk about
    some standard modules that have generic uses.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的即将到来的章节涵盖了许多特定于网络、系统、数据库等的标准模块。在本节中，我讨论一些具有通用用途的标准模块。
- en: Handle Missing Keys with setdefault() and defaultdict()
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `setdefault()` 和 `defaultdict()` 处理缺失键
- en: 'You’ve seen that trying to access a dictionary with a nonexistent key raises
    an exception. Using the dictionary `get()` function to return a default value
    avoids an exception. The `setdefault()` function is like `get()`, but also assigns
    an item to the dictionary if the key is missing:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到尝试访问字典的不存在键会引发异常。使用字典的 `get()` 函数返回一个默认值可以避免异常。`setdefault()` 函数类似于 `get()`，但也会在键缺失时向字典中分配一个项目：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the key was *not* already in the dictionary, the new value is used:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键原先 *不* 在字典中，新值就会被使用：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we try to assign a different default value to an *existing* key, the original
    value is returned and nothing is changed:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试为 *现有* 键分配不同的默认值，将返回原始值且不会发生任何更改：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`defaultdict()` is similar, but specifies the default value for any new key
    up front, when the dictionary is created. Its argument is a function. In this
    example, we pass the function `int`, which will be called as `int()` and return
    the integer `0`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict()` 类似，但在创建字典时就指定了任何新键的默认值。它的参数是一个函数。在这个例子中，我们传递了函数 `int`，它将被调用为
    `int()` 并返回整数 `0`：'
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now any missing value will be an integer (`int`), with the value `0`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '现在任何缺失的值将是整数 (`int`), 其值为 `0`:'
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The argument to `defaultdict()` is a function that returns the value to be
    assigned to a missing key. In the following example, `no_idea()` is executed to
    return a value when needed:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict()` 的参数是一个返回要分配给缺失键的值的函数。在下面的例子中，当需要时执行 `no_idea()` 来返回一个值：'
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can use the functions `int()`, `list()`, or `dict()` to return default
    empty values for those types: `int()` returns `0`, `list()` returns an empty list
    (`[]`), and `dict()` returns an empty dictionary (`{}`). If you omit the argument,
    the initial value of a new key will be set to `None`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `int()`、`list()` 或 `dict()` 函数来返回这些类型的默认空值：`int()` 返回 `0`，`list()` 返回一个空列表
    (`[]`)，`dict()` 返回一个空字典 (`{}`)。如果省略参数，新键的初始值将设置为 `None`。
- en: 'By the way, you can use `lambda` to define your default-making function right
    inside the call:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，您可以使用`lambda`在调用内部定义您的默认生成函数：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Using `int` is one way to make your own counter:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`int`是制作自己的计数器的一种方法：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding example, if `food_counter` had been a normal dictionary instead
    of a `defaultdict`, Python would have raised an exception every time we tried
    to increment the dictionary element `food_counter[food]` because it would not
    have been initialized. We would have needed to do some extra work, as shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，如果`food_counter`是一个普通的字典而不是`defaultdict`，每次尝试增加字典元素`food_counter[food]`时，Python都会引发一个异常，因为它不会被初始化。我们需要做一些额外的工作，如下所示：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Count Items with Counter()
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Counter()计算项数
- en: 'Speaking of counters, the standard library has one that does the work of the
    previous example and more:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 说到计数器，标准库中有一个可以执行前面示例工作以及更多工作的计数器：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `most_common()` function returns all elements in descending order, or just
    the top `count` elements if given a count:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`most_common()`以降序返回所有元素，或者如果给定了计数，则仅返回前`count`个元素：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can combine counters. First, let’s see again what’s in `breakfast_counter`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以组合计数器。首先，让我们再次看看`breakfast_counter`中有什么：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This time, we make a new list called `lunch`, and a counter called `lunch_counter`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们创建了一个名为`lunch`的新列表，以及一个名为`lunch_counter`的计数器：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The first way we combine the two counters is by addition, using `+`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组合两个计数器的第一种方法是通过加法，使用`+`：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you might expect, you subtract one counter from another by using `-`. What’s
    for breakfast but not for lunch?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所预期的，您可以使用`-`从另一个计数器中减去一个计数器。早餐吃什么而午餐不吃呢？
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Okay, now what can we have for lunch that we can’t have for breakfast?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们可以吃午餐了，但是我们早餐不能吃什么呢？
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Similar to sets in [Chapter 8](ch08.html#ch_dicts), you can get common items
    by using the intersection operator `&`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[第8章](ch08.html#ch_dicts)中的集合，您可以使用交集运算符`&`获取共同的项：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The intersection chose the common element (`''eggs''`) with the lower count.
    This makes sense: breakfast offered only one egg, so that’s the common count.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 交集选择了具有较低计数的共同元素（`'eggs'`）。这是有道理的：早餐只提供了一个鸡蛋，所以这是共同的计数。
- en: 'Finally, you can get all items by using the union operator `|`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用并集运算符`|`获取所有项：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The item `'eggs'` was again common to both. Unlike addition, union didn’t add
    their counts, but selected the one with the larger count.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 项目`'eggs'`再次是两者共同的。与加法不同，联合操作并未将它们的计数相加，而是选择计数较大的那个。
- en: Order by Key with OrderedDict()
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用OrderedDict()按键排序
- en: 'This is an example run with the Python 2 interpreter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用Python 2解释器运行的示例：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with Python 3.7, dictionaries retain keys in the order in which they
    were added. `OrderedDict` is useful for earlier versions, which have an unpredictable
    order. The examples in this section are relevant only if you’re a version of Python
    earlier than 3.7.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.7开始，字典会按照它们被添加的顺序保留键。`OrderedDict`对于早期版本非常有用，因为它们具有不可预测的顺序。本节中的示例仅在您使用的Python版本早于3.7时才相关。
- en: 'An `OrderedDict()` remembers the order of key addition and returns them in
    the same order from an iterator. Try creating an `OrderedDict` from a sequence
    of (*key*, *value*) tuples:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderedDict()`记住键添加的顺序，并从迭代器中以相同的顺序返回它们。尝试从一个(*键*, *值*)元组序列创建一个`OrderedDict`：'
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Stack + Queue == deque
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈+队列==deque
- en: 'A `deque` (pronounced *deck*) is a double-ended queue, which has features of
    both a stack and a queue. It’s useful when you want to add and delete items from
    either end of a sequence. Here, we work from both ends of a word to the middle
    to see whether it’s a palindrome. The function `popleft()` removes the leftmost
    item from the deque and returns it; `pop()` removes the rightmost item and returns
    it. Together, they work from the ends toward the middle. As long as the end characters
    match, it keeps popping until it reaches the middle:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`deque`（发音为*deck*）是一个双端队列，具有栈和队列的特性。当你想要从序列的任一端添加或删除项时，它非常有用。在这里，我们从单词的两端向中间工作，以查看它是否是回文。函数`popleft()`从deque中删除最左边的项并返回它；`pop()`则删除最右边的项并返回它。它们一起从两端向中间工作。只要末尾字符匹配，它就会持续弹出，直到达到中间位置：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'I used this as a simple illustration of deques. If you really wanted a quick
    palindrome checker, it would be a lot simpler to just compare a string with its
    reverse. Python doesn’t have a `reverse()` function for strings, but it does have
    a way to reverse a string with a slice, as illustrated here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其用作双端队列的简单说明。如果你真的想要一个快速的回文检查器，只需将字符串与其反转比较就简单得多了。Python 没有字符串的 `reverse()`
    函数，但它确实有一种通过切片来反转字符串的方法，如下例所示：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Iterate over Code Structures with itertools
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用itertools遍历代码结构
- en: '[`itertools`](http://bit.ly/py-itertools) contains special-purpose iterator
    functions. Each returns one item at a time when called within a `for` … `in` loop,
    and remembers its state between calls.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[`itertools`](http://bit.ly/py-itertools)包含特殊用途的迭代器函数。每次在`for`…`in`循环中调用时，它返回一个项目，并在调用之间记住其状态。'
- en: '`chain()` runs through its arguments as though they were a single iterable:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`chain()` 将其参数视为单个可迭代对象运行：'
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`cycle()` is an infinite iterator, cycling through its arguments:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`cycle()`是一个无限迭代器，循环遍历其参数：'
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And, so on.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。
- en: '`accumulate()` calculates accumulated values. By default, it calculates the
    sum:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`accumulate()` 计算累积值。默认情况下，它计算总和：'
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can provide a function as the second argument to `accumulate()`, and it
    will be used instead of addition. The function should take two arguments and return
    a single result. This example calculates an accumulated product:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将一个函数作为`accumulate()`的第二个参数提供，它将被用于代替加法。该函数应该接受两个参数并返回一个单一的结果。这个例子计算一个累积乘积：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `itertools` module has many more functions, notably some for combinations
    and permutations that can be time savers when the need arises.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: itertools模块还有许多其他函数，尤其是一些组合和排列函数，在需要时可以节省时间。
- en: Print Nicely with pprint()
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`pprint()`进行漂亮打印
- en: 'All of our examples have used `print()` (or just the variable name, in the
    interactive interpreter) to print things. Sometimes, the results are hard to read.
    We need a *pretty printer* such as `pprint()`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的例子都使用`print()`（或者在交互式解释器中仅使用变量名）来打印东西。有时，结果很难读取。我们需要一个*漂亮打印机*，比如`pprint()`：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Plain old `print()` just dumps things out there:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的`print()`只是将东西倒出来：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'However, `pprint()` tries to align elements for better readability:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`pprint()`试图对齐元素以提高可读性：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Get Random
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取随机数
- en: 'We played with `random.choice()` at the beginning of this chapter. That returns
    a value from the sequence (list, tuple, dictionary, string) argument that it’s
    given:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的开头玩了`random.choice()`。它从给定的序列（列表、元组、字典、字符串）中返回一个值：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Use the `sample()` function to get more than one value at a time:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sample()`函数一次获取多个值：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To get a random integer from any range, you can use `choice()` or `sample()`
    with `range()`, or use `randint()` or `randrange()`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要从任意范围获取一个随机整数，您可以使用`choice()`或`sample()`与`range()`，或者使用`randint()`或`randrange()`：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`randrange()`, like `range()`, has arguments for the start (inclusive) and
    end (exclusive) integers, and an optional integer step:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`randrange()`像`range()`一样，有起始（包含）和结束（不包含）整数的参数，还有一个可选的整数步长：'
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, get a random real number (a float) between 0.0 and 1.0:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，获取一个在0.0到1.0之间的随机实数（浮点数）：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'More Batteries: Get Other Python Code'
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多电池：获取其他Python代码
- en: 'Sometimes, the standard library doesn’t have what you need, or doesn’t do it
    in quite the right way. There’s an entire world of open source, third-party Python
    software. Good resources include the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，标准库没有您需要的功能，或者没有以正确的方式执行。有一个完整的开源、第三方Python软件世界。良好的资源包括以下内容：
- en: '[PyPi](http://pypi.python.org) (also known as the Cheese Shop, after an old
    Monty Python skit)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PyPi](http://pypi.python.org)（也称为奶酪商店，源自老蒙提·派森小品）'
- en: '[GitHub](https://github.com/Python)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GitHub](https://github.com/Python)'
- en: '[readthedocs](https://readthedocs.org)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[readthedocs](https://readthedocs.org)'
- en: You can find many smaller code examples at [activestate](https://oreil.ly/clMAi).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[activestate](https://oreil.ly/clMAi)找到许多较小的代码示例。
- en: 'Almost all of the Python code in this book uses the standard Python installation
    on your computer, which includes all the built-ins and the standard library. External
    packages are featured in some places: I mentioned `requests` in [Chapter 1](ch01.html#ch_intro);
    I have more details in [Chapter 18](ch18.html#ch_web). [Appendix B](app02.html#app_install)
    shows how to install third-party Python software, along with many other nuts-and-bolts
    development details.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本书几乎所有的Python代码都使用您计算机上的标准Python安装，其中包括所有内置函数和标准库。某些地方特别提到了`requests`在[第1章](ch01.html#ch_intro)中；更多细节请参见[第18章](ch18.html#ch_web)。[附录B](app02.html#app_install)展示了如何安装第三方Python软件，以及许多其他开发细节。
- en: Coming Up
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将发生的事情
- en: The next chapter is a practical one, covering many aspects of data manipulation
    in Python. You’ll encounter the binary *bytes* and *bytearray* data types, handle
    Unicode characters in text strings, and search text strings with regular expressions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是一个实用章节，涵盖Python中许多数据操作的方面。您将遇到二进制*bytes*和*bytearray*数据类型，在文本字符串中处理Unicode字符，并使用正则表达式搜索文本字符串。
- en: Things to Do
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要做的事情
- en: 11.1 Create a file called *zoo.py*. In it, define a function called `hours()`
    that prints the string `'Open 9-5 daily'`. Then, use the interactive interpreter
    to import the `zoo` module and call its `hours()` function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 11.1 创建一个名为*zoo.py*的文件。在其中，定义一个名为`hours()`的函数，打印字符串`'Open 9-5 daily'`。然后，使用交互解释器导入`zoo`模块并调用其`hours()`函数。
- en: 11.2 In the interactive interpreter, import the `zoo` module as `menagerie`
    and call its `hours()` function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 11.2 在交互解释器中，将`zoo`模块作为`menagerie`导入，并调用其`hours()`函数。
- en: 11.3 Staying in the interpreter, import the `hours()` function from `zoo` directly
    and call it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 11.3 仍然在解释器中，直接从`zoo`中导入`hours()`函数并调用它。
- en: 11.4 Import the `hours()` function as `info` and call it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 11.4 将`hours()`函数作为`info`导入并调用它。
- en: '11.5 Make a dictionary called `plain` with the key-value pairs `''a'': 1`,
    `''b'': 2`, and `''c'': 3`, and then print it.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '11.5 创建一个名为`plain`的字典，其键值对为`''a'': 1`，`''b'': 2`和`''c'': 3`，然后打印它。'
- en: 11.6 Make an `OrderedDict` called `fancy` from the same pairs listed in the
    previous question and print it. Did it print in the same order as `plain`?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 11.6 从上一个问题中列出的相同对创建一个名为`fancy`的`OrderedDict`并打印它。它是否按照`plain`的顺序打印？
- en: 11.7 Make a `defaultdict` called `dict_of_lists` and pass it the argument `list`.
    Make the list `dict_of_lists['a']` and append the value `'something for a'` to
    it in one assignment. Print `dict_of_lists['a']`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 11.7 创建一个名为`dict_of_lists`的`defaultdict`，并传递`list`作为参数。用一次赋值操作将列表`dict_of_lists['a']`并附加值`'something
    for a'`。打印`dict_of_lists['a']`。
- en: ^([1](ch11.html#idm45794994198296-marker)) At least, a little less readable
    than it already is.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.html#idm45794994198296-marker)) 至少，比它现在的阅读性少一点。
- en: ^([2](ch11.html#idm45794993539736-marker)) Or am I? Bwa ha ha.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch11.html#idm45794993539736-marker)) 还是会？布娃哈哈。
