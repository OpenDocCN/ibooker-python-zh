- en: Chapter 6\. Customizing Your Typechecker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typecheckers are one of your best resources for building robust codebases.
    Jukka Lehtosalo, the lead developer of mypy, offers a beautifully concise definition
    of typecheckers: “In essence, [a typechecker] provides verified documentation.”^([1](part0009_split_008.html#idm45644746850088))
    Type annotations provide documentation about your codebase, allowing other developers
    the ability to reason about your intentions. Typecheckers use those annotations
    to verify that the documentation matches the behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: As such, a typechecker is invaluable. Confucius once said, “The mechanic, who
    wishes to do his work well, must first sharpen his tools.”^([2](part0009_split_008.html#idm45644746847016))
    This chapter is all about sharpening your typechecker. Great coding techniques
    can get you far, but it’s your surrounding tooling that takes you to the next
    level. Don’t stop with just learning your editor, compiler, or operating system.
    Learn your typechecker too. I will show you some of the more useful options to
    get the most out of your tools.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Your Typechecker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I will focus on one of the most popular typecheckers out there: mypy. When
    you run a typechecker in an IDE (such as PyCharm), it typically runs mypy underneath
    the hood (although many IDEs will allow you to change the default typechecker).
    Anytime you configure mypy (or whatever your default typechecker is), your IDE
    will use that configuration as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Mypy offers quite a few configuration options to control the typechecker’s *strictness*,
    or the amount of errors reported. The stricter you make your typechecker, the
    more type annotations you need to write, which provides better documentation and
    creates fewer bugs. However, make the typechecker too strict, and you will find
    the minimum bar for developing code too high, incurring high costs to make changes.
    Mypy configuration options control these strictness levels. I’ll go through the
    different options available to you, and you can decide where that bar lies for
    you and your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to install mypy (if you haven’t already). The easiest way is
    through `pip` on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have mypy installed, you you can control configuration in one of three
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Command line
  prefs: []
  type: TYPE_NORMAL
- en: When instantiating mypy from a terminal, you can pass various options to configure
    behavior. This is great for exploring new checks in your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Inline configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify configuration values at the top of a file to indicate any options
    you may want to set. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Putting this line at the top of your file will tell mypy to explicitly fail
    if it finds any generic type annotated with `Any`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration file
  prefs: []
  type: TYPE_NORMAL
- en: You can set up a configuration file to use the same options every time mypy
    runs. This is extremely useful when needing to share the same options across a
    team. This file is typically stored in version control alongside the code.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring mypy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When running mypy, it looks in your current directory for a configuration file
    named *mypy.ini*. This file will define which options you have set up for the
    project. Some options will be global, applied to every file, and other options
    will be per-module. A sample *mypy.ini* file might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can use the `--config-file` command-line option to specify config files
    in different places. Also, mypy will look for configuration files in specific
    home directories if it can’t find a local config file, in case you want the same
    settings across multiple projects. For more information, check out the [mypy documentation](https://oreil.ly/U1JO9).
  prefs: []
  type: TYPE_NORMAL
- en: As a note, I won’t cover too much more about the configuration file. Most options
    that I’ll talk about work in both a configuration file and on the command line,
    and for the sake of simplicity, I’ll show you how to run the commands on mypy
    invocations.
  prefs: []
  type: TYPE_NORMAL
- en: In the following pages, I will cover a multitude of typechcecker configurations;
    you do not need to apply every single one of them to see value in a typechecker.
    Most typecheckers provide immense value right out of the box. However, feel free
    to consider the following options to improve a typechecker’s likelihood of finding
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Catching dynamic behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned before, Python’s dynamically typed nature will make maintenance
    hard on codebases that last a long time. Variables are free to be rebound to values
    with different types at any time. When this happens, the variable is essentially
    an `Any` type. `Any` types indicate that you should make no assumptions about
    what type that variable is. This makes it tricky to reason about: your typechecker
    won’t be of much use in preventing errors and you aren’t communicating anything
    special to future developers.'
  prefs: []
  type: TYPE_NORMAL
- en: Mypy comes with a set of flags that you can turn on to flag instances of the
    `Any` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you can turn on the `--disallow-any-expr` option to flag any
    expression that has an `Any` type. The following code will fail with that option
    turned on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option I like for disallowing `Any` in type declarations (such as in
    collections) is `--disallow-any-generics`. This catches the use of `Any` for anything
    using a generic (such as collection types). The following code fails to typecheck
    with this option turned on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You would need to use `list[int]` explicitly to get this code to work.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out all the ways to disable the use of `Any` in the [mypy dynamic
    typing documentation](https://oreil.ly/Fmspo).
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with disabling `Any` too broadly, though. There is a valid use case
    of `Any` that you don’t want to flag erroneously. `Any` should be reserved for
    when you absolutely don’t care what type something is and that it is up to the
    caller to verify the type. A prime example is a heterogeneous key-value store
    (perhaps a general-purpose cache).
  prefs: []
  type: TYPE_NORMAL
- en: Requiring types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An expression is *untyped* if there is no type annotation. In these cases, mypy
    treats the result of that expression as an `Any` type if it can’t otherwise infer
    the type. However, the previous checks for disallowing `Any` will not catch where
    a function is left untyped. There is a separate set of flags for checking for
    untyped functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will not error out in a typechecker unless the `--disallow-untyped-defs`
    option is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With that option set, you receive the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If this is too severe for you, you might want to check out `--disallow-incomplete-defs`,
    which only flags functions if they only have some variables/return values annotated
    (but not all), or `--disallow-untyped-calls`, which only flags calls from annotated
    functions to unannotated functions. You’ll find all the different options concerning
    untyped functions in the [mypy documentation](https://oreil.ly/pOvWs).
  prefs: []
  type: TYPE_NORMAL
- en: Handling None/Optional
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 4](part0007_split_000.html#constraints), you learned how easy it
    was to make the “billion-dollar mistake” when using `None` values. If you turn
    on no other options, make sure that you have `--strict-optional` turned on in
    your typechecker to catch these costly errors. You absolutely want to be checking
    that your use of `None` is not hiding any latent bugs.
  prefs: []
  type: TYPE_NORMAL
- en: When using `--strict-optional`, you must explicitly perform `is None` checks;
    otherwise, your code will fail typechecking.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `--strict-optional` is set (the default is different depending on the mypy
    version, so be sure to double-check), this code should fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s worth noting that mypy also treats `None` values as `Optional`s implicitly.
    I recommend turning this off, so that you are being more explicit in your code.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The parameter `x` is implicitly converted to an `Optional[int]`, since `None`
    is a valid value for it. If you were to do any integer operations on `x`, the
    typechecker would flag it. However, it’s better to be more explicit and express
    that a value can be `None` (to disambiguate for future readers).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set `--no-implicit-optional` in order to get an error, forcing you
    to specify `Optional`. If you were to typecheck the above code with this option
    set, you would see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Mypy Reporting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a typechecker fails in the forest and nobody is around to see it, does it
    print an error message? How do you know that mypy is actually checking your files,
    and that it will actually catch errors? Use mypy’s built-in reporting techniques
    to better visualize results.
  prefs: []
  type: TYPE_NORMAL
- en: First, you can get an HTML report about how many lines of code mypy was able
    to check by passing in `--html-report` to mypy. This produces a HTML file that
    will provide a table similar to the one pictured in [Figure 6-1](part0009_split_003.html#mypy_report).
  prefs: []
  type: TYPE_NORMAL
- en: '![HTML report from running mypy on the mypy source code](../images/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. HTML report from running mypy on the mypy source code
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want a plain-text file, you can use `--linecount-report` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mypy also allows you to track explicit `Any` expressions to understand how
    you are doing on a line-by-line basis. When using the `--any-exprs-report` command-line
    option, mypy will create a text file enumerating per-module statistics for how
    many times you use `Any`. This is very useful for seeing how explicit your type
    annotations are across a codebase. Here are the first few lines from running the
    `--any-exprs-report` option on the mypy codebase itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you’d like more machine-readable formats, you can use the `--junit-xml` option
    to create an XML file in the JUnit format. Most continuous integration systems
    can parse this format, making it ideal for automated report generation as part
    of your build system. To learn about all the different reporting options, check
    out the mypy [report-generation documentation](https://oreil.ly/vVRsm).
  prefs: []
  type: TYPE_NORMAL
- en: Speeding Up mypy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the common complaints about mypy is the time it takes to typecheck large
    codebases. By default, mypy *incrementally* checks files. That is, it uses a cache
    (typically a *.mypy_cache* folder, but the location is also configurable) to check
    only what has changed since last typecheck. This does speed up typechecking, but
    as your codebase gets larger, your typechecker will take longer to run, no matter
    what. This is detrimental for fast feedback during development cycles. The longer
    a tool takes to provide useful feedback to developers, the less often developers
    will run the tool, thus defeating the purpose. It is in everyone’s interest for
    typecheckers to run as fast as possible, so that developers are getting type errors
    at near real time.
  prefs: []
  type: TYPE_NORMAL
- en: In order to speed up mypy even more, you may want to consider a *remote cache*.
    A remote cache provides a way of caching your mypy typechecks somewhere accessible
    to your entire team. This way, you can cache results based on specific commit
    IDs in your version control and share typechecker information. Building this system
    is outside the scope of this book, but the [remote cache documentation](https://oreil.ly/5gO9N)
    in mypy will provide a solid start.
  prefs: []
  type: TYPE_NORMAL
- en: You also should consider mypy in daemon mode. Daemon mode is when mypy runs
    as a standalone process, and keeps the previous mypy state in memory rather than
    on a file system (or across a network link). You can start a mypy daemon by running
    `dmypy run -- mypy-flags <mypy-files>`. Once the daemon is running, you can run
    the exact same command to check the files again.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, I ran mypy on the mypy source code itself. My initial run took
    23 seconds. Subsequent typechecks on my system took between 16 and 18 seconds.
    This is *technically* faster, but I would not consider it fast. When I use the
    mypy daemon, though, my subsequent runs ended up being under half a second. With
    times like that, I can run my typechecker much more often to get feedback faster.
    Check out more about dmypy in the [mypy daemon mode documentation](https://oreil.ly/6Coxe).
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Typecheckers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mypy is highly configurable, and its wealth of options will let you decide
    on the exact behavior you are looking for, but it won’t meet all of your needs
    all of the time. It isn’t the only typechecker out there. I’d like to introduce
    two other typecheckers: Pyre (written by Facebook) and Pyright (written by Microsoft).'
  prefs: []
  type: TYPE_NORMAL
- en: Pyre
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can install Pyre with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[Pyre](https://pyre-check.org) runs very similarly to mypy’s daemon mode. A
    separate process will run, from which you can ask for typechecking results. To
    typecheck your code, you need to set up Pyre (by running `pyre init`) in your
    project directory, and then run `pyre` to start the daemon. From here, the information
    you receive is pretty similar to mypy. However, there are two features that set
    Pyre apart from other typecheckers: codebase querying and the Python Static Analyzer
    (Pysa) framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Codebase querying
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the `pyre` daemon is running, there are a lot of cool queries you can make
    to inspect your codebase. I’ll use the mypy codebase as an example codebase for
    all of the following queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, I can learn about the attributes of any class in my codebase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](../images/00002.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Pyre query for attributes
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](../images/00005.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A description of the constructor
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](../images/00006.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A list of strings for messages
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](../images/00007.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: An `Optional` string describing a module with blocker
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](../images/00008.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: A flag indicating printing to a screen
  prefs: []
  type: TYPE_NORMAL
- en: Look at all this information I can find out about the attributes in a class!
    I can see their type annotations to understand how the tool sees these attributes.
    This is incredibly handy in exploring classes as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another cool query is the `callees` of any function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](../images/00002.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Calls the length function
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](../images/00005.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Calls the string.*getitem* function (such as `str[0]`)
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](../images/00006.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Calls the `startswith` function on a string
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](../images/00007.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Initializes a list slice (such as `str[3:8]`)
  prefs: []
  type: TYPE_NORMAL
- en: The typechecker needs to store all this information to do its job. It’s a huge
    bonus that you can query the information as well. I could write a whole extra
    book on what you can do with this information, but for now, check out the [Pyre
    query documentation](https://oreil.ly/X4h0h). You will learn about different queries
    you can execute, such as observing class hierarchies, call graphs, and more. These
    queries allow you to learn more about your codebase or to build new tools to better
    understand your codebase (and catch other types of errors that a typechecker can’t,
    such as temporal dependencies, which I’ll cover in [Part III](part0019.html#part_3)).
  prefs: []
  type: TYPE_NORMAL
- en: Python Static Analyzer (Pysa)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Pysa* (pronounced like the Leaning Tower of Pisa) is a static code analyzer
    built into Pyre. Pysa specializes in a type of security static analysis known
    as *taint analysis*. Taint analysis is the tracking of potentially tainted data,
    such as user-supplied input. The tainted data is tracked for the entire life cycle
    of the data; Pyre makes sure that any tainted data cannot propagate to a system
    in an insecure fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me walk you through the process to catch a simple security flaw (modified
    from the [Pyre documentation](https://oreil.ly/l8gK8)). Consider the case where
    a user creates a new recipe in a filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This looks pretty innocuous. A user can enter in `carrots` to create the file
    *~/food_data/carrots.json*. But what if a user enters in `carrots; ls ~;`? If
    this were entered, it would print out the entire home directory (the command becomes
    `touch ~/food_data/carrots; ls ~;.json`). Based on input, a malicious user could
    enter in arbitrary commands on your server (this is known as remote code execution
    [RCE]), which is a huge security risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pysa provides tools to check this. I can specify that anything coming from
    `input()` is potentially tainted data (known as a *taint source*), and anything
    passed to `os.system` should not be tainted (known as a *taint sink*). With this
    information, I need to build a *taint model*, which is a set of rules for detecting
    potential security holes. First, I must specify a *taint.config* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](../images/00002.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Specify an annotation for user-controlled input.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](../images/00005.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Specify an annotation for RCE flaws.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](../images/00006.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Specify a rule that makes any tainted data from `UserControlled` sources an
    error if it ends up in a `RemoteCodeExecution` sink.
  prefs: []
  type: TYPE_NORMAL
- en: 'From there, I must specify a taint model to annotate these sources as tainted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These stubs tell Pysa through type annotations about where your taint sources
    and sinks are in your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to tell Pyre to detect tainted information by modifying the
    `.pyre_configuration` to add in your directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, when I run `pyre analyze` on that code, Pysa flags an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In order to fix this, I either need to make this data flow impossible or run
    tainted data through a *sanitizer* function. Sanitizer functions take untrusted
    data and inspect/modify it so that it can be trusted. Pysa allows you decorate
    functions with `@sanitize` to specify your sanitizers.^([3](part0009_split_008.html#idm45644746190568))
  prefs: []
  type: TYPE_NORMAL
- en: This was admittedly a simple example, but Pysa allows you to annotate your codebase
    to catch more complicated problems (such as SQL injection and cookie mismanagement).
    To learn everything that Pysa can do (including built-in common security flaw
    checking), check out the [complete documentation](https://oreil.ly/lw7BP).
  prefs: []
  type: TYPE_NORMAL
- en: Pyright
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Pyright](https://oreil.ly/VhZBj) is a typechecker designed by Microsoft. I
    have found it to be the most configurable of the typecheckers I’ve come across.
    If you would like more control than your current typechecker, explore the [Pyright
    configuration documentation](https://oreil.ly/nwkne) for all that you can do.
    However, Pyright has an additional awesome feature: VS Code integration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'VS Code (also built by Microsoft) is an immensely popular code editor for developers.
    Microsoft leveraged the ownership of both tools to create a VS Code extension
    called [Pylance](https://oreil.ly/Y6WAC). You can install Pylance from your VS
    Code extensions browser. Pylance is built upon Pyright and uses type annotations
    to provide a better code-editing experience. Before, I mentioned that autocomplete
    was a benefit of type annotations in IDEs, but Pylance takes it to the next level.
    Pylance offers the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic insertion of imports based on your types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tooltips with full type annotations based on signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Codebase browsing such as finding references or browsing a call graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time diagnostic checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s this last feature that sells Pylance/Pyright for me. Pylance has a setting
    that allows you to constantly run diagnostics in your whole workspace. This means
    that every time you edit a file, `pyright` will run across your entire workspace
    (and it runs fast, too) to look for additional areas that you broke. You don’t
    need to manually run any commands; it happens automatically. As someone who likes
    to refactor often, I find this tool invaluable for finding breakages early. Remember,
    you want to find your errors in as close to real time as possible.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve pulled up the mypy source codebase again and have Pylance enabled and in
    workplace diagnostics mode. I want to change one type on line 19 from a `sequence`
    to a `tuple` and see how Pylance handles the change. The code snippet I’m changing
    is shown in [Figure 6-2](part0009_split_007.html#VS_code_before_editing).
  prefs: []
  type: TYPE_NORMAL
- en: '![Problems in VS Code before editing](../images/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Problems in VS Code before editing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice at the bottom where my “Problems” are listed. The current view is showing
    issues in another file that imports and uses the current function I’m editing.
    Once I change the `paths` parameter from `sequence` to a `tuple`, see how the
    “Problems” change in [Figure 6-3](part0009_split_007.html#VS_code_after_editing).
  prefs: []
  type: TYPE_NORMAL
- en: Within half a second of saving my file, new errors have shown up in my “Problems”
    pane, telling me that I’ve just broken assumptions in calling code. I don’t have
    to wait to run a typechecker manually, or wait for a continuous integration (CI)
    process to yell at me; my errors show up right in my editor. If that doesn’t lead
    me to finding errors earlier, I don’t know what will.
  prefs: []
  type: TYPE_NORMAL
- en: '![Problems in VS Code after editing](../images/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. Problems in VS Code after editing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python typecheckers put a wealth of options at your disposal, and you need to
    be comfortable with advanced configuration to get the most out of your tooling.
    You can control severity options and reporting, or even use different typecheckers
    to reap benefits. As you evaluate tools and options, ask yourself how strict you
    want your typecheckers to be. As you increase the scope of errors that can be
    caught, you will increase the amount of time and effort needed to make your codebase
    compliant. However, the more informative you can make your code, the more robust
    it will be in its lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I will talk about how to assess the trade-offs between
    benefits and costs associated with typechecking. You’ll learn how to identify
    important areas to typecheck and use strategies to mitigate your pain.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](part0009_split_000.html#idm45644746850088-marker)) Jukka Lehtosalo. “Our
    Journey to Type Checking 4 Million Lines of Python.” *Dropbox.Tech* (blog). Dropbox,
    September 5, 2019\. [*https://oreil.ly/4BK3k*](https://oreil.ly/4BK3k).
  prefs: []
  type: TYPE_NORMAL
- en: '^([2](part0009_split_000.html#idm45644746847016-marker)) Confucius and Arthur
    Waley. *The Analects of Confucius*. New York, NY: Random House, 1938.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](part0009_split_006.html#idm45644746190568-marker)) You can learn more
    about sanitizers at [*https://oreil.ly/AghGg*](https://oreil.ly/AghGg).
  prefs: []
  type: TYPE_NORMAL
