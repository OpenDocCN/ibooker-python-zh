- en: 17\. Inheritance#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkPython/chap17.html](https://allendowney.github.io/ThinkPython/chap17.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The language feature most often associated with object-oriented programming
    is **inheritance**. Inheritance is the ability to define a new class that is a
    modified version of an existing class. In this chapter I demonstrate inheritance
    using classes that represent playing cards, decks of cards, and poker hands. If
    you don’t play poker, don’t worry – I’ll tell you what you need to know.
  prefs: []
  type: TYPE_NORMAL
- en: 17.1\. Representing cards[#](#representing-cards "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are 52 playing cards in a standard deck – each of them belongs to one
    of four suits and one of thirteen ranks. The suits are Spades, Hearts, Diamonds,
    and Clubs. The ranks are Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, and King.
    Depending on which game you are playing, an Ace can be higher than King or lower
    than 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to define a new object to represent a playing card, it is obvious
    what the attributes should be: `rank` and `suit`. It is less obvious what type
    the attributes should be. One possibility is to use strings like `''Spade''` for
    suits and `''Queen''` for ranks. A problem with this implementation is that it
    would not be easy to compare cards to see which had a higher rank or suit.'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to use integers to **encode** the ranks and suits. In this
    context, “encode” means that we are going to define a mapping between numbers
    and suits, or between numbers and ranks. This kind of encoding is not meant to
    be a secret (that would be “encryption”).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this table shows the suits and the corresponding integer codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Suit | Code |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Spades | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Hearts | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Diamonds | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Clubs | 0 |'
  prefs: []
  type: TYPE_TB
- en: With this encoding, we can compare suits by comparing their codes.
  prefs: []
  type: TYPE_NORMAL
- en: To encode the ranks, we’ll use the integer `2` to represent the rank `2`, `3`
    to represent `3`, and so on up to `10`. The following table shows the codes for
    the face cards.
  prefs: []
  type: TYPE_NORMAL
- en: '| Rank | Code |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Jack | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| Queen | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| King | 13 |'
  prefs: []
  type: TYPE_TB
- en: And we can use either `1` or `14` to represent an Ace, depending on whether
    we want it to be considered lower or higher than the other ranks.
  prefs: []
  type: TYPE_NORMAL
- en: To represent these encodings, we will use two lists of strings, one with the
    names of the suits and the other with the names of the ranks.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a definition for a class that represents a playing card, with these lists
    of strings as **class variables**, which are variables defined inside a class
    definition, but not inside a method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first element of `rank_names` is `None` because there is no card with rank
    zero. By including `None` as a place-keeper, we get a list with the nice property
    that the index `2` maps to the string `'2'`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Class variables are associated with the class, rather than an instance of the
    class, so we can access them like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can use `suit_names` to look up a suit and get the corresponding string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And `rank_names` to look up a rank.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 17.2\. Card attributes[#](#card-attributes "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s an `__init__` method for the `Card` class – it takes `suit` and `rank`
    as parameters and assigns them to attributes with the same names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we can create a `Card` object like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can use the new instance to access the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is also legal to use the instance to access the class variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: But if you use the class, it is clearer that they are class variables, not attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 17.3\. Printing cards[#](#printing-cards "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s a `__str__` method for `Card` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When we print a `Card`, Python calls the `__str__` method to get a human-readable
    representation of the card.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The following is a diagram of the `Card` class object and the Card instance.
    `Card` is a class object, so its type is `type`. `queen` is an instance of `Card`,
    so its type is `Card`. To save space, I didn’t draw the contents of `suit_names`
    and `rank_names`.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/5f1d5a265aab792dbe104aaedafa1a65dded15806c5dff8a8854f2f3896703eb.png](../Images/cf84277cd6a15970041c403cff3b289f.png)'
  prefs: []
  type: TYPE_IMG
- en: Every `Card` instance has its own `suit` and `rank` attributes, but there is
    only one `Card` class object, and only one copy of the class variables `suit_names`
    and `rank_names`.
  prefs: []
  type: TYPE_NORMAL
- en: 17.4\. Comparing cards[#](#comparing-cards "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we create a second `Card` object with the same suit and rank.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If we use the `==` operator to compare them, it checks whether `queen` and `queen2`
    refer to the same object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: They don’t, so it returns `False`. We can change this behavior by defining the
    special method `__eq__`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`__eq__` takes two `Card` objects as parameters and returns `True` if they
    have the same suit and rank, even if they are not the same object. In other words,
    it checks whether they are equivalent, even if they are not identical.'
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `==` operator with `Card` objects, Python calls the `__eq__`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As a second test, let’s create a card with the same suit and a different rank.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can confirm that `queen` and `six` are not equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If we use the `!=` operator, Python invokes a special method called `__ne__`,
    if it exists. Otherwise it invokes`__eq__` and inverts the result – so if `__eq__`
    returns `True`, the result of the `!=` operator is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now suppose we want to compare two cards to see which is bigger. If we use one
    of the relational operators, we get a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To change the behavior of the `<` operator, we can define a special method called
    `__lt__`, which is short for “less than”. For the sake of this example, let’s
    assume that suit is more important than rank – so all Spades outrank all Hearts,
    which outrank all Diamonds, and so on. If two cards have the same suit, the one
    with the higher rank wins.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this logic, we’ll use the following method, which returns a tuple
    containing a card’s suit and rank, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We can use this method to write `__lt__`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Tuple comparison compares the first elements from each tuple, which represent
    the suits. If they are the same, it compares the second elements, which represent
    the ranks.
  prefs: []
  type: TYPE_NORMAL
- en: Now if we use the `<` operator, it invokes the `__lt__` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If we use the `>` operator, it invokes a special method called `__gt__`, if
    it exists. Otherwise it invokes `__lt__` with the arguments in the opposite order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if we use the `<=` operator, it invokes a special method called `__le__`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So we can check whether one card is less than or equal to another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If we use the `>=` operator, it uses `__ge__` if it exists. Otherwise, it invokes
    `__le__` with the arguments in the opposite order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As we have defined them, these methods are complete in the sense that we can
    compare any two `Card` objects, and consistent in the sense that results from
    different operators don’t contradict each other. With these two properties, we
    can say that `Card` objects are **totally ordered**. And that means, as we’ll
    see soon, that they can be sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 17.5\. Decks[#](#decks "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have objects that represent cards, let’s define objects that represent
    decks. The following is a class definition for `Deck` with an `__init__` method
    takes a list of `Card` objects as a parameter and assigns it to an attribute called
    `cards`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: To create a list that contains the 52 cards in a standard deck, we’ll use the
    following static method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In `make_cards`, the outer loop enumerates the suits from `0` to `3`. The inner
    loop enumerates the ranks from `2` to `14` – where `14` represents an Ace that
    outranks a King. Each iteration creates a new `Card` with the current suit and
    rank, and appends it to `cards`.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how we make a list of cards and a `Deck` object that contains it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: It contains 52 cards, as intended.
  prefs: []
  type: TYPE_NORMAL
- en: '## 17.6\. Printing the deck[#](#printing-the-deck "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Here is a `__str__` method for `Deck`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This method demonstrates an efficient way to accumulate a large string – building
    a list of strings and then using the string method `join`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll test this method with a deck that only contains two cards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If we call `str`, it invokes `__str__`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: When Jupyter displays a string, it shows the “representational” form of the
    string, which represents a newline with the sequence `\n`.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we print the result, Jupyter shows the “printable” form of the string,
    which prints the newline as whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: So the cards appear on separate lines.
  prefs: []
  type: TYPE_NORMAL
- en: 17.7\. Add, remove, shuffle and sort[#](#add-remove-shuffle-and-sort "Link to
    this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To deal cards, we would like a method that removes a card from the deck and
    returns it. The list method `pop` provides a convenient way to do that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here’s how we use it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We can confirm that there are `51` cards left in the deck.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: To add a card, we can use the list method `append`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As an example, we can put back the card we just popped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To shuffle the deck, we can use the `shuffle` function from the `random` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: If we shuffle the deck and print the first few cards, we can see that they are
    in no apparent order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: To sort the cards, we can use the list method `sort`, which sorts the elements
    “in place” – that is, it modifies the list rather than creating a new list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: When we invoke `sort`, it uses the `__lt__` method to compare cards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: If we print the first few cards, we can confirm that they are in increasing
    order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `Deck.sort` doesn’t do anything other than invoke `list.sort`.
    Passing along responsibility like this is called **delegation**.
  prefs: []
  type: TYPE_NORMAL
- en: 17.8\. Parents and children[#](#parents-and-children "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inheritance is the ability to define a new class that is a modified version
    of an existing class. As an example, let’s say we want a class to represent a
    “hand”, that is, the cards held by one player.
  prefs: []
  type: TYPE_NORMAL
- en: A hand is similar to a deck – both are made up of a collection of cards, and
    both require operations like adding and removing cards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hand is also different from a deck – there are operations we want for hands
    that don’t make sense for a deck. For example, in poker we might compare two hands
    to see which one wins. In bridge, we might compute a score for a hand in order
    to make a bid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This relationship between classes – where one is a specialized version of another
    – lends itself to inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: To define a new class that is based on an existing class, we put the name of
    the existing class in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This definition indicates that `Hand` inherits from `Deck`, which means that
    `Hand` objects can access methods defined in `Deck`, like `take_card` and `put_card`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Hand` also inherits `__init__` from `Deck`, but if we define `__init__` in
    the `Hand` class, it overrides the one in the `Deck` class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This version of `__init__` takes an optional string as a parameter, and always
    starts with an empty list of cards. When we create a `Hand`, Python invokes this
    method, not the one in `Deck` – which we can confirm by checking that the result
    has a `label` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: To deal a card, we can use `take_card` to remove a card from a `Deck`, and `put_card`
    to add the card to a `Hand`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Let’s encapsulate this code in a `Deck` method called `move_cards`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is polymorphic – that is, it works with more than one type: `self`
    and `other` can be either a `Hand` or a `Deck`. So we can use this method to deal
    a card from `Deck` to a `Hand`, from one `Hand` to another, or from a `Hand` back
    to a `Deck`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new class inherits from an existing one, the existing one is called
    the **parent** and the new class is called the **child**. In general:'
  prefs: []
  type: TYPE_NORMAL
- en: Instances of the child class should have all of the attributes of the parent
    class, but they can have additional attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The child class should have all of the methods of the parent class, but it can
    have additional methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a child class overrides a method from the parent class, the new method should
    take the same parameters and return a compatible result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This set of rules is called the “Liskov substitution principle” after computer
    scientist Barbara Liskov.
  prefs: []
  type: TYPE_NORMAL
- en: If you follow these rules, any function or method designed to work with an instance
    of a parent class, like a `Deck`, will also work with instances of a child class,
    like `Hand`. If you violate these rules, your code will collapse like a house
    of cards (sorry).
  prefs: []
  type: TYPE_NORMAL
- en: 17.9\. Specialization[#](#specialization "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s make a class called `BridgeHand` that represents a hand in bridge – a
    widely played card game. We’ll inherit from `Hand` and add a new method called
    `high_card_point_count` that evaluates a hand using a “high card point” method,
    which adds up points for the high cards in the hand.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a class definition that contains as a class variable a dictionary that
    maps from card names to their point values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Given the rank of a card, like `12`, we can use `Card.rank_names` to get the
    string representation of the rank, and then use `hcp_dict` to get its score.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The following method loops through the cards in a `BridgeHand` and adds up their
    scores.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: To test it, we’ll deal a hand with five cards – a bridge hand usually has thirteen,
    but it’s easier to test code with small examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: And here is the total score for the King and Queen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '`BridgeHand` inherits the variables and methods of `Hand` and adds a class
    variable and a method that are specific to bridge. This way of using inheritance
    is called **specialization** because it defines a new class that is specialized
    for a particular use, like playing bridge.'
  prefs: []
  type: TYPE_NORMAL
- en: 17.10\. Debugging[#](#debugging "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inheritance is a useful feature. Some programs that would be repetitive without
    inheritance can be written more concisely with it. Also, inheritance can facilitate
    code reuse, since you can customize the behavior of a parent class without having
    to modify it. In some cases, the inheritance structure reflects the natural structure
    of the problem, which makes the design easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, inheritance can make programs difficult to read. When a method
    is invoked, it is sometimes not clear where to find its definition – the relevant
    code may be spread across several modules.
  prefs: []
  type: TYPE_NORMAL
- en: Any time you are unsure about the flow of execution through your program, the
    simplest solution is to add print statements at the beginning of the relevant
    methods. If `Deck.shuffle` prints a message that says something like `Running
    Deck.shuffle`, then as the program runs it traces the flow of execution.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative, you could use the following function, which takes an object
    and a method name (as a string) and returns the class that provides the definition
    of the method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '`find_defining_class` uses the `mro` method to get the list of class objects
    (types) that will be searched for methods. “MRO” stands for “method resolution
    order”, which is the sequence of classes Python searches to “resolve” a method
    name – that is, to find the function object the name refers to.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s instantiate a `BridgeHand` and then find the defining class
    of `shuffle`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The `shuffle` method for the `BridgeHand` object is the one in `Deck`.
  prefs: []
  type: TYPE_NORMAL
- en: 17.11\. Glossary[#](#glossary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**inheritance:** The ability to define a new class that is a modified version
    of a previously defined class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**encode:** To represent one set of values using another set of values by constructing
    a mapping between them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**class variable:** A variable defined inside a class definition, but not inside
    any method.'
  prefs: []
  type: TYPE_NORMAL
- en: '**totally ordered:** A set of objects is totally ordered if we can compare
    any two elements and the results are consistent.'
  prefs: []
  type: TYPE_NORMAL
- en: '**delegation:** When one method passes responsibility to another method to
    do most or all of the work.'
  prefs: []
  type: TYPE_NORMAL
- en: '**parent class:** A class that is inherited from.'
  prefs: []
  type: TYPE_NORMAL
- en: '**child class:** A class that inherits from another class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**specialization:** A way of using inheritance to create a new class that is
    a specialized version of an existing class.'
  prefs: []
  type: TYPE_NORMAL
- en: 17.12\. Exercises[#](#exercises "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 17.12.1\. Ask a Virtual Assistant[#](#ask-a-virtual-assistant "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it goes well, object-oriented programming can make programs more readable,
    testable, and reusable. But it can also make programs complicated and hard to
    maintain. As a result, OOP is a topic of controversy – some people love it, and
    some people don’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the topic, ask a virtual assistant:'
  prefs: []
  type: TYPE_NORMAL
- en: What are some pros and cons of object-oriented programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does it mean when people say “favor composition over inheritance”?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the Liskov substitution principle?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is Python an object-oriented language?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the requirements for a set to be totally ordered?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And as always, consider using a virtual assistant to help with the following
    exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 17.12.2\. Exercise[#](#exercise "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In contract bridge, a “trick” is a round of play in which each of four players
    plays one card. To represent those cards, we’ll define a class that inherits from
    `Deck`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: As an example, consider this trick, where the first player leads with the 3
    of Diamonds, which means that Diamonds are the “led suit”. The second and third
    players “follow suit”, which means they play a card with the led suit. The fourth
    player plays a card of a different suit, which means they cannot win the trick.
    So the winner of this trick is the third player, because they played the highest
    card in the led suit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Write a `Trick` method called `find_winner` that loops through the cards in
    the `Trick` and returns the index of the card that wins. In the previous example,
    the index of the winning card is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 17.12.3\. Exercise[#](#id1 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next few exercises ask to you write functions that classify poker hands.
    If you are not familiar with poker, I’ll explain what you need to know. We’ll
    use the following class to represent poker hands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '`PokerHand` provides two methods that will help with the exercises.'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_suit_counts` loops through the cards in the `PokerHand`, counts the number
    of cards in each suit, and returns a dictionary that maps from each suit code
    to the number of times it appears.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_rank_counts` does the same thing with the ranks of the cards, returning
    a dictionary that maps from each rank code to the number of times it appears.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the exercises that follow can be done using only the Python features
    we have learned so far, but some of them are more difficult than most of the previous
    exercises. I encourage you to ask a virtual assistant for help.
  prefs: []
  type: TYPE_NORMAL
- en: For problems like this, it often works well to ask for general advice about
    strategies and algorithms. Then you can either write the code yourself or ask
    for code. If you ask for code, you might want to provide the relevant class definitions
    as part of the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: As a first exercise, we’ll write a method called `has_flush` that checks whether
    a hand has a “flush” – that is, whether it contains at least five cards of the
    same suit.
  prefs: []
  type: TYPE_NORMAL
- en: In most varieties of poker, a hand contains either five or seven cards, but
    there are some exotic variations where a hand contains other numbers of cards.
    But regardless of how many cards there are in a hand, the only ones that count
    are the five that make the best hand.
  prefs: []
  type: TYPE_NORMAL
- en: 17.12.4\. Exercise[#](#id2 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a method called `has_straight` that checks whether a hand contains a straight,
    which is a set of five cards with consecutive ranks. For example, if a hand contains
    ranks `5`, `6`, `7`, `8`, and `9`, it contains a straight.
  prefs: []
  type: TYPE_NORMAL
- en: An Ace can come before a two or after a King, so `Ace`, `2`, `3`, `4`, `5` is
    a straight and so is `10`, `Jack`, `Queen`, `King`, `Ace`. But a straight cannot
    “wrap around”, so `King`, `Ace`, `2`, `3`, `4` is not a straight.
  prefs: []
  type: TYPE_NORMAL
- en: 17.12.5\. Exercise[#](#id3 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A hand has a straight flush if it contains a set of five cards that are both
    a straight and a flush – that is, five cards of the same suit with consecutive
    ranks. Write a `PokerHand` method that checks whether a hand has a straight flush.
  prefs: []
  type: TYPE_NORMAL
- en: 17.12.6\. Exercise[#](#id4 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A poker hand has a pair if it contains two or more cards with the same rank.
    Write a `PokerHand` method that checks whether a hand contains a pair.
  prefs: []
  type: TYPE_NORMAL
- en: To test your method, here’s a hand that has a pair.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 17.12.7\. Exercise[#](#id5 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A hand has a full house if it contains three cards of one rank and two cards
    of another rank. Write a `PokerHand` method that checks whether a hand has a full
    house.
  prefs: []
  type: TYPE_NORMAL
- en: 17.12.8\. Exercise[#](#id6 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This exercise is a cautionary tale about a common error that can be difficult
    to debug. Consider the following class definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '`__init__` takes two parameters: `name` is required, but `contents` is optional
    – if it’s not provided, the default value is an empty list.'
  prefs: []
  type: TYPE_NORMAL
- en: '`__str__` returns a string representation of the object that includes the name
    and the contents of the pouch.'
  prefs: []
  type: TYPE_NORMAL
- en: '`put_in_pouch` takes any object and appends it to `contents`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how this class works. We’ll create two `Kangaroo` objects with
    the names `'Kanga'` and `'Roo'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: To Kanga’s pouch we’ll add two strings and Roo.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: If we print `kanga`, it seems like everything worked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: But what happens if we print `roo`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Roo’s pouch contains the same contents as Kanga’s, including a reference to
    `roo`!
  prefs: []
  type: TYPE_NORMAL
- en: See if you can figure out what went wrong. Then ask a virtual assistant, “What’s
    wrong with the following program?” and paste in the definition of `Kangaroo`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
