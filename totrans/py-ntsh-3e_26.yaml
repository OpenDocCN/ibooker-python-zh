- en: Chapter 26\. v3.7 to v3.n Migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This book spans several versions of Python and covers some substantial (and
    still evolving!) new features, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Order-preserving dicts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: := assignment expressions (informally called “the walrus operator”)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individual developers may be able to install each new Python version as it is
    released, and solve compatibility issues as they go. But for Python developers
    working in a corporate environment or maintaining a shared library, migrating
    from one version to the next involves deliberation and planning.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter deals with the changing shape of the Python language, as seen
    from a Python programmer’s viewpoint. (There have been many changes in Python
    internals as well, including to the Python C API, but those are beyond the scope
    of this chapter: for details, see the “What’s New in Python 3.*n*” sections of
    each release’s online documentation.)'
  prefs: []
  type: TYPE_NORMAL
- en: Significant Changes in Python Through 3.11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most releases have a handful of significant new features and improvements that
    characterize that release, and it is useful to have these in mind as high-level
    reasons for targeting a particular release. [Table 26-1](#significant_changes_in_recent_python_re)
    details only major new features and breaking changes in versions 3.6–3.11^([1](ch26.xhtml#ch01fn164))
    that are likely to affect many Python programs; see the [Appendix](app01.xhtml#new_features_and_changes_in)
    for a more complete list.
  prefs: []
  type: TYPE_NORMAL
- en: Table 26-1\. Significant changes in recent Python releases
  prefs: []
  type: TYPE_NORMAL
- en: '| Version | New features | Breaking changes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 3.6 |'
  prefs: []
  type: TYPE_TB
- en: dicts preserve order (as an implementation detail of CPython)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F-strings added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _ in numeric literals supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotations can be used for types, which can be checked with external tools
    such as mypy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: asyncio is no longer a provisional module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Initial release: December 2016*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*End of support: December 2021*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Unknown escapes of \ and an ASCII letter no longer supported in pattern arguments
    to most re functions (still permitted in re.sub() only)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 3.7 |'
  prefs: []
  type: TYPE_TB
- en: dicts preserve order (as a formal language guarantee)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dataclasses module added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: breakpoint() function added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Initial release: June 2018*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Planned end of support: June 2023*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Unknown escapes of \ and an ASCII letter no longer supported in pattern arguments
    to re.sub()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named arguments no longer supported in bool(), float(), list(), and tuple()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leading named argument in int() no longer supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 3.8 |'
  prefs: []
  type: TYPE_TB
- en: Assignment expressions (:= , aka the walrus operator) added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: / and * in function argument lists to indicate positional-only and named-only
    arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trailing = for debugging in f-strings (f'{x=}' short form for f'x={x!r}')
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typing classes added (Literal, TypedDict, Final, Protocol)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Initial release: October 2019*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Planned end of support: October 2024*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: time.clock() removed; use time.perf_counter()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pyvenv script removed; use **python -m venv**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**yield** and **yield from** no longer allowed in comprehensions or genexps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SyntaxWarnings on **is** and **is not** tests against str and int literals added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 3.9 |'
  prefs: []
  type: TYPE_TB
- en: Union operators &#124; and &#124;= on dicts supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: str.removeprefix() and str.removesuffix() methods added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: zoneinfo module added for IANA time zone support (to replace third-party pytz
    module)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type hints can now use built-in types in generics (list[int] instead of List[int])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Initial release: October 2020*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Planned end of support: October 2025*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: array.array.tostring() and fromstring() removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: threading.Thread.isAlive() removed (use is_alive() instead)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ElementTree and Element’s getchildren() and getiterator() removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: base64.encodestring() and decodestring() removed (use encodebytes() and decodebytes()
    instead)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fractions.gcd() removed (use math.gcd() instead)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: typing.NamedTuple._fields removed (use __annotations__ instead)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 3.10 |'
  prefs: []
  type: TYPE_TB
- en: '**match**/**case** structural pattern matching supported'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing union types as X &#124; Y (in type annotations and as second argument
    to isinstance()) allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional strict argument added to zip() built-in to detect sequences of differing
    lengths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parenthesized context managers now officially supported; e.g., **with**(*ctxmgr*,
    *ctxmgr*, ...):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Initial release: October 2021*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Planned end of support: October 2026*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Importing ABCs from collections removed (must now import from collections.abc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: loop parameter removed from most of asyncio’s high-level API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 3.11 |'
  prefs: []
  type: TYPE_TB
- en: Improved error messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General performance boost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception groups and except* added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typing classes added (Never, Self)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tomllib TOML parser added to stdlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Initial release: October 2022*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Planned end of support: October 2027 (est.)*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: binhex module removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: int to str conversion restricted to 4,300 digits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Planning a Python Version Upgrade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why upgrade in the first place? If you have a stable, running application,
    and a stable deployment environment, a reasonable decision might be to leave it
    alone. But version upgrades do come with benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: New versions usually introduce new features, which may allow you to simplify
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updated versions include bug fixes and refactorings, which can improve system
    stability and performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security vulnerabilities identified in an older version may be fixed in a new
    version.^([2](ch26.xhtml#ch01fn165))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eventually, old Python versions fall out of support, and projects running on
    older versions become difficult to staff and more costly to maintain. Upgrading
    might then become a necessity.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a Target Version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before deciding which version to migrate to, sometimes you have to figure out
    first, “What version am I running now?” You may be unpleasantly surprised to find
    old software running unsupported Python versions lurking in your company’s systems.
    Often this happens when those systems depend on some third-party package that
    is itself behind in version upgrades, or does not have an upgrade available. The
    situation is even more dire when such a system is critical in some way for company
    operations. You may be able to isolate the lagging package behind a remote-access
    API, allowing that package to run on the old version while permitting your own
    code to safely upgrade. The presence of systems with these upgrade constraints
    must be made visible to senior management, so they can be advised of the risks
    and trade-offs of retaining, upgrading, isolating, or replacing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The choice of target version often defaults to “whatever version is the most
    current.” This is a reasonable choice, as it is usually the most cost-effective
    option with respect to the investment involved in doing the upgrade: the most
    recent release will have the longest support period moving forward. A more conservative
    position might be “whatever version is the most current, minus 1.” You can be
    reasonably sure that version *N*–1 has undergone some period of in-production
    testing at other companies, and someone else has shaken out most of the bugs.'
  prefs: []
  type: TYPE_NORMAL
- en: Scoping the Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After you have selected your target version of Python, identify all the breaking
    changes in the versions after the version your software is currently using, up
    to and including the target version (see the [Appendix](app01.xhtml#new_features_and_changes_in)
    for a detailed table of features and breaking changes by version; additional details
    can be found in the “What’s New in Python 3.*n*” sections of the [online docs](https://oreil.ly/pvEtK)).
    Breaking changes are usually documented with a compatible form that will work
    with both your current version and the target version. Document and communicate
    the source changes that development teams will need to make before upgrading.
    (There may be significantly more work than expected involved in moving directly
    to the selected target version, if a lot of your code is affected by breaking
    changes or compatibility issues with related software. You may even end up revisiting
    the choice of target version or considering smaller steps. Perhaps you’ll decide
    on upgrading to *target*–1 as a first step and deferring the task of the upgrade
    to *target* or *target*+1 for a subsequent upgrade project.)
  prefs: []
  type: TYPE_NORMAL
- en: Identify any third-party or open source libraries that your codebase uses, and
    ensure that they are compatible with (or have plans to be compatible with) the
    target Python version. Even if your own codebase is ready for upgrading to the
    target, an external library that lags behind may hold up your upgrade project.
    If necessary, you may be able to isolate such a library in a separate runtime
    environment (using virtual machines or container technologies), if that library
    offers a remote access programming interface.
  prefs: []
  type: TYPE_NORMAL
- en: Make the target Python version available in development environments, and optionally
    in deployment environments, so that developers can confirm that their upgrade
    changes are complete and correct.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Code Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have decided on your target version and identified all the breaking
    changes, you’ll need to make changes in your codebase to make it compatible with
    the target version. Your goal, ideally, is to have the code in a form that is
    compatible with both the current *and* target Python versions.
  prefs: []
  type: TYPE_NORMAL
- en: Imports from __future__
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: __future__ is a standard library module containing a variety of features, documented
    in the [online docs](https://oreil.ly/3NaU5), to ease migration between versions.
    It is unlike any other module, because importing features can affect the syntax,
    not just the semantics, of your program. Such imports *must* be the initial executable
    statements of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each “future feature” is activated using the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: where *feature* is the name of the feature you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the span of versions this book covers, the only future feature you might
    consider using is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: which permits references to as-yet-undefined types without enclosing them in
    quotes (as covered in [Chapter 5](ch05.xhtml#type_annotations)). If your current
    version is Python 3.7 or later, then adding this __future__ import will permit
    use of the unquoted types in type annotations, so you don’t have to redo them
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by reviewing libraries that are shared across multiple projects. Removing
    the blocking changes from these libraries will be a crucial first step, since
    you will be unable to deploy any dependent applications on the target version
    until this is done. Once a library is compatible with both versions, it can be
    deployed for use in the migration project. Moving forward, the library code must
    maintain compatibility with both the current Python version and the target version:
    shared libraries will likely be the *last* projects that will be able to utilize
    any new features of the target version.'
  prefs: []
  type: TYPE_NORMAL
- en: Standalone applications will have earlier opportunities to use the new features
    in the target version. Once the application has removed all code affected by breaking
    changes, commit it to your source control system as a cross-version-compatible
    snapshot. Afterwards, you may add new features to the application code and deploy
    it into environments that support the target version.
  prefs: []
  type: TYPE_NORMAL
- en: If version compatibility changes affect type annotations, you can use *.pyi*
    stub files to isolate version-dependent typing from your source code.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrade Automation Using pyupgrade
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be able to automate much of the toil in upgrading your code using automation
    tools such as the [pyupgrade package](https://oreil.ly/01AKX). pyupgrade analyzes
    the abstract syntax tree (AST) returned by Python’s ast.parse function to locate
    issues and make corrections to your source code. You can select a specific target
    Python version using command-line switches.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you use automatic code conversion, review the output of the conversion
    process. A dynamic language like Python makes it impossible to perform a perfect
    translation; while testing helps, it can’t pick up all imperfections.
  prefs: []
  type: TYPE_NORMAL
- en: Multiversion Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that your tests cover as much of your project as possible, so that
    inter-version errors are likely to be picked up during testing. Aim for at least
    80% testing coverage; much more than 90% can be difficult to achieve, so don’t
    spend too much effort trying to reach a too-ambitious standard. (*Mocks*, mentioned
    in [“Unit Testing and System Testing”](ch17.xhtml#unit_testing_and_system_testing),
    can help you increase the breadth of your unit testing coverage, if not the depth.)
  prefs: []
  type: TYPE_NORMAL
- en: The [tox package](https://tox.readthedocs.io) is useful to help you manage and
    test multiversion code. It lets you test your code under a number of different
    virtual environments, and it supports multiple CPython versions, as well as PyPy.
  prefs: []
  type: TYPE_NORMAL
- en: Use a Controlled Deployment Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make the target Python version available in deployment environments, with an
    application environment setting to indicate whether an application should run
    using the current or target Python version. Continuously track, and periodically
    report, the completion percentage to your management team.
  prefs: []
  type: TYPE_NORMAL
- en: How Often Should You Upgrade?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PSF releases Python on a minor-release-per-year cadence, with each version
    enjoying five years of support after release. If you apply a latest-release-minus-1
    strategy, it provides you with a stable, proven version to migrate to, with a
    four-year support horizon (in case a future upgrade needs to be deferred). Given
    the four-year time window, doing upgrades to the latest release minus 1 every
    year or two should provide a reasonable balance of periodic upgrade cost and platform
    stability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining the version currency of the software that your organization’s systems
    depend on is an ongoing habit of proper “software hygiene,” in Python just like
    in any other development stack. By performing regular upgrades of just one or
    two versions at a time, you can keep this work at a steady and manageable level,
    and it will become a recognized and valued activity in your organization.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch26.xhtml#ch01fn164-marker)) While Python 3.6 is outside the range of
    versions covered in this book, it introduced some significant new features, and
    we include it here for historical context.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch26.xhtml#ch01fn165-marker)) When this happens, it is usually an “all
    hands on deck” emergency situation to do the upgrade in a hurry. These events
    are the very ones you are trying to avoid, or at least minimize, by implementing
    a steady and ongoing Python version upgrade program.
  prefs: []
  type: TYPE_NORMAL
