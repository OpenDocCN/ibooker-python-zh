- en: 'Chapter 10\. User-Defined Types: Classes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes will be the final user-defined type that I’ll cover in this book. Many
    developers learn classes early, and this is both a boon and a bane. Classes are
    used in many frameworks and codebases, so it pays off to be fluent in class design.
    However, when developers learn classes too early, they miss the nuance of when
    and, more importantly, when not to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Think back to your use of classes. Could you represent that data as a `dataclass`
    instead? What about a set of free functions? I’ve seen too many codebases that
    use classes everywhere when they really shouldn’t, and maintainability suffers
    because of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I’ve also come across codebases that swing the pendulum the other
    way: using no classes at all. This also affects maintainability; it is easy to
    break assumptions and have inconsistent data throughout. In Python, you should
    strive for a balance. Classes have a place in your codebase, but it is important
    to recognize their strengths and weaknesses. It’s time to really dig deep, cast
    aside your preconceptions, and learn how classes help you make more robust code.'
  prefs: []
  type: TYPE_NORMAL
- en: Class Anatomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes are intended to be another way of grouping related data together. They
    have decades of history in the object-oriented paradigm and, at first glance,
    don’t differ that much from what you learned about data classes. In fact, you
    can write a class just like you wrote a `dataclass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the code above, you could easily write it a different way with a
    `dict` or `dataclass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 9](part0013_split_000.html#dataclasses), you learned the advantages
    of data classes over raw dictionaries, and classes offer many of the same benefits.
    But you might (rightly) wonder why you would ever use a class instead of a data
    class again?
  prefs: []
  type: TYPE_NORMAL
- en: In fact, given the flexibility and convenvenience of data classes, classes might
    feel inferior. You don’t get the fancy features like `frozen` or `ordered`. You
    don’t get built-in string methods. Why, you can’t even instantiate a `Person`
    as nicely as with data classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to do something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When trying this with a class, you’ll be immediately greeted with an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That’s really frustrating, at first glance. However, this design decision is
    intentional. You need to explicitly define how a class gets constructed, which
    is done through a special method called a *constructor*. It may seem like a drawback
    compared to data classes, but it allows you to have more fine-grained control
    over the fields in your class. The next few sections will describe how you can
    use this control to your benefit. First, let’s look at what the constructor of
    a class actually provides you.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A constructor describes how to initialize your class. You define a constructor
    with an `__init__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I tweaked the class a bit. Instead of defining the variables like
    I did in a `dataclass`, I am defining all the variables in a constructor. The
    constructor is a special method that gets called when class is instantiated. It
    takes arguments needed to define your user data type, as well as a special argument
    called `self`. The specific name for this parameter is arbitrary, but you’ll see
    most code use `self` as the convention. Each time you instantiate a class, the
    `self` argument refers to that specific instance; one instance’s attributes won’t
    conflict with another instance’s attributes, even though they are the same class.
  prefs: []
  type: TYPE_NORMAL
- en: 'So why would you ever write a class? Dictionaries or data classes are simpler
    to write and involve less ceremony. For something like the `Person` object listed
    earlier, I don’t disagree. However, a class can convey one key thing that a dictionary
    or data class can’t easily convey: *invariants*.'
  prefs: []
  type: TYPE_NORMAL
- en: Invariants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An invariant is a property of an entity that remains unchanged throughout the
    lifetime of that entity. Invariants are the concepts that hold true about your
    code. Readers and writers of code will reason about your code and depend upon
    that reasoning to keep everything straight. Invariants are the building blocks
    for understanding your codebase. Here are some examples of invariants:'
  prefs: []
  type: TYPE_NORMAL
- en: Every employee has a unique ID; no two employee IDs are duplicated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enemies in a game may only take actions if their health points are above zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circles may only have a positive radius.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pizzas will always have cheese on top of sauce.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invariants convey immutable properties of objects. They can reflect mathematical
    properties, business rules, coordination guarantees, or anything else you want
    to hold true. Invariants do not have to mirror the real world; they just have
    to be true for *your* system. For instance, Chicago-style deep-dish pizza aficionados
    may disagree with that last pizza-related bullet, but if your system only handles
    cheese-on-sauce pizzas, it’s OK to encode that as an invariant. The invariant
    only refers to a specific entity, too. You get to decide the scope of the invariant,
    whether it is true across your system, or whether it only applies to a specific
    program, module, or class. This chapter will focus on classes and their role in
    *preserving* invariants.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does a class help convey invariants? Let’s start with the constructor.
    You can put in safeguards and assertions to check that an invariant is satisfied,
    and from that point on, a user of that class should be able to depend on that
    invariant being true for the lifetime of the class. Let’s see how.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an imaginary automated pizza maker that makes a perfect pizza every
    time. It will take dough, roll it into a circle, apply sauce and toppings, and
    then bake the pizza. I will list out some invariants that I want to preserve in
    my system (these invariants are not universally true about all pizzas in the world,
    just true for the pizzas I want to create).
  prefs: []
  type: TYPE_NORMAL
- en: 'I want the following to hold true for the lifetime of the pizza:'
  prefs: []
  type: TYPE_NORMAL
- en: Sauce will never be put on top of toppings (cheese is a topping in this scenario).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toppings may go above or below cheese.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pizza will have at most only one sauce.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dough radius can be only whole numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The radius of dough may be only between 6 and 12 inches, inclusive (between
    15 and 30 centimeters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these might be for business reasons, some might be for health reasons,
    and some might be just limitations of machinery, but every one of these is intended
    to be true for the lifetime of that pizza. I’ll check for these invariants during
    construction of the pizza.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down this invariant checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dough_radius_in_inches` is an integer. This doesn’t stop callers from passing
    floats/strings/whatever into the constructor, but if used in conjunction with
    a typechecker (like those you used in [Part I](part0004.html#part_1)), you can
    detect when callers pass the wrong type. If you aren’t using a typechecker, you
    would have to do an `isinstance()` check (or something similar) instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This code asserts that the dough radius is between 6 and 12 inches (inclusive).
    If this is not the case, an `AssertionError` is thrown (preventing construction
    of the class).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This code asserts that there is at most one sauce, throwing an `AssertionError`
    if that does not hold true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This code ensures that the sauce is at the beginning of our toppings list (presumably
    this will be used to tell the pizza maker in what order to lay toppings down).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that I don’t explicitly do anything to preserve that toppings can be above
    or below cheese. This is because the default behavior of the implementation satisfies
    the invariant. However, you may still choose to communicate the invariant to your
    callers through documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding Broken Invariants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is incredibly important that you never, ever construct this class if the
    invariants would be broken. You have two avenues that you can choose if the caller
    ever constructs an object in a way such that invariants would be broken.
  prefs: []
  type: TYPE_NORMAL
- en: Throw an exception
  prefs: []
  type: TYPE_NORMAL
- en: This prevents the object from being constructed. This is what I did when making
    sure the dough radius was appropriate and that I had at most one sauce.
  prefs: []
  type: TYPE_NORMAL
- en: Massage the data
  prefs: []
  type: TYPE_NORMAL
- en: Make the data conform to the invariant. I could have thrown an exception when
    I didn’t get toppings in the right order, but instead, I rearranged them to satisfy
    the invariant.
  prefs: []
  type: TYPE_NORMAL
- en: Why Are Invariants Beneficial?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is a lot of work to write a class and come up with invariants. But I want
    you to consciously think about invariants every time you group some data together.
    Ask yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: Should any of this data be restricted in any form that I can’t catch through
    the type system (such as the order of toppings)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are some fields interdependent (i.e., changing one field may necessitate a change
    in another field)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there guarantees I want to provide about the data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you answer yes to any of these questions, you have invariants you want to
    preserve and should write a class. When you choose to write a class and define
    a set of invariants, you’re doing a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: You’re adhering to the Don’t Repeat Yourself (DRY) principle.^([1](part0014_split_014.html#idm45644740381352))
    Instead of littering your code with checks before object construction, you put
    those checks in one place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’re putting more work on the writer to ease the work of the reader/maintainer/caller.
    Your code will most likely live longer than you work on it. By providing an invariant
    (and communicating it well—see the next section), you lessen the burden of those
    who come after you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’re more effectively able to reason about code. There’s a reason why languages
    like [Ada](https://www.adacore.com/about-ada) and concepts like formal proofs
    are used in mission-critical environments. They provide developers with comfort;
    other coders can trust your code to a certain degree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of this leads to fewer bugs. You’re not running the risk of people misconstructing
    objects or missing a required check. You’re making an easier API for people to
    think about, and you reduce the risk of people using your objects incorrectly.
    You will also adhere closer to the Law of Least Surprise. You never want someone
    to be surprised when using your code (how many times have you heard the phrase,
    “Wait, *that’s* how the class works?”). By defining invariants and sticking to
    them, there is less chance for someone to be surprised.
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary simply cannot do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a pizza specification represented by a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There is no simple way for you to force a user to construct this dictionary
    correctly. You would have to rely on callers doing the right thing in every invocation
    (which will only become more difficult as the codebase grows). There is also no
    way to prevent users from modifying the dictionary freely and breaking invariants.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s true, you could define methods that construct dictionaries after checking
    invariants, and only mutate the dictionary through functions that also check invariants.
    Or, you could certainly write a constructor and invariant-checking methods on
    data classes. But if you go through all that trouble, why not write a class? Be
    mindful of what your choices communicate to future maintainers. You must be deliberate
    between your choice of dictionaries, data classes and classes. Each of these abstractions
    conveys a very specific meaning, and if you choose the wrong one, you’ll confuse
    maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s another benefit that I haven’t talked about, and it relates to the
    “S” in SOLID (see the next sidebar): the Single Responsibility Principle. The
    Single Responsibility Principle states that each object “should have one and only
    one reason to change.”^([2](part0014_split_014.html#idm45644740365960)) It sounds
    simple, but in practice it can be a struggle to know exactly how granular *one*
    reason to change is. My suggestion to you is to define a set of related invariants
    (such as your dough and toppings) and write a class per set of related invariants.
    If you ever find yourself writing attributes or methods that do not directly relate
    to one of those invariants, your class has low *cohesion*, which means it has
    too many responsibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider some of the most important parts of your codebase. What invariants
    are true about that system? How well are these invariants enforced, such that
    developers cannot break them?
  prefs: []
  type: TYPE_NORMAL
- en: Communicating Invariants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, you can’t realize these benefits unless you can effectively communicate
    them. Nobody can reason about invariants that they don’t know about. So, how do
    you do that? Well, with any communication, you should consider your audience.
    You have two types of people with two different use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Consumers of the class
  prefs: []
  type: TYPE_NORMAL
- en: These are people who are trying to solve their own problems and are looking
    for tools to help them. They may be trying to debug an issue or find a class in
    a codebase that helps them out.
  prefs: []
  type: TYPE_NORMAL
- en: Future maintainers of the class
  prefs: []
  type: TYPE_NORMAL
- en: People will add onto your class, and it’s important that they do not break invariants
    that all your callers have come to depend on.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to keep both in mind when desigining your classes.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming Your Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, consumers of your class will typically look at your source code to see
    how it works and if it meets their needs. Putting assertion statements (or raising
    other exceptions) in the constructor is a great way to tell a user what is and
    isn’t possible with your class. A constructor is typically the first place a developer
    will look (after all, if they can’t instantiate your class, how can they use it?).
    For invariants that you cannot represent in code (yes, those exist), you want
    to document that in whatever your users use for API reference. The closer to the
    code your documentation is, the more likely a user will find it when looking at
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge in one’s head is not scalable or discoverable. Wikis and/or documentation
    portals are a decent step, but often are better suited for larger scale ideas
    that don’t go out of date as quickly. A README in the code repository is a better
    step, but the true best place is a comment or docstring with the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: I’ve had a bit of a contentious relationship with comments throughout my career.
    In the beginning, I would comment everything, probably because my university professors
    required it. A few years later, the pendulum swung too far in the other direction,
    and I was one to espouse “code shall be self-documenting,” meaning that the code
    should be able to stand on its own. After all, comments could go out of date and,
    as the common saying goes, “a wrong comment is worse than no comment.” The pendulum
    has since shifted back and I’ve learned that code should absolutely self-document
    *what* it’s doing (this is just another spin on the Law of Least Surprise), but
    comments help the human nature of code. Most people simplify this to *why* the
    code behaves it does, but sometimes that is vague. In the snippet above, I go
    about it by documenting my invariants (including ones not apparent in code), and
    backing it up with business reasons. This way, a consumer can ascertain what the
    class is and isn’t used for, as well as whether the class fits into their intended
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: What About Maintainers?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will have to deal with the other group, the future maintainers of your code,
    differently. This is a tricky one. You have a comment that helps define your constraints,
    but that won’t prevent inadvertent changing of invariants. Changing invariants
    is a delicate thing. People will come to depend on these invariants, even if they
    aren’t reflected in function signatures or type systems. If somebody changes an
    invariant, every consumer of the class could be affected (sometimes this is inevitable,
    but be aware of the cost).
  prefs: []
  type: TYPE_NORMAL
- en: 'To help catch this, I’ll lean on an old friend as a safety net—unit tests.
    Unit tests are snippets of code that will automatically test your own classes
    and functions. (For more discussion on unit tests, check out [Chapter 21](part0027_split_000.html#testing_strategy).)
    You should absolutely write unit tests around your expectations and invariants,
    but there’s one additional facet I’d like you to consider: help future test writers
    know when invariants are broken as well. I like to do this with the help of a
    context manager—a construct in Python that forces code to run when a `with` block
    is exited (if you’re not familiar with context managers, you’ll learn more in
    [Chapter 11](part0015_split_000.html#api)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The beauty of using a context manager like this is that every invariant can
    be checked as a postcondition of the test. This feels like duplication and direct
    violation of the DRY principle, but in this case, it’s warranted. Unit tests are
    a form of double-entry bookkeeping, and you want them to find errors when one
    side erroneously changes.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation and Maintaining Invariants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have a little secret for you. I wasn’t completely honest in the last section.
    I know, I know, shame on me, and I’m sure the eagle-eyed readers have already
    spotted my deception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Nothing at all is preventing a future developer from changing some invariants
    after the fact.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'What was the point of talking about invariants if any developer can immediately
    invalidate them? Well, it turns out that I have another concept to discuss: *encapsulation*.'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsul-what, Now?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encapsulation. Simply put, it’s the ability for an entity to hide properties
    and the actions that operate upon those properties. Practically speaking, it means
    that you decide what properties are visible to callers, and restrict how they
    can access them and/or change data. This is accomplished using an *application
    programming interface* (API).
  prefs: []
  type: TYPE_NORMAL
- en: When most people think of an API, things like REST or SDKs (software development
    kits) come to mind. But every class has its own API. It’s the cornerstone of how
    you interact with classes. Every function call, every property access, every initialization
    is part of an object’s API.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, I’ve covered two parts of the API in the `PizzaSpecification`: the
    initialization (constructor) and property access. I don’t have much more to say
    about the constructor; its done its job in verifying invariants. Now, I will address
    how to preserve those invariants as you flesh out the rest of an API (the operations
    that we wish to bundle with this class).'
  prefs: []
  type: TYPE_NORMAL
- en: Protecting Data Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'That leads us back to the problem at the beginning of this section: how do
    we prevent users of our API (our class) from breaking invariants? By signaling
    that this data should be *private*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of access control in many programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: Public
  prefs: []
  type: TYPE_NORMAL
- en: Any other piece of code can access this part of the API.
  prefs: []
  type: TYPE_NORMAL
- en: Protected
  prefs: []
  type: TYPE_NORMAL
- en: Only subclasses (we’ll see these more in [Chapter 12](part0016_split_000.html#subtyping))
    should access this part of the API.
  prefs: []
  type: TYPE_NORMAL
- en: Private
  prefs: []
  type: TYPE_NORMAL
- en: Only this class (and any other instances of this class) should access this part
    of the API.
  prefs: []
  type: TYPE_NORMAL
- en: Public and protected attributes form your public API, and should be relatively
    stable before people depend on your class heavily. However, it is a general convention
    that people should leave your private API alone. This should leave you free to
    hide things that you feel need to be inaccessible. This is how you can preserve
    your invariants.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, you signal to other developers that an attribute should be protected
    by prefixing it with an underscore (`_`). Private attributes and methods should
    be prefixed with two underscores (`__`). (Note that this is not the same as functions
    *surrounded* by two underscores—those denote special magic methods, which I’ll
    cover in [Chapter 11](part0015_split_000.html#api).) In Python, you don’t have
    a compiler that can catch when this access control is broken. There is nothing
    stopping a developer from reaching in and messing with your protected and private
    members. Enforcing this becomes an organizational challenge, part of the nature
    of the beast with a dynamically typed language like Python. Set up linting, enforce
    code styles, do thorough code reviews; you should treat your API as a core tenet
    of your class and not allow it to be broken lightly.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few benefits to making your attributes protected/private. Protected
    and private attributes don’t show up in `help()` of a class. This will reduce
    the chance of somebody using these attributes inadvertently. Furthermore, private
    attributes aren’t as easily accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `PizzaSpecification` with private members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](../images/00002.gif)](part0014_split_012.html#co_user_defined_types__classes_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Dough radius in inches is now a private member.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](../images/00005.gif)](part0014_split_012.html#co_user_defined_types__classes_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Toppings is now a private member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python does something called name mangling when you prefix attributes with
    two underscores. That is, Python changes the name out from underneath you, making
    it very obvious when users are abusing your API. I can find out what name mangling
    is by using the `__dict__` attribute of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see an attribute access like this, you should raise a red flag: developers
    are messing with class internals and this might break invariants. Fortunately,
    this is very easy to catch when linting code bases (you’ll learn more about linters
    in [Chapter 20](part0026_split_000.html#static_analysis)). Form a pact with your
    cocontributors and don’t touch anything that is private; otherwise, you’ll find
    yourself in an unmaintainable mess.'
  prefs: []
  type: TYPE_NORMAL
- en: Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So now I have a class whose invariants cannot be (easily) broken. I have a
    class that is constructible, but I’m not able to change or read any data from
    it. That’s because I’ve only touched upon one part of encapsulation thus far:
    the hiding of data. I still need to walk through how to bundle operations with
    data. Enter methods.'
  prefs: []
  type: TYPE_NORMAL
- en: I will trust that you have a good handle on functions that live outside of a
    class (also known as free functions). What I’ll focus on are functions that live
    inside the class, also known as methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say that for my pizza specification, I want to be able to add a topping
    while the pizza is queued to be made. After all, my pizzas are a huge success
    (it’s my imagination, let me have this one), and there is often a long line of
    pizzas to be made. But a family just placing their order realizes they missed
    their son’s favorite topping, and in order to prevent a toddler meltdown over
    melted cheese, they need to modify their order after they’ve submitted it. I’ll
    define a new function that adds a topping for their convenience.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](../images/00002.gif)](part0014_split_013.html#co_user_defined_types__classes_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the new `add_topping` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](../images/00005.gif)](part0014_split_013.html#co_user_defined_types__classes_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The new `add_topping` method.
  prefs: []
  type: TYPE_NORMAL
- en: It’d be easy to write a method that merely appends a topping to a list. But
    that wouldn’t be right. I have an invariant to uphold, and I’m not backing down
    now. The code makes sure that we don’t add a second sauce, and if the topping
    is a sauce, ensures that it is laid down first. Remember, an invariant needs to
    be true for the lifetime of an object, which extends far past initial construction.
    Every method you add should be continuing to preserve that invariant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods are often separated into two categories: accessors and mutators. Some
    people simplify this to “getters” and “setters,” but I feel like that is a bit
    too narrow. “Getters” and “setters” often describe methods that just return a
    simple value or set a member variable. Many methods are much more complicated:
    setting multiple fields, performing complex calculations, or manipulating data
    structures.'
  prefs: []
  type: TYPE_NORMAL
- en: Accessors are for retrieving information. If you have invariants that relate
    to how you represent data, these are the methods you care about. For example,
    the pizza specification might include a way to transform its internal data into
    machine operations (roll dough, apply sauce, apply toppings, bake). By nature
    of the invariants, you’d want to make sure you aren’t producing invalid machine
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Mutators are things that alter the state of your object. If you have mutators,
    you need to be extra careful that you are preserving any invariants as you change
    state. Adding new toppings to an existing pizza is a mutator.
  prefs: []
  type: TYPE_NORMAL
- en: This is also a good way to measure whether a function should be inside your
    class or not. If you have functions that don’t concern themselves with invariants,
    or even worse, don’t concern themselves with members of the class, you probably
    have a free function instead. This class is better served by living at module
    scope and outside of your class. It may be appealing to jam just one more function
    into an already bloated class (it often is the easiest), but if you strive for
    maintainability, having unrelated functions in a class leads to a nightmare. (You
    set up all sorts of interesting dependency chains; if you’ve ever asked yourself
    why one file depends on another file, this is often the reason.) It also may happen
    that your class has no invariants at all, and you should instead just chain together
    free functions.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s invariants. It’s not something developers talk about enough, but
    once you start thinking in terms of invariants, you’ll see a major boost to class
    maintainability. Remember, you use invariants to allow users to reason about your
    objects and reduce cognitive load. It’s OK if you take extra time writing code
    if you will pay off the costs for however many readers after.
  prefs: []
  type: TYPE_NORMAL
- en: Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I spent a fair amount of time on classes, especially compared to other user-defined
    data types such as enumerations and data classes. However, this was intentional.
    Classes are typically taught very early, and rarely revisited. I’ve found that
    most developers tend to overuse classes, without considering what they are meant
    for.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you decide how to create user-defined types, I offer the following guide
    for you:'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries are meant for mappings from keys to values. If you are using dictionaries
    but rarely iterating over them or dynamically asking for keys, you aren’t using
    them like an associative mapping and probably need a different type. There is
    an exception when retrieving data from data sources at runtime (e.g., getting
    JSON, parsing YAML, retrieving database data, etc.), where a `TypedDict` is appropriate
    (see [Chapter 5](part0008_split_000.html#collections)). However, if you don’t
    need to use them as dictionaries elsewhere, you should strive to get these into
    user-defined classes after parsing the data.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations are great for representing a union of discrete scalar values. You
    don’t necessarily care about what the enumeration values are; you just need separate
    identifiers to differentiate cases in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Data classes
  prefs: []
  type: TYPE_NORMAL
- en: Data classes are great for bundles of data that are mostly independent. You
    may have some restrictions on how individual fields can be set, but for the most
    part, users are free to get and set individual attributes to their heart’s content.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs: []
  type: TYPE_NORMAL
- en: Classes are all about invariants. If you have an invariant you want to preserve,
    create a class, assert that the preconditions hold when constructing, and don’t
    let any method or user access break that invariant.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-1](part0014_split_014.html#class_flowchart) is a handy flowchart
    that describes these rules of thumb.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Picking the appropriate abstraction](../images/00014.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Picking the appropriate abstraction
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: However, knowing which type to pick is only half the battle. Once you’ve picked
    the right type, you need to make it seamless to interact with from a consumer’s
    perspective. In the next chapter, you’re going to learn how to make your user-defined
    types more natural to work with by focusing on the type’s API.
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](part0014_split_005.html#idm45644740381352-marker)) Andrew Hunt and David
    Thomas. *The Pragmatic Programmer: From Journeyman to Master*. Reading, MA: Addison-Wesley,
    2000.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](part0014_split_005.html#idm45644740365960-marker)) Robert C. Martin. “The
    Single Responsibility Principle.” *The Clean Code Blog* (blog), May 8, 2014\.
    [*https://oreil.ly/ZOMxb*](https://oreil.ly/ZOMxb).
  prefs: []
  type: TYPE_NORMAL
