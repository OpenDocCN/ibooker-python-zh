- en: Chapter 7\. Adding Changeable/Mutable State with Dask Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dask is focused on scaling analytic use cases, but you can use it to scale many
    other types of problems. So far, most of the tools you have used in Dask are functional.
    Functional programming means that previous calls do not impact future calls. Stateless
    functions are common in distributed systems like Dask, as they can safely be re-executed
    multiple times on failure. Updating the weights of a model during training is
    an example of state common in data science. One of the most common ways of handling
    state in a distributed system is with the actor model. This chapter will introduce
    both the general actor model and Dask’s specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Dask futures offer a non-mutable distributed state, where values are stored
    on the workers. However, this doesn’t work well for situations in which you want
    to update the state, like changing a bank account balance (an alternative solution
    is illustrated in [Example 7-1](#making_bank_acct_actor_ch07_1686239522527)),
    or updating machine learning model weights during training.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dask actors have a number of limitations, and we believe that in many cases
    the right answer is to keep mutable state *outside* of Dask (like in a database).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you don’t have to use distributed mutable state. In some cases, you
    may choose to not use distributed state and instead put it all in your main program.
    This can quickly lead to bottlenecks on the node responsible for your main program.
    Other options include storing your state outside of Dask, like in a database,
    which has its own trade-offs. While this chapter focuses on how to use the actor
    model, we conclude with when not to use Dask actors and alternatives for handling
    state, which is of equal importance.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dask also has distributed mutable objects, covered in [“Distributed Data Structures
    for Scheduling”](ch06.xhtml#dds_scheduling).
  prefs: []
  type: TYPE_NORMAL
- en: What Is the Actor Model?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the actor model, actors do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive and respond to messages, including from other actors and external
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actor model is a technique of dealing with state in parallel and distributed
    systems that avoid locks. While proper locking ensures that only one piece of
    code modifies a given value, it can be very expensive and difficult to get right.
    A common problem with locking is known as deadlocking—this is where resources
    are acquired/released in an incorrect order that the program can block forever.
    The slowness and difficulty of locks only increase in distributed systems.^([1](ch07.xhtml#id695))
    The actor model was introduced in 1973 and has since been implemented in most
    programming languages,^([2](ch07.xhtml#id696)) with some popular modern implementations
    including Akka in Scala and the .NET languages.
  prefs: []
  type: TYPE_NORMAL
- en: It can be helpful to think of each actor as a person holding a note about their
    state, and that person is the only one allowed to read or update the note. Whenever
    another part of the code wants to access or modify the state, it must ask the
    actor to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, this is very similar to classes in object-oriented programming.
    However, unlike with generic classes, actors process one request at a time to
    ensure an actor’s state consistency. To improve the throughput, people often create
    a pool of actors (assuming they can shard or replicate the actor’s state). We’ll
    cover an example in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actor model is a good fit for many distributed systems scenarios. Here
    are some typical use cases in which the actor model can be advantageous:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to deal with a large distributed state that is hard to synchronize
    between invocations (e.g., ML model weights, counters, etc.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to work with single-threaded objects that do not require significant
    interaction from external components. This is especially useful for legacy code
    that is not fully understood.^([3](ch07.xhtml#id697))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have an understanding of the actor model in general, it’s time
    for you to learn about how Dask implements it, and about its trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: Dask Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dask actors are one implementation of actors, and some of the properties differ
    between Dask and other systems. Unlike the rest of Dask, Dask actors are not resilient
    to failures. If the node, or process, running the actor fails, the data inside
    the actor is lost and Dask is not able to recover from it.
  prefs: []
  type: TYPE_NORMAL
- en: Your First Actor (It’s a Bank Account)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating an actor in Dask is relatively simple. To start with, you make a normal
    Python class with functions that you will call. These functions are responsible
    for receiving and responding to messages in the actor model. Once you have your
    class, you `submit` it to Dask, along with the flag `actor=True`, and Dask gives
    you back a future representing a reference to the actor. When you get the `result`
    of this future, Dask creates and returns to you a proxy object, which passes any
    function calls as messages to the actor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note this is effectively an object-oriented bank account implementation, except
    we don’t have any locks since we only ever have a single thread changing the values.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at how you can implement a common example actor for a bank
    account. In [Example 7-1](#making_bank_acct_actor_ch07_1686239522527), we define
    three methods—`balance`, `deposit`, and `withdrawal`—that can be used to interact
    with the actor. Once the actor is defined, we ask Dask to schedule the actor so
    that we can call it.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-1\. Making a bank account actor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you call methods on the resulting proxy object (see [Example 7-2](#using_bank_acct_actor_ch07_1686239559633)),
    Dask dispatches a remote procedure call and returns a special ActorFuture immediately.
    This allows you to use actors in a non-blocking fashion. Unlike the generic `@dask.delayed`
    calls, these are all routed to the same process, namely the one where Dask has
    scheduled the actor.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-2\. Using the bank account actor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The ActorFuture *is not serializable*, so if you need to transfer the result
    of calling an actor, you need to block and get its value, as shown in [Example 7-3](#actorfutures_not_serializable_ch07_1686239609453).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-3\. ActorFutures are not serializable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While having one actor per bank account does a good job of avoiding bottlenecks,
    since each bank account likely won’t have too many transactions queued, it is
    slightly inefficient, as there is a non-zero actor overhead. One solution is to
    extend our bank account actor to support multiple accounts by using a key and
    hashmap, but if all accounts are inside one actor, this can lead to scaling problems.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling Dask Actors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The actor model described earlier in this chapter typically assumes that actors
    are lightweight, meaning they contain a single piece of state, and do not require
    scal⁠ing/​parallelization. In Dask and similar systems (including Akka), actors
    are often used for coarser-grained implementations and can require scaling.^([4](ch07.xhtml#id706))
  prefs: []
  type: TYPE_NORMAL
- en: As with `dask.delayed`, you can scale actors horizontally (across pro⁠cesses/​machines)
    by creating multiple actors or vertically (with more resources). Scaling actors
    horizontally is not as simple as just adding more machines or workers, since Dask
    cannot break up a single actor across multiple processes.
  prefs: []
  type: TYPE_NORMAL
- en: When scaling actors horizontally, it is up to you to break up the state in such
    a way that you can have multiple actors handling it. One technique is to use *actor
    pools* (see [Figure 7-1](#figure0701_ch07_1686049800930)). These pools can have
    a static mapping of, say, user → actor, or, in the situation in which the actors
    share a database, round-robin or other non-deterministic balancing can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '![spwd 0701](Images/spwd_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Scaled actor model using consistent hashing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We extend the bank account example to a “bank” where an actor may be responsible
    for multiple accounts (but not for all of the accounts in the bank). We can then
    use an actor pool with hashing to route the requests to the correct “branch” or
    actor, as shown in [Example 7-4](#sketchy_bank_ex).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-4\. Hashing actor pool example for a bank
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously mentioned, Dask actors are not resilient to machine or process
    failure. This is a design decision in Dask and is not true for all actor systems.
    Many, but not all, actor systems offer different options for the persistence and
    recovery of actors during failure. For example, Ray has the concept of recoverable
    actors (managed automatically inside of workflows or manually).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Calls to `dask.delayed` functions may be retried on failure, and if they call
    functions on actors, those function calls will then be duplicated. If you cannot
    have a function replayed, then you need to ensure it is called only from inside
    other actors.
  prefs: []
  type: TYPE_NORMAL
- en: Dask’s actor model is less full-featured than Ray’s actor model, much as Ray’s
    DataFrame is less full-featured than Dask’s. You may wish to consider running
    Dask on Ray to get the best of both worlds. While Holden is biased, she suggests
    you check out her book *Scaling Python with Ray* if you are interested in Ray.
  prefs: []
  type: TYPE_NORMAL
- en: When to Use Dask Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common problem in the industry is not realizing when our cool new tool is
    not the right tool for the job. As the saying goes, “When you have a hammer, the
    whole world looks like a nail.” *You likely do not need actors and should stick
    with tasks if you are not mutating state.* It is important for you to remember
    that there are other options for handling state, as shown in [Table 7-1](#table_ch07_1687457980057).
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. Comparison of techniques for managing mutable state
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Local state (e.g., driver) | Dask actors | External distributed state
    (e.g., ZooKeeper, Ray, or AKKA) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Scalability** | No, all state must fit on a single machine. | State within
    each actor must fit on a machine, but actors are spread out. | Yes^([a](ch07.xhtml#id711))
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Resilience** | Medium, but no increase in resilience cost (e.g., loss of
    driver is already catastrophic) | No, loss of any worker with an actor becomes
    catastrophic. | Yes, loss of entire cluster can be recovered from. |'
  prefs: []
  type: TYPE_TB
- en: '| **Performance overhead** | RPC to driver | Same as `dask.delayed` | RPC to
    external system + external systems overhead |'
  prefs: []
  type: TYPE_TB
- en: '| **Code complexity** | Low | Medium | High (new library to learn and integrate),
    extra logic for avoiding duplicate execution |'
  prefs: []
  type: TYPE_TB
- en: '| **Deployment complexity** | Low | Low | High (new system to maintain) |'
  prefs: []
  type: TYPE_TB
- en: '| ^([a](ch07.xhtml#id711-marker)) Ray actors still require that the state within
    an actor must fit on a single machine. Ray has additional tools to shard or create
    pools of actors. |'
  prefs: []
  type: TYPE_TB
- en: As with most things in life, picking the right technique is a compromise specific
    to the problem you are trying to solve. We believe that one of the two local (e.g.,
    driver) states, or the use of Ray actors in conjunction with Dask for its analytical
    powers, can handle most cases in which you need mutable state.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter you have learned the basics of how the actor model works as
    well as how Dask implements it. You’ve also learned some alternatives for dealing
    with state in a distributed system, and how to choose between them. Dask actors
    are a relatively new part of Dask and do not have the same resilience properties
    as delayed functions. The failure of a worker containing an actor cannot be recovered
    from. Many other actor systems offer some ability to recover from failures, and
    if you find yourself depending heavily on actors, you may wish to explore alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch07.xhtml#id695-marker)) See the [ZooKeeper documentation](https://oreil.ly/btzJK)
    for an understanding of ZooKeeper’s distributed performance.
  prefs: []
  type: TYPE_NORMAL
- en: '^([2](ch07.xhtml#id696-marker)) The actor model was extended in 1985 for concurrent
    computation; see [“Actors: A Model of Concurrent Computation in Distributed Systems”](https://oreil.ly/uPCfx)
    by Gul Abdulnabi Agha.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch07.xhtml#id697-marker)) Think COBOL, where the author left and the documentation
    was lost, but when you tried to turn it off accounting came running, literally.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch07.xhtml#id706-marker)) A *coarse-grained* actor is one that may contain
    multiple pieces of state; a *fine-grained* actor is one where each piece of state
    would be represented as a separate actor. This is similar to the concept of [coarse-grained
    locking](https://oreil.ly/7RMkS).
  prefs: []
  type: TYPE_NORMAL
