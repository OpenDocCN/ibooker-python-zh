<html><head></head><body><section data-pdf-bookmark="Chapter 8. Ray Workflows" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch08">
<h1><span class="label">Chapter 8. </span>Ray Workflows</h1>


<p class="byline">With contributions from Carlos Andrade Costa</p>

<p>Real-life and modern applications in a wide range of domains are often a combination of multiple interdependent steps. For example, in AI/ML workflows, training workloads require multiple steps for data cleaning, balancing, and augmentation, while model serving often includes many subtasks and integration with long-running business processes. Different steps in the workflows can depend on multiple upstreams and sometimes require different scaling tools.</p>

<p>Computer libraries for workflow management date back over 25 years, with new tools focused on AI/ML emerging. Workflow specifications range from graphical user interfaces to custom formats, YAML Ain’t Markup Language (YAML) and Extensible Markup Language (XML), and libraries in full-fledged programming languages. Specifying workflows in code allows you to use general programming tools, like source control for versioning and collaboration.</p>

<p>In this chapter, you will learn the basics of Ray’s Workflows implementation and some simple examples of its usage.</p>






<section data-pdf-bookmark="What Is Ray Workflows?" data-type="sect1"><div class="sect1" id="idm45354770935584">
<h1>What Is Ray Workflows?</h1>

<p><em>Ray Workflows</em> extends<a data-primary="Ray Workflows" data-seealso="workflows" data-type="indexterm" id="idm45354770934192"/><a data-primary="workflows" data-seealso="Ray Workflows" data-type="indexterm" id="idm45354770933344"/> Ray Core by adding workflow primitives, providing support for programmatic workflow execution with a shared interface with tasks and actors. This allows you to use Ray’s core primitives as part of your workflow’s steps. Ray Workflows is targeted at supporting both traditional ML and data workflows (e.g., data preprocessing and training) and long-running business workflows, including model-serving integration. It leverages Ray tasks for execution to provide scalability and reliability. Ray’s workflow primitives greatly reduce the burden of embedding workflow logic into application steps.</p>
</div></section>






<section data-pdf-bookmark="How Is It Different from Other Solutions?" data-type="sect1"><div class="sect1" id="idm45354770932112">
<h1>How Is It Different from Other Solutions?</h1>

<p>Unlike <a data-primary="Ray Workflows" data-secondary="comparison with other solutions" data-type="indexterm" id="idm45354770930880"/>other popular workflow frameworks—​e.g., <a href="https://oreil.ly/ZKymk">Apache Airflow</a>, <a href="https://oreil.ly/dgEk7">Kubeflow Pipelines</a>, and others—​which focus on tool integration and deployment orchestration, Ray Workflows focuses on lower-level workflow primitives enabling programmatic workflows.<sup><a data-type="noteref" href="ch08.html#idm45354770928336" id="idm45354770928336-marker">1</a></sup> This programmatic approach can be considered a lower level compared to other implementations; this low-level approach allows for unique workflow management features.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Ray Workflows focuses on embedding core workflow primitives into Ray Core to enable rich programmatic workflows, as opposed to supporting tools integration and deployment orchestration.</p>
</div>
</div></section>






<section data-pdf-bookmark="Ray Workflows Features" data-type="sect1"><div class="sect1" id="idm45354770925536">
<h1>Ray Workflows Features</h1>

<p>In this section, we will walk through the main features of Ray Workflows, review the core primitives, and see how they are used in simple examples.</p>








<section data-pdf-bookmark="What Are the Main Features?" data-type="sect2"><div class="sect2" id="idm45354770923920">
<h2>What Are the Main Features?</h2>

<p>The <a data-primary="Ray Workflows" data-secondary="features of" data-type="indexterm" id="idm45354770922624"/>main features provided by Ray Workflows include the following:</p>
<dl>
<dt>Durability</dt>
<dd>
<p>By adding virtual actors (see <a data-type="xref" href="#virtual-actors-section">“Virtual Actors”</a>), Ray Workflows adds durability guarantees to steps executed with Ray’s dynamic task graph.</p>
</dd>
<dt>Dependency management</dt>
<dd>
<p>Ray Workflows leverages Ray’s runtime environment feature to snapshot the code dependencies of a workflow. This enables management of workflows and virtual actors as code is upgraded over time.</p>
</dd>
<dt>Low-latency and scale</dt>
<dd>
<p>By leveraging Ray’s zero-copy overhead with Plasma (a shared memory store), Ray Workflows provides subsecond overhead when launching tasks. Ray’s scalability extends to workflows, allowing you to create workflows with thousands of steps.</p>
</dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Ray Workflows provides durable execution of workflow steps using any of Ray’s distributed libraries, with low-latency and dynamic dependency management.</p>
</div>
</div></section>








<section data-pdf-bookmark="Workflow Primitives" data-type="sect2"><div class="sect2" id="idm45354770914608">
<h2>Workflow Primitives</h2>

<p>Ray Workflows <a data-primary="Ray Workflows" data-secondary="primitives" data-tertiary="types of" data-type="indexterm" id="ray-workflow-primitive-type"/><a data-primary="primitives" data-secondary="types of" data-type="indexterm" id="primitive-type"/>provides core primitives to build workflows with steps and a <em>virtual actor</em>. The following list summarizes the core primitives and basic concepts in Ray Workflows:</p>
<dl>
<dt>Steps</dt>
<dd>
<p>Annotated functions<a data-primary="@workflow.step" data-type="indexterm" id="idm45354770907680"/><a data-primary="decorators" data-secondary="@workflow.step" data-type="indexterm" id="idm45354770906944"/><a data-primary="steps (workflow primitive)" data-secondary="defined" data-type="indexterm" id="idm45354770906000"/> with the <code>@workflow.step</code> decorator. Steps are executed once when finished successfully, and retried on failure. Steps can be used as arguments for other step futures. To ensure recoverability, steps don’t support the <code>ray.get</code> and <code>ray.wait</code> calls.</p>
</dd>
<dt>Objects</dt>
<dd>
<p>Data objects<a data-primary="objects (workflow primitive)" data-secondary="defined" data-type="indexterm" id="idm45354770902464"/> stored in the Ray object store, with references to these objects being passed into and returned from steps. When initially returned from a step, objects are checkpointed and can be shared with other Workflows steps through the Ray object store.</p>
</dd>
<dt>Workflows</dt>
<dd>
<p>Execution graph<a data-primary="workflows" data-secondary="defined" data-type="indexterm" id="idm45354770900080"/> created with <code>@Workflow.run</code> and <code>Workflow.run_async</code>. The workflow execution, after starting, is logged to storage for durability and can be resumed upon failure on any Ray cluster with access to the storage.</p>

<p>Workflows can also be dynamic, generating new steps in subworkflows at runtime. Workflows support dynamic looping, nesting, and recursion. You can even dynamically add new steps to your workflow directed acyclic graph (DAG) by returning more workflow steps from a workflow step.</p>
</dd>
<dt>Virtual actors</dt>
<dd>
<p>Virtual actors<a data-primary="virtual actors" data-secondary="defined" data-type="indexterm" id="idm45354770896352"/> are like regular Ray actors, which can hold member states. The main difference is that virtual actors are backed by durable storage instead of only in-process memory, which does not survive cluster restarts or worker failures.</p>

<p>Virtual actors manage long-running business workflows. They save their state into external storage for durability. They also support the launch of sub­work⁠flows from method calls and receive externally triggered events.</p>

<p>You can use virtual actors to add state to an otherwise stateless workflow.</p>
</dd>
<dt>Events</dt>
<dd>
<p>Workflows<a data-primary="events" data-secondary="defined" data-type="indexterm" id="idm45354770893104"/> can be triggered by timers and external events through pluggable event listeners. Events can also be used as an argument for a step, making the step execution wait until the event is <a data-primary="Ray Workflows" data-secondary="primitives" data-startref="ray-workflow-primitive-type" data-tertiary="types of" data-type="indexterm" id="idm45354770891968"/><a data-primary="primitives" data-secondary="types of" data-startref="primitive-type" data-type="indexterm" id="idm45354770890512"/>received.</p>
</dd>
</dl>
</div></section>
</div></section>






<section data-pdf-bookmark="Working with Basic Workflow Concepts" data-type="sect1"><div class="sect1" id="idm45354770888784">
<h1>Working with Basic Workflow Concepts</h1>

<p>Workflows are built out of various primitives, and you’ll start with learning how to use steps and objects.</p>








<section data-pdf-bookmark="Workflows, Steps, and Objects" data-type="sect2"><div class="sect2" id="idm45354770886944">
<h2>Workflows, Steps, and Objects</h2>

<p><a data-type="xref" href="#basic_workflow">Example 8-1</a> shows<a data-primary="Ray Workflows" data-secondary="primitives" data-tertiary="example usage" data-type="indexterm" id="ray-workflow-primitive-example"/><a data-primary="primitives" data-secondary="example usage" data-type="indexterm" id="primitive-example"/><a data-primary="workflows" data-secondary="example usage" data-type="indexterm" id="workflow-example"/><a data-primary="steps (workflow primitive)" data-secondary="example usage" data-type="indexterm" id="step-example"/><a data-primary="objects (workflow primitive)" data-secondary="example usage" data-type="indexterm" id="object-example"/> a simple Hello World workflow example, demonstrating how the step, object, and workflow primitives work in a simple case.</p>
<div data-type="example" id="basic_workflow">
<h5><span class="label">Example 8-1. </span><a href="https://oreil.ly/4G4VW">Hello World workflow</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code> <code class="nn">ray</code>
<code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>
<code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">List</code>

<code class="c1"># Creating an arbitrary Ray remote function</code>
<code class="nd">@ray</code><code class="o">.</code><code class="n">remote</code>
<code class="k">def</code> <code class="nf">hello</code><code class="p">():</code>
    <code class="k">return</code> <code class="s2">"hello"</code>

<code class="c1"># Defining a workflow step that puts an object into the object store</code>
<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">words</code><code class="p">()</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">[</code><code class="n">ray</code><code class="o">.</code><code class="n">ObjectRef</code><code class="p">]:</code>
    <code class="k">return</code> <code class="p">[</code><code class="n">hello</code><code class="o">.</code><code class="n">remote</code><code class="p">(),</code> <code class="n">ray</code><code class="o">.</code><code class="n">put</code><code class="p">(</code><code class="s2">"world"</code><code class="p">)]</code>

<code class="c1"># Defining a step that receives an object</code>
<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">concat</code><code class="p">(</code><code class="n">words</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">ray</code><code class="o">.</code><code class="n">ObjectRef</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="nb">str</code><code class="p">:</code>
    <code class="k">return</code> <code class="s2">" "</code><code class="o">.</code><code class="n">join</code><code class="p">([</code><code class="n">ray</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="n">w</code><code class="p">)</code> <code class="k">for</code> <code class="n">w</code> <code class="ow">in</code> <code class="n">words</code><code class="p">])</code>

<code class="c1"># Creating workflow</code>
<code class="n">workflow</code><code class="o">.</code><code class="n">init</code><code class="p">(</code><code class="s2">"tmp/workflow_data"</code><code class="p">)</code>
<code class="n">output</code><code class="p">:</code> <code class="s2">"Workflow[int]"</code> <code class="o">=</code> <code class="n">concat</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">words</code><code class="o">.</code><code class="n">step</code><code class="p">())</code>

<code class="c1"># Running workflow</code>
<code class="k">assert</code> <code class="n">output</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">workflow_id</code><code class="o">=</code><code class="s2">"workflow_1"</code><code class="p">)</code> <code class="o">==</code> <code class="s2">"hello world"</code>
<code class="k">assert</code> <code class="n">workflow</code><code class="o">.</code><code class="n">get_status</code><code class="p">(</code><code class="s2">"workflow_1"</code><code class="p">)</code> <code class="o">==</code> <code class="n">workflow</code><code class="o">.</code><code class="n">WorkflowStatus</code><code class="o">.</code><code class="n">SUCCESSFUL</code>
<code class="k">assert</code> <code class="n">workflow</code><code class="o">.</code><code class="n">get_output</code><code class="p">(</code><code class="s2">"workflow_1"</code><code class="p">)</code> <code class="o">==</code> <code class="s2">"hello world"</code></pre></div>

<p class="pagebreak-before">Similar to Ray tasks and actors (described in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#ch03">3</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#ch04">4</a>), you can explicitly assign computing resources (e.g., CPU core, GPUs) to a step with the same arguments as in core Ray: <code>num_cpus</code>, <code>num_gpus</code>, and <code>resources</code>. <a data-primary="Ray Workflows" data-secondary="primitives" data-startref="ray-workflow-primitive-example" data-tertiary="example usage" data-type="indexterm" id="idm45354770792992"/><a data-primary="primitives" data-secondary="example usage" data-startref="primitive-example" data-type="indexterm" id="idm45354770791472"/><a data-primary="workflows" data-secondary="example usage" data-startref="workflow-example" data-type="indexterm" id="idm45354770790256"/><a data-primary="steps (workflow primitive)" data-secondary="example usage" data-startref="step-example" data-type="indexterm" id="idm45354770789040"/><a data-primary="objects (workflow primitive)" data-secondary="example usage" data-startref="object-example" data-type="indexterm" id="idm45354770787856"/>See <a data-type="xref" href="#step_resources">Example 8-2</a>.</p>
<div data-type="example" id="step_resources">
<h5><span class="label">Example 8-2. </span>Adding resources to steps</h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>
<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">num_gpus</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>
<code class="k">def</code> <code class="nf">train_model</code><code class="p">()</code> <code class="o">-&gt;</code> <code class="n">Model</code><code class="p">:</code>
    <code class="k">pass</code>  <code class="c1"># This step is assigned a GPU by Ray.</code>

<code class="n">train_model</code><code class="o">.</code><code class="n">step</code><code class="p">()</code><code class="o">.</code><code class="n">run</code><code class="p">()</code></pre></div>
</div></section>








<section data-pdf-bookmark="Dynamic Workflows" data-type="sect2"><div class="sect2" id="idm45354770654304">
<h2>Dynamic Workflows</h2>

<p>In <a data-primary="Ray Workflows" data-secondary="dynamic workflows" data-type="indexterm" id="idm45354770609840"/><a data-primary="workflows" data-secondary="dynamic" data-type="indexterm" id="idm45354770640416"/><a data-primary="dynamic workflows" data-type="indexterm" id="idm45354770639584"/>addition to the workflows with the predefined DAG, Ray allows you to create steps programmatically based on the current state of workflow execution: <em>dynamic workflows</em>. You can use this type of workflow, for example, to implement recursion and more complex execution flows. A simple recursion can be illustrated with a recursive factorial program. <a data-type="xref" href="#basic_dynamic_workflow">Example 8-3</a> shows how you can use recursion within a workflow (note that this is for illustration only and that other implementations with better performance exist without the need of Ray Workflows).</p>
<div class="pagebreak-after" data-type="example" id="basic_dynamic_workflow">
<h5><span class="label">Example 8-3. </span><a href="https://oreil.ly/3vtT5">Dynamically creating workflow steps</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">factorial</code><code class="p">(</code><code class="n">n</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>
    <code class="k">if</code> <code class="n">n</code> <code class="o">==</code> <code class="mi">1</code><code class="p">:</code>
        <code class="k">return</code> <code class="mi">1</code>
    <code class="k">else</code><code class="p">:</code>
        <code class="k">return</code> <code class="n">mult</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">n</code><code class="p">,</code> <code class="n">factorial</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">n</code> <code class="o">-</code> <code class="mi">1</code><code class="p">))</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">mult</code><code class="p">(</code><code class="n">a</code><code class="p">:</code> <code class="nb">int</code><code class="p">,</code> <code class="n">b</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>
    <code class="k">return</code> <code class="n">a</code> <code class="o">*</code> <code class="n">b</code>

<code class="c1"># Calculate the factorial of 5 by creating a recursion of 5 steps</code>
<code class="n">factorial_workflow</code> <code class="o">=</code> <code class="n">factorial</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code><code class="o">.</code><code class="n">run</code><code class="p">()</code>
<code class="k">assert</code> <code class="n">factorial_workflow</code><code class="o">.</code><code class="n">run</code><code class="p">()</code> <code class="o">==</code> <code class="mi">120</code></pre></div>
</div></section>








<section class="less_space" data-pdf-bookmark="Virtual Actors" data-type="sect2"><div class="sect2" id="virtual-actors-section">
<h2>Virtual Actors</h2>

<p><em>Virtual actors</em> are<a data-primary="Ray Workflows" data-secondary="virtual actors" data-type="indexterm" id="idm45354770476384"/><a data-primary="workflows" data-secondary="virtual actors" data-type="indexterm" id="idm45354770475376"/><a data-primary="virtual actors" data-secondary="example usage" data-type="indexterm" id="idm45354770474432"/><a data-primary="@virtual_actor" data-type="indexterm" id="idm45354770473488"/><a data-primary="decorators" data-secondary="@virtual_actor" data-type="indexterm" id="idm45354770472816"/> Ray actors (see <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>) backed by durable storage instead of memory; they are created with the decorator <code>@virtual_actor</code>. <a data-type="xref" href="#basic_virtual_actor">Example 8-4</a> shows how to use a persistent virtual actor to implement a counter.</p>
<div data-type="example" id="basic_virtual_actor">
<h5><span class="label">Example 8-4. </span><a href="https://oreil.ly/1lV4k">Virtual actors</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">virtual_actor</code>
<code class="k">class</code> <code class="nc">counter</code><code class="p">:</code>
    <code class="k">def</code> <code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">count</code> <code class="o">=</code> <code class="mi">0</code>

    <code class="k">def</code> <code class="nf">incr</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">count</code> <code class="o">+=</code> <code class="mi">1</code>
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">count</code>

<code class="n">workflow</code><code class="o">.</code><code class="n">init</code><code class="p">(</code><code class="n">storage</code><code class="o">=</code><code class="s2">"/tmp/workflows"</code><code class="p">)</code>


<code class="n">workflow1</code> <code class="o">=</code> <code class="n">counter</code><code class="o">.</code><code class="n">get_or_create</code><code class="p">(</code><code class="s2">"counter_workflw"</code><code class="p">)</code>
<code class="k">assert</code> <code class="n">c1</code><code class="o">.</code><code class="n">incr</code><code class="o">.</code><code class="n">run</code><code class="p">()</code> <code class="o">==</code> <code class="mi">1</code>
<code class="k">assert</code> <code class="n">c1</code><code class="o">.</code><code class="n">incr</code><code class="o">.</code><code class="n">run</code><code class="p">()</code> <code class="o">==</code> <code class="mi">2</code></pre></div>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Because a virtual actor retrieves and stores its state before and after every step of execution, its state either has to be JSON serializable (in the form of state dictionary) or <code>getstate</code> and <code>setstate</code> methods should be provided that convert the actor’s state to and from a JSON serializable dictionary.</p>
</div>
</div></section>
</div></section>






<section data-pdf-bookmark="Workflows in Real Life" data-type="sect1"><div class="sect1" id="idm45354770358944">
<h1>Workflows in Real Life</h1>

<p>Let’s take a look at the common steps for creating and managing a reference use case implementation with Ray Workflows.</p>








<section data-pdf-bookmark="Building Workflows" data-type="sect2"><div class="sect2" id="idm45354770357184">
<h2>Building Workflows</h2>

<p>As seen<a data-primary="workflows" data-secondary="building" data-type="indexterm" id="workflow-build"/><a data-primary="steps (workflow primitive)" data-secondary="building workflows" data-type="indexterm" id="step-build-workflow"/><a data-primary="Ray Workflows" data-secondary="building workflows" data-type="indexterm" id="ray-workflow-build"/><a data-primary="@workflow.step" data-type="indexterm" id="idm45354770351776"/><a data-primary="decorators" data-secondary="@workflow.step" data-type="indexterm" id="idm45354770351104"/> before, you start with implementing individual workflow steps and declaring them with the <code>@workflow.step</code> annotation. Similarly to a Ray task, steps can receive one or more inputs, where each input can be a specific value or a future—​the result of executing one or more previous workflow steps. The return type of workflow is <code>Workflow[T]</code> and is a future with the value available after the execution of the workflow is completed. <a data-type="xref" href="#workflow_step">Example 8-5</a> illustrates this process. In this case, the steps <code>get_value1</code> and <code>get_value2</code> return futures that are passed to the <code>sum</code> step function.</p>
<div data-type="example" id="workflow_step">
<h5><span class="label">Example 8-5. </span><a href="https://oreil.ly/Sl5bx">Implementing workflow steps</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">sum</code><code class="p">(</code><code class="n">x</code><code class="p">:</code> <code class="nb">int</code><code class="p">,</code> <code class="n">y</code><code class="p">:</code> <code class="nb">int</code><code class="p">,</code> <code class="n">z</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>
    <code class="k">return</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code> <code class="o">+</code> <code class="n">z</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">get_value1</code><code class="p">()</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>
    <code class="k">return</code> <code class="mi">100</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">get_value2</code><code class="p">(</code><code class="n">x</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>
    <code class="k">return</code> <code class="mi">10</code><code class="o">*</code><code class="n">x</code>

<code class="n">sum_workflow</code> <code class="o">=</code> <code class="nb">sum</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">get_val1</code><code class="o">.</code><code class="n">step</code><code class="p">(),</code> <code class="n">get_val2</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="mi">10</code><code class="p">),</code> <code class="mi">100</code><code class="p">)</code>

<code class="k">assert</code> <code class="n">sum_workflow</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"sum_example"</code><code class="p">)</code> <code class="o">==</code> <code class="mi">300</code></pre></div>

<p>To simplify accessing step execution results and passing data between steps, Ray Workflows allows you to explicitly name the steps. You can, for example, retrieve the results of step execution by calling <code>workflow.get_output(workflow_id, name="step_name")</code>, which will return an <code>ObjectRef[T]</code>. If you do not explicitly name the step, Ray will automatically generate one in the format of <code>&lt;<em>WORK⁠FLOW_ID</em>&gt;​.&lt;<em>MOD⁠ULE_NAME</em>&gt;.&lt;<em>FUNC_NAME</em>&gt;</code>.</p>

<p>Note that you can call <code>ray.get</code> on the returned reference, which will block until the workflow is completed. For example, <code>ray.get(workflow.get_output("sum​_exam⁠ple")) == 100</code>.</p>

<p>Steps can be named in two ways:</p>

<ul>
<li>
<p>Using <code>.options(name="step_name")</code></p>
</li>
<li>
<p>Using <a data-primary="workflows" data-secondary="building" data-startref="workflow-build" data-type="indexterm" id="idm45354770203680"/><a data-primary="steps (workflow primitive)" data-secondary="building workflows" data-startref="step-build-workflow" data-type="indexterm" id="idm45354770202400"/><a data-primary="Ray Workflows" data-secondary="building workflows" data-startref="ray-workflow-build" data-type="indexterm" id="idm45354770201216"/>the decorator <code>@workflows.step(name=”step_name”)</code></p>
</li>
</ul>
</div></section>








<section data-pdf-bookmark="Managing Workflows" data-type="sect2"><div class="sect2" id="idm45354770199200">
<h2>Managing Workflows</h2>

<p>Each <a data-primary="workflows" data-secondary="managing" data-type="indexterm" id="workflow-manage"/><a data-primary="Ray Workflows" data-secondary="managing workflows" data-type="indexterm" id="ray-workflow-manage"/><a data-primary="managing" data-secondary="workflows" data-type="indexterm" id="manage-workflow"/>workflow in Ray Workflows has a unique <code>workflow_id</code>. You can explicitly set a workflow ID during workflow startup, using <code>.run(workflow_id="workflow_id")</code>. The same option is also applicable to <code>.run_async</code>. If no ID is provided when calling <code>.run</code> and <code>run_async</code>, a random ID is generated.</p>

<p>Once created, workflows can be in the following states:</p>
<dl>
<dt>Running</dt>
<dd>
<p>Currently running in the cluster.</p>
</dd>
<dt>Failed</dt>
<dd>
<p>Failed with an application error. It may be resumed from the failed step.</p>
</dd>
<dt>Resumable</dt>
<dd>
<p>Workflow that failed with a system error and can be resumed from the failed step.</p>
</dd>
<dt>Canceled</dt>
<dd>
<p>Workflow has been canceled. It cannot be resumed, and results are unavailable.</p>
</dd>
<dt>Successful</dt>
<dd>
<p>Workflow completed successfully.</p>
</dd>
</dl>

<p><a data-type="xref" href="#table-workflow-mgmt-apis">Table 8-1</a> shows a summary of the management APIs and how you can use them to manage workflows both individually or in bulk.</p>
<table id="table-workflow-mgmt-apis">
<caption><span class="label">Table 8-1. </span>Workflow management APIs</caption>
<thead>
<tr>
<th>Single workflow</th>
<th>Action</th>
<th>Bulk workflow</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>.get_status(​work⁠flow_id=&lt;&gt;)</code></p></td>
<td><p>Get status of workflows (running, resumable, failed, canceled, successful)</p></td>
<td><p><code>.list_all(​&lt;<em>work⁠flow_state1</em>, <em>work⁠flow_state2</em>, …&gt;)</code></p></td>
<td><p>List all workflows in the states listed</p></td>
</tr>
<tr>
<td><p><code>.resume(​work⁠flow_id=&lt;&gt;)</code></p></td>
<td><p>Resume a workflow</p></td>
<td><p><code>.resume_all</code></p></td>
<td><p>Resume all resumable workflows</p></td>
</tr>
<tr>
<td><p><code>.cancel(​work⁠flow_id=&lt;&gt;)</code></p></td>
<td><p>Cancel a workflow</p></td>
<td/>
<td/>
</tr>
<tr>
<td><p><code>.delete(​work⁠flow_id=&lt;&gt;)</code></p></td>
<td><p>Delete a workflow</p></td>
<td/>
<td/>
</tr>
</tbody>
</table>

<p>Ray Workflows stores workflow information in your configured storage location. You configure the location either when creating the workflow with the decorator <code>workflow.init(storage=&lt;<em>path</em>&gt;)</code>, or by setting the environment variable <code>RAY_WORKFLOW_STORAGE</code>.</p>

<p>You can use either regular/local storage or distributed storage using an S3-compatible API:</p>
<dl>
<dt>Local filesystem</dt>
<dd>
<p>Either single node, for testing purposes only, or through a shared filesystem (e.g., NFS mount) across the nodes in the cluster. Location is passed as an absolute path.</p>
</dd>
<dt>S3 backend</dt>
<dd>
<p>Enable workflow data to be written to an S3-based backend for use in 
<span class="keep-together">production.</span></p>
</dd>
</dl>

<p>If you do not specify a path, Workflows will use the default location: <em>/tmp/ray/work​flow_data</em>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If no storage data location is specified, workflow data is saved locally and works for only a single-node Ray cluster.</p>
</div>

<p>Ray’s Workflows dependencies are actively under development. Once available, this feature will allow Ray to log the full runtime environment to storage, at the workflow submission time. By tracking this information, Ray can ensure that the workflow can run on a different<a data-primary="workflows" data-secondary="managing" data-startref="workflow-manage" data-type="indexterm" id="idm45354770158272"/><a data-primary="Ray Workflows" data-secondary="managing workflows" data-startref="ray-workflow-manage" data-type="indexterm" id="idm45354770157024"/><a data-primary="managing" data-secondary="workflows" data-startref="manage-workflow" data-type="indexterm" id="idm45354770155808"/> cluster.</p>
</div></section>








<section data-pdf-bookmark="Building a Dynamic Workflow" data-type="sect2"><div class="sect2" id="idm45354770198608">
<h2>Building a Dynamic Workflow</h2>

<p>As <a data-primary="workflows" data-secondary="dynamic" data-tertiary="building" data-type="indexterm" id="idm45354770153184"/><a data-primary="workflows" data-secondary="building" data-tertiary="dynamic" data-type="indexterm" id="idm45354770151904"/><a data-primary="Ray Workflows" data-secondary="building workflows" data-tertiary="dynamic" data-type="indexterm" id="idm45354770150688"/><a data-primary="dynamic workflows" data-secondary="building" data-type="indexterm" id="idm45354770149472"/><a data-primary="steps (workflow primitive)" data-secondary="building workflows" data-tertiary="dynamic" data-type="indexterm" id="idm45354770148528"/>mentioned before, you can create workflows dynamically by creating steps based on the current state of a given step. When such a step is created, it is inserted into the original workflow DAG. <a data-type="xref" href="#dynamic_workflow">Example 8-6</a> shows how to use a dynamic workflow to calculate the Fibonacci sequence.</p>
<div data-type="example" id="dynamic_workflow">
<h5><span class="label">Example 8-6. </span><a href="https://oreil.ly/zaIwk">Dynamic workflow</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">add</code><code class="p">(</code><code class="n">a</code><code class="p">:</code> <code class="nb">int</code><code class="p">,</code> <code class="n">b</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>
    <code class="k">return</code> <code class="n">a</code> <code class="o">+</code> <code class="n">b</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">fib</code><code class="p">(</code><code class="n">n</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>
    <code class="k">if</code> <code class="n">n</code> <code class="o">&lt;=</code> <code class="mi">1</code><code class="p">:</code>
        <code class="k">return</code> <code class="n">n</code>
    <code class="k">return</code> <code class="n">add</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">fib</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">n</code> <code class="o">-</code> <code class="mi">1</code><code class="p">),</code> <code class="n">fib</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">n</code> <code class="o">-</code> <code class="mi">2</code><code class="p">))</code>

<code class="k">assert</code> <code class="n">fib</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code><code class="o">.</code><code class="n">run</code><code class="p">()</code> <code class="o">==</code> <code class="mi">55</code></pre></div>
</div></section>








<section data-pdf-bookmark="Building Workflows with Conditional Steps" data-type="sect2"><div class="sect2" id="idm45354770050784">
<h2>Building Workflows with Conditional Steps</h2>

<p>Workflows <a data-primary="workflows" data-secondary="building" data-tertiary="with conditional steps" data-tertiary-sortas="conditional steps" data-type="indexterm" id="idm45354770022096"/><a data-primary="steps (workflow primitive)" data-secondary="building workflows" data-tertiary="with conditional steps" data-tertiary-sortas="conditional steps" data-type="indexterm" id="idm45354770020768"/><a data-primary="Ray Workflows" data-secondary="building workflows" data-tertiary="with conditional steps" data-tertiary-sortas="conditional steps" data-type="indexterm" id="idm45354770019376"/><a data-primary="conditional steps, building workflows with" data-type="indexterm" id="idm45354770017888"/>with conditional steps are central to many use cases. <a data-type="xref" href="#flight_booking_example">Example 8-7</a> shows a simplified scenario of a workflow implementing a trip booking.</p>
<div data-type="example" id="flight_booking_example">
<h5><span class="label">Example 8-7. </span><a href="https://oreil.ly/i7jro">Trip-booking example</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">book_flight</code><code class="p">(</code><code class="o">...</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Flight</code><code class="p">:</code> <code class="o">...</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">book_hotel</code><code class="p">(</code><code class="o">...</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Hotel</code><code class="p">:</code> <code class="o">...</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">finalize_or_cancel</code><code class="p">(</code>
    <code class="n">flights</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Flight</code><code class="p">],</code>
    <code class="n">hotels</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="n">Hotel</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">Receipt</code><code class="p">:</code> <code class="o">...</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">book_trip</code><code class="p">(</code><code class="n">origin</code><code class="p">:</code> <code class="nb">str</code><code class="p">,</code> <code class="n">dest</code><code class="p">:</code> <code class="nb">str</code><code class="p">,</code> <code class="n">dates</code><code class="p">)</code> <code class="o">-&gt;</code>
        <code class="s2">"Workflow[Receipt]"</code><code class="p">:</code>
    <code class="c1"># Note that the workflow engine will not begin executing</code>
    <code class="c1"># child workflows until the parent step returns.</code>
    <code class="c1"># This avoids step overlap and ensures recoverability.</code>
    <code class="n">f1</code><code class="p">:</code> <code class="n">Workflow</code> <code class="o">=</code> <code class="n">book_flight</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">origin</code><code class="p">,</code> <code class="n">dest</code><code class="p">,</code> <code class="n">dates</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code>
    <code class="n">f2</code><code class="p">:</code> <code class="n">Workflow</code> <code class="o">=</code> <code class="n">book_flight</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">dest</code><code class="p">,</code> <code class="n">origin</code><code class="p">,</code> <code class="n">dates</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code>
    <code class="n">hotel</code><code class="p">:</code> <code class="n">Workflow</code> <code class="o">=</code> <code class="n">book_hotel</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">dest</code><code class="p">,</code> <code class="n">dates</code><code class="p">)</code>
    <code class="k">return</code> <code class="n">finalize_or_cancel</code><code class="o">.</code><code class="n">step</code><code class="p">([</code><code class="n">f1</code><code class="p">,</code> <code class="n">f2</code><code class="p">],</code> <code class="p">[</code><code class="n">hotel</code><code class="p">])</code>

<code class="n">fut</code> <code class="o">=</code> <code class="n">book_trip</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="s2">"OAK"</code><code class="p">,</code> <code class="s2">"SAN"</code><code class="p">,</code> <code class="p">[</code><code class="s2">"6/12"</code><code class="p">,</code> <code class="s2">"7/5"</code><code class="p">])</code>
<code class="n">fut</code><code class="o">.</code><code class="n">run</code><code class="p">()</code>  <code class="c1"># Returns Receipt(...)</code></pre></div>
</div></section>








<section data-pdf-bookmark="Handling Exceptions" data-type="sect2"><div class="sect2" id="idm45354770011920">
<h2>Handling Exceptions</h2>

<p>You <a data-primary="Ray Workflows" data-secondary="exception handling" data-type="indexterm" id="idm45354770010544"/><a data-primary="workflows" data-secondary="exception handling" data-type="indexterm" id="idm45354769876160"/><a data-primary="exceptions" data-secondary="handling" data-type="indexterm" id="idm45354769875216"/><a data-primary="handling" data-secondary="exceptions" data-type="indexterm" id="idm45354769874272"/>can choose to have Ray handle exceptions in one of two ways:</p>

<ul>
<li>
<p>Automatic retry, until a maximum number of retries is reached</p>
</li>
<li>
<p>Catching and handling the exception</p>
</li>
</ul>

<p>You configure this in either the step decorator or via <code>.options</code>. You specify the settings for the two techniques, respectively, as follows:</p>
<dl>
<dt><code>max_retries</code></dt>
<dd>
<p>The step is retried upon failure until <code>max_retries</code> is reached. The <code>max_retries</code> default is <code>3</code>.</p>
</dd>
<dt><code>catch_exceptions</code></dt>
<dd>
<p>When <code>True</code>, this option will convert the return value of the function to a <code>Tuple[Optional[T], Optional[Exception]]</code>.</p>
</dd>
</dl>

<p>You can also pass these to the <code>workflow.step</code> decorator.</p>

<p><a data-type="xref" href="#exception_handling_example">Example 8-8</a> illustrates exception handling with these options.</p>
<div data-type="example" id="exception_handling_example">
<h5><span class="label">Example 8-8. </span><a href="https://oreil.ly/Itn5V">Exception handling</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>
<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">random_failure</code><code class="p">()</code> <code class="o">-&gt;</code> <code class="nb">str</code><code class="p">:</code>
    <code class="k">if</code> <code class="n">random</code><code class="o">.</code><code class="n">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.95</code><code class="p">:</code>
        <code class="k">raise</code> <code class="ne">RuntimeError</code><code class="p">(</code><code class="s2">"Found failure"</code><code class="p">)</code>
    <code class="k">return</code> <code class="s2">"OK"</code>

<code class="c1"># Run 5 times before giving up</code>
<code class="n">s1</code> <code class="o">=</code> <code class="n">faulty_function</code><code class="o">.</code><code class="n">options</code><code class="p">(</code><code class="n">max_retries</code><code class="o">=</code><code class="mi">5</code><code class="p">)</code><code class="o">.</code><code class="n">step</code><code class="p">()</code>
<code class="n">s1</code><code class="o">.</code><code class="n">run</code><code class="p">()</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">handle_errors</code><code class="p">(</code><code class="n">result</code><code class="p">:</code> <code class="n">Tuple</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="ne">Exception</code><code class="p">]):</code>
    <code class="c1"># Setting the exception field to NONE on success</code>
    <code class="n">err</code> <code class="o">=</code> <code class="n">result</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>
    <code class="k">if</code> <code class="n">err</code><code class="p">:</code>
        <code class="k">return</code> <code class="s2">"There was an error: </code><code class="si">{}</code><code class="s2">"</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="n">err</code><code class="p">)</code>
    <code class="k">else</code><code class="p">:</code>
        <code class="k">return</code> <code class="s2">"OK"</code>

<code class="c1"># `handle_errors` receives a tuple of (result, exception).</code>
<code class="n">s2</code> <code class="o">=</code> <code class="n">faulty_function</code><code class="o">.</code><code class="n">options</code><code class="p">(</code><code class="n">catch_exceptions</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code class="o">.</code><code class="n">step</code><code class="p">()</code>
<code class="n">handle_errors</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">s2</code><code class="p">)</code><code class="o">.</code><code class="n">run</code><code class="p">()</code></pre></div>
</div></section>








<section data-pdf-bookmark="Handling Durability Guarantees" data-type="sect2"><div class="sect2" id="idm45354769742528">
<h2>Handling Durability Guarantees</h2>

<p>Ray <a data-primary="Ray Workflows" data-secondary="durability guarantees" data-type="indexterm" id="idm45354769675568"/><a data-primary="workflows" data-secondary="durability guarantees" data-type="indexterm" id="idm45354769674624"/><a data-primary="durability guarantees, handling in workflows" data-type="indexterm" id="idm45354769673680"/><a data-primary="handling" data-secondary="durability guarantees in workflows" data-type="indexterm" id="idm45354769673040"/>Workflows ensures that once a step succeeds, it will never be reexecuted. To enforce this guarantee, Ray Workflows logs the step result to durable storage, ensuring that results from previous successful steps will not change when used in subsequent steps.</p>

<p>Ray’s workflows go beyond the durability of retrying within a cluster or single application. Workflows implements a failure model based on two statuses:</p>
<dl>
<dt>Cluster failure</dt>
<dd>
<p>If the cluster fails, any workflow running on the cluster is set to <code>RESUMABLE</code> state. Workflows in <code>RESUMABLE</code> state can be resumed on a different cluster. This can be done with <code>ray.workflow.resume.all</code>, which will resume all resumable workflow jobs.</p>
</dd>
<dt>Driver failure</dt>
<dd>
<p>The workflow will transition to the failed state, and once the issue is resolved, it can be resumed from the failed step.</p>
</dd>
</dl>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Workflow resumability is a beta API at the moment of writing and may change before becoming stable.</p>
</div>

<p>You can use durability guarantees to create idempotent workflows that include steps that have side effects. This is needed because a step can fail before its output is logged. <a data-type="xref" href="#idempotent_workflow_example">Example 8-9</a> shows how to use a durability guarantee to make a workflow idempotent.</p>
<div data-type="example" id="idempotent_workflow_example">
<h5><span class="label">Example 8-9. </span><a href="https://oreil.ly/wmmp1">Idempotent workflow</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">generate_id</code><code class="p">()</code> <code class="o">-&gt;</code> <code class="nb">str</code><code class="p">:</code>
   <code class="c1"># Generate a unique idempotency token.</code>
   <code class="k">return</code> <code class="n">uuid</code><code class="o">.</code><code class="n">uuid4</code><code class="p">()</code><code class="o">.</code><code class="n">hex</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">book_flight_idempotent</code><code class="p">(</code><code class="n">request_id</code><code class="p">:</code> <code class="nb">str</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">FlightTicket</code><code class="p">:</code>
   <code class="k">if</code> <code class="n">service</code><code class="o">.</code><code class="n">has_ticket</code><code class="p">(</code><code class="n">request_id</code><code class="p">):</code>
       <code class="c1"># Retrieve the previously created ticket.</code>
       <code class="k">return</code> <code class="n">service</code><code class="o">.</code><code class="n">get_ticket</code><code class="p">(</code><code class="n">request_id</code><code class="p">)</code>
   <code class="k">return</code> <code class="n">service</code><code class="o">.</code><code class="n">book_flight</code><code class="p">(</code><code class="n">request_id</code><code class="p">)</code>

<code class="c1"># SAFE: book_flight is written to be idempotent</code>
<code class="n">request_id</code> <code class="o">=</code> <code class="n">generate_id</code><code class="o">.</code><code class="n">step</code><code class="p">()</code>
<code class="n">book_flight_idempotent</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">request_id</code><code class="p">)</code><code class="o">.</code><code class="n">run</code><code class="p">()</code></pre></div>
</div></section>








<section data-pdf-bookmark="Extending Dynamic Workflows with Virtual Actors" data-type="sect2"><div class="sect2" id="idm45354769563648">
<h2>Extending Dynamic Workflows with Virtual Actors</h2>

<p>Virtual actors, <a data-primary="Ray Workflows" data-secondary="extending dynamic workflows with virtual actors" data-type="indexterm" id="ray-workflow-extend"/><a data-primary="workflows" data-secondary="dynamic" data-tertiary="extending with virtual actors" data-type="indexterm" id="workflow-dynamic-extend"/><a data-primary="dynamic workflows" data-secondary="extending with virtual actors" data-type="indexterm" id="dynamic-workflow-extend"/><a data-primary="extending dynamic workflows with virtual actors" data-type="indexterm" id="extend-dynamic-workflow"/><a data-primary="virtual actors" data-secondary="extending dynamic workflows" data-type="indexterm" id="virtual-actor-extend-dynamic"/>described previously, also allow subworkflows to be called from each of their methods.</p>

<p>When you create a virtual actor, Ray stores its initial state and class definition in durable storage. As a workflow name is used in the actor’s definition, Ray stores it in durable storage. When the actor’s method creates new steps, they are dynamically appended to the workflow and executed. In this case, both the step definition and its result are stored in the actor’s state. To retrieve the actor, you can use the decorator <code>.get_actor(workflow_id="workflow_id")</code>.</p>

<p>You can also define workflows as read-only. Because they don’t require logging, they incur less overhead. Additionally, because they don’t imply conflict issues with mutating methods in the actor, Ray can execute them concurrently.</p>

<p><a data-type="xref" href="#virtual_actor_workflow_example">Example 8-10</a> shows how virtual actors can be used to manage state in a workflow.</p>
<div data-type="example" id="virtual_actor_workflow_example">
<h5><span class="label">Example 8-10. </span><a href="https://oreil.ly/zTWOk">Workflow management with virtual actors</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>
<code class="kn">import</code> <code class="nn">ray</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">virtual_actor</code>
<code class="k">class</code> <code class="nc">Counter</code><code class="p">:</code>
    <code class="k">def</code> <code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">init_val</code><code class="p">):</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">_val</code> <code class="o">=</code> <code class="n">init_val</code>

    <code class="k">def</code> <code class="nf">incr</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">val</code><code class="o">=</code><code class="mi">1</code><code class="p">):</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">_val</code> <code class="o">+=</code> <code class="n">val</code>
        <code class="nb">print</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">_val</code><code class="p">)</code>

    <code class="nd">@workflow</code><code class="o">.</code><code class="n">virtual_actor</code><code class="o">.</code><code class="n">readonly</code>
    <code class="k">def</code> <code class="nf">value</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">_val</code>

<code class="n">workflow</code><code class="o">.</code><code class="n">init</code><code class="p">()</code>

<code class="c1"># Initialize a Counter actor with id="my_counter".</code>
<code class="n">counter</code> <code class="o">=</code> <code class="n">Counter</code><code class="o">.</code><code class="n">get_or_create</code><code class="p">(</code><code class="s2">"my_counter"</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>

<code class="c1"># Similar to workflow steps, actor methods support:</code>
<code class="c1"># - `run()`, which will return the value</code>
<code class="c1"># - `run_async()`, which will return a ObjectRef</code>
<code class="n">counter</code><code class="o">.</code><code class="n">incr</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>
<code class="k">assert</code> <code class="n">counter</code><code class="o">.</code><code class="n">value</code><code class="o">.</code><code class="n">run</code><code class="p">()</code> <code class="o">==</code> <code class="mi">10</code>

<code class="c1"># Nonblocking execution.</code>
<code class="n">counter</code><code class="o">.</code><code class="n">incr</code><code class="o">.</code><code class="n">run_async</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>
<code class="n">counter</code><code class="o">.</code><code class="n">incr</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>
<code class="k">assert</code> <code class="mi">30</code> <code class="o">==</code> <code class="n">ray</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="n">counter</code><code class="o">.</code><code class="n">value</code><code class="o">.</code><code class="n">run_async</code><code class="p">())</code></pre></div>

<p>Virtual actors can also create subworkflows that involve other methods in the virtual actor or steps defined outside the actor class to be invoked. This means that a workflow can be launched inside a method or passed to another method. See 
<span class="keep-together"><a data-type="xref" href="#subworkflow_example">Example 8-11</a></span>.</p>
<div data-type="example" id="subworkflow_example">
<h5><span class="label">Example 8-11. </span><a href="https://oreil.ly/exFyJ">Using subworkflows</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>
<code class="kn">import</code> <code class="nn">ray</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">double</code><code class="p">(</code><code class="n">s</code><code class="p">):</code>
    <code class="k">return</code> <code class="mi">2</code> <code class="o">*</code> <code class="n">s</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">virtual_actor</code>
<code class="k">class</code> <code class="nc">Actor</code><code class="p">:</code>
    <code class="k">def</code> <code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">val</code> <code class="o">=</code> <code class="mi">1</code>

    <code class="k">def</code> <code class="nf">double</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">update</code><code class="p">):</code>
        <code class="n">step</code> <code class="o">=</code> <code class="n">double</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">val</code><code class="p">)</code>
        <code class="k">if</code> <code class="ow">not</code> <code class="n">update</code><code class="p">:</code>
            <code class="c1"># Inside the method, a workflow can be launched</code>
            <code class="k">return</code> <code class="n">step</code>
        <code class="k">else</code><code class="p">:</code>
            <code class="c1"># Workflow can also be passed to another method</code>
            <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">update</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">step</code><code class="p">)</code>

    <code class="k">def</code> <code class="nf">update</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">v</code><code class="p">):</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">val</code> <code class="o">=</code> <code class="n">v</code>
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">val</code>


<code class="n">handler</code> <code class="o">=</code> <code class="n">Actor</code><code class="o">.</code><code class="n">get_or_create</code><code class="p">(</code><code class="s2">"actor"</code><code class="p">)</code>
<code class="k">assert</code> <code class="n">handler</code><code class="o">.</code><code class="n">double</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="kc">False</code><code class="p">)</code> <code class="o">==</code> <code class="mi">2</code>
<code class="k">assert</code> <code class="n">handler</code><code class="o">.</code><code class="n">double</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="kc">False</code><code class="p">)</code> <code class="o">==</code> <code class="mi">2</code>
<code class="k">assert</code> <code class="n">handler</code><code class="o">.</code><code class="n">double</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="kc">True</code><code class="p">)</code> <code class="o">==</code> <code class="mi">2</code>
<code class="k">assert</code> <code class="n">handler</code><code class="o">.</code><code class="n">double</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="kc">True</code><code class="p">)</code> <code class="o">==</code> <code class="mi">4</code></pre></div>

<p>Virtual actors can also be used for sharing data among multiple workflows (even running on different Ray clusters). For example, virtual actors may be used to store fitted parameters in an ML model such as a Python scikit-learn pipeline. <a data-type="xref" href="#machine_learning_workflow">Example 8-12</a> illustrates a simple two-stage pipeline consisting of a standard scalar followed by a decision tree classifier. Each stage is implemented as a workflow step, directly invoking an instance of a virtual actor defined in the class <code>estimator_virtual_actor</code>. Its member estimator uses the <code>getstate</code> and <code>setstate</code> methods to convert its state to and from the JSON serializable dictionary. The pipeline is trained when the third input parameter of the input tuple is specified as <code>'fit'</code>, and the pipeline is used for prediction when that parameter is specified as <code>'predict'</code>.</p>

<p>To train a pipeline, the workflow execution submits <code>training_tuple</code> to the standard scalar, whose output is then piped through the classification model to train:</p>

<pre data-code-language="python" data-type="programlisting"><code class="n">training_tuple</code> <code class="o">=</code> <code class="p">(</code><code class="n">X_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="s1">'fit'</code><code class="p">)</code>
<code class="n">classification</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">scaling</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">training_tuple</code><code class="p">,</code> <code class="s1">'standardscalar'</code><code class="p">),</code>
                    <code class="s1">'decisiontree'</code><code class="p">)</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s1">'training_pipeline'</code><code class="p">)</code></pre>

<p>To use the trained pipeline for prediction, the workflow execution submits 
<span class="keep-together"><code>predict_tuple</code></span> to the same chain of steps, although its <code>'predict'</code> parameter invokes the <code>predict</code> function in the virtual actor. The prediction result is returned as another tuple with labels found in <code>pred_y</code>:</p>

<pre data-code-language="python" data-type="programlisting"><code class="n">predict_tuple</code> <code class="o">=</code> <code class="p">(</code><code class="n">X_test</code><code class="p">,</code> <code class="n">y_test</code><code class="p">,</code> <code class="s1">'predict'</code><code class="p">)</code>
<code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">pred_y</code><code class="p">,</code> <code class="n">mode</code><code class="p">)</code> <code class="o">=</code> <code class="n">classification</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">scaling</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">predict_tuple</code><code class="p">,</code>
  <code class="s1">'standardscalar'</code><code class="p">),</code><code class="s1">'decisiontree'</code><code class="p">)</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s1">'prediction_pipeline'</code><code class="p">)</code></pre>

<p class="pagebreak-after">The power of the workflow virtual actor is to make the trained model available to another Ray cluster. Furthermore, the ML workflow backed by a virtual actor can incrementally update its state, such as recalculated time-series features. This makes it easier to implement stateful time-series analysis, including forecasting, prediction, and anomaly detection.</p>
<div class="less_space" data-type="example" id="machine_learning_workflow">
<h5><span class="label">Example 8-12. </span><a href="https://oreil.ly/mQBVn">Machine learning workflow</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code> <code class="nn">ray</code>
<code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>

<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>
<code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>
<code class="kn">from</code> <code class="nn">sklearn</code> <code class="kn">import</code> <code class="n">base</code>
<code class="kn">from</code> <code class="nn">sklearn.base</code> <code class="kn">import</code> <code class="n">BaseEstimator</code>
<code class="kn">from</code> <code class="nn">sklearn.preprocessing</code> <code class="kn">import</code> <code class="n">StandardScaler</code>
<code class="kn">from</code> <code class="nn">sklearn.tree</code> <code class="kn">import</code> <code class="n">DecisionTreeClassifier</code>
<code class="kn">from</code> <code class="nn">sklearn.model_selection</code> <code class="kn">import</code> <code class="n">train_test_split</code>

<code class="n">ray</code><code class="o">.</code><code class="n">init</code><code class="p">(</code><code class="n">address</code><code class="o">=</code><code class="s1">'auto'</code><code class="p">)</code>
<code class="n">workflow</code><code class="o">.</code><code class="n">init</code><code class="p">()</code>

<code class="nd">@ray</code><code class="o">.</code><code class="n">workflow</code><code class="o">.</code><code class="n">virtual_actor</code>
<code class="k">class</code> <code class="nc">estimator_virtual_actor</code><code class="p">():</code>
    <code class="k">def</code> <code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">estimator</code><code class="p">:</code> <code class="n">BaseEstimator</code><code class="p">):</code>
        <code class="k">if</code> <code class="n">estimator</code> <code class="ow">is</code> <code class="ow">not</code> <code class="kc">None</code><code class="p">:</code>
            <code class="bp">self</code><code class="o">.</code><code class="n">estimator</code> <code class="o">=</code> <code class="n">estimator</code>

    <code class="k">def</code> <code class="nf">fit</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">inputtuple</code><code class="p">):</code>
        <code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">mode</code><code class="p">)</code><code class="o">=</code> <code class="n">inputtuple</code>
        <code class="k">if</code> <code class="n">base</code><code class="o">.</code><code class="n">is_classifier</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">estimator</code><code class="p">)</code> <code class="ow">or</code> <code class="n">base</code><code class="o">.</code><code class="n">is_regressor</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">estimator</code><code class="p">):</code>
            <code class="bp">self</code><code class="o">.</code><code class="n">estimator</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">y</code><code class="p">)</code>
            <code class="k">return</code> <code class="n">X</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">mode</code>
        <code class="k">else</code><code class="p">:</code>
            <code class="n">X</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">estimator</code><code class="o">.</code><code class="n">fit_transform</code><code class="p">(</code><code class="n">X</code><code class="p">)</code>
            <code class="k">return</code> <code class="n">X</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">mode</code>

    <code class="nd">@workflow</code><code class="o">.</code><code class="n">virtual_actor</code><code class="o">.</code><code class="n">readonly</code>
    <code class="k">def</code> <code class="nf">predict</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">inputtuple</code><code class="p">):</code>
        <code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">mode</code><code class="p">)</code> <code class="o">=</code> <code class="n">inputtuple</code>
        <code class="k">if</code> <code class="n">base</code><code class="o">.</code><code class="n">is_classifier</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">estimator</code><code class="p">)</code> <code class="ow">or</code> <code class="n">base</code><code class="o">.</code><code class="n">is_regressor</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">estimator</code><code class="p">):</code>
            <code class="n">pred_y</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">estimator</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">X</code><code class="p">)</code>
            <code class="k">return</code> <code class="n">X</code><code class="p">,</code> <code class="n">pred_y</code><code class="p">,</code> <code class="n">mode</code>
        <code class="k">else</code><code class="p">:</code>
            <code class="n">X</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">estimator</code><code class="o">.</code><code class="n">transform</code><code class="p">(</code><code class="n">X</code><code class="p">)</code>
            <code class="k">return</code> <code class="n">X</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">mode</code>

    <code class="k">def</code> <code class="nf">run_workflow_step</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">inputtuple</code><code class="p">):</code>
        <code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">mode</code><code class="p">)</code> <code class="o">=</code> <code class="n">inputtuple</code>
        <code class="k">if</code> <code class="n">mode</code> <code class="o">==</code> <code class="s1">'fit'</code><code class="p">:</code>
            <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">fit</code><code class="p">(</code><code class="n">inputtuple</code><code class="p">)</code>
        <code class="k">elif</code> <code class="n">mode</code> <code class="o">==</code> <code class="s1">'predict'</code><code class="p">:</code>
            <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">predict</code><code class="p">(</code><code class="n">inputtuple</code><code class="p">)</code>

    <code class="k">def</code> <code class="nf">__getstate__</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">estimator</code>

    <code class="k">def</code> <code class="nf">__setstate__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">estimator</code><code class="p">):</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">estimator</code> <code class="o">=</code> <code class="n">estimator</code>

<code class="c1">## Prepare the data</code>
<code class="n">X</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">randint</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">100</code><code class="p">,</code><code class="n">size</code><code class="o">=</code><code class="p">(</code><code class="mi">10000</code><code class="p">,</code> <code class="mi">4</code><code class="p">)),</code> <code class="n">columns</code><code class="o">=</code><code class="nb">list</code><code class="p">(</code><code class="s1">'ABCD'</code><code class="p">))</code>
<code class="n">y</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">randint</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="n">size</code><code class="o">=</code><code class="p">(</code><code class="mi">10000</code><code class="p">,</code> <code class="mi">1</code><code class="p">)),</code> <code class="n">columns</code><code class="o">=</code><code class="p">[</code><code class="s1">'Label'</code><code class="p">])</code>

<code class="n">X_train</code><code class="p">,</code> <code class="n">X_test</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="n">y_test</code> <code class="o">=</code> <code class="n">train_test_split</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">test_size</code><code class="o">=</code><code class="mf">0.2</code><code class="p">)</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">scaling</code><code class="p">(</code><code class="n">inputtuple</code><code class="p">,</code> <code class="n">name</code><code class="p">):</code>
    <code class="n">va</code> <code class="o">=</code> <code class="n">estimator_virtual_actor</code><code class="o">.</code><code class="n">get_or_create</code><code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="n">StandardScaler</code><code class="p">())</code>
    <code class="n">outputtuple</code> <code class="o">=</code> <code class="n">va</code><code class="o">.</code><code class="n">run_workflow_step</code><code class="o">.</code><code class="n">run_async</code><code class="p">(</code><code class="n">inputtuple</code><code class="p">)</code>
    <code class="k">return</code> <code class="n">outputtuple</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">classification</code><code class="p">(</code><code class="n">inputtuple</code><code class="p">,</code> <code class="n">name</code><code class="p">):</code>
    <code class="n">va</code> <code class="o">=</code> <code class="n">estimator_virtual_actor</code><code class="o">.</code><code class="n">get_or_create</code><code class="p">(</code><code class="n">name</code><code class="p">,</code>
                                               <code class="n">DecisionTreeClassifier</code><code class="p">(</code><code class="n">max_depth</code><code class="o">=</code><code class="mi">3</code><code class="p">))</code>
    <code class="n">outputtuple</code> <code class="o">=</code> <code class="n">va</code><code class="o">.</code><code class="n">run_workflow_step</code><code class="o">.</code><code class="n">run_async</code><code class="p">(</code><code class="n">inputtuple</code><code class="p">)</code>
    <code class="k">return</code> <code class="n">outputtuple</code>

<code class="n">training_tuple</code> <code class="o">=</code> <code class="p">(</code><code class="n">X_train</code><code class="p">,</code> <code class="n">y_train</code><code class="p">,</code> <code class="s1">'fit'</code><code class="p">)</code>
<code class="n">classification</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">scaling</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">training_tuple</code><code class="p">,</code> <code class="s1">'standardscalar'</code><code class="p">),</code> <code class="s1">'decisiontree'</code><code class="p">)</code><code class="o">.</code>
                    <code class="n">run</code><code class="p">(</code><code class="s1">'training_pipeline'</code><code class="p">)</code>

<code class="n">predict_tuple</code> <code class="o">=</code> <code class="p">(</code><code class="n">X_test</code><code class="p">,</code> <code class="n">y_test</code><code class="p">,</code> <code class="s1">'predict'</code><code class="p">)</code>
<code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">pred_y</code><code class="p">,</code> <code class="n">mode</code><code class="p">)</code> <code class="o">=</code> <code class="n">classification</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">scaling</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">predict_tuple</code><code class="p">,</code>
  <code class="s1">'standardscalar'</code><code class="p">),</code><code class="s1">'decisiontree'</code><code class="p">)</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s1">'prediction_pipeline'</code><code class="p">)</code>
<code class="k">assert</code> <code class="n">pred_y</code><code class="o">.</code><code class="n">shape</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">==</code> <code class="mi">2000</code></pre></div>

<p>Long-running workflows require special attention when used as subworkflows, since subworkflows block future actor calls when running. To properly handle long-running workflows, it is recommended to use the Workflows API to monitor execution and to run separate workflows with deterministic names. This approach prevents a duplicate workflow from being launched in the case of a failure.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Subworkflows block future actor method calls. It is not recommended to run a long running workflow as a subworkflow of a virtual actor.</p>
</div>

<p><a data-type="xref" href="#non_blocking_example">Example 8-13</a> shows how to run a long-running workflow <a data-primary="Ray Workflows" data-secondary="extending dynamic workflows with virtual actors" data-startref="ray-workflow-extend" data-type="indexterm" id="idm45354768412192"/><a data-primary="workflows" data-secondary="dynamic" data-startref="workflow-dynamic-extend" data-tertiary="extending with virtual actors" data-type="indexterm" id="idm45354768411008"/><a data-primary="dynamic workflows" data-secondary="extending with virtual actors" data-startref="dynamic-workflow-extend" data-type="indexterm" id="idm45354768409552"/><a data-primary="extending dynamic workflows with virtual actors" data-startref="extend-dynamic-workflow" data-type="indexterm" id="idm45354768408368"/><a data-primary="virtual actors" data-secondary="extending dynamic workflows" data-startref="virtual-actor-extend-dynamic" data-type="indexterm" id="idm45354768407456"/>without blocking.</p>
<div data-type="example" id="non_blocking_example">
<h5><span class="label">Example 8-13. </span><a href="https://oreil.ly/eRs6K">Nonblocking workflow</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>
<code class="kn">import</code> <code class="nn">ray</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">virtual_actor</code>
<code class="k">class</code> <code class="nc">ShoppingCart</code><code class="p">:</code>
    <code class="o">...</code>
    <code class="c1"># Check status via ``self.shipment_workflow_id`` for avoid blocking</code>
    <code class="k">def</code> <code class="nf">do_checkout</code><code class="p">():</code>
        <code class="c1"># Deterministically generate a workflow ID for idempotency.</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">shipment_workflow_id</code> <code class="o">=</code> <code class="s2">"ship_</code><code class="si">{}</code><code class="s2">"</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">order_id</code><code class="p">)</code>
        <code class="c1"># Run shipping workflow as a separate async workflow.</code>
        <code class="n">ship_items</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">items</code><code class="p">)</code><code class="o">.</code><code class="n">run_async</code><code class="p">(</code>
            <code class="n">workflow_id</code><code class="o">=</code><code class="bp">self</code><code class="o">.</code><code class="n">shipment_workflow_id</code><code class="p">)</code></pre></div>
</div></section>








<section data-pdf-bookmark="Integrating Workflows with Other Ray Primitives" data-type="sect2"><div class="sect2" id="idm45354785649952">
<h2>Integrating Workflows with Other Ray Primitives</h2>

<p>Ray workflows <a data-primary="Ray Workflows" data-secondary="integrating with other primitives" data-type="indexterm" id="ray-workflow-integrate"/><a data-primary="workflows" data-secondary="integrating with other primitives" data-type="indexterm" id="workflow-integrate"/><a data-primary="integrating workflows with other primitives" data-type="indexterm" id="integrate-workflow"/><a data-primary="primitives" data-secondary="integrating with workflows" data-type="indexterm" id="primitive-integrate"/><a data-primary="remote actors" data-secondary="integrating with workflows" data-type="indexterm" id="remote-actor-integrate"/>can be used with Ray’s core primitives. Here we will describe some common scenarios where the Workflows API is integrated with a common Ray program. There are two main scenarios when integrating workflows with tasks and actors:</p>

<ul>
<li>
<p>Running a workflow from within a Ray task or actor</p>
</li>
<li>
<p>Using a Ray task or actor within a workflow step</p>
</li>
</ul>

<p>Another common case is passing object references between steps in a workflow. Ray object references can be passed as arguments and returned from any workflow step, as shown in <a data-type="xref" href="#object_reference_example">Example 8-14</a>.</p>
<div data-type="example" id="object_reference_example">
<h5><span class="label">Example 8-14. </span><a href="https://oreil.ly/NaZs2">Using object references</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>

<code class="nd">@ray</code><code class="o">.</code><code class="n">remote</code>
<code class="k">def</code> <code class="nf">do_add</code><code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="n">b</code><code class="p">):</code>
    <code class="k">return</code> <code class="n">a</code> <code class="o">+</code> <code class="n">b</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">add</code><code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="n">b</code><code class="p">):</code>
    <code class="k">return</code> <code class="n">do_add</code><code class="o">.</code><code class="n">remote</code><code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="n">b</code><code class="p">)</code>

<code class="n">add</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">ray</code><code class="o">.</code><code class="n">put</code><code class="p">(</code><code class="mi">10</code><code class="p">),</code> <code class="n">ray</code><code class="o">.</code><code class="n">put</code><code class="p">(</code><code class="mi">20</code><code class="p">))</code><code class="o">.</code><code class="n">run</code><code class="p">()</code> <code class="o">==</code> <code class="mi">30</code></pre></div>

<p>To ensure recoverability, Ray Workflows logs the contents to persistent storage. Thankfully, when passed to multiple steps, Ray will not checkpoint the object more than once.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Ray actor handlers cannot be passed between steps.</p>
</div>

<p>Another consideration when integrating actors and tasks with Workflows is handling nested arguments. As described before, workflow outputs are fully resolved when passed to a step, as a form to guarantee that all the ancestors of a step are executed before the current step is executed. <a data-type="xref" href="#output_arguments_example">Example 8-15</a> illustrates this <a data-primary="Ray Workflows" data-secondary="integrating with other primitives" data-startref="ray-workflow-integrate" data-type="indexterm" id="idm45354768134480"/><a data-primary="workflows" data-secondary="integrating with other primitives" data-startref="workflow-integrate" data-type="indexterm" id="idm45354768133264"/><a data-primary="integrating workflows with other primitives" data-startref="integrate-workflow" data-type="indexterm" id="idm45354768132080"/><a data-primary="primitives" data-secondary="integrating with workflows" data-startref="primitive-integrate" data-type="indexterm" id="idm45354768131168"/><a data-primary="remote actors" data-secondary="integrating with workflows" data-startref="remote-actor-integrate" data-type="indexterm" id="idm45354768118208"/>behavior.</p>
<div data-type="example" id="output_arguments_example">
<h5><span class="label">Example 8-15. </span><a href="https://oreil.ly/RiOl3">Using output arguments</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code> <code class="nn">ray</code>
<code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>
<code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">List</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">add</code><code class="p">(</code><code class="n">values</code><code class="p">:</code> <code class="n">List</code><code class="p">[</code><code class="nb">int</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>
    <code class="k">return</code> <code class="nb">sum</code><code class="p">(</code><code class="n">values</code><code class="p">)</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">get_val</code><code class="p">()</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>
    <code class="k">return</code> <code class="mi">10</code>

<code class="n">ret</code> <code class="o">=</code> <code class="n">add</code><code class="o">.</code><code class="n">step</code><code class="p">([</code><code class="n">get_val</code><code class="o">.</code><code class="n">step</code><code class="p">()</code> <code class="k">for</code> <code class="n">_</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">3</code><code class="p">)])</code>
<code class="k">assert</code> <code class="n">ret</code><code class="o">.</code><code class="n">run</code><code class="p">()</code> <code class="o">==</code> <code class="mi">30</code></pre></div>
</div></section>








<section data-pdf-bookmark="Triggering Workflows (Connecting to Events)" data-type="sect2"><div class="sect2" id="idm45354768086512">
<h2>Triggering Workflows (Connecting to Events)</h2>

<p>Workflows <a data-primary="Ray Workflows" data-secondary="triggering workflows" data-type="indexterm" id="ray-workflow-trigger"/><a data-primary="workflows" data-secondary="triggering" data-type="indexterm" id="workflow-trigger"/><a data-primary="triggering workflows" data-type="indexterm" id="trigger-workflow"/><a data-primary="events" data-secondary="connecting to workflows" data-type="indexterm" id="events-connect-workflow"/>has a pluggable event system, allowing external events to trigger workflows. This framework provides an efficient built-in wait mechanism and guarantee of exactly-once event delivery semantics. This implies that the user doesn’t need to implement a trigger mechanism based on a running workflow step to react to an event. As with the rest of workflows, for fault-tolerance, events are checkpointed upon occurrence.</p>

<p>Workflow <em>events</em> can be seen as a type of workflow step that completes only when the event occurs. The decorator <code>.wait_for_event</code> is used to create an event step.</p>

<p><a data-type="xref" href="#event_integration_example">Example 8-16</a> shows a workflow step that finishes after 90 seconds and triggers the execution for an outer workflow.</p>
<div data-type="example" id="event_integration_example">
<h5><span class="label">Example 8-16. </span><a href="https://oreil.ly/7hwaG">Using events</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>
<code class="kn">import</code> <code class="nn">time</code>

<code class="c1"># Create an event that finishes after 60 seconds.</code>
<code class="n">event1_step</code> <code class="o">=</code> <code class="n">workflow</code><code class="o">.</code><code class="n">wait_for_event</code><code class="p">(</code>
    <code class="n">workflow</code><code class="o">.</code><code class="n">event_listener</code><code class="o">.</code><code class="n">TimerListener</code><code class="p">,</code> <code class="n">time</code><code class="o">.</code><code class="n">time</code><code class="p">()</code> <code class="o">+</code> <code class="mi">60</code><code class="p">)</code>

<code class="c1"># Create another event that finishes after 30 seconds.</code>
<code class="n">event2_step</code> <code class="o">=</code> <code class="n">workflow</code><code class="o">.</code><code class="n">wait_for_event</code><code class="p">(</code>
    <code class="n">workflow</code><code class="o">.</code><code class="n">event_listener</code><code class="o">.</code><code class="n">TimerListener</code><code class="p">,</code> <code class="n">time</code><code class="o">.</code><code class="n">time</code><code class="p">()</code> <code class="o">+</code> <code class="mi">30</code><code class="p">)</code>

<code class="nd">@workflow</code><code class="o">.</code><code class="n">step</code>
<code class="k">def</code> <code class="nf">gather</code><code class="p">(</code><code class="o">*</code><code class="n">args</code><code class="p">):</code>
    <code class="k">return</code> <code class="n">args</code><code class="p">;</code>

<code class="c1"># Gather will run after 60 seconds, when both event1 and event2 are done.</code>
<code class="n">gather</code><code class="o">.</code><code class="n">step</code><code class="p">(</code><code class="n">event1_step</code><code class="p">,</code> <code class="n">event2_step</code><code class="p">)</code><code class="o">.</code><code class="n">run</code><code class="p">()</code></pre></div>

<p>Events also support customer listeners by subclassing the <code>EventListener</code> interface, as shown <a data-primary="Ray Workflows" data-secondary="triggering workflows" data-startref="ray-workflow-trigger" data-type="indexterm" id="idm45354767926464"/><a data-primary="workflows" data-secondary="triggering" data-startref="workflow-trigger" data-type="indexterm" id="idm45354767887712"/><a data-primary="triggering workflows" data-startref="trigger-workflow" data-type="indexterm" id="idm45354767886624"/><a data-primary="events" data-secondary="connecting to workflows" data-startref="events-connect-workflow" data-type="indexterm" id="idm45354767885680"/>in <a data-type="xref" href="#custom_listeners_example">Example 8-17</a>.</p>
<div data-type="example" id="custom_listeners_example">
<h5><span class="label">Example 8-17. </span><a href="https://oreil.ly/3j532">Custom event listeners</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">ray</code> <code class="kn">import</code> <code class="n">workflow</code>
<code class="k">class</code> <code class="nc">EventListener</code><code class="p">:</code>
    <code class="k">def</code> <code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>
        <code class="sd">"""Optional constructor. Only the constructor with no arguments will be</code>
<code class="sd">          called."""</code>
        <code class="k">pass</code>

    <code class="k">async</code> <code class="k">def</code> <code class="nf">poll_for_event</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="o">*</code><code class="n">args</code><code class="p">,</code> <code class="o">**</code><code class="n">kwargs</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Event</code><code class="p">:</code>
        <code class="sd">"""Should return only when the event is received."""</code>
        <code class="k">raise</code> <code class="ne">NotImplementedError</code>

    <code class="k">async</code> <code class="k">def</code> <code class="nf">event_checkpointed</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">event</code><code class="p">:</code> <code class="n">Event</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="kc">None</code><code class="p">:</code>
        <code class="sd">"""Optional. Called after an event has been checkpointed and a transaction</code>
<code class="sd">          can be safely committed."""</code>
        <code class="k">pass</code></pre></div>
</div></section>








<section data-pdf-bookmark="Working with Workflow Metadata" data-type="sect2"><div class="sect2" id="idm45354767863536">
<h2>Working with Workflow Metadata</h2>

<p>One of <a data-primary="Ray Workflows" data-secondary="workflow metadata" data-type="indexterm" id="ray-workflow-metadata"/><a data-primary="workflows" data-secondary="metadata" data-type="indexterm" id="workflow-metadata"/><a data-primary="metadata for workflows" data-type="indexterm" id="metadata-workflows"/>the important requirements for workflow execution is observability. Typically, you want not only to see the workflow execution results but also to get the information about the internal states (e.g., paths that execution took, their performance, and values of variables). Ray’s <a href="https://oreil.ly/kgiX2">workflow metadata</a> provides support for some of the standard and user-defined metadata options. Standard metadata is split between workflow-level metadata:</p>
<dl>
<dt><code>status</code></dt>
<dd>
<p>Workflow states, which can be one of <code>RUNNING</code>, <code>FAILED</code>, <code>RESUMABLE</code>, <code>CANCELED</code>, or <code>SUCCESSFUL</code></p>
</dd>
<dt><code>user_metadata</code></dt>
<dd>
<p>A Python dictionary of custom metadata by the user via <code>workflow.run</code></p>
</dd>
<dt><code>stats</code></dt>
<dd>
<p>Workflow running stats, including workflow start time and end time</p>
</dd>
</dl>

<p>And step-level metadata:</p>
<dl>
<dt><code>name</code></dt>
<dd>
<p>Name of <a data-primary="steps (workflow primitive)" data-secondary="metadata" data-type="indexterm" id="idm45354767834384"/>the step, either provided by the user via <code>step.options</code> or generated by the system</p>
</dd>
<dt><code>step_options</code></dt>
<dd>
<p>Options of the step, either provided by the user via <code>step.options</code> or the system default</p>
</dd>
<dt><code>user_metadata</code></dt>
<dd>
<p>A Python dictionary of custom metadata by the user via <code>step.options</code></p>
</dd>
<dt><code>stats</code></dt>
<dd>
<p>The step’s running stats, including step start time and end time</p>
</dd>
</dl>

<p>Ray Workflows provides a simple API to obtain standard metadata:</p>

<pre data-type="programlisting">workflow.get_metadata(workflow_id)</pre>

<p>You can also get metadata about the workflow and a step:</p>

<pre data-type="programlisting">workflow.get_metadata(workflow_id, name=&lt;<em>step name</em>&gt;)</pre>

<p>Both versions of the API return a dictionary containing all the metadata for either the workflow itself or an individual step.</p>

<p>In addition to the standard metadata, you can add custom ones, capturing parameters of interest either in the workflow or specific step:</p>

<ul>
<li>
<p>Workflow-level metadata can be added via <code>.run(metadata=metadata)</code>.</p>
</li>
<li>
<p>Step-level metadata can be added via <code>.options(metadata=metadata)</code> or in the decorator <code>@workflow.step(metadata=metadata)</code>.</p>
</li>
</ul>

<p>Finally, you can expose metadata from the virtual actors execution and also retrieve workflow/steps metadata to control execution.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The metrics that you add to Ray metrics are exposed as Prometheus metrics, just like Ray’s built-in metrics.</p>
</div>

<p>Be aware that <code>get_metadata</code> returns an immediate result at invocation time, which means that not all fields might be available in the<a data-primary="Ray Workflows" data-secondary="workflow metadata" data-startref="ray-workflow-metadata" data-type="indexterm" id="idm45354767764960"/><a data-primary="workflows" data-secondary="metadata" data-startref="workflow-metadata" data-type="indexterm" id="idm45354767763712"/><a data-primary="metadata for workflows" data-startref="metadata-workflows" data-type="indexterm" id="idm45354767762496"/> result.</p>
</div></section>
</div></section>






<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="idm45354770358480">
<h1>Conclusion</h1>

<p>In this chapter, you learned how Ray Workflows adds workflow primitives to Ray, allowing you to create dynamic pipelines with rich workflow management support. Ray Workflows allows you to create common pipelines involving multiple steps, like data preprocessing, training, and long-running business workflows. With Ray, the possibility of a programmatic workflow execution engine became feasible with a shared interface with Ray tasks and actors. This capability can greatly reduce the burden of orchestrating workflows and embedding workflow logic into application steps.</p>

<p>This said, be aware that Ray remote functions (see <a data-type="xref" href="ch03.html#ch03">Chapter 3</a>) provide basic execution sequencing and fork/merge capabilities based on an argument’s availability. As a result, for some simple use cases, using Ray Workflows might seem like overkill, but if you need execution reliability, restartability, programmatic control, and metadata management (which you typically do), Ray Workflows is a preferred implementation approach.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45354770928336"><sup><a href="ch08.html#idm45354770928336-marker">1</a></sup> The approach was originally introduced by <a href="https://oreil.ly/UNfII">Cadence workflow</a>. Cadence consists of a programming framework (or client library) that provides what its documentation calls a “fault-oblivious” stateful programming model, allowing developers to create workflows the same way they are writing normal code.</p></div></div></section></body></html>