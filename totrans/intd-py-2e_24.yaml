- en: Chapter 22\. Py Sci
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第22章。Py Sci
- en: In her reign the power of steam
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在她统治期间，蒸汽的力量
- en: On land and sea became supreme,
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在陆地和海上变得无与伦比，
- en: And all now have strong reliance
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在所有都有强烈的依赖
- en: In fresh victories of science.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在科学的新胜利中。
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: James McIntyre, Queen’s Jubilee Ode 1887
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 詹姆斯·麦金泰尔，《女王1887年的银禧颂歌》
- en: In the past few years, largely because of the software you’ll see in this chapter,
    Python has become extremely popular with scientists. If you’re a scientist or
    student yourself, you might have used tools like MATLAB and R, or traditional
    languages such as Java, C, or C++. Now you’ll see how Python makes an excellent
    platform for scientific analysis and publishing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 近几年来，主要因为你将在本章看到的软件，Python 在科学家中变得非常流行。如果你是科学家或学生，你可能已经使用过类似 MATLAB 和 R 的工具，或者传统语言如
    Java、C 或 C++。现在你将看到 Python 如何成为科学分析和出版的优秀平台。
- en: Math and Statistics in the Standard Library
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库中的数学和统计
- en: First, let’s take a little trip back to the standard library and visit some
    features and modules that we’ve ignored.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回到标准库，看看我们忽略了的一些特性和模块。
- en: Math Functions
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学函数
- en: Python has a menagerie of math functions in the standard [math](https://oreil.ly/01SHP)
    library. Just type **`import math`** to access them from your programs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在标准[math](https://oreil.ly/01SHP)库中拥有丰富的数学函数。只需输入**`import math`**即可从你的程序中访问它们。
- en: 'It has a few constants such as `pi` and `e`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有一些常量，如`pi`和`e`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Most of it consists of functions, so let’s look at the most useful ones.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分由函数组成，让我们看看最有用的几个。
- en: '`fabs()` returns the absolute value of its argument:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`fabs()`返回其参数的绝对值：'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Get the integer below (`floor()`) and above (`ceil()`) some number:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 获取某个数字下方（`floor()`）和上方（`ceil()`）的整数：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Calculate the factorial (in math, *n* `!`) by using `factorial()`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`factorial()`来计算阶乘（数学中的*n*`!`）：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Get the logarithm of the argument in base `e` with `log()`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`log()`在自然对数`e`的基础上获取参数的对数：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you want a different base for the log, provide it as a second argument:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要不同基数的对数，可以提供第二个参数：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The function `pow()` does the opposite, raising a number to a power:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`pow()`执行相反操作，将一个数提升为某个幂次方：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Python also has the built-in exponentiation operator `**` to do the same, but
    it doesn’t automatically convert the result to a float if the base and power are
    both integers:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还有内置的指数运算符`**`来完成相同的功能，但如果底数和指数都是整数，结果不会自动转换为浮点数：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Get a square root with `sqrt()`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sqrt()`获取平方根：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Don’t try to trick this function; it’s seen it all before:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不要试图愚弄这个函数；它以前见过所有的东西：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The usual trigonometric functions are all there, and I’ll just list their names
    here: `sin()`, `cos()`, `tan()`, `asin()`, `acos()`, `atan()`, and `atan2()`.
    If you remember the Pythagorean theorem (or can say it fast three times without
    spitting), the math library also has a `hypot()` function to calculate the hypotenuse
    from two sides:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有常见的三角函数都在这里，我会在这里列出它们的名字：`sin()`，`cos()`，`tan()`，`asin()`，`acos()`，`atan()`，和`atan2()`。如果你记得毕达哥拉斯定理（或者能快速连续三次说出来而不喷出口水），数学库还有一个`hypot()`函数用于计算两边的斜边：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you don’t trust all these fancy functions, you can work it out yourself:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不信任所有这些花哨的函数，你可以自己解决：
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A last set of functions converts angular coordinates:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一组最后的函数转换角坐标：
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Working with Complex Numbers
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理复数
- en: 'Complex numbers are fully supported in the base Python language, with their
    familiar notation of *real* and *imaginary* parts:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 复数在基本的 Python 语言中得到了完全支持，具有熟悉的*实部*和*虚部*的表示法：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Because the imaginary number `i` (`1j` in Python) is defined as the square
    root of –1, we can execute the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因为虚数`i`（Python 中的`1j`）定义为–1的平方根，我们可以执行以下操作：
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Some complex math functions are in the standard [`cmath`](https://oreil.ly/1EZQ0)
    module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些复杂的数学函数在标准[`cmath`](https://oreil.ly/1EZQ0)模块中。
- en: Calculate Accurate Floating Point with decimal
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用十进制计算准确的浮点数
- en: 'Floating-point numbers in computers are not quite like the real numbers we
    learned in school:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机中的浮点数不像我们在学校学到的实数那样：
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Hey, what’s that `5` at the end? It should be `3` all the way down. This happens
    because there are only so many bits in computer CPU registers, and numbers that
    aren’t exact powers of two can’t be represented exactly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，末尾的`5`是什么？应该一路都是`3`。这是因为计算机 CPU 寄存器中只有有限的位数，而不是2的整数次幂的数字无法被精确表示。
- en: 'With Python’s [`decimal`](https://oreil.ly/o-bmR) module, you can represent
    numbers to your desired level of significance. This is especially important for
    calculations involving money. US currency doesn’t go lower than a cent (a hundredth
    of a dollar), so if we’re calculating money amounts as dollars and cents, we want
    to be accurate to the penny. If we try to represent dollars and cents through
    floating-point values such as 19.99 and 0.06, we’ll lose some significance way
    down in the end bits before we even begin calculating with them. How do we handle
    this? Easy. We use the `decimal` module, instead:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python的[`decimal`](https://oreil.ly/o-bmR)模块，您可以将数字表示为您所需的显著位数。这对涉及货币的计算特别重要。美元货币的最小单位是一分（美元的百分之一），因此如果我们将金额表示为美元和分，我们希望准确到分。如果我们尝试使用浮点值（如19.99和0.06）表示美元和分，我们将在开始计算之前失去一些显著性。我们如何处理这个问题？很简单，我们使用`decimal`模块：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We created the price and tax with string values to preserve their significance.
    The `total` calculation maintained all the significant fractions of a cent, but
    we want to get the nearest cent:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了价格和税费的字符串值以保留它们的意义。`total`的计算保留了所有显著的分数部分，但我们希望获得最接近的分数：
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You might get the same results with plain old floats and rounding, but not always.
    You could also multiply everything by 100 and use integer cents in your calculations,
    but that will bite you eventually, too.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会使用普通的浮点数和四舍五入得到相同的结果，但并非总是如此。您也可以将所有内容乘以100，并在计算中使用整数分（cents），但最终这也会给您带来麻烦。
- en: Perform Rational Arithmetic with fractions
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用fractions执行有理算术
- en: 'You can represent numbers as a numerator divided by a denominator through the
    standard Python [`fractions`](https://oreil.ly/l286g) module. Here is a simple
    operation multiplying one-third by two-thirds:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过标准Python [`fractions`](https://oreil.ly/l286g)模块将数字表示为分子除以分母。这里是一个简单的操作，将三分之一乘以三分之二：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Floating-point arguments can be inexact, so you can use `Decimal` within `Fraction`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数参数可能不精确，因此您可以在`Fraction`内使用`Decimal`：
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Get the greatest common divisor of two numbers with the `gcd` function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gcd`函数获取两个数字的最大公约数：
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Use Packed Sequences with array
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`array`处理打包的序列
- en: A Python list is more like a linked list than an array. If you want a one-dimensional
    sequence of the same type, use the [`array`](https://oreil.ly/VejPU) type. It
    uses less space than a list and supports many list methods. Create one with `array(`
    *`typecode`* , *`initializer`* `)`. The *typecode* specifies the data type (like
    `int` or `float`) and the optional *`initializer`* contains initial values, which
    you can specify as a list, string, or iterable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Python列表更像是链表而不是数组。如果您想要相同类型的一维序列，请使用[`array`](https://oreil.ly/VejPU)类型。它比列表使用更少的空间，并支持许多列表方法。使用`array(`
    *`typecode`* , *`initializer`* `)`来创建一个。*typecode*指定数据类型（如`int`或`float`），可选的*`initializer`*包含初始值，可以指定为列表、字符串或可迭代对象。
- en: I’ve never used this package for real work. It’s a low-level data structure,
    useful for things such as image data. If you actually need an array—especially
    with more then one dimension—to do numeric calculations, you’re much better off
    with NumPy, which we discuss momentarily.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我从未真正使用这个包进行实际工作。它是一个低级数据结构，适用于诸如图像数据之类的事物。如果您确实需要一个数组——尤其是带有多个维度——来进行数值计算，那么使用NumPy要好得多，稍后我们会讨论它。
- en: Handling Simple Stats with statistics
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`statistics`处理简单的统计数据
- en: 'Beginning with Python 3.4, [`statistics`](https://oreil.ly/DELnM) is a standard
    module. It has the usual functions: mean, media, mode, standard deviation, variance,
    and so on. Input arguments are sequences (lists or tuples) or iterators of various
    numeric data types: int, float, decimal, and fraction. One function, `mode`, also
    accepts strings. Many more statistical functions are available in packages such
    as SciPy and Pandas, featured later in this chapter.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.4开始，[`statistics`](https://oreil.ly/DELnM)是一个标准模块。它具有常见的函数：均值、中位数、众数、标准差、方差等等。输入参数是各种数值数据类型的序列（列表或元组）或迭代器：int、float、decimal和fraction。一个函数，`mode`，还接受字符串。许多更多的统计函数可以在诸如SciPy和Pandas等包中找到，稍后在本章中介绍。
- en: Matrix Multiplication
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵乘法
- en: Starting with Python 3.5, you’ll see the `@` character doing something out of
    character. It will still be used for decorators, but it will also have a new use
    for [*matrix multiplication*](https://oreil.ly/fakoD). If you’re using an older
    version of Python, NumPy (coming right up) is your best bet.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.5 开始，你会看到 `@` 字符有些不同寻常的用法。它仍然用于装饰器，但也有一个新的用法用于 [*矩阵乘法*](https://oreil.ly/fakoD)。如果你正在使用较旧版本的
    Python，NumPy（即将介绍）是你的最佳选择。
- en: Scientific Python
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 科学 Python
- en: 'The rest of this chapter covers third-party Python packages for science and
    math. Although you can install them individually, you should consider downloading
    all of them at once as part of a scientific Python distribution. Here are your
    main choices:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分涵盖了用于科学和数学的第三方 Python 包。虽然你可以单独安装它们，但考虑作为科学 Python 发行版的一部分同时下载所有这些包会更好。以下是你的主要选择：
- en: '[Anaconda](https://www.anaconda.com)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[Anaconda](https://www.anaconda.com)'
- en: Free, extensive, up-to-the-minute, supports Python 2 and 3, and won’t clobber
    your existing system Python
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 免费、全面、最新，支持 Python 2 和 3，并且不会破坏现有的系统 Python。
- en: '[Enthought Canopy](https://assets.enthought.com/downloads)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[Enthought Canopy](https://assets.enthought.com/downloads)'
- en: Available in both free and commercial versions
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 提供免费和商业版本
- en: '[Python(x,y)](https://python-xy.github.io)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python(x,y)](https://python-xy.github.io)'
- en: A Windows-only release
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 仅适用于 Windows 版本
- en: '[Pyzo](http://www.pyzo.org)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[Pyzo](http://www.pyzo.org)'
- en: Based on some tools from Anaconda, plus a few others
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Anaconda 的一些工具，以及其他一些工具
- en: I recommend installing Anaconda. It’s big, but everything in this chapter is
    in there. The examples in the rest of this chapter will assume that you’ve installed
    the required packages, either individually or as part of Anaconda.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议安装 Anaconda。它很大，但本章的所有示例都包含在其中。本章的其余示例将假定你已安装了所需的包，无论是单独安装还是作为 Anaconda 的一部分。
- en: NumPy
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy
- en: '[NumPy](http://www.numpy.org) is one of the main reasons for Python’s popularity
    among scientists. You’ve heard that dynamic languages such as Python are often
    slower than compiled languages like C, or even other interpreted languages such
    as Java. NumPy was written to provide fast multidimensional numeric arrays, similar
    to scientific languages like FORTRAN. You get the speed of C with the developer-friendly
    nature of Python.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[NumPy](http://www.numpy.org) 是 Python 在科学家中流行的主要原因之一。你听说过动态语言如 Python 通常比编译语言如
    C 或甚至其他解释语言如 Java 慢。NumPy 的出现是为了提供快速的多维数值数组，类似于科学语言如 FORTRAN。你既得到了 C 的速度，又保留了
    Python 的开发者友好性。'
- en: If you’ve downloaded one of the scientific Python distributions, you already
    have NumPy. If not, follow the instructions on the NumPy [download page](https://oreil.ly/HcZZi).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经下载了其中一个科学 Python 发行版，那么你已经拥有了 NumPy。如果没有，请按照 NumPy 的 [下载页面](https://oreil.ly/HcZZi)
    上的说明操作。
- en: To begin with NumPy, you should understand a core data structure, a multidimensional
    array called an `ndarray` (for *N-dimensional array*) or just an `array`. Unlike
    Python’s lists and tuples, each element needs to be of the same type. NumPy refers
    to an array’s number of dimensions as its *rank*. A one-dimensional array is like
    a row of values, a two-dimensional array is like a table of rows and columns,
    and a three-dimensional array is like a Rubik’s Cube. The lengths of the dimensions
    need not be the same.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 NumPy，你应该了解一个核心数据结构，称为 *ndarray*（*N-dimensional array* 的缩写）或简称 *array*
    的多维数组。与 Python 的列表和元组不同，每个元素都需要是相同类型的。NumPy 将数组的维数称为其 *rank*。一维数组类似于值的行，二维数组类似于行和列的表，三维数组类似于魔方。各维度的长度不必相同。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The NumPy `array` and the standard Python `array` are not the same thing. For
    the rest of this chapter, when I say *array*, I’m referring to a NumPy array.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的 `array` 和标准的 Python `array` 不是一回事。本章的其余部分中，当我说 *array* 时，我指的是 NumPy
    数组。
- en: But why do you need an array?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么你需要一个数组？
- en: Scientific data often consists of large sequences of data.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 科学数据通常包含大量的数据序列。
- en: Scientific calculations on this data often use matrix math, regression, simulation,
    and other techniques that process many data points at a time.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这些数据上进行科学计算通常使用矩阵数学、回归、模拟以及其他处理大量数据点的技术。
- en: NumPy handles arrays *much* faster than standard Python lists or tuples.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 处理数组比标准的 Python 列表或元组快得多。
- en: There are many ways to make a NumPy array.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以创建一个 NumPy 数组。
- en: Make an Array with array()
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 array() 创建一个数组
- en: 'You can make an array from a normal list or tuple:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从普通列表或元组创建一个数组：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The attribute `ndim` returns the rank:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 属性 `ndim` 返回数组的维数：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The total number of values in the array are given by `size`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的值的总数由`size`给出：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The number of values in each rank are returned by `shape`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个秩中的值的数量由`shape`返回：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Make an Array with arange()
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`arange()`创建一个数组
- en: 'NumPy’s `arange()` method is similar to Python’s standard `range()`. If you
    call `arange()` with a single integer argument `num`, it returns an `ndarray`
    from `0` to `num-1`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的`arange()`方法类似于 Python 的标准`range()`。如果你用一个整数参数`num`调用`arange()`，它会返回一个从`0`到`num-1`的`ndarray`：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With two values, it creates an array from the first to the last, minus one:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 用两个值，它创建一个从第一个到最后一个的数组，减去一个：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And you can provide a step size to use instead of one as a third argument:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以提供一个步长作为第三个参数来使用：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So far, our examples have used integers, but floats work just fine:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的例子都使用整数，但浮点数也完全可以：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And one last trick: the `dtype` argument tells `arange` what type of values
    to produce:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个小技巧：`dtype`参数告诉`arange`要产生什么类型的值：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Make an Array with zeros(), ones(), or random()
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 zeros()、ones() 或 random() 创建一个数组
- en: 'The `zeros()` method returns an array in which all the values are zero. The
    argument you provide is a tuple with the shape that you want. Here’s a one-dimensional
    array:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`zeros()`方法返回一个所有值都为零的数组。你提供的参数是一个你想要的形状的元组。这是一个一维数组：'
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This one is of rank two:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个是二阶的：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The other special function that fills an array with the same value is `ones()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 用相同值填充数组的另一个特殊函数是`ones()`：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'One last initializer creates an array with random values between 0.0 and 1.0:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个初始化器创建一个具有介于 0.0 和 1.0 之间的随机值的数组：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Change an Array’s Shape with reshape()
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`reshape()`改变数组的形状
- en: 'So far, an array doesn’t seem that different from a list or tuple. One difference
    is that you can get it to do tricks such as change its shape by using `reshape()`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，数组似乎并不比列表或元组不同。一个区别是你可以让它执行诸如使用`reshape()`改变其形状的技巧：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can reshape the same array in different ways:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以不同的方式重塑相同的数组：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Assigning a shapely tuple to `shape` does the same thing:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个具有形状的元组分配给`shape`会做同样的事情：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The only restriction on a shape is that the product of the rank sizes needs
    to equal the total number of values (in this case, 10):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 形状的唯一限制是秩大小的乘积需要等于值的总数（在本例中为 10）：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Get an Element with []
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用[]获取一个元素
- en: 'A one-dimensional array works like a list:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一维数组的工作方式类似于列表：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, if the array has a different shape, use comma-separated indices within
    the square brackets:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果数组的形状不同，请在方括号内使用逗号分隔的索引：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'That’s different from a two-dimensional Python list, which has its indexes
    in separate square brackets:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这与二维 Python 列表不同，后者的索引位于单独的方括号中：
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'One last thing: slices work, but again, only within one set of square brackets.
    Let’s make our familiar test array again:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事：切片是有效的，但再次强调，只能在一组方括号内。让我们再次创建我们熟悉的测试数组：
- en: '[PRE41]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Use a slice to get the first row, elements from offset `2` to the end:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片获取第一行，从偏移量`2`到末尾的元素：
- en: '[PRE42]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, get the last row, elements up to the third from the end:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，获取最后一行，从末尾倒数第三个元素开始：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can also assign a value to more than one element with a slice. The following
    statement assigns the value `1000` to columns (offsets) `2` and `3` of all rows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用切片为多个元素赋值。以下语句将值`1000`赋给所有行的列（偏移量）`2`和`3`：
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Array Math
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组数学
- en: 'Making and reshaping arrays was so much fun that we almost forgot to actually
    *do* something with them. For our first trick, we use NumPy’s redefined multiplication
    (`*`) operator to multiply all the values in a NumPy array at once:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 制作和重塑数组是如此有趣，以至于我们几乎忘记了实际上*要*用它们做些什么。作为我们的第一个技巧，我们使用 NumPy 的重新定义的乘法（`*`）运算符一次性将
    NumPy 数组中的所有值相乘：
- en: '[PRE45]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you tried to multiply each element in a normal Python list by a number,
    you’d need a loop or a list comprehension:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将普通的 Python 列表中的每个元素乘以一个数字，你将需要一个循环或列表推导：
- en: '[PRE46]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This all-at-once behavior also applies to addition, subtraction, division,
    and other functions in the NumPy library. For example, you can initialize all
    members of an array to any value by using `zeros()` and `+`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这种一次性行为也适用于 NumPy 库中的加法、减法、除法和其他函数。例如，你可以使用`zeros()`和`+`将数组的所有成员初始化为任何值：
- en: '[PRE47]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Linear Algebra
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性代数
- en: 'NumPy includes many functions for linear algebra. For example, let’s define
    this system of linear equations:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 包含许多线性代数函数。例如，让我们定义这个线性方程组：
- en: '[PRE48]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'How do we solve for `x` and `y`? We build two arrays:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解出`x`和`y`？我们构建两个数组：
- en: The *coefficients* (multipliers for `x` and `y`)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系数*（`x`和`y`的乘数）'
- en: The *dependent* variables (right side of the equation)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖*变量（方程的右侧）'
- en: '[PRE49]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, use the `solve()` function in the `linalg` module:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`linalg`模块中使用`solve()`函数：
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The result says that `x` is about –8.3 and `y` is about 10.6. Did these numbers
    solve the equation?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示`x`约为–8.3，`y`约为10.6。这些数字是否解出了方程？
- en: '[PRE51]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'How about that. To avoid all that typing, you can also ask NumPy to get the
    *dot product* of the arrays for you:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。为了避免输入所有内容，您还可以要求NumPy为您获取数组的*点积*：
- en: '[PRE52]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The values in the `product` array should be close to the values in `dependents`
    if this solution is correct. You can use the `allclose()` function to check whether
    the arrays are approximately equal (they might not be exactly equal because of
    floating-point rounding):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此解决方案正确，则`product`数组中的值应接近`dependents`中的值。您可以使用`allclose()`函数来检查数组是否大致相等（由于浮点数精度问题，它们可能并不完全相等）：
- en: '[PRE53]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: NumPy also has modules for polynomials, Fourier transforms, statistics, and
    some probability distributions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy还包括用于多项式、傅里叶变换、统计以及一些概率分布的模块。
- en: SciPy
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SciPy
- en: 'There’s even more in a library of mathematical and statistical functions built
    on top of NumPy: [SciPy](http://www.scipy.org). The SciPy [release](https://oreil.ly/Yv7G-)
    includes NumPy, SciPy, Pandas (coming later in this chapter), and other libraries.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy之上构建的数学和统计函数库还有更多：[SciPy](http://www.scipy.org)。SciPy的[发布](https://oreil.ly/Yv7G-)包括NumPy、SciPy、Pandas（本章后续会讨论）、以及其他库。
- en: 'SciPy includes many modules, including some for the following tasks:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy包括许多模块，包括以下任务：
- en: Optimization
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化
- en: Statistics
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计
- en: Interpolation
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值
- en: Linear regression
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性回归
- en: Integration
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 积分
- en: Image processing
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像处理
- en: Signal processing
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号处理
- en: If you’ve worked with other scientific computing tools, you’ll find that Python,
    NumPy, and SciPy cover some of the same ground as the commercial [MATLAB](https://oreil.ly/jOPMO)
    or open source [R](http://www.r-project.org).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用过其他科学计算工具，您会发现Python、NumPy和SciPy与商业软件[MATLAB](https://oreil.ly/jOPMO)或开源软件[R](http://www.r-project.org)涵盖了一些相同的领域。
- en: SciKit
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SciKit
- en: 'In the same pattern of building on earlier software, [SciKit](https://scikits.appspot.com)
    is a group of scientific packages built on SciPy. [SciKit-Learn](https://scikit-learn.org)
    is a prominent *machine learning* package: it supports modeling, classification,
    clustering, and various algorithms.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似之前软件的模式下，[SciKit](https://scikits.appspot.com)是基于SciPy构建的一组科学软件包。[SciKit-Learn](https://scikit-learn.org)是一个重要的*机器学习*软件包：它支持建模、分类、聚类以及各种算法。
- en: Pandas
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pandas
- en: Recently, the phrase *data science* has become common. Some definitions that
    I’ve seen include “statistics done on a Mac,” or “statistics done in San Francisco.”
    However you define it, the tools we’ve talked about in this chapter—NumPy, SciPy,
    and the subject of this section, Pandas—are components of a growing popular data-science
    toolkit. (Mac and San Francisco are optional.)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，“数据科学”这个术语变得很常见。我见过一些定义，包括“在Mac上进行的统计分析”或“在旧金山进行的统计分析”。不管您如何定义它，本章讨论的工具——NumPy、SciPy以及本节的主题Pandas——都是一个日益流行的数据科学工具包的组成部分。（Mac和旧金山是可选的。）
- en: '[Pandas](http://pandas.pydata.org) is a new package for interactive data analysis.
    It’s especially useful for real-world data manipulation, combining the matrix
    math of NumPy with the processing ability of spreadsheets and relational databases.
    The book [*Python for Data Analysis: Data Wrangling with Pandas, NumPy, and IPython*](http://bit.ly/python_for_data_analysis)
    by Wes McKinney (O’Reilly) covers data wrangling with NumPy, IPython, and Pandas.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[Pandas](http://pandas.pydata.org)是一种用于交互式数据分析的新软件包。它特别适用于真实世界的数据处理，结合了NumPy的矩阵数学和电子表格以及关系数据库的处理能力。Wes
    McKinney（O’Reilly）的书籍[*Python for Data Analysis: Data Wrangling with Pandas, NumPy,
    and IPython*](http://bit.ly/python_for_data_analysis)介绍了使用NumPy、IPython和Pandas进行数据整理。'
- en: NumPy is oriented toward traditional scientific computing, which tends to manipulate
    multidimensional data sets of a single type, usually floating point. Pandas is
    more like a database editor, handling multiple data types in groups. In some languages,
    such groups are called *records* or *structures*. Pandas defines a base data structure
    called a `DataFrame`. This is an ordered collection of columns with names and
    types. It has some resemblance to a database table, a Python named tuple, and
    a Python nested dictionary. Its purpose is to simplify the handling of the kind
    of data you’re likely to encounter not just in science, but also in business.
    In fact, Pandas was originally designed to manipulate financial data, for which
    the most common alternative is a spreadsheet.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy致力于传统的科学计算，通常用于处理单一类型的多维数据集，通常是浮点数。而Pandas更像是一个数据库编辑器，可以处理多种数据类型的组合。在某些语言中，这些组合被称为*记录*或*结构*。Pandas定义了一个名为`DataFrame`的基本数据结构。它是具有名称和类型的列的有序集合。它与数据库表、Python的命名元组和嵌套字典有些相似。其目的在于简化您可能会遇到的数据处理，不仅仅局限于科学领域，还包括商业领域。事实上，Pandas最初是为了处理金融数据而设计的，而其最常见的替代品是电子表格。
- en: Pandas is an ETL tool for real-world, messy data—missing values, oddball formats,
    scattered measurements—of all data types. You can split, join, extend, fill in,
    convert, reshape, slice, and load and save files. It integrates with the tools
    we’ve just discussed—NumPy, SciPy, iPython—to calculate statistics, fit data to
    models, draw plots, publish, and so on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas是一个处理现实世界中混乱数据（缺失值、奇怪的格式、零散的测量）的ETL工具，支持各种数据类型。您可以分割、连接、扩展、填充、转换、重塑、切片、加载和保存文件。它与我们刚讨论过的工具集成在一起——NumPy、SciPy、iPython——用于计算统计数据、将数据拟合到模型、绘制图表、发布等等。
- en: Most scientists just want to get their work done, without spending months to
    become experts in esoteric computer languages or applications. With Python, they
    can become productive more quickly.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数科学家只想完成他们的工作，而不是花数月时间成为奇特计算机语言或应用的专家。使用Python，他们可以更快地变得高效。
- en: Python and Scientific Areas
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python与科学领域
- en: 'We’ve been looking at Python tools that could be used in almost any area of
    science. What about software and documentation targeted to specific scientific
    domains? Here’s a small sample of Python’s use for specific problems, and some
    special-purpose libraries:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过几乎适用于任何科学领域的Python工具。那么针对特定科学领域的软件和文档呢？以下是Python在特定问题和一些特殊用途库中的应用示例：
- en: General
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一般
- en: '[Python computations in science and engineering](http://bit.ly/py-comp-sci)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[科学与工程中的Python计算](http://bit.ly/py-comp-sci)'
- en: '[A crash course in Python for scientists](http://bit.ly/pyforsci)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[科学家的Python速成课程](http://bit.ly/pyforsci)'
- en: Physics
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 物理学
- en: '[Computational physics](http://bit.ly/comp-phys-py)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[计算物理学](http://bit.ly/comp-phys-py)'
- en: '[Astropy](https://www.astropy.org)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Astropy](https://www.astropy.org)'
- en: '[SunPy](https://sunpy.org) (solar data analysis)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SunPy](https://sunpy.org)（太阳数据分析）'
- en: '[MetPy](https://unidata.github.io/MetPy) (meteorological data analysis)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MetPy](https://unidata.github.io/MetPy)（气象数据分析）'
- en: '[Py-ART](https://arm-doe.github.io/pyart) (weather radar)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Py-ART](https://arm-doe.github.io/pyart)（天气雷达）'
- en: '[Community Intercomparison Suite](http://www.cistools.net) (atmospheric sciences)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[社区比较套件](http://www.cistools.net)（大气科学）'
- en: '[Freud](https://freud.readthedocs.io) (trajectory analysis)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Freud](https://freud.readthedocs.io)（轨迹分析）'
- en: '[Platon](https://platon.readthedocs.io) (exoplanet atmospheres)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Platon](https://platon.readthedocs.io)（系外行星大气层）'
- en: '[PSI4](http://psicode.org) (quantum chemistry)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PSI4](http://psicode.org)（量子化学）'
- en: '[OpenQuake Engine](https://github.com/gem/oq-engine)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[OpenQuake Engine](https://github.com/gem/oq-engine)'
- en: '[yt](https://yt-project.org) (volumetric data analysis)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[yt](https://yt-project.org)（体积数据分析）'
- en: Biology and medicine
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 生物学和医学
- en: '[Biopython](https://biopython.org)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Biopython](https://biopython.org)'
- en: '[Python for biologists](http://pythonforbiologists.com)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[生物学家的Python](http://pythonforbiologists.com)'
- en: '[Introduction to Applied Bioinformatics](http://readiab.org)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[应用生物信息学导论](http://readiab.org)'
- en: '[Neuroimaging in Python](http://nipy.org)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python中的神经影像学](http://nipy.org)'
- en: '[MNE](https://www.martinos.org/mne) (neurophysiological data visualization)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MNE](https://www.martinos.org/mne)（神经生理数据可视化）'
- en: '[PyMedPhys](https://pymedphys.com)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PyMedPhys](https://pymedphys.com)'
- en: '[Nengo](https://www.nengo.ai) (neural simulator)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Nengo](https://www.nengo.ai)（神经模拟器）'
- en: 'International conferences on Python and scientific data include the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Python和科学数据的国际会议包括以下内容：
- en: '[PyData](http://pydata.org)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PyData](http://pydata.org)'
- en: '[SciPy](http://conference.scipy.org)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SciPy](http://conference.scipy.org)'
- en: '[EuroSciPy](https://www.euroscipy.org)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[EuroSciPy](https://www.euroscipy.org)'
- en: Coming Up
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将到来
- en: We’ve reached the end of our observable Python universe, except for the multiverse
    appendices.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经触及了可观察的 Python 宇宙的尽头，除了多元宇宙附录。
- en: Things to Do
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要做的事情
- en: 22.1 Install Pandas. Get the CSV file in [Example 16-1](ch16.html#villains_csv).
    Run the program in [Example 16-2](ch16.html#pandas_csv_example). Experiment with
    some of the Pandas commands.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Pandas。获取 [示例 16-1](ch16.html#villains_csv) 中的 CSV 文件。运行 [示例 16-2](ch16.html#pandas_csv_example)
    中的程序。尝试一些 Pandas 命令。
