<html><head></head><body><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Asyncio Walk-Through"><div class="chapter" id="walkthrough">
<h1><span class="label">Chapter 3. </span>Asyncio Walk-Through</h1>

<blockquote>
  <p>Asyncio provides another tool for concurrent programming in Python,
that is more lightweight than threads or multiprocessing. In a very
simple sense it does this by having an event loop execute a collection
of tasks, with a key difference being that each task chooses when to
yield control back to the event loop.</p>

  <p data-type="attribution">Philip Jones, <a href="http://bit.ly/2EPys9Q">“Understanding Asyncio”</a></p>
</blockquote>

<p>The <code>asyncio</code> API in Python is complex because it aims to solve
different problems for different groups of people. Unfortunately,
very little guidance is available to help you figure out which
parts of <code>asyncio</code> are important for the group <em>you’re</em> in.<a data-type="indexterm" data-primary="Jones, Phillip" id="idm46363038759064"/></p>

<p>My goal is to help you figure that out.<a data-type="indexterm" data-primary="asyncio" data-secondary="main target audiences for" id="idm46363038757944"/><a data-type="indexterm" data-primary="developers, main target audiences for asyncio" id="idm46363038757000"/> There are two main target
audiences for the async features in Python:</p>
<dl>
<dt>End-user developers</dt>
<dd>
<p>These want to make applications using <code>asyncio</code>. I am going to assume that you’re in this group.<a data-type="indexterm" data-primary="end-user developers" id="idm46363038754344"/></p>
</dd>
<dt>Framework developers</dt>
<dd>
<p>These want to make frameworks and libraries that end-user developers can use in their applications.<a data-type="indexterm" data-primary="framework developers" id="idm46363038752248"/></p>
</dd>
</dl>

<p>Much of the confusion around <code>asyncio</code> in the community today is due
to lack of understanding of this difference. For instance, the official Python
documentation for <code>asyncio</code> is more appropriate
for framework developers than end users. This means that end-user
developers reading those docs quickly become shell-shocked by the
apparent complexity. You’re somewhat forced to take it all in before
being able to do anything with it.</p>

<p>It is my hope that this book can help you distinguish between the
features of Asyncio that are important for end-user developers and
those important for framework <span class="keep-together">developers</span>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you’re interested in the lower-level details around how
concurrency frameworks like Asyncio are built internally, I highly
recommend a wonderful talk by Dave Beazley,
<a href="https://oreil.ly/_68Rm">“Python Concurrency from the Ground Up:
LIVE!”</a>, in which he demonstrates putting together a simpler version of
an async framework like Asyncio.<a data-type="indexterm" data-primary="Beazley, Dave" id="idm46363038717048"/><a data-type="indexterm" data-primary="“Python Concurrency From the Ground Up: LIVE!” talk (Beazley)" data-primary-sortas="Python Concurrency" id="idm46363038716376"/></p>
</div>

<p>My goal is to give you only the most basic understanding of the
building blocks of Asyncio—enough that you should be able to write
simple programs with it, and certainly enough that you will be able to
dive into more complete references.<sup><a data-type="noteref" id="idm46363038714696-marker" href="ch03.html#idm46363038714696">1</a></sup></p>

<p>First up, we have a “quickstart” section that introduces the
most important building blocks for Asyncio applications.</p>






<section data-type="sect1" data-pdf-bookmark="Quickstart"><div class="sect1" id="quickstart-section">
<h1>Quickstart</h1>
<blockquote>
  <p>You only need to know about seven functions to use Asyncio [for everyday use].</p>
    <p data-type="attribution">Yury Selivanov, author of PEP 492, which added the <code>async</code> and <code>await</code> keywords to Python</p>
</blockquote>

<p>It’s pretty scary diving into the
<a href="https://oreil.ly/4Y_Pd">official documentation</a>
for Asyncio.<a data-type="indexterm" data-primary="Selivanov, Yury" id="idm46363038707784"/><a data-type="indexterm" data-primary="asyncio" data-secondary="quickstart" id="ix_asyqk"/> There are many sections with new, enigmatic words and
concepts that will be unfamiliar to even experienced Python
programmers, as Asyncio is a very new thing in Python. I’m going to break
all that down and explain how to approach the <code>asyncio</code> module documentation
later, but for now you need to know that the actual surface area you
have to worry about with the <code>asyncio</code> library is much smaller than
it seems.</p>

<p>Yury Selivanov, the author of
<a href="https://oreil.ly/I3K7H">PEP 492</a> and all-round major
contributor to async Python, explained in his PyCon 2016 talk <a href="https://oreil.ly/ImGca">“async/await in Python
3.5 and Why It Is Awesome,”</a> that many of the APIs in the <code>asyncio</code> module are really
intended for framework designers, not end-user developers.<a data-type="indexterm" data-primary="framework developers" data-secondary="many APIs in asyncio module intended for" id="idm46363038701944"/><a data-type="indexterm" data-primary="“async/await in Python 3.5 and Why It Is Awesome” talk (Selivanov)" data-primary-sortas="async/await" id="idm46363038700872"/> In that talk,
he emphasized the main features that end users should care about. These
are a small subset of the whole <span class="keep-together"><code>asyncio</code></span> API and can be summarized as follows:</p>

<ul>
<li>
<p>Starting the <code>asyncio</code> event loop</p>
</li>
<li>
<p>Calling <code>async</code>/<code>await</code> functions</p>
</li>
<li>
<p>Creating a <em>task</em> to be run on the loop</p>
</li>
<li>
<p>Waiting for multiple tasks to complete</p>
</li>
<li>
<p>Closing the loop after all concurrent tasks have completed</p>
</li>
</ul>

<p>In this section, we’re going to look at those core features and see
how to hit the ground looping with event-based programming in Python.</p>

<p>The “Hello World” of Asyncio in Python<a data-type="indexterm" data-primary="“Hello World” of asyncio in Python" data-primary-sortas="Hello" id="idm46363038691256"/> looks like <a data-type="xref" href="#helloworld00">Example 3-1</a>.</p>
<div id="helloworld00" data-type="example">
<h5><span class="label">Example 3-1. </span>The “Hello World” of Asyncio</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># quickstart.py</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code class="o">,</code><code> </code><code class="nn">time</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">{</code><code class="s1">time.ctime()} Hello!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">1.0</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">{</code><code class="s1">time.ctime()} Goodbye!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>
</code><code class="n">asyncio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO1-1" href="#callout_asyncio_walk_through_CO1-1"><img src="assets/1.png" alt="1"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO1-1" href="#co_asyncio_walk_through_CO1-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p><code>asyncio</code> provides a <code>run()</code> function to execute an <code>async def</code> function
and all other coroutines called from there, like <code>sleep()</code> in the
<code>main()</code> function.<a data-type="indexterm" data-primary="run function" id="idm46363038679112"/><a data-type="indexterm" data-primary="async def functions" id="idm46363038678488"/><a data-type="indexterm" data-primary="sleep function" id="idm46363038677432"/></p></dd>
</dl></div>

<p>Here’s the output from running <a data-type="xref" href="#helloworld00">Example 3-1</a>:</p>
<pre data-type="programlisting">
$ <strong>python quickstart.py</strong>
Sun Aug 18 02:14:34 2019 Hello!
Sun Aug 18 02:14:35 2019 Goodbye!
</pre>

<p>In practice, most of your Asyncio-based code will use the <code>run()</code> function
shown here, but it’s important to understand a little more about
what that function is doing for you. This understanding is important
because it will influence how you design larger applications.</p>

<p><a data-type="xref" href="#helloworld">Example 3-2</a> is what I’ll call a “Hello-ish World” example. It isn’t exactly
the same as what <code>run()</code> does, but it’s close enough to introduce the ideas that we’ll build on throughout the rest of the
book. You’ll need a basic knowledge of coroutines (discussed in depth later in this chapter), but try to follow along anyway and focus on the high-level
concepts for now.</p>
<div id="helloworld" data-type="example">
<h5><span class="label">Example 3-2. </span>The “Hello-ish World” of Asyncio</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># quickstart.py</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">time</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s2">"</code><code class="s2">{</code><code class="s2">time.ctime()} Hello!</code><code class="s2">"</code><code class="p">)</code><code>
</code><code>    </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">1.0</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s2">"</code><code class="s2">{</code><code class="s2">time.ctime()} Goodbye!</code><code class="s2">"</code><code class="p">)</code><code>
</code><code>
</code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">(</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO2-1" href="#callout_asyncio_walk_through_CO2-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="n">task</code><code> </code><code class="o">=</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO2-2" href="#callout_asyncio_walk_through_CO2-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="n">loop</code><code class="o">.</code><code class="n">run_until_complete</code><code class="p">(</code><code class="n">task</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO2-3" href="#callout_asyncio_walk_through_CO2-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="n">pending</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">all_tasks</code><code class="p">(</code><code class="n">loop</code><code class="o">=</code><code class="n">loop</code><code class="p">)</code><code>
</code><code class="k">for</code><code> </code><code class="n">task</code><code> </code><code class="ow">in</code><code> </code><code class="n">pending</code><code class="p">:</code><code>
</code><code>    </code><code class="n">task</code><code class="o">.</code><code class="n">cancel</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">group</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">gather</code><code class="p">(</code><code class="o">*</code><code class="n">pending</code><code class="p">,</code><code> </code><code class="n">return_exceptions</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO2-4" href="#callout_asyncio_walk_through_CO2-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code class="n">loop</code><code class="o">.</code><code class="n">run_until_complete</code><code class="p">(</code><code class="n">group</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO2-5" href="#callout_asyncio_walk_through_CO2-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="n">loop</code><code class="o">.</code><code class="n">close</code><code class="p">(</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO2-6" href="#callout_asyncio_walk_through_CO2-5"><img src="assets/5.png" alt="5"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO2-1" href="#co_asyncio_walk_through_CO2-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p><code>loop</code> = <em><code>asyncio.get_event_loop()</code></em><br/>
You need a loop instance before you can run any coroutines, and this is
how you get one.  <a data-type="indexterm" data-primary="loops" data-secondary="getting loop instance" id="idm46363038461688"/><a data-type="indexterm" data-primary="get_event_loop function" id="idm46363038460808"/>In fact, anywhere you call it, <code>get_event_loop()</code> will give
you the same <code>loop</code> instance each time, as long as you’re using only a single
thread.<sup><a data-type="noteref" id="idm46363038459208-marker" href="ch03.html#idm46363038459208">2</a></sup>
If you’re inside an <code>async def</code> function, you should call
<code>asyncio.get_running_loop()</code> instead, which always gives you what you expect.
This is covered in much more detail later in the book.<a data-type="indexterm" data-primary="asyncio.get_running_loop function" id="idm46363038456872"/><a data-type="indexterm" data-primary="get_running_loop function" id="idm46363038456232"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO2-2" href="#co_asyncio_walk_through_CO2-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p><code>task</code> = <em><code>loop.create_task(coro)</code></em><br/>
In this case, the specific call is <code>loop.create_task(main())</code>.
Your coroutine function will not be executed until you do this.<a data-type="indexterm" data-primary="tasks" data-secondary="loop.create_task function" id="idm46363038402952"/><a data-type="indexterm" data-primary="create_task function" id="idm46363038402040"/> We say that
<code>create_task()</code> <em>schedules</em> your coroutine to be run on the loop.<sup><a data-type="noteref" id="idm46363038400376-marker" href="ch03.html#idm46363038400376">3</a></sup>
The returned <code>task</code> object can be used
to monitor the status of the task (for example, whether it is still
running or has completed), and can also be used to obtain a result
value from your completed coroutine. You can cancel the task with
<code>task.cancel()</code>.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO2-3" href="#co_asyncio_walk_through_CO2-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p><em><code>loop.run_until_complete(coro)</code></em><br/>
This call will <em>block</em> the current thread, which will usually be the
main thread.<a data-type="indexterm" data-primary="blocking functions" data-secondary="loop.run_until_complete" id="idm46363038391192"/><a data-type="indexterm" data-primary="threads" data-secondary="blocking with loop.run_until_complete" id="idm46363038390216"/><a data-type="indexterm" data-primary="run_until_complete function" id="idm46363038389256"/><a data-type="indexterm" data-primary="loop.run_until_complete function" id="idm46363038388568"/> Note that
<code>run_until_complete()</code> will keep the loop running only until the given <em><code>coro</code></em>
completes—but all <em>other</em> tasks scheduled on the loop will also run while
the loop is running. Internally, <code>asyncio.run()</code> calls <code>run_until_complete()</code>
for you and therefore blocks the main thread in the same way.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO2-4" href="#co_asyncio_walk_through_CO2-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p><code>group</code> = <em><code>asyncio.gather(task1, task2, task3)</code></em><br/>
When the “main” part of the program unblocks, either due to a <a href="https://oreil.ly/KfOmB">process signal</a>
being received or the loop being stopped by some code calling <code>loop.stop()</code>,
the code after <code>run_until_complete()</code> will run.<a data-type="indexterm" data-primary="loop.stop function" id="idm46363038380280"/><a data-type="indexterm" data-primary="process signals" id="idm46363038379544"/> The standard idiom as shown here
is to gather the still-pending tasks, cancel them,
and then use <code>loop.run_until_complete()</code> again until those tasks are done.
<code>gather()</code> is the method for doing the gathering.<a data-type="indexterm" data-primary="gather function" id="idm46363038377768"/>
Note that <code>asyncio.run()</code> will do all of the cancelling, gathering, and
waiting for pending tasks to finish up.<a data-type="indexterm" data-primary="run function" data-secondary="cancelling, gathering, and waiting for pending tasks" id="idm46363038376520"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO2-5" href="#co_asyncio_walk_through_CO2-6"><img src="assets/5.png" alt="5"/></a></dt>
<dd><p><em><code>loop.close()</code></em><br/>
 <code>loop.close()</code> is usually the final action: it must be called on a stopped loop,
and it will clear all queues and shut down the executor.<a data-type="indexterm" data-primary="loop.close function" id="idm46363038371976"/> A <em>stopped</em> loop
can be restarted, but a <em>closed</em> loop is gone for good. Internally,
<code>asyncio.run()</code> will close the loop before returning.<a data-type="indexterm" data-primary="run function" data-secondary="closing loops" id="idm46363038369848"/> This is fine because
<code>run()</code> creates a new event loop every time you call it.</p></dd>
</dl></div>

<p><a data-type="xref" href="#helloworld00">Example 3-1</a> shows that if you use <code>asyncio.run()</code>, none of
these steps are necessary: they are all done for you. However, it is
important to understand these steps
because more complex situations will come up in practice, and
you’ll need the extra knowledge to deal with them. Several of these
are covered in detail later in the book.</p>
<div data-type="caution"><h6>Caution</h6>
<p>The preceding example is still too simplistic to be useful in a
practical setting.<a data-type="indexterm" data-primary="shutdown, handling" id="idm46363038365928"/> More information around correct shutdown handling
is required. The goal of the example is merely to introduce the
most important functions and methods in <code>asyncio</code>. More practical
information for shutdown handling is presented in <a data-type="xref" href="#shutdown">“Starting Up and Shutting Down (Gracefully!)”</a>.</p>
</div>

<p><code>asyncio</code> in Python exposes a great deal of the underlying machinery
around the event loop—and requires you to be aware of
aspects like lifecycle management.<a data-type="indexterm" data-primary="event loops" data-secondary="handling by asyncio in Python" id="idm46363038362712"/><a data-type="indexterm" data-primary="Node.js, event loops in" id="idm46363038361768"/> This is different from
Node.js, for example, which also contains an event loop but keeps it
somewhat hidden away. However, once you’ve worked with <code>asyncio</code> for
bit, you’ll begin to notice that the pattern for starting up and
shutting down the event loop doesn’t stray terribly far from the code
presented here. We’ll examine some of the nuances of managing the loop life cycle in more detail later in the book.</p>

<p>I left something out in the preceding example. <a data-type="indexterm" data-primary="blocking functions" data-secondary="running" id="idm46363038359512"/> The last item of basic
functionality you’ll need to know about is how to run <em>blocking</em> functions.
The thing about <span class="keep-together">cooperative</span> multitasking is that you need all
I/O-bound functions to…well, cooperate, and that means allowing a
context switch back to the loop using the keyword <code>await</code>.<a data-type="indexterm" data-primary="await keyword" id="idm46363038356744"/> Most of the
Python code available in the wild today does not do this, and instead relies
on you to run such functions in threads.  Until there is more
widespread support for <code>async def</code> functions, you’re going to find
that using such blocking libraries is unavoidable.<a data-type="indexterm" data-primary="async def functions" data-secondary="blocking functions and" id="idm46363038355304"/></p>

<p>For this, <code>asyncio</code> provides an API that is very similar to the API in
the <code>concurrent.futures</code> package. This package provides a
<code>ThreadPoolExecutor</code> and a <code>ProcessPoolExecutor</code>.<a data-type="indexterm" data-primary="ThreadPoolExecutor class" id="idm46363038352120"/><a data-type="indexterm" data-primary="ProcessPoolExecutor class" id="idm46363038351320"/><a data-type="indexterm" data-primary="executors" data-secondary="thread-based and pool-based" id="idm46363038350632"/> The default is thread-based,
but either thread-based or pool-based executors can be used. I omitted
executor considerations from the previous example because they would have
obscured the description of how the fundamental parts fit together. Now that
those have been covered, we can look at the executor directly.</p>

<p>There are a couple of quirks to be aware of.<a data-type="indexterm" data-primary="executors" data-secondary="basic interface and quirks to take note of" id="idm46363038348952"/> Let’s have a look at the
code sample in <a data-type="xref" href="#quickstart-executor">Example 3-3</a>.</p>
<div id="quickstart-executor" data-type="example">
<h5><span class="label">Example 3-3. </span>The basic executor interface</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># quickstart_exe.py</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">time</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">{</code><code class="s1">time.ctime()} Hello!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">1.0</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">{</code><code class="s1">time.ctime()} Goodbye!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>
</code><code class="k">def</code><code> </code><code class="nf">blocking</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO3-1" href="#callout_asyncio_walk_through_CO3-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>    </code><code class="n">time</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">0.5</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO3-2" href="#callout_asyncio_walk_through_CO3-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s2">"</code><code class="s2">{</code><code class="s2">time.ctime()} Hello from a thread!</code><code class="s2">"</code><code class="p">)</code><code>
</code><code>
</code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">task</code><code> </code><code class="o">=</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code>
</code><code class="n">loop</code><code class="o">.</code><code class="n">run_in_executor</code><code class="p">(</code><code class="kc">None</code><code class="p">,</code><code> </code><code class="n">blocking</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO3-3" href="#callout_asyncio_walk_through_CO3-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="n">loop</code><code class="o">.</code><code class="n">run_until_complete</code><code class="p">(</code><code class="n">task</code><code class="p">)</code><code>
</code><code>
</code><code class="n">pending</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">all_tasks</code><code class="p">(</code><code class="n">loop</code><code class="o">=</code><code class="n">loop</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO3-4" href="#callout_asyncio_walk_through_CO3-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code class="k">for</code><code> </code><code class="n">task</code><code> </code><code class="ow">in</code><code> </code><code class="n">pending</code><code class="p">:</code><code>
</code><code>    </code><code class="n">task</code><code class="o">.</code><code class="n">cancel</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">group</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">gather</code><code class="p">(</code><code class="o">*</code><code class="n">pending</code><code class="p">,</code><code> </code><code class="n">return_exceptions</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code>
</code><code class="n">loop</code><code class="o">.</code><code class="n">run_until_complete</code><code class="p">(</code><code class="n">group</code><code class="p">)</code><code>
</code><code class="n">loop</code><code class="o">.</code><code class="n">close</code><code class="p">(</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO3-1" href="#co_asyncio_walk_through_CO3-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p><code>blocking()</code> calls the traditional <code>time.sleep()</code> internally, which <em>would have</em>
blocked the main thread and prevented your event loop from running.<a data-type="indexterm" data-primary="sleep" data-secondary="blocking vs. non-blocking sleep time" id="idm46363038159640"/><a data-type="indexterm" data-primary="time.sleep function" id="idm46363038183800"/><a data-type="indexterm" data-primary="blocking functions" data-secondary="sleep time" id="idm46363038183128"/> This means that
you must not make this function a coroutine—indeed, you
cannot even call this function from <em>anywhere</em> in the main thread, which
is where the <code>asyncio</code> loop is running. We solve this problem by running
this function in an <em>executor</em>.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO3-2" href="#co_asyncio_walk_through_CO3-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Unrelated to this section, but something to keep in mind for later in
the book: note that the blocking sleep time (0.5 seconds) is shorter than
the nonblocking sleep time (1 second)
in the <code>main()</code> coroutine.<a data-type="indexterm" data-primary="main coroutine" data-secondary="sleep time in" id="idm46363038177800"/> This makes the code sample neat and tidy. In
<a data-type="xref" href="#waitforexe">“Waiting for the Executor During Shutdown”</a> we’ll explore what happens if executor
functions outlive their async counterparts during the shutdown sequence.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO3-3" href="#co_asyncio_walk_through_CO3-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p><code>await loop.run_in_executor(None, func)</code><br/>
This is the last of our list of essential, must-know features of
<code>asyncio</code>. <a data-type="indexterm" data-primary="await loop.run_in_executor function" id="idm46363038126440"/>Sometimes you need to run things in a separate thread or
even a separate process: this method is used for exactly that. Here
we pass our blocking function to be run in the default executor.<sup><a data-type="noteref" id="idm46363038125400-marker" href="ch03.html#idm46363038125400">4</a></sup>
Note that <code>run_in_executor()</code> does <em>not</em> block the main thread: it
only schedules the executor task to run (it returns a <code>Future</code>, which
means you can <code>await</code> it if the method is called within another coroutine function).
The executor task will begin executing only after <code>run_until_complete()</code>
is called, which allows the event loop to start processing events.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO3-4" href="#co_asyncio_walk_through_CO3-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>Further to the note in callout 2: the set of tasks in <code>pending</code> does
<em>not</em> include an entry for the call to <code>blocking()</code> made in
<code>run_in_executor()</code>. This will be true of any call that returns a <code>Future</code>
rather than a <code>Task</code>. The documentation is quite good at specifying return
types, so you’ll see the return type there; just remember that <code>all_tasks()</code> really
does return only <code>Task</code>s, not <code>Future</code>s.</p></dd>
</dl></div>

<p>Here’s the output of running this script:</p>
<pre data-type="programlisting">
$ <strong>python quickstart_exe.py</strong>
Sun Aug 18 01:20:42 2019 Hello!
Sun Aug 18 01:20:43 2019 Hello from a thread!
Sun Aug 18 01:20:43 2019 Goodbye!
</pre>

<p>Now that you’ve seen the most essential parts of <code>asyncio</code> for
end-user developer needs, it’s time to expand our scope and arrange
the <code>asyncio</code> API into a kind of hierarchy. This will make it easier
to digest and understand how to take what you need from the documentation,
and no more.<a data-type="indexterm" data-primary="asyncio" data-secondary="quickstart" data-startref="ix_asyqk" id="idm46363038110744"/></p>
</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="The Tower of Asyncio"><div class="sect1" id="idm46363038712280">
<h1>The Tower of Asyncio</h1>

<p>As you saw in the preceding section, there are only
a handful of commands that you need to know to be able to use <code>asyncio</code> as
an end-user developer.<a data-type="indexterm" data-primary="asyncio" data-secondary="hierarchy in" id="ix_asyhier"/>  Unfortunately, the documentation for <code>asyncio</code>
presents a huge number of APIs, and it does so in a very
“flat” format that makes it hard to tell which things are intended for
common use and which are facilities being provided to framework designers.</p>

<p>When framework designers look at the same documentation, they look for
<em>hook points</em> to which they can connect up their new frameworks or
third-party libraries.<a data-type="indexterm" data-primary="hook points" id="idm46363038104120"/> In this section, we’ll look at <code>asyncio</code> through
the eyes of a framework designer to get a sense of how they might approach
building a new async-compatible library. Hopefully, this will help to further
delineate the features that you need to care about in your
own work.</p>

<p>From this perspective, it is much more useful to think about the <code>asyncio</code>
module as being arranged in a hierarchy (rather than a flat list), in
which each level is built on top of the specification of the previous level.
It isn’t quite as neat as that, unfortunately, and I’ve taken liberties with
the arrangement in <a data-type="xref" href="#features_of_asyncio_arranged_in_a_hierarchy">Table 3-1</a>, but hopefully this will give you an alternative view of the <code>asyncio</code> API.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><a data-type="xref" href="#features_of_asyncio_arranged_in_a_hierarchy">Table 3-1</a>, and the names and numbering of the “tiers” given
here, is entirely my own invention, intended to add a little structure
to help explain the <code>asyncio</code> API. The expert reader
might arrange things in a different order, and that’s OK!</p>
</div>
<table id="features_of_asyncio_arranged_in_a_hierarchy">
<caption><span class="label">Table 3-1. </span>Features of asyncio arranged in a hierarchy; for end-user developers, the most important tiers are highlighted in bold</caption>
<thead>
<tr>
<th>Level</th>
<th>Concept</th>
<th>Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><strong>Tier 9</strong></p></td>
<td><p><strong>Network: streams</strong></p></td>
<td><p><code>StreamReader</code>, <code>StreamWriter</code>,  <code>asyncio.open_connection()</code>, <code>asyncio.start_server()</code></p></td>
</tr>
<tr>
<td><p>Tier 8</p></td>
<td><p>Network: TCP &amp; UDP</p></td>
<td><p><code>Protocol</code></p></td>
</tr>
<tr>
<td><p>Tier 7</p></td>
<td><p>Network: transports</p></td>
<td><p><code>BaseTransport</code></p></td>
</tr>
<tr>
<td><p><strong>Tier 6</strong></p></td>
<td><p><strong>Tools</strong></p></td>
<td><p><code>asyncio.Queue</code></p></td>
</tr>
<tr>
<td><p><strong>Tier 5</strong></p></td>
<td><p><strong>Subprocesses &amp; threads</strong></p></td>
<td><p><code>run_in_executor()</code>, <code>asyncio.subprocess</code></p></td>
</tr>
<tr>
<td><p>Tier 4</p></td>
<td><p>Tasks</p></td>
<td><p><code>asyncio.Task</code>, <code>asyncio.create_task()</code></p></td>
</tr>
<tr>
<td><p>Tier 3</p></td>
<td><p>Futures</p></td>
<td><p><code>asyncio.Future</code></p></td>
</tr>
<tr>
<td><p><strong>Tier 2</strong></p></td>
<td><p><strong>Event loop</strong></p></td>
<td><p><code>asyncio.run()</code>, <code>BaseEventLoop</code></p></td>
</tr>
<tr>
<td><p><strong>Tier 1 (Base)</strong></p></td>
<td><p><strong>Coroutines</strong></p></td>
<td><p><code>async def</code>, <code>async with</code>, <code>async for</code>, <code>await</code></p></td>
</tr>
</tbody>
</table>

<p>At the most fundamental level, Tier 1, we have the coroutines that you’ve
already seen earlier in this book.<a data-type="indexterm" data-primary="coroutines" data-secondary="asyncio Tier 1 for framework developers" id="idm46363038067192"/><a data-type="indexterm" data-primary="async frameworks" id="idm46363038066248"/> This is the lowest level at which
one can begin to think about designing a third-party framework, and
surprisingly, this turns out to be somewhat popular with not one, but
<em>two</em>, async frameworks currently available in the wild:
<a href="https://oreil.ly/Zu0lP">Curio</a> and
<a href="https://oreil.ly/z2lZY">Trio</a>.<a data-type="indexterm" data-primary="Curio" id="idm46363038063464"/><a data-type="indexterm" data-primary="Trio" id="idm46363038062728"/>  Both of these rely <em>only</em>
on native coroutines in Python, and nothing whatsoever from the
<code>asyncio</code> library module.</p>

<p>The next level is the event loop.<a data-type="indexterm" data-primary="event loops" data-secondary="specification and implementation in asyncio" id="idm46363038060552"/><a data-type="indexterm" data-primary="coroutines" data-secondary="dependence on event loops to run them" id="idm46363038059608"/> Coroutines are not useful by
themselves: they won’t do anything without a loop on which to run them
(therefore, necessarily, Curio and Trio implement their own event
loops). <code>asyncio</code> provides both a loop <em>specification</em>, <code>AbstractEventLoop</code>, and an <em>implementation</em>, <code>BaseEventLoop</code>.<a data-type="indexterm" data-primary="BaseEventLoop" id="idm46363038056200"/><a data-type="indexterm" data-primary="AbstractEventLoop" id="idm46363038055464"/></p>

<p>The clear separation between specification and implementation makes it
possible for third-party developers to make alternative
implementations of the event loop, and this has already happened with
the <a href="https://oreil.ly/2itn_">uvloop</a> project, which
provides a much faster loop implementation than the one in the <code>asyncio</code>
standard library module.<a data-type="indexterm" data-primary="uvloop project" id="idm46363038052984"/><a data-type="indexterm" data-primary="MagicStack, uvloop project" id="idm46363038052280"/><a data-type="indexterm" data-primary="event loops" data-secondary="third-party implementations of" id="idm46363038051640"/> Importantly, uvloop simply “plugs into” the
hierarchy and replaces <em>only</em> the loop part of the stack.  The ability to
make these kinds of choices is exactly why the <code>asyncio</code> API has been
designed like this, with clear separation between the moving
parts.</p>

<p>Tiers 3 and 4 bring us futures and tasks, which are very closely
related; they’re separated only because <code>Task</code> is a subclass of
<code>Future</code>, but they<a data-type="indexterm" data-primary="futures" data-secondary="Future vs. Task instances" id="idm46363038048136"/><a data-type="indexterm" data-primary="tasks" data-secondary="futures and" data-tertiary="Task vs. Future class" id="idm46363038047160"/> could easily be considered to be in the same tier.
A <code>Future</code> instance represents some sort of ongoing action that will
return a result via <em>notification</em> on the event loop, while a <code>Task</code>
represents a coroutine running on the event loop.<a data-type="indexterm" data-primary="coroutines" data-secondary="Task instances as coroutine-aware" id="idm46363038044600"/><a data-type="indexterm" data-primary="notifications, Future instances returning" id="idm46363038043608"/><a data-type="indexterm" data-primary="event loops" data-secondary="future and tasks as loop-aware" id="idm46363038042968"/> The short version is: a future
is “loop-aware,” while a task is both “loop-aware” <em>and</em>
“coroutine-aware.” As an end-user developer, you will be working
with tasks much more than futures, but for a framework designer, the
proportion might be the other way around, depending on the details.</p>

<p>Tier 5 represents the facilities for launching,  and awaiting on work that
must be run in a separate thread, or even in a separate process.</p>

<p>Tier 6 represents additional async-aware tools such as <span class="keep-together"><code>asyncio.Queue</code></span>. I
could have placed this tier after the network tiers, but I think it’s
neater to get all of the coroutine-aware APIs out of the way first, before
we look at the I/O layers.<a data-type="indexterm" data-primary="Queue class" data-secondary="asyncio.Queue vs. thread-safe Queue in queue module" id="idm46363038038872"/><a data-type="indexterm" data-primary="asyncio.Queue class" id="idm46363038037960"/> The <code>Queue</code> provided by <code>asyncio</code> has a very
similar API to the thread-safe <code>Queue</code> in the <code>queue</code> module, except that
the <code>asyncio</code> version requires the <code>await</code> keyword on <code>get()</code> and <code>put()</code>. You
cannot use <code>queue.Queue</code> directly inside coroutines because its <code>get()</code>
will block the main thread.<a data-type="indexterm" data-primary="await keyword" data-secondary="on asyncio.Queue get and put functions" id="idm46363038032808"/></p>

<p>Finally, we have the network I/O tiers, 7 through 9.<a data-type="indexterm" data-primary="network I/O tiers for end-user developers" id="idm46363038031464"/> As an end-user
developer, the most convenient API to work with is the streams API
at Tier 9. <a data-type="indexterm" data-primary="streams API" id="idm46363038030552"/>I have positioned the streams API at the highest level of
abstraction in the tower.<a data-type="indexterm" data-primary="protocols API" id="idm46363038029752"/>  The protocols API, <span class="keep-together">immediately</span> below
that (Tier 8), is a more fine-grained API; you
<em>can</em> use the protocols tier in all instances where you might use
the streams tier, but using streams will be simpler. The final network I/O tier is the transport tier (Tier 7).<a data-type="indexterm" data-primary="transport tier" id="idm46363038027656"/> It is
unlikely you will ever have to work with this tier
directly, unless you’re creating a framework for others to use and
you need to customize how the transports are set up.</p>

<p>In <a data-type="xref" href="#quickstart-section">“Quickstart”</a>, we looked at the absolute bare minimum
that one would need to know to get started with the <code>asyncio</code> library.
Now that we’ve had a look at how the entire <code>asyncio</code> library API is
put together, I’d like to revisit that short list of features and
reemphasize which parts you are likely to need to learn.</p>

<p>These are the tiers that are most important to focus on when learning
how to use the <code>asyncio</code> library module<a data-type="indexterm" data-primary="network programming" data-secondary="asyncio tiers most important for" id="idm46363038023608"/> for writing network
applications:</p>
<dl>
<dt>Tier 1</dt>
<dd>
<p>Understanding how to write <code>async def</code> functions and use
  <code>await</code> to call and execute other coroutines is essential.</p>
</dd>
<dt>Tier 2</dt>
<dd>
<p>Understanding how to start up, shut down, and interact with
  the event loop is essential.<a data-type="indexterm" data-primary="event loops" data-secondary="starting up, shutting down, and interacting with" id="idm46363038018312"/></p>
</dd>
<dt>Tier 5</dt>
<dd>
<p>Executors are necessary to use blocking code in
  your async application, and the reality is that most third-party
  libraries are not yet <code>asyncio</code>-compatible.<a data-type="indexterm" data-primary="executors" data-secondary="necessity for using blocking code in async applications" id="idm46363038015384"/> A good example of this
  is the SQLAlchemy database ORM library, for which no feature-comparable
  alternative is available right now for <code>asyncio</code>.<a data-type="indexterm" data-primary="SQLAlchemy database ORM library" id="idm46363038013672"/></p>
</dd>
<dt>Tier 6</dt>
<dd>
<p>If you need to feed data to one or more long-running
  coroutines, the best way to do that is with <code>asyncio.Queue</code>.<a data-type="indexterm" data-primary="coroutines" data-secondary="feeding data to, with asyncio.Queue" id="idm46363038010840"/><a data-type="indexterm" data-primary="Queue class" data-secondary="using asyncio.Queue to feed data to coroutines" id="idm46363038009864"/><a data-type="indexterm" data-primary="asyncio.Queue class" data-secondary="using to feed data to coroutines" id="idm46363038008888"/> This
  is exactly the same strategy as using <code>queue.Queue</code> for distributing
  data between threads. The Asyncio version of <code>Queue</code> uses the
  same API as the standard library queue module, but uses coroutines
  instead of the blocking methods like <code>get()</code>.</p>
</dd>
<dt>Tier 9</dt>
<dd>
<p>The streams API gives you the simplest way to handle
  socket communication over a network, and it is here that you should
  begin prototyping ideas for <span class="keep-together">network</span> applications.<a data-type="indexterm" data-primary="streams API" data-secondary="handling socket communication over networks" id="idm46363038004376"/><a data-type="indexterm" data-primary="sockets" data-secondary="communication, handling with streams API" id="idm46363038003272"/> You may find that more
  fine-grained control is needed, and then you could switch to the
  protocols API, but in most projects it’s usually best to keep
  things simple until you know exactly what problem you’re trying to
  solve.</p>
</dd>
</dl>

<p>Of course, if you’re using an <code>asyncio</code>-compatible third-party library
that handles all the socket communication for you, like <code>aiohttp</code>,
you won’t need to directly work with the <code>asyncio</code> network tiers
at all.<a data-type="indexterm" data-primary="libraries" data-secondary="asyncio-compatible third-party libraries handling socket communication" id="idm46363038000168"/> In this case, you must rely heavily on the documentation provided
with the library.</p>

<p>The <code>asyncio</code> library
tries to provide sufficient features for both end-user developers
and framework designers. Unfortunately, this means that the
<code>asyncio</code> API can appear somewhat sprawling. I hope that this section
has provided enough of a road map to help you pick out the parts you
need.</p>

<p>In the next sections, we’re going to look at the component parts of the preceding list in more detail.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The
<a href="http://bit.ly/2toWDL1">pysheeet</a> site
provides an in-depth summary (or “cheat sheet”) of large chunks of the
<code>asyncio</code> API; each concept is presented with a short code
snippet.<a data-type="indexterm" data-primary="pysheet site, in-depth summary of asyncio API" id="idm46363037994840"/> The presentation is dense, so I wouldn’t recommend it for
beginners, but if you have experience with Python and you’re the kind
of person who “gets it” only when new programming info is presented in code, this is sure to
be a useful resource.<a data-type="indexterm" data-primary="asyncio" data-secondary="hierarchy in" data-startref="ix_asyhier" id="idm46363037993640"/></p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Coroutines"><div class="sect1" id="idm46363038108680">
<h1>Coroutines</h1>

<p>Let’s begin at the very beginning: what is a coroutine?<a data-type="indexterm" data-primary="coroutines" id="ix_coros"/><a data-type="indexterm" data-primary="asyncio" data-secondary="coroutines" id="ix_asycor"/></p>

<p>My goal in this section is to help you understand the specific meaning
behind terms like <em>coroutine object</em> and <em>asynchronous function</em>. <a data-type="indexterm" data-primary="coroutine object" id="idm46363037987720"/><a data-type="indexterm" data-primary="asynchronous functions" id="idm46363037986984"/>The
examples that follow will show low-level interactions not normally
required in most programs; however, the examples will help give you a clearer
understanding of the fundamental parts of Asyncio, and will make later
sections much easier to grasp.</p>

<p>The following examples can all be reproduced in a Python 3.8 interpreter in
interactive mode, and I urge you to work through them on your own by typing
them yourself, observing the output, and perhaps experimenting with different ways of
interacting with <code>async</code> and <code>await</code>.</p>
<div data-type="caution"><h6>Caution</h6>
<p><code>asyncio</code> was first added to Python 3.4, but the new syntax for
coroutines using <code>async def</code> and <code>await</code> was only added in Python 3.5. How
did people <a data-type="indexterm" data-primary="Python" data-secondary="asyncio and coroutines in versions 3.4 and 3.5" id="idm46363037981816"/><a data-type="indexterm" data-primary="coroutines" data-secondary="new syntax in Python 3.5 using async def and await" id="idm46363037980744"/><a data-type="indexterm" data-primary="await keyword" data-secondary="coroutines generated using async def and await" id="idm46363037979768"/>do anything with <code>asyncio</code> in 3.4? <a data-type="indexterm" data-primary="generator functions" data-secondary="coroutines based on (Python 3.4)" id="idm46363037978248"/>They used <em>generators</em>
in very special ways to act as if they were coroutines.  In some
older codebases, you’ll see generator functions decorated with
<code>@asyncio.coroutine</code> and containing <code>yield from</code> statements.<a data-type="indexterm" data-primary="@asyncio.coroutine decorator" id="idm46363037975720"/><a data-type="indexterm" data-primary="yield from statements" id="idm46363037975016"/> Coroutines
created with the newer <code>async def</code> are now referred to as <em>native
coroutines</em> because they are built into the language as coroutines and nothing
else. This book ignores the older generator-based coroutines entirely.</p>
</div>








<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="The New async def Keywords"><div class="sect2" id="idm46363037973208">
<h2>The New async def Keywords</h2>

<p>Let us begin with the simplest <a data-type="indexterm" data-primary="async def functions" data-secondary="new async def keywords" id="idm46363037971128"/><a data-type="indexterm" data-primary="coroutines" data-secondary="declaring, using new async def keywords" id="idm46363037970152"/><a data-type="indexterm" data-primary="asynchronous functions" data-secondary="new async def keywords" id="idm46363037969144"/>possible thing, shown in <a data-type="xref" href="#firstsurprise">Example 3-4</a>.</p>
<div id="firstsurprise" data-type="example">
<h5><span class="label">Example 3-4. </span>Async functions are functions, not coroutines</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">f</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO4-1" href="#callout_asyncio_walk_through_CO4-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>   </code><code class="k">return</code><code> </code><code class="mi">123</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="nb">type</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO4-2" href="#callout_asyncio_walk_through_CO4-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="o">&lt;</code><code class="k">class</code><code> </code><code class="err">'</code><code class="nc">function</code><code class="s1">'</code><code class="s1">&gt;</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="kn">import</code><code> </code><code class="nn">inspect</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO4-3" href="#callout_asyncio_walk_through_CO4-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">inspect</code><code class="o">.</code><code class="n">iscoroutinefunction</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO4-4" href="#callout_asyncio_walk_through_CO4-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code class="kc">True</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO4-1" href="#co_asyncio_walk_through_CO4-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>This is the simplest possible declaration of a coroutine: it looks like
a regular function, except that it begins with the keywords <code>async def</code>.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO4-2" href="#co_asyncio_walk_through_CO4-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Surprise! The precise type of <code>f</code> is <em>not</em> “coroutine”; it’s just an
ordinary function. While it is common to refer to
<code>async def</code> functions as coroutines, strictly speaking they are
considered by Python to be <em>coroutine functions</em>.<a data-type="indexterm" data-primary="generator functions" data-secondary="coroutine functions and" id="idm46363037904040"/><a data-type="indexterm" data-primary="coroutine functions" data-seealso="coroutines" id="idm46363037903032"/> This behavior is
identical to the way generator functions work in Python:<br/></p>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;&gt;</code> <code class="k">def</code> <code class="nf">g</code><code class="p">():</code>
<code class="o">...</code>     <code class="k">yield</code> <code class="mi">123</code>
<code class="o">...</code>
<code class="o">&gt;&gt;&gt;</code> <code class="nb">type</code><code class="p">(</code><code class="n">g</code><code class="p">)</code>
<code class="o">&lt;</code><code class="k">class</code> <code class="err">'</code><code class="nc">function</code><code class="s1">'&gt;</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">gen</code> <code class="o">=</code> <code class="n">g</code><code class="p">()</code>
<code class="o">&gt;&gt;&gt;</code> <code class="nb">type</code><code class="p">(</code><code class="n">gen</code><code class="p">)</code>
<code class="o">&lt;</code><code class="k">class</code> <code class="err">'</code><code class="nc">generator</code><code class="s1">'&gt;</code></pre>

<p>Even though <code>g</code> is sometimes incorrectly referred to as a “generator,”
it remains a
function, and it is only when this function is <em>evaluated</em> that the
generator is returned. Coroutine functions work in exactly the same
way: you need to <em>call</em> the <code>async def</code> function to obtain the coroutine object.<a data-type="indexterm" data-primary="type function" id="idm46363037829080"/><a data-type="indexterm" data-primary="inspect module" data-secondary="introspection with" id="idm46363037828376"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO4-3" href="#co_asyncio_walk_through_CO4-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>The <code>inspect</code> module in the standard library can provide much better
introspective capabilities than the <code>type()</code> built-in function.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO4-4" href="#co_asyncio_walk_through_CO4-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>There is an <code>iscoroutinefunction()</code> function that lets you
distinguish between an ordinary function and a coroutine function.<a data-type="indexterm" data-primary="iscoroutinefunction function" id="idm46363037821256"/></p></dd>
</dl></div>

<p>Returning to our <code>async def f()</code>, <a data-type="xref" href="#adefretcoro">Example 3-5</a> reveals what happens when we
call it.<a data-type="indexterm" data-primary="coroutine object" data-secondary="returned by async def function" id="idm46363037818952"/></p>
<div id="adefretcoro" data-type="example">
<h5><span class="label">Example 3-5. </span>An async def function returns a coroutine object</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;&gt;</code> <code class="n">coro</code> <code class="o">=</code> <code class="n">f</code><code class="p">()</code>
<code class="o">&gt;&gt;&gt;</code> <code class="nb">type</code><code class="p">(</code><code class="n">coro</code><code class="p">)</code>
<code class="o">&lt;</code><code class="k">class</code> <code class="err">'</code><code class="nc">coroutine</code><code class="s1">'&gt;</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">inspect</code><code class="o">.</code><code class="n">iscoroutine</code><code class="p">(</code><code class="n">coro</code><code class="p">)</code>
<code class="kc">True</code></pre></div>

<p>This brings us back to our original question: what exactly is a coroutine? A <em>coroutine</em> is an
<em>object</em> that encapsulates the ability to resume an underlying
function that has been suspended before completion. <a data-type="indexterm" data-primary="coroutines" data-secondary="defined" id="idm46363037765704"/>If that sounds familiar,
it’s because coroutines are very similar to generators. <a data-type="indexterm" data-primary="native coroutines" id="idm46363037764696"/>Indeed, before the introduction of
<em>native</em> coroutines with the <code>async def</code> and <code>await</code> keywords in Python
3.5, it was already possible to use the <code>asyncio</code> library in Python 3.4
by using normal generators with special decorators.<sup><a data-type="noteref" id="idm46363037762200-marker" href="ch03.html#idm46363037762200">5</a></sup> It isn’t
surprising that the new <code>async def</code> functions (and the coroutines they
return) behave in a similar way to generators.</p>

<p>We can play with coroutine objects a bit more to see how Python makes use
of them. Most importantly, we want to see how Python is able to
“switch” execution between coroutines. Let’s first look at how the
return value can be obtained.</p>

<p>When <a data-type="indexterm" data-primary="StopIteration exception" id="idm46363037760312"/>a coroutine <em>returns</em>, what really happens is that a
<code>StopIteration</code> exception is raised. <a data-type="xref" href="#corointernals">Example 3-6</a>, which
continues in the same session as the previous examples, makes that
clear.<a data-type="indexterm" data-primary="coroutines" data-secondary="using send function and StopIteration" id="idm46363037757752"/></p>
<div id="corointernals" data-type="example">
<h5><span class="label">Example 3-6. </span>Coroutine internals: using send() and StopIteration</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">f</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>    </code><code class="k">return</code><code> </code><code class="mi">123</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">coro</code><code> </code><code class="o">=</code><code> </code><code class="n">f</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">try</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>   </code><code class="n">coro</code><code class="o">.</code><code class="n">send</code><code class="p">(</code><code class="kc">None</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO5-1" href="#callout_asyncio_walk_through_CO5-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code> </code><code class="k">except</code><code> </code><code class="ne">StopIteration</code><code> </code><code class="k">as</code><code> </code><code class="n">e</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>   </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">The answer was:</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">e</code><code class="o">.</code><code class="n">value</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO5-2" href="#callout_asyncio_walk_through_CO5-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="n">The</code><code> </code><code class="n">answer</code><code> </code><code class="n">was</code><code class="p">:</code><code> </code><code class="mi">123</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO5-1" href="#co_asyncio_walk_through_CO5-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>A coroutine is <em>initiated</em> by “sending” it a <code>None</code>.
Internally, this is what the <em>event loop</em> is going to be doing to your
precious <span class="keep-together">coroutines</span>; you will never have to do this manually. All the  <span class="keep-together">coroutines
you</span> make will be executed either with <span class="keep-together"><code>loop.create_task(<em>coro</em>)</code></span> or
<span class="keep-together"><code>await <em>coro</em></code></span>. It’s the <code>loop</code> that does the <code>.send(None)</code> behind the
scenes.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO5-2" href="#co_asyncio_walk_through_CO5-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>When the coroutine <em>returns</em>, a special kind of exception is raised,
called <code>StopIteration</code>. Note that we can access the return value of the
coroutine via the <code>value</code> attribute of the exception itself. Again, you don’t
need to know that it works like this: from your point of view, <code>async def</code>
functions will simply return a value with the <code>return</code> statement, just like
normal functions.</p></dd>
</dl></div>

<p>These two points, the <code>send()</code> and the <code>StopIteration</code>, define
the start and end of the executing coroutine, respectively. So far
this just seems like a really convoluted way to run a function, but
that’s OK: the <em>event loop</em> will be responsible for driving coroutines
with these low-level internals.<a data-type="indexterm" data-primary="event loops" data-secondary="driving coroutines" id="idm46363033413432"/> From your point of view, you will simply
schedule coroutines for execution on the loop, and they will get executed
top-down, almost like normal functions.</p>

<p>The next step is to see how the execution of the coroutine can be
suspended.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The New await Keyword"><div class="sect2" id="idm46363037972584">
<h2>The New await Keyword</h2>

<p>This new keyword <a href="https://oreil.ly/uk4H3"><code>await</code></a> always takes a parameter and will accept <em>only</em> a thing called an <em>awaitable</em>, which <a data-type="indexterm" data-primary="awaitables" id="idm46363033408584"/><a data-type="indexterm" data-primary="coroutines" data-secondary="await keyword and" id="idm46363033407976"/><a data-type="indexterm" data-primary="await keyword" data-secondary="using on coroutines" id="idm46363033407128"/>is defined as one
of these (exclusively!):</p>

<ul>
<li>
<p>A coroutine (i.e., the <em>result</em> of a called <code>async def</code> function).<sup><a data-type="noteref" id="idm46363033404616-marker" href="ch03.html#idm46363033404616">6</a></sup></p>
</li>
<li>
<p>Any object implementing the <code>__await__()</code> special method. That special method <em>must</em> return an iterator.<a data-type="indexterm" data-primary="__await__ special method" data-primary-sortas="await" id="idm46363033401544"/><a data-type="indexterm" data-primary="iterators" data-secondary="returned by use of await special method" id="idm46363033400696"/></p>
</li>
</ul>

<p>The second kind of awaitable is out of scope for this book (you’ll never
need it in day-to-day <code>asyncio</code> programming), but the first use
case is pretty straightforward, as <a data-type="xref" href="#firstawait">Example 3-7</a> shows.</p>
<div id="firstawait" data-type="example">
<h5><span class="label">Example 3-7. </span>Using await on a coroutine</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">f</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">1.0</code><code class="p">)</code><code>
</code><code>    </code><code class="k">return</code><code> </code><code class="mi">123</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">result</code><code> </code><code class="o">=</code><code> </code><code class="k">await</code><code> </code><code class="n">f</code><code class="p">(</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO6-1" href="#callout_asyncio_walk_through_CO6-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>    </code><code class="k">return</code><code> </code><code class="n">result</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO6-1" href="#co_asyncio_walk_through_CO6-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Calling <code>f()</code> produces a coroutine; this means we are allowed to <code>await</code> it.
The value of the <code>result</code> variable will be <code>123</code> when <code>f()</code> completes.</p></dd>
</dl></div>

<p>Before we close out this section and move on to the event loop, it is
useful to <a data-type="indexterm" data-primary="coroutines" data-secondary="using coro.throw function to inject exceptions" id="idm46363033352120"/><a data-type="indexterm" data-primary="tasks" data-secondary="cancellation with task.cancel function" id="idm46363033351176"/><a data-type="indexterm" data-primary="coro.throw function" id="idm46363033350264"/><a data-type="indexterm" data-primary="asyncio.CancelledError" id="idm46363033349592"/><a data-type="indexterm" data-primary="CancelledError exception" data-secondary="raising inside coroutines" id="idm46363033348920"/><a data-type="indexterm" data-primary="exceptions" data-secondary="feeding to coroutines to cancel them" id="idm46363033323784"/>look at how coroutines may be fed exceptions. This is most
commonly used for cancellation: when you
call <code>task.cancel()</code>,
the event loop will internally use <code>coro.throw()</code> to
raise <code>asyncio.CancelledError</code> <em>inside</em> your coroutine (<a data-type="xref" href="#injectexcept">Example 3-8</a>).</p>
<div id="injectexcept" data-type="example">
<h5><span class="label">Example 3-8. </span>Using coro.throw() to inject exceptions into a coroutine</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">coro</code><code> </code><code class="o">=</code><code> </code><code class="n">f</code><code class="p">(</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO7-1" href="#callout_asyncio_walk_through_CO7-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">coro</code><code class="o">.</code><code class="n">send</code><code class="p">(</code><code class="kc">None</code><code class="p">)</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">coro</code><code class="o">.</code><code class="n">throw</code><code class="p">(</code><code class="ne">Exception</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">blah</code><code class="s1">'</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO7-2" href="#callout_asyncio_walk_through_CO7-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="n">Traceback</code><code> </code><code class="p">(</code><code class="n">most</code><code> </code><code class="n">recent</code><code> </code><code class="n">call</code><code> </code><code class="n">last</code><code class="p">)</code><code class="p">:</code><code>
</code><code>  </code><code class="n">File</code><code> </code><code class="s2">"</code><code class="s2">&lt;stdin&gt;</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="n">line</code><code> </code><code class="mi">1</code><code class="p">,</code><code> </code><code class="ow">in</code><code> </code><code class="o">&lt;</code><code class="n">module</code><code class="o">&gt;</code><code>
</code><code>  </code><code class="n">File</code><code> </code><code class="s2">"</code><code class="s2">&lt;stdin&gt;</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="n">line</code><code> </code><code class="mi">2</code><code class="p">,</code><code> </code><code class="ow">in</code><code> </code><code class="n">f</code><code>
</code><code class="ne">Exception</code><code class="p">:</code><code> </code><code class="n">blah</code><code>
</code><code class="n">blah</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO7-1" href="#co_asyncio_walk_through_CO7-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>As before, a new coroutine is created from the coroutine function <code>f()</code>.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO7-2" href="#co_asyncio_walk_through_CO7-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Instead of doing another <code>send()</code>, we call <code>throw()</code> and provide an
exception class and a value. This raises an exception <em>inside</em> our
coroutine, at the <code>await</code> point.<a data-type="indexterm" data-primary="throw function" id="idm46363033235512"/></p></dd>
</dl></div>

<p>The <code>throw()</code> method is used (internally in <code>asyncio</code>) for <em>task
cancellation</em>, which we can also demonstrate quite easily.<a data-type="indexterm" data-primary="coroutines" data-secondary="cancellation with CancelledError" id="idm46363033232792"/> We’re even
going to go ahead in <a data-type="xref" href="#corocancel">Example 3-9</a> and handle the cancellation inside a new <span class="keep-together">coroutine</span>.</p>
<div id="corocancel" data-type="example">
<h5><span class="label">Example 3-9. </span>Coroutine cancellation with CancelledError</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">f</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">try</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="k">while</code><code> </code><code class="kc">True</code><code class="p">:</code><code> </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">except</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">CancelledError</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO8-1" href="#callout_asyncio_walk_through_CO8-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">I was cancelled!</code><code class="s1">'</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO8-2" href="#callout_asyncio_walk_through_CO8-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">else</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="k">return</code><code> </code><code class="mi">111</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">coro</code><code> </code><code class="o">=</code><code> </code><code class="n">f</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">coro</code><code class="o">.</code><code class="n">send</code><code class="p">(</code><code class="kc">None</code><code class="p">)</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">coro</code><code class="o">.</code><code class="n">send</code><code class="p">(</code><code class="kc">None</code><code class="p">)</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">coro</code><code class="o">.</code><code class="n">throw</code><code class="p">(</code><code class="n">asyncio</code><code class="o">.</code><code class="n">CancelledError</code><code class="p">)</code><code> </code><a class="co" id="co_asyncio_walk_through_CO8-3" href="#callout_asyncio_walk_through_CO8-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="n">I</code><code> </code><code class="n">was</code><code> </code><code class="n">cancelled</code><code class="err">!</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO8-4" href="#callout_asyncio_walk_through_CO8-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code class="n">Traceback</code><code> </code><code class="p">(</code><code class="n">most</code><code> </code><code class="n">recent</code><code> </code><code class="n">call</code><code> </code><code class="n">last</code><code class="p">)</code><code class="p">:</code><code>
</code><code>  </code><code class="n">File</code><code> </code><code class="s2">"</code><code class="s2">&lt;stdin&gt;</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="n">line</code><code> </code><code class="mi">1</code><code class="p">,</code><code> </code><code class="ow">in</code><code> </code><code class="o">&lt;</code><code class="n">module</code><code class="o">&gt;</code><code>
</code><code class="ne">StopIteration</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO8-5" href="#callout_asyncio_walk_through_CO8-5"><img src="assets/5.png" alt="5"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO8-1" href="#co_asyncio_walk_through_CO8-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Our coroutine function now handles an exception. In fact, it handles the <em>specific</em>
exception type used throughout the <code>asyncio</code> library for task
cancellation: <span class="keep-together"><code>asyncio.CancelledError</code></span>. Note that the exception is being injected into the coroutine from outside; i.e.,
by the event loop, which we’re still simulating with manual <code>send()</code>
and <code>throw()</code> commands. In real code, which you’ll see later, <span class="keep-together"><code>CancelledError</code></span> is raised inside the task-wrapped coroutine when tasks are <span class="keep-together">cancelled.</span></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO8-2" href="#co_asyncio_walk_through_CO8-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>A simple message to say that the task got cancelled. Note that by handling the
exception, we ensure it will no longer propagate and our coroutine will <code>return</code>.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO8-3" href="#co_asyncio_walk_through_CO8-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Here we <code>throw()</code> the <code>CancelledError</code> exception.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO8-4" href="#co_asyncio_walk_through_CO8-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>As expected, we see our cancellation message being printed.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO8-5" href="#co_asyncio_walk_through_CO8-5"><img src="assets/5.png" alt="5"/></a></dt>
<dd><p>Our coroutine exits normally.  (Recall that the <code>StopIteration</code>
exception is the normal way that coroutines exit.)</p></dd>
</dl></div>

<p>Just to drive home the point about how task cancellation is nothing more
than regular exception raising (and handling), let’s look at <a data-type="xref" href="#absorbcancel">Example 3-10</a>,
where we  absorb cancellation and move on to a different coroutine.</p>
<div id="absorbcancel" data-type="example">
<h5><span class="label">Example 3-10. </span>For educational purposes only—don’t do this!</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">f</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">try</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="k">while</code><code> </code><code class="kc">True</code><code class="p">:</code><code> </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">except</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">CancelledError</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Nope!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="k">while</code><code> </code><code class="kc">True</code><code class="p">:</code><code> </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code><code> </code><a class="co" id="co_asyncio_walk_through_CO9-1" href="#callout_asyncio_walk_through_CO9-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">else</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="k">return</code><code> </code><code class="mi">111</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">coro</code><code> </code><code class="o">=</code><code> </code><code class="n">f</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">coro</code><code class="o">.</code><code class="n">send</code><code class="p">(</code><code class="kc">None</code><code class="p">)</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">coro</code><code class="o">.</code><code class="n">throw</code><code class="p">(</code><code class="n">asyncio</code><code class="o">.</code><code class="n">CancelledError</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO9-2" href="#callout_asyncio_walk_through_CO9-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="n">Nope</code><code class="err">!</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">coro</code><code class="o">.</code><code class="n">send</code><code class="p">(</code><code class="kc">None</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO9-3" href="#callout_asyncio_walk_through_CO9-3"><img src="assets/3.png" alt="3"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO9-1" href="#co_asyncio_walk_through_CO9-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Instead of printing a message, what happens if after cancellation,
we just go right back to awaiting another awaitable?</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO9-2" href="#co_asyncio_walk_through_CO9-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Unsurprisingly, our outer coroutine continues to live, and it immediately
suspends again inside the <em>new</em> coroutine.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO9-3" href="#co_asyncio_walk_through_CO9-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Everything proceeds normally, and our coroutine continues to suspend
and resume as expected.</p></dd>
</dl></div>

<p>Of course, it should go without saying that you should never actually
do this! If your coroutine receives a cancellation signal, that is a
clear directive to do only whatever cleanup is necessary and exit. Don’t
just ignore it.</p>

<p>By this point, it’s getting pretty tiring <em>pretending</em>
to be an event loop by manually doing all the <code>.send(None)</code> calls, so
in <a data-type="xref" href="#finallyloop">Example 3-11</a> we’ll bring in the loop provided by <code>asyncio</code> and clean up
the preceding example accordingly.<a data-type="indexterm" data-primary="event loops" data-secondary="using to execute coroutines" id="idm46363032833064"/><a data-type="indexterm" data-primary="coroutines" data-secondary="using event loop to execute" id="idm46363032809016"/></p>
<div id="finallyloop" data-type="example">
<h5><span class="label">Example 3-11. </span>Using the event loop to execute coroutines</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">f</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">return</code><code> </code><code class="mi">111</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">(</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO10-1" href="#callout_asyncio_walk_through_CO10-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">coro</code><code> </code><code class="o">=</code><code> </code><code class="n">f</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">run_until_complete</code><code class="p">(</code><code class="n">coro</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO10-2" href="#callout_asyncio_walk_through_CO10-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="mi">111</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO10-1" href="#co_asyncio_walk_through_CO10-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Obtain a loop.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO10-2" href="#co_asyncio_walk_through_CO10-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Run the coroutine to completion. Internally, this is doing all those
<code>.send(None)</code> method calls for us, and it detects completion of our coroutine
with the <span class="keep-together"><code>StopIteration</code></span> exception, which also contains our return value.<a data-type="indexterm" data-primary="coroutines" data-startref="ix_coros" id="idm46363032750360"/><a data-type="indexterm" data-primary="asyncio" data-secondary="coroutines" data-startref="ix_asycor" id="idm46363032749416"/></p></dd>
</dl></div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Event Loop"><div class="sect1" id="idm46363033411304">
<h1>Event Loop</h1>

<p>The preceding section showed how the <code>send()</code> and <code>throw()</code>
methods can interact with a coroutine, but that was just to help you understand
how coroutines themselves are structured. <a data-type="indexterm" data-primary="asyncio" data-secondary="event loops" id="ix_asyevlp"/><a data-type="indexterm" data-primary="event loops" id="ix_evlp"/>The event loop
in <code>asyncio</code> handles all of the switching between coroutines, as well
as catching those <code>StopIteration</code> exceptions—and much more, such as
listening to sockets and file descriptors for events.</p>

<p>You can get by without ever needing to work with the event loop
directly: your <code>asyncio</code> code can be written entirely using <code>await</code> calls,
initiated by an <code>asyncio.run(<em>coro</em>)</code> call.
However, at times some degree of interaction with the
event loop itself might be necessary, and here we’ll discuss how to
obtain it.<a data-type="indexterm" data-primary="event loops" data-secondary="getting" id="idm46363032703672"/></p>

<p>There are two ways:</p>
<dl>
<dt><em>Recommended</em></dt>
<dd>
<p><code>asyncio.get_running_loop()</code>, callable from inside the context of a
   coroutine</p>
</dd>
<dt><em>Discouraged</em></dt>
<dd>
<p><code>asyncio.get_event_loop()</code>, callable from anywhere</p>
</dd>
</dl>

<p>You’re going to see the discouraged function in much existing code, because
the newer <a data-type="indexterm" data-primary="asyncio.get_running_loop function" id="idm46363032698264"/><a data-type="indexterm" data-primary="get_running_loop function" id="idm46363032697656"/>function, <code>get_running_loop()</code>, was introduced much later, in Python 3.8.<a data-type="indexterm" data-primary="asyncio.get_event_loop function" id="idm46363032696536"/><a data-type="indexterm" data-primary="get_event_loop function" id="idm46363032695928"/>
Thus, it will be useful in practice to have a basic idea of how the older method
works, so we’ll look at both. Let’s start with <a data-type="xref" href="#sameloop">Example 3-12</a>.</p>
<div id="sameloop" data-type="example">
<h5><span class="label">Example 3-12. </span>Always getting the same event loop</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">loop2</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">loop</code><code> </code><code class="ow">is</code><code> </code><code class="n">loop2</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO11-1" href="#callout_asyncio_walk_through_CO11-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="kc">True</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO11-1" href="#co_asyncio_walk_through_CO11-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Both identifiers, <code>loop</code> and <code>loop2</code>, refer to the same instance.</p></dd>
</dl></div>

<p id="dont-pass-loop-around">This means that if you’re inside a coroutine function and you need access
to the loop instance, it’s fine to call <code>get_event_loop()</code> or
<code>get_running_loop()</code> to obtain it.  You <em>do not</em> need to pass an
explicit <code>loop</code> parameter through all your functions.</p>

<p>The situation is different if you’re a framework designer:
it would be better to design your functions to accept a <code>loop</code> parameter,
just in case your users are doing something unusual with
<a href="https://oreil.ly/oMe9w">event loop policies</a>. Policies are out of scope for
this book, and we’ll say no more about them.</p>

<p>So if <code>get_event_loop()</code> and <code>get_running_loop()</code> work the same, why do they
both exist? The <code>get_event_loop()</code> method works only within the <em>same
thread</em>. In fact, <code>get_event_loop()</code> will fail if called inside a new
thread unless you specifically create a new loop with
<code>new_event_loop()</code>, <em>and</em> set that new instance to be <em>the</em> loop for
that thread by calling <code>set_event_loop()</code>. <a data-type="indexterm" data-primary="set_event_loop function" id="idm46363032627304"/><a data-type="indexterm" data-primary="new_event_loop function" id="idm46363032626696"/>Most of us will only ever
need (and want!) a single loop instance running in a single thread.
This is nearly the entire point of async programming in the first
place.</p>

<p>In <a data-type="indexterm" data-primary="get_running_loop function" data-secondary="advantages over get_event_loop" id="idm46363032625656"/><a data-type="indexterm" data-primary="asyncio.get_running_loop function" data-secondary="advantages over get_event_loop" id="idm46363032624808"/>contrast, <code>get_running_loop()</code> (the recommended method) will always do
what you expect: because it can be called only within the context of
a coroutine, a task, or a function called from one of those, it always
provides the <em>current</em> running event loop, which is almost always what
you want.</p>

<p>The introduction of <code>get_running_loop()</code> has also simplified the spawning
of background tasks. <a data-type="indexterm" data-primary="tasks" data-secondary="creating inside coroutine function and not awaiting" id="idm46363032622088"/>Consider <a data-type="xref" href="#creatingtasks">Example 3-13</a>, a coroutine
function inside which additional tasks are created and <em>not</em> awaited.</p>
<div id="creatingtasks" data-type="example">
<h5><span class="label">Example 3-13. </span>Creating tasks</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="k">async</code> <code class="k">def</code> <code class="nf">f</code><code class="p">():</code>
    <code class="c1"># Create some tasks!</code>
    <code class="n">loop</code> <code class="o">=</code> <code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">()</code>
    <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">():</code>
        <code class="n">loop</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="o">&lt;</code><code class="n">some</code> <code class="n">other</code> <code class="n">coro</code><code class="o">&gt;</code><code class="p">)</code></pre></div>

<p>In this example, the intention is to launch completely new tasks inside the
coroutine. By not awaiting them, we ensure they will run independently of the execution
context inside coroutine function <code>f()</code>. In fact, <code>f()</code> will exit before
the tasks that it launched have completed.</p>

<p>Before Python 3.7, it was necessary to first obtain the <code>loop</code> instance
to schedule a task, but with the introduction of <code>get_running_loop()</code> came
other <code>asyncio</code> functions that use it, like <code>asyncio.create_task()</code>.<a data-type="indexterm" data-primary="asyncio.create_task function" id="idm46363032594776"/><a data-type="indexterm" data-primary="create_task function" id="idm46363032594072"/><a data-type="indexterm" data-primary="tasks" data-secondary="async, creating the modern way" id="idm46363032593400"/> From
Python 3.7 on, the code to spawn an async task now looks like <a data-type="xref" href="#newcreatetask">Example 3-14</a>.</p>
<div id="newcreatetask" data-type="example">
<h5><span class="label">Example 3-14. </span>Creating tasks the modern way</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="kn">import</code> <code class="nn">asyncio</code>

<code class="k">async</code> <code class="k">def</code> <code class="nf">f</code><code class="p">():</code>
    <code class="c1"># Create some tasks!</code>
    <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">():</code>
        <code class="n">asyncio</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="o">&lt;</code><code class="n">some</code> <code class="n">other</code> <code class="n">coro</code><code class="o">&gt;</code><code class="p">)</code></pre></div>

<p>It is also possible to use another low-level function
called <code>asyncio.ensure_future()</code> to spawn tasks in the same way as
<code>create_task()</code>, and you will likely still see calls to <code>ensure_future()</code> in older<a data-type="indexterm" data-primary="tasks" data-secondary="creating using asyncio.ensure_future" id="idm46363032573720"/><a data-type="indexterm" data-primary="asyncio.ensure_future function" id="idm46363032572840"/><a data-type="indexterm" data-primary="ensure_future function" id="idm46363032572200"/>
<code>asyncio</code> code. I considered avoiding the distraction of discussing
<code>ensure_future()</code>, but it is a perfect case study of an <code>asyncio</code>
API that was intended only for framework designers, but made the original
adoption of <code>asyncio</code> much more difficult to understand for application
developers. The difference between <code>asyncio.create_task()</code>
and <code>asyncio.ensure_future()</code> is
subtle and confusing for many newcomers. We explore these differences in
the next section.<a data-type="indexterm" data-primary="event loops" data-startref="ix_evlp" id="idm46363032537528"/><a data-type="indexterm" data-primary="asyncio" data-secondary="event loops" data-startref="ix_asyevlp" id="idm46363032536552"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Tasks and Futures"><div class="sect1" id="idm46363032574840">
<h1>Tasks and Futures</h1>

<p>Earlier we covered coroutines, and how they need to be
run on a loop to be useful.<a data-type="indexterm" data-primary="asyncio" data-secondary="tasks and futures" id="ix_asytskfut"/><a data-type="indexterm" data-primary="futures" data-secondary="tasks and" id="ix_futtsk"/><a data-type="indexterm" data-primary="tasks" data-secondary="futures and" id="ix_tskfut"/> Now I want to talk briefly about the <code>Task</code> and
<code>Future</code> APIs.  The one you will work with the most is <code>Task</code>, as most
of your work will involve running coroutines with the
<code>create_task()</code> function, exactly as set out in <a data-type="xref" href="#quickstart-section">“Quickstart”</a>.<a data-type="indexterm" data-primary="futures" data-secondary="tasks and" data-tertiary="Future class as superclass of Task" id="idm46363032527416"/> The <code>Future</code> class is actually a superclass of
<code>Task</code>, and it provides all of the functionality for
interaction with the loop.</p>

<p>A simple way to think of it is like this: a <code>Future</code> represents a
future completion state of some activity and is managed by the loop. A
<code>Task</code> is exactly the same, but the specific “activity” is a coroutine—
probably one of yours that you created with an <code>async def</code> function plus
<code>create_task()</code>.<a data-type="indexterm" data-primary="tasks" data-secondary="futures and" data-tertiary="Task vs. Future class" id="idm46363032523128"/></p>

<p>The <code>Future</code> class represents a <em>state</em> of something that is interacting
with a loop. That description is too fuzzy to be useful, so you can instead think of a
<code>Future</code> instance as a toggle for completion status.
When a <code>Future</code> instance is created, the toggle is set to “not yet completed,” but
at some later time it will be “completed.” In fact, a <code>Future</code> instance has a
method called <code>done()</code> that allows you to check the status, <a data-type="indexterm" data-primary="futures" data-secondary="tasks and" data-tertiary="checking completion status with Future.done" id="idm46363032518328"/><a data-type="indexterm" data-primary="Future.done method" id="idm46363032516984"/><a data-type="indexterm" data-primary="done method" id="idm46363032488760"/>as shown in <a data-type="xref" href="#futdone">Example 3-15</a>.</p>
<div id="futdone" data-type="example">
<h5><span class="label">Example 3-15. </span>Checking completion status with done()</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;&gt;</code> <code class="kn">from</code> <code class="nn">asyncio</code> <code class="k">import</code> <code class="n">Future</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">f</code> <code class="o">=</code> <code class="n">Future</code><code class="p">()</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">f</code><code class="o">.</code><code class="n">done</code><code class="p">()</code>
<code class="kc">False</code></pre></div>

<p>A <code>Future</code> instance may also do the following:</p>

<ul>
<li>
<p>Have a “result” value set (use <code>.set_result(<em>value</em>)</code> to<a data-type="indexterm" data-primary="set_result function" data-secondary="calling on Future instances" id="idm46363032461112"/><a data-type="indexterm" data-primary="futures" data-secondary="tasks and" data-tertiary="other capabilities of Future instance" id="idm46363032460136"/> set it and <code>.result()</code> to obtain it)</p>
</li>
<li>
<p>Be cancelled with <code>.cancel()</code> (and check for cancellation with <code>.cancelled()</code>)</p>
</li>
<li>
<p>Have additional callback functions added that will be run when the future <span class="keep-together">completes</span></p>
</li>
</ul>

<p>Even though <code>Task</code>s are more common, you can’t avoid <code>Future</code>s entirely: for
instance, running a function on an executor will return a <code>Future</code> instance,
<em>not</em> a <code>Task</code>. <a data-type="indexterm" data-primary="executors" data-secondary="running function on, returning Future instance" id="idm46363032452120"/> Let’s take a quick look at <a data-type="xref" href="#futmanip">Example 3-16</a> to get a feel for
what it is like to work with a <code>Future</code> instance directly.</p>
<div id="futmanip" data-type="example">
<h5><span class="label">Example 3-16. </span>Interaction with a Future instance</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="n">f</code><code class="p">:</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">Future</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO12-1" href="#callout_asyncio_walk_through_CO12-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="n">f</code><code class="o">.</code><code class="n">set_result</code><code class="p">(</code><code class="s1">'</code><code class="s1">I have finished.</code><code class="s1">'</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO12-2" href="#callout_asyncio_walk_through_CO12-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">fut</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">Future</code><code class="p">(</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO12-3" href="#callout_asyncio_walk_through_CO12-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="nb">print</code><code class="p">(</code><code class="n">fut</code><code class="o">.</code><code class="n">done</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO12-4" href="#callout_asyncio_walk_through_CO12-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code class="kc">False</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="n">fut</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO12-5" href="#callout_asyncio_walk_through_CO12-5"><img src="assets/5.png" alt="5"/></a><code>
</code><code class="o">&lt;</code><code class="n">Task</code><code> </code><code class="n">pending</code><code> </code><code class="n">name</code><code class="o">=</code><code class="s1">'</code><code class="s1">Task-1</code><code class="s1">'</code><code> </code><code class="n">coro</code><code class="o">=</code><code class="o">&lt;</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code> </code><code class="n">running</code><code> </code><code class="n">at</code><code> </code><code class="o">&lt;</code><code class="n">console</code><code class="o">&gt;</code><code class="p">:</code><code class="mi">1</code><code class="o">&gt;&gt;</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">run_until_complete</code><code class="p">(</code><code class="n">fut</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO12-6" href="#callout_asyncio_walk_through_CO12-6"><img src="assets/6.png" alt="6"/></a><code>
</code><code class="s1">'</code><code class="s1">I have finished.</code><code class="s1">'</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="nb">print</code><code class="p">(</code><code class="n">fut</code><code class="o">.</code><code class="n">done</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="kc">True</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="nb">print</code><code class="p">(</code><code class="n">fut</code><code class="o">.</code><code class="n">result</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO12-7" href="#callout_asyncio_walk_through_CO12-7"><img src="assets/7.png" alt="7"/></a><code>
</code><code class="n">I</code><code> </code><code class="n">have</code><code> </code><code class="n">finished</code><code class="o">.</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO12-1" href="#co_asyncio_walk_through_CO12-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Create a simple <code>main</code> function.<a data-type="indexterm" data-primary="futures" data-secondary="tasks and" data-tertiary="interactions with Future instance" id="idm46363032253352"/> We can run this,
wait for a bit, and then set a result on this <code>Future</code>, <code>f</code>.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO12-2" href="#co_asyncio_walk_through_CO12-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Set the result.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO12-3" href="#co_asyncio_walk_through_CO12-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Manually create a <code>Future</code> instance. Note that this instance is (by default)
tied to our <code>loop</code>, but it is not and will not be attached to any coroutine
(that’s what <code>Task</code>s are for).</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO12-4" href="#co_asyncio_walk_through_CO12-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>Before doing anything, verify that the future is not done yet.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO12-5" href="#co_asyncio_walk_through_CO12-5"><img src="assets/5.png" alt="5"/></a></dt>
<dd><p><em>Schedule</em> the <code>main()</code> coroutine, passing the future.<a data-type="indexterm" data-primary="main coroutine" data-secondary="scheduling and passing the future" id="idm46363032192184"/> Remember, all the
<code>main()</code> coroutine does is sleep and then toggle the <code>Future</code> instance. (Note that
the <code>main()</code> coroutine will not start running yet: coroutines run only when
the loop is <span class="keep-together">running.)</span></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO12-6" href="#co_asyncio_walk_through_CO12-6"><img src="assets/6.png" alt="6"/></a></dt>
<dd><p>Here we use
<code>run_until_complete()</code> on a <code>Future</code> instance, rather<a data-type="indexterm" data-primary="AbstractEventLoop.run_until_complete function" id="idm46363032186472"/><a data-type="indexterm" data-primary="run_until_complete function" id="idm46363032185864"/> than a <code>Task</code> instance.<sup><a data-type="noteref" id="idm46363032184744-marker" href="ch03.html#idm46363032184744">7</a></sup> This is different from what you’ve seen before. Now that the loop is running, the <code>main()</code> coroutine will begin executing.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO12-7" href="#co_asyncio_walk_through_CO12-7"><img src="assets/7.png" alt="7"/></a></dt>
<dd><p>Eventually, the future completes when its result is set. After completion,
the result can be accessed.</p></dd>
</dl></div>

<p>Of course, it is unlikely that you will work with <code>Future</code> directly in the
way shown here; the code sample is for education purposes only.  Most of your
contact with <code>asyncio</code> will be through <code>Task</code> instances.<a data-type="indexterm" data-primary="tasks" data-secondary="futures and" data-tertiary="calling set_result on Task instance" id="idm46363032178328"/><a data-type="indexterm" data-primary="set_result function" data-secondary="calling on Task instance" id="idm46363032177240"/></p>

<p>You might wonder what happens if you call <code>set_result()</code> on a <code>Task</code> instance.
It was possible to do this before Python 3.8, but it is no longer allowed.
<code>Task</code> instances are wrappers for coroutine objects, and their result values
can be set only internally as the result<a data-type="indexterm" data-primary="coroutine object" data-secondary="Task instance as wrapper for" id="idm46363032174504"/> of the underlying coroutine function, as
shown in <a data-type="xref" href="#taskmanip">Example 3-17</a>.</p>
<div id="taskmanip" data-type="example">
<h5><span class="label">Example 3-17. </span>Calling set_result() on a Task</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="kn">from</code><code> </code><code class="nn">contextlib</code><code> </code><code class="k">import</code><code> </code><code class="n">suppress</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="n">f</code><code class="p">:</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">Future</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">try</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="n">f</code><code class="o">.</code><code class="n">set_result</code><code class="p">(</code><code class="s1">'</code><code class="s1">I have finished.</code><code class="s1">'</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO13-1" href="#callout_asyncio_walk_through_CO13-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">except</code><code> </code><code class="ne">RuntimeError</code><code> </code><code class="k">as</code><code> </code><code class="n">e</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">No longer allowed: </code><code class="si">{e}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="n">f</code><code class="o">.</code><code class="n">cancel</code><code class="p">(</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO13-2" href="#callout_asyncio_walk_through_CO13-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">fut</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">Task</code><code class="p">(</code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">1</code><code class="n">_000_000</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO13-3" href="#callout_asyncio_walk_through_CO13-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="nb">print</code><code class="p">(</code><code class="n">fut</code><code class="o">.</code><code class="n">done</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="kc">False</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="n">fut</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="o">&lt;</code><code class="n">Task</code><code> </code><code class="n">pending</code><code> </code><code class="n">name</code><code class="o">=</code><code class="s1">'</code><code class="s1">Task-2</code><code class="s1">'</code><code> </code><code class="n">coro</code><code class="o">=</code><code class="o">&lt;</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code> </code><code class="n">running</code><code> </code><code class="n">at</code><code> </code><code class="o">&lt;</code><code class="n">console</code><code class="o">&gt;</code><code class="p">:</code><code class="mi">1</code><code class="o">&gt;&gt;</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">with</code><code> </code><code class="n">suppress</code><code class="p">(</code><code class="n">asyncio</code><code class="o">.</code><code class="n">CancelledError</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="n">loop</code><code class="o">.</code><code class="n">run_until_complete</code><code class="p">(</code><code class="n">fut</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="n">No</code><code> </code><code class="n">longer</code><code> </code><code class="n">allowed</code><code class="p">:</code><code> </code><code class="n">Task</code><code> </code><code class="n">does</code><code> </code><code class="ow">not</code><code> </code><code class="n">support</code><code> </code><code class="n">set_result</code><code> </code><code class="n">operation</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="nb">print</code><code class="p">(</code><code class="n">fut</code><code class="o">.</code><code class="n">done</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="kc">True</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="nb">print</code><code class="p">(</code><code class="n">fut</code><code class="o">.</code><code class="n">cancelled</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO13-4" href="#callout_asyncio_walk_through_CO13-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="kc">True</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO13-1" href="#co_asyncio_walk_through_CO13-3"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>The only difference is that we create a <code>Task</code> instance instead of a <code>Future</code>. Of course,
the <code>Task</code> API requires us to provide a coroutine; we just use <code>sleep()</code>
because it’s convenient.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO13-2" href="#co_asyncio_walk_through_CO13-1"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>A <code>Task</code> instance is being passed in. It satisfies the
type signature of the function (because <code>Task</code> is a subclass of <code>Future</code>), but
since Python 3.8, we’re no longer allowed to call <code>set_result()</code> on a <code>Task</code>: an
attempt will raise <code>RuntimeError</code>.<a data-type="indexterm" data-primary="RuntimeError" id="idm46363032149544"/> The idea is that a <code>Task</code> represents
a running coroutine, so the result should always come only from that.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO13-3" href="#co_asyncio_walk_through_CO13-2"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>We can, however, still <code>cancel()</code> a task, which will raise
<code>CancelledError</code> inside the underlying coroutine.<a data-type="indexterm" data-primary="CancelledError exception" data-secondary="in calling set_result on a Task" data-secondary-sortas="calling" id="idm46363032019448"/></p></dd>
</dl></div>








<section data-type="sect2" data-pdf-bookmark="Create a Task? Ensure a Future? Make Up Your Mind!"><div class="sect2" id="idm46363032018024">
<h2>Create a Task? Ensure a Future? Make Up Your Mind!</h2>

<p>In <a data-type="xref" href="#quickstart-section">“Quickstart”</a>, I said that the way to run coroutines was to
use <span class="keep-together"><code>asyncio.create_task()</code>.</span> Before that function was introduced, it was necessary to obtain a <code>loop</code> instance and use <code>loop.create_task()</code> to do the same thing.<a data-type="indexterm" data-primary="loop.create_task function" id="idm46363032120680"/><a data-type="indexterm" data-primary="create_task function" id="idm46363032103368"/><a data-type="indexterm" data-primary="tasks" data-secondary="futures and" data-tertiary="creating a task or ensuring a future" id="idm46363032102696"/><a data-type="indexterm" data-primary="futures" data-secondary="tasks and" data-tertiary="creating a task or ensuring a future" id="idm46363032101512"/> <span class="keep-together">This can, in fact, also be
achieved with a different module-level</span> function: <span class="keep-together"><code>asyncio.ensure_future()</code>.</span>
Some developers recommended <code>create_task()</code>, while others recommended
<code>ensure_future()</code>.<a data-type="indexterm" data-primary="asyncio.ensure_future function" id="idm46363032127880"/><a data-type="indexterm" data-primary="ensure_future function" id="idm46363031899576"/></p>

<p>During my research for this book, I became convinced that the API
method <span class="keep-together"><code>asyncio.ensure_future()</code></span> is responsible for much of the
widespread misunderstanding about the <code>asyncio</code> library.<a data-type="indexterm" data-primary="asyncio.ensure_future function" data-secondary="problems with" id="idm46363031897320"/><a data-type="indexterm" data-primary="ensure_future function" data-secondary="problems with" id="idm46363031896344"/> Much of the
API is really quite clear, but there are a few bad stumbling blocks to
learning, and this is one of them. When you come across
<code>ensure_future()</code>, your brain works very hard to integrate it into your
mental model of how <code>asyncio</code> should be used—and likely fails!<a data-type="indexterm" data-primary="Python" data-secondary="Python 3.6 asyncio documentation for ensure_future" id="idm46363031922248"/></p>

<p>The problem with <code>ensure_future()</code> is highlighted by this
now-infamous explanation in the <a href="https://oreil.ly/fnjCs">Python 3.6 <code>asyncio</code> documentation</a>:</p>

<p><code>asyncio.ensure_future</code>(<em><code>coro_or_future</code></em>, *, _<code>loop=None</code>)</p>
<blockquote>
<p>Schedule the execution of a <em>coroutine object</em>: wrap it in a future.
Return a <em>Task</em> object.</p>

<p>If the argument is a <em>Future</em>, it is returned directly.</p></blockquote>

<p>What!? When I first read this, it was very confusing. Here is a (hopefully)
clearer description of <code>ensure_future()</code>:</p>

<ul>
<li>
<p>If you pass in a coroutine, it will produce a <code>Task</code> instance (and
your coroutine will be scheduled to run on the event loop). This is
identical to calling <span class="keep-together"><code>asyncio.create_task()</code></span> (or <code>loop.create_task()</code>)
and returning the new <code>Task</code> instance.</p>
</li>
<li>
<p>If you pass in a <code>Future</code> instance (or a <code>Task</code> instance,
because <code>Task</code> is a subclass of <code>Future</code>), you get that very same
thing returned, <em>unchanged</em>. Yes, really!</p>
</li>
</ul>

<p>This function is a great <a data-type="indexterm" data-primary="end-user developers" data-secondary="asyncio API aimed at, ensure_future function and" id="idm46363031956872"/><a data-type="indexterm" data-primary="framework developers" data-secondary="asyncio API aimed at, ensure_future function and" id="idm46363031955928"/>example of the difference
between the <code>asyncio</code> API that is aimed at <em>end-user developers</em>
(the high-level API) and the <code>asyncio</code> API aimed at <em>framework designers</em>
(the low-level API). Let’s have a closer look at how it works, in <a data-type="xref" href="#eflook">Example 3-18</a>.</p>
<div id="eflook" data-type="example">
<h5><span class="label">Example 3-18. </span>A closer look at what ensure_future() is doing</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">f</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO14-1" href="#callout_asyncio_walk_through_CO14-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>    </code><code class="k">pass</code><code>
</code><code>
</code><code class="n">coro</code><code> </code><code class="o">=</code><code> </code><code class="n">f</code><code class="p">(</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO14-2" href="#callout_asyncio_walk_through_CO14-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">(</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO14-3" href="#callout_asyncio_walk_through_CO14-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code>
</code><code class="n">task</code><code> </code><code class="o">=</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">coro</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO14-4" href="#callout_asyncio_walk_through_CO14-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code class="k">assert</code><code> </code><code class="nb">isinstance</code><code class="p">(</code><code class="n">task</code><code class="p">,</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">Task</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO14-5" href="#callout_asyncio_walk_through_CO14-5"><img src="assets/5.png" alt="5"/></a><code>
</code><code>
</code><code class="n">new_task</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">ensure_future</code><code class="p">(</code><code class="n">coro</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO14-6" href="#callout_asyncio_walk_through_CO14-6"><img src="assets/6.png" alt="6"/></a><code>
</code><code class="k">assert</code><code> </code><code class="nb">isinstance</code><code class="p">(</code><code class="n">new_task</code><code class="p">,</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">Task</code><code class="p">)</code><code>
</code><code>
</code><code class="n">mystery_meat</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">ensure_future</code><code class="p">(</code><code class="n">task</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO14-7" href="#callout_asyncio_walk_through_CO14-7"><img src="assets/7.png" alt="7"/></a><code>
</code><code class="k">assert</code><code> </code><code class="n">mystery_meat</code><code> </code><code class="ow">is</code><code> </code><code class="n">task</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO14-8" href="#callout_asyncio_walk_through_CO14-8"><img src="assets/8.png" alt="8"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO14-1" href="#co_asyncio_walk_through_CO14-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>A simple do-nothing coroutine function. We just need something that can
make a coroutine.<a data-type="indexterm" data-primary="asyncio.ensure_future function" data-secondary="closer look at" id="idm46363031676888"/><a data-type="indexterm" data-primary="ensure_future function" data-secondary="closer look at" id="idm46363031698168"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO14-2" href="#co_asyncio_walk_through_CO14-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>We make the coroutine object by calling the function directly. Your
code will rarely do this, but I want to be explicit here (a few lines down)
that we’re passing a coroutine object into each of <code>create_task()</code> and
<code>ensure_future()</code>.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO14-3" href="#co_asyncio_walk_through_CO14-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Obtain the loop.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO14-4" href="#co_asyncio_walk_through_CO14-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>First off, we use <code>loop.create_task()</code> to schedule our coroutine on the
loop, and we get a new <code>Task</code> instance back.<a data-type="indexterm" data-primary="loop.create_task function" id="idm46363031635544"/><a data-type="indexterm" data-primary="create_task function" id="idm46363031634936"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO14-5" href="#co_asyncio_walk_through_CO14-5"><img src="assets/5.png" alt="5"/></a></dt>
<dd><p>We verify the type. So far, nothing interesting.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO14-6" href="#co_asyncio_walk_through_CO14-6"><img src="assets/6.png" alt="6"/></a></dt>
<dd><p>We show that <span class="keep-together"><code>asyncio.ensure_future()</code></span> can be used to perform the
same act as <code>create_task()</code>: we passed in a coroutine and we got back a
<code>Task</code> instance (and the coroutine has been scheduled to run on the loop)!
If you’re passing in a <span class="keep-together">coroutine,</span> there is no difference
between <code>loop.create_task()</code> and <span class="keep-together"><code>asyncio.ensure_future()</code>.</span></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO14-7" href="#co_asyncio_walk_through_CO14-7"><img src="assets/7.png" alt="7"/></a></dt>
<dd><p>But what happens if we pass a <code>Task</code> instance to <code>ensure_future()</code>?
Note that we’re passing in a <code>Task</code> instance that was already created
by <code>loop.create_task()</code> in step 4.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO14-8" href="#co_asyncio_walk_through_CO14-8"><img src="assets/8.png" alt="8"/></a></dt>
<dd><p>We get back <em>exactly</em> the same <code>Task</code> instance as we passed in: it
passes through unchanged.</p></dd>
</dl></div>

<p>What’s the point of passing <code>Future</code> instances straight through?
And why do two different things with the same function? The answer is
that <code>ensure_future()</code> is intended to be used <em>by
framework authors</em> to provide APIs <em>to end-user developers</em> that can
handle both kinds of parameters.  Don’t believe me?  Here it is from
the ex-BDFL himself:</p>
<blockquote>
  <p>The point of <code>ensure_future()</code> is if you have something that could
either be a coroutine or a <code>Future</code> (the latter includes a <code>Task</code> because
that’s a subclass of <code>Future</code>), and you want to be able to call a method
on it that is only defined on <code>Future</code> (probably about the only useful
example being <code>cancel()</code>). When it is already a <code>Future</code> (or <code>Task</code>), this
does nothing; when it is a coroutine, it wraps it in a <code>Task</code>.</p>

<p>If you know that you have a coroutine and you want it to be scheduled,
the correct API to use is <code>create_task()</code>. The only time when you should
be calling <code>ensure_future()</code> is when you are providing an API (like most
of asyncio’s own APIs) that accepts either a coroutine or a <code>Future</code> and
you need to do something to it that requires you to have a <code>Future</code>.</p>

  <p data-type="attribution">Guido van Rossum, <a href="https://oreil.ly/cSOFB">commenting</a> on <a href="https://oreil.ly/ydRpR">issue #477</a></p>
</blockquote>

<p>In sum, <code>asyncio.ensure_future()</code> is a helper function
intended for framework designers.<a data-type="indexterm" data-primary="framework developers" data-secondary="asyncio API aimed at, ensure_future function and" data-tertiary="ensure_future as helper function" id="idm46363031608520"/> This is easiest to explain by analogy to a much more common kind of function, so let’s do that. If you have a few years’ programming experience behind you, you may have<a data-type="indexterm" data-primary="listify function" id="idm46363031607112"/> seen functions similar to the <code>listify()</code>
function in <a data-type="xref" href="#listify">Example 3-19</a>.</p>
<div id="listify" data-type="example">
<h5><span class="label">Example 3-19. </span>A utility function for coercing input into a list</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="k">def</code> <code class="nf">listify</code><code class="p">(</code><code class="n">x</code><code class="p">:</code> <code class="n">Any</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">List</code><code class="p">:</code>
    <code class="sd">""" Try hard to convert x into a list """</code>
    <code class="k">if</code> <code class="nb">isinstance</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="p">(</code><code class="nb">str</code><code class="p">,</code> <code class="nb">bytes</code><code class="p">)):</code>
        <code class="k">return</code> <code class="p">[</code><code class="n">x</code><code class="p">]</code>

    <code class="k">try</code><code class="p">:</code>
        <code class="k">return</code> <code class="p">[</code><code class="n">_</code> <code class="k">for</code> <code class="n">_</code> <code class="ow">in</code> <code class="n">x</code><code class="p">]</code>
    <code class="k">except</code> <code class="ne">TypeError</code><code class="p">:</code>
        <code class="k">return</code> <code class="p">[</code><code class="n">x</code><code class="p">]</code></pre></div>

<p>This function tries to convert the argument into a list, no matter
what comes in. These kinds of functions are often used in APIs and
frameworks to coerce inputs into a known type, which simplifies
subsequent code—in this case, you know that the parameter (output from
<code>listify()</code>) will always be a list.</p>

<p>If I rename the <code>listify()</code> function to <code>ensure_list()</code>, then you should
begin to see the parallel with <code>asyncio.ensure_future()</code>: it
tries to always coerce the argument into a <code>Future</code> (or subclass) type.
This is a utility function to make life easier for <em>framework
developers</em>, not end-user developers like you and I.</p>

<p>Indeed, the <code>asyncio</code> standard library module itself uses
<code>ensure_future()</code> for exactly this reason. When next you look over the API,
everywhere you see a function parameter described as “awaitable objects,” it
is likely that internally <code>ensure_future()</code> is being used to coerce
the parameter.<a data-type="indexterm" data-primary="ensure_future function" data-secondary="asyncio.gather function using ensure_future for type coercion" id="idm46363031553048"/><a data-type="indexterm" data-primary="asyncio.gather function" data-secondary="using ensure_future function internally" id="idm46363031552216"/> For example, the <code>asyncio.gather()</code> function has the
following signature:</p>
<pre data-type="programlisting" data-code-language="python3">
<code class="n">asyncio</code><code class="o">.</code><code class="n">gather</code><code class="p">(</code><em><code class="o">*</code><code class="n">aws</code></em><code class="p">,</code><code> </code><em><code class="n">loop</code><code class="o">=</code><code class="kc">None</code></em><code class="p">,</code><code> </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code class="p">)</code><code>
</code></pre>

<p>The <em><code>aws</code></em> parameter means “awaitable objects,” which includes coroutines,
tasks, and futures.<a data-type="indexterm" data-primary="awaitables" data-secondary="aws parameter for asyncio.gather" id="idm46363031528008"/> Internally, <code>gather()</code> is using <code>ensure_future()</code> for
type coercion: tasks and futures are left untouched, while tasks are created
for coroutines.<a data-type="indexterm" data-primary="type coercion, asyncio.gather function using ensure_future for" id="idm46363031526024"/></p>

<p>The key point here is that as an end-user application developer, you
should never need to use <code>asyncio.ensure_future()</code>. It’s more a tool for
framework designers.<a data-type="indexterm" data-primary="coroutines" data-secondary="scheduling on event loop using asyncio.create_task" id="idm46363031524440"/><a data-type="indexterm" data-primary="asyncio.create_task function" data-secondary="using to schedule coroutine on event loop" id="idm46363031523496"/> If you need to schedule a coroutine on the event
loop, just do that directly with <span class="keep-together"><code>asyncio.create_task()</code>.</span></p>

<p>In the next few sections, we’ll go back to language-level features, starting
with asynchronous context managers.<a data-type="indexterm" data-primary="futures" data-secondary="tasks and" data-startref="ix_futtsk" id="idm46363031521128"/><a data-type="indexterm" data-primary="tasks" data-secondary="futures and" data-startref="ix_tskfut" id="idm46363031519880"/><a data-type="indexterm" data-primary="asyncio" data-secondary="tasks and futures" data-startref="ix_asytskfut" id="idm46363031518664"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Async Context Managers: async with"><div class="sect1" id="idm46363032535208">
<h1>Async Context Managers: async with</h1>

<p>Support for coroutines in context managers turns out to be exceptionally
convenient.<a data-type="indexterm" data-primary="context managers" data-secondary="async, async with" id="ix_ctxtmgr"/><a data-type="indexterm" data-primary="asyncio" data-secondary="async context managers, async with" id="ix_asyctxtmgr"/><a data-type="indexterm" data-primary="coroutines" data-secondary="support in context managers" id="idm46363031476248"/> This makes sense, because many situations require network
resources—say, <span class="keep-together">connections—to</span> be opened and closed within a well-defined
scope.</p>

<p>The key to understanding <code>async with</code> is to realize that the operation
of a context manager<a data-type="indexterm" data-primary="async with" data-secondary="understanding" id="idm46363031473880"/> is driven by <em>method calls</em>, and then consider:
what if those methods were coroutine functions? Indeed, this is
exactly how it works, as shown in <a data-type="xref" href="#asyncctx">Example 3-20</a>.</p>
<div id="asyncctx" data-type="example">
<h5><span class="label">Example 3-20. </span>Async context manager</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="k">class</code><code> </code><code class="nc">Connection</code><code class="p">:</code><code>
</code><code>    </code><code class="k">def</code><code> </code><code class="nf">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">host</code><code class="p">,</code><code> </code><code class="n">port</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">host</code><code> </code><code class="o">=</code><code> </code><code class="n">host</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">port</code><code> </code><code class="o">=</code><code> </code><code class="n">port</code><code>
</code><code>    </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">__aenter__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO15-1" href="#callout_asyncio_walk_through_CO15-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">conn</code><code> </code><code class="o">=</code><code> </code><code class="k">await</code><code> </code><code class="n">get_conn</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">host</code><code class="p">,</code><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">port</code><code class="p">)</code><code>
</code><code>        </code><code class="k">return</code><code> </code><code class="n">conn</code><code>
</code><code>    </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">__aexit__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">exc_type</code><code class="p">,</code><code> </code><code class="n">exc</code><code class="p">,</code><code> </code><code class="n">tb</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO15-2" href="#callout_asyncio_walk_through_CO15-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>        </code><code class="k">await</code><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">conn</code><code class="o">.</code><code class="n">close</code><code class="p">(</code><code class="p">)</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">with</code><code> </code><code class="n">Connection</code><code class="p">(</code><code class="s1">'</code><code class="s1">localhost</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="mi">9001</code><code class="p">)</code><code> </code><code class="k">as</code><code> </code><code class="n">conn</code><code class="p">:</code><code>
</code><code>    </code><code class="o">&lt;</code><code class="n">do</code><code> </code><code class="n">stuff</code><code> </code><code class="k">with</code><code> </code><code class="n">conn</code><code class="o">&gt;</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO15-1" href="#co_asyncio_walk_through_CO15-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Instead of the <code>__enter__()</code> special method for synchronous context
managers, the new <code>__aenter__()</code> special method is used.<a data-type="indexterm" data-primary="__aenter__ special method" data-primary-sortas="aenter" id="idm46363031341240"/> This special
method must be an <code>async def</code> method.<a data-type="indexterm" data-primary="async def functions" data-secondary="__aenter__ special method" data-secondary-sortas="aenter" id="idm46363031361288"/><a data-type="indexterm" data-primary="async def functions" data-secondary="aenter method and" id="idm46363031360200"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO15-2" href="#co_asyncio_walk_through_CO15-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Likewise, instead of <code>__exit__()</code>, use <code>__aexit__()</code>. The parameters
are identical to those for <code>__exit__()</code> and are populated if an exception
was raised in the body of the context manager.<a data-type="indexterm" data-primary="__aexit__ special method" data-primary-sortas="aexit" id="idm46363031356104"/></p></dd>
</dl></div>
<div data-type="caution"><h6>Caution</h6>
<p>Just because you’re using <code>asyncio</code> in your program, that
doesn’t mean that all your context managers must be async ones like
these.<a data-type="indexterm" data-primary="context managers" data-secondary="async, async with" data-tertiary="using synchronous context managers instead" id="idm46363031308328"/> They’re useful only if you need to <code>await</code> something inside the
<em>enter</em> and <em>exit</em> methods.<a data-type="indexterm" data-primary="await keyword" data-secondary="async context managers and" id="idm46363031305960"/> If there is no blocking I/O code, just use
regular context managers.</p>
</div>

<p>Now—between you and me—I don’t much like using this explicit style of
context manager when the wonderful <code>@contextmanager</code> decorator exists in the <code>contextlib</code> module of the standard library. As you might guess, an asynchronous version, <span class="keep-together"><code>@asynccontextmanager</code>,</span> also exists and makes it
much easier to create simple async context managers.</p>








<section data-type="sect2" data-pdf-bookmark="The contextlib Way"><div class="sect2" id="idm46363031302696">
<h2>The contextlib Way</h2>

<p>This approach is analogous to the <code>@contextmanager</code> decorator in the
<code>contextlib</code> standard library.<a data-type="indexterm" data-primary="context managers" data-secondary="async, async with" data-tertiary="contextlib @contextmanager decorator" id="idm46363031300136"/><a data-type="indexterm" data-primary="contextlib standard library" data-secondary="@contextmanager decorator" id="idm46363031299048"/><a data-type="indexterm" data-primary="blocking functions" data-secondary="process function example" id="idm46363031298200"/> To recap, <a data-type="xref" href="#blockway">Example 3-21</a> takes a look at the blocking
way first.</p>
<div id="blockway" data-type="example">
<h5><span class="label">Example 3-21. </span>The blocking way</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="kn">from</code><code> </code><code class="nn">contextlib</code><code> </code><code class="k">import</code><code> </code><code class="n">contextmanager</code><code>
</code><code>
</code><code class="nd">@contextmanager</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO16-1" href="#callout_asyncio_walk_through_CO16-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="k">def</code><code> </code><code class="nf">web_page</code><code class="p">(</code><code class="n">url</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">data</code><code> </code><code class="o">=</code><code> </code><code class="n">download_webpage</code><code class="p">(</code><code class="n">url</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO16-2" href="#callout_asyncio_walk_through_CO16-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>    </code><code class="k">yield</code><code> </code><code class="n">data</code><code>
</code><code>    </code><code class="n">update_stats</code><code class="p">(</code><code class="n">url</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO16-3" href="#callout_asyncio_walk_through_CO16-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code>
</code><code class="k">with</code><code> </code><code class="n">web_page</code><code class="p">(</code><code class="s1">'</code><code class="s1">google.com</code><code class="s1">'</code><code class="p">)</code><code> </code><code class="k">as</code><code> </code><code class="n">data</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO16-4" href="#callout_asyncio_walk_through_CO16-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code>    </code><code class="n">process</code><code class="p">(</code><code class="n">data</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO16-5" href="#callout_asyncio_walk_through_CO16-5"><img src="assets/5.png" alt="5"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO16-1" href="#co_asyncio_walk_through_CO16-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>The <code>@contextmanager</code> decorator transforms a generator function into a
context manager.<a data-type="indexterm" data-primary="generator functions" data-secondary="transforming into context managers" id="idm46363031242952"/><a data-type="indexterm" data-primary="@contextmanager decorator" id="idm46363031242104"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO16-2" href="#co_asyncio_walk_through_CO16-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>This function call (which I made up for this example) looks suspiciously
like the sort of thing that will want to use a network interface, which is
many orders of magnitude slower than “normal” CPU-bound code. This
context manager <em>must</em> be used in a dedicated thread; otherwise, the whole
program will be paused while waiting for data.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO16-3" href="#co_asyncio_walk_through_CO16-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Imagine that we update some statistics every time we process data from
a URL, such as the number of times the URL has been downloaded.
From a concurrency perspective, we would need to know whether this function
involves I/O internally, such as writing to a database over
a network. If so, <code>update_stats()</code> is also a blocking call.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO16-4" href="#co_asyncio_walk_through_CO16-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>Our context manager is being used. Note specifically how the
network call (to <code>download_webpage()</code>) is hidden inside the construction
of the context manager.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO16-5" href="#co_asyncio_walk_through_CO16-5"><img src="assets/5.png" alt="5"/></a></dt>
<dd><p>This function call, <code>process()</code>, might also be blocking. We’d have to look at what the function does, because the distinction between what is blocking or nonblocking is not clear-cut. It might be:</p>

<ul>
<li>
<p>Innocuous and nonblocking (fast and CPU-bound)</p>
</li>
<li>
<p>Mildly blocking (fast and I/O-bound, perhaps something like fast disk access
instead of network I/O)</p>
</li>
<li>
<p>Blocking (slow and I/O-bound)</p>
</li>
<li>
<p>Diabolical (slow and CPU-bound)</p>
</li>
</ul>

<p>For the sake of simplicity in this example, let’s presume that the call
to <code>process()</code> is a fast, CPU-bound operation and therefore nonblocking.<a data-type="indexterm" data-primary="nonblocking functions" data-secondary="process function example" id="idm46363031186456"/></p></dd>
</dl></div>

<p><a data-type="xref" href="#nonblockway">Example 3-22</a> is exactly the same example, but using the new async-aware
helper that was introduced in Python 3.7.<a data-type="indexterm" data-primary="contextlib standard library" data-secondary="@asynccontextmanager decorator" id="idm46363031184760"/></p>
<div id="nonblockway" data-type="example">
<h5><span class="label">Example 3-22. </span>The nonblocking way</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="kn">from</code><code> </code><code class="nn">contextlib</code><code> </code><code class="k">import</code><code> </code><code class="n">asynccontextmanager</code><code>
</code><code>
</code><code class="nd">@asynccontextmanager</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO17-1" href="#callout_asyncio_walk_through_CO17-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">web_page</code><code class="p">(</code><code class="n">url</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO17-2" href="#callout_asyncio_walk_through_CO17-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>    </code><code class="n">data</code><code> </code><code class="o">=</code><code> </code><code class="k">await</code><code> </code><code class="n">download_webpage</code><code class="p">(</code><code class="n">url</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO17-3" href="#callout_asyncio_walk_through_CO17-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code>    </code><code class="k">yield</code><code> </code><code class="n">data</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO17-4" href="#callout_asyncio_walk_through_CO17-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code>    </code><code class="k">await</code><code> </code><code class="n">update_stats</code><code class="p">(</code><code class="n">url</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO17-5" href="#callout_asyncio_walk_through_CO17-5"><img src="assets/5.png" alt="5"/></a><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">with</code><code> </code><code class="n">web_page</code><code class="p">(</code><code class="s1">'</code><code class="s1">google.com</code><code class="s1">'</code><code class="p">)</code><code> </code><code class="k">as</code><code> </code><code class="n">data</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO17-6" href="#callout_asyncio_walk_through_CO17-6"><img src="assets/6.png" alt="6"/></a><code>
</code><code>    </code><code class="n">process</code><code class="p">(</code><code class="n">data</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO17-1" href="#co_asyncio_walk_through_CO17-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>The new <code>@asynccontextmanager</code> decorator<a data-type="indexterm" data-primary="@asynccontextmanager decorator" id="idm46363031119768"/> is used in exactly the same way.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO17-2" href="#co_asyncio_walk_through_CO17-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>It does, however, require that the decorated generator function be declared
with <code>async def</code>.<a data-type="indexterm" data-primary="async def functions" data-secondary="generator functions decorated with @asynccontextmanager" id="idm46363031115976"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO17-3" href="#co_asyncio_walk_through_CO17-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>As before, we fetch the data from the URL before making it available to
the body of the context manager. I have added the <code>await</code> keyword, which
tells us that this coroutine will allow the event loop to run other tasks
while we wait for the network call to complete.<br/></p>

<p>Note that we <em>cannot</em> simply
tack on the <code>await</code> keyword to anything.<a data-type="indexterm" data-primary="await keyword" data-secondary="requirement for adding" id="idm46363031070136"/> This change presupposes that we were
also able to <em>modify</em> the <code>download_webpage()</code> function itself, and convert
it into a coroutine that is compatible with the <code>await</code> keyword. For the times
when it is not possible to modify the function, a different approach is
needed; we’ll discuss that in the next example.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO17-4" href="#co_asyncio_walk_through_CO17-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>As before, the data is made available to the body of the context manager.
I’m trying to keep the code simple, so I’ve omitted the usual
<code>try/finally</code> handler that you should normally write to deal with exceptions
raised in the body of caller.</p>

<p>Note that the presence of <code>yield</code> is what changes a
function into a <em>generator function</em>; the additional <a data-type="indexterm" data-primary="yield keyword" data-secondary="changing function into genarator function" id="idm46363031063528"/>presence of the <code>async def</code>
keywords in point 1 makes this an
<em>asynchronous generator function</em>. <a data-type="indexterm" data-primary="async def functions" data-secondary="asynchronous generator functions" id="idm46363031061784"/><a data-type="indexterm" data-primary="asynchronous generator functions" id="idm46363031060936"/><a data-type="indexterm" data-primary="generator functions" data-secondary="asynchronous" id="idm46363031060328"/>When called, it will return an
<em>asynchronous generator</em>. <a data-type="indexterm" data-primary="isasyncgen function" id="idm46363031058968"/><a data-type="indexterm" data-primary="isasyncgenfunction function" id="idm46363031058360"/><a data-type="indexterm" data-primary="inspect module" data-secondary="functions testing for asynchronous generators" id="idm46363031057752"/>The <code>inspect</code> module has two functions that can
test for these: <span class="keep-together"><code>isasyncgenfunction()</code></span> and <code>isasyncgen()</code>, respectively.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO17-5" href="#co_asyncio_walk_through_CO17-5"><img src="assets/5.png" alt="5"/></a></dt>
<dd><p>Here, assume that we’ve also converted the code inside the
<code>update_stats()</code> function to allow it to produce coroutines. We can then use the
<code>await</code> keyword, which allows a context switch to the event loop while we
wait for the I/O-bound work to complete.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO17-6" href="#co_asyncio_walk_through_CO17-6"><img src="assets/6.png" alt="6"/></a></dt>
<dd><p>Another change was required in the usage of the context manager itself: we
needed to use <code>async with</code> instead of a plain <code>with</code>.<a data-type="indexterm" data-primary="async with" data-secondary="use with context managers" id="idm46363031049416"/></p></dd>
</dl></div>

<p>Hopefully, this example shows that the new <code>@asynccontextmanager</code> is
perfectly analogous to the <code>@contextmanager</code> decorator.</p>

<p>In callouts 3 and 5, I said it was necessary to modify some functions to return coroutines; these were <code>download_webpage()</code> and <code>update_stats()</code>.<a data-type="indexterm" data-primary="coroutines" data-secondary="modifying functions to return" id="idm46363031046056"/> This is usually <span class="keep-together">not that easy to do, since async support needs to be added down at the socket</span> level. The focus of the preceding examples was simply to show off the new <span class="keep-together"><code>@asynccontextmanager</code></span> decorator, not to show how to convert blocking functions into
nonblocking ones. <a data-type="indexterm" data-primary="blocking functions" data-secondary="converting to nonblocking" id="idm46363031043704"/><a data-type="indexterm" data-primary="nonblocking functions" data-secondary="converting blocking functions to" id="idm46363031042856"/>The more common situation is when you want to
use a blocking function in your program, but it’s not possible to modify the code in that <span class="keep-together">function.</span></p>

<p>This situation will usually happen with third-party libraries, and a
great <a data-type="indexterm" data-primary="requests library" id="idm46363031040632"/>example is the <code>requests</code> library, which uses
blocking calls throughout.<sup><a data-type="noteref" id="idm46363031039256-marker" href="ch03.html#idm46363031039256">8</a></sup>
If you can’t change the code being called,
there is another way.<a data-type="indexterm" data-primary="executors" data-secondary="using to convert blocking functions to nonblocking" id="idm46363031037176"/> This is a convenient place to
show you how an <em>executor</em> can be used to do exactly that, as illustrated in <a data-type="xref" href="#ctxdec">Example 3-23</a>.</p>
<div id="ctxdec" data-type="example">
<h5><span class="label">Example 3-23. </span>The nonblocking-with-a-little-help-from-my-friends way</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="kn">from</code><code> </code><code class="nn">contextlib</code><code> </code><code class="k">import</code><code> </code><code class="n">asynccontextmanager</code><code>
</code><code>
</code><code class="nd">@asynccontextmanager</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">web_page</code><code class="p">(</code><code class="n">url</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO18-1" href="#callout_asyncio_walk_through_CO18-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>    </code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="n">data</code><code> </code><code class="o">=</code><code> </code><code class="k">await</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">run_in_executor</code><code class="p">(</code><code>
</code><code>        </code><code class="kc">None</code><code class="p">,</code><code> </code><code class="n">download_webpage</code><code class="p">,</code><code> </code><code class="n">url</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO18-2" href="#callout_asyncio_walk_through_CO18-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>    </code><code class="k">yield</code><code> </code><code class="n">data</code><code>
</code><code>    </code><code class="k">await</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">run_in_executor</code><code class="p">(</code><code class="kc">None</code><code class="p">,</code><code> </code><code class="n">update_stats</code><code class="p">,</code><code> </code><code class="n">url</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO18-3" href="#callout_asyncio_walk_through_CO18-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">with</code><code> </code><code class="n">web_page</code><code class="p">(</code><code class="s1">'</code><code class="s1">google.com</code><code class="s1">'</code><code class="p">)</code><code> </code><code class="k">as</code><code> </code><code class="n">data</code><code class="p">:</code><code>
</code><code>    </code><code class="n">process</code><code class="p">(</code><code class="n">data</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO18-1" href="#co_asyncio_walk_through_CO18-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>For this example, assume that we are <em>unable</em> to modify the code for our
two blocking calls, <code>download_webpage()</code> and <code>update_stats()</code>; i.e., we
can’t alter them to be coroutine functions.
That’s bad, because the most grave sin of event-based programming is breaking the rule that you
must never, under any circumstances, prevent the event loop from processing
events.</p>

<p>To get around the problem, we will use an <em>executor</em> to run the blocking
calls in a separate thread. The executor is made available to us as an
attribute of the event loop itself.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO18-2" href="#co_asyncio_walk_through_CO18-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>We call the executor.<a data-type="indexterm" data-primary="AbstractEventLoop.run_in_executor function" id="idm46363030946616"/><a data-type="indexterm" data-primary="run_in_executor function" id="idm46363030945560"/> The signature is
<code>AbstractEventLoop.run_in_executor</code>(<em><code>executor</code></em>, <em><code>func</code></em>, <em><code>*args</code></em>). If you want
to use the <a data-type="indexterm" data-primary="ThreadPoolExecutor class" data-secondary="run_in_executor, None as value for executor" id="idm46363030903624"/>default executor (which is
a <code>ThreadPoolExecutor</code>), you must pass <code>None</code> as the value for the
<em><code>executor</code></em> <span class="keep-together">argument</span>.<sup><a data-type="noteref" id="idm46363030900744-marker" href="ch03.html#idm46363030900744">9</a></sup></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO18-3" href="#co_asyncio_walk_through_CO18-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>As with the call to <code>download_webpage()</code>, we also run the other blocking
call to <code>update_stats()</code> in an executor. Note that you <em>must</em> use
the <code>await</code> keyword in front.<a data-type="indexterm" data-primary="await keyword" data-secondary="await loop.run_in_executor" id="idm46363030896008"/> If you forget, the execution of the
asynchronous generator (i.e., your async context manager) will not wait for
the call to complete before proceeding.</p></dd>
</dl></div>

<p>It’s likely that async context managers are going to be heavily used in
many <code>asyncio</code>-based codebases, so it’s pretty important to have a
good understanding of them.<a data-type="indexterm" data-primary="@asynccontextmanager decorator" data-secondary="documentation" id="idm46363030894216"/> You can read more about the new <code>@asynccontextmanager</code> decorator in the
<a href="http://bit.ly/2FoWl9f">Python 3.7 documentation</a>.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Async Iterators: async for"><div class="sect1" id="asynciter">
<h1>Async Iterators: async for</h1>

<p>Next up is the async version of the <code>for</code> loop. <a data-type="indexterm" data-primary="context managers" data-secondary="async, async with" data-startref="ix_ctxtmgr" id="idm46363030889848"/><a data-type="indexterm" data-primary="asyncio" data-secondary="async context managers, async with" data-startref="ix_asyctxtmgr" id="idm46363030888760"/><a data-type="indexterm" data-primary="iterators" data-secondary="async for loops" id="ix_iterasy"/><a data-type="indexterm" data-primary="asyncio" data-secondary="async iterators, async for loops" id="ix_asyasyit"/><a data-type="indexterm" data-primary="for loops (async)" id="ix_forasy"/> It is easiest to understand how this works if you first
recognize that ordinary iteration—just like so many other language
features—is implemented through the use of <em>special methods</em>,
recognizable by the double underscores in their names.<a data-type="indexterm" data-primary="special methods" id="idm46363030883944"/></p>

<p>For reference, <a data-type="xref" href="#normaliter">Example 3-24</a> shows how a standard (nonasync) iterator
is defined through <a data-type="indexterm" data-primary="__next__ special method" data-primary-sortas="next" id="idm46363030882344"/><a data-type="indexterm" data-primary="__iter__ special method" data-primary-sortas="iter" id="idm46363030881496"/>the use of the <code>__iter__()</code> and <code>__next__()</code> methods.</p>
<div id="normaliter" data-type="example">
<h5><span class="label">Example 3-24. </span>A traditional, nonasync iterator</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">class</code><code> </code><code class="nc">A</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">def</code><code> </code><code class="nf">__iter__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>   </code><a class="co" id="co_asyncio_walk_through_CO19-1" href="#callout_asyncio_walk_through_CO19-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="bp">self</code><code class="o">.</code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="mi">0</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO19-2" href="#callout_asyncio_walk_through_CO19-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="k">return</code><code> </code><code class="bp">self</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO19-3" href="#callout_asyncio_walk_through_CO19-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">def</code><code> </code><code class="nf">__next__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO19-4" href="#callout_asyncio_walk_through_CO19-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="k">if</code><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">x</code><code> </code><code class="o">&gt;</code><code> </code><code class="mi">2</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>             </code><code class="k">raise</code><code> </code><code class="ne">StopIteration</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO19-5" href="#callout_asyncio_walk_through_CO19-5"><img src="assets/5.png" alt="5"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="k">else</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>             </code><code class="bp">self</code><code class="o">.</code><code class="n">x</code><code> </code><code class="o">+</code><code class="o">=</code><code> </code><code class="mi">1</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>             </code><code class="k">return</code><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">x</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO19-6" href="#callout_asyncio_walk_through_CO19-6"><img src="assets/6.png" alt="6"/></a><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">for</code><code> </code><code class="n">i</code><code> </code><code class="ow">in</code><code> </code><code class="n">A</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="nb">print</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code>
</code><code class="mi">1</code><code>
</code><code class="mi">2</code><code>
</code><code class="mi">3</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO19-1" href="#co_asyncio_walk_through_CO19-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>An <em>iterator</em> must implement the <code>__iter__()</code> special method.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO19-2" href="#co_asyncio_walk_through_CO19-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Initialize some state to the “starting” state.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO19-3" href="#co_asyncio_walk_through_CO19-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>The <code>__iter__()</code> special method must return an <em>iterable</em>; i.e., an
object that implements the <code>__next__()</code> special method.<a data-type="indexterm" data-primary="iterables" id="idm46363030753000"/> In this case, it’s the
same instance, because <code>A</code> itself also implements the <code>__next__()</code> special
method.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO19-4" href="#co_asyncio_walk_through_CO19-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>The <code>__next__()</code> method is defined. This will be called for every step
in the iteration sequence until…</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO19-5" href="#co_asyncio_walk_through_CO19-5"><img src="assets/5.png" alt="5"/></a></dt>
<dd><p>…<code>StopIteration</code> is raised.<a data-type="indexterm" data-primary="StopIteration exception" id="idm46363030694056"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO19-6" href="#co_asyncio_walk_through_CO19-6"><img src="assets/6.png" alt="6"/></a></dt>
<dd><p>The <em>returned values</em> for each iteration are generated.</p></dd>
</dl></div>

<p>Now you ask: what happens if you declare the <code>__next__()</code>
special method as an <code>async def</code> coroutine function? That will allow
it to <code>await</code> some kind of I/O-bound operation—and this is pretty much
exactly how <code>async for</code> works, except for some small details around
naming. The specification (in PEP 492) shows that to use <code>async for</code>
on an async iterator, several things are required in the async iterator
itself:</p>
<ol>
<li>
<p>You must <a data-type="indexterm" data-primary="def __aiter__ function" id="idm46363030687688"/>implement <code>def __aiter__()</code>. (Note: <em>not</em> with <code>async def</code>!)</p>
</li>
<li>
<p><code>__aiter__()</code> must return an object that implements <code>async def __anext__()</code>.</p>
</li>
<li>
<p><code>__anext__()</code> must return a value for each iteration and raise
<code>Stop​AsyncIteration</code> when finished.<a data-type="indexterm" data-primary="__anext__ special method" data-primary-sortas="anext" id="idm46363030682984"/><a data-type="indexterm" data-primary="async def functions" data-secondary="__anext__ special method" data-secondary-sortas="anext" id="idm46363030682136"/></p>
</li>

</ol>

<p>Let’s take a quick look at how that might work. Imagine that we have a
bunch of keys in a <a href="https://redis.io/">Redis</a> database, and we want to
iterate over their data, but we fetch the data only on demand.  An
asynchronous <a data-type="indexterm" data-primary="aioredis" id="idm46363030679544"/><a data-type="indexterm" data-primary="Redis database, async iterator fetching data from" id="idm46363030678936"/>iterator for that might look like <a data-type="xref" href="#iter_redis">Example 3-25</a>.</p>
<div id="iter_redis" data-type="example">
<h5><span class="label">Example 3-25. </span>Async iterator for fetching data from Redis</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="kn">from</code><code> </code><code class="nn">aioredis</code><code> </code><code class="k">import</code><code> </code><code class="n">create_redis</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO20-1" href="#callout_asyncio_walk_through_CO20-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>    </code><code class="n">redis</code><code> </code><code class="o">=</code><code> </code><code class="k">await</code><code> </code><code class="n">create_redis</code><code class="p">(</code><code class="p">(</code><code class="s1">'</code><code class="s1">localhost</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="mi">6379</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO20-2" href="#callout_asyncio_walk_through_CO20-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>    </code><code class="n">keys</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="s1">'</code><code class="s1">Americas</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">Africa</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">Europe</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">Asia</code><code class="s1">'</code><code class="p">]</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO20-3" href="#callout_asyncio_walk_through_CO20-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code>
</code><code>    </code><code class="k">async</code><code> </code><code class="k">for</code><code> </code><code class="n">value</code><code> </code><code class="ow">in</code><code> </code><code class="n">OneAtATime</code><code class="p">(</code><code class="n">redis</code><code class="p">,</code><code> </code><code class="n">keys</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO20-4" href="#callout_asyncio_walk_through_CO20-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code>        </code><code class="k">await</code><code> </code><code class="n">do_something_with</code><code class="p">(</code><code class="n">value</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO20-5" href="#callout_asyncio_walk_through_CO20-5"><img src="assets/5.png" alt="5"/></a><code>
</code><code>
</code><code class="k">class</code><code> </code><code class="nc">OneAtATime</code><code class="p">:</code><code>
</code><code>    </code><code class="k">def</code><code> </code><code class="nf">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">redis</code><code class="p">,</code><code> </code><code class="n">keys</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO20-6" href="#callout_asyncio_walk_through_CO20-6"><img src="assets/6.png" alt="6"/></a><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">redis</code><code> </code><code class="o">=</code><code> </code><code class="n">redis</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">keys</code><code> </code><code class="o">=</code><code> </code><code class="n">keys</code><code>
</code><code>    </code><code class="k">def</code><code> </code><code class="nf">__aiter__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO20-7" href="#callout_asyncio_walk_through_CO20-7"><img src="assets/7.png" alt="7"/></a><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">ikeys</code><code> </code><code class="o">=</code><code> </code><code class="nb">iter</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">keys</code><code class="p">)</code><code>
</code><code>        </code><code class="k">return</code><code> </code><code class="bp">self</code><code>
</code><code>    </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">__anext__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO20-8" href="#callout_asyncio_walk_through_CO20-8"><img src="assets/8.png" alt="8"/></a><code>
</code><code>        </code><code class="k">try</code><code class="p">:</code><code>
</code><code>            </code><code class="n">k</code><code> </code><code class="o">=</code><code> </code><code class="nb">next</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">ikeys</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO20-9" href="#callout_asyncio_walk_through_CO20-9"><img src="assets/9.png" alt="9"/></a><code>
</code><code>        </code><code class="k">except</code><code> </code><code class="ne">StopIteration</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO20-10" href="#callout_asyncio_walk_through_CO20-10"><img src="assets/10.png" alt="10"/></a><code>
</code><code>            </code><code class="k">raise</code><code> </code><code class="n">StopAsyncIteration</code><code>
</code><code>
</code><code>        </code><code class="n">value</code><code> </code><code class="o">=</code><code> </code><code class="k">await</code><code> </code><code class="n">redis</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="n">k</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO20-11" href="#callout_asyncio_walk_through_CO20-11"><img src="assets/11.png" alt="11"/></a><code>
</code><code>        </code><code class="k">return</code><code> </code><code class="n">value</code><code>
</code><code>
</code><code class="n">asyncio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO20-1" href="#co_asyncio_walk_through_CO20-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>The <code>main()</code> function: we run it using <code>asyncio.run()</code> toward the
bottom of the code sample.<a data-type="indexterm" data-primary="main function" data-secondary="running using asyncio.run function" id="idm46363030455912"/><a data-type="indexterm" data-primary="asyncio.run function" data-secondary="running main function with" id="idm46363030454968"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO20-2" href="#co_asyncio_walk_through_CO20-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>We use the high-level interface in <code>aioredis</code> to get a connection.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO20-3" href="#co_asyncio_walk_through_CO20-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Imagine that each of the values associated with these keys is quite large
and stored in the Redis instance.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO20-4" href="#co_asyncio_walk_through_CO20-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>We’re using <code>async for</code>: the<a data-type="indexterm" data-primary="for loops (async)" data-secondary="using to read data from Redis" id="idm46363030473000"/><a data-type="indexterm" data-primary="iteration, suspending while waiting for next datum to arrive" id="idm46363030472024"/> point is that <em>iteration</em>
<em>is able to suspend itself</em> while waiting for the next datum to arrive.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO20-5" href="#co_asyncio_walk_through_CO20-5"><img src="assets/5.png" alt="5"/></a></dt>
<dd><p>For completeness, imagine that we also perform some I/O-bound activity
on the fetched value—perhaps a simple data transformation—and then it gets
sent on to another destination.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO20-6" href="#co_asyncio_walk_through_CO20-6"><img src="assets/6.png" alt="6"/></a></dt>
<dd><p>The initializer of this class is quite ordinary: we store the Redis
connection instance and the list of keys to iterate over.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO20-7" href="#co_asyncio_walk_through_CO20-7"><img src="assets/7.png" alt="7"/></a></dt>
<dd><p>Just as in the previous code example with <code>__iter__()</code>, we
use <code>__aiter__()</code> to set things up for iteration.<a data-type="indexterm" data-primary="__anext__ special method" data-primary-sortas="anext" id="idm46363030387576"/><a data-type="indexterm" data-primary="__aiter__  special method" data-primary-sortas="aiter" id="idm46363030386728"/> We create a normal iterator over the keys, <code>self.ikeys</code>, and <code>return self</code>
because <code>OneAtATime</code> also implements the <code>__anext__()</code> coroutine method.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO20-8" href="#co_asyncio_walk_through_CO20-8"><img src="assets/8.png" alt="8"/></a></dt>
<dd><p>Note that the <code>__anext__()</code> method is declared with <code>async def</code>, while
the <code>__aiter__()</code> method is declared only with <code>def</code>.<a data-type="indexterm" data-primary="async def functions" data-secondary="__anext__ special method" data-secondary-sortas="anext" id="idm46363030380360"/><a data-type="indexterm" data-primary="def __aiter__ function" id="idm46363030379272"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO20-9" href="#co_asyncio_walk_through_CO20-9"><img src="assets/9.png" alt="9"/></a></dt>
<dd><p>For each key, we fetch the value from Redis: <code>self.ikeys</code> is a regular
iterator over the keys, so we use <code>next()</code> to move over them.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO20-10" href="#co_asyncio_walk_through_CO20-10"><img src="assets/10.png" alt="10"/></a></dt>
<dd><p>When <code>self.ikeys</code> is exhausted, we handle the <code>StopIteration</code> and simply
turn it into a <code>StopAsyncIteration</code>! This is how you signal stop from
inside an async iterator.<a data-type="indexterm" data-primary="StopAsyncIteration" id="idm46363030372424"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO20-11" href="#co_asyncio_walk_through_CO20-11"><img src="assets/11.png" alt="11"/></a></dt>
<dd><p>Finally—the entire point of this example—we can get the data from
Redis associated with this key.<a data-type="indexterm" data-primary="await keyword" data-secondary="using with async iterators" id="idm46363030369480"/> We can <code>await</code> the data, which means that
other code can run on the event loop while we wait on network I/O.</p></dd>
</dl></div>

<p>Hopefully, this example is clear: <code>async for</code> provides the ability to retain
the convenience of a simple <code>for</code> loop, even when iterating over data where
the iteration itself is performing I/O. The benefit is that you can
process enormous amounts of data with a single loop, because you have to deal with each chunk only in tiny batches.<a data-type="indexterm" data-primary="for loops (async)" data-startref="ix_forasy" id="idm46363030367128"/><a data-type="indexterm" data-primary="iterators" data-secondary="async for loops" data-startref="ix_iterasy" id="idm46363030366280"/><a data-type="indexterm" data-primary="asyncio" data-secondary="async iterators, async for" data-startref="ix_asyasyit" id="idm46363030365192"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Simpler Code with Async Generators"><div class="sect1" id="idm46363030891800">
<h1>Simpler Code with Async Generators</h1>

<p><em>Async generators</em> are <code>async def</code> functions that have <code>yield</code> keywords inside
them. Async generators result in simpler code.<a data-type="indexterm" data-primary="yield keyword" id="idm46363030361704"/><a data-type="indexterm" data-primary="asyncio" data-secondary="simpler code with async generators" id="ix_asygen"/><a data-type="indexterm" data-primary="asynchronous generator functions" data-secondary="simpler code with" id="ix_asyncgen"/><a data-type="indexterm" data-primary="async def functions" data-secondary="asynchronous generator functions" id="idm46363030358920"/></p>

<p>However, the idea of them might be confusing if you have some experience with using generators <em>as if</em> they were coroutines, such as with the Twisted framework, or the Tornado framework, or even with <code>yield from</code> in Python 3.4’s <code>asyncio</code>. Therefore, before we continue, it will be best if you can convince yourself that</p>

<ul>
<li>
<p>Coroutines and generators are completely different concepts.</p>
</li>
<li>
<p>Async generators behave much like ordinary generators.</p>
</li>
<li>
<p>For iteration, you use <code>async for</code> for async generators, instead of
the ordinary <code>for</code> used for ordinary generators.<a data-type="indexterm" data-primary="for loops (async)" data-secondary="using with async generators" id="idm46363030353112"/><a data-type="indexterm" data-primary="iterators" data-secondary="async for loops" data-tertiary="using with async generators" id="idm46363030352264"/></p>
</li>
</ul>

<p>The example used in the previous section to demonstrate
an async iterator for
interaction with Redis turns out to be much simpler if we set it up as
an async generator, shown in <a data-type="xref" href="#asyncgenredis">Example 3-26</a>.</p>
<div id="asyncgenredis" data-type="example">
<h5><span class="label">Example 3-26. </span>Easier with an async generator</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="kn">from</code><code> </code><code class="nn">aioredis</code><code> </code><code class="k">import</code><code> </code><code class="n">create_redis</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO21-1" href="#callout_asyncio_walk_through_CO21-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>    </code><code class="n">redis</code><code> </code><code class="o">=</code><code> </code><code class="k">await</code><code> </code><code class="n">create_redis</code><code class="p">(</code><code class="p">(</code><code class="s1">'</code><code class="s1">localhost</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="mi">6379</code><code class="p">)</code><code class="p">)</code><code>
</code><code>    </code><code class="n">keys</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="s1">'</code><code class="s1">Americas</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">Africa</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">Europe</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">Asia</code><code class="s1">'</code><code class="p">]</code><code>
</code><code>
</code><code>    </code><code class="k">async</code><code> </code><code class="k">for</code><code> </code><code class="n">value</code><code> </code><code class="ow">in</code><code> </code><code class="n">one_at_a_time</code><code class="p">(</code><code class="n">redis</code><code class="p">,</code><code> </code><code class="n">keys</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO21-2" href="#callout_asyncio_walk_through_CO21-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>        </code><code class="k">await</code><code> </code><code class="n">do_something_with</code><code class="p">(</code><code class="n">value</code><code class="p">)</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">one_at_a_time</code><code class="p">(</code><code class="n">redis</code><code class="p">,</code><code> </code><code class="n">keys</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO21-3" href="#callout_asyncio_walk_through_CO21-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code>    </code><code class="k">for</code><code> </code><code class="n">k</code><code> </code><code class="ow">in</code><code> </code><code class="n">keys</code><code class="p">:</code><code>
</code><code>        </code><code class="n">value</code><code> </code><code class="o">=</code><code> </code><code class="k">await</code><code> </code><code class="n">redis</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="n">k</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO21-4" href="#callout_asyncio_walk_through_CO21-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code>        </code><code class="k">yield</code><code> </code><code class="n">value</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO21-5" href="#callout_asyncio_walk_through_CO21-5"><img src="assets/5.png" alt="5"/></a><code>
</code><code>
</code><code class="n">asyncio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO21-1" href="#co_asyncio_walk_through_CO21-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>The <code>main()</code> function is identical <a data-type="indexterm" data-primary="main function" id="idm46363030195080"/>to the version in
<a data-type="xref" href="#iter_redis">Example 3-25</a>.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO21-2" href="#co_asyncio_walk_through_CO21-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Well, almost identical: I changed the name from <em><code>CamelCase</code></em>
to <em><code>snake_case</code></em>.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO21-3" href="#co_asyncio_walk_through_CO21-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Our function is now declared with <code>async def</code>, making it
a <em>coroutine function</em>, and since this function also contains the <code>yield</code>
keyword, we refer to it <a data-type="indexterm" data-primary="asynchronous generator functions" id="idm46363030165944"/><a data-type="indexterm" data-primary="coroutine functions" data-secondary="asynchronous generator functions and" id="idm46363030165448"/><a data-type="indexterm" data-primary="yield keyword" id="idm46363030164600"/>as an <em>asynchronous generator function</em>.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO21-4" href="#co_asyncio_walk_through_CO21-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>We don’t have to do the convoluted things necessary in the previous
example with <code>self.ikeys</code>: here, we just loop over the keys directly
and obtain the value…</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO21-5" href="#co_asyncio_walk_through_CO21-5"><img src="assets/5.png" alt="5"/></a></dt>
<dd><p>…and then yield it to the caller, just like a normal generator.</p></dd>
</dl></div>

<p>It might seem complex if this is new to you, but I urge you to
play around with this yourself on a few toy examples. It starts to
feel natural pretty quickly. Async generators are likely to become
popular in <code>asyncio</code>-based codebases because they bring all the same benefits as normal generators: making code shorter and simpler.<a data-type="indexterm" data-primary="asynchronous generator functions" data-secondary="simpler code with" data-startref="ix_asyncgen" id="idm46363030157912"/><a data-type="indexterm" data-primary="asyncio" data-secondary="simpler code with async generators" data-startref="ix_asygen" id="idm46363030156824"/></p>
</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Async Comprehensions"><div class="sect1" id="idm46363030155608">
<h1>Async Comprehensions</h1>

<p>Now that we’ve seen how Python supports asynchronous iteration, the next
natural question to ask is whether it also works for list comprehensions—and
the answer is <em>yes</em>.<a data-type="indexterm" data-primary="comprehensions, async" id="ix_compre"/><a data-type="indexterm" data-primary="asyncio" data-secondary="async comprehensions" id="ix_asycompr"/><a data-type="indexterm" data-primary="list, dict, and set comprehensions, async" id="ix_lstdctset"/><a data-type="indexterm" data-primary="set comprehensions, async" id="ix_setcmpre"/><a data-type="indexterm" data-primary="dict comprehensions, async" id="ix_dictcmpre"/> This support was introduced in
<a href="https://oreil.ly/4qNoH">PEP 530</a>, and I recommend you take a look
at the PEP yourself; it is short and readable. <a data-type="xref" href="#asynccomps">Example 3-27</a>
shows how typical async comprehensions are laid out.</p>
<div id="asynccomps" data-type="example">
<h5><span class="label">Example 3-27. </span>Async list, dict, and set comprehensions</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">doubler</code><code class="p">(</code><code class="n">n</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">for</code><code> </code><code class="n">i</code><code> </code><code class="ow">in</code><code> </code><code class="nb">range</code><code class="p">(</code><code class="n">n</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="k">yield</code><code> </code><code class="n">i</code><code class="p">,</code><code> </code><code class="n">i</code><code> </code><code class="o">*</code><code> </code><code class="mi">2</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO22-1" href="#callout_asyncio_walk_through_CO22-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">0.1</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO22-2" href="#callout_asyncio_walk_through_CO22-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="n">result</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="n">x</code><code> </code><code class="k">async</code><code> </code><code class="k">for</code><code> </code><code class="n">x</code><code> </code><code class="ow">in</code><code> </code><code class="n">doubler</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="p">]</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO22-3" href="#callout_asyncio_walk_through_CO22-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="nb">print</code><code class="p">(</code><code class="n">result</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="n">result</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="n">x</code><code class="p">:</code><code> </code><code class="n">y</code><code> </code><code class="k">async</code><code> </code><code class="k">for</code><code> </code><code class="n">x</code><code class="p">,</code><code> </code><code class="n">y</code><code> </code><code class="ow">in</code><code> </code><code class="n">doubler</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="p">}</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO22-4" href="#callout_asyncio_walk_through_CO22-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="nb">print</code><code class="p">(</code><code class="n">result</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="n">result</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="n">x</code><code> </code><code class="k">async</code><code> </code><code class="k">for</code><code> </code><code class="n">x</code><code> </code><code class="ow">in</code><code> </code><code class="n">doubler</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="p">}</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO22-5" href="#callout_asyncio_walk_through_CO22-5"><img src="assets/5.png" alt="5"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="nb">print</code><code class="p">(</code><code class="n">result</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="p">[</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code> </code><code class="mi">0</code><code class="p">)</code><code class="p">,</code><code> </code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code> </code><code class="mi">2</code><code class="p">)</code><code class="p">,</code><code> </code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code> </code><code class="mi">4</code><code class="p">)</code><code class="p">]</code><code>
</code><code class="p">{</code><code class="mi">0</code><code class="p">:</code><code> </code><code class="mi">0</code><code class="p">,</code><code> </code><code class="mi">1</code><code class="p">:</code><code> </code><code class="mi">2</code><code class="p">,</code><code> </code><code class="mi">2</code><code class="p">:</code><code> </code><code class="mi">4</code><code class="p">}</code><code>
</code><code class="p">{</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code> </code><code class="mi">4</code><code class="p">)</code><code class="p">,</code><code> </code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code> </code><code class="mi">2</code><code class="p">)</code><code class="p">,</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code> </code><code class="mi">0</code><code class="p">)</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO22-1" href="#co_asyncio_walk_through_CO22-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p><code>doubler()</code> is a very simple async generator: given an upper value, it’ll
iterate over a simple range, yielding a tuple of the value and its double.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO22-2" href="#co_asyncio_walk_through_CO22-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Sleep a little, just to emphasize that this is really an async function.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO22-3" href="#co_asyncio_walk_through_CO22-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>An async list comprehension: note how <code>async for</code> is used instead of the
usual <code>for</code>. <a data-type="indexterm" data-primary="for loops (async)" data-secondary="using in async comprehensions" id="idm46363029887736"/>This difference is the same as that shown in the examples in <a data-type="xref" href="#asynciter">“Async Iterators: async for”</a>.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO22-4" href="#co_asyncio_walk_through_CO22-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>An async dict comprehension; all the usual tricks work, such as unpacking
the tuple into <code>x</code> and <code>y</code> so that they can feed the dict comprehension
syntax.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO22-5" href="#co_asyncio_walk_through_CO22-5"><img src="assets/5.png" alt="5"/></a></dt>
<dd><p>The async set comprehension works exactly as you would expect.</p></dd>
</dl></div>

<p>You can also use <code>await</code> inside comprehensions, as outlined in PEP 530.<a data-type="indexterm" data-primary="await keyword" data-secondary="using inside comprehensions" id="idm46363029833800"/> This shouldn’t be a surprise; <code>await</code> <em><code>coro</code></em> is a normal expression and can be used in most places you would expect.</p>

<p>It’s the <code>async for</code> that makes a comprehension an <em>async
comprehension</em>, not the presence of <code>await</code>. All that’s needed for <code>await</code>
to be legal (inside a comprehension) is for it to be used inside the body of
a coroutine function—i.e., a function declared with <code>async def</code>.
Using <code>await</code> and <code>async for</code> inside the same list
comprehension is really combining two separate concepts,
but we’ll do this anyway in <a data-type="xref" href="#awaitcomp">Example 3-28</a> to make sure you’re
comfortable with async language syntax.</p>
<div id="awaitcomp" data-type="example">
<h5><span class="label">Example 3-28. </span>Putting it all together</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">f</code><code class="p">(</code><code class="n">x</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO23-1" href="#callout_asyncio_walk_through_CO23-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>   </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">0.1</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>   </code><code class="k">return</code><code> </code><code class="n">x</code><code> </code><code class="o">+</code><code> </code><code class="mi">100</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">factory</code><code class="p">(</code><code class="n">n</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO23-2" href="#callout_asyncio_walk_through_CO23-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>   </code><code class="k">for</code><code> </code><code class="n">x</code><code> </code><code class="ow">in</code><code> </code><code class="nb">range</code><code class="p">(</code><code class="n">n</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">0.1</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="k">yield</code><code> </code><code class="n">f</code><code class="p">,</code><code> </code><code class="n">x</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO23-3" href="#callout_asyncio_walk_through_CO23-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>   </code><code class="n">results</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="k">await</code><code> </code><code class="n">f</code><code class="p">(</code><code class="n">x</code><code class="p">)</code><code> </code><code class="k">async</code><code> </code><code class="k">for</code><code> </code><code class="n">f</code><code class="p">,</code><code> </code><code class="n">x</code><code> </code><code class="ow">in</code><code> </code><code class="n">factory</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="p">]</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO23-4" href="#callout_asyncio_walk_through_CO23-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>   </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">results = </code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">results</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="n">results</code><code> </code><code class="o">=</code><code>  </code><code class="p">[</code><code class="mi">100</code><code class="p">,</code><code> </code><code class="mi">101</code><code class="p">,</code><code> </code><code class="mi">102</code><code class="p">]</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO23-1" href="#co_asyncio_walk_through_CO23-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>A simple coroutine function: sleep for a bit; then return the
parameter plus 100.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO23-2" href="#co_asyncio_walk_through_CO23-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>This is an <em>async generator</em>, which we will call inside an
async list comprehension a bit farther down, using <code>async for</code> to drive
the iteration.<a data-type="indexterm" data-primary="asynchronous generator functions" data-secondary="calling in async comprehensions" id="idm46363029665752"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO23-3" href="#co_asyncio_walk_through_CO23-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>The async generator will yield a tuple of <code>f</code> and the
iteration var <code>x</code>. The <code>f</code> return value is a <em>coroutine function</em>, not yet
a coroutine.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO23-4" href="#co_asyncio_walk_through_CO23-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>Finally, the async comprehension. This example has been contrived to
demonstrate a comprehension that includes <em>both</em> <code>async for</code> and
<code>await</code>. Let’s break down what’s happening inside the comprehension. First,
the <code>factory(3)</code> call returns an async
generator, which must be driven by iteration. Because it’s an <em>async</em>
generator, you can’t just use <code>for</code>; you must use <code>async for</code>. <br/></p>

<p>The values produced by the async generator are a tuple of a coroutine function
<code>f</code> and an <code>int</code>. Calling the coroutine function <code>f()</code> produces a
coroutine, which must be evaluated with <code>await</code>.<br/></p>

<p>Note that inside the comprehension, the use of <code>await</code> has nothing at all
to do with the use of <code>async for</code>: they are doing completely different
things and acting on different objects entirely.<a data-type="indexterm" data-primary="set comprehensions, async" data-startref="ix_setcmpre" id="idm46363029591880"/><a data-type="indexterm" data-primary="dict comprehensions, async" data-startref="ix_dictcmpre" id="idm46363029591032"/><a data-type="indexterm" data-primary="list, dict, and set comprehensions, async" data-startref="ix_lstdctset" id="idm46363029590184"/><a data-type="indexterm" data-primary="comprehensions, async" data-startref="ix_compre" id="idm46363029589336"/><a data-type="indexterm" data-primary="asyncio" data-secondary="async comprehensions" data-startref="ix_asycompr" id="idm46363029588488"/></p></dd>
</dl></div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Starting Up and Shutting Down (Gracefully!)"><div class="sect1" id="shutdown">
<h1>Starting Up and Shutting Down (Gracefully!)</h1>

<p>Most async-based programs are going to be long-running, network-based
applications.<a data-type="indexterm" data-primary="asyncio" data-secondary="starting up and shutting down gracefully" id="ix_asystsh"/><a data-type="indexterm" data-primary="shutdown, handling" id="ix_shtdwn"/> This domain holds a surprising amount of complexity in
dealing with how to start up and shut down correctly.</p>

<p>Of the two, startup is simpler.<a data-type="indexterm" data-primary="startup, handling" id="idm46363029582392"/> The standard way of starting up an <code>asyncio</code>
application <a data-type="indexterm" data-primary="main coroutine" data-secondary="calling with asyncio.run function" id="idm46363029581272"/>is to have a <code>main()</code> coroutine function and call it with
<code>asyncio.run()</code>, as shown in <a data-type="xref" href="#helloworld">Example 3-2</a> at the beginning of this chapter.</p>

<p>Generally, startup will be fairly straightforward; for the server case
described earlier, you can read more about it
<a href="http://bit.ly/2FrKaIV">in the docs</a>.
We’ll also briefly look at a demonstration of server startup in an
upcoming code example.</p>

<p>Shutdown is much more intricate. For shutdown, I previously covered the dance that happens inside <code>asyncio.run()</code>. <a data-type="indexterm" data-primary="shutdown, handling" data-secondary="asyncio.run function" id="idm46363029576792"/><a data-type="indexterm" data-primary="asyncio.run function" data-secondary="actions taking place in" id="idm46363029575944"/>When the <code>async def main()</code> function exits, the following actions are taken:</p>
<ol>
<li>
<p>Collect<a data-type="indexterm" data-primary="tasks" data-secondary="collecting and cancelling in asyncio.run" id="idm46363029573688"/> all the still-pending task objects (if any).</p>
</li>
<li>
<p>Cancel these tasks (this raises <code>CancelledError</code> inside each running
coroutine, which you may choose to handle in a <code>try/except</code> within the
body of the coroutine function).<a data-type="indexterm" data-primary="group tasks" id="idm46363029571176"/></p>
</li>
<li>
<p>Gather all these tasks into a <em>group</em> task.</p>
</li>
<li>
<p>Use <code>run_until_complete()</code> on the group task to wait
for them to finish—i.e., let the <code>CancelledError</code> exception be raised
and dealt with.<a data-type="indexterm" data-primary="CancelledError exception" id="idm46363029567880"/></p>
</li>

</ol>

<p><code>asyncio.run()</code> performs these actions for you, but in spite of this assistance, a rite of passage in building your first
few nontrivial <code>asyncio</code> apps is going to be trying to get rid of error
messages like “Task was destroyed but it is pending!” during shutdown.<a data-type="indexterm" data-primary="shutdown, handling" data-secondary="destroyer of pending tasks" id="idm46363029565704"/><a data-type="indexterm" data-primary="tasks" data-secondary="pending, destroying during shutdown" id="idm46363029564856"/> This
happens because your application was not expecting one or more of the preceding
steps. <a data-type="xref" href="#destroytasks">Example 3-29</a>  is an example of a script that raises this annoying error.</p>
<div id="destroytasks" data-type="example">
<h5><span class="label">Example 3-29. </span>Destroyer of pending tasks</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># taskwarning.py</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">f</code><code class="p">(</code><code class="n">delay</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="n">delay</code><code class="p">)</code><code>
</code><code>
</code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">t1</code><code> </code><code class="o">=</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">f</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO24-1" href="#callout_asyncio_walk_through_CO24-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="n">t2</code><code> </code><code class="o">=</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">f</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO24-2" href="#callout_asyncio_walk_through_CO24-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="n">loop</code><code class="o">.</code><code class="n">run_until_complete</code><code class="p">(</code><code class="n">t1</code><code class="p">)</code><code> </code><a class="co" id="co_asyncio_walk_through_CO24-3" href="#callout_asyncio_walk_through_CO24-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="n">loop</code><code class="o">.</code><code class="n">close</code><code class="p">(</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO24-1" href="#co_asyncio_walk_through_CO24-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Task 1 will run for 1 second.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO24-2" href="#co_asyncio_walk_through_CO24-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Task 2 will run for 2 seconds.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO24-3" href="#co_asyncio_walk_through_CO24-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Run only until task 1 is complete.</p></dd>
</dl></div>

<p>Running it produces the following output:</p>
<pre data-type="programlisting">
$ <strong>python taskwarning.py</strong>
Task was destroyed but it is pending!
task: &lt;Task pending coro=&lt;f() done, defined at [...snip...]&gt;
</pre>

<p>This error is telling you that some tasks had not yet been completed
when the loop was closed. We want to avoid this, and that is why the
idiomatic shutdown procedure is to collect all unfinished tasks, cancel them, and then let them all finish <em>before</em> closing the loop.<a data-type="indexterm" data-primary="tasks" data-secondary="unfinished, collecting, cancelling, and allowing to finish during shutdown" id="idm46363029489640"/><a data-type="indexterm" data-primary="asyncio.run function" data-secondary="collecting, cancelling and allowing pending tasks to finish before closing the loop" id="idm46363029448696"/> <code>asyncio.run()</code> does all of these steps for you, but it is important to understand the process in detail so that you will
be able to handle more complex <span class="keep-together">situations</span>.</p>

<p>Let’s look at a more detailed code sample that illustrates all these phases.
<a data-type="xref" href="#telnetdemo">Example 3-30</a> is a mini case study with a Telnet-based echo server.<a data-type="indexterm" data-primary="startup, handling" data-secondary="Telnet-based echo server example" id="idm46363029445432"/><a data-type="indexterm" data-primary="Telnet-based echo server, asyncio application life cycle exmple" id="ix_Telecho"/><a data-type="indexterm" data-primary="Telnet-based echo server, asyncio application life cycle exmple" id="idm46363029443736"/></p>
<div id="telnetdemo" data-type="example">
<h5><span class="label">Example 3-30. </span>Asyncio application life cycle (based on the TCP echo server in the Python documentation)</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># telnetdemo.py</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="kn">from</code><code> </code><code class="nn">asyncio</code><code> </code><code class="k">import</code><code> </code><code class="n">StreamReader</code><code class="p">,</code><code> </code><code class="n">StreamWriter</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">echo</code><code class="p">(</code><code class="n">reader</code><code class="p">:</code><code> </code><code class="n">StreamReader</code><code class="p">,</code><code> </code><code class="n">writer</code><code class="p">:</code><code> </code><code class="n">StreamWriter</code><code class="p">)</code><code class="p">:</code><code> </code><a class="co" id="co_asyncio_walk_through_CO25-1" href="#callout_asyncio_walk_through_CO25-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">New connection.</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="k">try</code><code class="p">:</code><code>
</code><code>        </code><code class="k">while</code><code> </code><code class="n">data</code><code> </code><code class="p">:</code><code class="o">=</code><code> </code><code class="k">await</code><code> </code><code class="n">reader</code><code class="o">.</code><code class="n">readline</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO25-2" href="#callout_asyncio_walk_through_CO25-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>            </code><code class="n">writer</code><code class="o">.</code><code class="n">write</code><code class="p">(</code><code class="n">data</code><code class="o">.</code><code class="n">upper</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO25-3" href="#callout_asyncio_walk_through_CO25-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code>            </code><code class="k">await</code><code> </code><code class="n">writer</code><code class="o">.</code><code class="n">drain</code><code class="p">(</code><code class="p">)</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Leaving Connection.</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="k">except</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">CancelledError</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO25-4" href="#callout_asyncio_walk_through_CO25-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Connection dropped!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="n">host</code><code class="o">=</code><code class="s1">'</code><code class="s1">127.0.0.1</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">port</code><code class="o">=</code><code class="mi">8888</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">server</code><code> </code><code class="o">=</code><code> </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">start_server</code><code class="p">(</code><code class="n">echo</code><code class="p">,</code><code> </code><code class="n">host</code><code class="p">,</code><code> </code><code class="n">port</code><code class="p">)</code><code> </code><a class="co" id="co_asyncio_walk_through_CO25-5" href="#callout_asyncio_walk_through_CO25-5"><img src="assets/5.png" alt="5"/></a><code>
</code><code>    </code><code class="k">async</code><code> </code><code class="k">with</code><code> </code><code class="n">server</code><code class="p">:</code><code>
</code><code>        </code><code class="k">await</code><code> </code><code class="n">server</code><code class="o">.</code><code class="n">serve_forever</code><code class="p">(</code><code class="p">)</code><code>
</code><code>
</code><code class="k">try</code><code class="p">:</code><code>
</code><code>    </code><code class="n">asyncio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="k">except</code><code> </code><code class="ne">KeyboardInterrupt</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Bye!</code><code class="s1">'</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO25-1" href="#co_asyncio_walk_through_CO25-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>This <code>echo()</code> coroutine function will be used (by the server)
to create a coroutine for each connection made. The function is using the
streams API for networking with <code>asyncio</code>.<a data-type="indexterm" data-primary="echo coroutine function" id="idm46363029251496"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO25-2" href="#co_asyncio_walk_through_CO25-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>To keep the connection alive, we’ll have an infinite loop to wait for
messages.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO25-3" href="#co_asyncio_walk_through_CO25-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Return the data back to the sender, but in ALL CAPS.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO25-4" href="#co_asyncio_walk_through_CO25-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>If this task is <em>cancelled</em>, we’ll print a message.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO25-5" href="#co_asyncio_walk_through_CO25-5"><img src="assets/5.png" alt="5"/></a></dt>
<dd><p>This code for starting a TCP server is taken directly from the
Python 3.8 <span class="keep-together">documentation.</span></p></dd>
</dl></div>

<p>After starting the echo server, you can telnet to and interact with it:</p>
<pre data-type="programlisting">
$ <strong>telnet 127.0.0.1 8888</strong>
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
hi!
HI!
stop shouting
STOP SHOUTING
<strong>^]</strong>
telnet&gt; <strong>q/</strong>
Connection closed.
</pre>

<p>The server output for that session looks like this (the server keeps
running until we hit Ctrl-C):</p>
<pre data-type="programlisting">
$ <strong>python telnetdemo.py</strong>
New connection.
Leaving Connection.
<strong>^C</strong>Bye!
</pre>

<p>In the Telnet session<a data-type="indexterm" data-primary="shutdown, handling" data-secondary="Telnet-based echo server example" id="idm46363029205240"/> just shown, the client (i.e., Telnet) closed the connection
before the server was stopped, but let’s see what happens if we shut down our
server while a connection is active. We’ll see the following output from
the server process:</p>
<pre data-type="programlisting">
$ <strong>python telnetdemo.py</strong>
New connection.
<strong>^C</strong>Connection dropped!
Bye!
</pre>

<p>Here you can see that the exception handler for <code>CancelledError</code> was
triggered. Now let’s imagine that this is a real-world production
application, and we want to send all events about dropped connections
to a monitoring service.<a data-type="indexterm" data-primary="tasks" data-secondary="creating in a cancellation handler" id="idm46363029201672"/> The code sample might be modified to look
like <a data-type="xref" href="#taskaftercancel">Example 3-31</a>.</p>
<div id="taskaftercancel" data-type="example">
<h5><span class="label">Example 3-31. </span>Creating a task inside a cancellation handler</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># telnetdemo.py</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="kn">from</code><code> </code><code class="nn">asyncio</code><code> </code><code class="k">import</code><code> </code><code class="n">StreamReader</code><code class="p">,</code><code> </code><code class="n">StreamWriter</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">send_event</code><code class="p">(</code><code class="n">msg</code><code class="p">:</code><code> </code><code class="nb">str</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO26-1" href="#callout_asyncio_walk_through_CO26-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>    </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">echo</code><code class="p">(</code><code class="n">reader</code><code class="p">:</code><code> </code><code class="n">StreamReader</code><code class="p">,</code><code> </code><code class="n">writer</code><code class="p">:</code><code> </code><code class="n">StreamWriter</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">New connection.</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="k">try</code><code class="p">:</code><code>
</code><code>        </code><code class="k">while</code><code> </code><code class="p">(</code><code class="n">data</code><code> </code><code class="p">:</code><code class="o">=</code><code> </code><code class="k">await</code><code> </code><code class="n">reader</code><code class="o">.</code><code class="n">readline</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">:</code><code>
</code><code>            </code><code class="n">writer</code><code class="o">.</code><code class="n">write</code><code class="p">(</code><code class="n">data</code><code class="o">.</code><code class="n">upper</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code>            </code><code class="k">await</code><code> </code><code class="n">writer</code><code class="o">.</code><code class="n">drain</code><code class="p">(</code><code class="p">)</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Leaving Connection.</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="k">except</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">CancelledError</code><code class="p">:</code><code>
</code><code>        </code><code class="n">msg</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">Connection dropped!</code><code class="s1">'</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="n">msg</code><code class="p">)</code><code>
</code><code>        </code><code class="n">asyncio</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">send_event</code><code class="p">(</code><code class="n">msg</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO26-2" href="#callout_asyncio_walk_through_CO26-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="n">host</code><code class="o">=</code><code class="s1">'</code><code class="s1">127.0.0.1</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">port</code><code class="o">=</code><code class="mi">8888</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">server</code><code> </code><code class="o">=</code><code> </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">start_server</code><code class="p">(</code><code class="n">echo</code><code class="p">,</code><code> </code><code class="n">host</code><code class="p">,</code><code> </code><code class="n">port</code><code class="p">)</code><code>
</code><code>    </code><code class="k">async</code><code> </code><code class="k">with</code><code> </code><code class="n">server</code><code class="p">:</code><code>
</code><code>        </code><code class="k">await</code><code> </code><code class="n">server</code><code class="o">.</code><code class="n">serve_forever</code><code class="p">(</code><code class="p">)</code><code>
</code><code>
</code><code class="k">try</code><code class="p">:</code><code>
</code><code>    </code><code class="n">asyncio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="k">except</code><code> </code><code class="ne">KeyboardInterrupt</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Bye!</code><code class="s1">'</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO26-1" href="#co_asyncio_walk_through_CO26-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Pretend that this coroutine actually contacts an external server
to submit event notifications.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO26-2" href="#co_asyncio_walk_through_CO26-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Because the event notifier involves network access, it is common for
such calls to be made in a separate async task; that’s why we’re using
the <code>create_task()</code> function here.<a data-type="indexterm" data-primary="asyncio.create_task function" id="idm46363029055656"/><a data-type="indexterm" data-primary="create_task function" id="idm46363029054952"/></p></dd>
</dl></div>

<p>This code has a bug, however. It becomes obvious if we rerun the example, and
make sure to stop the server (with Ctrl-C) while a connection is
active:</p>
<pre data-type="programlisting">
$ <strong>python telnetdemo.py</strong>
New connection.
<strong>^C</strong>Connection dropped!
Bye!
Task was destroyed but it is pending!
task: &lt;Task pending name='Task-6' coro=&lt;send_event() done, ...&gt;
</pre>

<p>To understand why this is happening, we must go back to the sequence of
cleanup events that <code>asyncio.run()</code> does during<a data-type="indexterm" data-primary="asyncio.run function" data-secondary="cleanup events during shutdown, Telnet-based echo server example" id="idm46363029050776"/> the shutdown phase; in
particular, the important part is that when we press Ctrl-C, all the
currently active tasks are collected and cancelled. At this point,
<em>only those tasks</em> are then awaited, and <code>asyncio.run()</code> returns immediately
after that.  The bug in our modified code is that we created a <em>new</em> task
inside the cancellation handler of our existing “echo” task. This new task
was created only after <code>asyncio.run()</code> had collected and cancelled all the
tasks in the process.</p>

<p>This is why it is important to be aware of how <code>asyncio.run()</code> works.</p>
<div data-type="tip"><h6>Tip</h6>
<p>As a general rule of thumb, try to avoid creating new tasks inside
<code>CancelledError</code> exception handlers.<a data-type="indexterm" data-primary="CancelledError exception" data-secondary="avoiding creation of new tasks in exception handlers" id="idm46363029045544"/><a data-type="indexterm" data-primary="await keyword" data-secondary="awaiting new tasks created in CancelledError handlers" id="idm46363029044552"/> If you must, be sure to also
<code>await</code> the new task or future inside the scope of the same function.</p>
</div>

<p>And finally: if you’re using a library or framework, make sure to follow its
documentation on how you should perform startup and shutdown.<a data-type="indexterm" data-primary="frameworks (third-party), startup/shutdown in" id="idm46363029042424"/><a data-type="indexterm" data-primary="libraries" data-secondary="third-party, startup/shutdown in" id="idm46363029041752"/> Third-party
frameworks usually provide their own functions for startup and shutdown,
and they’ll provide event hooks for customization.
You can see an example of these hooks with the Sanic framework in <a data-type="xref" href="ch04.html#asyncpg_cs">“Case Study: Cache Invalidation”</a>.<a data-type="indexterm" data-primary="Telnet-based echo server, asyncio application life cycle exmple" data-startref="ix_Telecho" id="idm46363029039592"/></p>








<section data-type="sect2" data-pdf-bookmark="What Is the return_exceptions=True for in gather()?"><div class="sect2" id="retexcept">
<h2>What Is the return_exceptions=True for in gather()?</h2>

<p>You may have noticed the keyword argument
<code>return_exceptions=True</code> in the call to <code>gather()</code> in Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#quickstart-executor">3-3</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#features_of_asyncio_arranged_in_a_hierarchy">3-1</a>
during the shutdown sequence, but I very sneakily said nothing about it at the time.<a data-type="indexterm" data-primary="asyncio" data-secondary="starting up and shutting down gracefully" data-tertiary="return_exceptions=True argument in gather" id="idm46363029032728"/><a data-type="indexterm" data-primary="gather function" data-secondary="return_exceptions=True argument" id="idm46363029031576"/><a data-type="indexterm" data-primary="asyncio.gather function" data-secondary="return_exceptions=True argument" id="idm46363029030664"/><a data-type="indexterm" data-primary="return_exceptions=True argument in gather function" id="idm46363029029704"/><a data-type="indexterm" data-primary="shutdown, handling" data-secondary="return_exceptions=True argument in gather" id="idm46363029029064"/>
<code>asyncio.run()</code> also uses <code>gather()</code> and <code>return_exceptions=True</code>
internally, and the time has come for further discussion.<a data-type="indexterm" data-primary="asyncio.run function" data-secondary="asyncio.gather function, return_exceptions=True argument" id="idm46363029026712"/></p>

<p>Unfortunately, the default is <code>gather(..., return_exceptions=False</code>). This
default is problematic for most situations, including the shutdown process,
and this is why <code>asyncio.run()</code> sets the parameter to <code>True</code>. It’s a little
complicated to explain directly; instead, let’s step through a sequence of
observations that’ll make it much easier to understand:</p>
<ol>
<li>
<p><code>run_until_complete()</code> operates on a future; during shutdown, it’s the
future returned by <code>gather()</code>.<a data-type="indexterm" data-primary="futures" data-secondary="generated by asyncio.gather during shutdown" id="idm46363029022072"/><a data-type="indexterm" data-primary="run_until_complete function" data-secondary="operating on a future during shutdown, exceptions and" id="idm46363029021096"/></p>
</li>
<li>
<p>If that future raises an exception, the exception will <em>also</em> be
raised out of <code>run_until_complete()</code>, which means that the loop will stop.</p>
</li>
<li>
<p>If <code>run_until_complete()</code> is being used<a data-type="indexterm" data-primary="group futures, run_until_complete function called on, exceptions and" id="idm46363029016936"/> on a group future, any exception
raised inside <em>any of the subtasks</em> will also be raised in the “group” future if
it isn’t handled in the subtask.<a data-type="indexterm" data-primary="CancelledError exception" data-secondary="tasks not handling, causing loop to stop" id="idm46363029015720"/><a data-type="indexterm" data-primary="tasks" data-secondary="not handling CancelledError, causing loop to stop before all tasks complete" id="idm46363029014760"/> Note this includes <code>CancelledError</code>.</p>
</li>
<li>
<p>If only some tasks handle <code>CancelledError</code> and others don’t, the ones that don’t
will cause the loop to stop. This means that the loop will be
stopped <em>before</em> all the tasks are done.</p>
</li>
<li>
<p>For shutdown, we really don’t want this behavior. We want
<span class="keep-together"><code>run_until_complete()</code></span> to finish only when all the tasks in the group
have finished, regardless of whether some of the tasks raise
exceptions.</p>
</li>
<li>
<p>Hence we have <code>gather(*, return_exceptions=True)</code>: that setting makes the
“group” future treat exceptions from the subtasks as <em>returned values</em>, so
that they don’t bubble out and interfere with <code>run_until_complete()</code>.</p>
</li>

</ol>

<p>And there you have it: the relationship between <code>return_exceptions=True</code>
and <code>run_until_complete()</code>.<a data-type="indexterm" data-primary="exceptions" data-secondary="run_until_complete function and" id="idm46363029005928"/> An undesirable consequence of capturing exceptions in this way is that
some errors may escape your attention because they’re now
(effectively) being handled inside the group task. If this is a
concern, you can obtain the output list from <code>run_until_complete()</code> and
scan it for any subclasses of <code>Exception</code>, and then write log messages
appropriate for your situation. <a data-type="xref" href="#allcomplete">Example 3-32</a> demonstrates this approach.</p>
<div id="allcomplete" data-type="example">
<h5><span class="label">Example 3-32. </span>All the tasks will complete</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># alltaskscomplete.py</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">f</code><code class="p">(</code><code class="n">delay</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">1</code><code> </code><code class="o">/</code><code> </code><code class="n">delay</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO27-1" href="#callout_asyncio_walk_through_CO27-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>    </code><code class="k">return</code><code> </code><code class="n">delay</code><code>
</code><code>
</code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="k">for</code><code> </code><code class="n">i</code><code> </code><code class="ow">in</code><code> </code><code class="nb">range</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">f</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="n">pending</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">all_tasks</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">group</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">gather</code><code class="p">(</code><code class="o">*</code><code class="n">pending</code><code class="p">,</code><code> </code><code class="n">return_exceptions</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code>
</code><code class="n">results</code><code> </code><code class="o">=</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">run_until_complete</code><code class="p">(</code><code class="n">group</code><code class="p">)</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">Results: </code><code class="si">{results}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">loop</code><code class="o">.</code><code class="n">close</code><code class="p">(</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO27-1" href="#co_asyncio_walk_through_CO27-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>It would be awful if someone were to pass in a zero…</p></dd>
</dl></div>

<p>Here’s the output:</p>
<pre data-type="programlisting">
$ <strong>python alltaskscomplete.py</strong>
Results: [6, 9, 3, 7, ...
          ZeroDivisionError('division by zero',), 4, ...
          8, 1, 5, 2]
</pre>

<p>Without <code>return_exceptions=True</code>, the <code>ZeroDivisionError</code> would
be raised from <code>run_until_complete()</code>, stopping the loop and thus
preventing the other tasks from finishing.</p>

<p>In the next section, we look at handling signals (beyond
<span class="keep-together">KeyboardInterrupt),</span>
but before we get there, it’s worth keeping in
mind that graceful shutdown is one of the more difficult aspects of
network programming, and this remains true for <code>asyncio</code>.<a data-type="indexterm" data-primary="shutdown, handling" data-secondary="difficulty of graceful shutdown in network programming" id="idm46363029089592"/><a data-type="indexterm" data-primary="network programming" data-secondary="difficulty of graceful shutdown" id="idm46363028728328"/> The
information in this section is merely a start. I encourage you to have
specific tests for clean shutdown in your own automated test suites.
Different applications often require different strategies.</p>
<div data-type="tip"><h6>Tip</h6>
<p>I’ve published a tiny package on the Python package index (PyPI) called
<a href="https://oreil.ly/kQDt8"><code>aiorun</code></a>, primarily for my own
experiments and education in dealing with <code>asyncio</code> shutdown, <a data-type="indexterm" data-primary="aiorun package" id="idm46363028724856"/><a data-type="indexterm" data-primary="Python" data-secondary="package index (PyPI), aiorun package on" id="idm46363028724120"/>that incorporates
many ideas from this section. It may also be useful for you to tinker
with the code and experiment with your own ideas around <code>asyncio</code>
shutdown scenarios.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Signals"><div class="sect2" id="signals">
<h2>Signals</h2>

<p>Previous examples showed how the event loop is stopped with a
<code>KeyboardInterrupt</code>; i.e., pressing Ctrl-C.<a data-type="indexterm" data-primary="Ctrl-C" data-seealso="KeyboardInterrupt" id="idm46363028719912"/><a data-type="indexterm" data-primary="process signals" id="idm46363028814744"/><a data-type="indexterm" data-primary="KeyboardInterrupt" id="idm46363028814072"/><a data-type="indexterm" data-primary="signals" id="idm46363028813400"/><a data-type="indexterm" data-primary="asyncio" data-secondary="starting up and shutting down gracefully" data-tertiary="signals" id="idm46363028812728"/><a data-type="indexterm" data-primary="event loops" data-secondary="stopped by KeyboardInterrupt or Ctrl-C" id="idm46363028811544"/> Internally within
<code>asyncio.run()</code>, the raised
<code>KeyboardInterrupt</code> effectively unblocks a  <code>loop.run_until_complete()</code>
call and allows the subsequent shutdown sequence to happen.</p>

<p><code>KeyboardInterrupt</code> corresponds to the <code>SIGINT</code> signal. <a data-type="indexterm" data-primary="SIGINT signal" id="idm46363028808008"/>In network services,
the more common signal for process termination is actually <code>SIGTERM</code>, and
this is also the default signal when you use the <code>kill</code> command in a Unix
shell.<a data-type="indexterm" data-primary="SIGTERM signal" id="idm46363028806344"/><a data-type="indexterm" data-primary="kill command (Unix systems)" id="idm46363028805640"/><a data-type="indexterm" data-primary="Unix systems" data-secondary="kill command" id="idm46363028804952"/></p>
<div data-type="tip"><h6>Tip</h6>
<p>The <code>kill</code> command on Unix systems is deceptively named: all it
does it send signals to a process. Without arguments, <code>kill</code> <em><code>&lt;PID&gt;</code></em>
will send a <code>TERM</code> signal: your process can receive the signal and do
a graceful shutdown, or simply ignore it! That’s a bad idea, though,
because if your process doesn’t stop eventually, the next thing the
would-be killer usually does is <code>kill -s KILL</code> <em><code>&lt;PID&gt;</code></em>, which sends the <code>KILL</code>
signal. This will shut you down, and there’s nothing your program can
do about it. Receiving the <code>TERM</code> (or <code>INT</code>) signal is your opportunity
to shut down in a controlled way.</p>
</div>

<p><code>asyncio</code> has built-in support for handling process signals, but
there’s a surprising degree of complexity around signal handling in
general (not specific to <code>asyncio</code>).<a data-type="indexterm" data-primary="signals" data-secondary="complexity around signal handling" id="idm46363028796984"/> We cannot cover everything here, but
we can have a look at some of the more basic considerations that need
to be made. <a data-type="xref" href="#shutsig01">Example 3-33</a> will produce the following output:</p>
<pre data-type="programlisting">
$ <strong>python shell_signal01.py</strong>
&lt;Your app is running&gt;
&lt;Your app is running&gt;
&lt;Your app is running&gt;
&lt;Your app is running&gt;
<strong>^C</strong>Got signal: SIGINT, shutting down.
</pre>

<p>I pressed Ctrl-C to stop the program, as shown on the last line.
<a data-type="xref" href="#shutsig01">Example 3-33</a> intentionally avoids using <a data-type="indexterm" data-primary="Ctrl-C" data-secondary="stopping a program with" id="idm46363028791768"/>the convenient <code>asyncio.run()</code>
function because I want to warn you about specific traps in handling the two
most common signals, <code>SIGTERM</code> and <code>SIGINT</code>, during your shutdown sequence.
After we discuss these, I will show a final example of signal
handling using the more <a data-type="indexterm" data-primary="signals" data-secondary="using KeyboardInterrupt as handler for SIGINT" id="idm46363028789176"/><a data-type="indexterm" data-primary="SIGINT signal" data-secondary="using KeyboardInterrupt as handler" id="idm46363028788232"/><a data-type="indexterm" data-primary="KeyboardInterrupt" data-secondary="using as SIGINT handler" id="idm46363028787224"/>convenient <code>asyncio.run()</code> function.</p>
<div id="shutsig01" data-type="example">
<h5><span class="label">Example 3-33. </span>Refresher for using KeyboardInterrupt as a SIGINT handler</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># shell_signal01.py</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO28-1" href="#callout_asyncio_walk_through_CO28-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>    </code><code class="k">while</code><code> </code><code class="kc">True</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">&lt;Your app is running&gt;</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code>
</code><code>
</code><code>
</code><code class="k">if</code><code> </code><code class="nv-Magic">__name__</code><code> </code><code class="o">==</code><code> </code><code class="s1">'</code><code class="s1">__main__</code><code class="s1">'</code><code class="p">:</code><code>
</code><code>    </code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="n">task</code><code> </code><code class="o">=</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO28-2" href="#callout_asyncio_walk_through_CO28-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>    </code><code class="k">try</code><code class="p">:</code><code>
</code><code>        </code><code class="n">loop</code><code class="o">.</code><code class="n">run_until_complete</code><code class="p">(</code><code class="n">task</code><code class="p">)</code><code>
</code><code>    </code><code class="k">except</code><code> </code><code class="ne">KeyboardInterrupt</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO28-3" href="#callout_asyncio_walk_through_CO28-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Got signal: SIGINT, shutting down.</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="n">tasks</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">all_tasks</code><code class="p">(</code><code class="n">loop</code><code class="o">=</code><code class="n">loop</code><code class="p">)</code><code>
</code><code>    </code><code class="k">for</code><code> </code><code class="n">t</code><code> </code><code class="ow">in</code><code> </code><code class="n">tasks</code><code class="p">:</code><code>
</code><code>        </code><code class="n">t</code><code class="o">.</code><code class="n">cancel</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="n">group</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">gather</code><code class="p">(</code><code class="o">*</code><code class="n">tasks</code><code class="p">,</code><code> </code><code class="n">return_exceptions</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">run_until_complete</code><code class="p">(</code><code class="n">group</code><code class="p">)</code><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">close</code><code class="p">(</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO28-1" href="#co_asyncio_walk_through_CO28-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>This is the main part of our application. To keep things
simple, we’re just going to sleep in an infinite loop.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO28-2" href="#co_asyncio_walk_through_CO28-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>This startup and shutdown sequence will be familiar to you from the
previous section. We schedule <code>main()</code>, call <code>run_forever()</code>, and wait for
something to stop the loop.<a data-type="indexterm" data-primary="loop.run_forever function" id="idm46363028537832"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO28-3" href="#co_asyncio_walk_through_CO28-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>In this case, only Ctrl-C will stop the loop. Then we handle
<code>KeyboardInterrupt</code> and do all the necessary cleanup bits, as covered
in the previous sections.</p></dd>
</dl></div>

<p>So far, that’s pretty straightforward. Now I’m going to complicate things. Suppose that:</p>

<ul>
<li>
<p>One of your colleagues asks that you please handle <code>SIGTERM</code> in addition
to <code>SIGINT</code> as a shutdown signal.<a data-type="indexterm" data-primary="SIGTERM signal" data-secondary="handling as shutdown signal" id="idm46363028527864"/></p>
</li>
<li>
<p>In your real application, you need to do cleanup
inside your <code>main()</code> coroutine; you will need to  handle <code>CancelledError</code>,
and the cleanup code inside the exception handler will take several seconds
to finish (imagine that you have to communicate with network peers and close
a bunch of socket connections).</p>
</li>
<li>
<p>Your app must not do weird things if you’re sent signals
multiple times (such as rerunning any shutdown steps); after you receive the first shutdown signal, you want to
simply ignore any new signals until exit.</p>
</li>
</ul>

<p><code>asyncio</code> provides enough granularity in the API to handle all these
situations. <a data-type="xref" href="#bothsig">Example 3-34</a> modifies the previous simple code example to include
these new <span class="keep-together">features.</span></p>
<div id="bothsig" data-type="example">
<h5><span class="label">Example 3-34. </span>Handle both SIGINT and SIGTERM, but stop the loop only once</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># shell_signal02.py</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="kn">from</code><code> </code><code class="nn">signal</code><code> </code><code class="k">import</code><code> </code><code class="n">SIGINT</code><code class="p">,</code><code> </code><code class="n">SIGTERM</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO29-1" href="#callout_asyncio_walk_through_CO29-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="k">try</code><code class="p">:</code><code>
</code><code>        </code><code class="k">while</code><code> </code><code class="kc">True</code><code class="p">:</code><code>
</code><code>            </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">&lt;Your app is running&gt;</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>            </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code>
</code><code>    </code><code class="k">except</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">CancelledError</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO29-2" href="#callout_asyncio_walk_through_CO29-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>        </code><code class="k">for</code><code> </code><code class="n">i</code><code> </code><code class="ow">in</code><code> </code><code class="nb">range</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="p">:</code><code>
</code><code>            </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">&lt;Your app is shutting down...&gt;</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>            </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code>
</code><code>
</code><code class="k">def</code><code> </code><code class="nf">handler</code><code class="p">(</code><code class="n">sig</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO29-3" href="#callout_asyncio_walk_through_CO29-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">stop</code><code class="p">(</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO29-4" href="#callout_asyncio_walk_through_CO29-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">Got signal: </code><code class="si">{sig!s}</code><code class="s1">, shutting down.</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">remove_signal_handler</code><code class="p">(</code><code class="n">SIGTERM</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO29-5" href="#callout_asyncio_walk_through_CO29-5"><img src="assets/5.png" alt="5"/></a><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">add_signal_handler</code><code class="p">(</code><code class="n">SIGINT</code><code class="p">,</code><code> </code><code class="k">lambda</code><code class="p">:</code><code> </code><code class="kc">None</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO29-6" href="#callout_asyncio_walk_through_CO29-6"><img src="assets/6.png" alt="6"/></a><code>
</code><code>
</code><code class="k">if</code><code> </code><code class="nv-Magic">__name__</code><code> </code><code class="o">==</code><code> </code><code class="s1">'</code><code class="s1">__main__</code><code class="s1">'</code><code class="p">:</code><code>
</code><code>    </code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="k">for</code><code> </code><code class="n">sig</code><code> </code><code class="ow">in</code><code> </code><code class="p">(</code><code class="n">SIGTERM</code><code class="p">,</code><code> </code><code class="n">SIGINT</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO29-7" href="#callout_asyncio_walk_through_CO29-7"><img src="assets/7.png" alt="7"/></a><code>
</code><code>        </code><code class="n">loop</code><code class="o">.</code><code class="n">add_signal_handler</code><code class="p">(</code><code class="n">sig</code><code class="p">,</code><code> </code><code class="n">handler</code><code class="p">,</code><code> </code><code class="n">sig</code><code class="p">)</code><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">run_forever</code><code class="p">(</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO29-8" href="#callout_asyncio_walk_through_CO29-8"><img src="assets/8.png" alt="8"/></a><code>
</code><code>    </code><code class="n">tasks</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">all_tasks</code><code class="p">(</code><code class="n">loop</code><code class="o">=</code><code class="n">loop</code><code class="p">)</code><code>
</code><code>    </code><code class="k">for</code><code> </code><code class="n">t</code><code> </code><code class="ow">in</code><code> </code><code class="n">tasks</code><code class="p">:</code><code>
</code><code>        </code><code class="n">t</code><code class="o">.</code><code class="n">cancel</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="n">group</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">gather</code><code class="p">(</code><code class="o">*</code><code class="n">tasks</code><code class="p">,</code><code> </code><code class="n">return_exceptions</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">run_until_complete</code><code class="p">(</code><code class="n">group</code><code class="p">)</code><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">close</code><code class="p">(</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO29-1" href="#co_asyncio_walk_through_CO29-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Import the signal values from the standard library <code>signal</code> module.<a data-type="indexterm" data-primary="signals" data-secondary="handling both SIGINT and SIGTERM, stopping loop only once" id="idm46363028222712"/><a data-type="indexterm" data-primary="SIGTERM signal" data-secondary="handling both SIGINT and, stopping loop only once" id="idm46363028221864"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO29-2" href="#co_asyncio_walk_through_CO29-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>This time, our <code>main()</code> coroutine is going to do some cleanup
internally.<a data-type="indexterm" data-primary="main coroutine" data-secondary="cleanup after SIGINT and SIGTERM signals" id="idm46363028258088"/> When the cancellation signal is received (initiated by cancelling each of the tasks), there will be a period of 3 seconds where <code>main()</code> will
continue running during the <code>run_until_complete()</code> phase of the
shutdown process. <a data-type="indexterm" data-primary="loop.run_until_complete function" id="idm46363028256200"/>It’ll print, “Your app is shutting down…”.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO29-3" href="#co_asyncio_walk_through_CO29-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>This is a callback handler for when we receive a signal. It is configured
on the loop via<a data-type="indexterm" data-primary="add_signal_handler function" id="idm46363028253256"/> the call to <code>add_signal_handler()</code> a bit farther down.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO29-4" href="#co_asyncio_walk_through_CO29-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>The primary purpose of the handler is to stop the loop: this will
unblock the <code>loop.run_forever()</code> call and allow pending task collection and
cancellation, and the <code>run_complete()</code> for shutdown.<a data-type="indexterm" data-primary="run_complete function" id="idm46363028192696"/><a data-type="indexterm" data-primary="loop.run_forever function" id="idm46363028192088"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO29-5" href="#co_asyncio_walk_through_CO29-5"><img src="assets/5.png" alt="5"/></a></dt>
<dd><p>Since we are now in shutdown mode, we <em>don’t want</em> another <code>SIGINT</code>
or <code>SIGTERM</code> to trigger this handler again: that would call <code>loop.stop()</code>
during the <code>run_until_complete()</code> phase, which would interfere with our
shutdown process. <a data-type="indexterm" data-primary="loop.stop function" id="idm46363028187112"/> Therefore, we <em>remove</em> the signal handler for
<code>SIGTERM</code> from the loop.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO29-6" href="#co_asyncio_walk_through_CO29-6"><img src="assets/6.png" alt="6"/></a></dt>
<dd><p>This is a “gotcha”: we can’t simply remove the handler for <code>SIGINT</code>, because
if we did that, <code>KeyboardInterrupt</code> would again become the handler
for <code>SIGINT</code>, the same as it was
before we added our own handlers. Instead, we set an empty <code>lambda</code>
function as the handler.<a data-type="indexterm" data-primary="lambda function, setting as handler for SIGINT" id="idm46363028181752"/> This means that <code>KeyboardInterrupt</code> stays away,
and <code>SIGINT</code> (and Ctrl-C) has no effect.<sup><a data-type="noteref" id="idm46363028180248-marker" href="ch03.html#idm46363028180248">10</a></sup></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO29-7" href="#co_asyncio_walk_through_CO29-7"><img src="assets/7.png" alt="7"/></a></dt>
<dd><p>Here the signal handlers are attached to the loop. Note that, as
discussed previously, setting a handler on <code>SIGINT</code> means a <code>KeyboardInterrupt</code>
will no longer be raised on <code>SIGINT</code>. The raising of a <code>KeyboardInterrupt</code>
is the “default” handler for <code>SIGINT</code> and is preconfigured in Python until
you do something to change the handler, as we’re doing here.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO29-8" href="#co_asyncio_walk_through_CO29-8"><img src="assets/8.png" alt="8"/></a></dt>
<dd><p>As usual, execution blocks on <code>run_forever()</code> until something stops
the loop. In this case, the loop will be stopped inside <span class="keep-together"><code>handler()</code></span> if
either <code>SIGINT</code> or <code>SIGTERM</code> is sent to our process. The remainder of the
code is the same as before.</p></dd>
</dl></div>

<p>Here’s the output:</p>
<pre data-type="programlisting">
$ <strong>python shell_signal02.py</strong>
&lt;Your app is running&gt;
&lt;Your app is running&gt;
&lt;Your app is running&gt;
&lt;Your app is running&gt;
&lt;Your app is running&gt;
<strong>^C</strong>Got signal: Signals.SIGINT, shutting down.
&lt;Your app is shutting down...&gt;
<strong>^C</strong>&lt;Your app is shutting down...&gt;  <a class="co" id="comarker1" href="#c01"><img src="assets/1.png" alt="1"/></a>
<strong>^C</strong>&lt;Your app is shutting down...&gt;
</pre>
<dl class="calloutlist">
 <dt><a class="co" id="c01" href="#comarker1"><img src="assets/1.png" alt="1"/></a></dt>
  <dd><p>I hit Ctrl-C a bunch of times during the shutdown phase, but as
expected, nothing happened until the <code>main()</code> coroutine eventually
completed.</p>
</dd>
</dl>

<p>In these examples, I’ve controlled the life cycle of the event loop
the hard way, but this was necessary to explain the components of the
shutdown procedure. In practice, we would much prefer to use the more convenient <code>asyncio.run()</code>
function. <a data-type="xref" href="#bothsigrun">Example 3-35</a> retains the features of the preceding
signal-handling design, but also takes advantage of the convenience of
<code>asyncio.run()</code>.<a data-type="indexterm" data-primary="signals" data-secondary="handling when using asyncio.run" id="idm46363028160520"/><a data-type="indexterm" data-primary="asyncio.run function" data-secondary="handling signals when using" id="idm46363028159672"/></p>
<div id="bothsigrun" data-type="example">
<h5><span class="label">Example 3-35. </span>Signal handling when using asyncio.run()</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># shell_signal02b.py</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="kn">from</code><code> </code><code class="nn">signal</code><code> </code><code class="k">import</code><code> </code><code class="n">SIGINT</code><code class="p">,</code><code> </code><code class="n">SIGTERM</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_running_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="k">for</code><code> </code><code class="n">sig</code><code> </code><code class="ow">in</code><code> </code><code class="p">(</code><code class="n">SIGTERM</code><code class="p">,</code><code> </code><code class="n">SIGINT</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="n">loop</code><code class="o">.</code><code class="n">add_signal_handler</code><code class="p">(</code><code class="n">sig</code><code class="p">,</code><code> </code><code class="n">handler</code><code class="p">,</code><code> </code><code class="n">sig</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO30-1" href="#callout_asyncio_walk_through_CO30-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>
</code><code>    </code><code class="k">try</code><code class="p">:</code><code>
</code><code>        </code><code class="k">while</code><code> </code><code class="kc">True</code><code class="p">:</code><code>
</code><code>            </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">&lt;Your app is running&gt;</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>            </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code>
</code><code>    </code><code class="k">except</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">CancelledError</code><code class="p">:</code><code>
</code><code>        </code><code class="k">for</code><code> </code><code class="n">i</code><code> </code><code class="ow">in</code><code> </code><code class="nb">range</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="p">:</code><code>
</code><code>            </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">&lt;Your app is shutting down...&gt;</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>            </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code>
</code><code>
</code><code class="k">def</code><code> </code><code class="nf">handler</code><code class="p">(</code><code class="n">sig</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_running_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="k">for</code><code> </code><code class="n">task</code><code> </code><code class="ow">in</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">all_tasks</code><code class="p">(</code><code class="n">loop</code><code class="o">=</code><code class="n">loop</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO30-2" href="#callout_asyncio_walk_through_CO30-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>        </code><code class="n">task</code><code class="o">.</code><code class="n">cancel</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">Got signal: </code><code class="si">{sig!s}</code><code class="s1">, shutting down.</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">remove_signal_handler</code><code class="p">(</code><code class="n">SIGTERM</code><code class="p">)</code><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">add_signal_handler</code><code class="p">(</code><code class="n">SIGINT</code><code class="p">,</code><code> </code><code class="k">lambda</code><code class="p">:</code><code> </code><code class="kc">None</code><code class="p">)</code><code>
</code><code>
</code><code class="k">if</code><code> </code><code class="nv-Magic">__name__</code><code> </code><code class="o">==</code><code> </code><code class="s1">'</code><code class="s1">__main__</code><code class="s1">'</code><code class="p">:</code><code>
</code><code>    </code><code class="n">asyncio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO30-1" href="#co_asyncio_walk_through_CO30-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Because <code>asyncio.run()</code> takes control of the event loop startup, our
first opportunity to change signal handling behavior will be in the <code>main()</code>
function.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO30-2" href="#co_asyncio_walk_through_CO30-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Inside the signal handler, we can’t stop the loop as in previous examples,
because we’ll get warnings about how the loop was stopped before the task
created for <code>main()</code> was completed. Instead, we can initiate task cancellation
here, which will ultimately result in the <code>main()</code> task exiting; when
that happens, the cleanup handling inside <code>asyncio.run()</code> will take over.</p></dd>
</dl></div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Waiting for the Executor During Shutdown"><div class="sect2" id="waitforexe">
<h2>Waiting for the Executor During Shutdown</h2>

<p><a data-type="xref" href="#quickstart-section">“Quickstart”</a> introduced the basic executor interface
with <a data-type="xref" href="#quickstart-executor">Example 3-3</a>, where I <a data-type="indexterm" data-primary="shutdown, handling" data-secondary="waiting for the executor" id="idm46363027937944"/><a data-type="indexterm" data-primary="asyncio" data-secondary="starting up and shutting down gracefully" data-tertiary="waiting for executor during shutdown" id="idm46363027937000"/><a data-type="indexterm" data-primary="executors" data-secondary="waiting for during shutdown" id="idm46363027964744"/>pointed out that the
blocking <code>time.sleep()</code> call was conveniently shorter than the
<code>asyncio.sleep()</code> call—luckily for us, because it means the executor
task completes sooner than the <code>main()</code> coroutine, and as a result the
program shuts down correctly.<a data-type="indexterm" data-primary="sleep" data-secondary="time.sleep and asyncio.sleep functions" id="idm46363027962440"/><a data-type="indexterm" data-primary="time.sleep function" id="idm46363027961400"/><a data-type="indexterm" data-primary="asyncio.sleep function" id="idm46363027960728"/></p>

<p>This section examines what happens during shutdown when executor
jobs take longer to finish than all the pending <code>Task</code> instances.<a data-type="indexterm" data-primary="tasks" data-secondary="executor jobs taking longer than pending Task instances in shutdown" id="idm46363028151112"/> The
short answer is: without intervention, you’re going to get errors like
those produced by the code in <a data-type="xref" href="#exetoolong">Example 3-36</a>.</p>
<div id="exetoolong" data-type="example">
<h5><span class="label">Example 3-36. </span>The executor takes too long to finish</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># quickstart.py</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">time</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_running_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">run_in_executor</code><code class="p">(</code><code class="kc">None</code><code class="p">,</code><code> </code><code class="n">blocking</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">{</code><code class="s1">time.ctime()} Hello!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">1.0</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">{</code><code class="s1">time.ctime()} Goodbye!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>
</code><code class="k">def</code><code> </code><code class="nf">blocking</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">time</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">1.5</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO31-1" href="#callout_asyncio_walk_through_CO31-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s2">"</code><code class="s2">{</code><code class="s2">time.ctime()} Hello from a thread!</code><code class="s2">"</code><code class="p">)</code><code>
</code><code>
</code><code class="n">asyncio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO31-1" href="#co_asyncio_walk_through_CO31-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>This code sample is exactly the same as the one in <a data-type="xref" href="#quickstart-executor">Example 3-3</a>,
<em>except</em> that the sleep time in the blocking function is now longer than in the
async one.</p></dd>
</dl></div>

<p>Running this code produces the following output:</p>

<pre data-type="programlisting">$ python quickstart.py
Fri Jan 24 16:25:08 2020 Hello!
Fri Jan 24 16:25:09 2020 Goodbye!
exception calling callback for &lt;Future at [...snip...]&gt;
Traceback (most recent call last):

&lt;big nasty traceback&gt;

RuntimeError: Event loop is closed
Fri Jan 24 16:25:09 2020 Hello from a thread!</pre>

<p>What’s <a data-type="indexterm" data-primary="run_in_executor function" data-secondary="returning future and not creating a task" id="idm46363027851640"/><a data-type="indexterm" data-primary="futures" data-secondary="returned by run_in_executor function" id="idm46363027833640"/>happening here is that behind the scenes, <code>run_in_executor()</code>
does <em>not</em> create a <code>Task</code> instance: it returns a <code>Future</code>. That means
it isn’t included in the set of “active tasks” that get cancelled inside
<code>asyncio.run()</code>, and therefore <code>run_until_complete()</code> (called inside
<code>asyncio.run()</code>) does <em>not</em> wait for the executor task to finish. The
<span class="keep-together"><code>RuntimeError</code></span> is being raised from the internal <code>loop.close()</code> call made
inside <code>asyncio.run()</code>.<a data-type="indexterm" data-primary="asyncio.run function" data-secondary="not waiting for executor jobs to finish" id="idm46363027839080"/><a data-type="indexterm" data-primary="loop.close function" data-secondary="not waiting for executor jobs to finish" id="idm46363027831304"/></p>

<p>At the time of writing, <code>loop.close()</code> in
Python 3.8 does not wait for all executor jobs to finish, and this is
why the <code>Future</code> returned from <code>run_in_executor()</code> complains: by the time
it resolves, the loop has already been closed.
There are discussions about how to improve this in the core Python dev team,
but until a solution has been settled on, you’re going to need a strategy for handling these errors.</p>
<div data-type="tip"><h6>Tip</h6>
<p>In Python 3.9, the <code>asyncio.run()</code> function
<a href="https://oreil.ly/ZrpRb">has been improved</a> to correctly wait for
executor shutdown, but at the time of writing, this has not yet been
backported to Python 3.8.<a data-type="indexterm" data-primary="asyncio.run function" data-secondary="improvements in Python 3.9" id="idm46363027842936"/><a data-type="indexterm" data-primary="Python" data-secondary="asyncio.run function, improvement in Python 3.9" id="idm46363027845800"/></p>
</div>

<p>Several ideas for fixing this spring to mind, all with
different trade-offs, and we’re going to look at a few of them. My
real goal for this exercise is to help you think about the event loop
life cycle from different points of view, considering the lifetime
management of all the coroutines, threads, and subprocesses that
might be interoperating in a nontrivial program.</p>

<p>The first idea—and the easiest to implement, as shown in <a data-type="xref" href="#wrapexecoro">Example 3-37</a>—
is to always <code>await</code> an executor <a data-type="indexterm" data-primary="executors" data-secondary="waiting for during shutdown" data-tertiary="wrapping executor call in a coroutine" id="idm46363028092232"/><a data-type="indexterm" data-primary="await keyword" data-secondary="awaiting an executor task from inside a coroutine" id="idm46363028091016"/><a data-type="indexterm" data-primary="coroutines" data-secondary="wrapping executor call in" id="idm46363027978824"/>task from inside a coroutine.</p>
<div id="wrapexecoro" data-type="example">
<h5><span class="label">Example 3-37. </span>Option A: wrap the executor call inside a coroutine</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># quickstart.py</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">time</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="kn">from</code><code> </code><code class="nn">concurrent</code><code class="nn">.</code><code class="nn">futures</code><code> </code><code class="k">import</code><code> </code><code class="n">ThreadPoolExecutor</code><code> </code><code class="k">as</code><code> </code><code class="n">Executor</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_running_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="n">future</code><code> </code><code class="o">=</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">run_in_executor</code><code class="p">(</code><code class="kc">None</code><code class="p">,</code><code> </code><code class="n">blocking</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO32-1" href="#callout_asyncio_walk_through_CO32-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>    </code><code class="k">try</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">{</code><code class="s1">time.ctime()} Hello!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">1.0</code><code class="p">)</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">{</code><code class="s1">time.ctime()} Goodbye!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="k">finally</code><code class="p">:</code><code>
</code><code>        </code><code class="k">await</code><code> </code><code class="n">future</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO32-2" href="#callout_asyncio_walk_through_CO32-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>
</code><code class="k">def</code><code> </code><code class="nf">blocking</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">time</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">2.0</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s2">"</code><code class="s2">{</code><code class="s2">time.ctime()} Hello from a thread!</code><code class="s2">"</code><code class="p">)</code><code>
</code><code>
</code><code class="k">try</code><code class="p">:</code><code>
</code><code>    </code><code class="n">asyncio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="k">except</code><code> </code><code class="ne">KeyboardInterrupt</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Bye!</code><code class="s1">'</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO32-1" href="#co_asyncio_walk_through_CO32-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>The idea aims at fixing the shortcoming that <code>run_in_executor()</code> returns
only a <code>Future</code> instance and not a task. We can’t capture the job in
<code>all_tasks()</code> (used within <code>asyncio.run()</code>), but we <em>can</em> use <code>await</code> on the
future. The first part of the plan is to create a future inside the <code>main()</code>
function.<a data-type="indexterm" data-primary="futures" data-secondary="returned by run_in_executor function" data-tertiary="using await for" id="idm46363027609752"/></p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO32-2" href="#co_asyncio_walk_through_CO32-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>We can use the <code>try/finally</code> structure to ensure that we wait for the
future to be finished before the <code>main()</code> function returns.</p></dd>
</dl></div>

<p>The code works, but it places a heavy limitation on lifetime
management of the executor function: it implies that you must use
a <code>try/finally</code> within every single scope where an executor job is created.
We would prefer to spawn executor jobs in the same way that we create
async tasks, and still have the shutdown handling inside <code>asyncio.run()</code>
perform a graceful exit.</p>

<p>The next idea, shown in <a data-type="xref" href="#addfuturealltasks">Example 3-38</a>, is a little more cunning. Since
our problem is that an executor creates a future instead of a task, and the
shutdown handling inside <code>asyncio.run()</code> deals with tasks, our next plan is to
wrap the future (produced by the executor) inside a new task object.<a data-type="indexterm" data-primary="executors" data-secondary="waiting for during shutdown" data-tertiary="adding executor future to gathered tasks" id="idm46363027566664"/><a data-type="indexterm" data-primary="tasks" data-secondary="gathered, adding executor future to" id="idm46363027565576"/><a data-type="indexterm" data-primary="futures" data-secondary="adding executor future to gathered tasks" id="idm46363027564728"/></p>
<div id="addfuturealltasks" data-type="example">
<h5><span class="label">Example 3-38. </span>Option B: add the executor future to the gathered tasks</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># quickstart.py</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">time</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="kn">from</code><code> </code><code class="nn">concurrent</code><code class="nn">.</code><code class="nn">futures</code><code> </code><code class="k">import</code><code> </code><code class="n">ThreadPoolExecutor</code><code> </code><code class="k">as</code><code> </code><code class="n">Executor</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">make_coro</code><code class="p">(</code><code class="n">future</code><code class="p">)</code><code class="p">:</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO33-1" href="#callout_asyncio_walk_through_CO33-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>    </code><code class="k">try</code><code class="p">:</code><code>
</code><code>        </code><code class="k">return</code><code> </code><code class="k">await</code><code> </code><code class="n">future</code><code>
</code><code>    </code><code class="k">except</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">CancelledError</code><code class="p">:</code><code>
</code><code>        </code><code class="k">return</code><code> </code><code class="k">await</code><code> </code><code class="n">future</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_running_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="n">future</code><code> </code><code class="o">=</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">run_in_executor</code><code class="p">(</code><code class="kc">None</code><code class="p">,</code><code> </code><code class="n">blocking</code><code class="p">)</code><code>
</code><code>    </code><code class="n">asyncio</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">make_coro</code><code class="p">(</code><code class="n">future</code><code class="p">)</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO33-2" href="#callout_asyncio_walk_through_CO33-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">{</code><code class="s1">time.ctime()} Hello!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">1.0</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">{</code><code class="s1">time.ctime()} Goodbye!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>
</code><code class="k">def</code><code> </code><code class="nf">blocking</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">time</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">2.0</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s2">"</code><code class="s2">{</code><code class="s2">time.ctime()} Hello from a thread!</code><code class="s2">"</code><code class="p">)</code><code>
</code><code>
</code><code class="k">try</code><code class="p">:</code><code>
</code><code>    </code><code class="n">asyncio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="k">except</code><code> </code><code class="ne">KeyboardInterrupt</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Bye!</code><code class="s1">'</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO33-1" href="#co_asyncio_walk_through_CO33-2"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>We take the future returned from the <code>run_in_executor()</code> call and pass
it into a new utility function, <code>make_coro()</code>.<a data-type="indexterm" data-primary="make_coro utility function" id="idm46363027443800"/><a data-type="indexterm" data-primary="asyncio.create_task function" id="idm46363027443096"/><a data-type="indexterm" data-primary="asyncio.run function" data-secondary="all_tasks in shutdown" id="idm46363027520616"/> The important point here is
that we’re using <code>create_task()</code>, which means that this task <em>will</em> appear
in the list of <code>all_tasks()</code> within<a data-type="indexterm" data-primary="all_tasks function" id="idm46363027495080"/> the shutdown handling of <code>asyncio.run()</code>,
and will receive a cancellation during the shutdown process.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO33-2" href="#co_asyncio_walk_through_CO33-1"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>This utility function <code>make_coro()</code> simply waits for the future to
complete—but crucially, it <em>continues to wait</em> for the future even inside
the exception handler for <code>CancelledError</code>.</p></dd>
</dl></div>

<p>This solution is better behaved during shutdown, and I encourage you to
run the example and hit Ctrl-C immediately after “Hello!” is printed. The
shutdown process will still wait for <code>make_coro()</code> to exit, which means that
it also waits for our executor job to exit. However, this code is very clumsy
because you have to wrap every executor <code>Future</code> instance inside a
<code>make_coro()</code> call.</p>

<p>If we’re willing to give up the <a data-type="indexterm" data-primary="executors" data-secondary="waiting for during shutdown" data-tertiary="bringing your own loop and executor" id="idm46363027553544"/>convenience of the <code>asyncio.run()</code> function
(until Python 3.9 is available), we can do better with custom loop handling,
shown in <a data-type="xref" href="#customexewait">Example 3-39</a>.</p>
<div id="customexewait" data-type="example">
<h5><span class="label">Example 3-39. </span>Option C: just like camping, bring your own loop and your own executor</h5>

<pre data-type="programlisting" data-code-language="python3"><code class="c1"># quickstart.py</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">time</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">asyncio</code><code>
</code><code class="kn">from</code><code> </code><code class="nn">concurrent</code><code class="nn">.</code><code class="nn">futures</code><code> </code><code class="k">import</code><code> </code><code class="n">ThreadPoolExecutor</code><code> </code><code class="k">as</code><code> </code><code class="n">Executor</code><code>
</code><code>
</code><code class="k">async</code><code> </code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">{</code><code class="s1">time.ctime()} Hello!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="k">await</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">1.0</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s1">'</code><code class="s1">{</code><code class="s1">time.ctime()} Goodbye!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">stop</code><code class="p">(</code><code class="p">)</code><code>
</code><code>
</code><code class="k">def</code><code> </code><code class="nf">blocking</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">time</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mf">2.0</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">f</code><code class="s2">"</code><code class="s2">{</code><code class="s2">time.ctime()} Hello from a thread!</code><code class="s2">"</code><code class="p">)</code><code>
</code><code>
</code><code class="n">loop</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">get_event_loop</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">executor</code><code> </code><code class="o">=</code><code> </code><code class="n">Executor</code><code class="p">(</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO34-1" href="#callout_asyncio_walk_through_CO34-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="n">loop</code><code class="o">.</code><code class="n">set_default_executor</code><code class="p">(</code><code class="n">executor</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO34-2" href="#callout_asyncio_walk_through_CO34-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="n">loop</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="n">future</code><code> </code><code class="o">=</code><code> </code><code class="n">loop</code><code class="o">.</code><code class="n">run_in_executor</code><code class="p">(</code><code class="kc">None</code><code class="p">,</code><code> </code><code class="n">blocking</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO34-3" href="#callout_asyncio_walk_through_CO34-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="k">try</code><code class="p">:</code><code>
</code><code>    </code><code class="n">loop</code><code class="o">.</code><code class="n">run_forever</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="k">except</code><code> </code><code class="ne">KeyboardInterrupt</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Cancelled</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">tasks</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">all_tasks</code><code class="p">(</code><code class="n">loop</code><code class="o">=</code><code class="n">loop</code><code class="p">)</code><code>
</code><code class="k">for</code><code> </code><code class="n">t</code><code> </code><code class="ow">in</code><code> </code><code class="n">tasks</code><code class="p">:</code><code>
</code><code>    </code><code class="n">t</code><code class="o">.</code><code class="n">cancel</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">group</code><code> </code><code class="o">=</code><code> </code><code class="n">asyncio</code><code class="o">.</code><code class="n">gather</code><code class="p">(</code><code class="o">*</code><code class="n">tasks</code><code class="p">,</code><code> </code><code class="n">return_exceptions</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code>
</code><code class="n">loop</code><code class="o">.</code><code class="n">run_until_complete</code><code class="p">(</code><code class="n">group</code><code class="p">)</code><code>
</code><code class="n">executor</code><code class="o">.</code><code class="n">shutdown</code><code class="p">(</code><code class="n">wait</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code>  </code><a class="co" id="co_asyncio_walk_through_CO34-4" href="#callout_asyncio_walk_through_CO34-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code class="n">loop</code><code class="o">.</code><code class="n">close</code><code class="p">(</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asyncio_walk_through_CO34-1" href="#co_asyncio_walk_through_CO34-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>This time, we create our own executor instance.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO34-2" href="#co_asyncio_walk_through_CO34-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>We have to set our custom executor as the default one for the loop.
This means that anywhere the code calls <code>run_in_executor()</code>, it’ll be
using our custom instance.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO34-3" href="#co_asyncio_walk_through_CO34-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>As before, we run the blocking function.</p></dd>
<dt><a class="co" id="callout_asyncio_walk_through_CO34-4" href="#co_asyncio_walk_through_CO34-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>Finally, we can explicitly wait for all the executor jobs to finish
before closing the loop.<a data-type="indexterm" data-primary="loops" data-secondary="explicitly waiting for all executor jobs to finish before closing" id="idm46363027322328"/> This will avoid the “Event loop is closed” messages
that we saw before. We can do this because we have access to the
executor object; the default executor is not exposed in the <code>asyncio</code> API,
which is why we cannot call <code>shutdown()</code> on it and were forced to create our
own executor instance.</p></dd>
</dl></div>

<p>Finally, we have a strategy with general applicability: you can call
<code>run_in_executor()</code> anywhere, and your program will still shut down
cleanly, even if executor jobs are still running after all the async
tasks have completed.</p>

<p>I strongly urge you to experiment with the code examples shown here and
try different strategies to create tasks and executor jobs, staggering them
in time and trying to shut down cleanly. I expect that a future version of
Python will allow the <span class="keep-together"><code>asyncio.run()</code></span> function to wait (internally) for
executor jobs to finish, but I hope that the discussion in this section
is still useful for you to develop your thinking around clean
shutdown handling.<a data-type="indexterm" data-primary="shutdown, handling" data-startref="ix_shtdwn" id="idm46363027317720"/><a data-type="indexterm" data-primary="asyncio" data-secondary="starting up and shutting down gracefully" data-startref="ix_asystsh" id="idm46363027316776"/></p>
</div></section>





</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46363038714696"><sup><a href="ch03.html#idm46363038714696-marker">1</a></sup> When they become available! At the time of writing, the only available references for Asyncio were the API specification in the official Python documentation and a collection of blog posts, several of which have been linked to in this book.</p><p data-type="footnote" id="idm46363038459208"><sup><a href="ch03.html#idm46363038459208-marker">2</a></sup> The <code>asyncio</code> API lets you do lots of wild things with multiple loop instances and threads, but this is not the right book to get into that. 99% of the time you’re going to use only a single, main thread for your app, as shown here.</p><p data-type="footnote" id="idm46363038400376"><sup><a href="ch03.html#idm46363038400376-marker">3</a></sup> Using the parameter name <em><code>coro</code></em> is a common convention in the API documentation.<a data-type="indexterm" data-primary="coroutines" id="idm46363038399000"/><a data-type="indexterm" data-primary="coro (parameter name)" id="idm46363038398328"/> It refers to a <em>coroutine</em>; i.e., strictly speaking, the <em>result</em> of calling an <code>async def</code> function, and <em>not</em> the function itself.</p><p data-type="footnote" id="idm46363038125400"><sup><a href="ch03.html#idm46363038125400-marker">4</a></sup> Unfortunately, the first parameter of <code>run_in_executor()</code> is the <code>Executor</code> instance to use, and you <em>must</em> pass <code>None</code> in order to use the default. Every time I use this, it feels like the “executor” parameter is crying out to be a kwarg with a default value of <code>None</code>.</p><p data-type="footnote" id="idm46363037762200"><sup><a href="ch03.html#idm46363037762200-marker">5</a></sup> And furthermore, this is how other open source libraries such as Twisted and Tornado have exposed async support in the past.</p><p data-type="footnote" id="idm46363033404616"><sup><a href="ch03.html#idm46363033404616-marker">6</a></sup> Also acceptable is a legacy, generator-based coroutine, which is a generator function that is decorated with <code>@types.coroutine</code> and uses the <code>yield from</code> keyword internally to suspend. We are going to completely ignore legacy coroutines in this  book. Erase them from your mind!</p><p data-type="footnote" id="idm46363032184744"><sup><a href="ch03.html#idm46363032184744-marker">7</a></sup> The documentation is inconsistent here: the signature is given as <code>AbstractEventLoop.run_until_complete</code>(<em><code>future</code></em>), but it really should be <code>AbstractEventLoop.run_until_complete</code>(<em><code>coro_or_future</code></em>) as the same rules apply.</p><p data-type="footnote" id="idm46363031039256"><sup><a href="ch03.html#idm46363031039256-marker">8</a></sup> Async support can be quite difficult to add to an existing framework after the fact since large structural changes to the codebase might be needed. This was discussed in a <a href="https://oreil.ly/we5cZ">GitHub issue for <code>requests</code></a>.</p><p data-type="footnote" id="idm46363030900744"><sup><a href="ch03.html#idm46363030900744-marker">9</a></sup> Yes, this is super annoying. Every time I use this call, I can’t help wondering why the more common idiom of using <code>executor=None</code> as a keyword argument was not preferred.</p><p data-type="footnote" id="idm46363028180248"><sup><a href="ch03.html#idm46363028180248-marker">10</a></sup> <code>add_signal_handler()</code> should probably be named <code>set_signal_handler()</code>, since you can have only one handler per signal type; calling <code>add_signal_handler()</code> a second time for the same signal will replace the existing handler for that signal.</p></div></div></section></body></html>