["```py\n@ray.remote\nclass Account:\n    def __init__(self, balance: float, minimal_balance: float):\n        self.minimal = minimal_balance\n        if balance < minimal_balance:\n            raise Exception(\"Starting balance is less than minimal balance\")\n        self.balance = balance\n\n    def balance(self) -> float:\n        return self.balance\n\n    def deposit(self, amount: float) -> float:\n        if amount < 0:\n            raise Exception(\"Cannot deposit negative amount\")\n        self.balance = self.balance + amount\n        return self.balance\n\n    def withdraw(self, amount: float) -> float:\n        if amount < 0:\n            raise Exception(\"Cannot withdraw negative amount\")\n        balance = self.balance - amount\n        if balance < self.minimal:\n            raise Exception(\"Withdrawal is not supported by current balance\")\n        self.balance = balance\n        return balance\n```", "```py\naccount_actor = Account.remote(balance = 100.,minimal_balance=20.)\n```", "```py\nAccount = ray.remote(Account)\naccount_actor = Account.remote(balance = 100.,minimal_balance=20.)\n```", "```py\nprint(f\"Current balance {ray.get(account_actor.balance.remote())}\")\nprint(f\"New balance {ray.get(account_actor.withdraw.remote(40.))}\")\nprint(f\"New balance {ray.get(account_actor.deposit.remote(30.))}\")\n```", "```py\ntry:\n  result = ray.get(account_actor.withdraw.remote(-40.))\nexcept Exception as e:\n  print(f\"Oops! \\{e} occurred.\")\n```", "```py\naccount_actor = Account.options(name='Account')\\\n    .remote(balance = 100.,minimal_balance=20.)\n```", "```py\nray.get_actor('Account')\n```", "```py\naccount_actor = Account.options(name='Account', lifetime='detached')\\\n    .remote(balance = 100.,minimal_balance=20.)\n```", "```py\n@ray.remote\nclass Account:\n    def __init__(self, balance: float, minimal_balance: float, account_key: str,\n        basedir: str = '.'):\n        self.basedir = basedir\n        self.key = account_key\n        if not self.restorestate():\n            if balance < minimal_balance:\n                raise Exception(\"Starting balance is less than minimal balance\")\n            self.balance = balance\n            self.minimal = minimal_balance\n            self.storestate()\n\n    def balance(self) -> float:\n        return self.balance\n\n    def deposit(self, amount: float) -> float:\n        if amount < 0:\n            raise Exception(\"Cannot deposit negative amount\")\n        self.balance = self.balance + amount\n        self.storestate()\n        return self.balance\n\n    def withdraw(self, amount: float) -> float:\n        if amount < 0:\n            raise Exception(\"Cannot withdraw negative amount\")\n        balance = self.balance - amount\n        if balance < self.minimal:\n            raise Exception(\"Withdrawal is not supported by current balance\")\n        self.balance = balance\n        self.storestate()\n        return balance\n\n    def restorestate(self) -> bool:\n        if exists(self.basedir + '/' + self.key):\n            with open(self.basedir + '/' + self.key, \"rb\") as f:\n                bytes = f.read()\n            state = ray.cloudpickle.loads(bytes)\n            self.balance = state['balance']\n            self.minimal = state['minimal']\n            return True\n        else:\n            return False\n\n    def storestate(self):\n        bytes = ray.cloudpickle.dumps(\n            {'balance' : self.balance, 'minimal' : self.minimal})\n        with open(self.basedir + '/' + self.key, \"wb\") as f:\n            f.write(bytes)\n```", "```py\nclass BasePersitence:\n    def exists(self, key:str) -> bool:\n        pass\n    def save(self, key: str, data: dict):\n        pass\n    def restore(self, key:str) -> dict:\n        pass\n```", "```py\nclass FilePersistence(BasePersitence):\n    def __init__(self, basedir: str = '.'):\n        self.basedir = basedir\n\n    def exists(self, key:str) -> bool:\n        return exists(self.basedir + '/' + key)\n\n    def save(self, key: str, data: dict):\n        bytes = ray.cloudpickle.dumps(data)\n        with open(self.basedir + '/' + key, \"wb\") as f:\n            f.write(bytes)\n\n    def restore(self, key:str) -> dict:\n        if not self.exists(key):\n            return None\n        else:\n            with open(self.basedir + '/' + key, \"rb\") as f:\n                bytes = f.read()\n            return ray.cloudpickle.loads(bytes)\n```", "```py\n@ray.remote\nclass Account:\n    def __init__(self, balance: float, minimal_balance: float, account_key: str,\n                 persistence: BasePersitence):\n        self.persistence = persistence\n        self.key = account_key\n        if not self.restorestate():\n            if balance < minimal_balance:\n                raise Exception(\"Starting balance is less than minimal balance\")\n            self.balance = balance\n            self.minimal = minimal_balance\n            self.storestate()\n\n    def balance(self) -> float:\n        return self.balance\n\n    def deposit(self, amount: float) -> float:\n        if amount < 0:\n            raise Exception(\"Cannot deposit negative amount\")\n        self.balance = self.balance + amount\n        self.storestate()\n        return self.balance\n\n    def withdraw(self, amount: float) -> float:\n        if amount < 0:\n            raise Exception(\"Cannot withdraw negative amount\")\n        balance = self.balance - amount\n        if balance < self.minimal:\n            raise Exception(\"Withdrawal is not supported by current balance\")\n        self.balance = balance\n        self.storestate()\n        return balance\n\n    def restorestate(self) -> bool:\n        state = self.persistence.restore(self.key)\n        if state != None:\n            self.balance = state['balance']\n            self.minimal = state['minimal']\n            return True\n        else:\n            return False\n\n    def storestate(self):\n        self.persistence.save(self.key,\n                    {'balance' : self.balance, 'minimal' : self.minimal})\n```", "```py\npool = ActorPool([\n    FilePersistence.remote(), FilePersistence.remote(), FilePersistence.remote()])\n\n@ray.remote\nclass Account:\n    def __init__(self, balance: float, minimal_balance: float,\n            account_key: str, persistence: ActorPool):\n        self.persistence = persistence\n        self.key = account_key\n        if not self.restorestate():\n            if balance < minimal_balance:\n                raise Exception(\"Starting balance is less than minimal balance\")\n            self.balance = balance\n            self.minimal = minimal_balance\n            self.storestate()\n\n    def balance(self) -> float:\n        return self.balance\n\n    def deposit(self, amount: float) -> float:\n        if amount < 0:\n            raise Exception(\"Cannot deposit negative amount\")\n        self.balance = self.balance + amount\n        self.storestate()\n        return self.balance\n\n    def withdraw(self, amount: float) -> float:\n        if amount < 0:\n            raise Exception(\"Cannot withdraw negative amount\")\n        balance = self.balance - amount\n        if balance < self.minimal:\n            raise Exception(\"Withdrawal is not supported by current balance\")\n        self.balance = balance\n        self.storestate()\n        return balance\n\n    def restorestate(self) -> bool:\n        while(self.persistence.has_next()):\n            self.persistence.get_next()\n        self.persistence.submit(lambda a, v: a.restore.remote(v), self.key)\n        state = self.persistence.get_next()\n        if state != None:\n            print(f'Restoring state {state}')\n            self.balance = state['balance']\n            self.minimal = state['minimal']\n            return True\n        else:\n            return False\n\n    def storestate(self):\n        self.persistence.submit(\n            lambda a, v: a.save.remote(v),\n            (self.key,\n             {'balance' : self.balance, 'minimal' : self.minimal}))\n\naccount_actor = Account.options(name='Account').remote(\n    balance=100.,minimal_balance=20.,\n    account_key='1234567', persistence=pool)\n```", "```py\n@ray.remote\nclass AsyncActor:\n    async def computation(self, num):\n        print(f'Actor waiting for {num} sec')\n        for x in range(num):\n            await asyncio.sleep(1)\n            print(f'Actor slept for {x+1} sec')\n        return num\n```", "```py\nactor = AsyncActor.options(max_concurrency=5).remote()\n```", "```py\n@ray.remote\nclass ThreadedActor:\n  def computation(self, num):\n    print(f'Actor waiting for \\{num} sec')\n    for x in range(num):\n      sleep(1)\n      print(f'Actor slept for \\{x+1} sec')\n    return num\n\nactor = ThreadedActor.options(max_concurrency=3).remote()\n```"]