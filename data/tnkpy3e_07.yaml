- en: 5\. Conditionals and Recursion#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 条件语句与递归#
- en: 原文：[https://allendowney.github.io/ThinkPython/chap05.html](https://allendowney.github.io/ThinkPython/chap05.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://allendowney.github.io/ThinkPython/chap05.html](https://allendowney.github.io/ThinkPython/chap05.html)
- en: The main topic of this chapter is the `if` statement, which executes different
    code depending on the state of the program. And with the `if` statement we’ll
    be able to explore one of the most powerful ideas in computing, **recursion**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要主题是`if`语句，根据程序的状态执行不同的代码。通过`if`语句，我们将能够探索计算机科学中的一个强大概念——**递归**。
- en: 'But we’ll start with three new features: the modulus operator, boolean expressions,
    and logical operators.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们将从三个新特性开始：取模运算符、布尔表达式和逻辑运算符。
- en: 5.1\. Integer division and modulus[#](#integer-division-and-modulus "Link to
    this heading")
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1. 整数除法与取模[#](#integer-division-and-modulus "Link to this heading")
- en: 'Recall that the integer division operator, `//`, divides two numbers and rounds
    down to an integer. For example, suppose the run time of a movie is 105 minutes.
    You might want to know how long that is in hours. Conventional division returns
    a floating-point number:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，整数除法运算符`//`将两个数字相除并向下舍入为整数。例如，假设一部电影的放映时间是105分钟，你可能想知道这是多少小时。常规除法返回一个浮动数值：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But we don’t normally write hours with decimal points. Integer division returns
    the integer number of hours, rounding down:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们通常不写带小数点的小时数。整数除法返回整数小时数，并向下舍入：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To get the remainder, you could subtract off one hour in minutes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到余数，你可以用分钟形式减去一小时：
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Or you could use the **modulus operator**, `%`, which divides two numbers and
    returns the remainder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用**取模运算符**，`%`，它将两个数字相除并返回余数。
- en: '[PRE6]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The modulus operator is more useful than it might seem. For example, it can
    check whether one number is divisible by another – if `x % y` is zero, then `x`
    is divisible by `y`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 取模运算符比看起来更有用。例如，它可以检查一个数字是否能被另一个数字整除——如果`x % y`为零，那么`x`能被`y`整除。
- en: Also, it can extract the right-most digit or digits from a number. For example,
    `x % 10` yields the right-most digit of `x` (in base 10). Similarly, `x % 100`
    yields the last two digits.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，它还可以提取数字的最右边一位或几位。例如，`x % 10`返回`x`的最右一位数字（以十进制表示）。类似地，`x % 100`返回最后两位数字。
- en: '[PRE8]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, the modulus operator can do “clock arithmetic”. For example, if an
    event starts at 11 AM and lasts three hours, we can use the modulus operator to
    figure out what time it ends.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，取模运算符可以进行“钟表算术”。例如，如果一个事件从上午11点开始并持续三小时，我们可以使用取模运算符来计算它结束的时间。
- en: '[PRE12]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The event would end at 2 PM.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该事件将于下午2点结束。
- en: 5.2\. Boolean Expressions[#](#boolean-expressions "Link to this heading")
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2. 布尔表达式[#](#boolean-expressions "Link to this heading")
- en: 'A **boolean expression** is an expression that is either true or false. For
    example, the following expressions use the equals operator, `==`, which compares
    two values and produces `True` if they are equal and `False` otherwise:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔表达式**是一个值为真或假的表达式。例如，下面的表达式使用了等于运算符`==`，它比较两个值，如果它们相等则返回`True`，否则返回`False`：'
- en: '[PRE14]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A common error is to use a single equal sign (`=`) instead of a double equal
    sign (`==`). Remember that `=` assigns a value to a variable and `==` compares
    two values.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是使用单个等号（`=`）而不是双等号（`==`）。记住，`=`是将值赋给变量，而`==`是比较两个值。
- en: '[PRE18]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`True` and `False` are special values that belong to the type `bool`; they
    are not strings:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`True`和`False`是属于`bool`类型的特殊值；它们不是字符串：'
- en: '[PRE21]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `==` operator is one of the **relational operators**; the others are:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`运算符是**关系运算符**之一；其他的有：'
- en: '[PRE25]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 5.3\. Logical operators[#](#logical-operators "Link to this heading")
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3. 逻辑运算符[#](#logical-operators "Link to this heading")
- en: To combine boolean values into expressions, we can use **logical operators**.
    The most common are `and`, `or`, and `not`. The meaning of these operators is
    similar to their meaning in English. For example, the value of the following expression
    is `True` only if `x` is greater than `0` *and* less than `10`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要将布尔值组合成表达式，我们可以使用**逻辑运算符**。最常见的有`and`、`or`和`not`。这些运算符的意义与它们在英语中的含义相似。例如，下面的表达式的值为`True`，当且仅当`x`大于`0`
    *并且*小于`10`。
- en: '[PRE35]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following expression is `True` if *either or both* of the conditions is
    true, that is, if the number is divisible by 2 *or* 3:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*任一或两个*条件为真，下面的表达式的值为`True`，即如果数字能被2 *或* 3整除：
- en: '[PRE37]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, the `not` operator negates a boolean expression, so the following expression
    is `True` if `x > y` is `False`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`not`运算符否定一个布尔表达式，因此如果`x > y`为`False`，下面的表达式将是`True`。
- en: '[PRE39]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Strictly speaking, the operands of a logical operator should be boolean expressions,
    but Python is not very strict. Any nonzero number is interpreted as `True`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，逻辑运算符的操作数应该是布尔表达式，但 Python 并不严格。任何非零数字都会被解释为`True`：
- en: '[PRE41]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This flexibility can be useful, but there are some subtleties to it that can
    be confusing. You might want to avoid it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性可能很有用，但它有一些细节可能让人困惑。你可能会想避免使用它。
- en: 5.4\. if statements[#](#if-statements "Link to this heading")
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4\. if 语句[#](#if-statements "链接到该部分")
- en: 'In order to write useful programs, we almost always need the ability to check
    conditions and change the behavior of the program accordingly. **Conditional statements**
    give us this ability. The simplest form is the `if` statement:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写有用的程序，我们几乎总是需要能够检查条件，并根据条件改变程序的行为。**条件语句**赋予我们这个能力。最简单的形式是`if`语句：
- en: '[PRE43]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`if` is a Python keyword. `if` statements have the same structure as function
    definitions: a header followed by an indented statement or sequence of statements
    called a **block**.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`是 Python 的关键字。`if`语句的结构与函数定义相同：一个头部，后跟一个缩进的语句或语句序列，称为**块**。'
- en: The boolean expression after `if` is called the **condition**. If it is true,
    the statements in the indented block run. If not, they don’t.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`后面的布尔表达式称为**条件**。如果条件为真，缩进块中的语句会执行。如果条件为假，则不执行。'
- en: There is no limit to the number of statements that can appear in the block,
    but there has to be at least one. Occasionally, it is useful to have a block that
    does nothing – usually as a place keeper for code you haven’t written yet. In
    that case, you can use the `pass` statement, which does nothing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在块中可以包含任意数量的语句，但必须至少包含一个。有时，创建一个什么也不做的块是有用的——通常是作为你还未编写代码的占位符。在这种情况下，你可以使用`pass`语句，它什么也不做。
- en: '[PRE45]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The word `TODO` in a comment is a conventional reminder that there’s something
    you need to do later.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注释中的`TODO`字样是一个约定，提醒你稍后需要做某事。
- en: 5.5\. The `else` clause[#](#the-else-clause "Link to this heading")
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5\. `else`子句[#](#the-else-clause "链接到该部分")
- en: 'An `if` statement can have a second part, called an `else` clause. The syntax
    looks like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`if`语句可以有第二部分，称为`else`子句。语法如下：
- en: '[PRE46]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If the condition is true, the first indented statement runs; otherwise, the
    second indented statement runs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件为真，则执行第一个缩进的语句；否则，执行第二个缩进的语句。
- en: In this example, if `x` is even, the remainder when `x` is divided by `2` is
    `0`, so the condition is true and the program displays `x is even`. If `x` is
    odd, the remainder is `1`, so the condition is false, and the program displays
    `x is odd`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果`x`是偶数，那么`x`除以`2`的余数是`0`，所以条件为真，程序显示`x is even`。如果`x`是奇数，则余数是`1`，条件为假，程序显示`x
    is odd`。
- en: Since the condition must be true or false, exactly one of the alternatives will
    run. The alternatives are called **branches**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于条件必须为真或假，最终只有一个分支会被执行。分支被称为**分支**。
- en: 5.6\. Chained conditionals[#](#chained-conditionals "Link to this heading")
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6\. 链式条件语句[#](#chained-conditionals "链接到该部分")
- en: Sometimes there are more than two possibilities and we need more than two branches.
    One way to express a computation like that is a **chained conditional**, which
    includes an `elif` clause.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有时可能存在多于两个的可能性，需要更多的分支。表达这种计算的一种方式是**链式条件语句**，它包含一个`elif`子句。
- en: '[PRE48]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`elif` is an abbreviation of “else if”. There is no limit on the number of
    `elif` clauses. If there is an `else` clause, it has to be at the end, but there
    doesn’t have to be one.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif`是“else if”的缩写。`elif`子句的数量没有限制。如果有`else`子句，它必须位于最后，但不必存在。'
- en: Each condition is checked in order. If the first is false, the next is checked,
    and so on. If one of them is true, the corresponding branch runs and the `if`
    statement ends. Even if more than one condition is true, only the first true branch
    runs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个条件都会按顺序检查。如果第一个条件为假，则检查下一个，以此类推。如果其中一个条件为真，则执行相应的分支，`if`语句结束。即使有多个条件为真，也只有第一个为真的分支会执行。
- en: 5.7\. Nested Conditionals[#](#nested-conditionals "Link to this heading")
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7\. 嵌套条件语句[#](#nested-conditionals "链接到该部分")
- en: 'One conditional can also be nested within another. We could have written the
    example in the previous section like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个条件语句也可以嵌套在另一个条件语句中。我们可以像这样重新编写前一节中的例子：
- en: '[PRE50]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The outer `if` statement contains two branches. The first branch contains a
    simple statement. The second branch contains another `if` statement, which has
    two branches of its own. Those two branches are both simple statements, although
    they could have been conditional statements as well.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 外部的`if`语句包含了两个分支。第一个分支包含一个简单的语句。第二个分支包含另一个`if`语句，它有自己的两个分支。那两个分支都是简单语句，尽管它们也可以是条件语句。
- en: Although the indentation of the statements makes the structure apparent, **nested
    conditionals** can be difficult to read. I suggest you avoid them when you can.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管语句的缩进使得结构变得清晰，**嵌套条件语句**可能仍然难以阅读。我建议你尽量避免使用它们。
- en: Logical operators often provide a way to simplify nested conditional statements.
    Here’s an example with a nested conditional.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符通常提供了一种简化嵌套条件语句的方法。这里是一个包含嵌套条件的例子。
- en: '[PRE52]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `print` statement runs only if we make it past both conditionals, so we
    get the same effect with the `and` operator.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当我们通过了两个条件判断，`print`语句才会执行，因此我们可以通过`and`运算符获得相同的效果。
- en: '[PRE54]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For this kind of condition, Python provides a more concise option:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，Python提供了一种更简洁的选项：
- en: '[PRE56]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 5.8\. Recursion[#](#recursion "Link to this heading")
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.8\. 递归[#](#recursion "Link to this heading")
- en: It is legal for a function to call itself. It may not be obvious why that is
    a good thing, but it turns out to be one of the most magical things a program
    can do. Here’s an example.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数调用自身是合法的。虽然它为什么是个好事可能不那么显而易见，但事实证明，这是程序能够做的最神奇的事情之一。这里有一个例子。
- en: '[PRE58]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If `n` is 0 or negative, `countdown` outputs the word, “Blastoff!” Otherwise,
    it outputs `n` and then calls itself, passing `n-1` as an argument.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`n`为0或负数，`countdown`输出单词“Blastoff!”否则，它输出`n`，然后调用自身，传递`n-1`作为参数。
- en: Here’s what happens when we call this function with the argument `3`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当我们以参数`3`调用此函数时发生的情况。
- en: '[PRE59]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The execution of `countdown` begins with `n=3`, and since `n` is greater than
    `0`, it displays `3`, and then calls itself.…
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`countdown`的执行从`n=3`开始，由于`n`大于`0`，它显示`3`，然后调用自身。…'
- en: The execution of `countdown` begins with `n=2`, and since `n` is greater than
    `0`, it displays `2`, and then calls itself.…
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`countdown`的执行从`n=2`开始，由于`n`大于`0`，它显示`2`，然后调用自身。…'
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The execution of `countdown` begins with `n=1`, and since `n` is greater than
    `0`, it displays `1`, and then calls itself.…
  id: totrans-114
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`countdown`的执行从`n=1`开始，由于`n`大于`0`，它显示`1`，然后调用自身。…'
- en: ''
  id: totrans-115
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The execution of `countdown` begins with `n=0`, and since `n` is not greater
    than `0`, it displays “Blastoff!” and returns.
  id: totrans-116
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`countdown`的执行从`n=0`开始，由于`n`不大于`0`，它显示“Blastoff!”并返回。'
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `countdown` that got `n=1` returns.
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 得到`n=1`的`countdown`返回。
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `countdown` that got `n=2` returns.
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 得到`n=2`的`countdown`返回。
- en: The `countdown` that got `n=3` returns.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 得到`n=3`的`countdown`返回。
- en: A function that calls itself is **recursive**. As another example, we can write
    a function that prints a string `n` times.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个调用自身的函数是**递归的**。作为另一个例子，我们可以写一个函数，打印字符串`n`次。
- en: '[PRE61]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If `n` is positive, `print_n_times` displays the value of `string` and then
    calls itself, passing along `string` and `n-1` as arguments.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`n`为正数，`print_n_times`会显示`string`的值，然后调用自身，传递`string`和`n-1`作为参数。
- en: If `n` is `0` or negative, the condition is false and `print_n_times` does nothing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`n`为`0`或负数，条件为假，`print_n_times`什么也不做。
- en: Here’s how it works.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它的工作原理。
- en: '[PRE62]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: For simple examples like this, it is probably easier to use a `for` loop. But
    we will see examples later that are hard to write with a `for` loop and easy to
    write with recursion, so it is good to start early.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样的简单例子，可能使用`for`循环会更容易。但稍后我们会看到一些使用`for`循环很难编写而递归容易编写的例子，所以早点开始学习递归是有益的。
- en: 5.9\. Stack diagrams for recursive functions[#](#stack-diagrams-for-recursive-functions
    "Link to this heading")
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.9\. 递归函数的栈图[#](#stack-diagrams-for-recursive-functions "Link to this heading")
- en: Here’s a stack diagram that shows the frames created when we called `countdown`
    with `n = 3`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个栈图，展示了当我们用`n=3`调用`countdown`时创建的框架。
- en: '![_images/e6406e06456c8a30f02728ca9ab2416d72ded3e8d84449e77a93f601da23cedc.png](../Images/5dabd26c3a8ec6a56a8c98d2081490cb.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![_images/e6406e06456c8a30f02728ca9ab2416d72ded3e8d84449e77a93f601da23cedc.png](../Images/5dabd26c3a8ec6a56a8c98d2081490cb.png)'
- en: The four `countdown` frames have different values for the parameter `n`. The
    bottom of the stack, where `n=0`, is called the **base case**. It does not make
    a recursive call, so there are no more frames.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 四个`countdown`框架的参数`n`值各不相同。栈底部，即`n=0`的地方，称为**基准情况**。它不再做递归调用，因此没有更多的框架。
- en: 5.10\. Infinite recursion[#](#infinite-recursion "Link to this heading")
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.10\. 无限递归[#](#infinite-recursion "Link to this heading")
- en: If a recursion never reaches a base case, it goes on making recursive calls
    forever, and the program never terminates. This is known as **infinite recursion**,
    and it is generally not a good idea. Here’s a minimal function with an infinite
    recursion.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果递归永远无法到达基准情况，它将不断进行递归调用，程序也永远不会结束。这被称为**无限递归**，通常来说，这种情况是不推荐的。下面是一个包含无限递归的最小函数。
- en: '[PRE64]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Every time `recurse` is called, it calls itself, which creates another frame.
    In Python, there is a limit to the number of frames that can be on the stack at
    the same time. If a program exceeds the limit, it causes a runtime error.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`recurse`被调用时，它会调用自己，这样就会创建另一个栈帧。在 Python 中，栈上同时存在的栈帧数量是有限制的。如果程序超出了这个限制，就会导致运行时错误。
- en: '[PRE65]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The traceback indicates that there were almost 3000 frames on the stack when
    the error occurred.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 错误追踪信息显示，错误发生时栈上几乎有 3000 个栈帧。
- en: If you encounter an infinite recursion by accident, review your function to
    confirm that there is a base case that does not make a recursive call. And if
    there is a base case, check whether you are guaranteed to reach it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不小心遇到无限递归，检查你的函数，确认是否有一个不进行递归调用的基准情况。如果有基准情况，检查是否能够保证到达它。
- en: 5.11\. Keyboard input[#](#keyboard-input "Link to this heading")
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.11\. 键盘输入[#](#keyboard-input "Link to this heading")
- en: The programs we have written so far accept no input from the user. They just
    do the same thing every time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的程序没有接收任何来自用户的输入。它们每次都会做相同的事情。
- en: Python provides a built-in function called `input` that stops the program and
    waits for the user to type something. When the user presses *Return* or *Enter*,
    the program resumes and `input` returns what the user typed as a string.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了一个内置函数叫做`input`，它会暂停程序并等待用户输入。当用户按下*Return*或*Enter*键时，程序恢复执行，`input`会返回用户输入的内容作为字符串。
- en: '[PRE67]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Before getting input from the user, you might want to display a prompt telling
    the user what to type. `input` can take a prompt as an argument:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取用户输入之前，你可能想要显示一个提示，告诉用户应该输入什么。`input`可以接受一个提示作为参数：
- en: '[PRE68]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The sequence `\n` at the end of the prompt represents a **newline**, which is
    a special character that causes a line break – that way the user’s input appears
    below the prompt.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 提示末尾的序列`\n`表示**换行符**，它是一个特殊字符，导致换行——这样用户的输入就会显示在提示的下方。
- en: If you expect the user to type an integer, you can use the `int` function to
    convert the return value to `int`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你期望用户输入一个整数，可以使用`int`函数将返回值转换为`int`。
- en: '[PRE71]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: But if they type something that’s not an integer, you’ll get a runtime error.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果用户输入了非整数的内容，你将得到一个运行时错误。
- en: '[PRE74]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We will see how to handle this kind of error later.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面学习如何处理这种类型的错误。
- en: 5.12\. Debugging[#](#debugging "Link to this heading")
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.12\. 调试[#](#debugging "Link to this heading")
- en: 'When a syntax or runtime error occurs, the error message contains a lot of
    information, but it can be overwhelming. The most useful parts are usually:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现语法错误或运行时错误时，错误消息包含了大量信息，但可能会让人感到不知所措。通常最有用的部分是：
- en: What kind of error it was, and
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的类型是什么，以及
- en: Where it occurred.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误发生的位置。
- en: Syntax errors are usually easy to find, but there are a few gotchas. Errors
    related to spaces and tabs can be tricky because they are invisible and we are
    used to ignoring them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误通常很容易找到，但也有一些陷阱。与空格和制表符相关的错误可能会很棘手，因为它们是不可见的，而我们习惯于忽略它们。
- en: '[PRE76]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this example, the problem is that the second line is indented by one space.
    But the error message points to `y`, which is misleading. Error messages indicate
    where the problem was discovered, but the actual error might be earlier in the
    code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，问题在于第二行缩进了一个空格。但是错误信息指向了`y`，这很具有误导性。错误消息指示问题被发现的位置，但实际的错误可能出现在代码的更早部分。
- en: 'The same is true of runtime errors. For example, suppose you are trying to
    convert a ratio to decibels, like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时错误也有类似情况。例如，假设你尝试将一个比率转换为分贝，如下所示：
- en: '[PRE78]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The error message indicates line 5, but there is nothing wrong with that line.
    The problem is in line 4, which uses integer division instead of floating-point
    division – as a result, the value of `ratio` is `0`. When we call `math.log10`,
    we get a `ValueError` with the message `math domain error`, because `0` is not
    in the “domain” of valid arguments for `math.log10`, because the logarithm of
    `0` is undefined.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息显示的是第5行，但那一行没有问题。问题出在第4行，那里使用了整数除法而不是浮点数除法——结果是`ratio`的值为`0`。当我们调用`math.log10`时，会得到一个`ValueError`，错误信息为`math
    domain error`，因为`0`不在`math.log10`的有效参数“域”内，因为`0`的对数是未定义的。
- en: In general, you should take the time to read error messages carefully, but don’t
    assume that everything they say is correct.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你应该花时间仔细阅读错误信息，但不要假设它们说的每句话都是正确的。
- en: 5.13\. Glossary[#](#glossary "Link to this heading")
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.13\. 词汇表[#](#glossary "Link to this heading")
- en: '**recursion:** The process of calling the function that is currently executing.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归：** 调用当前正在执行的函数的过程。'
- en: '**modulus operator:** An operator, `%`, that works on integers and returns
    the remainder when one number is divided by another.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**取模运算符：** 一个运算符`%`，用于整数，并返回一个数字除以另一个数字后的余数。'
- en: '**boolean expression:** An expression whose value is either `True` or `False`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔表达式：** 其值为`True`或`False`的表达式。'
- en: '**relational operator:** One of the operators that compares its operands: `==`,
    `!=`, `>`, `<`, `>=`, and `<=`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系运算符：** 用于比较操作数的运算符：`==`、`!=`、`>`、`<`、`>=`和`<=`。'
- en: '**logical operator:** One of the operators that combines boolean expressions,
    including `and`, `or`, and `not`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑运算符：** 用于组合布尔表达式的运算符，包括`and`、`or`和`not`。'
- en: '**conditional statement:** A statement that controls the flow of execution
    depending on some condition.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件语句：** 根据某些条件控制执行流程的语句。'
- en: '**condition:** The boolean expression in a conditional statement that determines
    which branch runs.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件：** 条件语句中的布尔表达式，决定执行哪个分支。'
- en: '**block:** One or more statements indented to indicate they are part of another
    statement.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码块：** 一个或多个缩进的语句，表示它们是另一个语句的一部分。'
- en: '**branch:** One of the alternative sequences of statements in a conditional
    statement.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**分支：** 条件语句中的一个替代执行语句序列。'
- en: '**chained conditional:** A conditional statement with a series of alternative
    branches.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**链式条件：** 具有一系列替代分支的条件语句。'
- en: '**nested conditional:** A conditional statement that appears in one of the
    branches of another conditional statement.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌套条件：** 出现在另一个条件语句分支中的条件语句。'
- en: '**recursive:** A function that calls itself is recursive.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归：** 调用自身的函数就是递归的。'
- en: '**base case:** A conditional branch in a recursive function that does not make
    a recursive call.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本情况：** 递归函数中的一个条件分支，不进行递归调用。'
- en: '**infinite recursion:** A recursion that doesn’t have a base case, or never
    reaches it. Eventually, an infinite recursion causes a runtime error.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**无限递归：** 没有基本情况或永远达不到基本情况的递归。最终，无限递归会导致运行时错误。'
- en: '**newline:** A character that creates a line break between two parts of a string.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**换行符：** 在字符串的两个部分之间创建换行的字符。'
- en: 5.14\. Exercises[#](#exercises "Link to this heading")
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.14\. 练习[#](#exercises "Link to this heading")
- en: '[PRE80]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 5.14.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this heading")
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.14.1\. 向虚拟助手提问[#](#ask-a-virtual-assistant "Link to this heading")
- en: Ask a virtual assistant, “What are some uses of the modulus operator?”
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向虚拟助手询问：“取模运算符有什么用途？”
- en: Python provides operators to compute the logical operations `and`, `or`, and
    `not`, but it doesn’t have an operator that computes the exclusive `or` operation,
    usually written `xor`. Ask an assistant “What is the logical xor operation and
    how do I compute it in Python?”
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python提供了运算符来计算逻辑操作`and`、`or`和`not`，但它没有计算排他性`or`操作的运算符，通常写作`xor`。向助手询问：“什么是逻辑`xor`操作，我如何在Python中计算它？”
- en: In this chapter, we saw two ways to write an `if` statement with three branches,
    using a chained conditional or a nested conditional. You can use a virtual assistant
    to convert from one to the other. For example, ask a VA, “Convert this statement
    to a chained conditional.”
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了两种写三分支`if`语句的方法，使用链式条件或嵌套条件。你可以使用虚拟助手将它们相互转换。例如，问虚拟助手：“将这条语句转换为链式条件。”
- en: '[PRE82]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Ask a VA, “Rewrite this statement with a single conditional.”
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 向虚拟助手询问：“用一个条件重写这条语句。”
- en: '[PRE84]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: See if a VA can simplify this unnecessary complexity.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 看看虚拟助手是否能简化这个不必要的复杂性。
- en: '[PRE86]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here’s an attempt at a recursive function that counts down by two.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个尝试递归的函数，它以2为步长倒数。
- en: '[PRE88]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: It seems to work.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来它能正常工作。
- en: '[PRE89]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: But it has an error. Ask a virtual assistant what’s wrong and how to fix it.
    Paste the solution it provides back here and test it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但它有一个错误。询问虚拟助手问题出在哪里，以及如何修复它。将它提供的解决方案粘贴回来并进行测试。
- en: 5.14.2\. Exercise[#](#exercise "Link to this heading")
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.14.2\. 练习[#](#exercise "链接到此标题")
- en: The `time` module provides a function, also called `time`, that returns returns
    the number of seconds since the “Unix epoch”, which is January 1, 1970, 00:00:00
    UTC (Coordinated Universal Time).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`模块提供了一个名为`time`的函数，它返回自“Unix纪元”（1970年1月1日00:00:00 UTC协调世界时）以来的秒数。'
- en: '[PRE91]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Use integer division and the modulus operator to compute the number of days
    since January 1, 1970 and the current time of day in hours, minutes, and seconds.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用整数除法和取模运算符来计算自1970年1月1日以来的天数，并且计算当前的时、分、秒。
- en: You can read more about the `time` module at [https://docs.python.org/3/library/time.html](https://docs.python.org/3/library/time.html).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.python.org/3/library/time.html](https://docs.python.org/3/library/time.html)上阅读更多关于`time`模块的信息。
- en: 5.14.3\. Exercise[#](#id1 "Link to this heading")
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.14.3\. 练习[#](#id1 "链接到此标题")
- en: 'If you are given three sticks, you may or may not be able to arrange them in
    a triangle. For example, if one of the sticks is 12 inches long and the other
    two are one inch long, you will not be able to get the short sticks to meet in
    the middle. For any three lengths, there is a test to see if it is possible to
    form a triangle:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给定了三根棍子，你可能无法将它们排列成三角形。例如，如果其中一根棍子长12英寸，而其他两根棍子长1英寸，你就无法让短棍在中间相遇。对于任何三条边，都有一个测试来判断是否可以形成三角形：
- en: If any of the three lengths is greater than the sum of the other two, then you
    cannot form a triangle. Otherwise, you can. (If the sum of two lengths equals
    the third, they form what is called a “degenerate” triangle.)
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果三条边中的任何一条大于其他两条边的和，那么就不能形成三角形。否则，可以形成三角形。（如果两条边的和等于第三条边，它们就形成了所谓的“退化”三角形。）
- en: 'Write a function named `is_triangle` that takes three integers as arguments,
    and that prints either “Yes” or “No”, depending on whether you can or cannot form
    a triangle from sticks with the given lengths. Hint: Use a chained conditional.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`is_triangle`的函数，接受三个整数作为参数，并根据是否能够从给定长度的棍子中形成三角形，打印“是”或“否”。提示：使用链式条件。
- en: 5.14.4\. Exercise[#](#id2 "Link to this heading")
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.14.4\. 练习[#](#id2 "链接到此标题")
- en: What is the output of the following program? Draw a stack diagram that shows
    the state of the program when it prints the result.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序的输出是什么？绘制一个堆栈图，展示程序打印结果时的状态。
- en: '[PRE93]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 5.14.5\. Exercise[#](#id3 "Link to this heading")
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.14.5\. 练习[#](#id3 "链接到此标题")
- en: The following exercises use the `jupyturtle` module, described in Chapter 4.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习使用了第4章中描述的`jupyturtle`模块。
- en: Read the following function and see if you can figure out what it does. Then
    run it and see if you got it right. Adjust the values of `length`, `angle` and
    `factor` and see what effect they have on the result. If you are not sure you
    understand how it works, try asking a virtual assistant.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读以下函数，看看你能否弄清楚它的作用。然后运行它，看看你是否理解正确。调整`length`、`angle`和`factor`的值，观察它们对结果的影响。如果你不确定自己理解其工作原理，可以尝试问一个虚拟助手。
- en: '[PRE95]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 5.14.6\. Exercise[#](#id4 "Link to this heading")
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.14.6\. 练习[#](#id4 "链接到此标题")
- en: Ask a virtual assistant “What is the Koch curve?”
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 问虚拟助手：“什么是科赫曲线？”
- en: To draw a Koch curve with length `x`, all you have to do is
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要画一个长度为`x`的科赫曲线，你只需要
- en: Draw a Koch curve with length `x/3`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 画一个长度为`x/3`的科赫曲线。
- en: Turn left 60 degrees.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向左转60度。
- en: Draw a Koch curve with length `x/3`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 画一个长度为`x/3`的科赫曲线。
- en: Turn right 120 degrees.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向右转120度。
- en: Draw a Koch curve with length `x/3`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 画一个长度为`x/3`的科赫曲线。
- en: Turn left 60 degrees.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向左转60度。
- en: Draw a Koch curve with length `x/3`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 画一个长度为`x/3`的科赫曲线。
- en: The exception is if `x` is less than `5` – in that case, you can just draw a
    straight line with length `x`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 例外情况是如果`x`小于`5`——在这种情况下，你可以直接画一条长度为`x`的直线。
- en: Write a function called `koch` that takes `x` as an argument and draws a Koch
    curve with the given length.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`koch`的函数，接受`x`作为参数，并绘制给定长度的科赫曲线。
- en: 'The result should look like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应如下所示：
- en: '[PRE96]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 5.14.7\. Exercise[#](#id5 "Link to this heading")
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.14.7\. 练习[#](#id5 "链接到此标题")
- en: Virtual assistants know about the functions in the `jupyturtle` module, but
    there are many versions of these functions, with different names, so a VA might
    not know which one you are talking about.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟助理知道`jupyturtle`模块中的功能，但这些功能有许多版本，名称不同，因此助理可能不知道你在谈论哪个版本。
- en: To solve this problem, you can provide additional information before you ask
    a question. For example, you could start a prompt with “Here’s a program that
    uses the `jupyturtle` module,” and then paste in one of the examples from this
    chapter. After that, the VA should be able to generate code that uses this module.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是，在提问之前，你可以提供额外的信息。例如，你可以以“这是一个使用`jupyturtle`模块的程序”开头，然后粘贴本章节中的一个示例。之后，助理应该能够生成使用此模块的代码。
- en: As an example, ask a VA for a program that draws a Sierpiński triangle. The
    code you get should be a good starting place, but you might have to do some debugging.
    If the first attempt doesn’t work, you can tell the VA what happened and ask for
    help – or you can debug it yourself.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，向助理询问绘制谢尔宾斯基三角形的程序。你得到的代码应该是一个很好的起点，但你可能需要进行一些调试。如果第一次尝试不起作用，你可以告诉助理发生了什么，并请求帮助，或者自行调试。
- en: Here’s what the result might look like, although the version you get might be
    different.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果的大致样子，尽管你得到的版本可能会有所不同。
- en: '[PRE97]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[《Think Python：第三版》](https://allendowney.github.io/ThinkPython/index.html)'
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 版权 2024 [Allen B. Downey](https://allendowney.com)
- en: 'Code license: [MIT License](https://mit-license.org/)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 代码许可：[MIT 许可证](https://mit-license.org/)
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 文本许可：[知识共享署名-非商业性使用-相同方式共享 4.0 国际](https://creativecommons.org/licenses/by-nc-sa/4.0/)
