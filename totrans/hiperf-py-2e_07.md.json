["```py\nv = -1.0\nprint(type(v), abs(v))\n```", "```py\n<class 'float'> 1.0\n```", "```py\nv = 1-1j\nprint(type(v), abs(v))\n```", "```py\n<class 'complex'> 1.4142135623730951\n```", "```py\ndef calculate_z_serial_purepython(maxiter, zs, cs):\n    \"\"\"Calculate output list using Julia update rule\"\"\"\n    output = [0] * len(zs)\n    for i in range(len(zs)):\n        n = 0\n        z = zs[i]\n        c = cs[i]\n        while n < maxiter and abs(z) < 2:\n            z = z * z + c\n            n += 1\n        output[i] = n\n    return output\n```", "```py\n...\nimport cythonfn  # as defined in setup.py\n...\ndef calc_pure_python(desired_width, max_iterations):\n    # ...\n    start_time = time.time()\n    output = cythonfn.calculate_z(max_iterations, zs, cs)\n    end_time = time.time()\n    secs = end_time - start_time\n    print(f\"Took {secs:0.2f} seconds\")\n...\n```", "```py\n# cythonfn.pyx\ndef calculate_z(maxiter, zs, cs):\n    \"\"\"Calculate output list using Julia update rule\"\"\"\n    output = [0] * len(zs)\n    for i in range(len(zs)):\n        n = 0\n        z = zs[i]\n        c = cs[i]\n        while n < maxiter and abs(z) < 2:\n            z = z * z + c\n            n += 1\n        output[i] = n\n    return output\n```", "```py\nfrom distutils.core import setup\nfrom Cython.Build import cythonize\n\nsetup(ext_modules=cythonize(\"cythonfn.pyx\",\n                            compiler_directives={\"language_level\": \"3\"}))\n```", "```py\n$ python setup.py build_ext --inplace\nCompiling cythonfn.pyx because it changed.\n[1/1] Cythonizing cythonfn.pyx\nrunning build_ext\nbuilding 'cythonfn' extension\ngcc -pthread -B /home/ian/miniconda3/envs/high_performance_python_book_2e/...\ngcc -pthread -shared -B /home/ian/miniconda3/envs/high_performance_python_...\n\n```", "```py\nimport pyximport\npyximport.install(language_level=3)\nimport cythonfn\n# followed by the usual code\n```", "```py\ndef calculate_z(int maxiter, zs, cs):\n    \"\"\"Calculate output list using Julia update rule\"\"\"\n    cdef unsigned int i, n\n    cdef double complex z, c\n    output = [0] * len(zs)\n    for i in range(len(zs)):\n        n = 0\n        z = zs[i]\n        c = cs[i]\n        while n < maxiter and abs(z) < 2:\n            z = z * z + c\n            n += 1\n        output[i] = n\n    return output\n```", "```py\ndef calculate_z(int maxiter, zs, cs):\n    \"\"\"Calculate output list using Julia update rule\"\"\"\n    cdef unsigned int i, n\n    cdef double complex z, c\n    output = [0] * len(zs)\n    for i in range(len(zs)):\n        n = 0\n        z = zs[i]\n        c = cs[i]\n        while n < maxiter and (z.real * z.real + z.imag * z.imag) < 4:\n            z = z * z + c\n            n += 1\n        output[i] = n\n    return output\n```", "```py\n#cython: boundscheck=False\ndef calculate_z(int maxiter, zs, cs):\n```", "```py\n# cythonfn.pyx\nimport numpy as np\ncimport numpy as np\n\ndef calculate_z(int maxiter, double complex[:] zs, double complex[:] cs):\n    \"\"\"Calculate output list using Julia update rule\"\"\"\n    cdef unsigned int i, n\n    cdef double complex z, c\n    cdef int[:] output = np.empty(len(zs), dtype=np.int32)\n    for i in range(len(zs)):\n        n = 0\n        z = zs[i]\n        c = cs[i]\n        while n < maxiter and (z.real * z.real + z.imag * z.imag) < 4:\n            z = z * z + c\n            n += 1\n        output[i] = n\n    return output\n```", "```py\n# cythonfn.pyx\nfrom cython.parallel import prange\nimport numpy as np\ncimport numpy as np\n\ndef calculate_z(int maxiter, double complex[:] zs, double complex[:] cs):\n    \"\"\"Calculate output list using Julia update rule\"\"\"\n    cdef unsigned int i, length\n    cdef double complex z, c\n    cdef int[:] output = np.empty(len(zs), dtype=np.int32)\n    length = len(zs)\n    with nogil:\n        for i in prange(length, schedule=\"guided\"):\n            z = zs[i]\n            c = cs[i]\n            output[i] = 0\n            while output[i] < maxiter and (z.real * z.real + z.imag * z.imag) < 4:\n                z = z * z + c\n                output[i] += 1\n    return output\n```", "```py\n#setup.py\nfrom distutils.core import setup\nfrom distutils.extension import Extension\nimport numpy as np\n\next_modules = [Extension(\"cythonfn\",\n                         [\"cythonfn.pyx\"],\n                         extra_compile_args=['-fopenmp'],\n                         extra_link_args=['-fopenmp'])]\n\nfrom Cython.Build import cythonize\nsetup(ext_modules=cythonize(ext_modules,\n                            compiler_directives={\"language_level\": \"3\"},),\n      include_dirs=[np.get_include()])\n```", "```py\nfrom numba import jit\n...\n@jit()\ndef calculate_z_serial_purepython(maxiter, zs, cs, output):\n```", "```py\n@jit(nopython=False, parallel=True)\ndef calculate_z(maxiter, zs, cs, output):\n    \"\"\"Calculate output list using Julia update rule\"\"\"\n    for i in prange(len(zs)):\n        n = 0\n        z = zs[i]\n        c = cs[i]\n        while n < maxiter and (z.real*z.real + z.imag*z.imag) < 4:\n            z = z * z + c\n            n += 1\n        output[i] = n\n```", "```py\nprint(calculate_z.inspect_types())\n# calculate_z (int64, array(complex128, 1d, C),\n               array(complex128, 1d, C), array(int32, 1d, C))\n```", "```py\n...\ndef calculate_z(maxiter, zs, cs, output):\n\n    # --- LINE 14 ---\n\n    \"\"\"Calculate output list using Julia update rule\"\"\"\n\n    # --- LINE 15 ---\n    #   maxiter = arg(0, name=maxiter)  :: int64\n    #   zs = arg(1, name=zs)  :: array(complex128, 1d, C)\n    #   cs = arg(2, name=cs)  :: array(complex128, 1d, C)\n    #   output = arg(3, name=output)  :: array(int32, 1d, C)\n    #   jump 2\n    # label 2\n    #   $2.1 = global(range: <class 'range'>)  :: Function(<class 'range'>)\n...\n```", "```py\ndef ols_lstsq_raw(row):\n    \"\"\"Variant of `ols_lstsq` where row is a numpy array (not a Series)\"\"\"\n    X = np.arange(row.shape[0])\n    ones = np.ones(row.shape[0])\n    A = np.vstack((X, ones)).T\n    m, c = np.linalg.lstsq(A, row, rcond=-1)[0]\n    return m\n\n# generate a Numba compiled variant\nols_lstsq_raw_values_numba = jit(ols_lstsq_raw, nopython=True)\n\nresults = df.apply(ols_lstsq_raw_values_numba, axis=1, raw=True)\n```", "```py\n...\n$ pypy3\nPython 3.6.1 (784b254d6699, Apr 14 2019, 10:22:42)\n[PyPy 7.1.1-beta0 with GCC 6.2.0 20160901] on linux\nType \"help\", \"copyright\", \"credits\", or \"license\" for more information.\nAnd now for something completely different\n...\n```", "```py\n...\n$ pypy3 -m ensurepip\nCollecting setuptools\nCollecting pip\nInstalling collected packages: setuptools, pip\nSuccessfully installed pip-9.0.1 setuptools-28.8.0\n\n$ pip3 install ipython\nCollecting ipython\n\n$ ipython\nPython 3.6.1 (784b254d6699, Apr 14 2019, 10:22:42)\nType 'copyright', 'credits', or 'license' for more information\nIPython 7.8.0 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: %run julia1_nopil_expanded_math.py\nLength of x: 1000\nTotal elements: 1000000\ncalculate_z_serial_purepython took 0.2143106460571289 seconds\nLength of x: 1000\nTotal elements: 1000000\ncalculate_z_serial_purepython took 0.1965022087097168 seconds\n...\n```", "```py\nimport torch\nfrom torch import (roll, zeros)  ![1](Images/1.png)\n\ngrid_shape = (640, 640)\n\ndef laplacian(grid):\n    return (\n        roll(grid, +1, 0)\n        + roll(grid, -1, 0)\n        + roll(grid, +1, 1)\n        + roll(grid, -1, 1)\n        - 4 * grid\n    )\n\ndef evolve(grid, dt, D=1):\n    return grid + dt * D * laplacian(grid)\n\ndef run_experiment(num_iterations):\n    grid = zeros(grid_shape)\n\n    block_low = int(grid_shape[0] * 0.4)\n    block_high = int(grid_shape[0] * 0.5)\n    grid[block_low:block_high, block_low:block_high] = 0.005\n\n    grid = grid.cuda()  ![2](Images/2.png)\n    for i in range(num_iterations):\n        grid = evolve(grid, 0.1)\n    return grid\n```", "```py\n$ nvidia-smi\n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 440.44       Driver Version: 440.44       CUDA Version: 10.2     |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |\n|===============================+======================+======================|\n|   0  GeForce RTX 208...  Off  | 00000000:06:00.0 Off |                  N/A |\n| 30%   58C    P2    96W / 260W |   1200MiB / 11018MiB |     95%      Default |\n+-------------------------------+----------------------+----------------------+\n\n+-----------------------------------------------------------------------------+\n| Processes:                                                       GPU Memory |\n|  GPU       PID   Type   Process name                             Usage      |\n|=============================================================================|\n|    0     26329      C   .../.pyenv/versions/3.7.2/bin/python        1189MiB |\n+-----------------------------------------------------------------------------+\n```", "```py\n    grid = grid.to(device)\n    for i in range(num_iterations):\n        grid = evolve(grid, 0.1)\n        grid.cpu()\n```", "```py\nimport torch\n\ndef task(A, target):\n    \"\"\"\n Given an int array of length N with values from (0, N] and a target value,\n iterates through the array, using the current value to find the next array\n item to look at, until we have seen a total value of at least `target`.\n Returns how many iterations until the value was reached.\n \"\"\"\n    result = 0\n    i = 0\n    N = 0\n    while result < target:\n        r = A[i]\n        result += r\n        i = A[i]\n        N += 1\n    return N\n\nif __name__ == \"__main__\":\n    N = 1000\n\n    A_py = (torch.rand(N) * N).type(torch.int).to('cuda:0')\n    A_np = A_py.cpu().numpy()\n\n    task(A_py, 500)\n    task(A_np, 500)\n```", "```py\nvoid evolve(double in[][512], double out[][512], double D, double dt) {\n    int i, j;\n    double laplacian;\n    for (i=1; i<511; i++) {\n        for (j=1; j<511; j++) {\n            laplacian = in[i+1][j] + in[i-1][j] + in[i][j+1] + in[i][j-1] \\\n                        - 4 * in[i][j];\n            out[i][j] = in[i][j] + D * dt * laplacian;\n        }\n    }\n}\n```", "```py\n$ gcc -O3 -std=gnu11 -c diffusion.c\n$ gcc -shared -o diffusion.so diffusion.o\n```", "```py\nimport ctypes\n\ngrid_shape = (512, 512)\n_diffusion = ctypes.CDLL(\"diffusion.so\")  ![1](Images/1.png)\n\n# Create references to the C types that we will need to simplify future code\nTYPE_INT = ctypes.c_int\nTYPE_DOUBLE = ctypes.c_double\nTYPE_DOUBLE_SS = ctypes.POINTER(ctypes.POINTER(ctypes.c_double))\n\n# Initialize the signature of the evolve function to:\n# void evolve(int, int, double**, double**, double, double)\n_diffusion.evolve.argtypes = [TYPE_DOUBLE_SS, TYPE_DOUBLE_SS, TYPE_DOUBLE,\n                              TYPE_DOUBLE]\n_diffusion.evolve.restype = None\n\ndef evolve(grid, out, dt, D=1.0):\n    # First we convert the Python types into the relevant C types\n    assert grid.shape == (512, 512)\n    cdt = TYPE_DOUBLE(dt)\n    cD = TYPE_DOUBLE(D)\n    pointer_grid = grid.ctypes.data_as(TYPE_DOUBLE_SS)  ![2](Images/2.png)\n    pointer_out = out.ctypes.data_as(TYPE_DOUBLE_SS)\n\n    # Now we can call the function\n    _diffusion.evolve(pointer_grid, pointer_out, cD, cdt)  ![3](Images/3.png)\n```", "```py\nfrom ctypes import Structure\n\nclass cPoint(Structure):\n    _fields_ = (\"x\", c_int), (\"y\", c_int)\n```", "```py\nfrom cffi import FFI, verifier\n\ngrid_shape = (512, 512)\n\nffi = FFI()\nffi.cdef(\n    \"void evolve(double **in, double **out, double D, double dt);\"  ![1](Images/1.png)\n)\nlib = ffi.dlopen(\"../diffusion.so\")\n\ndef evolve(grid, dt, out, D=1.0):\n    pointer_grid = ffi.cast(\"double**\", grid.ctypes.data)  ![2](Images/2.png)\n    pointer_out = ffi.cast(\"double**\", out.ctypes.data)\n    lib.evolve(pointer_grid, pointer_out, D, dt)\n```", "```py\nffi = FFI()\nffi.cdef(\n    \"void evolve(double **in, double **out, double D, double dt);\"\n)\nlib = ffi.verify(\n    r\"\"\"\nvoid evolve(double in[][512], double out[][512], double D, double dt) {\n    int i, j;\n    double laplacian;\n    for (i=1; i<511; i++) {\n        for (j=1; j<511; j++) {\n            laplacian = in[i+1][j] + in[i-1][j] + in[i][j+1] + in[i][j-1] \\\n                        - 4 * in[i][j];\n            out[i][j] = in[i][j] + D * dt * laplacian;\n        }\n    }\n}\n\"\"\",\n    extra_compile_args=[\"-O3\"],  ![1](Images/1.png)\n)\n```", "```py\nstruct Point {\n    double x;\n    double y;\n    bool isActive;\n    char *id;\n    int num_times_visited;\n}\n```", "```py\nfrom cffi import FFI\n\nffi = FFI()\nffi.cdef(r\"\"\"\n struct Point {\n double x;\n double y;\n ...;\n };\n struct Point do_calculation();\n\"\"\")\nlib = ffi.verify(r\"\"\"\n #include <complicated.h>\n\"\"\")\n```", "```py\nSUBROUTINE evolve(grid, next_grid, D, dt, N, M)\n    !f2py threadsafe\n    !f2py intent(in) grid\n    !f2py intent(inplace) next_grid\n    !f2py intent(in) D\n    !f2py intent(in) dt\n    !f2py intent(hide) N\n    !f2py intent(hide) M\n    INTEGER :: N, M\n    DOUBLE PRECISION, DIMENSION(N,M) :: grid, next_grid\n    DOUBLE PRECISION, DIMENSION(N-2, M-2) :: laplacian\n    DOUBLE PRECISION :: D, dt\n\n    laplacian = grid(3:N, 2:M-1) + grid(1:N-2, 2:M-1) + &\n                grid(2:N-1, 3:M) + grid(2:N-1, 1:M-2) - 4 * grid(2:N-1, 2:M-1)\n    next_grid(2:N-1, 2:M-1) = grid(2:N-1, 2:M-1) + D * dt * laplacian\nEND SUBROUTINE evolve\n```", "```py\n$ f2py -c -m diffusion --fcompiler=gfortran --opt='-O3' diffusion.f90\n```", "```py\n>>> import diffusion\n\n>>> diffusion?\nType:        module\nString form: <module 'diffusion' from '[..]cpython-37m-x86_64-linux-gnu.so'>\nFile:        [..cut..]/diffusion.cpython-37m-x86_64-linux-gnu.so\nDocstring:\nThis module 'diffusion' is auto-generated with f2py (version:2).\nFunctions:\n  evolve(grid,scratch,d,dt)\n.\n\n>>> diffusion.evolve?\nCall signature: diffusion.evolve(*args, **kwargs)\nType:           fortran\nString form:    <fortran object>\nDocstring:\nevolve(grid,scratch,d,dt)\n\nWrapper for ``evolve``.\n\nParameters\ngrid : input rank-2 array('d') with bounds (n,m)\nscratch :  rank-2 array('d') with bounds (n,m)\nd : input float\ndt : input float\n```", "```py\nfrom diffusion import evolve\n\ndef run_experiment(num_iterations):\n    scratch = np.zeros(grid_shape, dtype=np.double, order=\"F\")  ![1](Images/1.png)\n    grid = np.zeros(grid_shape, dtype=np.double, order=\"F\")\n\n    initialize_grid(grid)\n\n    for i in range(num_iterations):\n        evolve(grid, scratch, 1.0, 0.1)\n        grid, scratch = scratch, grid\n```", "```py\n// python_interface.c\n// - cpython module interface for diffusion.c\n\n#define NPY_NO_DEPRECATED_API    NPY_1_7_API_VERSION\n\n#include <Python.h>\n#include <numpy/arrayobject.h>\n#include \"diffusion.h\"\n\n/* Docstrings */\nstatic char module_docstring[] =\n   \"Provides optimized method to solve the diffusion equation\";\nstatic char cdiffusion_evolve_docstring[] =\n   \"Evolve a 2D grid using the diffusion equation\";\n\nPyArrayObject *py_evolve(PyObject *, PyObject *);\n\n/* Module specification */\nstatic PyMethodDef module_methods[] =\n{\n   /* { method name , C function              , argument types , docstring       } */\n   { \"evolve\", (PyCFunction)py_evolve, METH_VARARGS, cdiffusion_evolve_docstring },\n   { NULL,     NULL,                              0, NULL                        }\n};\n\nstatic struct PyModuleDef cdiffusionmodule =\n{\n   PyModuleDef_HEAD_INIT,\n   \"cdiffusion\",      /* name of module */\n   module_docstring,  /* module documentation, may be NULL */\n   -1,                /* size of per-interpreter state of the module,\n * or -1 if the module keeps state in global variables. */\n   module_methods\n};\n\nPyArrayObject *py_evolve(PyObject *self, PyObject *args)\n{\n   PyArrayObject *data;\n   PyArrayObject *next_grid;\n   double         dt, D = 1.0;\n\n   /* The \"evolve\" function will have the signature:\n *     evolve(data, next_grid, dt, D=1)\n */\n   if (!PyArg_ParseTuple(args, \"OOd|d\", &data, &next_grid, &dt, &D))\n   {\n      PyErr_SetString(PyExc_RuntimeError, \"Invalid arguments\");\n      return(NULL);\n   }\n\n   /* Make sure that the numpy arrays are contiguous in memory */\n   if (!PyArray_Check(data) || !PyArray_ISCONTIGUOUS(data))\n   {\n      PyErr_SetString(PyExc_RuntimeError, \"data is not a contiguous array.\");\n      return(NULL);\n   }\n   if (!PyArray_Check(next_grid) || !PyArray_ISCONTIGUOUS(next_grid))\n   {\n      PyErr_SetString(PyExc_RuntimeError, \"next_grid is not a contiguous array.\");\n      return(NULL);\n   }\n\n   /* Make sure that grid and next_grid are of the same type and have the same\n * dimensions\n */\n   if (PyArray_TYPE(data) != PyArray_TYPE(next_grid))\n   {\n      PyErr_SetString(PyExc_RuntimeError,\n                      \"next_grid and data should have same type.\");\n      return(NULL);\n   }\n   if (PyArray_NDIM(data) != 2)\n   {\n      PyErr_SetString(PyExc_RuntimeError, \"data should be two dimensional\");\n      return(NULL);\n   }\n   if (PyArray_NDIM(next_grid) != 2)\n   {\n      PyErr_SetString(PyExc_RuntimeError, \"next_grid should be two dimensional\");\n      return(NULL);\n   }\n   if ((PyArray_DIM(data, 0) != PyArray_DIM(next_grid, 0)) ||\n       (PyArray_DIM(data, 1) != PyArray_DIM(next_grid, 1)))\n   {\n      PyErr_SetString(PyExc_RuntimeError,\n                      \"data and next_grid must have the same dimensions\");\n      return(NULL);\n   }\n\n   evolve(\n      PyArray_DATA(data),\n      PyArray_DATA(next_grid),\n      D,\n      dt\n      );\n\n   Py_XINCREF(next_grid);\n   return(next_grid);\n}\n\n/* Initialize the module */\nPyMODINIT_FUNC\nPyInit_cdiffusion(void)\n{\n   PyObject *m;\n\n   m = PyModule_Create(&cdiffusionmodule);\n   if (m == NULL)\n   {\n      return(NULL);\n   }\n\n   /* Load `numpy` functionality. */\n   import_array();\n\n   return(m);\n}\n```", "```py\n\"\"\"\nsetup.py for cpython diffusion module.  The extension can be built by running\n\n $ python setup.py build_ext --inplace\n\nwhich will create the __cdiffusion.so__ file, which can be directly imported into\nPython.\n\"\"\"\n\nfrom distutils.core import setup, Extension\nimport numpy.distutils.misc_util\n\n__version__ = \"0.1\"\n\ncdiffusion = Extension(\n    'cdiffusion',\n    sources = ['cdiffusion/cdiffusion.c', 'cdiffusion/python_interface.c'],\n    extra_compile_args = [\"-O3\", \"-std=c11\", \"-Wall\", \"-p\", \"-pg\", ],\n    extra_link_args = [\"-lc\"],\n)\n\nsetup (\n    name = 'diffusion',\n    version = __version__,\n    ext_modules = [cdiffusion,],\n    packages = [\"diffusion\", ],\n    include_dirs = numpy.distutils.misc_util.get_numpy_include_dirs(),\n)\n```", "```py\nfrom cdiffusion import evolve\n\ndef run_experiment(num_iterations):\n    next_grid = np.zeros(grid_shape, dtype=np.double)\n    grid = np.zeros(grid_shape, dtype=np.double)\n\n    # ... standard initialization ...\n\n    for i in range(num_iterations):\n        evolve(grid, next_grid, 1.0, 0.1)\n        grid, next_grid = next_grid, grid\n```"]