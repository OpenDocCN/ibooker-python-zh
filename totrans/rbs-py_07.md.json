["```py\npip install mypy\n```", "```py\n    # mypy: disallow-any-generics\n```", "```py\n# Global options:\n\n[mypy]\npython_version = 3.9\nwarn_return_any = True\n\n# Per-module options:\n\n[mypy-mycode.foo.*]\ndisallow_untyped_defs = True\n\n[mypy-mycode.bar]\nwarn_return_any = False\n\n[mypy-somelibrary]\nignore_missing_imports = True\n```", "```py\nfrom typing import Any\nx: Any = 1\ny = x + 1\n```", "```py\ntest.py:4: error: Expression has type \"Any\"\nFound 1 error in 1 file (checked 1 source file)\n```", "```py\nx: list = [1,2,3,4]\n```", "```py\ndef plus_four(x):\n    return x + 4\n```", "```py\ntest.py:4: error: Function is missing a type annotation\n```", "```py\nfrom typing import Optional\nx: Optional[int] = None\nprint(x + 5)\n```", "```py\ntest.py:3: error: Unsupported operand types for + (\"None\" and \"int\")\ntest.py:3: note: Left operand is of type \"Optional[int]\"\n```", "```py\ndef foo(x: int = None) -> None:\n    print(x)\n```", "```py\ntest.py:2: error: Incompatible default for argument \"x\"\n          (default has type \"None\", argument has type \"int\")\n```", "```py\n                  Name   Anys    Exprs   Coverage\n--------------------------------------------------\n         mypy.__main__      0       29    100.00%\n              mypy.api      0       57    100.00%\n        mypy.applytype      0      169    100.00%\n           mypy.argmap      0      394    100.00%\n           mypy.binder      0      817    100.00%\n       mypy.bogus_type      0       10    100.00%\n            mypy.build     97     6257     98.45%\n          mypy.checker     10    12914     99.92%\n        mypy.checkexpr     18    10646     99.83%\n      mypy.checkmember      6     2274     99.74%\n   mypy.checkstrformat     53     2271     97.67%\n    mypy.config_parser     16      737     97.83%\n```", "```py\npip install pyre-check\n```", "```py\npyre query \"attributes(mypy.errors.CompileError)\" ![1](../images/00002.gif)\n\n{\n   \"response\": {\n       \"attributes\": [\n           {\n               \"name\": \"__init__\", ![2](../images/00005.gif)\n               \"annotation\": \"BoundMethod[\n\t\t\t\ttyping.Callable(\n                                   mypy.errors.CompileError.__init__)\n                              [[Named(self, mypy.errors.CompileError),\n                                Named(messages, typing.list[str]),\n                                Named(use_stdout, bool, default),\n                                Named(module_with_blocker,\n                                typing.Optional[str], default)], None],\n                                mypy.errors.CompileError]\",\n               \"kind\": \"regular\",\n               \"final\": false\n           },\n           {\n               \"name\": \"messages\", ![3](../images/00006.gif)\n               \"annotation\": \"typing.list[str]\",\n               \"kind\": \"regular\",\n               \"final\": false\n           },\n           {\n               \"name\": \"module_with_blocker\", ![4](../images/00007.gif)\n               \"annotation\": \"typing.Optional[str]\",\n               \"kind\": \"regular\",\n               \"final\": false\n           },\n           {\n               \"name\": \"use_stdout\", ![5](../images/00008.gif)\n               \"annotation\": \"bool\",\n               \"kind\": \"regular\",\n               \"final\": false\n           }\n       ]\n   }\n}\n```", "```py\npyre query \"callees(mypy.errors.remove_path_prefix)\"\n\n{\n   \"response\": {\n       \"callees\": [\n           {\n               \"kind\": \"function\", ![1](../images/00002.gif)\n               \"target\": \"len\"\n           },\n           {\n               \"kind\": \"method\", ![2](../images/00005.gif)\n               \"is_optional_class_attribute\": false,\n               \"direct_target\": \"str.__getitem__\",\n               \"class_name\": \"str\",\n               \"dispatch\": \"dynamic\"\n           },\n           {\n               \"kind\": \"method\", ![3](../images/00006.gif)\n               \"is_optional_class_attribute\": false,\n               \"direct_target\": \"str.startswith\",\n               \"class_name\": \"str\",\n               \"dispatch\": \"dynamic\"\n           },\n           {\n               \"kind\": \"method\", ![4](../images/00007.gif)\n               \"is_optional_class_attribute\": false,\n               \"direct_target\": \"slice.__init__\",\n               \"class_name\": \"slice\",\n               \"dispatch\": \"static\"\n           }\n       ]\n   }\n}\n```", "```py\nimport os\n\ndef create_recipe():\n   recipe = input(\"Enter in recipe\")\n   create_recipe_on_disk(recipe)\n\ndef create_recipe_on_disk(recipe):\n   command = \"touch ~/food_data/{}.json\".format(recipe)\n   return os.system(command)\n```", "```py\n{\n  sources: [\n    {\n      name: \"UserControlled\", ![1](../images/00002.gif)\n      comment: \"use to annotate user input\"\n    }\n  ],\n\n  sinks: [\n    {\n      name: \"RemoteCodeExecution\", ![2](../images/00005.gif)\n      comment: \"use to annotate execution of code\"\n    }\n  ],\n\n  features: [],\n\n  rules: [\n    {\n      name: \"Possible shell injection\", ![3](../images/00006.gif)\n      code: 5001,\n      sources: [ \"UserControlled\" ],\n      sinks: [ \"RemoteCodeExecution\" ],\n      message_format: \"Data from [{$sources}] source(s) may reach \" +\n                      \"[{$sinks}] sink(s)\"\n    }\n  ]\n}\n```", "```py\n# stubs/taint/general.pysa\n\n # model for raw_input\ndef input(__prompt = ...) -> TaintSource[UserControlled]: ...\n\n# model for os.system\ndef os.system(command: TaintSink[RemoteCodeExecution]): ...\n```", "```py\n\"source_directories\": [\".\"],\n\"taint_models_path\": [\"stubs/taint\"]\n```", "```py\n[\n    {\n        \"line\": 9,\n        \"column\": 26,\n        \"stop_line\": 9,\n        \"stop_column\": 32,\n        \"path\": \"insecure.py\",\n        \"code\": 5001,\n        \"name\": \"Possible shell injection\",\n        \"description\":\n            \"Possible shell injection [5001]: \" +\n            \"Data from [UserControlled] source(s) may reach \" +\n            \"[RemoteCodeExecution] sink(s)\",\n        \"long_description\":\n            \"Possible shell injection [5001]: \" +\n            \"Data from [UserControlled] source(s) may reach \" +\n            \"[RemoteCodeExecution] sink(s)\",\n        \"concise_description\":\n            \"Possible shell injection [5001]: \" +\n            \"Data from [UserControlled] source(s) may reach \" + \"\n            \"[RemoteCodeExecution] sink(s)\",\n        \"inference\": null,\n        \"define\": \"insecure.create_recipe\"\n    }\n]\n```"]