- en: Chapter 8\. Automation with Nox
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章 自动化与 Nox
- en: 'When you maintain a Python project, you’re faced with many chores. Running
    checks on your code is an important part:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你维护一个 Python 项目时，你面临许多任务。对你的代码进行检查是其中重要的一部分：
- en: Testing helps you reduce the defect rate of your code ([Chapter 6](ch06.html#chapter_testing)).
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试帮助你降低代码的缺陷率（[第六章](ch06.html#chapter_testing)）。
- en: Coverage reporting pinpoints untested parts of your code ([Chapter 7](ch07.html#chapter_coverage)).
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖率报告可以找出你代码中未经测试的部分（[第七章](ch07.html#chapter_coverage)）。
- en: Linters analyze your source code to find ways to improve it ([Chapter 9](ch09.html#chapter_linting)).
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码检查器分析你的源代码，找到改进的方法（[第九章](ch09.html#chapter_linting)）。
- en: Code formatters lay out the source code in a readable way ([Chapter 9](ch09.html#chapter_linting)).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码格式化器以可读的方式排列源代码（[第九章](ch09.html#chapter_linting)）。
- en: Type checkers verify the type correctness of your code ([Chapter 10](ch10.html#chapter_typing)).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型检查器验证你的代码的类型正确性（[第十章](ch10.html#chapter_typing)）。
- en: 'Other chores include:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 其他任务包括：
- en: You need to build and publish packages for distribution ([Chapter 3](ch03.html#chapter_packages)).
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要为分发构建和发布包（[第三章](ch03.html#chapter_packages)）。
- en: You need to update the dependencies of your project ([Chapter 4](ch04.html#chapter_dependencies)).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要更新你的项目的依赖关系（[第四章](ch04.html#chapter_dependencies)）。
- en: You need to deploy your service (see [Example 5-7](ch05.html#example_docker_poetry_bundle)
    in [Chapter 5](ch05.html#chapter_poetry)).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要部署你的服务（见 [示例 5-7](ch05.html#example_docker_poetry_bundle) 在 [第五章](ch05.html#chapter_poetry)）。
- en: You need to build the documentation for your project.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要为你的项目构建文档。
- en: Automating these tasks has many benefits. You focus on coding while the check
    suite covers your back. You gain confidence in the steps that take your code from
    development to production. You remove human error and encode each process, so
    others can review and improve it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化这些任务有许多好处。你专注于编码，而检查套件则保护你的背后。你对将代码从开发到生产的步骤充满信心。你消除了人为错误，并对每个流程进行编码，以便他人可以审查和改进它。
- en: Automation gives you leverage to make each step as repeatable, each result as
    reproducible, as possible. Checks and tasks run in the same way on developer machines
    and in continuous integration (CI). They run across different Python versions,
    operating systems, and platforms.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化使你能够将每个步骤都尽可能地可重复，每个结果都尽可能地可再现。检查和任务在开发者机器上和持续集成（CI）中以相同的方式运行。它们跨不同的 Python
    版本、操作系统和平台运行。
- en: In this chapter, you’ll learn about Nox, a Python automation framework. Nox
    serves as a single entry point to your checks and tasks—​for your team, external
    contributors, and automated systems like CI runners.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习 Nox，一个 Python 自动化框架。Nox 作为你的检查和任务的单一入口点—​为你的团队、外部贡献者和自动化系统如 CI 运行器。
- en: 'You write Nox sessions in plain Python: each Nox session is a Python function
    that executes commands in a dedicated, isolated environment. Using Python as the
    automation language gives Nox great simplicity, portability, and expressivity.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你在纯 Python 中编写 Nox 会话：每个 Nox 会话都是一个执行命令的 Python 函数，它在专用的、隔离的环境中执行命令。使用 Python
    作为自动化语言给予了 Nox 很好的简单性、可移植性和表现力。
- en: First Steps with Nox
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nox 初步
- en: 'Install Nox globally using pipx:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pipx 全局安装 Nox：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Specify the latest stable version of Python—​Nox defaults to that version when
    creating environments. Pipx makes the command `nox` available globally, while
    keeping its dependencies isolated from your global Python installation (see [“Installing
    Applications with Pipx”](ch02.html#section_environments_pipx)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 指定最新稳定版本的 Python—​Nox 在创建环境时默认使用该版本。Pipx 使命令 `nox` 在全局范围内可用，同时将其依赖项与全局 Python
    安装隔离开来（见 [“使用 Pipx 安装应用程序”](ch02.html#section_environments_pipx)）。
- en: Configure Nox in a Python file named *noxfile.py* in your project, next to *pyproject.toml*.
    [Example 8-1](#example_nox_simple) shows a *noxfile.py* for running the test suite.
    It’s meant for a simple Python project with no test dependencies besides pytest.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中，通过在 *pyproject.toml* 旁边创建一个名为 *noxfile.py* 的 Python 文件来配置 Nox。[示例 8-1](#example_nox_simple)
    展示了一个用于运行测试套件的 *noxfile.py*。它适用于一个没有测试依赖项的简单 Python 项目，除了 pytest。
- en: Example 8-1\. A session for running the test suite
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-1\. 用于运行测试套件的会话
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Sessions* are the central concept in Nox: each session comprises an environment
    and some commands to run within it. You define a session by writing a Python function
    decorated with `@nox.session`. The function receives a session object as an argument,
    which you can use to install packages (`session.install`) and run commands (`session.run`)
    in the session environment.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*会话* 是 Nox 中的核心概念：每个会话包括一个环境和一些在其中运行的命令。您通过编写一个使用 `@nox.session` 装饰的 Python
    函数来定义会话。该函数接收一个会话对象作为参数，您可以使用它来在会话环境中安装包 (`session.install`) 和运行命令 (`session.run`)。'
- en: 'You can try the session with the example project from previous chapters. For
    now, add your test dependencies to the `session.install` arguments:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试使用前几章的示例项目来运行会话。现在，将您的测试依赖项添加到 `session.install` 参数中：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Invoke `nox` without arguments to run all sessions in the *noxfile.py*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 无需参数即可调用 `nox` 来运行 *noxfile.py* 中的所有会话：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see from the output, Nox starts by creating a virtual environment
    for the `tests` session using `virtualenv`. If you’re curious, you can find this
    environment under the *.nox* directory in your project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从输出中看到的那样，Nox 首先通过使用 `virtualenv` 为 `tests` 会话创建虚拟环境。如果您好奇，您可以在项目的 *.nox*
    目录下找到此环境。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: By default, environments use the same interpreter as Nox itself. In [“Working
    with Multiple Python Interpreters”](#section_nox_pythons), you’ll learn how to
    run sessions on another interpreter, and even across multiple ones.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，环境使用与 Nox 本身相同的解释器。在 [“使用多个 Python 解释器”](#section_nox_pythons) 中，您将学习如何在另一个解释器上运行会话，甚至跨多个解释器运行。
- en: 'First, the session installs the project and pytest into its environment. The
    function `session.install` is just `pip install` underneath. You can pass any
    appropriate options and arguments to pip. For example, you can install your dependencies
    from a requirements file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，会话将项目和 pytest 安装到其环境中。函数 `session.install` 实际上是 `pip install` 的简单封装。您可以向
    pip 传递任何适当的选项和参数。例如，您可以从要求文件中安装依赖项：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you keep your development dependencies in an extra, use the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将开发依赖项保存在额外位置，请使用以下方法：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Above, you’ve used `session.install(".")` to install your project. Behind the
    scenes, pip builds a wheel using the build backend you’ve specified in *pyproject.toml*.
    Nox runs in the directory containing *noxfile.py*, so this command assumes both
    files are in the same directory.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，您使用了 `session.install(".")` 来安装您的项目。在 *pyproject.toml* 中指定的构建后端下，pip
    在包含 *noxfile.py* 的目录中运行 Nox，因此该命令假定这两个文件位于同一个目录中。
- en: 'Nox lets you use `uv` instead of virtualenv and pip for creating environments
    and installing packages. You can switch the backend to `uv` by setting an environment
    variable:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Nox 允许您使用 `uv` 替代 virtualenv 和 pip 来创建环境并安装包。您可以通过设置环境变量来将后端切换到 `uv`：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Second, the session runs the `pytest` command you just installed. If a command
    fails, the session is marked as failed. By default, Nox continues with the next
    session, but it will exit with a non-zero status at the end if any session failed.
    In the run above, the test suite passes and Nox reports success.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，会话运行刚刚安装的 `pytest` 命令。如果命令失败，则会将会话标记为失败。默认情况下，Nox 继续执行下一个会话，但如果任何会话失败，则最终将以非零状态退出。在上述运行中，测试套件通过，Nox
    报告成功。
- en: '[Example 8-2](#example_nox_build) adds a session to build packages for the
    project (see [Chapter 3](ch03.html#chapter_packages)). The session also validates
    the packages using Twine’s `check` command.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-2](#example_nox_build) 添加了一个用于为项目构建包的会话（参见 [第 3 章](ch03.html#chapter_packages)）。该会话还使用
    Twine 的 `check` 命令验证包。'
- en: Example 8-2\. A session for building packages
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-2\. 用于构建包的一个会话
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Example 8-2](#example_nox_build) relies on the standard library for clearing
    out stale packages and locating the freshly built ones: `Path.glob` matches files
    against wildcards, and `shutil.rmtree` removes a directory and its contents.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-2](#example_nox_build) 依赖于标准库来清除陈旧的包并定位新构建的包：`Path.glob` 使用通配符匹配文件，而
    `shutil.rmtree` 删除目录及其内容。'
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Nox doesn’t implicitly run commands in a shell, unlike tools such as `make`.
    Shells differ widely between platforms, so they’d make Nox sessions less portable.
    For the same reason, avoid Unix utilities like `rm` or `find` in your sessions—use
    Python’s standard library instead!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Nox 不像 `make` 等工具那样隐式在 shell 中运行命令。由于平台之间的 shell 差异很大，它们会使 Nox 会话的可移植性降低。出于同样的原因，在会话中避免使用类
    Unix 工具如 `rm` 或 `find` ——应使用 Python 的标准库代替！
- en: The programs you invoke with `session.run` should be available inside the environment.
    If they’re not, Nox prints a friendly warning and falls back to the system-wide
    environment. In the Python world, running programs outside their intended environment
    is a mistake that’s easy to make and hard to diagnose. Turn the warning into an
    error! [Example 8-3](#example_nox_external_error) shows how.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `session.run` 调用的程序应该在环境内可用。如果不可用，Nox 会打印友好的警告并回退到系统范围的环境。在Python世界中，以错误的环境运行程序是一个容易犯而难以诊断的错误。将警告转为错误！[示例
    8-3](#example_nox_external_error) 展示了如何做到这一点。
- en: Example 8-3\. Preventing external commands in Nox sessions
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-3\. 在 Nox 会话中阻止外部命令
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_automation_with_nox_CO1-1)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_automation_with_nox_CO1-1)'
- en: Modify `nox.options` at the top of your *noxfile.py*, outside of sessions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *noxfile.py* 的顶部（会话之外）修改 `nox.options`。
- en: At times, you do need to run external commands, such as non-Python build tools.
    You can allow external commands by passing the `external` flag to `session.run`.
    [Example 8-4](#example_nox_external) shows how to build packages using an existing
    Poetry installation on your system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您确实需要运行非Python构建工具等外部命令。您可以通过向 `session.run` 传递 `external` 标志来允许外部命令。[示例
    8-4](#example_nox_external) 展示了如何使用系统中现有的 Poetry 安装构建软件包。
- en: Example 8-4\. Using an external command to build the packages
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-4\. 使用外部命令构建软件包
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You’re trading off reliability for speed here. [Example 8-2](#example_nox_build)
    works with any build backend declared in *pyproject.toml* and installs it in an
    isolated environment on each run. [Example 8-4](#example_nox_external) assumes
    that contributors have a recent version of Poetry on their system and breaks if
    they don’t. Prefer the first method unless every developer environment has a well-known
    Poetry version.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在权衡可靠性与速度。[示例 8-2](#example_nox_build) 可与 *pyproject.toml* 中声明的任何构建后端一起工作，并在每次运行时将其安装在隔离环境中。[示例
    8-4](#example_nox_external) 假设贡献者系统中有最新版本的 Poetry，并且如果没有，会出问题。除非每个开发环境都有一个已知的
    Poetry 版本，否则请优先考虑第一种方法。
- en: Working with Sessions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话操作
- en: Over time, *noxfile.py* may accumulate a number of sessions. The `--list` option
    gives you a quick overview of them. If you add module and function docstrings
    with helpful descriptions, Nox includes them in the listing as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间推移，*noxfile.py* 可能会积累多个会话。 `--list` 选项可以快速概览它们。如果您为模块和函数添加了有用的描述性文档字符串，Nox
    也会将它们包含在列表中。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Running Nox with the `--session` option lets you select individual sessions
    by name:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--session` 选项运行 Nox，可以按名称选择单个会话：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'During development, running `nox` repeatedly lets you catch errors early. On
    the other hand, you don’t need to validate your packages each time. Fortunately,
    you can change which sessions run by default by setting `nox.options.sessions`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，反复运行 `nox` 可以让您及早捕捉错误。另一方面，您不需要每次验证包。幸运的是，您可以通过设置 `nox.options.sessions`
    来更改默认运行的会话：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, when you run `nox` without arguments, only the `tests` session runs. You
    can still select the `build` session using the `--session` option. Command-line
    options override values specified in `nox.options` in *noxfile.py*.^([1](ch08.html#id304))
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您无参数运行 `nox` 时，只会运行 `tests` 会话。您仍然可以使用 `--session` 选项选择 `build` 会话。命令行选项会覆盖
    *noxfile.py* 中 `nox.options` 中指定的值。^([1](ch08.html#id304))
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keep your default sessions aligned with the mandatory checks for your project.
    Contributors should be able to run `nox` without arguments to check if their code
    changes are acceptable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 保持默认会话与项目的强制检查一致。贡献者应该能够无需参数运行 `nox` 来检查他们的代码更改是否可接受。
- en: Every time a session runs, Nox creates a fresh virtual environment and installs
    the dependencies. This is a good default, because it makes the checks strict,
    deterministic, and repeatable. You won’t miss problems with your code due to stale
    packages in the session environment.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每次会话运行时，Nox 都会创建一个新的虚拟环境并安装依赖项。这是一个很好的默认设置，因为它使检查严格、可预测且可重复。您不会因为会话环境中的过期软件包而错过代码问题。
- en: However, Nox gives you a choice. Setting up environments each time might be
    a tad slow if you re-run your tests in quick succession while coding. You can
    reuse environments with the option `-r` or `--reuse-existing-virtualenvs`. Additionally,
    you can skip installation commands by specifying `--no-install`, or combine these
    options using the shorthand `-R`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Nox 给了您选择的余地。如果您在编码时快速连续重新运行测试，每次设置环境可能会有点慢。您可以使用 `-r` 或 `--reuse-existing-virtualenvs`
    选项重用环境。此外，您可以通过指定 `--no-install` 跳过安装命令，或者使用 `-R` 简写组合这些选项。
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Working with Multiple Python Interpreters
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个 Python 解释器
- en: If your project supports more than a single version of Python, you should run
    your tests on all of them. Nox really shines when it comes to running sessions
    on multiple interpreters. When you define the session with `@nox.session`, use
    the `python` keyword to request one or more specific Python versions, as shown
    in [Example 8-5](#example_nox_python).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目支持多个版本的 Python，你应该在所有这些版本上运行测试。当涉及到在多个解释器上运行会话时，Nox 真的非常出色。当你使用 `@nox.session`
    定义会话时，可以使用 `python` 关键字请求一个或多个特定的 Python 版本，如 [示例 8-5](#example_nox_python) 所示。
- en: Example 8-5\. Running tests across multiple Python versions
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-5\. 在多个 Python 版本上运行测试
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Nox creates an environment for each version and runs the commands in those
    environments in turn:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Nox 为每个版本创建一个环境，并依次在这些环境中运行命令：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Did you get errors from pip when you ran Nox just now? Don’t use the same compiled
    requirements file for every Python version. You need to lock dependencies separately
    for each environment (see [“Session Dependencies”](#section_nox_dependencies)).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才在运行 Nox 时是否收到了来自 pip 的错误？不要为每个 Python 版本使用相同的编译后的依赖文件。你需要为每个环境单独锁定依赖项（参见 [“会话依赖项”](#section_nox_dependencies)）。
- en: 'You can narrow down sessions by Python version using the option `--python`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `--python` 选项按 Python 版本缩小会话范围：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: During development, the `--python` option comes in handy, as it lets you save
    time by running tests on the latest version only.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，`--python` 选项非常方便，因为它只让你在最新版本上运行测试，从而节省时间。
- en: Nox discovers interpreters by searching `PATH` for commands like `python3.12`,
    `python3.11`, and so on. You can also specify a string like `"pypy3.10"` to request
    the PyPy interpreter—​any command that can be resolved against `PATH` will work.
    On Windows, Nox also queries the Python Launcher to find available interpreters.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Nox 通过在 `PATH` 中搜索 `python3.12`、`python3.11` 等命令来发现解释器。你还可以指定类似 `"pypy3.10"`
    的字符串来请求 PyPy 解释器—任何可以在 `PATH` 中解析的命令都可以工作。在 Windows 上，Nox 还查询 Python 启动器以查找可用的解释器。
- en: 'Suppose you’ve installed a prerelease of Python and want to test your project
    on it. The `--python` option would require that the session lists the prerelease.
    Instead, you can specify `--force-python`: it overrides the interpreter for a
    single run. For example, the following invocation runs the `tests` session on
    Python 3.13:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经安装了 Python 的预发行版本，并想在其上测试你的项目。`--python` 选项将要求会话列出预发行版。相反，你可以指定 `--force-python`：它将覆盖解释器以进行单次运行。例如，以下调用在
    Python 3.13 上运行 `tests` 会话：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Session Arguments
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话参数
- en: 'So far, the `tests` session runs pytest without arguments:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`tests` 会话以无参数运行 pytest：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You *could* pass additional options—​such as `--verbose`, which lists every
    individual test separately in the output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你*可以*传递额外的选项—比如 `--verbose`，它会在输出中单独列出每个单独的测试：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'But you don’t always want the same options for pytest. For example, the `--pdb`
    option launches the Python debugger on test failures. The debug prompt can be
    a life saver when you investigate a mysterious bug. But it’s worse than useless
    in a CI context: it would hang forever since there’s nobody to enter commands.
    Similarly, when you work on a feature, the `-k` option lets you run tests with
    a specific keyword in their name—​but you wouldn’t want to hardcode it in *noxfile.py*
    either.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非每次都需要相同的选项来运行 pytest。例如，`--pdb` 选项会在测试失败时启动 Python 调试器。在调查神秘错误时，调试提示符可能是救命稻草。但在
    CI 环境中却比毫无用处更糟糕：它会永远挂起，因为没有人来输入命令。同样，当你在开发一个功能时，`-k` 选项允许你运行具有特定关键字名称的测试，但你也不希望在
    *noxfile.py* 中硬编码它。
- en: Fortunately, Nox lets you pass additional command-line arguments for a session.
    The session can forward the session arguments to a command or evaluate them for
    its own purposes. Session arguments are available in the session as `session.posargs`.
    [Example 8-6](#example_nox_posargs) shows how you forward them to a command like
    pytest.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Nox 允许你为会话传递额外的命令行参数。会话可以将这些参数转发给一个命令或者用于自己的目的。会话参数可以在会话中作为 `session.posargs`
    使用。[示例 8-6](#example_nox_posargs) 展示了如何将它们转发给像 pytest 这样的命令。
- en: Example 8-6\. Forwarding session arguments to pytest
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-6\. 将会话参数转发给 pytest
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You must separate session arguments from Nox’s own command-line arguments with
    the `--` delimiter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用 `--` 分隔符将会话参数与 Nox 自己的命令行参数分开：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Automating Coverage
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化覆盖率
- en: 'Coverage tools give you a sense of how much your tests exercise the codebase
    (see [Chapter 7](ch07.html#chapter_coverage)). In a nutshell, you install the
    `coverage` package and invoke pytest via `coverage run`. [Example 8-7](#example_nox_coverage_run)
    shows how to automate this process with Nox:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖工具可以帮助您了解您的测试覆盖了多少代码库（参见[第 7 章](ch07.html#chapter_coverage)）。简而言之，您需要安装`coverage`包，并通过`coverage
    run`调用pytest。[示例 8-7](#example_nox_coverage_run)展示了如何使用Nox自动化此过程：
- en: Example 8-7\. Running tests with code coverage
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-7\. 带代码覆盖运行测试
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you’re testing in multiple environments, you need to store the coverage
    data from each environment in a separate file (see [“Parallel Coverage”](ch07.html#section_coverage_parallel)).
    Add the following lines to *pyproject.toml* to enable this mode:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在多个环境中进行测试时，您需要将每个环境的覆盖数据存储在单独的文件中（参见[“并行覆盖”](ch07.html#section_coverage_parallel)）。要启用此模式，请向*pyproject.toml*添加以下行：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In [Chapter 7](ch07.html#chapter_coverage), you installed your project in editable
    mode. The Nox session builds and installs a wheel of your project instead. This
    ensures that you’re testing the final artifact you’re distributing to users. But
    it also means that Coverage.py needs to map the installed files back to your source
    tree. Configure the mapping in *pyproject.toml*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 7 章](ch07.html#chapter_coverage)中，您以可编辑模式安装了您的项目。Nox会话将构建并安装您项目的轮子。这确保您正在测试最终分发给用户的工件。但这也意味着Coverage.py需要将安装的文件映射回您的源树。请在*pyproject.toml*中配置映射：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_automation_with_nox_CO2-1)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_automation_with_nox_CO2-1)'
- en: This maps files installed in the *site-packages* directory in an environment
    to files in your *src* directory. The key `source` is an arbitrary identifier;
    it’s needed because you can have multiple mappings in this section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将环境中安装的文件映射到您*src*目录中的文件。键`source`是任意标识符；这是必需的，因为此部分可以有多个映射。
- en: '[Example 8-8](#example_nox_coverage_report) aggregates the coverage files and
    displays the coverage report:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-8](#example_nox_coverage_report) 聚合覆盖文件并显示覆盖报告：'
- en: Example 8-8\. Reporting the code coverage
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-8\. 报告代码覆盖率
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The session only invokes `coverage combine` if there are any coverage data files—​the
    command would fail with an error otherwise. As a result, you can safely use `nox
    -s coverage` to inspect your test coverage without having to re-run the tests
    first.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当存在覆盖数据文件时，会话才会调用`coverage combine`—否则该命令会失败。因此，您可以安全地使用`nox -s coverage`检查测试覆盖率，而无需首先重新运行测试。
- en: Unlike [Example 8-7](#example_nox_coverage_run), this session runs on the default
    Python version and installs only Coverage.py. You don’t need to install your project
    to generate the coverage report.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与[示例 8-7](#example_nox_coverage_run)不同，此会话在默认Python版本上运行，并且仅安装Coverage.py。您无需安装项目即可生成覆盖报告。
- en: If you run these sessions on the example project, make sure to configure Coverage.py
    as shown in [Chapter 7](ch07.html#chapter_coverage). Include Python 3.7 in the
    `tests` session if your project uses the conditional import for `importlib-metadata`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在示例项目上运行这些会话，请确保按照[第 7 章](ch07.html#chapter_coverage)中所示配置Coverage.py。如果您的项目使用条件导入`importlib-metadata`，请在`tests`会话中包含Python 3.7。
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `coverage` session still reports missing coverage for the `main` function
    and the `__main__` module. You’ll take care of that in [“Automating Coverage in
    Subprocesses”](#section_nox_subprocess_coverage).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`coverage`会话仍然报告了`main`函数和`__main__`模块的缺失覆盖。您将在[“子进程中自动化覆盖率”](#section_nox_subprocess_coverage)中处理这些问题。'
- en: Session Notification
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话通知
- en: As it stands, this *noxfile.py* has a subtle problem. Until you run the `coverage`
    session, your project will be littered with data files waiting to be processed.
    And if you haven’t run the `tests` session recently, the data in those files may
    be stale—​so your coverage report won’t reflect the latest state of the codebase.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，这个*noxfile.py*存在一个微妙的问题。在运行`coverage`会话之前，您的项目将充斥着等待处理的数据文件。如果您最近没有运行`tests`会话，则这些文件中的数据可能已过时—因此您的覆盖报告将不会反映代码库的最新状态。
- en: '[Example 8-9](#example_nox_coverage_notify) triggers the `coverage` session
    to run automatically after the test suite. Nox supports this with the `session.notify`
    method. If the notified session isn’t already selected, it runs after the other
    sessions have completed.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-9](#example_nox_coverage_notify) 在测试套件之后自动触发`coverage`会话运行。Nox通过`session.notify`方法支持此功能。如果通知的会话尚未选定，则它会在其他会话完成后运行。'
- en: Example 8-9\. Triggering coverage reports from the tests
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-9\. 从测试触发覆盖率报告
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `try...finally` block ensures you get a coverage report even when a test
    fails. That’s helpful when you start development with a failing test: you want
    to be sure the test exercises the code you’re writing to make it pass.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`try...finally`块确保即使测试失败，您也能获得覆盖报告。当您从一个失败的测试开始开发时，这非常有帮助：您希望确保测试覆盖您正在编写的代码以使其通过。'
- en: Automating Coverage in Subprocesses
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在子进程中自动化覆盖率
- en: 'Alan Kay, a pioneer in object-oriented programming and graphical user interface
    design, once said, “Simple things should be simple; complex things should be possible.”^([2](ch08.html#id305))
    Many Nox sessions will be two-liners: a line to install dependencies and a line
    to run a command. Yet some automations require more complex logic, and Nox excels
    at those, too—​primarily by staying out of your way and deferring to Python as
    a general-purpose programming language.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Alan Kay，面向对象编程和图形用户界面设计的先驱，曾经说过：“简单的事情应该是简单的；复杂的事情应该是可能的。”^([2](ch08.html#id305))
    许多Nox会话只有两行：一行用于安装依赖项，一行用于运行命令。然而，一些自动化任务需要更复杂的逻辑，而Nox也擅长处理这些，主要是通过不阻碍您并推迟到Python作为一种通用编程语言。
- en: Let’s iterate on the `tests` session and measure coverage in subprocesses. As
    you saw in [Chapter 7](ch07.html#chapter_coverage), setting this up requires a
    little dance. First, you install a *.pth* file into the environment; this gives
    `coverage` a chance to initialize when the subprocess starts up. Second, you set
    an environment variable to point `coverage` to its configuration file. It’s tedious
    and a bit tricky to get right. Let’s “automate it away”!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`tests`会话中进行迭代，并在子进程中测量覆盖率。正如您在[第7章](ch07.html#chapter_coverage)中看到的那样，设置这个需要一些技巧。首先，您需要将*.pth*文件安装到环境中；这使得在子进程启动时`coverage`有机会初始化。其次，您需要设置一个环境变量来指向`coverage`的配置文件。这些操作都有点繁琐且需要一定技巧才能做好。让我们“自动化”它吧！
- en: 'First, you need to determine the location for the *.pth* file. The directory
    is named *site-packages*, but the exact path depends on your platform and the
    Python version. Instead of taking a guess, you can query the `sysconfig` module
    for it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要确定*.pth*文件的位置。目录名为*site-packages*，但确切的路径取决于您的平台和Python版本。您可以通过查询`sysconfig`模块来获取它，而不是猜测：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you called the function directly in your session, it would return a location
    in the environment where you’ve installed Nox. Instead, you need to query the
    interpreter *in the session environment*. You can do this by running `python`
    with `session.run`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您直接在会话中调用函数，它将返回您已经安装Nox的环境中的位置。而实际上，您需要查询*会话环境*中的解释器。您可以通过使用`session.run`来运行`python`来实现这一点：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `silent` keyword lets you capture the output instead of echoing it to the
    terminal. Thanks to `pathlib` from the standard library, writing the *.pth* file
    now only takes a couple of statements:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`silent`关键字允许您捕获输出而不是将其回显到终端。由于标准库中的`pathlib`，现在编写*.pth*文件只需要几个语句：'
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Example 8-10](#example_nox_coverage_pth) extracts these statements into a
    helper function. The function takes a `session` argument, but it isn’t a Nox session—​it
    lacks the `@nox.session` decorator. In other words, the function won’t run unless
    you call it from a session.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-10](#example_nox_coverage_pth)将这些语句提取到一个助手函数中。该函数接受一个`session`参数，但它不是一个Nox会话——它缺少`@nox.session`装饰器。换句话说，如果不从会话中调用它，该函数将不会运行。'
- en: Example 8-10\. Installing *coverage.pth* into the environment
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-10\. 将*coverage.pth*安装到环境中
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You’re almost done. What’s left is invoking the helper function from the `tests`
    session and passing the environment variable to `coverage`. [Example 8-11](#example_nox_coverage_subprocess)
    shows the final session.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经快完成了。剩下的是从`tests`会话中调用助手函数并将环境变量传递给`coverage`。[示例 8-11](#example_nox_coverage_subprocess)展示了最终的会话。
- en: Example 8-11\. The `tests` session with subprocess coverage enabled
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-11\. 启用子进程覆盖率的`tests`会话
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](assets/1.png)](#co_automation_with_nox_CO3-1)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_automation_with_nox_CO3-1)'
- en: Install the dependencies before the *.pth* file. The order matters because the
    *.pth* file imports the `coverage` package.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在*.pth*文件之前安装依赖项。顺序很重要，因为*.pth*文件会导入`coverage`包。
- en: 'With subprocess coverage enabled, the end-to-end test produces the missing
    coverage data for the `main` function and the `__main__` module. Invoke `nox`
    and watch it run your tests and generate a coverage report. Here’s what the report
    should look like:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 启用子进程覆盖率后，端到端测试将为`main`函数和`__main__`模块生成缺失的覆盖数据。调用`nox`并观看它运行您的测试并生成覆盖报告。以下是报告的示例内容：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Parameterizing Sessions
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化会话
- en: 'The phrase “works for me” describes a common story: a user reports an issue
    with your code, but you can’t reproduce the bug in your environment. Runtime environments
    in the real world differ in a myriad of ways. Testing across Python versions covers
    one important variable. Another common cause of surprise is the packages that
    your project uses directly or indirectly—​its dependency tree.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: “对我有效”这个短语描述了一个常见的情况：用户报告您代码的问题，但您无法在自己的环境中重现该错误。真实世界的运行时环境在许多方面都是不同的。跨Python版本进行测试涵盖了一个重要变量。另一个常见的令人惊讶的原因是您的项目直接或间接使用的包——即其依赖树。
- en: Nox offers a powerful technique for testing your project against different versions
    of a dependency. *Parameterization* allows you to add parameters to your session
    functions and supply predefined values for them; Nox runs the session with each
    of these values.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Nox为测试项目与不同版本依赖提供了强大的技术。*参数化*允许您向会话函数添加参数并为其提供预定义的值；Nox会使用每个值运行会话。
- en: You declare the parameter and its values in a decorator named `@nox.parametrize`.^([3](ch08.html#id306))
    [Example 8-12](#example_nox_parametrize) demonstrates this feature and how it
    allows you to test against different versions of the Django web framework.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您在名为`@nox.parametrize`的装饰器中声明参数及其值。^([3](ch08.html#id306))[示例8-12](#example_nox_parametrize)演示了此功能及其如何允许您针对Django
    Web框架的不同版本进行测试。
- en: Example 8-12\. Testing the project with multiple Django versions
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-12\. 使用多个Django版本测试项目
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Parameterized sessions are similar to parameterized tests in pytest (see [Chapter 6](ch06.html#chapter_testing)),
    which is where Nox borrowed the concept from. You can stack `@nox.parametrize`
    decorators to run sessions against all combinations of parameters:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化会话类似于pytest中的参数化测试（参见[第6章](ch06.html#chapter_testing)），这是Nox借用的概念。您可以堆叠`@nox.parametrize`装饰器，以针对所有参数组合运行会话：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you only want to check for certain combinations, you can combine parameters
    in a single `@nox.parametrize` decorator:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想检查某些组合，可以将参数组合在单个`@nox.parametrize`装饰器中：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When running a session across Python versions, you’re effectively parameterizing
    the session by the interpreter. In fact, Nox let’s you write the following instead
    of passing the versions to `@nox.session`:^([4](ch08.html#id307))
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当跨Python版本运行会话时，您实际上是通过解释器对会话进行参数化。事实上，Nox让您可以这样写，而不是将版本传递给`@nox.session`：^([4](ch08.html#id307))
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This syntax is useful when you want specific combinations of Python and the
    dependency. Here’s an example: As of this writing, Django 3.2 (LTE) doesn’t officially
    support Python versions newer than 3.10\. Consequently, you need to exclude these
    combinations from the test matrix. [Example 8-13](#example_nox_parametrize_python)
    shows how.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在您想要特定Python和依赖组合时，此语法非常有用。以下是一个示例：截至本文撰写时，Django 3.2（LTE）并不正式支持比3.10更新的Python版本。因此，您需要从测试矩阵中排除这些组合。[示例8-13](#example_nox_parametrize_python)展示了如何实现这一点。
- en: Example 8-13\. Parameterizing by valid Python and Django combinations
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-13\. 使用有效的Python和Django组合进行参数化
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Session Dependencies
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话依赖
- en: 'If you’ve followed [Chapter 4](ch04.html#chapter_dependencies) closely, you
    may see some problems with the way [Example 8-8](#example_nox_coverage_report)
    and [Example 8-11](#example_nox_coverage_subprocess) install packages. Here are
    the relevant parts again:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细阅读了[第4章](ch04.html#chapter_dependencies)，您可能会注意到[示例8-8](#example_nox_coverage_report)和[示例8-11](#example_nox_coverage_subprocess)安装包的方式存在一些问题。这里再次列出相关部分：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For one, the `coverage` session doesn’t specify which version of `coverage`
    the project requires. The `tests` session does this right: it references the `tests`
    extra in *pyproject.toml*, which includes the appropriate version specifiers (see
    [“Managing Test Dependencies”](ch06.html#section_testing_dependencies)).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`coverage`会话没有指定项目需要的`coverage`版本。`tests`会话做得对：它引用了*pyproject.toml*中的`tests`额外部分，其中包含适当的版本说明符（参见[“管理测试依赖”](ch06.html#section_testing_dependencies)）。
- en: 'The `coverage` session doesn’t need the project, though, so an extra seems
    like a bad fit. But before I get to this, let me point out another problem with
    the sessions above: They don’t lock their dependencies.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`coverage`会话不需要项目，所以额外的似乎不太合适。但在我继续之前，让我指出上述会话的另一个问题：它们没有锁定它们的依赖关系。'
- en: 'Running checks without locking dependencies has two drawbacks. First, the checks
    aren’t deterministic: subsequent runs of the same session may install different
    packages. Second, if a dependency breaks your project, checks fail until you exclude
    the release or another release fixes the problem.^([5](ch08.html#id308)) In other
    words, any project you depend on, even indirectly, has the power to block your
    entire CI pipeline.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在不锁定依赖项的情况下运行检查有两个缺点。首先，检查不是确定性的：同一会话的后续运行可能会安装不同的包。其次，如果一个依赖关系破坏了你的项目，检查将失败，直到你排除该发布或另一个发布修复了问题。^([5](ch08.html#id308))
    换句话说，你依赖的任何项目，甚至间接依赖的项目，都有可能阻塞你整个持续集成流水线。
- en: On the other hand, lock file updates are a constant churn, and they clutter
    your Git history. Reducing their frequency comes at the price of running checks
    with stale dependencies. If you don’t require locking for other reasons, such
    as secure deployments—​and you’re happy to quickly fix a build when an incompatible
    release wreaks havoc on your CI—​you may prefer to keep your dependencies unlocked.
    There ain’t no such thing as a free lunch.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，锁定文件的更新是一个不断变化的过程，并且会混淆你的Git历史记录。减少它们的频率是以使用过时依赖项来运行检查为代价的。如果你没有其他原因要求锁定，比如安全部署，且愿意在不兼容的发布混乱你的持续集成时快速修复构建，你可能更愿意保持你的依赖项未锁定。没有免费的午餐。
- en: 'In [“Development Dependencies”](ch04.html#section_dependencies_development),
    you grouped dependencies in extras and compiled requirements files from each.
    In this section, I’ll show you a lighter-weight method for locking: *constraints
    files*. You only need a single extra for it. It also doesn’t require installing
    the project itself, as extras usually do—​which helps with the `coverage` session.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“开发依赖”](ch04.html#section_dependencies_development)中，你将额外的依赖项分组并从每个编译需求文件。在本节中，我将向你展示一种更轻量级的锁定方法：*约束文件*。你只需要一个额外的依赖项。它也不需要像通常那样安装项目本身，这有助于`coverage`会话。
- en: 'Constraints files look similar to requirements files: Each line lists a package
    with a version specifier. Unlike requirements files, however, constraints files
    don’t cause pip to install a package—​they only control which version pip selects
    *if* it needs to install the package.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 约束文件看起来类似于需求文件：每行列出一个带有版本说明符的包。然而，与需求文件不同，约束文件不会导致pip安装一个包——它们只控制pip在需要安装包时选择的版本。
- en: A constraints file works great for locking session dependencies. You can share
    it across sessions while only installing the packages each session needs. Its
    only drawback, compared to using a set of requirements files, is that you need
    to resolve all dependencies together, so there’s a higher chance of dependency
    conflicts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 约束文件非常适合用于锁定会话依赖项。你可以在会话之间共享它，同时仅安装每个会话所需的包。与使用一组需求文件相比，它唯一的缺点是需要一起解决所有依赖关系，因此存在更高的依赖冲突的可能性。
- en: You can generate constraints files using pip-tools or uv (see [“Compiling Requirements
    with pip-tools and uv”](ch04.html#section_dependencies_piptools)). Nox can automate
    this part, too, as shown in [Example 8-14](#example_nox_constraints).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用pip-tools或uv生成约束文件（请参阅[“使用pip-tools和uv编译需求”](ch04.html#section_dependencies_piptools)）。Nox也可以自动化这一部分，如[示例 8-14](#example_nox_constraints)所示。
- en: Example 8-14\. Locking the dependencies with uv
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-14\. 使用uv锁定依赖项
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](assets/1.png)](#co_automation_with_nox_CO4-1)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_automation_with_nox_CO4-1)'
- en: Explicitly require uv as the environment backend. (You could also install uv
    into the session with `session.install("uv")`, but uv supports a broader range
    of Python versions than you can use to install its PyPI package.)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 明确要求将uv作为环境后端。（你也可以在会话中安装uv，方法是`session.install("uv")`，但uv支持比你可以用来安装其PyPI包的Python版本范围更广。）
- en: The `--output-file` option specifies the conventional name for a constraints
    file, *constraints.txt*. The `--upgrade` option ensures that you get up-to-date
    dependencies whenever you run the session. The `--all-extras` option includes
    all the optional dependencies of the project.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`--output-file`选项指定约束文件的传统名称，*constraints.txt*。`--upgrade`选项确保您在每次运行会话时获取最新的依赖关系。`--all-extras`选项包含项目的所有可选依赖项。'
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Don’t forget to commit the constraints file to source control. You need to share
    this file with every contributor, and it needs to be available in CI.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将约束文件提交到源代码控制。你需要与每个贡献者分享这个文件，并且它需要在持续集成中可用。
- en: Pass the constraints file to `session.install` using the `--constraint` or `-c`
    option. [Example 8-15](#example_nox_single_constraints) shows the `tests` and
    `coverage` sessions with locked dependencies.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--constraint` 或 `-c` 选项将约束文件传递给 `session.install`。[示例 8-15](#example_nox_single_constraints)
    显示了带有锁定依赖项的 `tests` 和 `coverage` 会话。
- en: Example 8-15\. Using a constraints file to lock session dependencies
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-15\. 使用约束文件锁定会话依赖项
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using a single constraints file requires that you target a well-known interpreter
    and platform. You can’t use the same constraints file for different environments
    because each environment may require different packages.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个约束文件需要定位一个众所周知的解释器和平台。你不能在不同的环境中使用相同的约束文件，因为每个环境可能需要不同的包。
- en: If you support multiple Python versions, operating systems, or processor architectures,
    compile a separate constraints file for each environment. Keep the constraints
    files in a subdirectory to avoid clutter. [Example 8-16](#example_nox_constraints_helper)
    shows a helper function that constructs filenames like *constraints/python3.12-linux-arm64.txt*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你支持多个 Python 版本、操作系统或处理器架构，请为每个环境编译一个单独的约束文件。将约束文件保存在子目录中以避免混乱。[示例 8-16](#example_nox_constraints_helper)
    显示了一个辅助函数，用于构建类似 *constraints/python3.12-linux-arm64.txt* 的文件名。
- en: Example 8-16\. Constructing paths for a constraints file
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-16\. 构建约束文件的路径
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[Example 8-17](#example_nox_constraints_multipython) updates the `lock` session
    to generate the constraints files. The session now runs on every Python version.
    It uses the helper function to build the path for the constraints file, ensures
    that the target directory exists, and passes the filename to uv.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-17](#example_nox_constraints_multipython) 更新了 `lock` 会话以生成约束文件。该会话现在在每个
    Python 版本上运行。它使用辅助函数构建约束文件的路径，确保目标目录存在，并将文件名传递给 uv。'
- en: Example 8-17\. Locking dependencies on multiple Python versions
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-17\. 在多个 Python 版本上锁定依赖项
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `tests` and `coverage` sessions can now reference the appropriate constraints
    file for each Python version. For this to work, you have to declare a Python version
    for the `coverage` session as well.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests` 和 `coverage` 会话现在可以引用每个 Python 版本的适当约束文件。为使其正常工作，你必须为 `coverage` 会话声明一个
    Python 版本。'
- en: Example 8-18\. The `tests` and `coverage` session with multi-Python constraints
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-18\. `tests` 和 `coverage` 会话与多 Python 约束
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using Nox with Poetry Projects
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Nox 处理 Poetry 项目
- en: 'If you manage your project with Poetry, you organize dependencies in dependency
    groups (see [“Dependency Groups”](ch05.html#section_poetry_development_dependencies)).
    Dependency groups align naturally with Nox sessions: packages for the `tests`
    session go into a `tests` group, those for a `docs` session into a `docs` group,
    and so on. Using Poetry as the installer means you get locked dependencies for
    free—​all installations honor the lock file.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Poetry 管理项目，则将依赖项组织在依赖组中（参见 [“Dependency Groups”](ch05.html#section_poetry_development_dependencies)）。依赖组与
    Nox 会话自然对齐：`tests` 会话的包进入 `tests` 组，`docs` 会话的包进入 `docs` 组，依此类推。使用 Poetry 作为安装程序意味着你免费获得了锁定的依赖项——所有安装都遵循锁定文件。
- en: Before I show you how to use Poetry in Nox sessions, let me call out a couple
    of differences between Poetry environments and Nox environments.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我向你展示如何在 Nox 会话中使用 Poetry 之前，让我先指出 Poetry 环境和 Nox 环境之间的一些区别。
- en: 'First, the Poetry environment is comprehensive: by default, it includes the
    project, its main dependencies, and every non-optional dependency group. Nox environments
    only install packages required for the task they automate.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Poetry 环境非常全面：默认情况下，它包括项目、其主要依赖项以及每个非可选的依赖组。Nox 环境仅安装任务自动化所需的包。
- en: Second, the Poetry environment uses editable installs for the project so you
    don’t need to reinstall after every code change. Nox environments build and install
    a wheel so automated checks see the project the same way an end user would.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，Poetry 环境使用可编辑安装项目，因此你不需要在每次代码更改后重新安装。Nox 环境构建并安装轮子，因此自动化检查会看到与最终用户相同的项目。
- en: There’s no right and wrong here. Poetry environments are perfect for ad-hoc
    interactions with your project during development, with every tool just a `poetry
    run` away. Nox environments, on the other hand, are optimized for reliable and
    repeatable checks; they aim to be as isolated and deterministic as possible.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有对错之分。Poetry 环境非常适合在开发过程中与项目进行临时交互，每个工具都只需执行 `poetry run` 即可。另一方面，Nox 环境则针对可靠和可重复的检查进行了优化；它们旨在尽可能地隔离和确定性。
- en: 'When you use Poetry in a Nox session, it’s good to be mindful of these differences.
    I recommend these guidelines for invoking `poetry install` with Nox:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nox会话中使用Poetry时，需要注意这些差异。我建议在使用Nox调用`poetry install`时遵循以下准则：
- en: Use the option `--no-root` to avoid an editable install of the project. If the
    session needs the project to be installed (not every session does), follow the
    command with `session.install(".")` to build and install a wheel.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选项`--no-root`避免对项目进行可编辑的安装。如果会话需要安装项目（并非每个会话都需要），请在命令后跟随`session.install(".")`来构建和安装一个wheel。
- en: Use the option `--only=*<group>*` to install the appropriate dependency group
    for the session. If the session needs the project to be installed, list the special
    group `main` as well—​this ensures that every package is pinned using *poetry.lock*.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选项`--only=*<group>*`为会话安装适当的依赖组。如果会话需要安装项目，请同时列出特殊组`main`—​这确保每个软件包都使用*poetry.lock*进行固定。
- en: Use the option `--sync` to remove packages from a reused session environment
    when your project no longer depends on them.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选项`--sync`从重用的会话环境中删除项目不再依赖的软件包。
- en: '[Example 8-19](#example_nox_poetry_install) puts this logic into a helper function
    that you can share across your session functions.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例8-19](#example_nox_poetry_install)将此逻辑放入一个辅助函数中，您可以在会话函数之间共享它。'
- en: Example 8-19\. Installing session dependencies with Poetry
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-19\. 使用Poetry安装会话依赖项
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The helper function uses `session.run_install` instead of `session.run`. The
    two functions work exactly alike, but `session.run_install` marks the command
    as an installation. This avoids package installations when you reuse environments
    with `--no-install` or `-R`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数使用`session.run_install`而不是`session.run`。这两个函数的工作方式完全相同，但`session.run_install`将命令标记为安装操作。这在您使用`--no-install`或`-R`重用环境时避免了软件包安装。
- en: If you’ve followed along using Poetry in [Chapter 6](ch06.html#chapter_testing)
    and [Chapter 7](ch07.html#chapter_coverage), your *pyproject.toml* should have
    a dependency group named `tests` containing pytest and coverage. Let’s split the
    `coverage` dependency off into a separate group, since you don’t need the test
    dependencies for the `coverage` session:^([6](ch08.html#id309))
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在[第6章](ch06.html#chapter_testing)和[第7章](ch07.html#chapter_coverage)中使用Poetry进行了跟随，那么您的*pyproject.toml*应该有一个名为`tests`的依赖组，其中包含pytest和coverage。让我们将`coverage`依赖项拆分到单独的组中，因为您不需要`coverage`会话的测试依赖项:^([6](ch08.html#id309))
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here’s how you’d install the dependencies in the `tests` session:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在`tests`会话中安装依赖项的示例：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And here’s what the `coverage` session looks like with the helper function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是带有辅助函数的`coverage`会话的样子：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: How does Poetry know to use a Nox environment instead of the Poetry environment?
    Poetry installs packages into the active environment, if one exists. When Nox
    runs Poetry, it activates the session environment by exporting the `VIRTUAL_ENV`
    environment variable (see [“Virtual Environments”](ch02.html#section_environments_venv)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry如何知道要使用Nox环境而不是Poetry环境？Poetry会将软件包安装到活动环境中（如果存在）。当Nox运行Poetry时，它通过导出`VIRTUAL_ENV`环境变量来激活会话环境（参见[“虚拟环境”](ch02.html#section_environments_venv)）。
- en: Locking Dependencies with nox-poetry
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`nox-poetry`锁定依赖关系
- en: There’s an alternative approach to using Nox with Poetry projects. The `nox-poetry`
    package is an unofficial plugin for Nox that lets you write sessions without worrying
    about locking, using plain `session.install`. Behind the scenes, `nox-poetry`
    exports a constraints file for pip using `poetry export`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Nox与Poetry项目的另一种方法是选择。`nox-poetry`包是Nox的非官方插件，允许您使用简单的`session.install`编写会话，无需担心锁定。在幕后，`nox-poetry`通过`poetry
    export`导出一个pip的约束文件。
- en: 'Install `nox-poetry` into the same environment as Nox:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将`nox-poetry`安装到与Nox相同的环境中：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Decorate your sessions with `@session` from the `nox-poetry` package, which
    is a drop-in replacement for `@nox.session`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`nox-poetry`包中的`@session`装饰您的会话，它是`@nox.session`的替代品：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When you install packages with `session.install`, the constraints file keeps
    their versions in sync with `poetry.lock`. You can manage dependencies in separate
    dependency groups or put them into a single `dev` group.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`session.install`安装软件包时，约束文件会将它们的版本与`poetry.lock`保持同步。您可以将依赖项管理在单独的依赖组中，也可以将它们放入单个`dev`组中。
- en: While this approach is convenient and simplifies the resulting *noxfile.py*,
    it doesn’t come for free. Translating Poetry’s dependency information into a constraints
    file isn’t lossless—​for example, it doesn’t include package hashes or the URLs
    of private package repositories. Another drawback is that contributors have another
    global dependency to worry about. When I wrote `nox-poetry` in 2020, dependency
    groups didn’t exist. As of this writing, I recommend using Poetry directly, as
    described in the previous section.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法方便且简化了结果的 *noxfile.py*，但它并非免费的。将 Poetry 的依赖信息翻译为约束文件并非无损—例如，它不包括包哈希或私有包存储库的
    URL。另一个缺点是贡献者需要担心另一个全局依赖。当我在 2020 年编写 `nox-poetry` 时，不存在依赖组。截至撰写本文时，我建议直接使用 Poetry，正如前一节所述。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Nox lets you automate checks and tasks for a project. Its Python configuration
    file *noxfile.py* organizes them into one or more sessions. Sessions are functions
    decorated with `@nox.session`. They receive a single argument `session` providing
    the session API ([Table 8-1](#table_nox_session)). Every session runs in an isolated
    virtual environment. If you pass a list of Python versions to `@nox.session`,
    Nox runs the session across all of them.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Nox 让你能够自动化项目的检查和任务。它的 Python 配置文件 *noxfile.py* 将它们组织成一个或多个会话。会话是使用 `@nox.session`
    装饰的函数。它们接收一个名为 `session` 的参数，提供会话 API（[表 8-1](#table_nox_session)）。每个会话在独立的虚拟环境中运行。如果你向
    `@nox.session` 传递一个 Python 版本列表，Nox 将在所有这些版本上运行该会话。
- en: Table 8-1\. The session object
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1\. 会话对象
- en: '| Attribute | Description | Example |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `run()` | Run a command | `session.run("coverage", "report")` |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `run()` | 运行命令 | `session.run("coverage", "report")` |'
- en: '| `install()` | Install packages with pip | `session.install(".", "pytest")`
    |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `install()` | 使用 pip 安装包 | `session.install(".", "pytest")` |'
- en: '| `run_install()` | Run an installation command | `session.run_install("poetry",
    "install")` |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `run_install()` | 运行安装命令 | `session.run_install("poetry", "install")` |'
- en: '| `notify()` | Enqueue another session | `session.notify("coverage")` |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `notify()` | 将另一个会话加入队列 | `session.notify("coverage")` |'
- en: '| `python` | The interpreter for this session | `"3.12"` |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `python` | 该会话的解释器 | `"3.12"` |'
- en: '| `posargs` | Extra command-line arguments | `nox -- --verbose --pdb` |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `posargs` | 额外的命令行参数 | `nox -- --verbose --pdb` |'
- en: The command `nox` ([Table 8-2](#table_nox_options)) provides a single entry
    point to your suite of checks. Without arguments, it runs every session defined
    in *noxfile.py* (or those you’ve listed in `nox.options.sessions`). The earlier
    you identify issues with your code, the cheaper it is to fix them—​so use Nox
    to run the same checks locally as in continuous integration (CI). Besides checks,
    you can automate many other chores, such as building packages or documentation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `nox`（[表 8-2](#table_nox_options)）为你的一套检查提供了单一入口点。如果没有参数，它将运行 *noxfile.py*
    中定义的每个会话（或者你在 `nox.options.sessions` 中列出的会话）。尽早发现代码问题，修复起来就越便宜—因此使用 Nox 在本地运行与持续集成（CI）中相同的检查。除了检查，你还可以自动化许多其他任务，如构建包或文档。
- en: Table 8-2\. Command-line options for `nox`
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2\. `nox` 的命令行选项
- en: '| Option | Description | Example |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `--list` | List the available sessions | `nox -l` |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `--list` | 列出可用的会话 | `nox -l` |'
- en: '| `--session` | Select sessions by name | `nox -s tests` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `--session` | 通过名称选择会话 | `nox -s tests` |'
- en: '| `--python` | Select sessions by interpreter | `nox -p 3.12` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `--python` | 选择解释器会话 | `nox -p 3.12` |'
- en: '| `--force-python` | Override the interpreter for a session | `nox --force-python
    3.13` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `--force-python` | 为会话强制指定解释器 | `nox --force-python 3.13` |'
- en: '| `--reuse-existing-virtualenvs` | Reuse existing virtual environments | `nox
    -rs tests` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `--reuse-existing-virtualenvs` | 重用现有的虚拟环境 | `nox -rs tests` |'
- en: '| `--no-install` | Skip installation commands | `nox -Rs tests` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `--no-install` | 跳过安装命令 | `nox -Rs tests` |'
- en: There’s a lot more to Nox that this chapter didn’t cover. For example, you can
    use Conda or Mamba to create environments and install packages. You can organize
    sessions using keywords and tags, and assign friendly identifiers using `nox.param`.
    Last but not least, Nox comes with a GitHub Action that makes it easy to run Nox
    sessions in CI. Take a look at the [official documentation](https://nox.thea.codes)
    to learn more.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Nox 还有更多内容本章没有覆盖到。例如，你可以使用 Conda 或 Mamba 创建环境并安装包。你可以使用关键字和标签来组织会话，并使用 `nox.param`
    分配友好的标识符。最后但同样重要的是，Nox 提供了一个 GitHub Action，方便在 CI 中运行 Nox 会话。请查阅[官方文档](https://nox.thea.codes)以了解更多。
- en: ^([1](ch08.html#id304-marker)) In case you’re wondering, always use the plural
    form `nox.options.sessions` in *noxfile.py*. On the command line, both `--session`
    and `--sessions` work. You can specify any number of sessions with these options.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.html#id304-marker)) 如果你在想，始终在*noxfile.py*中使用复数形式`nox.options.sessions`。在命令行中，`--session`和`--sessions`都可用。这些选项可以指定任意数量的会话。
- en: ^([2](ch08.html#id305-marker)) Alan Kay, [“What is the story behind Alan Kay’s
    adage *Simple things should be simple, complex things should be possible*?”](https://qr.ae/pyjKrs),
    *Quora Answer*, June 19, 2020.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.html#id305-marker)) 艾伦·凯，[“艾伦·凯的格言 *简单的事物应该简单，复杂的事物应该是可能的* 的背后有什么故事？”](https://qr.ae/pyjKrs)，*Quora回答*，2020年6月19日。
- en: ^([3](ch08.html#id306-marker)) Like pytest, Nox uses the alternate spelling
    “parametrize” to protect your “E” keycap from excessive wear.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch08.html#id306-marker)) 与pytest类似，Nox使用替代拼写“parametrize”来保护你的“E”键帽免受过度磨损。
- en: ^([4](ch08.html#id307-marker)) The eagle-eyed reader may notice that `python`
    is not a function parameter here. If you do need it in the session function, use
    `session.python` instead.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch08.html#id307-marker)) 眼尖的读者可能会注意到，这里`python`不是一个函数参数。如果你确实需要在会话函数中使用它，请改用`session.python`。
- en: '^([5](ch08.html#id308-marker)) Semantic Versioning constraints do more harm
    here than they help. Bugs occur in all releases, and your upstream’s definition
    of a breaking change may be narrower than you like. See Hynek Schlawack: [“Semantic
    Versioning Will Not Save You,”](https://hynek.me/articles/semver-will-not-save-you/)
    March 2, 2021.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch08.html#id308-marker)) 在这里，语义版本控制的约束比它的帮助更有害。所有版本都可能出现错误，而你的上游定义的破坏性更改可能比你想象的要狭窄。请参见Hynek
    Schlawack的文章：[“语义版本控制无法拯救你”，](https://hynek.me/articles/semver-will-not-save-you/)
    2021年3月2日。
- en: ^([6](ch08.html#id309-marker)) Run `poetry lock --no-update` after editing *pyproject.toml*
    to update the *poetry.lock* file.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch08.html#id309-marker)) 编辑*pyproject.toml*后运行`poetry lock --no-update`，以更新*poetry.lock*文件。
