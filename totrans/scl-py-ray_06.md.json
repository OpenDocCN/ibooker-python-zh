["```py\n@ray.remote\ndef flaky_remote_fun(x):\n    import random\n    import sys\n    if random.randint(0, 2) == 1:\n        sys.exit(0)\n    return x\n\nr = flaky_remote_fun.remote(1)\n```", "```py\nremote_array = ray.put([1])\nv = ray.get(remote_array)\nv.append(2)\nprint(v)\nprint(ray.get(remote_array))\n```", "```py\nimport numpy as np\n@ray.remote\ndef sup(x):\n    import random\n    import sys\n    return len(x)\n\np = ray.put(np.array(range(0, 1000)))\nray.get([sup.remote(p), sup.remote(p), sup.remote(p)])\n```", "```py\n    ray.init(num_cpus=20,\n         _system_config={\n            \"min_spilling_size\": 1024 * 1024,  # Spill at least 1 MB\n            \"object_store_memory_mb\": 500,\n            \"object_spilling_config\": json.dumps(\n                {\"type\": \"filesystem\", \"params\": {\"directory_path\": \"/tmp/fast\"}},\n                )\n             })\n```", "```py\nimport ray.cloudpickle as pickle\nfrom multiprocessing import Pool\npickle\n\nclass BadClass:\n    def __init__(self, threadCount, friends):\n        self.friends = friends\n        self.p = Pool(threadCount) # not serializable\n\ni = BadClass(5, [\"boo\", \"boris\"])\n# This will fail with a \"NotImplementedError: pool objects cannot be passed between \n# processes or pickled\"\n# pickle.dumps(i)\n\nclass LessBadClass:\n    def __init__(self, threadCount, friends):\n        self.friends = friends\n        self.p = Pool(threadCount)\n    def __getstate__(self):\n        state_dict = self.__dict__.copy()\n        # We can't move the threads but we can move the info to make a pool \n        # of the same size\n        state_dict[\"p\"] = len(self.p._pool)\n        return state_dict\n    def __setsate__(self):\n        self.__dict__.update(state)\n        self.p = Pool(self.p)\nk = LessBadClass(5, [\"boo\", \"boris\"])\npickle.loads(pickle.dumps(k))\n```", "```py\ndef custom_serializer(bad):\n    return {\"threads\": len(bad.p._pool), \"friends\": bad.friends}\n\ndef custom_deserializer(params):\n    return BadClass(params[\"threads\"], params[\"friends\"])\n\n# Register serializer and deserializer the BadClass:\nray.util.register_serializer(\n  BadClass, serializer=custom_serializer, deserializer=custom_deserializer)\nray.get(ray.put(i))\n```", "```py\nfrom ray.util.placement_group import (\n    placement_group,\n    placement_group_table,\n    remove_placement_group\n)\n```", "```py\n# Create a placement group.\ncpu_bundle = {\"CPU\": 3}\nmini_cpu_bundle = {\"CPU\": 1}\npg = placement_group([cpu_bundle, mini_cpu_bundle])\nray.get(pg.ready())\nprint(placement_group_table(pg))\nprint(ray.available_resources())\n# Run remote_fun in cpu_bundle\nhandle = remote_fun.options(placement_group=pg, \nplacement_group_bundle_index=0).remote(1)\n```", "```py\n# Create a placement group.\ncpu_bundle = {\"CPU\": 1}\ngpu_bundle = {\"GPU\": 1}\npg = placement_group([cpu_bundle, gpu_bundle])\nray.get(pg.ready())\nprint(placement_group_table(pg))\nprint(ray.available_resources())\n```", "```py\nruntime_env = {\"pip\": [\"bs4\"]}\n```", "```py\nruntime_env = {\"pip\": \"requirements.txt\"}\n```", "```py\n    ray.init(num_cpus=20, runtime_env=runtime_env)\n```", "```py\n@ray.remote(runtime_env=runtime_env)\ndef sup(x):\n    from bs4 import BeautifulSoup\n```", "```py\nclass ParseKwargs(argparse.Action):\n   def __call__(self, parser, namespace, values, option_string=None):\n       setattr(namespace, self.dest, dict())\n       for value in values:\n           key, value = value.split('=')\n           getattr(namespace, self.dest)[key] = value\n\nparser = argparse.ArgumentParser()\nparser.add_argument('-k', '--kwargs', nargs='*', action=ParseKwargs)\nargs = parser.parse_args()\n\nnumberOfIterations = int(args.kwargs[\"iterations\"])\nprint(f\"Requested number of iterations is: {numberOfIterations}\")\n\nprint(f'Environment variable MY_VARIABLE has a value \" +\nf\"of {os.getenv(\"MY_VARIABLE\")}')\n\nray.init()\n\n@ray.remote\nclass Counter:\n   def __init__(self):\n       self.counter = 0\n\n   def inc(self):\n       self.counter += 1\n\n   def get_counter(self):\n       return self.counter\n\ncounter = Counter.remote()\n\nfor _ in range(numberOfIterations):\n   ray.get(counter.inc.remote())\n   print(ray.get(counter.get_counter.remote()))\n\nprint(\"Requests\", requests.__version__)\nprint(\"Qiskit\", qiskit.__version__)\n```", "```py\nclient = JobSubmissionClient(\"*`<your Ray URL>`*\")\n\njob_id = client.submit_job(\n   # Entrypoint shell command to execute\n   entrypoint=\"python script_with_parameters.py --kwargs iterations=7\",\n   # Working dir\n   runtime_env={\n       \"working_dir\": \".\",\n       \"pip\": [\"requests==2.26.0\", \"qiskit==0.34.2\"],\n       \"env_vars\": {\"MY_VARIABLE\": \"foo\"}\n   }\n)\n\nprint(f\"Submitted job with ID : {job_id}\")\n\nwhile True:\n   status = client.get_job_status(job_id)\n   print(f\"status: {status}\")\n   if status in {JobStatus.SUCCEEDED, JobStatus.STOPPED, JobStatus.FAILED}:\n       break\n   time.sleep(5)\n\nlogs = client.get_job_logs(job_id)\nprint(f\"logs: {logs}\")\n```"]