["```py\ndef close_kitchen_if_past_close(point_in_time: datetime.datetime): ![1](../images/00002.gif)\n    if point_in_time >= closing_time():\n        close_kitchen()\n        log_time_closed(point_in_time)\n```", "```py\n# CustomDateTime offers all the same functionality with\n# datetime.datetime. I'm using it here for its better\n# logging facilities.\nclose_kitchen_if_past_close(CustomDateTime(\"now\")) # no error\n```", "```py\ndef schedule_restaurant_open(open_time, workers_needed):\n```", "```py\nimport datetime\nimport random\n\ndef schedule_restaurant_open(open_time: datetime.datetime,\n                             workers_needed: int):\n    workers = find_workers_available_for_time(open_time)\n    # Use random.sample to pick X available workers\n    # where X is the number of workers needed.\n    for worker in random.sample(workers, workers_needed):\n        worker.schedule(open_time)\n```", "```py\ndef find_workers_available_for_time(open_time: datetime.datetime):\n```", "```py\ndef find_workers_available_for_time(open_time: datetime.datetime):\n    workers = worker_database.get_all_workers()\n    available_workers = [worker for worker in workers\n                           if is_available(worker)]\n    if available_workers:\n        return available_workers\n\n    # fall back to workers who listed they are available\n    # in an emergency\n    emergency_workers = [worker for worker in get_emergency_workers()\n                           if is_available(worker)]\n\n    if emergency_workers:\n        return emergency_workers\n\n    # Schedule the owner to open, they will find someone else\n    return [OWNER]\n```", "```py\ndef find_workers_available_for_time(open_time: datetime.datetime) -> list[str]:\n```", "```py\nfrom typing import Dict,List\nAuthorToCountMapping = Dict[str, int]\ndef count_authors(\n                   cookbooks: List[Cookbook]\n                 ) -> AuthorToCountMapping:\n    # ...\n```", "```py\nworkers: list[str] = find_workers_available_for_time(open_time)\nnumbers: list[int] = []\nratio: float = get_ratio(5,3)\n```", "```py\nnumber: int = 0\ntext: str = \"useless\"\nvalues: list[float] = [1.2, 3.4, 6.0]\nworker: Worker = Worker()\n```", "```py\n>>> a: int = 5\n>>> a = \"string\"\n>>> a\n\"string\"\n```", "```py\na: int = 5\na = \"string\"\n```", "```py\nmypy invalid_type.py\n\nchapter3/invalid_type.py:2: error: Incompatible types in assignment\n                            (expression has type \"str\", variable has type\n                             \"int\")\nFound 1 error in 1 file (checked 1 source file)\n```", "```py\ndef read_file_and_reverse_it(filename: str) -> str:\n    with open(filename) as f:\n        # Convert bytes back into str\n        return f.read().encode(\"utf-8\")[::-1]\n```", "```py\nmypy chapter3/invalid_example1.py\nchapter3/invalid_example1.py:3: error: Incompatible return value type\n                                       (got \"bytes\", expected \"str\")\nFound 1 error in 1 file (checked 1 source file)\n```", "```py\n# takes a list and adds the doubled values\n# to the end\n# [1,2,3] => [1,2,3,2,4,6]\ndef add_doubled_values(my_list: list[int]):\n    my_list.update([x*2 for x in my_list])\n\nadd_doubled_values([1,2,3])\n```", "```py\nmypy chapter3/invalid_example2.py\nchapter3/invalid_example2.py:6: error: \"list[int]\" has no attribute \"update\"\nFound 1 error in 1 file (checked 1 source file)\n```", "```py\n# The restaurant is named differently\n# in different parts of the world\ndef get_restaurant_name(city: str) -> str:\n    if city in ITALY_CITIES:\n            return \"Trattoria Viafore\"\n    if city in GERMANY_CITIES:\n            return \"Pat's Kantine\"\n    if city in US_CITIES:\n            return \"Pat's Place\"\n    return None\n\nif get_restaurant_name('Boston'):\n    print(\"Location Found\")\n```", "```py\nchapter3/invalid_example3.py:14: error: Incompatible return value type\n                                        (got \"None\", expected \"str\")\nFound 1 error in 1 file (checked 1 source file)\n```"]