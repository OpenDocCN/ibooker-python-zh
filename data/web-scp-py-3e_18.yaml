- en: Chapter 16\. Image Processing and Text Recognition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章 图像处理与文本识别
- en: 'From Google’s self-driving cars to vending machines that recognize counterfeit
    currency, machine vision is a huge field with far-reaching goals and implications.
    This chapter focuses on one small aspect of the field: text recognition—specifically,
    how to recognize and use text-based images found online by using a variety of
    Python libraries.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从谷歌的自动驾驶汽车到能够识别假钞的自动售货机，机器视觉是一个具有深远目标和影响的广阔领域。本章专注于该领域的一个小方面：文本识别——具体而言，如何利用各种Python库识别和使用在线找到的基于文本的图像。
- en: Using an image in lieu of text is a common technique when you don’t want text
    to be found and read by bots. This is often seen on contact forms when an email
    address is partially or completely rendered as an image. Depending on how skillfully
    it is done, it might not even be noticeable to human viewers, but bots have a
    difficult time reading these images, and the technique is enough to stop most
    spammers from acquiring your email address.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不希望文本被机器人发现和阅读时，使用图像代替文本是一种常见的技术。这在联系表单上经常见到，当电子邮件地址部分或完全呈现为图像时。取决于执行的技巧如何，这甚至可能对人类观众不可察觉，但机器人很难读取这些图像，这种技术足以阻止大多数垃圾邮件发送者获取您的电子邮件地址。
- en: CAPTCHAs, of course, take advantage of the fact that users can read security
    images but most bots can’t. Some CAPTCHAs are more difficult than others, an issue
    we’ll tackle later in this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，CAPTCHA利用了用户能够阅读安全图像而大多数机器人不能的事实。一些CAPTCHA比其他更难，这是我们将在本书后面解决的问题。
- en: But CAPTCHAs aren’t the only place on the web where scrapers need image-to-text
    translation assistance. Even to, many documents are scanned from hard copies and
    put on the web, making these documents inaccessible as far as much of the internet
    is concerned, although they are “hiding in plain sight.” Without image-to-text
    capabilities, the only way to make these documents accessible is for a human to
    type them up by hand—and nobody has time for that.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但CAPTCHA并不是网络上唯一需要图像转文本翻译帮助的地方。甚至很多文档都是从硬拷贝扫描并放在网络上，这使得这些文档对大部分互联网用户而言是无法访问的，尽管它们就在“人们的视线之中”。没有图像转文本的能力，唯一的方法是让人类手动输入它们，但谁有时间做这件事呢。
- en: Translating images into text is called *optical character recognition*, or *OCR*.
    A few major libraries can perform OCR, and many other libraries support them or
    are built on top of them. This system of libraries can get fairly complicated,
    so I recommend you read the next section before attempting any of the exercises
    in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像转换为文本称为*光学字符识别*（OCR）。一些主要的库可以执行OCR，许多其他库支持它们或构建在它们之上。这些库体系相当复杂，因此建议您在尝试本章中的任何练习之前先阅读下一节。
- en: All example images used throughout this chapter can be found in the GitHub repository
    folder *Chapter16_ImageProcessingFiles*. For the sake of brevity, all in-text
    code samples will refer to this directory simply as *files*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有示例图像都可以在GitHub仓库文件夹*Chapter16_ImageProcessingFiles*中找到。为简洁起见，所有文中代码示例将简称为*files*目录。
- en: Overview of Libraries
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库概述
- en: 'Python is a fantastic language for image processing and reading, image-based
    machine-learning, and even image creation. Although many libraries can be used
    for image processing, I’ll focus on two: Pillow and Tesseract.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python是处理图像和阅读、基于图像的机器学习甚至图像创建的绝佳语言。虽然有许多库可用于图像处理，但我将专注于两个：Pillow和Tesseract。
- en: These two libraries make for a powerful complementary duo when it comes to processing
    and doing OCR on images from around the web. *Pillow* performs the first pass,
    cleaning and filtering images, and *Tesseract* attempts to match the shapes found
    in those images to its library of known text.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理并对来自网络的图像进行OCR时，这两个库组成了一个强大的互补二重奏。*Pillow*执行第一次清理和过滤图像，*Tesseract*则尝试将这些图像中找到的形状与其已知文本库进行匹配。
- en: This chapter covers their installation and basic usage, along with several examples
    of this library duo working together. I’ll also cover some advanced Tesseract
    training, so that you can train Tesseract to OCR additional fonts and languages
    (or even CAPTCHAs) that you might encounter on the web.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了它们的安装和基本使用，以及这两个库一起工作的几个示例。我还将介绍一些高级的Tesseract训练，以便您可以训练Tesseract识别您可能在网络上遇到的额外字体和语言（甚至是CAPTCHA）。
- en: Pillow
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pillow
- en: Although Pillow might not be the most fully featured image-processing library,
    it has all the features you are likely to need and then some—unless you plan to
    rewrite Photoshop in Python, in which case you’re reading the wrong book! Pillow
    also has the advantage of being one of the better-documented third-party libraries
    and is extremely easy to use out of the box.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Pillow 可能不是最全功能的图像处理库，但它具有您可能需要的所有功能，甚至更多——除非您计划用 Python 重写 Photoshop，否则您读的不是这本书！Pillow
    还有一个优点，即是其中一些更好文档化的第三方库之一，并且非常容易上手使用。
- en: 'Forked off the Python Imaging Library (PIL) for Python 2.x, Pillow adds support
    for Python 3.x. Like its predecessor, Pillow allows you to easily import and manipulate
    images with a variety of filters, masks, and even pixel-specific transformations:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 'Forked off the Python Imaging Library (PIL) for Python 2.x, Pillow adds support
    for Python 3.x. Like its predecessor, Pillow allows you to easily import and manipulate
    images with a variety of filters, masks, and even pixel-specific transformations:'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, the image *kitten.jpg* will open in your default image
    viewer with a blur added to it and will also be saved in its blurrier state as
    *kitten_blurred.jpg* in the same directory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，*kitten.jpg* 图像将在您默认的图像查看器中打开，并添加模糊效果，同时也会保存为同一目录下更模糊的 *kitten_blurred.jpg*。
- en: You will use Pillow to perform preprocessing on images to make them more machine
    readable, but as mentioned before, you can do many other things with the library
    aside from these simple filter applications. For more information, check out the
    [Pillow documentation](http://pillow.readthedocs.org).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用 Pillow 对图像执行预处理，使其更易于机器读取，但正如前面提到的，您也可以使用该库进行许多其他操作，而不仅仅是这些简单的滤镜应用。欲了解更多信息，请查看
    [Pillow 文档](http://pillow.readthedocs.org)。
- en: Tesseract
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tesseract
- en: Tesseract is an OCR library. Sponsored by Google (a company obviously well-known
    for its OCR and machine-learning technologies), Tesseract is widely regarded to
    be the best, most accurate, open source OCR system available.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Tesseract 是一个 OCR 库。由 Google 赞助（一个显然以其 OCR 和机器学习技术而闻名的公司），Tesseract 被普遍认为是目前最好、最准确的开源
    OCR 系统。
- en: In addition to being accurate, it is also extremely flexible. It can be trained
    to recognize any number of fonts (as long as those fonts are relatively consistent
    within themselves, as you will see soon). It also can be expanded to recognize
    any Unicode character.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了准确外，它还非常灵活。它可以被训练来识别任何数量的字体（只要这些字体在自身内部相对一致，您很快就会看到）。它还可以扩展到识别任何 Unicode 字符。
- en: This chapter uses both the command-line program *Tesseract* along with its third-party
    Python wrapper *pytesseract*. Both will be explicitly named as one of these two,
    so know that when you see Tesseract, I’m referring to the command-line software,
    and when you see pytesseract, I’m specifically referring to its third-party Python
    wrapper.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章同时使用命令行程序 *Tesseract* 及其第三方 Python 包装 *pytesseract*。这两者将明确命名为其中的一个，所以当您看到
    Tesseract 时，我指的是命令行软件，当您看到 pytesseract 时，我特指它的第三方 Python 包装。
- en: Installing Tesseract
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Tesseract
- en: For Windows users, there is a convenient [executable installer](https://code.google.com/p/tesseract-ocr/downloads/list). As
    of this writing, the current version is 3.02, although newer versions should be
    fine as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 用户，有一个方便的 [可执行安装程序](https://code.google.com/p/tesseract-ocr/downloads/list)。截至目前，当前版本是
    3.02，尽管新版本也应该是可以的。
- en: 'Linux users can install Tesseract with `apt-get`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 用户可以使用 `apt-get` 安装 Tesseract：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Installing Tesseract on a Mac is slightly more complicated, although it can
    be done easily with many third-party installers, such as [Homebrew](http://brew.sh),
    which was used in [Chapter 9](ch09.html#c-9) to install MySQL. For example, you
    can install Homebrew and use it to install Tesseract in two lines:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上安装 Tesseract 稍微复杂一些，但可以通过许多第三方安装程序轻松完成，例如 [Homebrew](http://brew.sh)，它在
    [第9章](ch09.html#c-9) 中用于安装 MySQL。例如，您可以安装 Homebrew 并使用它在两行命令中安装 Tesseract：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tesseract also can be installed from the source, on the [project’s download
    page](https://code.google.com/p/tesseract-ocr/downloads/list).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Tesseract 也可以从源代码安装，在[项目的下载页面](https://code.google.com/p/tesseract-ocr/downloads/list)。
- en: 'To convert images to text, Tesseract uses machine learning models that have
    been trained on large datasets in various languages (or sets of characters). To
    view the available models that come with your installation, use the command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像转换为文本，Tesseract 使用在各种语言（或字符集）的大型数据集上训练过的机器学习模型。要查看安装的可用模型，请使用以下命令：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will print the directory where the models are stored (*/usr/local/share*
    on Linux, and */opt/homebrew/share/tessdata/* on a Mac installed with HomeBrew)
    and the models that are available.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印存储模型的目录（在Linux上是*/usr/local/share*，在使用HomeBrew安装的Mac上是*/opt/homebrew/share/tessdata/*），以及可用的模型。
- en: After Tesseract is installed, you’re ready to install the Python wrapper library,
    pytesseract, which uses your existing Tesseract installation to read image files
    and output strings and objects that can be used in Python scripts.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Tesseract后，您可以准备安装Python包装库pytesseract，它使用您现有的Tesseract安装来读取图像文件并输出可在Python脚本中使用的字符串和对象。
- en: 'As usual, you can install pytesseract via pip:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，您可以通过pip安装pytesseract：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Pytesseract can be used in conjunction with PIL to read text from images:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Pytesseract可以与PIL结合使用从图像中读取文本：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If pytesseract does not recognize that you have Tesseract installed, you can
    get the location of your Tesseract installation using the command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果pytesseract无法识别您是否已安装了Tesseract，则可以使用以下命令获取您的Tesseract安装位置：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'and, in Python, point pytesseract to the location by including this line:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在Python中，通过包含这一行来指定pytesseract的位置：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Pytesseract has several useful features in addition to returning the OCR results
    of an image as in the code sample above. It can estimate box files (pixel locations
    for the boundaries of each character):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Pytesseract除了像上面代码示例中返回图像OCR结果之外，还有几个有用的功能。它可以估算框文件（每个字符边界的像素位置）：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It can also return a complete output of all data, such as confidence scores,
    page and line numbers, box data, as well as other information:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以返回所有数据的完整输出，如置信度分数、页数和行数、框数据以及其他信息：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The default output for these last two files is as space- or tab-delimited string
    files, but you can also get output as dictionaries or (if decoding in UTF-8 isn’t
    sufficient) byte strings:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件的默认输出为以空格或制表符分隔的字符串文件，但您也可以将输出作为字典或（如果UTF-8解码不够用）字节字符串获取：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This chapter uses a combination of the pytesseract library, as well as command-line
    Tesseract and triggering Tesseract from Python via the `subprocess` library. Although
    the pytesseract library is useful and convenient, there are some Tesseract functions
    it cannot do, so it’s good to be familiar with all methods.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节同时使用了pytesseract库和通过`subprocess`库从Python触发Tesseract的命令行Tesseract。虽然pytesseract库很有用且方便，但它无法完成一些Tesseract函数，因此熟悉所有方法是很好的。
- en: NumPy
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy
- en: While NumPy is not required for straightforward OCR, you will need it if you
    want to train Tesseract to recognize additional character sets or fonts introduced
    later in this chapter. You will also be using it for simple math tasks (such as
    weighted averages) in some of the code samples later in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然NumPy对于简单的OCR并非必需，但如果您想要在本章后面介绍的训练Tesseract识别额外字符集或字体，您将需要它。您还将在本章后面的某些代码示例中使用它进行简单的数学任务（如加权平均数）。
- en: NumPy is a powerful library used for linear algebra and other large-scale math
    applications. NumPy works well with Tesseract because of its ability to mathematically
    represent and manipulate images as large arrays of pixels.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy是用于线性代数和其他大规模数学应用的强大库。NumPy与Tesseract配合良好，因为它能够将图像数学地表示为大型像素数组并进行操作。
- en: NumPy can be installed using any third-party Python installer such as pip, or
    by [downloading the package](https://pypi.python.org/pypi/numpy) and installing
    with `$ python setup.py install`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy可以通过任何第三方Python安装器如pip来安装，或者通过[下载软件包](https://pypi.python.org/pypi/numpy)并使用`$
    python setup.py install`进行安装。
- en: Even if you don’t plan on running any of the code samples that use it, I highly
    recommend installing it or adding it to your Python arsenal. It serves to round
    out Python’s built-in math library and has many useful features, particularly
    for operations with lists of numbers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不打算运行使用它的代码示例，我强烈建议您安装它或将其添加到Python工具库中。它有助于完善Python的内置数学库，并具有许多有用的特性，特别是对于操作数字列表。
- en: 'By convention, NumPy is imported as `np` and can be used as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，NumPy作为`np`导入，并且可以如下使用：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example prints the standard deviation and mean of the set of numbers provided
    to it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例打印了提供给它的数字集的标准差和均值。
- en: Processing Well-Formatted Text
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理格式良好的文本
- en: With any luck, most of the text that you’ll need to process will be relatively
    clean and well formatted. Well-formatted text generally meets several requirements,
    although the line between what is “messy” and what is “well formatted” can be
    subjective.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的话，大多数需要处理的文本应该相对干净且格式良好。格式良好的文本通常符合几个要求，尽管“混乱”和“格式良好”之间的界限可能是主观的。
- en: 'In general, well-formatted text:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，格式良好的文本
- en: Is written in one standard font (excluding handwriting fonts, cursive fonts,
    or excessively decorative fonts)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以一种标准字体书写（不包括手写字体、草书字体或过度装饰的字体）
- en: If copied or photographed, has extremely crisp lines, with no copying artifacts
    or dark spots
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果复制或拍摄，具有极其清晰的线条，没有复制伪影或黑斑
- en: Is well aligned, without slanted letters
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对齐良好，没有倾斜的字母
- en: Does not run off the image, nor is there cut-off text or margins on the edges
    of the image
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不会跑到图像之外，也没有截断的文本或图像边缘的边距
- en: Some of these things can be fixed in preprocessing. For instance, images can
    be converted to grayscale, brightness and contrast can be adjusted, and the image
    can be cropped and rotated as needed. However, some fundamental limitations might
    require more extensive training. See [“Reading CAPTCHAs and Training Tesseract”](#reading_caps_train_tesser).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些问题可以在预处理中修复。例如，图像可以转换为灰度，亮度和对比度可以调整，根据需要可以裁剪和旋转图像。但是，某些基本限制可能需要更广泛的训练。请参阅[“阅读CAPTCHA和训练Tesseract”](#reading_caps_train_tesser)。
- en: '[Figure 16-1](#tesseract_tiff) is an ideal example of well-formatted text.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 16-1](#tesseract_tiff)是格式良好文本的理想示例。'
- en: '![Alt Text](assets/wsp3_1601.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Alt Text](assets/wsp3_1601.png)'
- en: Figure 16-1\. Sample text saved as a .tiff file, to be read by Tesseract
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-1\. 保存为.tiff文件以供Tesseract读取的示例文本
- en: 'In the *files* directory, you can run Tesseract from the command line to read
    this file and write the results to a text file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在*files*目录中，您可以从命令行运行Tesseract来读取此文件并将结果写入文本文件：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output contains the contents of the newly created *textoutput.txt* file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出包含新创建的*textoutput.txt*文件的内容：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see that the results are mostly accurate, although it added an extra
    pipe character between the `!` and the `@`. On the whole, though, this lets you
    read the text fairly comfortably.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到结果大多是准确的，尽管它在`!`和`@`之间添加了额外的竖线字符。总体而言，这使您能够相当舒适地阅读文本。
- en: After blurring the image text, creating some JPG compression artifacts, and
    adding a slight background gradient, the Tesseract’s results get much worse (see
    [Figure 16-2](#bad_jpg)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在模糊图像文本、创建一些JPG压缩伪影和添加轻微背景渐变后，Tesseract的结果变得更糟（见[图 16-2](#bad_jpg)）。
- en: '![Alt Text](assets/wsp3_1602.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Alt Text](assets/wsp3_1602.png)'
- en: Figure 16-2\. Unfortunately, many of the documents you will encounter on the
    internet will look more like this than the previous example
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-2\. 不幸的是，您在互联网上遇到的许多文档更像是这种情况，而不是前面的例子
- en: 'Rather than write the results to a file, you can also pass a dash character
    (`-`) where the filename would normally be, and Tesseract will echo the results
    to the terminal:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将结果写入文件，您还可以在文件名通常出现的地方传递一个破折号（`-`），Tesseract将结果回显到终端：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Tesseract is not able to deal with this image nearly as well mainly because
    of the background gradient and produces the following output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Tesseract由于背景渐变的原因无法处理此图像，因此产生了以下输出：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that the text is cut off as soon as the background gradient makes the
    text more difficult to distinguish, and that the last character from each line
    is wrong, as Tesseract tries futilely to make sense of it. In addition, the JPG
    artifacts and blurring make it difficult for Tesseract to distinguish between
    a lowercase *i* and an uppercase *I* and the number *1*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦背景渐变使文本更难以区分，文本就会被截断，并且每行的最后一个字符都是错误的，因为Tesseract试图徒劳地理解它。此外，JPG伪影和模糊使得Tesseract难以区分小写字母*i*和大写字母*I*以及数字*1*。
- en: This is where using a Python script to clean your images first comes in handy.
    Using the Pillow library, you can create a threshold filter to get rid of the
    gray in the background, bring out the text, and make the image clearer for Tesseract
    to read.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用Python脚本首先清理图像非常方便。使用Pillow库，您可以创建一个阈值滤镜来去除背景中的灰色，突出文本，并使图像更清晰，以便Tesseract读取。
- en: 'In addition, instead of using Tesseract from the command line, you can use
    the pytesseract library to run the Tesseract commands and read the resulting file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用pytesseract库而不是从命令行使用Tesseract来运行Tesseract命令并读取生成的文件：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The resulting image, automatically created as *text_cleaned.png*, is shown in
    [Figure 16-3](#better_image).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图像被自动创建为 *text_cleaned.png*，如 [图16-3](#better_image) 所示。
- en: '![Alt Text](assets/wsp3_1603.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Alt Text](assets/wsp3_1603.png)'
- en: Figure 16-3\. This image was created by passing the previous “messy” version
    of the image through a threshold filter
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图16-3。通过将图像的前一“混乱”版本通过阈值过滤器进行处理而创建的图像
- en: 'Apart from some barely legible or missing punctuation, the text is readable,
    at least to us. Tesseract gives it its best shot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一些几乎难以辨认或缺失的标点符号外，文本是可读的，至少对我们来说是这样。Tesseract 尽力而为：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The periods and commas, being extremely small, are the first victims of this
    image wrangling and nearly disappear, both from our view and Tesseract’s. There’s
    also the unfortunate misinterpretation of “Arial” as “Anal,” the result of Tesseract
    interpreting the *r* and the *i* as the single character *n*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号和句号非常小，是图像整理的首要受害者，几乎从我们的视野和 Tesseract 的视野中消失。还有不幸的是，Tesseract 将“Arial”误解为“Anal”，这是
    Tesseract 将 *r* 和 *i* 解释为单个字符 *n* 的结果。
- en: Still, it’s an improvement over the previous version, in which nearly half of
    the text was cut off.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，它仍然比之前的版本有所改进，其中近一半的文本被切掉。
- en: Tesseract’s greatest weakness seems to be backgrounds with varying brightness.
    Tesseract’s algorithms attempt to adjust the contrast of the image automatically
    before reading the text, but you can probably get better results doing this yourself
    with a tool like the Pillow library.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Tesseract 最大的弱点似乎是背景亮度不均。Tesseract 的算法在读取文本之前尝试自动调整图像的对比度，但使用类似 Pillow 库这样的工具可能会获得更好的结果。
- en: Images you should definitely fix before submitting to Tesseract are those that
    are tilted, have large areas of nontext, or have other problems.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 提交给 Tesseract 之前绝对需要修复的图像包括倾斜的图像、有大量非文本区域或其他问题的图像。
- en: Adjusting Images Automatically
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动调整图像
- en: In the previous example, the value 143 was chosen experimentally as the “ideal”
    threshold to adjust all image pixels to black or white, in order for Tesseract
    to read the image. But what if you have many images, all with slightly different
    grayscale problems, and aren’t reasonably able to go and adjust all of them by
    hand?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，值143被实验性地选择为将所有图像像素调整为黑色或白色以便 Tesseract 读取图像的“理想”阈值。但是，如果您有许多图像，所有图像都有稍有不同的灰度问题，并且无法合理地手动调整所有图像，那该怎么办？
- en: One way to find the best solution (or at least, a pretty good one) is to run
    Tesseract against a range of images adjusted to different values and algorithmically
    choose the one with the best result, as measured by some combination of the number
    of characters and/or strings Tesseract is able to read, and the “confidence” with
    which it reads those characters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 找到最佳解决方案（或至少是相当不错的解决方案）的一种方法是对一系列调整到不同值的图像运行 Tesseract，并通过某种组合来选择最佳结果，这些组合包括
    Tesseract 能够读取的字符和/或字符串的数量以及它读取这些字符的“置信度”。
- en: 'Which algorithm you use, exactly, may vary slightly from application to application,
    but this is one example of iterating through image-processing thresholds to find
    the “best” setting:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用的确切算法可能因应用程序而异，但以下是通过图像处理阈值进行迭代以找到“最佳”设置的一个示例：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This script has two functions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本有两个功能：
- en: '`cleanFile`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`cleanFile`'
- en: Takes in an original “bad” file and a threshold variable to run the PIL threshold
    tool with. It processes the file and returns the PIL image object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接收原始的“坏”文件和一个阈值变量以运行 PIL 阈值工具。它处理文件并返回 PIL 图像对象。
- en: '`getConfidence`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`getConfidence`'
- en: Takes in the cleaned PIL image object and runs it through Tesseract. It calculates
    the average confidence of each recognized string (weighted by the number of characters
    in that string), as well as the number of recognized characters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接收清理后的 PIL 图像对象并将其传递给 Tesseract。它计算每个识别字符串的平均置信度（按该字符串中的字符数加权），以及识别字符的数量。
- en: 'By varying the threshold value and getting the confidence and number of recognized
    characters at each value, you get the output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变阈值并在每个值上获取识别字符的置信度和数量，您可以得到输出：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is a clear trend among both the average confidence in the result, as well
    as the number of characters recognized. Both tend to peak around a threshold of
    145, which is close to the manually found “ideal” result of 143.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是结果中的平均置信度还是识别字符的数量，都显示出明显的趋势。两者都倾向于在阈值约为145时达到峰值，这接近手动找到的“理想”结果143。
- en: Thresholds of both 140 and 145 give the maximum number of recognized characters
    (83), but a threshold of 145 gives the highest confidence for those found characters,
    so you may want to go with that result and return the text that was recognized
    at that threshold as the “best guess” for what text the image contains.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 140和145的阈值都给出了最大数量的识别字符（83个），但是145的阈值为这些找到的字符提供了最高的置信度，因此您可能希望选择该结果，并返回在该阈值下被识别为图像包含的文本的“最佳猜测”。
- en: Of course, simply finding the “most” characters does not necessarily mean that
    all of those characters are real. At some thresholds, Tesseract could split single
    characters into multiple ones, or interpret random noise in the image as a text
    character that doesn’t actually exist. In this case, you may want to rely more
    heavily on the average confidence of each score.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅找到“最多”字符并不一定意味着所有这些字符都是真实的。在某些阈值下，Tesseract可能会将单个字符拆分为多个字符，或者将图像中的随机噪声解释为实际不存在的文本字符。在这种情况下，您可能更倾向于更重视每个评分的平均置信度。
- en: 'For example, if you find results that read (in part):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你找到的结果读取（部分）：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: it would probably be a no-brainer to go with the result that gives you over
    a 20% increase in confidence, with only a one-character loss, and assume that
    the result with a threshold of 145 was simply incorrect, or perhaps split a character
    or found something that wasn’t there.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果让您的置信度增加超过20％，仅丢失一个字符，并假设145的阈值结果仅仅是不正确的，或者可能分割一个字符或者找到了不存在的东西，那么选择该结果可能是个明智的选择。
- en: This is the part where some up-front experimentation to perfect your threshold
    selection algorithm may come in handy. For instance, you may want to select the
    score for which the *product* of the confidence and the number of characters is
    maximized (in this case, 145 still wins with a product of 6272, and in our imaginary
    example, the threshold 150 would win with a product of 7964) or some other metric.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是某些前期实验用于完善您的阈值选择算法可能会派上用场的部分。例如，您可能希望选择其置信度和字符数的*乘积*最大化的得分（在本例中，145仍以6272的产品获胜，在我们的想象例子中，阈值150以7964的产品获胜），或者其他某种度量。
- en: Note that this type of selection algorithm also works with arbitrary PIL tool
    values besides just `threshold`. You also can use it to select two or more values
    by varying the values of each and similarly selecting the best resulting score.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此类选择算法除了仅限于`threshold`之外，还适用于任意PIL工具值。您还可以通过改变每个值的值来选择两个或多个值，并以类似的方式选择最佳结果分数。
- en: Obviously, this type of selection algorithm is computationally intensive. You’re
    running both PIL and Tesseract many times on every single image, whereas if you
    know the “ideal” threshold values ahead of time, you have to run them only once.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种选择算法在计算上是非常密集的。您在每张图片上都要运行PIL和Tesseract多次，而如果您事先知道“理想”的阈值值，您只需运行它们一次。
- en: Keep in mind that, as you start to work with the images you’re processing, you
    may start to notice patterns in the “ideal” values found. Instead of trying every
    threshold from 80 to 200, you may realistically need to try only thresholds from
    130 to 180.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当您开始处理的图像时，您可能会开始注意到找到的“理想”值中的模式。而不是尝试从80到200的每个阈值，您可能实际上只需要尝试从130到180的阈值。
- en: You may even take another approach and choose thresholds that are, say, 20 apart
    on the first pass, and then use a greedy algorithm to hone in on the best result
    by decreasing your step size for thresholds between the “best” solutions found
    in the previous iteration. This may also work best when you’re dealing with multiple
    variables.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以采用另一种方法，并选择首次通过时间间隔为20的阈值，然后使用贪心算法在前一次迭代中找到的“最佳”解决方案之间减小您的阈值步长，以获得最佳结果。当您处理多个变量时，这种方法可能也是最佳的。
- en: Scraping Text from Images on Websites
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从网站上的图像中抓取文本
- en: Using Tesseract to read text from an image on your hard drive might not seem
    all that exciting, but it can be a powerful tool when used with a web scraper.
    Images can inadvertently obfuscate text on websites (as with the JPG copy of a
    menu on a local restaurant site), but they can also purposefully hide the text,
    as I’ll show in the next example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Tesseract从硬盘上的图像中读取文本可能并不那么令人兴奋，但是当与网页抓取器一起使用时，它可以成为一个强大的工具。图片在网站上可能会无意中混淆文本（例如在本地餐馆网站上的菜单的JPG副本），但它们也可以有意地隐藏文本，正如我将在下一个例子中展示的那样。
- en: Although Amazon’s *robots.txt* file allows scraping of the site’s product pages,
    book previews typically don’t get picked up by passing bots. That’s because the
    book previews are loaded via user-triggered Ajax scripts, and the images are carefully
    hidden in layers of divs and an iframe. Of course, even if you could get to the
    images, there’s the not-so-small matter of reading them as text.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管亚马逊的 *robots.txt* 文件允许爬取其产品页面，但书籍预览通常不会被通过的爬虫所捕捉到。这是因为书籍预览是通过用户触发的Ajax脚本加载的，图像被精心隐藏在多层的div和iframe中。当然，即使你能访问这些图像，还有一个不小的问题是将它们作为文本进行阅读。
- en: 'The following script accomplishes just this feat: it navigates to the large-print
    edition of Tolstoy’s *The Death of Ivan Ilyich*, opens the reader, collects image
    URLs, and then systematically downloads, reads, and prints the text from each
    one.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本就实现了这一壮举：它导航到托尔斯泰的大字版《伊凡·伊里奇之死》，打开阅读器，收集图像网址，然后系统地从每一个图像中下载、阅读和打印文本。
- en: Picking a Test Subject
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个测试主题
- en: When it comes to processing fonts it hasn’t been trained on, Tesseract fares
    much better with large-format editions of books, especially if the images are
    small. The next section covers how to train Tesseract on different fonts, which
    can help it read much smaller font sizes, including previews for non-large-print
    book editions!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到处理它未经训练的字体时，Tesseract在处理大格式的书籍版本时表现得更好，特别是如果图像较小。下一节将介绍如何训练Tesseract以识别不同字体，这可以帮助它读取包括非大字版书籍预览在内的更小字号！
- en: Note that this code depends on a live Amazon listing as well as several architectural
    features of the Amazon website to run correctly. If this listing goes down or
    is replaced, please fill free to substitute the URL of another book with a Preview
    feature (I find that large print, sans serif fonts work well).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此代码依赖于亚马逊上的实时列表以及亚马逊网站的几个架构特性才能正确运行。如果此列表下架或更换，请随时用另一本具有预览功能的书籍URL进行替换（我发现大字版和无衬线字体效果良好）。
- en: 'Because this is relatively complex code that draws on multiple concepts from
    previous chapters, I’ve added comments throughout to make it a little easier to
    understand what’s going on:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个相对复杂的代码，整合了前几章的多个概念，我在整个过程中添加了注释，以便更容易理解正在进行的操作：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although this script can, in theory, be run with any type of Selenium webdriver,
    I’ve found that it currently works most reliably with Chrome.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管理论上这个脚本可以使用任何类型的Selenium webdriver运行，但我发现它目前与Chrome一起工作最为可靠。
- en: 'As you have experienced with the Tesseract reader before, this prints many
    long passages of the book mostly legibly, as seen in the preview of the first
    chapter:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前使用Tesseract阅读器时所经历的那样，它能够基本上清晰地打印出书籍的许多长段落，就像在第一章的预览中所看到的那样：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The large print and sans serif font makes for a flawless transcription of the
    images. In cases where errors in the transcription might occur, they can be fixed
    by making guesses based on a dictionary word list (perhaps with additions based
    on relevant proper nouns like “Melvinski”).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大字版和无衬线字体确保了图像的无误转录。在转录中可能出现错误的情况下，可以通过基于字典单词列表的猜测进行修正（也许还可以根据相关专有名词如“Melvinski”进行补充）。
- en: 'Occasionally, an error may span an entire word, such as on page three of the
    text:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，错误可能会涵盖整个单词，比如文本第三页上的情况：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case the word “I” is replaced by the character “1.” A Markov chain analysis
    might be useful here, in addition to a word dictionary. If any part of the text
    contains an extremely uncommon phrase (“and not 1”), it might be assumed that
    the text was actually the more common phrase (“and not I”).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，“I” 这个单词被字符 “1” 替换了。在这里，马尔科夫链分析可能会有所帮助，除了一个单词字典之外。如果文本的任何部分包含一个极不常见的短语（“and
    not 1”），则可以假设该文本实际上是更常见的短语（“and not I”）。
- en: 'Of course, it helps that these character substitutions follow predictable patterns:
    “vi” becomes “w,” and “I” becomes “1.” If these substitutions occur frequently
    in your text, you might create a list of them that can be used to “try” new words
    and phrases, selecting the solution that makes the most sense. An approach might
    be to substitute frequently confused characters, and use a solution that matches
    a word in a dictionary, or is a recognized (or most common) n-gram.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些字符替换遵循可预测的模式是有帮助的：“vi” 变成了 “w”，“I” 变成了 “1”。如果你的文本中这些替换经常发生，你可以创建一个列表，用来“尝试”新词和短语，选择最合理的解决方案。一种方法可能是替换频繁混淆的字符，并使用与字典中的词匹配的解决方案，或者是一个被认可的（或最常见的）n-gram。
- en: If you do take this approach, be sure to read [Chapter 12](ch12.html#c-12) for
    more information about working with text and natural language processing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择这种方法，请务必阅读[第12章](ch12.html#c-12)以获取有关处理文本和自然语言处理的更多信息。
- en: Although the text in this example is a common sans serif font and Tesseract
    should be able to recognize it with relative ease, sometimes a little retraining
    helps improve the accuracy as well. The next section discusses another approach
    to solving the problem of mangled text with a little up-front time investment.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此示例中的文本是常见的无衬线字体，Tesseract 应该能够相对容易地识别它，有时稍微重新训练也有助于提高准确性。下一节将讨论另一种解决错乱文本问题的方法，需事先投入一些时间。
- en: By providing Tesseract with a large collection of text images with known values,
    Tesseract can be “taught” to recognize the same font in the future with far greater
    precision and accuracy, even despite occasional background and positioning problems
    in the text.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为 Tesseract 提供大量具有已知值的文本图像集合，Tesseract 可以“学习”以便在将来更精确和准确地识别相同字体，即使文本中偶尔存在背景和位置问题。
- en: Reading CAPTCHAs and Training Tesseract
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读 CAPTCHA 并训练 Tesseract
- en: 'Although the word *CAPTCHA* is familiar to most, far fewer people know what
    it stands for: *Completely Automated Public Turing Test to Tell Computers and
    Humans Apart*. Its unwieldy acronym hints at its rather unwieldy role in obstructing
    otherwise perfectly usable web interfaces, as both humans and nonhuman robots
    often struggle to solve CAPTCHA tests.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数人熟悉 *CAPTCHA* 这个词，但很少有人知道它代表什么：*Completely Automated Public Turing Test
    to Tell Computers and Humans Apart*。它笨重的首字母缩略语暗示了它在阻碍本应完全可用的网络界面中的作用，因为人类和非人类机器人经常难以解决
    CAPTCHA 测试。
- en: The Turing test was first described by Alan Turing in his 1950 paper, “Computing
    Machinery and Intelligence.” In the paper, he described a theoretical scenario
    in which a human being could communicate with both humans and artificial intelligence
    programs through a computer terminal. If the human was unable to distinguish the
    humans from the AI programs during a casual conversation, the AI programs would
    be considered to have passed the Turing test. The artificial intelligence, Turing
    reasoned, would be genuinely “thinking” for all intents and purposes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵测试是由艾伦·图灵在其1950年的论文《计算机机器与智能》中首次描述的。在这篇论文中，他描述了一个理论情景，其中一个人可以通过计算机终端与人类和人工智能程序进行交流。如果在随意对话中，人类无法区分人类和AI程序，那么AI程序被认为通过了图灵测试。图灵推理认为，从所有意图和目的来看，人工智能会真正地“思考”。
- en: Seventy years after the theoretical inception of Turing tests, today CAPTCHAs
    are primarily used to infuriate humans rather than machines. In 2017, Google shut
    down its iconic  reCAPTCHA due in large part to its tendency to block legitimate
    website users.^([1](ch16.html#id831))  (See [Figure 16-4](#fig-16-4) for an example.)
    Many other companies followed suit, replacing the traditional text-based CAPTCHAs
    with alternative bot blockers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在图灵测试理论提出70年后，如今 CAPTCHA 主要用于激怒人类而不是机器。2017年，Google 关闭了其标志性的 reCAPTCHA，这在很大程度上是因为它倾向于阻止合法的网站用户。^[1](ch16.html#id831)（参见[图16-4](#fig-16-4)的例子。）许多其他公司也效仿，用替代性的防机器人程序替换传统的基于文本的
    CAPTCHA。
- en: '![](assets/wsp3_1604.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/wsp3_1604.png)'
- en: Figure 16-4\. Text from Google reCAPTCHA, prior to 2017
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-4\. Google reCAPTCHA 的文本，2017年之前
- en: Although CAPTCHAs have declined somewhat in popularity, they are still commonly
    used, especially on smaller sites. They are also useful as a source of sample
    “difficult” text for a computer to read. Perhaps your goal is not solving CAPTCHAs
    but reading badly scanned PDFs or handwritten notes. The principles are the same.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 CAPTCHA 的流行度有所下降，但它们仍然常用，尤其是在较小的网站上。它们还可以作为计算机阅读样本“困难”文本的来源。也许您的目标不是解决 CAPTCHA，而是阅读扫描不良的
    PDF 或手写笔记。但原则是相同的。
- en: With that in mind, I’ve created a form that robots are “blocked” from submitting
    because it requires solving a CAPTCHA: [*https://pythonscraping.com/humans-only/*](https://pythonscraping.com/humans-only/).
    In this section, you will train the Tesseract library on its specific font and
    text variations in order to solve this CAPTCHA with high reliability.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，我创建了一个表单，机器人“被阻止”提交，因为它需要解决一个 CAPTCHA：[*https://pythonscraping.com/humans-only/*](https://pythonscraping.com/humans-only/)。在这一部分中，您将训练
    Tesseract 库以识别其特定字体和文本变化，以便高可靠性地解决此 CAPTCHA。
- en: In case you are a robot and have trouble reading this image, “U8DG” is the solution
    to the CAPTCHA in [Figure 16-5](#fig-16-5). Tesseract, being a robot, certainly
    has trouble solving it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是机器人并且难以阅读此图像，“U8DG” 是[图 16-5](#fig-16-5)中 CAPTCHA 的解决方案。作为机器人的 Tesseract
    当然难以解决它。
- en: '![](assets/wsp3_1605.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/wsp3_1605.png)'
- en: Figure 16-5\. The bot-proof captcha at [*https://pythonscraping.com/humans-only/*](https://pythonscraping.com/humans-only/)
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-5\. 防机器人验证码位于[*https://pythonscraping.com/humans-only/*](https://pythonscraping.com/humans-only/)
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, Tesseract returns five characters (including a space) and gets
    only one of the characters, the uppercase D, correctly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Tesseract 返回五个字符（包括一个空格），并且只正确识别了一个字符，大写的 D。
- en: The issue isn’t that Tesseract is bad at reading text, or that this CAPTCHA
    is too difficult for a computer to comprehend—it’s that this particular handwriting
    font is dissimilar to the regular English-language fonts that Tesseract has been
    trained on “out of the box.” Fortunately, it is possible to train it to recognize
    additional fonts, characters, and languages.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 问题不在于 Tesseract 读取文本的能力差，或者这个验证码对计算机来说过于复杂——而是这种手写字体与 Tesseract "开箱即用" 的常规英文字体不同。幸运的是，可以训练它识别额外的字体、字符和语言。
- en: Training Tesseract
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 训练 Tesseract
- en: 'Whether you’re training for CAPTCHAs or any other text, there are a few factors
    to consider that greatly impact Tesseract’s performance and the approach you might
    take for training it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是为验证码还是任何其他文本进行训练，都有几个因素需要考虑，这些因素会极大地影响 Tesseract 的性能以及您训练的方法：
- en: Do characters overlap in the image, or can you draw a neat rectangle around
    each character without parts of any other character infringing on this rectangle?
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符是否在图像中重叠，或者您是否可以在每个字符周围画出整齐的矩形而不会有其他字符的部分侵犯这个矩形？
- en: Are there multiple variations of the font or style of writing or is only a single
    font used?
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本中是否存在多种字体或书写风格的变体，还是仅使用单一字体？
- en: Are there any background images, lines, or other distracting garbage in the
    image?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像中是否有任何背景图像、线条或其他分散注意力的垃圾？
- en: Is there high contrast with clear boundaries between the characters and the
    background?
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符之间是否有高对比度，字符与背景之间是否有清晰的边界？
- en: Is the font a fairly standard serif or sans serif font, or is it an unusual
    font with random elements and perhaps a “handwriting” style?
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体是否是比较标准的有衬线或无衬线字体，还是具有随机元素和“手写”风格的不寻常字体？
- en: If there is some overlap of the characters in some of the text samples, you
    might consider using only text samples where no overlap occurs. If overlap occurs
    in every text sample, consider preprocessing to separate characters before training.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些文本样本中字符有重叠，您可以考虑仅使用没有重叠的文本样本。如果每个文本样本都有重叠，则考虑在训练之前进行预处理以分离字符。
- en: Scraping and preparing images
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 爬取和准备图像
- en: Preprocessing helps remove any background junk and improves the color, contrast,
    and separation of characters in images.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理有助于去除任何背景垃圾，并改善图像中字符的颜色、对比度和分离度。
- en: How Many Images Do You Need?
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要多少图像？
- en: How many images should you obtain? I recommend about 10 examples per character,
    or more if there is high variation or randomness in your text. Tesseract does
    occasionally discard files as being unreadable, for having overlapping boxes,
    or for other arcane reasons, so you may want some buffer room on top of that. If
    you find that your OCR results aren’t quite as good as you’d like, or Tesseract
    is stumbling over certain characters, it’s a good debugging step to create additional
    training data and try again.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该获取多少图像？我建议每个字符大约有 10 个示例，如果您的文本有高变异性或随机性，则更多。Tesseract 偶尔会丢弃文件，例如由于重叠的框或其他神秘的原因，因此您可能希望有一些额外的缓冲空间。如果发现您的
    OCR 结果不如预期，或者 Tesseract 在某些字符上出现问题，创建额外的训练数据并再次尝试是一个良好的调试步骤。
- en: In addition, if there are multiple variations of fonts in the same text sample
    or if there are other variations involved (randomly tilted or obfuscated text),
    you may need more training data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果同一文本样本中存在多种字体变体，或者涉及其他变体（随机倾斜或混淆文本），您可能需要更多的训练数据。
- en: If the font is fairly standard and there are no other severe complicating factors,
    make sure you’ve tried Tesseract without additional training first! The performance
    without training may be acceptable for your needs, and training can be a very
    time-consuming process.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字体比较标准且没有其他严重的复杂因素，请确保先尝试使用 Tesseract 而不需额外训练！没有训练的情况下，性能可能已经满足您的需求，而训练可能是非常耗时的过程。
- en: 'Training requires giving Tesseract at least a few examples of each character
    you want it to be able to recognize. The following downloads 100 sample CAPTCHA
    images, each containing four characters, for a total of 400 character samples:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 训练需要向 Tesseract 提供至少每个您希望其能够识别的字符的几个示例。以下内容下载了包含四个字符的每个样本 CAPTCHA 图像的100个示例，共计400个字符样本：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After reviewing the downloaded training images, it’s time to decide what sort
    of preprocessing, if any, needs to be done. The images in this CAPTCHA have gray
    text on a black background. You can write a `cleanImage` function that transforms
    this into black text on a white background and adds a white border to make sure
    each character has separation from the edge of the image:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查下载的训练图像之后，现在是决定是否需要进行任何预处理的时候了。这些 CAPTCHA 图像中的文本为灰色，背景为黑色。您可以编写一个*cleanImage*函数，将其转换为白色背景上的黑色文本，并添加白色边框，以确保每个字符与图像边缘分离：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Creating box files with the Tesseract trainer project
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Tesseract 训练项目创建框文件
- en: 'Next, you need to use these cleaned images to create *box files*. A box file
    contains each character in the image on its own line, followed by the bounding
    box coordinates for that character. For example, a CAPTCHA image with the characters
    “AK6F” might have the corresponding box file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要使用这些清理过的图像来创建*框文件*。框文件包含图像中每个字符占据一行，后跟该字符的边界框坐标。例如，包含字符“AK6F”的 CAPTCHA
    图像可能具有相应的框文件：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'I’ve created a project at [*https://github.com/REMitchell/tesseract-trainer*](https://github.com/REMitchell/tesseract-trainer) that
    contains, among other things, a web app that assists in creating these box files.
    To create box files using this project, follow these steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[*https://github.com/REMitchell/tesseract-trainer*](https://github.com/REMitchell/tesseract-trainer)创建了一个项目，其中包括一个Web应用程序，帮助创建这些框文件。要使用此项目创建框文件，请按照以下步骤操作：
- en: Rename each CAPTCHA image to its solution. For example, the image containing
    “AK6F” would be renamed to “AK6F.png.”
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个 CAPTCHA 图像重命名为其解决方案。例如，包含“AK6F”的图像将被重命名为“AK6F.png.”
- en: In the Tesseract trainer project, open the file *createBoxes.html* in the web
    browser of your choice.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Tesseract 训练项目中，打开名为*createBoxes.html*的文件，使用您选择的 Web 浏览器。
- en: Click the “Add a new file” link and select the multiple image files that you
    renamed in step 1.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“添加新文件”链接，并选择在第一步中重命名的多个图像文件。
- en: The web app will automatically generate boxes based on the image’s name. Drag
    these boxes around their corresponding character, as shown in [Figure 16-6](#1606).
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web 应用程序将基于图像名称自动生成框。将这些框拖动到其对应字符周围，如[图16-6](#1606)所示。
- en: When you are happy with the placement of the boxes, click “Download .box” to
    download the box file, and the next image should appear.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您满意框的放置位置时，请单击“下载.box”以下载框文件，接下来的图像应该会出现。
- en: '![](assets/wsp3_1606.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/wsp3_1606.png)'
- en: Figure 16-6\. Creating box files using the Tesseract trainer tool
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图16-6。使用 Tesseract 训练器工具创建框文件
- en: As an optional step, I recommend putting on a good podcast or TV show, because
    it’s going to be a couple of hours of boring work. Exactly how long depends on
    how many boxes you need to draw.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可选步骤，我建议您播放一些好的播客或电视节目，因为这将是几个小时的乏味工作。确切的时间取决于您需要绘制多少个框。
- en: The next step after creating your box files is to show off all your hard work
    to Tesseract and let it get training. The end goal of this process is to create
    a *traineddata* file that you can add to your Tesseract language directory.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建框文件后的下一步是向 Tesseract 展示您所有的辛勤工作，并让它进行训练。该过程的最终目标是创建一个*traineddata*文件，您可以将其添加到您的
    Tesseract 语言目录中。
- en: 'In the Tesseract trainer project at [*https://github.com/REMitchell/tesseract-trainer*](https://github.com/REMitchell/tesseract-trainer),
    I’ve included a file called trainer.py. This script expects a *data* directory
    in the project root with the directories *cleaned* and *box* under it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Tesseract 训练项目中，[*https://github.com/REMitchell/tesseract-trainer*](https://github.com/REMitchell/tesseract-trainer)，我包含了一个名为
    trainer.py 的文件。此脚本期望项目根目录下有一个*data*目录，并在其下有*cleaned*和*box*目录：
- en: '*data*'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*data*'
- en: '*cleaned*'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*cleaned*'
- en: CAPTCHA images with any preprocessing and cleaning done, with the filenames
    matching the box files
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有任何预处理和清理完成的 CAPTCHA 图像，文件名与框文件匹配
- en: '*box*'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*box*'
- en: Box files, as downloaded from the web app
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Web应用程序下载的框文件
- en: After creating your folders of *.box* files and image files, copy this data
    into a backup folder before doing any further manipulation on it. Although running
    training scripts over the data is unlikely to delete anything, it’s better safe
    than sorry when hours worth of work put into *.box* file creation are involved.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建您的*.box*文件和图像文件夹之后，请将这些数据复制到备份文件夹中，然后再进行任何进一步的操作。尽管运行数据训练脚本不太可能删除任何内容，但当涉及到花费数小时来创建*.box*文件时，最好还是小心为好。
- en: Training Tesseract from box files
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从box文件训练Tesseract
- en: Performing the data analysis and creating the training files required for Tesseract
    involves many steps involves many steps. The *trainer.py* file does all of them
    for you.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 执行数据分析并创建Tesseract所需的训练文件涉及许多步骤。*trainer.py*文件会为您完成所有这些工作。
- en: 'The initial settings and steps that this program takes can be seen in the `__init__`
    and `runAll` methods of the class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序采取的初始设置和步骤可以在该类的`__init__`和`runAll`方法中看到：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'At the bottom of *trainer.py* a new `TesseractTrainer` instance is created
    and the runAll method is called:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在*trainer.py*的底部创建了一个新的`TesseractTrainer`实例，并调用了runAll方法：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The three attributes passed into the `TesseractTrainer` object are:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将传递给`TesseractTrainer`对象的三个属性是：
- en: '`languageName`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`languageName`'
- en: The three-letter language code that Tesseract uses to keep track of languages.
    For specific training scenarios, I prefer to create a new language rather than
    combine it or use it to replace Tesseract’s pre-trained English data.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Tesseract用来跟踪语言的三个字母语言代码。对于特定的训练场景，我更喜欢创建一个新语言，而不是合并它或使用它来替换Tesseract预训练的英文数据。
- en: '`fontName`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`fontName`'
- en: The name for your chosen font. This can be anything, but it must be a single
    word without spaces. In practice, this is just for internal purposes during training,
    and you’re unlikely to see it or need to reference it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您选择的字体名称。这可以是任何东西，但必须是一个没有空格的单词。在实践中，这仅用于训练过程中的内部目的，您不太可能看到它或需要引用它。
- en: '`directory`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`directory`'
- en: The directory name containing the directories of your cleaned images and box
    files. By default, this is data. If you have multiple projects, you can pass in
    a unique data directory name for each project to keep everything organized.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 包含清理图像和box文件的目录名。默认情况下，这是data。如果您有多个项目，您可以为每个项目传入一个唯一的数据目录名称，以保持所有内容的组织。
- en: Let’s look at some of the individual methods used.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些使用的个别方法。
- en: '`createDirectories` does some initial housekeeping and creates subdirectories
    such as the *exp* directory, which will later store the trained files.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`createDirectories`会进行一些初始的清理工作，并创建子目录，如稍后将存储训练文件的*exp*目录。'
- en: '`createFontProperties` creates a required file, *font_properties*, that lets
    Tesseract know about the new font you are creating:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`createFontProperties`会创建一个必需的文件*font_properties*，让Tesseract知道您正在创建的新字体：'
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This file consists of the name of the font, followed by 1s and 0s indicating
    whether italic, bold, or other versions of the font should be considered. Training
    fonts with these properties is an interesting exercise but unfortunately outside
    the scope of this book.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含字体名称，后面跟着1和0，表示是否考虑斜体、粗体或字体的其他版本。训练具有这些属性的字体是一个有趣的练习，但不幸的是超出了本书的范围。
- en: '`renameFiles` renames all your *.box* files and their corresponding image files
    with the names required by Tesseract (the file numbers here are sequential digits
    to keep multiple files separate):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`renameFiles`会重命名所有*.box*文件及其相应的图像文件，名称需符合Tesseract所需（这里的文件编号是顺序数字，以保持多个文件分开）：'
- en: '*<languageName>.<fontName>.exp<fileNumber>.box*'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<languageName>.<fontName>.exp<fileNumber>.box*'
- en: '*<languageName>.<fontName>.exp<fileNumber>.tiff*'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<languageName>.<fontName>.exp<fileNumber>.tiff*'
- en: '`extractUnicode` looks at all of the created *.box* files and determines the
    total set of characters available to be trained. The resulting Unicode file will
    tell you how many different characters you’ve found and could be a good way to
    quickly see if you’re missing anything.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`extractUnicode`会查看所有已创建的*.box*文件，并确定可以训练的总字符集。生成的Unicode文件将告诉您找到了多少不同的字符，这可能是快速查看是否缺少任何内容的好方法。'
- en: The next three functions, `runShapeClustering`, `runMfTraining`, and `runCtTraining`, create
    the files `shapetable`, `pfftable`, and `normproto`, respectively. These all provide
    information about the geometry and shape of each character, as well as provide
    statistical information that Tesseract uses to calculate the probability that
    a given character is one type or another.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的三个函数，`runShapeClustering`、`runMfTraining`和`runCtTraining`，分别创建文件`shapetable`、`pfftable`和`normproto`。它们都提供关于每个字符的几何和形状的信息，以及提供Tesseract用于计算给定字符是哪种类型的概率的统计信息。
- en: Finally, Tesseract renames each of the compiled data folders to be prepended
    by the required language name (e.g., *shapetable* is renamed to *cap.shapetable*)
    and compiles all of those files into the final training data file *cap.traineddata*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Tesseract将每个编译的数据文件夹重命名为所需语言名称的前缀（例如，*shapetable*重命名为*cap.shapetable*），并将所有这些文件编译成最终的训练数据文件*cap.traineddata*。
- en: Using traineddata files with Tesseract
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Tesseract的traineddata文件
- en: The *traineddata* file is the main output of this entire process. This file
    tells Tesseract how to identify characters in the training dataset you’ve given
    it. To use the file, you need to move it to your *tessdata* root folder.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*traineddata*文件是整个过程的主要输出。该文件告诉Tesseract如何在你提供的训练数据集中识别字符。要使用该文件，你需要将其移动到你的*tessdata*根目录。'
- en: 'You can find this folder using the following command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令找到这个文件夹：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will provide some output like:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供类似以下的输出：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then set the `TESSDATA_PREFIX` environment variable to this directory:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`TESSDATA_PREFIX`环境变量设置为此目录：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, move your new *traineddata* file to the *languages* directory:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将你的新*traineddata*文件移动到*languages*目录：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After the new *traineddata* file is in place, Tesseract should recognize it
    automatically as a new language and be able to solve new CAPTCHAs it’s presented
    with:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 安装新的*traineddata*文件后，Tesseract 应该会自动识别它作为新语言，并能够解决其遇到的新CAPTCHA：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Success! A significant improvement over the previous interpretation of the image
    as `u& DS`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！显著改进了之前将图像解释为`u& DS`的情况。
- en: This is just a quick overview of the full power of Tesseract’s font training
    and recognition capabilities. If you are interested in extensively training Tesseract,
    perhaps starting your own library of CAPTCHA training files, or sharing new font
    recognition capabilities with the world, I recommend checking out the [documentation](https://github.com/tesseract-ocr/tesseract).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对Tesseract字体训练和识别能力的简要概述。如果你对深入训练Tesseract感兴趣，也许开始自己的CAPTCHA训练文件库，或者与世界分享新的字体识别能力，我建议查看[文档](https://github.com/tesseract-ocr/tesseract)。
- en: Retrieving CAPTCHAs and Submitting Solutions
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索CAPTCHA并提交解决方案
- en: Many popular content management systems are frequently spammed with registrations
    by bots that are preprogrammed with the well-known location of these user registration
    pages. On [*http://pythonscraping.com*](http://pythonscraping.com), for instance,
    even a CAPTCHA (admittedly, weak) does little to put a damper on the influx of
    registrations.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 许多流行的内容管理系统经常会被预先编程的机器人注册，这些机器人知道这些用户注册页面的著名位置。例如，在[*http://pythonscraping.com*](http://pythonscraping.com)上，即使有CAPTCHA（诚然，不够强大），也无法阻止注册量的增加。
- en: So how do these bots do it? You’ve successfully solved CAPTCHAs in images sitting
    around on your hard drive, but how do you make a fully functioning bot? This section
    ties together many techniques covered in previous chapters. If you haven’t already,
    you should at least skim [Chapter 13](ch13.html#c-13).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这些机器人是如何做到的呢？你已经成功解决了硬盘上围绕的图像中的CAPTCHA，但是如何制作一个完全功能的机器人呢？本节综合了前几章涵盖的许多技术。如果你还没有，建议至少浏览[第13章](ch13.html#c-13)。
- en: 'Most image-based CAPTCHAs have several properties:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于图像的CAPTCHA具有几个特性：
- en: They are dynamically generated images, created by a server-side program. They
    might have image sources that do not look like traditional images, such as `<img
    src="WebForm.aspx?id=8AP85CQKE9TJ">`, but can be downloaded and manipulated like
    any other image.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是由服务器端程序动态生成的图像。它们可能具有看起来不像传统图像的图像源，例如`<img src="WebForm.aspx?id=8AP85CQKE9TJ">`，但可以像任何其他图像一样下载和操作。
- en: The solution to the image is stored in a server-side database.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的解决方案存储在服务器端数据库中。
- en: Many CAPTCHAs time out if you take too long to solve them. This usually isn’t
    a problem for bots, but queuing CAPTCHA solutions for later use, or other practices
    that may delay the time between when the CAPTCHA was requested and when the solution
    is submitted, may not be successful.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您花费的时间过长，许多CAPTCHA会超时。对于机器人来说，这通常不是问题，但是排队CAPTCHA解决方案以供以后使用，或者可能延迟CAPTCHA请求和提交解决方案之间时间的其他做法，可能不会成功。
- en: The general approach to this is to download the CAPTCHA image file to your hard
    drive, clean it, use Tesseract to parse the image, and return the solution under
    the appropriate form parameter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的一般方法是将CAPTCHA图像文件下载到您的硬盘上，清理它，使用Tesseract解析图像，并在适当的表单参数下返回解决方案。
- en: I’ve created a page at [*http://pythonscraping.com/humans-only*](http://pythonscraping.com/humans-only) with
    a CAPTCHA-protected comment form for the purpose of writing a bot to defeat. This
    bot uses the command-line Tesseract library, rather than the pytesseract wrapper,
    although either could be used.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个页面，位于[*http://pythonscraping.com/humans-only*](http://pythonscraping.com/humans-only)，带有一个CAPTCHA保护的评论表单，用于编写一个击败其的机器人。该机器人使用命令行的Tesseract库，而不是pytesseract包装器，尽管可以使用任一包。
- en: 'To start, load the page and find the location of a hidden token that needs
    to be POSTed with the rest of the form data:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，加载页面并找到需要与其余表单数据一起POST的隐藏令牌的位置：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This hidden token also happens to be the filename of the CAPTCHA image presented
    on the page, which makes writing the `getCaptchaSolution` function relatively
    straightforward:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个隐藏令牌恰好也是在页面上呈现的CAPTCHA图像的文件名，这使得编写`getCaptchaSolution`函数相对简单：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note that this script will fail under two conditions: if Tesseract did not
    extract exactly four characters from the image (because we know that all valid
    solutions to this CAPTCHA must have four characters), or if it submits the form
    but the CAPTCHA was solved incorrectly.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此脚本将在两种情况下失败：如果Tesseract未从图像中精确提取出四个字符（因为我们知道这个CAPTCHA的所有有效解决方案必须有四个字符），或者如果它提交了表单但CAPTCHA解决方案错误。
- en: In the first case, you can reload the page and try again, likely with no penalty
    from the web server. In the second case, the server might take note that you’re
    solving CAPTCHAs incorrectly and penalize you. Many servers, on multiple failed
    CAPTCHA attempts, will block the user or subject them to more rigorous screening.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，您可以重新加载页面并重试，可能不会受到Web服务器的任何惩罚。在第二种情况下，服务器可能会注意到您错误地解决了CAPTCHA，并对您进行惩罚。许多服务器在多次失败的CAPTCHA尝试后，会阻止用户或对其进行更严格的筛选。
- en: Of course, as the owner of this particular server I can attest to the fact that
    it’s extremely forgiving and unlikely to block you!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，作为这个特定服务器的所有者，我可以证明它非常宽容，不太可能阻止您！
- en: 'The form data itself is relatively lengthy and can be viewed in full in the
    GitHub repository or in your browser’s network inspector tools when submitting
    the form yourself. Checking the length of the CAPTCHA solution and submitting
    it using the Requests library is fairly straightforward, however:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 表单数据本身相对较长，您可以在GitHub存储库或在自己提交表单时的浏览器网络检查工具中完整查看。检查CAPTCHA解决方案的长度并使用Requests库提交它是相当简单的，但是：
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the CAPTCHA solution was correct (and it usually is), you should expect
    to see something like the following printed out:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CAPTCHA解决方案是正确的（通常是这样），您应该期望看到类似以下内容的打印输出：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: While CAPTCHAs are not as common as they were 10 or 20 years ago, they are still
    used by many sites, and knowing how to handle them is important. In addition,
    the skills gained by working with CAPTCHA solving easily translate to other image-to-text
    scenarios you may encounter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管CAPTCHA不像10或20年前那样普遍，但许多站点仍在使用它们，了解如何处理它们非常重要。此外，通过处理CAPTCHA解决方案而获得的技能，可以轻松转化为您可能遇到的其他图像到文本场景。
- en: ^([1](ch16.html#id831-marker)) See Rhett Jones, “Google Has Finally Killed the
    CAPTCHA,” Gizmodo, March 11, 2017, [*https://gizmodo.com/google-has-finally-killed-the-captcha-1793190374*](https://gizmodo.com/google-has-finally-killed-the-captcha-1793190374).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch16.html#id831-marker)) 参见Rhett Jones，“Google终于杀死了CAPTCHA”，Gizmodo，2017年3月11日，[*https://gizmodo.com/google-has-finally-killed-the-captcha-1793190374*](https://gizmodo.com/google-has-finally-killed-the-captcha-1793190374)。
