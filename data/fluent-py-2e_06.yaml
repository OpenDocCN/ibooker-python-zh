- en: Chapter 5\. Data Class Builders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 数据类构建器
- en: Data classes are like children. They are okay as a starting point, but to participate
    as a grownup object, they need to take some responsibility.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数据类就像孩子一样。它们作为一个起点是可以的，但要作为一个成熟的对象参与，它们需要承担一些责任。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Martin Fowler and Kent Beck^([1](ch05.html#idm46582456501248))
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 马丁·福勒和肯特·贝克^([1](ch05.html#idm46582456501248))
- en: 'Python offers a few ways to build a simple class that is just a collection
    of fields, with little or no extra functionality. That pattern is known as a “data
    class”—and `dataclasses` is one of the packages that supports this pattern. This
    chapter covers three different class builders that you may use as shortcuts to
    write data classes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了几种构建简单类的方法，这些类只是一组字段，几乎没有额外功能。这种模式被称为“数据类”，而`dataclasses`是支持这种模式的包之一。本章涵盖了三种不同的类构建器，您可以将它们用��编写数据类的快捷方式：
- en: '`collections.namedtuple`'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.namedtuple`'
- en: The simplest way—available since Python 2.6.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法——自Python 2.6起可用。
- en: '`typing.NamedTuple`'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing.NamedTuple`'
- en: An alternative that requires type hints on the fields—since Python 3.5, with
    `class` syntax added in 3.6.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一种需要在字段上添加类型提示的替代方法——自Python 3.5起，3.6中添加了`class`语法。
- en: '`@dataclasses.dataclass`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`@dataclasses.dataclass`'
- en: A class decorator that allows more customization than previous alternatives,
    adding lots of options and potential complexity—since Python 3.7.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类装饰器，允许比以前的替代方案更多的定制化，增加了许多选项和潜在的复杂性——自Python 3.7起。
- en: 'After covering those class builders, we will discuss why *Data Class* is also
    the name of a code smell: a coding pattern that may be a symptom of poor object-oriented
    design.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论完这些类构建器之后，我们将讨论为什么*数据类*也是一个代码异味的名称：一种可能是糟糕面向对象设计的症状的编码模式。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`typing.TypedDict` may seem like another data class builder. It uses similar
    syntax and is described right after `typing.NamedTuple` in the [`typing` module
    documentation](https://fpy.li/5-1) for Python 3.9.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing.TypedDict`可能看起来像另一个数据类构建器。它使用类似的语法，并在Python 3.9的[`typing`模块文档](https://fpy.li/5-1)中的`typing.NamedTuple`之后描述。'
- en: However, `TypedDict` does not build concrete classes that you can instantiate.
    It’s just syntax to write type hints for function parameters and variables that
    will accept mapping values used as records, with keys as field names. We’ll see
    them in [Chapter 15](ch15.html#more_types_ch), [“TypedDict”](ch15.html#typeddict_sec).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`TypedDict`不会构建您可以实例化的具体类。它只是一种语法，用于为将用作记录的映射值接受的函数参数和变量编写类型提示，其中键作为字段名。我们将在[第15章](ch15.html#more_types_ch)的“TypedDict”中看到它们。
- en: What’s New in This Chapter
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的新内容
- en: This chapter is new in the second edition of *Fluent Python*. The section [“Classic
    Named Tuples”](#classic_named_tuples_sec) appeared in Chapter 2 of the first edition,
    but the rest of the chapter is completely new.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是*流畅的Python*第二版中的新内容。第一版的第2章中出现了“经典命名元组”一节，但本章的其余部分是全新的。
- en: We begin with a high-level overview of the three class builders.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从三个类构建器的高级概述开始。
- en: Overview of Data Class Builders
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类构建器概述
- en: Consider a simple class to represent a geographic coordinate pair, as shown
    in [Example 5-1](#coord_class_ex).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的类来表示地理坐标对，如[示例 5-1](#coord_class_ex)所示。
- en: Example 5-1\. *class/coordinates.py*
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-1。*class/coordinates.py*
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That `Coordinate` class does the job of holding latitude and longitude attributes.
    Writing the `__init__` boilerplate becomes old real fast, especially if your class
    has more than a couple of attributes: each of them is mentioned three times! And
    that boilerplate doesn’t buy us basic features we’d expect from a Python object:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`Coordinate`类完成了保存纬度和经度属性的工作。编写`__init__`样板变得非常乏味，特别是如果你的类有超过几个属性：每个属性都被提及三次！而且那个样板并没有为我们购买我们期望从Python对象中获得的基本功能：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_data_class_builders_CO1-1)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_class_builders_CO1-1)'
- en: '`__repr__` inherited from `object` is not very helpful.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从`object`继承的`__repr__`并不是很有用。
- en: '[![2](assets/2.png)](#co_data_class_builders_CO1-2)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_class_builders_CO1-2)'
- en: Meaningless `==`; the `__eq__` method inherited from `object` compares object
    IDs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无意义的`==`；从`object`继承的`__eq__`方法比较对象ID。
- en: '[![3](assets/3.png)](#co_data_class_builders_CO1-3)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_data_class_builders_CO1-3)'
- en: Comparing two coordinates requires explicit comparison of each attribute.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个坐标需要显式比较每个属性。
- en: The data class builders covered in this chapter provide the necessary `__init__`,
    `__repr__`, and `__eq__` methods automatically, as well as other useful features.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的数据类构建器会自动提供必要的`__init__`、`__repr__`和`__eq__`方法，以及其他有用的功能。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: None of the class builders discussed here depend on inheritance to do their
    work. Both `collections.namedtuple` and `typing.NamedTuple` build classes that
    are `tuple` subclasses. `@dataclass` is a class decorator that does not affect
    the class hierarchy in any way. Each of them uses different metaprogramming techniques
    to inject methods and data attributes into the class under construction.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里讨论的类构建器都不依赖继承来完成工作。`collections.namedtuple`和`typing.NamedTuple`都构建了`tuple`子类的类。`@dataclass`是一个类装饰器，不会以任何方式影响类层次结构。它们每个都使用不同的元编程技术将方法和数据属性注入到正在构建的类中。
- en: 'Here is a `Coordinate` class built with `namedtuple`—a factory function that
    builds a subclass of `tuple` with the name and fields you specify:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`namedtuple`构建的`Coordinate`类——一个工厂函数，根据您指定的名称和字段构建`tuple`的子类：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_data_class_builders_CO2-1)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_class_builders_CO2-1)'
- en: Useful `__repr__`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的`__repr__`。
- en: '[![2](assets/2.png)](#co_data_class_builders_CO2-2)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_class_builders_CO2-2)'
- en: Meaningful `__eq__`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有意义的`__eq__`。
- en: 'The newer `typing.NamedTuple` provides the same functionality, adding a type
    annotation to each field:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 较新的`typing.NamedTuple`提供了相同的功能，为每个字段添加了类型注释：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'A typed named tuple can also be constructed with the fields given as keyword
    arguments, like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有字段作为关键字参数构造的类型命名元组也可以这样创建：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is more readable, and also lets you provide the mapping of fields and types
    as `**fields_and_types`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这更易读，也让您提供字段和类型的映射作为 `**fields_and_types`。
- en: Since Python 3.6, `typing.NamedTuple` can also be used in a `class` statement,
    with type annotations written as described in [PEP 526—Syntax for Variable Annotations](https://fpy.li/pep526).
    This is much more readable, and makes it easy to override methods or add new ones.
    [Example 5-2](#coord_tuple_ex) is the same `Coordinate` class, with a pair of
    `float` attributes and a custom `__str__` to display a coordinate formatted like
    55.8°N, 37.6°E.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Python 3.6 起，`typing.NamedTuple` 也可以在 `class` 语句中使用，类型注解的写法如 [PEP 526—变量注解的语法](https://fpy.li/pep526)
    中描述的那样。这样更易读，也方便重写方法或添加新方法。[示例 5-2](#coord_tuple_ex) 是相同的 `Coordinate` 类，具有一对
    `float` 属性和一个自定义的 `__str__` 方法，以显示格式为 55.8°N, 37.6°E 的坐标。
- en: Example 5-2\. *typing_namedtuple/coordinates.py*
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. *typing_namedtuple/coordinates.py*
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Warning
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Although `NamedTuple` appears in the `class` statement as a superclass, it’s
    actually not. `typing.NamedTuple` uses the advanced functionality of a metaclass^([2](ch05.html#idm46582456097616))
    to customize the creation of the user’s class. Check this out:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `NamedTuple` 在 `class` 语句中出现为���类，但实际上并非如此。`typing.NamedTuple` 使用元类的高级功能^([2](ch05.html#idm46582456097616))
    来自定义用户类的创建。看看这个：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `__init__` method generated by `typing.NamedTuple`, the fields appear
    as parameters in the same order they appear in the `class` statement.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `typing.NamedTuple` 生成的 `__init__` 方法中，字段按照在 `class` 语句中出现的顺序作为参数出现。
- en: Like `typing.NamedTuple`, the `dataclass` decorator supports [PEP 526](https://fpy.li/pep526)
    syntax to declare instance attributes. The decorator reads the variable annotations
    and automatically generates methods for your class. For comparison, check out
    the equivalent `Coordinate` class written with the help of the `dataclass` decorator,
    as shown in [Example 5-3](#coord_dataclas_ex).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `typing.NamedTuple` 一样，`dataclass` 装饰器支持 [PEP 526](https://fpy.li/pep526)
    语法来声明实例属性。装饰器读取变量注解并自动生成类的方法。为了对比，可以查看使用 `dataclass` 装饰器编写的等效 `Coordinate` 类，如
    [示例 5-3](#coord_dataclas_ex) 中所示。
- en: Example 5-3\. *dataclass/coordinates.py*
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-3\. *dataclass/coordinates.py*
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the body of the classes in [Example 5-2](#coord_tuple_ex) and [Example 5-3](#coord_dataclas_ex)
    are identical—the difference is in the `class` statement itself. The `@dataclass`
    decorator does not depend on inheritance or a metaclass, so it should not interfere
    with your own use of these mechanisms.^([3](ch05.html#idm46582455952240)) The
    `Coordinate` class in [Example 5-3](#coord_dataclas_ex) is a subclass of `object`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[示例 5-2](#coord_tuple_ex) 和 [示例 5-3](#coord_dataclas_ex) 中的类主体是相同的——区别在于
    `class` 语句本身。`@dataclass` 装饰器不依赖于继承或元类，因此不应干扰您对这些机制的使用。^([3](ch05.html#idm46582455952240))
    [示例 5-3](#coord_dataclas_ex) 中的 `Coordinate` 类是 `object` 的子类。
- en: Main Features
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要特点
- en: The different data class builders have a lot in common, as summarized in [Table 5-1](#builders_compared_tbl).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的数据类构建器有很多共同点，如 [表 5-1](#builders_compared_tbl) 所总结的。
- en: Table 5-1\. Selected features compared across the three data class builders;
    `x` stands for an instance of a data class of that kind
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-1\. 三种数据类构建器之间的选定特点比较；`x` 代表该类型数据类的一个实例
- en: '|  | namedtuple | NamedTuple | dataclass |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  | namedtuple | NamedTuple | dataclass |'
- en: '| --- | --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| mutable instances | NO | NO | YES |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 可变实例 | 否 | 否 | 是 |'
- en: '| class statement syntax | NO | YES | YES |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| class 语句语法 | 否 | 是 | 是 |'
- en: '| construct dict | x._asdict() | x._asdict() | dataclasses.asdict(x) |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 构造字典 | x._asdict() | x._asdict() | dataclasses.asdict(x) |'
- en: '| get field names | x._fields | x._fields | [f.name for f in dataclasses.fields(x)]
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 获取字段名 | x._fields | x._fields | [f.name for f in dataclasses.fields(x)] |'
- en: '| get defaults | x._field_defaults | x._field_defaults | [f.default for f in
    dataclasses.fields(x)] |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 获取默认值 | x._field_defaults | x._field_defaults | [f.default for f in dataclasses.fields(x)]
    |'
- en: '| get field types | N/A | x.__annotations__ | x.__annotations__ |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 获取字段类型 | 不适用 | x.__annotations__ | x.__annotations__ |'
- en: '| new instance with changes | x._replace(…) | x._replace(…) | dataclasses.replace(x,
    …) |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 使用更改创建新实例 | x._replace(…) | x._replace(…) | dataclasses.replace(x, …) |'
- en: '| new class at runtime | namedtuple(…) | NamedTuple(…) | dataclasses.make_dataclass(…)
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 运行时新类 | namedtuple(…) | NamedTuple(…) | dataclasses.make_dataclass(…) |'
- en: Warning
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The classes built by `typing.NamedTuple` and `@dataclass` have an `__annotations__`
    attribute holding the type hints for the fields. However, reading from `__annotations__`
    directly is not recommended. Instead, the recommended best practice to get that
    information is to call [`inspect.get_annotations(MyClass)`](https://fpy.li/5-2)
    (added in Python 3.10) or [`typing.​get_​type_​hints(MyClass)`](https://fpy.li/5-3)
    (Python 3.5 to 3.9). That’s because those functions provide extra services, like
    resolving forward references in type hints. We’ll come back to this issue much
    later in the book, in [“Problems with Annotations at Runtime”](ch15.html#problems_annot_runtime_sec).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing.NamedTuple` 和 `@dataclass` 构建的类具有一个 `__annotations__` 属性，其中包含字段的类型提示。然而，不建议直接从
    `__annotations__` 中读取。相反，获取该信息的推荐最佳实践是调用 [`inspect.get_annotations(MyClass)`](https://fpy.li/5-2)（Python
    3.10 中添加）或 [`typing.​get_​type_​hints(MyClass)`](https://fpy.li/5-3)（Python 3.5
    到 3.9）。这是因为这些函数提供额外的服务，如解析类型提示中的前向引用。我们将在本书的后面更详细地讨论这个问题，在 [“运行时注解问题”](ch15.html#problems_annot_runtime_sec)
    中。'
- en: Now let’s discuss those main features.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论这些主要特点。
- en: Mutable instances
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变实例
- en: A key difference between these class builders is that `collections.namedtuple`
    and `typing.NamedTuple` build `tuple` subclasses, therefore the instances are
    immutable. By default, `@dataclass` produces mutable classes. But the decorator
    accepts a keyword argument `frozen`—shown in [Example 5-3](#coord_dataclas_ex).
    When `frozen=True`, the class will raise an exception if you try to assign a value
    to a field after the instance is initialized.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类构建器之间的一个关键区别是，`collections.namedtuple` 和 `typing.NamedTuple` 构建 `tuple` 的子类，因此实例是不可变的。默认情况下，`@dataclass`
    生成可变类。但是，装饰器接受一个关键字参数 `frozen`—如 [示例 5-3](#coord_dataclas_ex) 中所示。当 `frozen=True`
    时，如果尝试在初始化实例后为字段分配值，类将引发异常。
- en: Class statement syntax
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类语句语法
- en: Only `typing.NamedTuple` and `dataclass` support the regular `class` statement
    syntax, making it easier to add methods and docstrings to the class you are creating.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`typing.NamedTuple`和`dataclass`支持常规的`class`语句语法，这样可以更容易地向正在创建的类添加方法和文档字符串。
- en: Construct dict
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造字典
- en: 'Both named tuple variants provide an instance method (`._asdict`) to construct
    a `dict` object from the fields in a data class instance. The `dataclasses` module
    provides a function to do it: `dataclasses.asdict`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种命名元组变体都提供了一个实例方法（`._asdict`），用于从数据类实例中的字段构造一个`dict`对象。`dataclasses`模块提供了一个执行此操作的函数：`dataclasses.asdict`。
- en: Get field names and default values
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取字段名称和默认值
- en: All three class builders let you get the field names and default values that
    may be configured for them. In named tuple classes, that metadata is in the `._fields`
    and `._fields_defaults` class attributes. You can get the same metadata from a
    `dataclass` decorated class using the `fields` function from the `dataclasses`
    module. It returns a tuple of `Field` objects that have several attributes, including
    `name` and `default`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种类构建器都允许您获取字段名称和可能为其配置的默认值。在命名元组类中，这些元数据位于`._fields`和`._fields_defaults`类属性中。您可以使用`dataclasses`模块中的`fields`函数从装饰的`dataclass`类中获取相同的元数据。它返回一个具有多个属性的`Field`对象的元组，包括`name`和`default`。
- en: Get field types
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取字段类型
- en: Classes defined with the help of `typing.NamedTuple` and `@dataclass` have a
    mapping of field names to type the `__annotations__` class attribute. As mentioned,
    use the `typing.get_type_hints` function instead of reading `__annotations__`
    directly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`typing.NamedTuple`和`@dataclass`帮助定义的类具有字段名称到类型的映射`__annotations__`类属性。如前所述，使用`typing.get_type_hints`函数而不是直接读取`__annotations__`。
- en: New instance with changes
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有更���的新实例
- en: Given a named tuple instance `x`, the call `x._replace(**kwargs)` returns a
    new instance with some attribute values replaced according to the keyword arguments
    given. The `dataclasses.replace(x, **kwargs)` module-level function does the same
    for an instance of a `dataclass` decorated class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个命名元组实例`x`，调用`x._replace(**kwargs)`将返回一个根据给定关键字参数替换了一些属性值的新实例。`dataclasses.replace(x,
    **kwargs)`模块级函数对于`dataclass`装饰的类的实例也是如此。
- en: New class at runtime
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时新类
- en: Although the `class` statement syntax is more readable, it is hardcoded. A framework
    may need to build data classes on the fly, at runtime. For that, you can use the
    default function call syntax of `collections.namedtuple`, which is likewise supported
    by `typing.NamedTuple`. The `dataclasses` module provides a `make_dataclass` function
    for the same purpose.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`class`语句语法更易读，但它是硬编码的。一个框架可能需要在运行时动态构建数据类。为此，您可以使用`collections.namedtuple`的默认函数调用语法，该语法同样受到`typing.NamedTuple`的支持。`dataclasses`模块提供了一个`make_dataclass`函数来实现相同的目的。
- en: After this overview of the main features of the data class builders, let’s focus
    on each of them in turn, starting with the simplest.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在对数据类构建器的主要特性进行概述之后，让我们依次专注于每个特性，从最简单的开始。
- en: Classic Named Tuples
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典的命名元组
- en: The `collections.namedtuple` function is a factory that builds subclasses of
    `tuple` enhanced with field names, a class name, and an informative `__repr__`.
    Classes built with `namedtuple` can be used anywhere where tuples are needed,
    and in fact many functions of the Python standard library that are used to return
    tuples now return named tuples for convenience, without affecting the user’s code
    at all.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.namedtuple`函数是一个工厂，构建了增强了字段名称、类名和信息性`__repr__`的`tuple`子类。使用`namedtuple`构建的类可以在需要元组的任何地方使用，并且实际上，Python标准库的许多函数现在用于返回元组的地方现在返回命名元组以方便使用，而不会对用户的代码产生任何影响。'
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Each instance of a class built by `namedtuple` takes exactly the same amount
    of memory as a tuple because the field names are stored in the class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由`namedtuple`构建的类的每个实例占用的内存量与元组相同，因为字段名称存储在类中。
- en: '[Example 5-4](#ex_named_tuple_1) shows how we could define a named tuple to
    hold information about a city.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-4](#ex_named_tuple_1) 展示了我们如何定义一个命名元组来保存有关城市信息的示例。'
- en: Example 5-4\. Defining and using a named tuple type
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-4\. 定义和使用命名元组类型
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_data_class_builders_CO3-1)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_class_builders_CO3-1)'
- en: 'Two parameters are required to create a named tuple: a class name and a list
    of field names, which can be given as an iterable of strings or as a single space-delimited
    string.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建命名元组需要两个参数：一个类名和一个字段名称列表，可以作为字符串的可迭代对象或作为单个以空格分隔的字符串给出。
- en: '[![2](assets/2.png)](#co_data_class_builders_CO3-2)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_class_builders_CO3-2)'
- en: Field values must be passed as separate positional arguments to the constructor
    (in contrast, the `tuple` constructor takes a single iterable).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 字段值必须作为单独的位置参数传递给构造函数（相反，`tuple`构造函数接受一个单一的可迭代对象）。
- en: '[![3](assets/3.png)](#co_data_class_builders_CO3-3)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_data_class_builders_CO3-3)'
- en: You can access the fields by name or position.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过名称或位置访问这些字段。
- en: As a `tuple` subclass, `City` inherits useful methods such as `__eq__` and the
    special methods for comparison operators—including `__lt__`, which allows sorting
    lists of `City` instances.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`tuple`子类，`City`继承了一些有用的方法，比如`__eq__`和用于比较运算符的特殊方法，包括`__lt__`，它允许对`City`实例的列表进行排序。
- en: 'A named tuple offers a few attributes and methods in addition to those inherited
    from the tuple. [Example 5-5](#ex_named_tuple_2) shows the most useful: the `_fields`
    class attribute, the class method `_make(iterable)`, and the `_asdict()` instance
    method.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从元组继承的属性和方法外，命名元组还提供了一些额外的属性和方法。[示例 5-5](#ex_named_tuple_2) 展示了最有用的：`_fields`类属性，类方法`_make(iterable)`和`_asdict()`实例方法。
- en: Example 5-5\. Named tuple attributes and methods (continued from the previous
    example)
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. 命名元组属性和方法（继续自上一个示例）
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_data_class_builders_CO4-1)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_class_builders_CO4-1)'
- en: '`._fields` is a tuple with the field names of the class.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`._fields` 是一个包含类的字段名称的元组。'
- en: '[![2](assets/2.png)](#co_data_class_builders_CO4-2)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_class_builders_CO4-2)'
- en: '`._make()` builds `City` from an iterable; `City(*delhi_data)` would do the
    same.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`._make()` 从可迭代对象构建 `City`；`City(*delhi_data)` 将执行相同操作。'
- en: '[![3](assets/3.png)](#co_data_class_builders_CO4-3)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_data_class_builders_CO4-3)'
- en: '`._asdict()` returns a `dict` built from the named tuple instance.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`._asdict()` 返回从命名元组实例构建的 `dict`。'
- en: '[![4](assets/4.png)](#co_data_class_builders_CO4-4)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_data_class_builders_CO4-4)'
- en: '`._asdict()` is useful to serialize the data in JSON format, for example.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`._asdict()` 对于将数据序列化为 JSON 格式非常有用，例如。'
- en: Warning
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'The `_asdict` method returned an `OrderedDict` until Python 3.7. Since Python
    3.8, it returns a simple `dict`—which is OK now that we can rely on key insertion
    order. If you must have an `OrderedDict`, the [`_asdict` documentation](https://fpy.li/5-4)
    recommends building one from the result: `OrderedDict(x._asdict())`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 Python 3.7，`_asdict` 方法返回一个 `OrderedDict`。自 Python 3.8 起，它返回一个简单的 `dict`——现在我们可以依赖键插入顺序了。如果你一定需要一个
    `OrderedDict`，[`_asdict` 文档](https://fpy.li/5-4)建议从结果构建一个：`OrderedDict(x._asdict())`。
- en: Since Python 3.7, `namedtuple` accepts the `defaults` keyword-only argument
    providing an iterable of N default values for each of the N rightmost fields of
    the class. [Example 5-6](#ex_coord_tuple_default) shows how to define a `Coordinate`
    named tuple with a default value for a `reference` field.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Python 3.7 起，`namedtuple` 接受 `defaults` 关键字参数，为类的 N 个最右字段的每个字段提供一个默认值的可迭代对象。[示例
    5-6](#ex_coord_tuple_default)展示了如何为 `reference` 字段定义一个带有默认值的 `Coordinate` 命名元组。
- en: Example 5-6\. Named tuple attributes and methods, continued from [Example 5-5](#ex_named_tuple_2)
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-6。命名元组属性和方法，继续自[示例 5-5](#ex_named_tuple_2)
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In [“Class statement syntax”](#class_syntax_feature), I mentioned it’s easier
    to code methods with the class syntax supported by `typing.NamedTuple` and `@dataclass`.
    You can also add methods to a `namedtuple`, but it’s a hack. Skip the following
    box if you’re not interested in hacks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“类语句语法”](#class_syntax_feature)中，我提到使用 `typing.NamedTuple` 和 `@dataclass`
    支持的类语法更容易编写方法。你也可以向 `namedtuple` 添加方法，但这是一种 hack。如果你对 hack 不感兴趣，可以跳过下面的框。
- en: Now let’s check out the `typing.NamedTuple` variation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `typing.NamedTuple` 的变化。
- en: Typed Named Tuples
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带类型的命名��组
- en: The `Coordinate` class with a default field from [Example 5-6](#ex_coord_tuple_default)
    can be written using `typing.NamedTuple`, as shown in [Example 5-8](#coord_tuple_default_ex).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Coordinate` 类与[示例 5-6](#ex_coord_tuple_default)中的默认字段可以使用 `typing.NamedTuple`
    编写，如[示例 5-8](#coord_tuple_default_ex)所示。'
- en: Example 5-8\. *typing_namedtuple/coordinates2.py*
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-8。*typing_namedtuple/coordinates2.py*
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_data_class_builders_CO6-1)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_class_builders_CO6-1)'
- en: Every instance field must be annotated with a type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实例字段都必须带有类型注释。
- en: '[![2](assets/2.png)](#co_data_class_builders_CO6-2)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_class_builders_CO6-2)'
- en: The `reference` instance field is annotated with a type and a default value.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`reference` 实例字段带有类型和默认值的注释。'
- en: Classes built by `typing.NamedTuple` don’t have any methods beyond those that
    `collections.namedtuple` also generates—and those that are inherited from `tuple`.
    The only difference is the presence of the `__annotations__` class attribute—which
    Python completely ignores at runtime.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `typing.NamedTuple` 构建的类除了那些 `collections.namedtuple` 生成的方法和从 `tuple` 继承的方法外，没有任何其他方法。唯一的区别是存在
    `__annotations__` 类属性——Python 在运行时完全忽略它。
- en: Given that the main feature of `typing.NamedTuple` are the type annotations,
    we’ll take a brief look at them before resuming our exploration of data class
    builders.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于 `typing.NamedTuple` 的主要特点是类型注释，我们将在继续探索数据类构建器之前简要介绍它们。
- en: Type Hints 101
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型提示 101
- en: Type hints—a.k.a. type annotations—are ways to declare the expected type of
    function arguments, return values, variables, and attributes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示，又称类型注释，是声明函数参数、返回值、变量和属性预期类型的方式。
- en: The first thing you need to know about type hints is that they are not enforced
    at all by the Python bytecode compiler and interpreter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解的第一件事是，类型提示完全不受 Python 字节码编译器和解释器的强制执行。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is a very brief introduction to type hints, just enough to make sense of
    the syntax and meaning of the annotations used in `typing.NamedTuple` and `@dataclass`
    declarations. We will cover type hints for function signatures in [Chapter 8](ch08.html#type_hints_in_def_ch)
    and more advanced annotations in [Chapter 15](ch15.html#more_types_ch). Here we’ll
    mostly see hints with simple built-in types, such as `str`, `int`, and `float`,
    which are probably the most common types used to annotate fields of data classes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对类型提示的非常简要介绍，足以理解 `typing.NamedTuple` 和 `@dataclass` 声明中使用的注释的语法和含义。我们将在[第
    8 章](ch08.html#type_hints_in_def_ch)中介绍函数签名的类型提示，以及在[第 15 章](ch15.html#more_types_ch)中介绍更高级的注释。在这里，我们将主要看到使用简单内置类型的提示，比如
    `str`、`int` 和 `float`，这些类型可能是用于注释数据类字段的最常见类型。
- en: No Runtime Effect
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无运行时效果
- en: Think about Python type hints as “documentation that can be verified by IDEs
    and type checkers.”
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 类型提示视为“可以由 IDE 和类型检查器验证的文档”。
- en: That’s because type hints have no impact on the runtime behavior of Python programs.
    Check out [Example 5-9](#no_runtime_check_ex).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为类型提示对 Python 程序的运行时行为没有影响。查看[示例 5-9](#no_runtime_check_ex)。
- en: Example 5-9\. Python does not enforce type hints at runtime
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-9。Python 不会在运行时强制执行类型提示
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_data_class_builders_CO7-1)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_class_builders_CO7-1)'
- en: 'I told you: no type checking at runtime!'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我告诉过你：运行时不进行类型检查！
- en: 'If you type the code of [Example 5-9](#no_runtime_check_ex) in a Python module,
    it will run and display a meaningless `Coordinate`, with no error or warning:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Python 模块中键入[示例 5-9](#no_runtime_check_ex)的代码，它将运行并显示一个无意义的 `Coordinate`，没有错误或警告：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The type hints are intended primarily to support third-party type checkers,
    like [Mypy](https://fpy.li/mypy) or the [PyCharm IDE](https://fpy.li/5-5) built-in
    type checker. These are static analysis tools: they check Python source code “at
    rest,” not running code.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示主要用于支持第三方类型检查器，如[Mypy](https://fpy.li/mypy)或[PyCharm IDE](https://fpy.li/5-5)内置的类型检查器。这些是静态分析工具：它们检查
    Python 源代码“静止”，而不是运行代码。
- en: 'To see the effect of type hints, you must run one of those tools on your code—like
    a linter. For instance, here is what Mypy has to say about the previous example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到类型提示的效果，你必须在你的代码上运行其中一个工具—比如一个检查器。例如，这是Mypy对前面示例的看法：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, given the definition of `Coordinate`, Mypy knows that both arguments
    to create an instance must be of type `float`, but the assignment to `trash` uses
    a `str` and `None`.^([5](ch05.html#idm46582455040272))
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，鉴于`Coordinate`的定义，Mypy知道创建实例的两个参数必须是`float`类型，但对`trash`的赋值使用了`str`和`None`。^([5](ch05.html#idm46582455040272))
- en: Now let’s talk about the syntax and meaning of type hints.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈类型提示的语法和含义。
- en: Variable Annotation Syntax
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量注释语法
- en: Both `typing.NamedTuple` and `@dataclass` use the syntax of variable annotations
    defined in [PEP 526](https://fpy.li/pep526). This is a quick introduction to that
    syntax in the context defining attributes in `class` statements.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing.NamedTuple`和`@dataclass`都使用在[PEP 526](https://fpy.li/pep526)中定义的变量注释语法。这是在`class`语句中定义属性的上下文中对该语法的快速介绍。'
- en: 'The basic syntax of variable annotation is:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 变量注释的基本语法是：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The [“Acceptable type hints” section in PEP 484](https://fpy.li/5-6) explains
    what are acceptable types, but in the context of defining a data class, these
    types are more likely to be useful:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 484中的“可接受的类型提示”部分](https://fpy.li/5-6)解释了什么是可接受的类型，但在定义数据类的上下文中，这些类型更有可能有用：'
- en: A concrete class, for example, `str` or `FrenchDeck`
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具体的类，例如，`str`或`FrenchDeck`
- en: A parameterized collection type, like `list[int]`, `tuple[str, float]`, etc.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个参数化的集合类型，如`list[int]`，`tuple[str, float]`，等等。
- en: '`typing.Optional`, for example, `Optional[str]`—to declare a field that can
    be a `str` or `None`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typing.Optional`，例如，`Optional[str]`—声明一个可以是`str`或`None`的字段'
- en: 'You can also initialize the variable with a value. In a `typing.NamedTuple`
    or `@dataclass` declaration, that value will become the default for that attribute
    if the corresponding argument is omitted in the constructor call:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用一个值初始化变量。在`typing.NamedTuple`或`@dataclass`声明中，如果在构造函数调用中省略了相应的参数，那个值将成为该属性的默认值：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Meaning of Variable Annotations
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量注释的含义
- en: We saw in [“No Runtime Effect”](#no_runtime_effect_sec) that type hints have
    no effect at runtime. But at import time—when a module is loaded—Python does read
    them to build the `__annotations__` dictionary that `typing.NamedTuple` and `@dataclass`
    then use to enhance the class.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“无运行时效果”](#no_runtime_effect_sec)中看到类型提示在运行时没有效果。但在导入时—模块加载时—Python会读取它们以构建`__annotations__`字典，然后`typing.NamedTuple`和`@dataclass`会使用它们来增强类。
- en: We’ll start this exploration with a simple class in [Example 5-10](#ex_demo_plain),
    so that we can later see what extra features are added by `typing.NamedTuple`
    and `@dataclass`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从[示例 5-10](#ex_demo_plain)中的一个简单类开始这个探索，这样我们以后可以看到`typing.NamedTuple`和`@dataclass`添加的额外功能。
- en: 'Example 5-10\. meaning/demo_plain.py: a plain class with type hints'
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-10\. meaning/demo_plain.py：带有类型提示的普通类
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_data_class_builders_CO8-1)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_class_builders_CO8-1)'
- en: '`a` becomes an entry in `__annotations__`, but is otherwise discarded: no attribute
    named `a` is created in the class.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`成为`__annotations__`中的一个条目，但在类中不会创建名为`a`的属性。'
- en: '[![2](assets/2.png)](#co_data_class_builders_CO8-2)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_class_builders_CO8-2)'
- en: '`b` is saved as an annotation, and also becomes a class attribute with value
    `1.1`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`b`被保存为注释，并且也成为一个具有值`1.1`的类属性。'
- en: '[![3](assets/3.png)](#co_data_class_builders_CO8-3)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_data_class_builders_CO8-3)'
- en: '`c` is just a plain old class attribute, not an annotation.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`c`只是一个普通的类属性，不是一个注释。'
- en: 'We can verify that in the console, first reading the `__annotations__` of the
    `DemoPlainClass`, then trying to get its attributes named `a`, `b`, and `c`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在控制台中验证，首先读取`DemoPlainClass`的`__annotations__`，然后尝试获取其名为`a`、`b`和`c`的属性：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the `__annotations__` special attribute is created by the interpreter
    to record the type hints that appear in the source code—even in a plain class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`__annotations__`特殊属性是由解释器创建的，用于记录源代码中出现的类型提示—即使在一个普通类中也是如此。
- en: The `a` survives only as an annotation. It doesn’t become a class attribute
    because no value is bound to it.^([6](ch05.html#idm46582454850176)) The `b` and
    `c` are stored as class attributes because they are bound to values.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`只作为一个注释存在。它不会成为一个类属性，因为没有值与它绑定。^([6](ch05.html#idm46582454850176)) `b`和`c`作为类属性存储，因为它们绑定了值。'
- en: None of those three attributes will be in a new instance of `DemoPlainClass`.
    If you create an object `o = DemoPlainClass()`, `o.a` will raise `AttributeError`,
    while `o.b` and `o.c` will retrieve the class attributes with values `1.1` and
    `'spam'`—that’s just normal Python object behavior.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个属性都不会出现在`DemoPlainClass`的新实例中。如果你创建一个对象`o = DemoPlainClass()`，`o.a`会引发`AttributeError`，而`o.b`和`o.c`将检索具有值`1.1`和`'spam'`的类属性——这只是正常的Python对象行为。
- en: Inspecting a typing.NamedTuple
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查一个`typing.NamedTuple`
- en: Now let’s examine a class built with `typing.NamedTuple` ([Example 5-11](#ex_demo_nt)),
    using the same attributes and annotations as `DemoPlainClass` from [Example 5-10](#ex_demo_plain).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一个使用与[示例 5-10](#ex_demo_plain)中`DemoPlainClass`相同属性和注释构建的类，该类使用`typing.NamedTuple`（[示例
    5-11](#ex_demo_nt)）。
- en: 'Example 5-11\. meaning/demo_nt.py: a class built with `typing.NamedTuple`'
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-11\. meaning/demo_nt.py：使用`typing.NamedTuple`构建的类
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_data_class_builders_CO9-1)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_class_builders_CO9-1)'
- en: '`a` becomes an annotation and also an instance attribute.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`成为一个注释，也成为一个实例属性。'
- en: '[![2](assets/2.png)](#co_data_class_builders_CO9-2)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_class_builders_CO9-2)'
- en: '`b` is another annotation, and also becomes an instance attribute with default
    value `1.1`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`b`是另一个注释，也成为一个具有默认值`1.1`的实例属性。'
- en: '[![3](assets/3.png)](#co_data_class_builders_CO9-3)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_data_class_builders_CO9-3)'
- en: '`c` is just a plain old class attribute; no annotation will refer to it.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`c`只是一个普通的类属性；没有注释会引用它。'
- en: 'Inspecting the `DemoNTClass`, we get:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`DemoNTClass`，我们得到：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we have the same annotations for `a` and `b` as we saw in [Example 5-10](#ex_demo_plain).
    But `typing.NamedTuple` creates `a` and `b` class attributes. The `c` attribute
    is just a plain class attribute with the value `'spam'`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们对`a`和`b`的注释与我们在[示例 5-10](#ex_demo_plain)中看到的相同。但是`typing.NamedTuple`创建了`a`和`b`类属性。`c`属性只是一个具有值`'spam'`的普通类属性。
- en: 'The `a` and `b` class attributes are *descriptors*—an advanced feature covered
    in [Chapter 23](ch23.html#attribute_descriptors). For now, think of them as similar
    to property getters: methods that don’t require the explicit call operator `()`
    to retrieve an instance attribute. In practice, this means `a` and `b` will work
    as read-only instance attributes—which makes sense when we recall that `DemoNTClass`
    instances are just fancy tuples, and tuples are immutable.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`和`b`类属性是*描述符*���这是[第23章](ch23.html#attribute_descriptors)中介绍的一个高级特性。现在，将它们视为类似于属性获取器的属性：这些方法不需要显式调用运算符`()`来检索实例属性。实际上，这意味着`a`和`b`将作为只读实例属性工作——当我们回想起`DemoNTClass`实例只是一种花哨的元组，而元组是不可变的时，这是有道理的。'
- en: '`DemoNTClass` also gets a custom docstring:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`DemoNTClass`也有一个自定义的文档字符串：'
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s inspect an instance of `DemoNTClass`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`DemoNTClass`的一个实例：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To construct `nt`, we need to give at least the `a` argument to `DemoNTClass`.
    The constructor also takes a `b` argument, but it has a default value of `1.1`,
    so it’s optional. The `nt` object has the `a` and `b` attributes as expected;
    it doesn’t have a `c` attribute, but Python retrieves it from the class, as usual.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造`nt`，我们至少需要将`a`参数传递给`DemoNTClass`。构造函数还接受一个`b`参数，但它有一个默认值`1.1`，所以是可选的。`nt`对象具有预期的`a`和`b`属性；它没有`c`属性，但Python会像往常一样从类中检索它。
- en: If you try to assign values to `nt.a`, `nt.b`, `nt.c`, or even `nt.z`, you’ll
    get `Attribute​Error` exceptions with subtly different error messages. Try that
    and reflect on the messages.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试为`nt.a`、`nt.b`、`nt.c`甚至`nt.z`分配值，您将收到略有不同的错误消息的`AttributeError`异常。尝试一下并思考这些消息。
- en: Inspecting a class decorated with dataclass
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查使用dataclass装饰的类
- en: Now, we’ll examine [Example 5-12](#ex_demo_dc).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查[示例 5-12](#ex_demo_dc)。
- en: 'Example 5-12\. meaning/demo_dc.py: a class decorated with `@dataclass`'
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-12\. meaning/demo_dc.py：使用`@dataclass`装饰的类
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_data_class_builders_CO10-1)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_class_builders_CO10-1)'
- en: '`a` becomes an annotation and also an instance attribute controlled by a descriptor.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`变成了一个注释，也是由描述符控制的实例属性。'
- en: '[![2](assets/2.png)](#co_data_class_builders_CO10-2)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_class_builders_CO10-2)'
- en: '`b` is another annotation, and also becomes an instance attribute with a descriptor
    and a default value `1.1`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`b`是另一个注释，也成为一个具有描述符和默认值`1.1`的实例属性。'
- en: '[![3](assets/3.png)](#co_data_class_builders_CO10-3)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_data_class_builders_CO10-3)'
- en: '`c` is just a plain old class attribute; no annotation will refer to it.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`c`只是一个普通的类属性；没有注释会引用它。'
- en: 'Now let’s check out `__annotations__`, `__doc__`, and the `a`, `b`, `c` attributes
    on `Demo​DataClass`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查`DemoDataClass`上的`__annotations__`、`__doc__`和`a`、`b`、`c`属性：
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `__annotations__` and `__doc__` are not surprising. However, there is no
    attribute named `a` in `DemoDataClass`—in contrast with `DemoNTClass` from [Example 5-11](#ex_demo_nt),
    which has a descriptor to get `a` from the instances as read-only attributes (that
    mysterious `<_collections._tuplegetter>`). That’s because the `a` attribute will
    only exist in instances of `DemoDataClass`. It will be a public attribute that
    we can get and set, unless the class is frozen. But `b` and `c` exist as class
    attributes, with `b` holding the default value for the `b` instance attribute,
    while `c` is just a class attribute that will not be bound to the instances.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`__annotations__`和`__doc__`并不奇怪。然而，在`DemoDataClass`中没有名为`a`的属性——与[示例 5-11](#ex_demo_nt)中的`DemoNTClass`相反，后者具有一个描述符来从实例中获取`a`作为只读属性（那个神秘的`<_collections._tuplegetter>`）。这是因为`a`属性只会存在于`DemoDataClass`的实例中。它将是一个公共属性，我们可以获取和设置，除非类被冻结。但是`b`和`c`存在为类属性，`b`保存了`b`实例属性的默认值，而`c`只是一个不会绑定到实例的类属性。'
- en: 'Now let’s see how a `DemoDataClass` instance looks:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`DemoDataClass`实例的外观：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Again, `a` and `b` are instance attributes, and `c` is a class attribute we
    get via the instance.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`a`和`b`是实例属性，`c`是我们通过实例获取的类属性。
- en: 'As mentioned, `DemoDataClass` instances are mutable—and no type checking is
    done at runtime:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`DemoDataClass`实例是可变的—并且在运行时不进行类型检查：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can do even sillier assignments:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以做更愚蠢的赋值：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now the `dc` instance has a `c` attribute—but that does not change the `c`
    class attribute. And we can add a new `z` attribute. This is normal Python behavior:
    regular instances can have their own attributes that don’t appear in the class.^([7](ch05.html#idm46582454350080))'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`dc`实例有一个`c`属性—但这并不会改变`c`类属性。我们可以添加一个新的`z`属性。这是正常的Python行为：常规实例可以有自己的属性，这些属性不会出现在类中。^([7](ch05.html#idm46582454350080))
- en: More About @dataclass
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 @dataclass 的更多信息
- en: 'We’ve only seen simple examples of `@dataclass` use so far. The decorator accepts
    several keyword arguments. This is its signature:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了`@dataclass`的简单示例。装饰器接受几个关键字参数。这是它的签名：
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `*` in the first position means the remaining parameters are keyword-only.
    [Table 5-2](#dataclass_options_tbl) describes them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个位置的`*`表示剩余参数只能通过关键字传递。[表格 5-2](#dataclass_options_tbl)描述了这些参数。
- en: Table 5-2\. Keyword parameters accepted by the `@dataclass` decorator
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 5-2\. `@dataclass`装饰器接受的关键字参数
- en: '| Option | Meaning | Default | Notes |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 含义 | 默认值 | 注释 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `init` | Generate `__init__` | `True` | Ignored if `__init__` is implemented
    by user. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `init` | 生成`__init__` | `True` | 如果用户实现了`__init__`，则忽略。 |'
- en: '| `repr` | Generate `__repr__` | `True` | Ignored if `__repr__` is implemented
    by user. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `repr` | 生成`__repr__` | `True` | 如果用户实现了`__repr__`，则忽略。 |'
- en: '| `eq` | Generate `__eq__` | `True` | Ignored if `__eq__` is implemented by
    user. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `eq` | 生成`__eq__` | `True` | 如果用户实现了`__eq__`，则忽略。 |'
- en: '| `order` | Generate `__lt__`, `__le__`, `__gt__`, `__ge__` | `False` | If
    `True`, raises exceptions if `eq=False`, or if any of the comparison methods that
    would be generated are defined or inherited. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `order` | 生成`__lt__`、`__le__`、`__gt__`、`__ge__` | `False` | 如果为`True`，则在`eq=False`时引发异常，或者如果定义或继承了将要生成的任何比较方法。
    |'
- en: '| `unsafe_hash` | Generate `__hash__` | `False` | Complex semantics and several
    caveats—see: [dataclass documentation](https://fpy.li/5-7). |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `unsafe_hash` | 生成`__hash__` | `False` | 复杂的语义和几个注意事项—参见：[数据类文档](https://fpy.li/5-7)。
    |'
- en: '| `frozen` | Make instances “immutable” | `False` | Instances will be reasonably
    safe from accidental change, but not really immutable.^([a](ch05.html#idm46582454217968))
    |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `frozen` | 使实例“不可变” | `False` | 实例将相对安全免受意外更改，但实际上并非不可变。^([a](ch05.html#idm46582454217968))
    |'
- en: '| ^([a](ch05.html#idm46582454217968-marker)) `@dataclass` emulates immutability
    by generating `__setattr__` and `__delattr__`, which raise `dataclass.FrozenInstanceError`—a
    subclass of `AttributeError`—when the user attempts to set or delete a field.
    |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch05.html#idm46582454217968-marker)) `@dataclass`通过生成`__setattr__`和`__delattr__`来模拟不可变性，当用户尝试设置或删除字段时，会引发`dataclass.FrozenInstanceError`—`AttributeError`的子类。
    |'
- en: 'The defaults are really the most useful settings for common use cases. The
    options you are more likely to change from the defaults are:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 默认设置实际上是最常用的常见用例的最有用设置。你更有可能从默认设置中更改的选项是：
- en: '`frozen=True`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`frozen=True`'
- en: Protects against accidental changes to the class instances.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 防止对类实例的意外更改。
- en: '`order=True`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`order=True`'
- en: Allows sorting of instances of the data class.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 允许对数据类的实例进行排序。
- en: Given the dynamic nature of Python objects, it’s not too hard for a nosy programmer
    to go around the protection afforded by `frozen=True`. But the necessary tricks
    should be easy to spot in a code review.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Python对象的动态特性，一个好奇的程序员很容易绕过`frozen=True`提供的保护。但是在代码审查中，这些必要的技巧应该很容易被发现。
- en: If the `eq` and `frozen` arguments are both `True`, `@dataclass` produces a
    suitable `__hash__` method, so the instances will be hashable. The generated `__hash__`
    will use data from all fields that are not individually excluded using a field
    option we’ll see in [“Field Options”](#field_options_sec). If `frozen=False` (the
    default), `@dataclass` will set `__hash__` to `None`, signalling that the instances
    are unhashable, therefore overriding `__hash__` from any superclass.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`eq`和`frozen`参数都为`True`，`@dataclass`会生成一个合适的`__hash__`方法，因此实例将是可散列的。生成的`__hash__`将使用所有未被单独排除的字段数据，使用我们将在[“字段选项”](#field_options_sec)中看到的字段选项。如果`frozen=False`（默认值），`@dataclass`将将`__hash__`设置为`None`，表示实例是不可散列的，因此覆盖了任何超类的`__hash__`。
- en: '[PEP 557—Data Classes](https://fpy.li/pep557) has this to say about `unsafe_hash`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 557—数据类](https://fpy.li/pep557)对`unsafe_hash`有如下说明：'
- en: Although not recommended, you can force Data Classes to create a `__hash__`
    method with `unsafe_hash=True`. This might be the case if your class is logically
    immutable but can nonetheless be mutated. This is a specialized use case and should
    be considered carefully.
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然不建议这样做，但你可以通过`unsafe_hash=True`强制数据类创建一个`__hash__`方法。如果你的类在逻辑上是不可变的，但仍然可以被改变，这可能是一个特殊的用例，应该仔细考虑。
- en: I will leave `unsafe_hash` at that. If you feel you must use that option, check
    the [`dataclasses.dataclass` documentation](https://fpy.li/5-7).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我会保留`unsafe_hash`。如果你觉得必须使用该选项，请查看[`dataclasses.dataclass`文档](https://fpy.li/5-7)。
- en: Further customization of the generated data class can be done at a field level.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在字段级别进一步定制生成的数据类。
- en: Field Options
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段选项
- en: 'We’ve already seen the most basic field option: providing (or not) a default
    value with the type hint. The instance fields you declare will become parameters
    in the generated `__init__`. Python does not allow parameters without defaults
    after parameters with defaults, therefore after you declare a field with a default
    value, all remaining fields must also have default values.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了最基本的字段选项：使用类型提示提供（或不提供）默认值。你声明的实例字段将成为��成的`__init__`中的参数。Python不允许在具有默认值的参数之后使用没有默认值的参数，因此在声明具有默认值的字段之后，所有剩余字段必须也具有默认值。
- en: 'Mutable default values are a common source of bugs for beginning Python developers.
    In function definitions, a mutable default value is easily corrupted when one
    invocation of the function mutates the default, changing the behavior of further
    invocations—an issue we’ll explore in [“Mutable Types as Parameter Defaults: Bad
    Idea”](ch06.html#mutable_default_parameter_sec) ([Chapter 6](ch06.html#mutability_and_references)).
    Class attributes are often used as default attribute values for instances, including
    in data classes. And `@dataclass` uses the default values in the type hints to
    generate parameters with defaults for `__init__`. To prevent bugs, `@dataclass`
    rejects the class definition in [Example 5-13](#club_wrong_ex).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 可变默认值是初学Python开发者常见的错误来源。在函数定义中，当函数的一个调用改变了默认值时，易变默认值很容易被破坏，从而改变了后续调用的行为——这是我们将在[“可变类型作为参数默认值：不好的想法”](ch06.html#mutable_default_parameter_sec)中探讨的问题（[第6章](ch06.html#mutability_and_references)）。类属性经常被用作实例的默认属性值，包括在数据类中。`@dataclass`使用类型提示中的默认值生成带有默认值的参数供`__init__`使用。为了防止错误，`@dataclass`拒绝了[示例 5-13](#club_wrong_ex)中的类定义。
- en: 'Example 5-13\. *dataclass/club_wrong.py*: this class raises `ValueError`'
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-13\. *dataclass/club_wrong.py*：这个类会引发`ValueError`。
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you load the module with that `ClubMember` class, this is what you get:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加载了具有`ClubMember`类的模块，你会得到这个：
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `ValueError` message explains the problem and suggests a solution: use
    `default_factory`. [Example 5-14](#club_ex) shows how to correct `ClubMember`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueError`消息解释了问题并建议解决方案：使用`default_factory`。[示例 5-14](#club_ex)展示了如何纠正`ClubMember`。'
- en: 'Example 5-14\. *dataclass/club.py*: this `ClubMember` definition works'
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-14\. *dataclass/club.py*：这个`ClubMember`定义可行
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the `guests` field of [Example 5-14](#club_ex), instead of a literal list,
    the default value is set by calling the `dataclasses.field` function with `default_factory=list`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 5-14](#club_ex)的`guests`字段中，不是使用字面列表作为默认值，而是通过调用`dataclasses.field`函数并使用`default_factory=list`来设置默认值。
- en: The `default_factory` parameter lets you provide a function, class, or any other
    callable, which will be invoked with zero arguments to build a default value each
    time an instance of the data class is created. This way, each instance of `ClubMember`
    will have its own `list`—instead of all instances sharing the same `list` from
    the class, which is rarely what we want and is often a bug.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`default_factory`参数允许你提供一个函数、类或任何其他可调用对象，每次创建数据类的实例时都会调用它以构建默认值。这样，`ClubMember`的每个实例都将有自己的`list`，而不是所有实例共享来自类的相同`list`，这很少是我们想要的，通常是一个错误。'
- en: Warning
  id: totrans-252
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: It’s good that `@dataclass` rejects class definitions with a `list` default
    value in a field. However, be aware that it is a partial solution that only applies
    to `list`, `dict`, and `set`. Other mutable values used as defaults will not be
    flagged by `@dataclass`. It’s up to you to understand the problem and remember
    to use a default factory to set mutable default values.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 很好的是`@dataclass`拒绝了具有`list`默认值的字段的类定义。但是，请注意，这是一个部分解决方案，仅适用于`list`、`dict`和`set`。其他用作默认值的可变值不会被`@dataclass`标记。你需要理解问题并记住使用默认工厂来设置可变默认值。
- en: If you browse the [`dataclasses`](https://fpy.li/5-9) module documentation,
    you’ll see a `list` field defined with a novel syntax, as in [Example 5-15](#club_generic_ex).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览[`dataclasses`](https://fpy.li/5-9)模块文档，你会看到一个用新语法定义的`list`字段，就像[示例5-15](#club_generic_ex)中一样。
- en: 'Example 5-15\. *dataclass/club_generic.py*: this `ClubMember` definition is
    more precise'
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-15\. *dataclass/club_generic.py*：这个`ClubMember`定义更加精确
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](assets/1.png)](#co_data_class_builders_CO11-1)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_class_builders_CO11-1)'
- en: '`list[str]` means “a list of str.”'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`list[str]`表示“一个`str`的列表”。'
- en: 'The new syntax `list[str]` is a parameterized generic type: since Python 3.9,
    the `list` built-in accepts that bracket notation to specify the type of the list
    items.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 新的语法`list[str]`是一个参数化的泛型类型：自Python 3.9以来，`list`内置接受方括号表示法来指定列表项的类型。
- en: Warning
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Prior to Python 3.9, the built-in collections did not support generic type
    notation. As a temporary workaround, there are corresponding collection types
    in the `typing` module. If you need a parameterized `list` type hint in Python
    3.8 or earlier, you must import the `List` type from `typing` and use it: `List[str]`.
    For more about this issue, see [“Legacy Support and Deprecated Collection Types”](ch08.html#legacy_deprecated_typing_box).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.9之前，内置的集合不支持泛型类型表示法。作为临时解决方法，在`typing`模块中有相应的集合类型。如果你需要在Python 3.8或更早版本中使用参数化的`list`类型提示，你必须导入`typing`中的`List`类型并使用它：`List[str]`。有关此问题的更多信息，请参阅[“遗留支持和已弃用的集合类型”](ch08.html#legacy_deprecated_typing_box)。
- en: We’ll cover generics in [Chapter 8](ch08.html#type_hints_in_def_ch). For now,
    note that Examples [5-14](#club_ex) and [5-15](#club_generic_ex) are both correct,
    and the Mypy type checker does not complain about either of those class definitions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](ch08.html#type_hints_in_def_ch)中介绍泛型。现在，请注意示例[5-14](#club_ex)和[5-15](#club_generic_ex)都是正确的，Mypy类型检查器不会对这两个类定义提出任何异议。
- en: 'The difference is that `guests: list` means that `guests` can be a `list` of
    objects of any kind, while `guests: list[str]` says that `guests` must be a `list`
    in which every item is a `str`. This will allow the type checker to find (some)
    bugs in code that puts invalid items in the list, or that read items from it.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '区别在于`guests: list`表示`guests`可以是任何类型对象的`list`，而`guests: list[str]`表示`guests`必须是每个项都是`str`的`list`。这将允许类型检查器在将无效项放入列表的代码中找到（一些）错误，或者从中读取项。'
- en: The `default_factory` is likely to be the most common option of the `field`
    function, but there are several others, listed in [Table 5-3](#field_options_tbl).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`default_factory` 很可能是`field`函数的最常见选项，但还有其他几个选项，列在[表5-3](#field_options_tbl)中。'
- en: Table 5-3\. Keyword arguments accepted by the `field` function
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-3\. `field`函数接受的关键字参数
- en: '| Option | Meaning | Default |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 含义 | 默认值 |'
- en: '| --- | --- | --- |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `default` | Default value for field | `_MISSING_TYPE`^([a](ch05.html#idm46582453966752))
    |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `default` | 字段的默认值 | `_MISSING_TYPE`^([a](ch05.html#idm46582453966752)) |'
- en: '| `default_factory` | 0-parameter function used to produce a default | `_MISSING_TYPE`
    |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `default_factory` | 用于生成默认值的0参数函数 | `_MISSING_TYPE` |'
- en: '| `init` | Include field in parameters to `__init__` | `True` |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `init` | 在`__init__`参数中包含字段 | `True` |'
- en: '| `repr` | Include field in `__repr__` | `True` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `repr` | 在`__repr__`中包含字段 | `True` |'
- en: '| `compare` | Use field in comparison methods `__eq__`, `__lt__`, etc. | `True`
    |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `compare` | 在比较方法`__eq__`、`__lt__`等中使用字段 | `True` |'
- en: '| `hash` | Include field in `__hash__` calculation | `None`^([b](ch05.html#idm46582453951136))
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `hash` | 在`__hash__`计算中包含字段 | `None`^([b](ch05.html#idm46582453951136)) |'
- en: '| `metadata` | Mapping with user-defined data; ignored by the `@dataclass`
    | `None` |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `metadata` | 具有用户定义数据的映射；被`@dataclass`忽略 | `None` |'
- en: '| ^([a](ch05.html#idm46582453966752-marker)) `dataclass._MISSING_TYPE` is a
    sentinel value indicating the option was not provided. It exists so we can set
    `None` as an actual default value, a common use case.^([b](ch05.html#idm46582453951136-marker))
    The option `hash=None` means the field will be used in `__hash__` only if `compare=True`.
    |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch05.html#idm46582453966752-marker)) `dataclass._MISSING_TYPE` 是一个标志值，表示未提供选项。它存在的原因是我们可以将`None`设置为实际的默认值，这是一个常见用例。^([b](ch05.html#idm46582453951136-marker))
    选项`hash=None`表示只有在`compare=True`时，该字段才会在`__hash__`中使用。'
- en: 'The `default` option exists because the `field` call takes the place of the
    default value in the field annotation. If you want to create an `athlete` field
    with a default value of `False`, and also omit that field from the `__repr__`
    method, you’d write this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`选项的存在是因为`field`调用取代了字段注释中的默认值。如果要创建一个默认值为`False`的`athlete`字段，并且还要在`__repr__`方法中省略该字段，你可以这样写：'
- en: '[PRE33]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Post-init Processing
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后初始化处理
- en: The `__init__` method generated by `@dataclass` only takes the arguments passed
    and assigns them—or their default values, if missing—to the instance attributes
    that are instance fields. But you may need to do more than that to initialize
    the instance. If that’s the case, you can provide a `__post_init__` method. When
    that method exists, `@dataclass` will add code to the generated `__init__` to
    call `__post_init__` as the last step.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `@dataclass` 生成的 `__init__` 方法只接受传递的参数并将它们分配给实例字段的实例属性，或者如果缺少参数，则分配它们的默认值。但您可能需要做的不仅仅是这些来初始化实例。如果是这种情况，您可以提供一个
    `__post_init__` 方法。当存在该方法时，`@dataclass` 将在生成的 `__init__` 中添加代码，以调用 `__post_init__`
    作为最后一步。
- en: Common use cases for `__post_init__` are validation and computing field values
    based on other fields. We’ll study a simple example that uses `__post_init__`
    for both of these reasons.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`__post_init__` 的常见用例是验证和基于其他字段计算字段值。我们将学习一个简单的示例，该示例使用 `__post_init__` 来实现这两个目的。'
- en: First, let’s look at the expected behavior of a `ClubMember` subclass named
    `HackerClubMember`, as described by doctests in [Example 5-16](#hackerclub_doctests_ex).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看名为 `HackerClubMember` 的 `ClubMember` 子类的预期行为，如 [示例 5-16](#hackerclub_doctests_ex)
    中的文档测试所描述。
- en: 'Example 5-16\. *dataclass/hackerclub.py*: doctests for `HackerClubMember`'
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 5-16\. *dataclass/hackerclub.py*: `HackerClubMember` 的文档测试'
- en: '[PRE34]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that we must provide `handle` as a keyword argument, because `HackerClubMember`
    inherits `name` and `guests` from `ClubMember`, and adds the `handle` field. The
    generated docstring for `HackerClubMember` shows the order of the fields in the
    constructor call:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须将 `handle` 作为关键字参数提供，因为 `HackerClubMember` 继承自 `ClubMember` 的 `name`
    和 `guests`，并添加了 `handle` 字段。生成的 `HackerClubMember` 的文档字符串显示了构造函数调用中字段的顺序：
- en: '[PRE35]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, `<factory>` is a short way of saying that some callable will produce
    the default value for `guests` (in our case, the factory is the `list` class).
    The point is: to provide a `handle` but no `guests`, we must pass `handle` as
    a keyword argument.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<factory>` 是指某个可调用对象将为 `guests` 生成默认值的简便方式（在我们的例子中，工厂是 `list` 类）。关键是：要提供一个
    `handle` 但没有 `guests`，我们必须将 `handle` 作为关键字参数传递。
- en: The [“Inheritance” section of the `dataclasses` module documentation](https://fpy.li/5-10)
    explains how the order of the fields is computed when there are several levels
    of inheritance.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[`dataclasses` 模块文档中的“继承”部分](https://fpy.li/5-10) 解释了在存在多级继承时如何计算字段的顺序。'
- en: Note
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In [Chapter 14](ch14.html#inheritance) we’ll talk about misusing inheritance,
    particularly when the superclasses are not abstract. Creating a hierarchy of data
    classes is usually a bad idea, but it served us well here to make [Example 5-17](#hackerclub_ex)
    shorter, focusing on the `handle` field declaration and `__post_init__` validation.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 14 章](ch14.html#inheritance) 中，我们将讨论错误使用继承，特别是当超类不是抽象类时。创建数据类的层次结构通常不是一个好主意，但在这里，它帮助我们缩短了
    [示例 5-17](#hackerclub_ex) 的长度，侧重于 `handle` 字段声明和 `__post_init__` 验证。
- en: '[Example 5-17](#hackerclub_ex) shows the implementation.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-17](#hackerclub_ex) 展示了实现方式。'
- en: 'Example 5-17\. *dataclass/hackerclub.py*: code for `HackerClubMember`'
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 5-17\. *dataclass/hackerclub.py*: `HackerClubMember` 的代码'
- en: '[PRE36]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[![1](assets/1.png)](#co_data_class_builders_CO12-1)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_class_builders_CO12-1)'
- en: '`HackerClubMember` extends `ClubMember`.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`HackerClubMember` 扩展了 `ClubMember`。'
- en: '[![2](assets/2.png)](#co_data_class_builders_CO12-2)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_class_builders_CO12-2)'
- en: '`all_handles` is a class attribute.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`all_handles` 是一个类属性。'
- en: '[![3](assets/3.png)](#co_data_class_builders_CO12-3)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_data_class_builders_CO12-3)'
- en: '`handle` is an instance field of type `str` with an empty string as its default
    value; this makes it optional.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle` 是一个类型为 `str` 的实例字段，其默认值为空字符串；这使其成为可选的。'
- en: '[![4](assets/4.png)](#co_data_class_builders_CO12-4)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_data_class_builders_CO12-4)'
- en: Get the class of the instance.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 获取实例的类。
- en: '[![5](assets/5.png)](#co_data_class_builders_CO12-5)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_data_class_builders_CO12-5)'
- en: If `self.handle` is the empty string, set it to the first part of `name`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `self.handle` 是空字符串，则将其设置为 `name` 的第一部分。
- en: '[![6](assets/6.png)](#co_data_class_builders_CO12-6)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_data_class_builders_CO12-6)'
- en: If `self.handle` is in `cls.all_handles`, raise `ValueError`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `self.handle` 在 `cls.all_handles` 中，则引发 `ValueError`。
- en: '[![7](assets/7.png)](#co_data_class_builders_CO12-7)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_data_class_builders_CO12-7)'
- en: Add the new `handle` to `cls.all_handles`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 将新的 `handle` 添加到 `cls.all_handles`。
- en: '[Example 5-17](#hackerclub_ex) works as intended, but is not satisfactory to
    a static type checker. Next, we’ll see why, and how to fix it.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-17](#hackerclub_ex) 的功能正常，但对于静态类型检查器来说并不令人满意。接下来，我们将看到原因以及如何解决。'
- en: Typed Class Attributes
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化类属性
- en: 'If we type check [Example 5-17](#hackerclub_ex) with Mypy, we are reprimanded:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 Mypy 对 [示例 5-17](#hackerclub_ex) 进行类型检查，我们会受到批评：
- en: '[PRE37]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Unfortunately, the hint provided by Mypy (version 0.910 as I review this) is
    not helpful in the context of `@dataclass` usage. First, it suggests using `Set`,
    but I am using Python 3.9 so I can use `set`—and avoid importing `Set` from `typing`.
    More importantly, if we add a type hint like `set[…]` to `all_handles`, `@dataclass`
    will find that annotation and make `all_handles` an instance field. We saw this
    happening in [“Inspecting a class decorated with dataclass”](#inspecting_dataclass_sec).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Mypy 提供的提示（我在审阅时使用的版本是 0.910）在 `@dataclass` 使用的上下文中并不有用。首先，它建议使用 `Set`，但我使用的是
    Python 3.9，因此可以使用 `set`，并避免从 `typing` 导入 `Set`。更重要的是，如果我们向 `all_handles` 添加一个类型提示，如
    `set[…]`，`@dataclass` 将找到该注释，并将 `all_handles` 变为实例字段。我们在[“检查使用 dataclass 装饰的类”](#inspecting_dataclass_sec)中看到了这种情况。
- en: The workaround defined in [PEP 526—Syntax for Variable Annotations](https://fpy.li/5-11)
    is ugly. To code a class variable with a type hint, we need to use a pseudotype
    named `typing.ClassVar`, which leverages the generics `[]` notation to set the
    type of the variable and also declare it a class attribute.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [PEP 526—变量注释的语法](https://fpy.li/5-11) 中定义的解决方法很丑陋。为了编写带有类型提示的类变量，我们需要使用一个名为
    `typing.ClassVar` 的伪类型，它利用泛型 `[]` 符号来设置变量的类型，并声明它为类属性。
- en: 'To make the type checker and `@dataclass` happy, this is how we are supposed
    to declare `all_handles` in [Example 5-17](#hackerclub_ex):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让类型检查器和 `@dataclass` 满意，我们应该在 [示例 5-17](#hackerclub_ex) 中这样声明 `all_handles`：
- en: '[PRE38]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'That type hint is saying:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 那个类型提示表示：
- en: '`all_handles` is a class attribute of type `set`-of-`str`, with an empty `set`
    as its default value.'
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`all_handles` 是一个类型为 `set`-of-`str` 的类属性，其默认值为空 `set`。'
- en: To code that annotation, we must import `ClassVar` from the `typing` module.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写该注释的代码，我们必须从 `typing` 模块导入 `ClassVar`。
- en: 'The `@dataclass` decorator doesn’t care about the types in the annotations,
    except in two cases, and this is one of them: if the type is `ClassVar`, an instance
    field will not be generated for that attribute.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`@dataclass` 装饰器不关心注释中的类型，除了两种情况之一，这就是其中之一：如果类型是 `ClassVar`，则不会为该属性生成实例字段。'
- en: The other case where the type of the field is relevant to `@dataclass` is when
    declaring *init-only variables*, our next topic.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明*仅初始化变量*时，字段类型对 `@dataclass` 有影响的另一种情况是我们接下来要讨论的。
- en: Initialization Variables That Are Not Fields
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不是字段的初始化变量
- en: Sometimes you may need to pass arguments to `__init__` that are not instance
    fields. Such arguments are called *init-only variables* by the [`dataclasses`
    documentation](https://fpy.li/initvar). To declare an argument like that, the
    `dataclasses` module provides the pseudotype `InitVar`, which uses the same syntax
    of `typing.ClassVar`. The example given in the documentation is a data class that
    has a field initialized from a database, and the database object must be passed
    to the constructor.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要向 `__init__` 传递不是实例字段的参数。这些参数被 [`dataclasses` 文档](https://fpy.li/initvar)
    称为*仅初始化变量*。要声明这样的参数，`dataclasses` 模块提供了伪类型 `InitVar`，其使用与 `typing.ClassVar` 相同的语法。文档中给出的示例是一个数据类，其字段从数据库初始化，并且必须将数据库对象传递给构造函数。
- en: '[Example 5-18](#initvar_ex) shows the code that illustrates the [“Init-only
    variables” section](https://fpy.li/initvar).'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-18](#initvar_ex) 展示了说明[“仅初始化变量”部分](https://fpy.li/initvar)的代码。'
- en: Example 5-18\. Example from the [`dataclasses`](https://fpy.li/initvar) module
    documentation
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-18\. 来自 [`dataclasses`](https://fpy.li/initvar) 模块文档的示例
- en: '[PRE39]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note how the `database` attribute is declared. `InitVar` will prevent `@dataclass`
    from treating `database` as a regular field. It will not be set as an instance
    attribute, and the `dataclasses.fields` function will not list it. However, `database`
    will be one of the arguments that the generated `__init__` will accept, and it
    will be also passed to `__post_init__`. If you write that method, you must add
    a corresponding argument to the method signature, as shown in [Example 5-18](#initvar_ex).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `database` 属性的声明方式。`InitVar` 将阻止 `@dataclass` 将 `database` 视为常规字段。它不会被设置为实例属性，并且
    `dataclasses.fields` 函数不会列出它。但是，`database` 将是生成的 `__init__` 将接受的参数之一，并且也将传递给 `__post_init__`。如果您编写该方法，必须在方法签名中添加相应的参数，如[示例 5-18](#initvar_ex)
    中所示。
- en: This rather long overview of `@dataclass` covered the most useful features—some
    of them appeared in previous sections, like [“Main Features”](#dc_main_features_sec)
    where we covered all three data class builders in parallel. The [`dataclasses`
    documentation](https://fpy.li/initvar) and [PEP 526—Syntax for Variable Annotations](https://fpy.li/pep526)
    have all the details.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相当长的 `@dataclass` 概述涵盖了最有用的功能——其中一些出现在之前的部分中，比如[“主要特性”](#dc_main_features_sec)，在那里我们并行讨论了所有三个数据类构建器。[`dataclasses`
    文档](https://fpy.li/initvar) 和 [PEP 526—变量注释的语法](https://fpy.li/pep526) 中有所有细节。
- en: In the next section, I present a longer example with `@dataclass`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将展示一个更长的示例，使用 `@dataclass`。
- en: '@dataclass Example: Dublin Core Resource Record'
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@dataclass 示例：Dublin Core 资源记录'
- en: Often, classes built with `@dataclass` will have more fields than the very short
    examples presented so far. [Dublin Core](https://fpy.li/5-12) provides the foundation
    for a more typical `@dataclass` example.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 经常使用 `@dataclass` 构建的类将具有比目前呈现的非常简短示例更多的字段。[Dublin Core](https://fpy.li/5-12)
    为一个更典型的 `@dataclass` 示例提供了基础。
- en: The Dublin Core Schema is a small set of vocabulary terms that can be used to
    describe digital resources (video, images, web pages, etc.), as well as physical
    resources such as books or CDs, and objects like artworks.^([8](ch05.html#idm46582453406656))
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dublin Core Schema 是一组可以用于描述数字资源（视频、图像、网页等）以及实体资源（如书籍或 CD）和艺术品等对象的词汇术语。^([8](ch05.html#idm46582453406656))
- en: ''
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dublin Core on Wikipedia
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 维基百科上的 Dublin Core
- en: The standard defines 15 optional fields; the `Resource` class in [Example 5-19](#resource_ex)
    uses 8 of them.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 标准定义了 15 个可选字段；[示例 5-19](#resource_ex) 中的 `Resource` 类使用了其中的 8 个。
- en: 'Example 5-19\. *dataclass/resource.py*: code for `Resource`, a class based
    on Dublin Core terms'
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 5-19\. *dataclass/resource.py*: `Resource` 类的代码，基于 Dublin Core 术语'
- en: '[PRE40]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](assets/1.png)](#co_data_class_builders_CO13-1)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_class_builders_CO13-1)'
- en: This `Enum` will provide type-safe values for the `Resource.type` field.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Enum` 将为 `Resource.type` 字段提供类型安全的值。
- en: '[![2](assets/2.png)](#co_data_class_builders_CO13-2)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_class_builders_CO13-2)'
- en: '`identifier` is the only required field.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`identifier` 是唯一必需的字段。'
- en: '[![3](assets/3.png)](#co_data_class_builders_CO13-3)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_data_class_builders_CO13-3)'
- en: '`title` is the first field with a default. This forces all fields below to
    provide defaults.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`title` 是第一个具有默认值的字段。这迫使下面的所有字段都提供默认值。'
- en: '[![4](assets/4.png)](#co_data_class_builders_CO13-4)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_data_class_builders_CO13-4)'
- en: The value of `date` can be a `datetime.date` instance, or `None`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`date` 的值可以是 `datetime.date` 实例，或者是 `None`。'
- en: '[![5](assets/5.png)](#co_data_class_builders_CO13-5)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_data_class_builders_CO13-5)'
- en: The `type` field default is `ResourceType.BOOK`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 字段的默认值是 `ResourceType.BOOK`。'
- en: '[Example 5-20](#resource_doctest_ex) shows a doctest to demonstrate how a `Resource`
    record appears in code.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-20](#resource_doctest_ex) 展示了一个 doctest，演示了代码中 `Resource` 记录的外观。'
- en: 'Example 5-20\. *dataclass/resource.py*: code for `Resource`, a class based
    on Dublin Core terms'
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 5-20\. *dataclass/resource.py*: `Resource` 类的代码，基于 Dublin Core 术语'
- en: '[PRE41]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `__repr__` generated by `@dataclass` is OK, but we can make it more readable.
    This is the format we want from `repr(book)`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `@dataclass` 生成的 `__repr__` 是可以的，但我们可以使其更易读。这是我们希望从 `repr(book)` 得到的格式：
- en: '[PRE42]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[Example 5-21](#resource_repr_ex) is the code of `__repr__` to produce the
    format shown in the last snippet. This example uses `dataclass.fields` to get
    the names of the data class fields.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-21](#resource_repr_ex) 是用于生成最后代码片段中所示格式的`__repr__`的代码。此示例使用`dataclass.fields`来获取数据类字段的名称。'
- en: 'Example 5-21\. `dataclass/resource_repr.py`: code for `__repr__` method implemented
    in the `Resource` class from [Example 5-19](#resource_ex)'
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-21\. `dataclass/resource_repr.py`：在[示例 5-19](#resource_ex)中实现的`Resource`类中实现的`__repr__`方法的代码
- en: '[PRE43]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_data_class_builders_CO14-1)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_class_builders_CO14-1)'
- en: Start the `res` list to build the output string with the class name and open
    parenthesis.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 开始`res`列表以构建包含类名和开括号的输出字符串。
- en: '[![2](assets/2.png)](#co_data_class_builders_CO14-2)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_class_builders_CO14-2)'
- en: For each field `f` in the class…
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类中的每个字段`f`…
- en: '[![3](assets/3.png)](#co_data_class_builders_CO14-3)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_data_class_builders_CO14-3)'
- en: …get the named attribute from the instance.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: …从实例中获取命名属性。
- en: '[![4](assets/4.png)](#co_data_class_builders_CO14-4)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_data_class_builders_CO14-4)'
- en: Append an indented line with the name of the field and `repr(value)`—that’s
    what the `!r` does.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 附加一个缩进的行，带有字段的名称和`repr(value)`—这就是`!r`的作用。
- en: '[![5](assets/5.png)](#co_data_class_builders_CO14-5)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_data_class_builders_CO14-5)'
- en: Append closing parenthesis.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 附加闭括号。
- en: '[![6](assets/6.png)](#co_data_class_builders_CO14-6)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_data_class_builders_CO14-6)'
- en: Build a multiline string from `res` and return it.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 从`res`构建一个多行字符串并返回它。
- en: With this example inspired by the soul of Dublin, Ohio, we conclude our tour
    of Python’s data class builders.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个受到俄亥俄州都柏林灵感的例子，我们结束了对Python数据类构建器的介绍。
- en: Data classes are handy, but your project may suffer if you overuse them. The
    next section explains.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类很方便，但如果过度使用它们，您的项目可能会受到影响。接下来的部分将进行解释。
- en: Data Class as a Code Smell
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类作为代码异味
- en: Whether you implement a data class by writing all the code yourself or leveraging
    one of the class builders described in this chapter, be aware that it may signal
    a problem in your design.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是通过自己编写所有代码来实现数据类，还是利用本章描述的类构建器之一，都要意识到它可能在您的设计中信号问题。
- en: 'In [*Refactoring: Improving the Design of Existing Code*, 2nd ed.](https://martinfowler.com/books/refactoring.html)
    (Addison-Wesley), Martin Fowler and Kent Beck present a catalog of “code smells”—patterns
    in code that may indicate the need for refactoring. The entry titled “Data Class”
    starts like this:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*重构：改善现有代码设计，第2版*](https://martinfowler.com/books/refactoring.html)（Addison-Wesley）中，Martin
    Fowler和Kent Beck提供了一个“代码异味”目录—代码中可能表明需要重构的模式。标题为“数据类”的条目开头是这样的：
- en: These are classes that have fields, getting and setting methods for fields,
    and nothing else. Such classes are dumb data holders and are often being manipulated
    in far too much detail by other classes.
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些类具有字段、获取和设置字段的方法，除此之外什么都没有。这样的类是愚蠢的数据持有者，往往被其他类以过于详细的方式操纵。
- en: In Fowler’s personal website, there’s an illuminating post titled [“Code Smell”](https://fpy.li/5-14).
    The post is very relevant to our discussion because he uses *data class* as one
    example of a code smell and suggests how to deal with it. Here is the post, reproduced
    in full.^([9](ch05.html#idm46582452758976))
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在福勒的个人网站上，有一篇标题为[“代码异味”](https://fpy.li/5-14)的启发性文章。这篇文章与我们的讨论非常相关，因为他将*数据类*作为代码异味的一个例子，并建议如何处理。以下是完整的文章。^([9](ch05.html#idm46582452758976))
- en: 'The main idea of object-oriented programming is to place behavior and data
    together in the same code unit: a class. If a class is widely used but has no
    significant behavior of its own, it’s possible that code dealing with its instances
    is scattered (and even duplicated) in methods and functions throughout the system—a
    recipe for maintenance headaches. That’s why Fowler’s refactorings to deal with
    a data class involve bringing responsibilities back into it.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的主要思想是将行为和数据放在同一个代码单元中：一个类。如果一个类被广泛使用但本身没有重要的行为，那么处理其实例的代码可能分散在整个系统的方法和函数中（甚至重复）—这是维护头痛的根源。这就是为什么福勒的重构涉及将责任带回到数据类中。
- en: Taking that into account, there are a couple of common scenarios where it makes
    sense to have a data class with little or no behavior.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，有几种常见情况下，拥有一个几乎没有行为的数据类是有意义的。
- en: Data Class as Scaffolding
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类作为脚手架
- en: In this scenario, the data class is an initial, simplistic implementation of
    a class to jump-start a new project or module. With time, the class should get
    its own methods, instead of relying on methods of other classes to operate on
    its instances. Scaffolding is temporary; eventually your custom class may become
    fully independent from the builder you used to start it.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数据类是一个初始的、简单的类实现，用于启动新项目或模块。随着时间的推移，该类应该拥有自己的方法，而不是依赖其他类的方法来操作其实例。脚手架是临时的；最终，您的自定义类可能会完全独立于您用来启动它的构建器。
- en: Python is also used for quick problem solving and experimentation, and then
    it’s OK to leave the scaffolding in place.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Python也用于快速问题解决和实验，然后保留脚手架是可以的。
- en: Data Class as Intermediate Representation
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类作为中间表示
- en: A data class can be useful to build records about to be exported to JSON or
    some other interchange format, or to hold data that was just imported, crossing
    some system boundary. Python’s data class builders all provide a method or function
    to convert an instance to a plain `dict`, and you can always invoke the constructor
    with a `dict` used as keyword arguments expanded with `**`. Such a `dict` is very
    close to a JSON record.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类可用于构建即将导出到JSON或其他交换格式的记录，或者保存刚刚导入的数据，跨越某些系统边界。Python的数据类构建器都提供了一个方法或函数，将实例转换为普通的`dict`，您总是可以调用构造函数，使用作为关键字参数扩展的`**`的`dict`。这样的`dict`非常接近JSON记录。
- en: In this scenario, the data class instances should be handled as immutable objects—even
    if the fields are mutable, you should not change them while they are in this intermediate
    form. If you do, you’re losing the key benefit of having data and behavior close
    together. When importing/exporting requires changing values, you should implement
    your own builder methods instead of using the given “as dict” methods or standard
    constructors.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数据类实例应被视为不可变对象—即使字段是可变的，也不应在其处于这种中间形式时更改它们。如果这样做，您将失去将数据和行为紧密结合的主要优势。当导入/导出需要更改值时，您应该实现自己的构建器方法，而不是使用给定的“作为字典”方法或标准构造函数。
- en: Now we change the subject to see how to write patterns that match instances
    of arbitrary classes, and not just the sequences and mappings we’ve seen in [“Pattern
    Matching with Sequences”](ch02.html#sequence_patterns_sec) and [“Pattern Matching
    with Mappings”](ch03.html#pattern_matching_mappings_sec).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们改变主题，看看如何编写匹配任意类实例而不仅仅是我们在[“使用序列进行模式匹配”](ch02.html#sequence_patterns_sec)和[“使用映射进行模式匹配”](ch03.html#pattern_matching_mappings_sec)中看到的序列和映射的模式。
- en: Pattern Matching Class Instances
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配类实例
- en: Class patterns are designed to match class instances by type and—optionally—by
    attributes. The subject of a class pattern can be any class instance, not only
    instances of data classes.^([10](ch05.html#idm46582452737920))
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 类模式旨在通过类型和—可选地—属性来匹配类实例。类模式的主题可以是任何类实例，不仅仅是数据类的实例。^([10](ch05.html#idm46582452737920))
- en: 'There are three variations of class patterns: simple, keyword, and positional.
    We’ll study them in that order.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 类模式有三种变体：简单、关键字和位置。我们将按照这个顺序来学习它们。
- en: Simple Class Patterns
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单类模式
- en: 'We’ve already seen an example with simple class patterns used as subpatterns
    in [“Pattern Matching with Sequences”](ch02.html#sequence_patterns_sec):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个简单类模式作为子模式在[“使用序列进行模式匹配”](ch02.html#sequence_patterns_sec)中的示例：
- en: '[PRE44]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That pattern matches a four-item sequence where the first item must be an instance
    of `str`, and the last item must be a 2-tuple with two instances of `float`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式匹配一个四项序列，其中第一项必须是`str`的实例，最后一项必须是一个包含两个`float`实例的2元组。
- en: 'The syntax for class patterns looks like a constructor invocation. The following
    is a class pattern that matches `float` values without binding a variable (the
    case body can refer to `x` directly if needed):'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 类模式的语法看起来像一个构造函数调用。以下是一个类模式，匹配`float`值而不绑定变量（如果需要，case体可以直接引用`x`）：
- en: '[PRE45]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'But this is likely to be a bug in your code:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 但这很可能是您代码中的一个错误：
- en: '[PRE46]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding example, `case float:` matches any subject, because Python
    sees `float` as a variable, which is then bound to the subject.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`case float:`匹配任何主题，因为Python将`float`视为一个变量，然后将其绑定到主题。
- en: 'The simple pattern syntax of `float(x)` is a special case that applies only
    to nine blessed built-in types, listed at the end of the [“Class Patterns”](https://fpy.li/5-16)
    section of [PEP 634—Structural Pattern Matching: Specification](https://fpy.li/pep634):'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`float(x)`的简单模式语法是一个特例，仅适用于列在[“类模式”](https://fpy.li/5-16)部分末尾的PEP 634—结构化模式匹配：规范中的九个受祝福的内置类型：'
- en: '[PRE47]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In those classes, the variable that looks like a constructor argument—e.g.,
    the `x` in `float(x)`—is bound to the whole subject instance or the part of the
    subject that matches a subpattern, as exemplified by `str(name)` in the sequence
    pattern we saw earlier:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些类中，看起来像构造函数参数的变量—例如，在我们之前看到的序列模式中的`str(name)`中的`x`—被绑定到整个主题实例或与子模式匹配的主题部分，如示例中的`str(name)`所示：
- en: '[PRE48]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If the class is not one of those nine blessed built-ins, then the argument-like
    variables represent patterns to be matched against attributes of an instance of
    that class.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类不是这九个受祝福的内置类型之一，那么类似参数的变量表示要与该类实例的属性进行匹配的模式。
- en: Keyword Class Patterns
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键字类模式
- en: To understand how to use keyword class patterns, consider the following `City`
    class and five instances in [Example 5-22](#ex_cities_match).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用关键字类模式，请考虑以下`City`类和[示例 5-22](#ex_cities_match)中的五个实例。
- en: Example 5-22\. `City` class and a few instances
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-22\. `City`类和一些实例
- en: '[PRE49]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Given those definitions, the following function would return a list of Asian
    cities:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些定义，以下函数将返回一个亚洲城市列表：
- en: '[PRE50]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The pattern `City(continent='Asia')` matches any `City` instance where the `continent`
    attribute value is equal to `'Asia'`, regardless of the values of the other attributes.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 模式`City(continent='Asia')`匹配任何`City`实例，其中`continent`属性值等于`'Asia'`，而不管其他属性的值如何。
- en: 'If you want to collect the value of the `country` attribute, you could write:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想收集`country`属性的值，您可以编写：
- en: '[PRE51]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The pattern `City(continent=''Asia'', country=cc)` matches the same Asian cities
    as before, but now the `cc` variable is bound to the `country` attribute of the
    instance. This also works if the pattern variable is called `country` as well:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 模式`City(continent='Asia', country=cc)`匹配与之前相同的亚洲城市，但现在`cc`变量绑定到实例的`country`属性。如果模式变量也称为`country`，这也适用：
- en: '[PRE52]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Keyword class patterns are very readable, and work with any class that has public
    instance attributes, but they are somewhat verbose.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字类模式非常易读，并且适用于具有公共实例属性的任何类，但它们有点冗长。
- en: Positional class patterns are more convenient in some cases, but they require
    explicit support by the class of the subject, as we’ll see next.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 位置类模式在某些情况下更方便，但它们需要主题类的显式支持，我们将在下一节中看到。
- en: Positional Class Patterns
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置类模式
- en: 'Given the definitions from [Example 5-22](#ex_cities_match), the following
    function would return a list of Asian cities, using a positional class pattern:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 给定[示例 5-22](#ex_cities_match)中的定义，以下函数将使用位置类模式返回一个亚洲城市列表：
- en: '[PRE53]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The pattern `City('Asia')` matches any `City` instance where the first attribute
    value is `'Asia'`, regardless of the values of the other attributes.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 模式`City('Asia')`匹配任何`City`实例，其中第一个属性值为`'Asia'`，而不管其他属性的值如何。
- en: 'If you want to collect the value of the `country` attribute, you could write:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您���收集`country`属性的值，您可以编写：
- en: '[PRE54]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The pattern `City('Asia', _, country)` matches the same cities as before, but
    now the `country` variable is bound to the third attribute of the instance.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 模式`City('Asia', _, country)`匹配与之前相同的城市，但现在`country`变量绑定到实例的第三个属性。
- en: I’ve mentioned “first” or “third” attribute, but what does that really mean?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到了“第一个”或“第三个”属性，但这到底是什么意思？
- en: 'What makes `City` or any class work with positional patterns is the presence
    of a special class attribute named `__match_args__`, which the class builders
    in this chapter automatically create. This is the value of `__match_args__` in
    the `City` class:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 使`City`或任何类与位置模式配合工作的是一个名为`__match_args__`的特殊类属性的存在，这是本章中的类构建器自动创建的。这是`City`类中`__match_args__`的值：
- en: '[PRE55]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you can see, `__match_args__` declares the names of the attributes in the
    order they will be used in positional patterns.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`__match_args__`声明了属性的名称，按照它们在位置模式中使用的顺序。
- en: In [“Supporting Positional Pattern Matching”](ch11.html#positional_pattern_implement_sec)
    we’ll write code to define `__match_args__` for a class we’ll create without the
    help of a class builder.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“支持位置模式匹配”](ch11.html#positional_pattern_implement_sec)中，我们将编写代码为一个我们将在没有类构建器帮助的情况下创建的类定义`__match_args__`。
- en: Tip
  id: totrans-424
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can combine keyword and positional arguments in a pattern. Some, but not
    all, of the instance attributes available for matching may be listed in `__match_args__`.
    Therefore, sometimes you may need to use keyword arguments in addition to positional
    arguments in a pattern.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在模式中组合关键字和位置参数。可能列出用于匹配的实例属性中的一些，但不是全部，可能需要在模式中除了位置参数之外还使用关键字参数。
- en: Time for a chapter summary.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行章节总结了。
- en: Chapter Summary
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: The main topic of this chapter was the data class builders `collections.namedtuple`,
    `typing.NamedTuple`, and `dataclasses.dataclass`. We saw that each generates data
    classes from descriptions provided as arguments to a factory function, or from
    `class` statements with type hints in the case of the latter two. In particular,
    both named tuple variants produce `tuple` subclasses, adding only the ability
    to access fields by name, and providing a `_fields` class attribute listing the
    field names as a tuple of strings.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题是数据类构建器`collections.namedtuple`，`typing.NamedTuple`和`dataclasses.dataclass`。我们看到，每个都从作为工厂函数参数提供的描述生成数据类，或者从`class`语句中生成具有类型提示的后两者。特别是，两种命名元组变体都生成`tuple`子类，仅添加按名称访问字段的能力，并提供一个列出字段名称的`_fields`类属性，作为字符串元组。
- en: Next we studied the main features of the three class builders side by side,
    including how to extract instance data as a `dict`, how to get the names and default
    values of fields, and how to make a new instance from an existing one.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们并排研究了三个类构建器的主要特性，包括如何将实例数据提取为`dict`，如何获取字段的名称和默认值，以及如何从现有实例创建新实例。
- en: This prompted our first look into type hints, particularly those used to annotate
    attributes in a `class` statement, using the notation introduced in Python 3.6
    with [PEP 526—Syntax for Variable Annotations](https://fpy.li/pep526). Probably
    the most surprising aspect of type hints in general is the fact that they have
    no effect at all at runtime. Python remains a dynamic language. External tools,
    like Mypy, are needed to take advantage of typing information to detect errors
    via static analysis of the source code. After a basic overview of the syntax from
    PEP 526, we studied the effect of annotations in a plain class and in classes
    built by `typing.NamedTuple` and `@dataclass`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这促使我们首次研究类型提示，特别是用于注释`class`语句中属性的提示，使用Python 3.6中引入的符号，[PEP 526—变量注释语法](https://fpy.li/pep526)。总体而言，类型提示最令人惊讶的方面可能是它们在运行时根本没有任何影响。Python仍然是一种动态语言。需要外部工具，如Mypy，利用类型信息通过对源代码的静态分析来检测错误。在对PEP
    526中的语法进行基本概述后，我们研究了在普通类和由`typing.NamedTuple`和`@dataclass`构建的类中注释的效果。
- en: Next, we covered the most commonly used features provided by `@dataclass` and
    the `default_factory` option of the `dataclasses.field` function. We also looked
    into the special pseudotype hints `typing.ClassVar` and `dataclasses.InitVar`
    that are important in the context of data classes. This main topic concluded with
    an example based on the Dublin Core Schema, which illustrated how to use `dataclasses.fields`
    to iterate over the attributes of a `Resource` instance in a custom `__repr__`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了`@dataclass`提供的最常用功能以及`dataclasses.field`函数的`default_factory`选项。我们还研究了在数据类上下文中重要的特殊伪类型提示`typing.ClassVar`和`dataclasses.InitVar`。这个主题以基于Dublin
    Core Schema的示例结束，示例说明了如何使用`dataclasses.fields`在自定义的`__repr__`中迭代`Resource`实例的属性。
- en: 'Then, we warned against possible abuse of data classes defeating a basic principle
    of object-oriented programming: data and the functions that touch it should be
    together in the same class. Classes with no logic may be a sign of misplaced logic.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们警告可能滥用数据类，违反面向对象编程的基本原则：数据和触及数据的函数应该在同一个类中。没有逻辑的类可能是放错逻辑的迹象。
- en: In the last section, we saw how pattern matching works with subjects that are
    instances of any class—not just classes built with the class builders presented
    in this chapter.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们看到了模式匹配如何与任何类的实例一起使用，而不仅仅是本章介绍的类构建器构建的类。
- en: Further Reading
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Python’s standard documentation for the data class builders we covered is very
    good, and has quite a few small examples.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Python对我们涵盖的数据类构建器的标准文档非常好，并且有相当多的小例子。
- en: 'For `@dataclass` in particular, most of [PEP 557—Data Classes](https://fpy.li/pep557)
    was copied into the [`dataclasses`](https://fpy.li/5-9) module documentation.
    But [PEP 557](https://fpy.li/pep557) has a few very informative sections that
    were not copied, including [“Why not just use namedtuple?”](https://fpy.li/5-18),
    [“Why not just use typing.NamedTuple?”](https://fpy.li/5-19), and the [“Rationale”
    section](https://fpy.li/5-20), which concludes with this Q&A:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特别的 `@dataclass`，[PEP 557—数据类](https://fpy.li/pep557) 的大部分内容都被复制到了 [`dataclasses`](https://fpy.li/5-9)
    模块文档中。但 [PEP 557](https://fpy.li/pep557) 还有一些非常信息丰富的部分没有被复制，包括 [“为什么不只使用 namedtuple？”](https://fpy.li/5-18)，[“为什么不只使用
    typing.NamedTuple？”](https://fpy.li/5-19)，以及以这个问答结束的 [“原理” 部分](https://fpy.li/5-20)：
- en: Where is it not appropriate to use Data Classes?
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在哪些情况下不适合使用数据类？
- en: ''
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: API compatibility with tuples or dicts is required. Type validation beyond that
    provided by PEPs 484 and 526 is required, or value validation or conversion is
    required.
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: API 兼容元组或字典是必需的。需要超出 PEPs 484 和 526 提供的类型验证，或者需要值验证或转换。
- en: ''
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Eric V. Smith, PEP 557 “Rationale”
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Eric V. Smith，PEP 557 “原理”
- en: Over at [*RealPython.com*](https://fpy.li/5-21), Geir Arne Hjelle wrote a very
    complete [“Ultimate guide to data classes in Python 3.7”](https://fpy.li/5-22).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*RealPython.com*](https://fpy.li/5-21) 上，Geir Arne Hjelle 写了一篇非常完整的 [“Python
    3.7 中数据类的终极指南”](https://fpy.li/5-22)。
- en: 'At PyCon US 2018, Raymond Hettinger presented [“Dataclasses: The code generator
    to end all code generators” (video)](https://fpy.li/5-23).'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PyCon US 2018 上，Raymond Hettinger 提出了 [“数据类：终结所有代码生成器的代码生成器”（视频）](https://fpy.li/5-23)。
- en: 'For more features and advanced functionality, including validation, the [*attrs*
    project](https://fpy.li/5-24) led by Hynek Schlawack appeared years before `dataclasses`,
    and offers more features, promising to “bring back the joy of writing classes
    by relieving you from the drudgery of implementing object protocols (aka dunder
    methods).” The influence of *attrs* on `@dataclass` is acknowledged by Eric V.
    Smith in PEP 557. This probably includes Smith’s most important API decision:
    the use of a class decorator instead of a base class and/or a metaclass to do
    the job.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多功能和高级功能，包括验证，由 Hynek Schlawack 领导的 [*attrs* 项目](https://fpy.li/5-24) 在 `dataclasses`
    出现多年之前，并提供更多功能，承诺“通过解除您实现对象协议（也称为 dunder 方法）的繁琐工作，带回编写类的乐趣。” Eric V. Smith 在 PEP
    557 中承认 *attrs* 对 `@dataclass` 的影响。这可能包括 Smith 最重要的 API 决定：使用类装饰器而不是基类和/或元类来完成工作。
- en: Glyph—founder of the Twisted project—wrote an excellent introduction to *attrs*
    in [“The One Python Library Everyone Needs”](https://fpy.li/5-25). The *attrs*
    documentation includes a [discussion of alternatives](https://fpy.li/5-26).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: Glyph——Twisted 项目的创始人——在 [“每个人都需要的一个 Python 库”](https://fpy.li/5-25) 中写了一篇关于
    *attrs* 的优秀介绍。*attrs* 文档包括 [替代方案的讨论](https://fpy.li/5-26)。
- en: 'Book author, instructor, and mad computer scientist Dave Beazley wrote [*cluegen*](https://fpy.li/5-27),
    yet another data class generator. If you’ve seen any of Dave’s talks, you know
    he is a master of metaprogramming Python from first principles. So I found it
    inspiring to learn from the *cluegen* *README.md* file the concrete use case that
    motivated him to write an alternative to Python’s `@dataclass`, and his philosophy
    of presenting an approach to solve the problem, in contrast to providing a tool:
    the tool may be quicker to use at first, but the approach is more flexible and
    can take you as far as you want to go.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍作者、讲师和疯狂的计算机科学家 Dave Beazley 写了 [*cluegen*](https://fpy.li/5-27)，又一个数据类生成器。如果你看过
    Dave 的任何演讲，你就知道他是一个从第一原则开始元编程 Python 的大师。因此，我发现从 *cluegen* 的 *README.md* 文件中了解到��励他编写
    Python 的 `@dataclass` 替代方案的具体用例，以及他提出解决问题方法的哲学，与提供工具相对立：工具可能一开始使用更快，但方法更灵活，可以带你走得更远。
- en: Regarding *data class* as a code smell, the best source I found was Martin Fowler’s
    book *Refactoring*, 2nd ed. This newest version is missing the quote from the
    epigraph of this chapter, “Data classes are like children…,” but otherwise it’s
    the best edition of Fowler’s most famous book, particularly for Pythonistas because
    the examples are in modern JavaScript, which is closer to Python than Java—the
    language of the first edition.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *数据类* 视为代码坏味道，我找到的最好的来源是 Martin Fowler 的书 *重构*，第二版。这个最新版本缺少了本章前言的引语，“数据类就像孩子一样……”，但除此之外，这是
    Fowler 最著名的书的最佳版本，特别适合 Python 程序员，因为示例是用现代 JavaScript 编写的，这比 Java 更接近 Python——第一版的语言。
- en: The website [*Refactoring Guru*](https://fpy.li/5-28) also has a description
    of the [data class code smell](https://fpy.li/5-29).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 网站 [*Refactoring Guru*](https://fpy.li/5-28) 也对 [数据类代码坏味道](https://fpy.li/5-29)
    进行了描述。
- en: ^([1](ch05.html#idm46582456501248-marker)) From *Refactoring*, first edition,
    Chapter 3, “Bad Smells in Code, Data Class” section, page 87 (Addison-Wesley).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#idm46582456501248-marker)) 来自《重构》，第一版，第 3 章，“代码中的坏味道，数据类”部分，第
    87 页（Addison-Wesley）。
- en: ^([2](ch05.html#idm46582456097616-marker)) Metaclasses are one of the subjects
    covered in [Chapter 24, “Class Metaprogramming”](ch24.html#class_metaprog).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.html#idm46582456097616-marker)) 元类是 [第 24 章，“类元编程”](ch24.html#class_metaprog)
    中涵盖的主题之一。
- en: ^([3](ch05.html#idm46582455952240-marker)) Class decorators are covered in [Chapter 24](ch24.html#class_metaprog),
    “Class Metaprogramming,” along with metaclasses. Both are ways of customizing
    class behavior beyond what is possible with inheritance.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.html#idm46582455952240-marker)) 类装饰器在 [第 24 章](ch24.html#class_metaprog)，“类元编程”
    中有介绍，与元类一起。两者都是超出继承可能的方式来定制类行为。
- en: ^([4](ch05.html#idm46582455283904-marker)) If you know Ruby, you know that injecting
    methods is a well-known but controversial technique among Rubyists. In Python,
    it’s not as common, because it doesn’t work with any built-in type—`str`, `list`,
    etc. I consider this limitation of Python a blessing.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch05.html#idm46582455283904-marker)) 如果你了解 Ruby，你会知道在 Ruby 程序员中，注入方法是一种众所周知但有争议的技术。在
    Python 中，这并不常见，因为它不适用于任何内置类型——`str`，`list` 等。我认为这是 Python 的一个福音。
- en: ^([5](ch05.html#idm46582455040272-marker)) In the context of type hints, `None`
    is not the `NoneType` singleton, but an alias for `NoneType` itself. This is strange
    when we stop to think about it, but appeals to our intuition and makes function
    return annotations easier to read in the common case of functions that return
    `None`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch05.html#idm46582455040272-marker)) 在类型提示的背景下，`None`不是`NoneType`的单例，而是`NoneType`本身的别名。当我们停下来思考时，这看起来很奇怪，但符合我们的直觉，并且使函数返回注解在返回`None`的常见情况下更容易阅读。
- en: ^([6](ch05.html#idm46582454850176-marker)) Python has no concept of *undefined*,
    one of the silliest mistakes in the design of JavaScript. Thank Guido!
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch05.html#idm46582454850176-marker)) Python没有*未定义*的概念，这是JavaScript设计中最愚蠢的错误之一。感谢Guido！
- en: ^([7](ch05.html#idm46582454350080-marker)) Setting an attribute after `__init__`
    defeats the `__dict__` key-sharing memory optimization mentioned in [“Practical
    Consequences of How dict Works”](ch03.html#consequences_dict_internals).
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch05.html#idm46582454350080-marker)) 在`__init__`之后设置属性会破坏[“dict工作方式的实际后果”](ch03.html#consequences_dict_internals)中提到的`__dict__`键共享内存优化。
- en: '^([8](ch05.html#idm46582453406656-marker)) Source: [Dublin Core](https://fpy.li/5-13)
    article in the English Wikipedia.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch05.html#idm46582453406656-marker)) 来源：[都柏林核心](https://fpy.li/5-13) 英文维基百科文章。
- en: ^([9](ch05.html#idm46582452758976-marker)) I am fortunate to have Martin Fowler
    as a colleague at Thoughtworks, so it took just 20 minutes to get his permission.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch05.html#idm46582452758976-marker)) 我很幸运在Thoughtworks有马丁·福勒作为同事，所以只用了20分钟就得到了他的许可。
- en: '^([10](ch05.html#idm46582452737920-marker)) I put this content here because
    it is the earliest chapter focusing on user-defined classes, and I thought pattern
    matching with classes was too important to wait until [Part II](part02.html#function_objects_part)
    of the book. My philosophy: it’s more important to know how to use classes than
    to define classes.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch05.html#idm46582452737920-marker)) 我将这部分内容放在这里，因为这是最早关注用户定义类的章节，我认为与类一起使用模式匹配太重要，不能等到书的[第二部分](part02.html#function_objects_part)。我的理念是：了解如何使用类比定义类更重要。
