<html><head></head><body>
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Protocols" class="preface"><div class="preface" id="protocols">
<h1 class="calibre10" id="calibre_pb_0"><span class="calibre">Chapter 13. </span>Protocols</h1>


<p class="author1">I have a confession to make. I’ve been skirting around something in the Python type system that, upon first glance, is contradictory. It has to do with a key difference in philosophy between the Python runtime type system and the static type hints.</p>

<p class="author1">Back in <a data-type="xref" href="part0005_split_000.html#types" class="calibre5">Chapter 2</a>, I described how Python supports duck typing.<a data-type="indexterm" data-primary="duck typing" id="idm45644736333176" class="calibre5"/> Recall that this means you can use objects in a context as long as that object supports a specific set of behaviors. You don’t need any sort of parent class or predefined inheritance structure to use duck typing.</p>

<p class="author1">However, the typechecker has no clue how to handle duck typing without any assistance.<a data-type="indexterm" data-primary="typechecking" data-secondary="protocols annotating duck typed variables during" id="idm45644736331768" class="calibre5"/> The typechecker knows how to handle types known at static analysis time, but how does it handle duck-typed decisions made at runtime?</p>

<p class="author1">To remedy this, I’m going to introduce protocols, a feature introduced in Python 3.8. Protocols solve the contradiction listed above; they annotate duck-typed variables during typechecking. I’ll cover why you need protocols, how to define your own, and how to use them in advanced scenarios. But before you start, you need to understand the disconnect between Python’s duck typing and static typecheckers.</p>






</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Protocols" class="preface">
<div class="preface" id="protocols">
<section data-type="sect1" data-pdf-bookmark="Tension Between Typing Systems" class="preface"><div class="preface" id="idm45644736329608">
<h1 class="calibre12" id="calibre_pb_1">Tension Between Typing Systems</h1>

<p class="author1">In this chapter, you are going to build an automated lunch shop’s digital menu system. <a data-type="indexterm" data-primary="type systems" data-secondary="tension between runtime type system and  static type hints" id="ix_typsysten" class="calibre5"/><a data-type="indexterm" data-primary="types" data-secondary="tension between typing systems" id="ix_typten" class="calibre5"/>This restaurant has a variety of entries that are “splittable,” meaning you can get a half order. Deli sandwiches, wraps, and soups can be split, but entries like drinks and hamburgers cannot be split. In the interest of deduplication, I want one method that does all the splitting. Here are some entries as an example:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">BLTSandwich</code><code class="calibre17">:</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">cost</code> <code class="calibre17">=</code> <code class="mi">6.95</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">name</code> <code class="calibre17">=</code> <code class="s">'BLT'</code>
        <code class="c"># This class handles a fully constructed BLT sandwich</code>
        <code class="c"># ...</code>

    <code class="k">def</code> <code class="nf">split_in_half</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">tuple</code><code class="calibre17">[</code><code class="s">'BLTSandwich'</code><code class="calibre17">,</code> <code class="s">'BLTSandwich'</code><code class="calibre17">]:</code>
        <code class="c"># Instructions for how to split a sandwich in half</code>
        <code class="c"># Cut along diagonal, wrap separately, etc.</code>
        <code class="c"># Return two sandwiches in return</code>

<code class="k">class</code> <code class="nc">Chili</code><code class="calibre17">:</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">cost</code> <code class="calibre17">=</code> <code class="mi">4.95</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">name</code> <code class="calibre17">=</code> <code class="s">'Chili'</code>
        <code class="c"># This class handles a fully loaded chili</code>
        <code class="c"># ...</code>

    <code class="k">def</code> <code class="nf">split_in_half</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">tuple</code><code class="calibre17">[</code><code class="s">'Chili'</code><code class="calibre17">,</code> <code class="s">'Chili'</code><code class="calibre17">]:</code>
        <code class="c"># Instructions for how to split chili in half</code>
        <code class="c"># Ladle into new container, add toppings</code>
        <code class="c"># Return two cups of chili in return</code>
        <code class="c"># ...</code>

<code class="k">class</code> <code class="nc">BaconCheeseburger</code><code class="calibre17">:</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">cost</code> <code class="calibre17">=</code> <code class="mi">11.95</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">name</code> <code class="calibre17">=</code> <code class="s">'Bacon Cheeseburger'</code>
        <code class="c"># This class handles a delicious Bacon Cheeseburger</code>
        <code class="c"># ...</code>

    <code class="c"># NOTE! no split_in_half method</code></pre>

<p class="author1">Now, the split method might look something like this:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">import</code> <code class="nn">math</code>
<code class="k">def</code> <code class="nf">split_dish</code><code class="calibre17">(</code><code class="n">dish</code><code class="calibre17">:</code> <code class="err">???</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="err">????</code><code class="calibre17">:</code>
    <code class="n">dishes</code> <code class="calibre17">=</code> <code class="n">dish</code><code class="calibre17">.</code><code class="n">split_in_half</code><code class="calibre17">()</code>
    <code class="k">assert</code> <code class="nb">len</code><code class="calibre17">(</code><code class="n">dishes</code><code class="calibre17">)</code> <code class="calibre17">==</code> <code class="mi">2</code>
    <code class="k">for</code> <code class="n">half_dish</code> <code class="calibre19">in</code> <code class="n">dishes</code><code class="calibre17">:</code>
        <code class="n">half_dish</code><code class="calibre17">.</code><code class="n">cost</code> <code class="calibre17">=</code> <code class="n">math</code><code class="calibre17">.</code><code class="n">ceil</code><code class="calibre17">(</code><code class="n">half_dish</code><code class="calibre17">.</code><code class="n">cost</code><code class="calibre17">)</code> <code class="calibre17">/</code> <code class="mi">2</code>
        <code class="n">half_dish</code><code class="calibre17">.</code><code class="n">name</code> <code class="calibre17">=</code> <code class="s">"½ "</code> <code class="calibre17">+</code> <code class="n">half_dish</code><code class="calibre17">.</code><code class="n">name</code>
    <code class="k">return</code> <code class="n">dishes</code></pre>

<p class="author1">What should the parameter <code class="calibre17">order</code> be typed as? Remember, a type is a set of behaviors, not necessarily a concrete Python type. I may not have a name for this set of behaviors, but I do want to make sure that I uphold them. In this example, the type must have these behaviors:</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">The type must have a function called <code class="calibre17">split_in_half</code>. This must return an iterable collection of two objects.</p>
</li>
<li class="calibre9">
<p class="author1">Each object returned from <code class="calibre17">split_in_half</code> must have an attribute called <code class="calibre17">cost</code>. This <code class="calibre17">cost</code> must be able to have the ceiling applied to it and to be integer-divided by two. This <code class="calibre17">cost</code> must be mutable.</p>
</li>
<li class="calibre9">
<p class="author1">Each object returned from <code class="calibre17">split_in_half</code> must have an attribute called <code class="calibre17">name</code>. This <code class="calibre17">name</code> must be allowed to set the text <code class="calibre17">"½ "</code> prefixed before it. This <code class="calibre17">name</code> must be mutable.</p>
</li>
</ul>

<p class="author1">A <code class="calibre17">Chili</code> or a <code class="calibre17">BLTSandwich</code> object will work just fine as a subtype, but <code class="calibre17">BaconCheeseburger</code> will not. <code class="calibre17">BaconCheeseburger</code> does not have the structure that the code is looking for. If you did try to pass in <code class="calibre17">BaconCheeseburger</code>, you’d get an <code class="calibre17">AttributeEr⁠ror</code> specifying that <code class="calibre17">BaconCheeseburger</code> has no method called <code class="calibre17">split_in_half()</code>. In other words, <code class="calibre17">BaconCheeseburger</code> does not match the structure of the expected type.<a data-type="indexterm" data-primary="subtyping" data-secondary="structural and nominal" id="idm45644736126568" class="calibre5"/><a data-type="indexterm" data-primary="structural subtyping" id="idm45644736125704" class="calibre5"/> In fact, this is where duck typing earns its other name: <em class="calibre6">structural subtyping</em>, or subtyping based on structure.</p>

<p class="author1">In contrast, most of the type hinting that you’ve been exploring throughout this part of the book is known as <em class="calibre6">nominal subtyping</em>. This means that types that have different names are separate from one another.<a data-type="indexterm" data-primary="nominal subtyping" id="idm45644736123848" class="calibre5"/> Do you see the problem? These two types of subtyping are opposed to each other. One is based on names of types and the other is based on structure. In order to catch errors during typechecking, you will need to come up with a named type:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">split_dish</code><code class="calibre17">(</code><code class="n">dish</code><code class="calibre17">:</code> <code class="err">???</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="err">???</code><code class="calibre17">:</code></pre>

<p class="author1">So, to ask again, what should the parameter be typed as? I’ve listed some options below.</p>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Protocols" class="preface">
<div class="preface" id="protocols">
<section data-type="sect1" data-pdf-bookmark="Tension Between Typing Systems" class="preface">
<div class="preface" id="idm45644736329608">
<section data-type="sect2" data-pdf-bookmark="Leave the Type Blank or Use Any" class="preface"><div class="preface" id="idm45644735976680">
<h2 class="calibre34" id="calibre_pb_2">Leave the Type Blank or Use Any</h2>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">split_dish</code><code class="calibre17">(</code><code class="n">dish</code><code class="calibre17">:</code> <code class="n">Any</code><code class="calibre17">)</code></pre>

<p class="author1">I cannot condone this, certainly not in a book all about robustness. This conveys no intent to future developers, and typecheckers will not detect common errors. Moving on.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Protocols" class="preface">
<div class="preface" id="protocols">
<section data-type="sect1" data-pdf-bookmark="Tension Between Typing Systems" class="preface">
<div class="preface" id="idm45644736329608">
<section data-type="sect2" data-pdf-bookmark="Use a Union" class="preface"><div class="preface" id="idm45644736105064">
<h2 class="calibre34" id="calibre_pb_3">Use a Union</h2>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">split_dish</code><code class="calibre17">(</code><code class="n">dish</code><code class="calibre17">:</code> <code class="n">Union</code><code class="calibre17">[</code><code class="n">BLTSandwich</code><code class="calibre17">,</code> <code class="n">Chili</code><code class="calibre17">])</code></pre>

<p class="author1">Ah, this is a bit better than leaving it blank.<a data-type="indexterm" data-primary="type systems" data-secondary="tension between runtime type system and  static type hints" data-tertiary="using Union type to solve" id="idm45644736113432" class="calibre5"/><a data-type="indexterm" data-primary="Union types" data-secondary="using to resolve runtime type system and static type hints" id="idm45644735955800" class="calibre5"/> An order can be either a <code class="calibre17">BLTSandwich</code> or <code class="calibre17">Chili</code>. And for this limited example, it does work. However, this should feel slightly off to you. I need to figure out how to reconcile structural subtyping and nominal subtyping, and all I’ve done is hardcode a few classes into the type signature.</p>

<p class="author1">What’s worse about this is that it’s fragile. Every time somebody needs to add a class that can be splittable, they have to remember to update this function. You can only hope that this function is somewhat near where classes are defined so that future maintainers might stumble upon it.</p>

<p class="author1">There’s another hidden danger here. What if this automated lunch maker is a library, meant to be used in automated kiosks by different vendors? Presumably, they would pull in this lunch-making library, make their own classes, and call <code class="calibre17">split_dish</code> on those classes. With the definition of <code class="calibre17">split_dish</code> in library code, there are very few reasonable ways that a consumer can get their code to typecheck.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Protocols" class="preface">
<div class="preface" id="protocols">
<section data-type="sect1" data-pdf-bookmark="Tension Between Typing Systems" class="preface">
<div class="preface" id="idm45644736329608">
<section data-type="sect2" data-pdf-bookmark="Use Inheritance" class="preface"><div class="preface" id="idm45644735951208">
<h2 class="calibre34" id="calibre_pb_4">Use Inheritance</h2>

<p class="author1">Some of you who are experienced in an object-oriented language such as C++ or Java may be yelling that an interface class is appropriate here.<a data-type="indexterm" data-primary="inheritance" data-secondary="using to resolve runtime type system and static type hints" id="idm45644735924808" class="calibre5"/><a data-type="indexterm" data-primary="type systems" data-secondary="tension between runtime type system and  static type hints" data-tertiary="using inheritance to solve" id="idm45644735923864" class="calibre5"/> It’d be simple to have both of these classes inherit from some base class that defined the methods you want.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">Splittable</code><code class="calibre17">:</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">cost</code><code class="calibre17">,</code> <code class="n">name</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">cost</code> <code class="calibre17">=</code> <code class="n">cost</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">name</code> <code class="calibre17">=</code> <code class="n">name</code>

    <code class="k">def</code> <code class="nf">split_in_half</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">tuple</code><code class="calibre17">[</code><code class="s">'Splittable'</code><code class="calibre17">,</code> <code class="s">'Splittable'</code><code class="calibre17">]:</code>
        <code class="k">raise</code> <code class="ne">NotImplementedError</code><code class="calibre17">(</code><code class="s">"Must implement split in half"</code><code class="calibre17">)</code>

<code class="k">class</code> <code class="nc">BLTSandwich</code><code class="calibre17">(</code><code class="n">Splittable</code><code class="calibre17">):</code>
    <code class="c"># ...</code>

<code class="k">class</code> <code class="nc">Chili</code><code class="calibre17">(</code><code class="n">Splittable</code><code class="calibre17">):</code>
    <code class="c"># ...</code></pre>

<p class="author1">This type hierarchy is modeled in <a data-type="xref" href="part0017_split_004.html#splittable_type_hierarchy" class="calibre5">Figure 13-1</a>.</p>

<figure class="calibre36"><div id="splittable_type_hierarchy" class="figure">
<img src="../images/00017.gif" alt="Type hierarchy for splittable" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 13-1. </span>Type hierarchy for splittable</h6>
</div></figure>

<p class="author1">And this does work:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">split_dish</code><code class="calibre17">(</code><code class="n">dish</code><code class="calibre17">:</code> <code class="n">Splittable</code><code class="calibre17">):</code></pre>

<p class="author1">In fact, you can even annotate the return type:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">split_dish</code><code class="calibre17">(</code><code class="n">dish</code><code class="calibre17">:</code> <code class="n">Splittable</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code>
    <code class="nb">tuple</code><code class="calibre17">[</code><code class="n">Splittable</code><code class="calibre17">,</code> <code class="n">Splittable</code><code class="calibre17">]:</code></pre>

<p class="author1">But what if there is a more complicated class hierarchy at play? What if your class hierarchy looks like <a data-type="xref" href="part0017_split_004.html#complicated_splittable" class="calibre5">Figure 13-2</a>?</p>

<figure class="calibre36"><div id="complicated_splittable" class="figure">
<img src="../images/00018.gif" alt="A more complicated type hierarchy" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 13-2. </span>A more complicated type hierarchy</h6>
</div></figure>

<p class="author1">Now, you have a tough decision in front of you. Where do you put the <code class="calibre17">Splittable</code> class in the type hierarchy? You can’t put it in the parent of the tree; not every dish should be splittable. You could make the <code class="calibre17">Splittable</code> class into a <code class="calibre17">SplittableLunch</code> class and jam it right between <code class="calibre17">Lunch</code> and whichever class that can be splittable, like in <a data-type="xref" href="part0017_split_004.html#more_complex_splittable" class="calibre5">Figure 13-3</a>.</p>

<figure class="calibre36"><div id="more_complex_splittable" class="figure">
<img src="../images/00019.gif" alt="ropy 1303" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 13-3. </span>A more complicated type hierarchy with <code class="calibre17">Splittable</code> injected in</h6>
</div></figure>

<p class="author1">This will fall apart as your codebase grows. For one, if you want to use <code class="calibre17">Splittable</code> anywhere else (say for dinner, or checks, or anything else), you’ll have to duplicate that code; nobody wants a billing system that inherits from <code class="calibre17">SplittableLunch</code>. Also, <code class="calibre17">Splittable</code> might not be the only parent class you want to introduce. You may have other attributes, such as being able to share an entree, having it available for curbside pickup, specifying that it allows substitutions, and so on. The number of classes you have to write explodes with each option you introduce.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Protocols" class="preface">
<div class="preface" id="protocols">
<section data-type="sect1" data-pdf-bookmark="Tension Between Typing Systems" class="preface">
<div class="preface" id="idm45644736329608">
<section data-type="sect2" data-pdf-bookmark="Use Mixins" class="preface"><div class="preface" id="idm45644735950584">
<h2 class="calibre34" id="calibre_pb_5">Use Mixins</h2>

<p class="author1">Now, some languages solve this<a data-type="indexterm" data-primary="mixins" data-secondary="using to resolve runtime type system and static type hints" id="idm45644735817160" class="calibre5"/><a data-type="indexterm" data-primary="type systems" data-secondary="tension between runtime type system and  static type hints" data-tertiary="using mixins to solve" id="idm45644735816216" class="calibre5"/> through the mixins, which I introduced in <a data-type="xref" href="part0015_split_000.html#api" class="calibre5">Chapter 11</a>. Mixins shift the burden to each class at the bottom of the class hierarchy without polluting any classes above. If I want my <code class="calibre17">BLTSandwich</code> to be <code class="calibre17">Shareable</code>, <code class="calibre17">PickUppable</code>, <code class="calibre17">Substitutable</code>, and <code class="calibre17">Splittable</code>, then I don’t have to modify anything else besides <code class="calibre17">BLTSandwich</code>.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">BLTSandwich</code><code class="calibre17">(</code><code class="n">Shareable</code><code class="calibre17">,</code>
                  <code class="n">PickUppable</code><code class="calibre17">,</code>
                  <code class="n">Substitutable</code><code class="calibre17">,</code>
                  <code class="n">Splittable</code><code class="calibre17">):</code>
    <code class="c"># ...</code></pre>

<p class="author1">Only the classes that need the functionality need to change. You reduce the need to coordinate across large codebases. Still, this is not perfect; users still need to add multiple inheritance to their classes to address this problem, and it would be great if you could minimize the changes needed to typecheck. It also introduces a physical dependency when you import the parent class, which may not be ideal.</p>

<p class="author1">In fact, none of the options above feels right. You’re changing existing classes just for the sake of typechecking, which feels very <em class="calibre6">unpythonic</em> to me. Many developers fell in love with Python because it doesn’t require such verbosity.<a data-type="indexterm" data-primary="type systems" data-secondary="tension between runtime type system and  static type hints" data-startref="ix_typsysten" id="idm45644735717736" class="calibre5"/>  Fortunately, there is a better solution in the form of <em class="calibre6">protocols</em>.</p>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Protocols" class="preface">
<div class="preface" id="protocols">
<section data-type="sect1" data-pdf-bookmark="Protocols" class="preface"><div class="preface" id="idm45644736328984">
<h1 class="calibre12" id="calibre_pb_6">Protocols</h1>

<p class="author1">Protocols provide a way of closing the gap between type hinting and the runtime type system.<a data-type="indexterm" data-primary="type systems" data-secondary="tension between runtime type system and  static type hints" data-tertiary="using protocols to solve" id="ix_typsystenprt" class="calibre5"/><a data-type="indexterm" data-primary="protocols" id="ix_prto" class="calibre5"/> They allow you to provide structural subtyping during typechecking. As a matter of fact, you probably are familiar with a protocol without even knowing it: the iterator protocol.<a data-type="indexterm" data-primary="iterator protocol" id="idm45644735711704" class="calibre5"/></p>

<p class="author1">The iterator protocol is a defined set of behaviors that objects may implement. If an object implements these behaviors, you can loop over the object. Consider:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">random</code> <code class="k">import</code> <code class="n">shuffle</code>
<code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">Iterator</code><code class="calibre17">,</code> <code class="n">MutableSequence</code>
<code class="k">class</code> <code class="nc">ShuffleIterator</code><code class="calibre17">:</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">sequence</code><code class="calibre17">:</code> <code class="n">MutableSequence</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">sequence</code> <code class="calibre17">=</code> <code class="nb">list</code><code class="calibre17">(</code><code class="n">sequence</code><code class="calibre17">)</code>
        <code class="n">shuffle</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">.</code><code class="n">sequence</code><code class="calibre17">)</code>

    <code class="k">def</code> <code class="calibre17">__iter__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">):</code>
        <code class="k">return</code> <code class="nb">self</code>

    <code class="k">def</code> <code class="nf">__next__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">):</code>
        <code class="k">if</code> <code class="calibre19">not</code> <code class="nb">self</code><code class="calibre17">.</code><code class="n">sequence</code><code class="calibre17">:</code>
            <code class="k">raise</code> <code class="ne">StopIteration</code>
        <code class="k">return</code> <code class="nb">self</code><code class="calibre17">.</code><code class="n">sequence</code><code class="calibre17">.</code><code class="n">pop</code><code class="calibre17">(</code><code class="mi">0</code><code class="calibre17">)</code>

<code class="n">my_list</code> <code class="calibre17">=</code> <code class="calibre17">[</code><code class="mi">1</code><code class="calibre17">,</code> <code class="mi">2</code><code class="calibre17">,</code> <code class="mi">3</code><code class="calibre17">,</code> <code class="mi">4</code><code class="calibre17">]</code>
<code class="n">iterator</code><code class="calibre17">:</code> <code class="n">Iterator</code> <code class="calibre17">=</code> <code class="n">ShuffleIterator</code><code class="calibre17">(</code><code class="n">my_list</code><code class="calibre17">)</code>

<code class="k">for</code> <code class="n">num</code> <code class="calibre19">in</code> <code class="n">iterator</code><code class="calibre17">:</code>
    <code class="k">print</code><code class="calibre17">(</code><code class="n">num</code><code class="calibre17">)</code></pre>

<p class="author1">Notice how I didn’t have to subclass <code class="calibre17">Iterator</code> in order for the typing to work. This is because the <code class="calibre17">ShuffleIterator</code> has the two methods needed for iterators to work: an <code class="calibre17">__iter__</code> method for looping over iterators, and a <code class="calibre17">__next__</code> method for getting the next item in the sequence.</p>

<p class="author1">This is exactly the sort of pattern I want to achieve with the <code class="calibre17">Splittable</code> examples. I want to be able to have typing work based on the structure of the code. To do this, you can define your own protocol.</p>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Protocols" class="preface">
<div class="preface" id="protocols">
<section data-type="sect1" data-pdf-bookmark="Protocols" class="preface">
<div class="preface" id="idm45644736328984">
<section data-type="sect2" data-pdf-bookmark="Defining a Protocol" class="preface"><div class="preface" id="idm45644735594600">
<h2 class="calibre34" id="calibre_pb_7">Defining a Protocol</h2>

<p class="author1">Defining a protocol is extremely simple.<a data-type="indexterm" data-primary="protocols" data-secondary="defining" id="ix_prtodef" class="calibre5"/> If you want something to be splittable, you define <code class="calibre17">Splittable</code> in terms of a protocol:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">Protocol</code>
<code class="k">class</code> <code class="nc">Splittable</code><code class="calibre17">(</code><code class="n">Protocol</code><code class="calibre17">):</code>
    <code class="n">cost</code><code class="calibre17">:</code> <code class="nb">int</code>
    <code class="n">name</code><code class="calibre17">:</code> <code class="nb">str</code>

    <code class="k">def</code> <code class="nf">split_in_half</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">tuple</code><code class="calibre17">[</code><code class="s">'Splittable'</code><code class="calibre17">,</code> <code class="s">'Splittable'</code><code class="calibre17">]:</code>
        <code class="sd">""" No implementation needed """</code>
        <code class="calibre17">...</code></pre>

<p class="author1">This looks pretty close to the example for subclassing earlier in this chapter, but you use it a tad differently.</p>

<p class="author1">To have the <code class="calibre17">BLTSandwich</code> be splittable, you don’t have to indicate anything different in the class. There is no subclassing needed:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">BLTSandwich</code><code class="calibre17">:</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">cost</code> <code class="calibre17">=</code> <code class="mi">6.95</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">name</code> <code class="calibre17">=</code> <code class="s">'BLT'</code>
        <code class="c"># This class handles a fully constructed BLT sandwich</code>
        <code class="c"># ...</code>

    <code class="k">def</code> <code class="nf">split_in_half</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="calibre17">(</code><code class="s">'BLTSandwich'</code><code class="calibre17">,</code> <code class="s">'BLTSandwich'</code><code class="calibre17">):</code>
        <code class="c"># Instructions for how to split a sandwich in half</code>
        <code class="c"># Cut along diagonal, wrap separately, etc.</code>
        <code class="c"># Return two sandwiches in return</code></pre>

<p class="author1">There is no explicit parent class for <code class="calibre17">BLTSandwich</code>. If you’d like to be explicit, you can still subclass from <code class="calibre17">Splittable</code>, but it’s not a requirement.</p>

<p class="author1">The <code class="calibre17">split_dish</code> function can now expect to use anything that supports the new <code class="calibre17">Splittable</code> protocol:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">split_dish</code><code class="calibre17">(</code><code class="n">order</code><code class="calibre17">:</code> <code class="n">Splittable</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">tuple</code><code class="calibre17">[</code><code class="n">Splittable</code><code class="calibre17">,</code> <code class="n">Splittable</code><code class="calibre17">]:</code></pre>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Protocols" class="preface">
<div class="preface" id="protocols">
<section data-type="sect1" data-pdf-bookmark="Protocols" class="preface">
<div class="preface" id="idm45644736328984">
<section data-type="sect2" data-pdf-bookmark="Defining a Protocol" class="preface">
<div class="preface" id="idm45644735594600">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_8">Discussion Topic</h1>
<p class="author1">Where can you use protocols in your codebase? Discuss areas where you use duck typing heavily or write generic code. Discuss how it would be easy to misuse these areas of code without using a protocol.</p>
</div>

<p class="author1">The typechecker will detect that a <code class="calibre17">BLTSandwich</code> is <code class="calibre17">Splittable</code> just by virtue of the fields and method it has defined. This simplifies class hierarchies immensely. You don’t need a complicated tree structure, even as you add more protocols. You can simply define a different protocol for each set of required behaviors, including <code class="calibre17">Shareable</code>, <code class="calibre17">Substitutable</code>, or <code class="calibre17">PickUppable</code>. Functions that depend on those behaviors can then rely on those protocols instead of any sort of base class. The original classes don’t need to change in any form, as long as they implement the needed functionality.<a data-type="indexterm" data-primary="type systems" data-secondary="tension between runtime type system and  static type hints" data-tertiary="using protocols to solve" data-startref="ix_typsystenprt" id="idm45644735434392" class="calibre5"/><a data-type="indexterm" data-primary="protocols" data-secondary="defining" data-startref="ix_prtodef" id="idm45644735433048" class="calibre5"/></p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre32"><div class="sidebar" id="idm45644735431832">
<h5 class="calibre33">Do Protocols Eliminate the Need for Inheritance?</h5>
<p class="author1">Once you get used to protocols, inheritance appears redundant.<a data-type="indexterm" data-primary="inheritance" data-secondary="deciding between protocols and" id="idm45644735423656" class="calibre5"/><a data-type="indexterm" data-primary="protocols" data-secondary="inheritance and" id="idm45644735422712" class="calibre5"/> While inheritance makes a lot of sense for nominal subtyping, it is too heavyweight for anything regarding structural subtyping. You are introducing linkages that don’t need to be there, increasing the maintenance cost of your system.</p>

<p class="author1">To decide whether to use a protocol or subclass, I want you to remember the lessons learned in <a data-type="xref" href="part0016_split_000.html#subtyping" class="calibre5">Chapter 12</a>. Anything subclassing another class or adhering to a protocol is a subtype. Therefore, it needs to uphold the contract of the parent type. If the contract just defines the structure of the type (such as being <code class="calibre17">Splittable</code>, which just needed certain attributes to be defined), use a protocol. However, if the parent type’s contract defines behaviors that need to be upheld, such as how to operate in certain conditions, use inheritance to better reflect the <em class="calibre6">is-a</em> relationship.<a data-type="indexterm" data-primary="protocols" data-startref="ix_prto" id="idm45644735418776" class="calibre5"/></p>
</div></aside>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Protocols" class="preface">
<div class="preface" id="protocols">
<section data-type="sect1" data-pdf-bookmark="Advanced Usage" class="preface"><div class="preface" id="idm45644735593976">
<h1 class="calibre12" id="calibre_pb_9">Advanced Usage</h1>

<p class="author1">I’ve covered the primary use case for protocols so far, but there’s a little more I’d like to show you.<a data-type="indexterm" data-primary="protocols" data-secondary="advanced usage" id="ix_prtoadv" class="calibre5"/> You won’t be reaching for these features as often, but they fill out a critical niche for protocols.</p>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Protocols" class="preface">
<div class="preface" id="protocols">
<section data-type="sect1" data-pdf-bookmark="Advanced Usage" class="preface">
<div class="preface" id="idm45644735593976">
<section data-type="sect2" data-pdf-bookmark="Composite Protocols" class="preface"><div class="preface" id="idm45644735414360">
<h2 class="calibre34" id="calibre_pb_10">Composite Protocols</h2>

<p class="author1">I talked in the last section about how a class might satisfy multiple protocols.<a data-type="indexterm" data-primary="composite protocols" id="idm45644735412600" class="calibre5"/><a data-type="indexterm" data-primary="protocols" data-secondary="advanced usage" data-tertiary="composite protocols" id="idm45644735411896" class="calibre5"/> For instance, a single lunch item may be <code class="calibre17">Splittable</code>, <code class="calibre17">Shareable</code>, <code class="calibre17">Substitutable</code>, and <code class="calibre17">PickUppable</code>.  While you can mix in these protocols quite easily, what if you found out that over half the lunch entries fall into this category? You could designate these lunch entries as a <code class="calibre17">StandardLunchEntry</code>, allowing you to refer to all four protocols as a single type.</p>

<p class="author1">Your first attempt might just be to write a type alias to cover your bases:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">StandardLunchEntry</code> <code class="calibre17">=</code> <code class="n">Union</code><code class="calibre17">[</code><code class="n">Splittable</code><code class="calibre17">,</code> <code class="n">Shareable</code><code class="calibre17">,</code>
                           <code class="n">Substitutable</code><code class="calibre17">,</code> <code class="n">PickUppable</code><code class="calibre17">]</code></pre>

<p class="author1">However, this will match anything that satisfies at least one protocol, not all four. To match all four protocols, you need to use a composite protocol:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">StandardLunchEntry</code><code class="calibre17">(</code><code class="n">Splittable</code><code class="calibre17">,</code> <code class="n">Shareable</code><code class="calibre17">,</code> <code class="n">Substitutable</code><code class="calibre17">,</code>
                         <code class="n">PickUppable</code><code class="calibre17">,</code> <code class="n">Protocol</code><code class="calibre17">):</code>
    <code class="k">pass</code>

<code class="c"># Remember, you don't need to explicitly subclass from the protocol</code>
<code class="c"># I do so here for clarity's sake</code>
<code class="k">class</code> <code class="nc">BLTSandwich</code><code class="calibre17">(</code><code class="n">StandardLunchEntry</code><code class="calibre17">):</code>
    <code class="c"># ... snip ...</code></pre>

<p class="author1">Then, you can use <code class="calibre17">StandardLunchEntry</code> anywhere an item should support all four protocols. This allows you to group protocols together, without having to duplicate the same combinations again and again throughout your codebase.</p>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1"><code class="calibre17">StandardLunchEntry</code> also subclasses from <code class="calibre17">Protocol</code>. <a data-type="indexterm" data-primary="subclassing" data-secondary="protocols and" id="idm45644735331576" class="calibre5"/>This is required; if it is left out, <code class="calibre17">StandardLunchEntry</code> would not be a protocol, even though it subclasses from other protocols. Put more generally: classes subclassed from a protocol do not automatically become a protocol.</p>
</div>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Protocols" class="preface">
<div class="preface" id="protocols">
<section data-type="sect1" data-pdf-bookmark="Advanced Usage" class="preface">
<div class="preface" id="idm45644735593976">
<section data-type="sect2" data-pdf-bookmark="Runtime Checkable Protocols" class="preface"><div class="preface" id="idm45644735299272">
<h2 class="calibre34" id="calibre_pb_11">Runtime Checkable Protocols</h2>

<p class="author1">Throughout all of this protocol discussion, I’ve stayed in the realm of static typechecking.<a data-type="indexterm" data-primary="runtime checkable protocols" id="idm45644735297560" class="calibre5"/><a data-type="indexterm" data-primary="protocols" data-secondary="advanced usage" data-tertiary="runtime checkable protocols" id="idm45644735296888" class="calibre5"/><a data-type="indexterm" data-primary="typechecking" data-secondary="runtime checkable protocols" id="idm45644735295704" class="calibre5"/> Sometimes, you just need to check a type at runtime, though. Unfortunately, protocols out of the box do not support any sort of <code class="calibre17">isinstance()</code> or <code class="calibre17">issubclass()</code> check.<a data-type="indexterm" data-primary="isinstance function" id="idm45644735293688" class="calibre5"/><a data-type="indexterm" data-primary="issubclass function" id="idm45644735292952" class="calibre5"/> It’s easy to add, though:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">runtime_checkable</code><code class="calibre17">,</code> <code class="n">Protocol</code>

<code class="nd">@runtime_checkable</code>
<code class="k">class</code> <code class="nc">Splittable</code><code class="calibre17">(</code><code class="n">Protocol</code><code class="calibre17">):</code>
    <code class="n">cost</code><code class="calibre17">:</code> <code class="nb">int</code>
    <code class="n">name</code><code class="calibre17">:</code> <code class="nb">str</code>

    <code class="k">def</code> <code class="nf">split_in_half</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">tuple</code><code class="calibre17">[</code><code class="s">'Splittable'</code><code class="calibre17">,</code> <code class="s">'Splittable'</code><code class="calibre17">]:</code>
        <code class="calibre17">...</code>

<code class="k">class</code> <code class="nc">BLTSandwich</code><code class="calibre17">():</code>
    <code class="c"># ... snip ..</code>

<code class="k">assert</code> <code class="nb">isinstance</code><code class="calibre17">(</code><code class="n">BLTSandwich</code><code class="calibre17">(),</code> <code class="n">Splittable</code><code class="calibre17">)</code></pre>

<p class="author1">As long as you throw the <code class="calibre17">runtime_checkable</code> decorator in there, you can do an <span class="calibre"><code class="calibre17">isinstance()</code></span> check to see if an object satisfies a protocol.  When you do, <span class="calibre"><code class="calibre17">isinstance()</code></span> is essentially calling a <code class="calibre17">__hasattr__</code> method on each of the expected variables and functions of the protocol.</p>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1"><code class="calibre17">issubclass()</code> will only work if your protocol is a nondata protocol, which is one that does not have any protocol variables. This has to deal with edge cases concerning setting variables in constructors.</p>
</div>

<p class="author1">You will typically mark protocols as <code class="calibre17">runtime_checkable</code> when you are using a <code class="calibre17">Union</code> of protocols. Functions may expect either one protocol or a different protocol, and those functions might need some way to differentiate the two inside the body of a function at runtime.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Protocols" class="preface">
<div class="preface" id="protocols">
<section data-type="sect1" data-pdf-bookmark="Advanced Usage" class="preface">
<div class="preface" id="idm45644735593976">
<section data-type="sect2" data-pdf-bookmark="Modules Satisfying Protocols" class="preface"><div class="preface" id="idm45644735215768">
<h2 class="calibre34" id="calibre_pb_12">Modules Satisfying Protocols</h2>

<p class="author1">While I’ve so far only talked about objects satisfying protocols, there’s a narrower use case that is worth mentioning.<a data-type="indexterm" data-primary="modules, using as protocols" id="idm45644735213928" class="calibre5"/><a data-type="indexterm" data-primary="protocols" data-secondary="advanced usage" data-tertiary="modules satisfying protocols" id="idm45644735213160" class="calibre5"/> It turns out that modules can satisfy protocols, too. After all, a module is still an object.</p>

<p class="author1">Suppose I want to define a protocol around a restaurant and each restaurant is defined in a separate file. Here’s one such file:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">name</code> <code class="calibre17">=</code> <code class="s">"Chameleon Café"</code>
<code class="n">address</code> <code class="calibre17">=</code> <code class="s">"123 Fake St."</code>

<code class="n">standard_lunch_entries</code> <code class="calibre17">=</code> <code class="calibre17">[</code><code class="n">BLTSandwich</code><code class="calibre17">,</code> <code class="n">TurkeyAvocadoWrap</code><code class="calibre17">,</code> <code class="n">Chili</code><code class="calibre17">]</code>
<code class="n">other_entries</code> <code class="calibre17">=</code> <code class="calibre17">[</code><code class="n">BaconCheeseburger</code><code class="calibre17">,</code> <code class="n">FrenchOnionSoup</code><code class="calibre17">]</code>

<code class="k">def</code> <code class="nf">render_menu</code><code class="calibre17">()</code> <code class="calibre17">-&gt;</code> <code class="n">Menu</code><code class="calibre17">:</code>
    <code class="c"># Code to render a menu</code></pre>

<p class="author1">Then, I need some code that will define the <code class="calibre17">Restaurant</code> protocol and be able to load a restaurant:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">Protocol</code>
<code class="k">from</code> <code class="nn">lunch</code> <code class="k">import</code> <code class="n">LunchEntry</code><code class="calibre17">,</code> <code class="n">Menu</code><code class="calibre17">,</code> <code class="n">StandardLunchEntry</code>

<code class="k">class</code> <code class="nc">Restaurant</code><code class="calibre17">(</code><code class="n">Protocol</code><code class="calibre17">):</code>
    <code class="n">name</code><code class="calibre17">:</code> <code class="nb">str</code>
    <code class="n">address</code><code class="calibre17">:</code> <code class="nb">str</code>
    <code class="n">standard_lunch_entries</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">StandardLunchEntry</code><code class="calibre17">]</code>
    <code class="n">other_entries</code><code class="calibre17">:</code> <code class="n">List</code><code class="calibre17">[</code><code class="n">LunchEntry</code><code class="calibre17">]</code>

    <code class="k">def</code> <code class="nf">render_menu</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="n">Menu</code><code class="calibre17">:</code>
        <code class="sd">""" No implementation needed """</code>
        <code class="calibre17">...</code>

<code class="k">def</code> <code class="nf">load_restaurant</code><code class="calibre17">(</code><code class="n">restaurant</code><code class="calibre17">:</code> <code class="n">Restaurant</code><code class="calibre17">):</code>
    <code class="c"># code to load restaurant</code>
    <code class="c"># ...</code></pre>

<p class="author1">Now, I can pass imported modules to my <code class="calibre17">load_restaurant</code> function:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">import</code> <code class="nn">restaurant</code>
<code class="k">from</code> <code class="nn">load_restaurant</code> <code class="k">import</code> <code class="n">load_restaurant</code>

<code class="c"># Loads our restaurant model</code>
<code class="n">load_restaurant</code><code class="calibre17">(</code><code class="n">restaurant</code><code class="calibre17">)</code></pre>

<p class="author1">In <code class="calibre17">main.py</code>, the call to <code class="calibre17">load_restaurant</code> will typecheck just fine. The restaurant module satisfies the <code class="calibre17">Restaurant</code> protocol I’ve defined. Protocols are even smart enough to ignore the <code class="calibre17">self</code> argument in <code class="calibre17">render_menu</code> when a module is passed in. Using a protocol to define a module isn’t an everyday Python sort of thing, but you’ll see it crop up if you have Python configuration files or plug-in architectures that need to enforce a contract.</p>
<div data-type="warning" epub:type="warning" class="calibre23"><h6 class="calibre24">Warning</h6>
<p class="author1">Not every typechecker may support using a module as a protocol just yet; double-check the bugs and documentation of your favorite typechecker for support.<a data-type="indexterm" data-primary="protocols" data-secondary="advanced usage" data-startref="ix_prtoadv" id="idm45644735055336" class="calibre5"/></p>
</div>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Protocols" class="preface">
<div class="preface" id="protocols">
<section data-type="sect1" data-pdf-bookmark="Closing Thoughts" class="preface"><div class="preface" id="idm45644735215144">
<h1 class="calibre12" id="calibre_pb_13">Closing Thoughts</h1>

<p class="author1">Protocols were just introduced in Python 3.8, so they are still relatively new. However, they patch a huge hole in what you can do with Python’s static typechecking. Remember, while the runtime is structurally subtyped, most of the static typechecking is nominally subtyped. Protocols fill that gap and let you do structural subtyping during typechecking. You’ll most commonly use them whenever you’re writing library code and want to provide a solid API that users can depend on, without relying on a specific type. Using protocols reduces physical dependencies of code, which helps with maintainability, but you still can catch errors early.</p>

<p class="author1">In the next chapter, you’ll learn about one more way to enhance your types: modeled types. Modeling a type allows you to create a rich set of constraints that are checked at typecheck and runtime, and can eliminate a whole class of errors without having to manually write validation for every field. Even better, by modeling your types, you provide built-in documentation for what is and what is not allowed in your codebase. Throughout the next chapter, you’ll see how to do all of this using the popular library pydantic.</p>
</div></section>







</div></section></body></html>