- en: 4\. Functions and Interfaces#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkPython/chap04.html](https://allendowney.github.io/ThinkPython/chap04.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This chapter introduces a module called `jupyturtle`, which allows you to create
    simple drawings by giving instructions to an imaginary turtle. We will use this
    module to write functions that draw squares, polygons, and circles – and to demonstrate
    **interface design**, which is a way of designing functions that work together.
  prefs: []
  type: TYPE_NORMAL
- en: '## 4.1\. The jupyturtle module[#](#the-jupyturtle-module "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: To use the `jupyturtle` module, we can import it like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use the functions defined in the module, like `make_turtle` and `forward`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`make_turtle` creates a **canvas**, which is a space on the screen where we
    can draw, and a turtle, which is represented by a circular shell and a triangular
    head. The circle shows the location of the turtle and the triangle indicates the
    direction it is facing.'
  prefs: []
  type: TYPE_NORMAL
- en: '`forward` moves the turtle a given distance in the direction it’s facing, drawing
    a line segment along the way. The distance is in arbitrary units – the actual
    size depends on your computer’s screen.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use functions defined in the `jupyturtle` module many times, so it would
    be nice if we did not have to write the name of the module every time. That’s
    possible if we import the module like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This version of the import statement imports `make_turtle` and `forward` from
    the `jupyturtle` module so we can call them like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`jupyturtle` provides two other functions we’ll use, called `left` and `right`.
    We’ll import them like this.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`left` causes the turtle to turn left. It takes one argument, which is the
    angle of the turn in degrees. For example, we can make a 90 degree left turn like
    this.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This program moves the turtle east and then north, leaving two line segments
    behind. Before you go on, see if you can modify the previous program to make a
    square.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2\. Making a square[#](#making-a-square "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s one way to make a square.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Because this program repeats the same pair of lines four times, we can do the
    same thing more concisely with a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '## 4.3\. Encapsulation and generalization[#](#encapsulation-and-generalization
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take the square-drawing code from the previous section and put it in a
    function called `square`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now we can call the function like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping a piece of code up in a function is called **encapsulation**. One of
    the benefits of encapsulation is that it attaches a name to the code, which serves
    as a kind of documentation. Another advantage is that if you re-use the code,
    it is more concise to call a function twice than to copy and paste the body!
  prefs: []
  type: TYPE_NORMAL
- en: In the current version, the size of the square is always `50`. If we want to
    draw squares with different sizes, we can take the length of the sides as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we can draw squares with different sizes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a parameter to a function is called **generalization** because it makes
    the function more general: with the previous version, the square is always the
    same size; with this version it can be any size.'
  prefs: []
  type: TYPE_NORMAL
- en: If we add another parameter, we can make it even more general. The following
    function draws regular polygons with a given number of sides.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In a regular polygon with `n` sides, the angle between adjacent sides is `360
    / n` degrees.
  prefs: []
  type: TYPE_NORMAL
- en: The following example draws a `7`-sided polygon with side length `30`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When a function has more than a few numeric arguments, it is easy to forget
    what they are, or what order they should be in. It can be a good idea to include
    the names of the parameters in the argument list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These are sometimes called “named arguments” because they include the parameter
    names. But in Python they are more often called **keyword arguments** (not to
    be confused with Python keywords like `for` and `def`).
  prefs: []
  type: TYPE_NORMAL
- en: This use of the assignment operator, `=`, is a reminder about how arguments
    and parameters work – when you call a function, the arguments are assigned to
    the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4\. Approximating a circle[#](#approximating-a-circle "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now suppose we want to draw a circle. We can do that, approximately, by drawing
    a polygon with a large number of sides, so each side is small enough that it’s
    hard to see. Here is a function that uses `polygon` to draw a `30`-sided polygon
    that approximates a circle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`circle` takes the radius of the the circle as a parameter. It computes `circumference`,
    which is the circumference of a circle with the given radius. `n` is the number
    of sides, so `circumference / n` is the length of each side.'
  prefs: []
  type: TYPE_NORMAL
- en: This function might take a long time to run. We can speed it up by calling `make_turtle`
    with a keyword argument called `delay` that sets the time, in seconds, the turtle
    waits after each step. The default value is `0.2` seconds – if we set it to `0.02`
    it runs about 10 times faster.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A limitation of this solution is that `n` is a constant, which means that for
    very big circles, the sides are too long, and for small circles, we waste time
    drawing very short sides. One option is to generalize the function by taking `n`
    as a parameter. But let’s keep it simple for now.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5\. Refactoring[#](#refactoring "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s write a more general version of `circle`, called `arc`, that takes
    a second parameter, `angle`, and draws an arc of a circle that spans the given
    angle. For example, if `angle` is `360` degrees, it draws a complete circle. If
    `angle` is `180` degrees, it draws a half circle.
  prefs: []
  type: TYPE_NORMAL
- en: To write `circle`, we were able to reuse `polygon`, because a many-sided polygon
    is a good approximation of a circle. But we can’t use `polygon` to write `arc`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we’ll create the more general version of `polygon`, called `polyline`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`polyline` takes as parameters the number of line segments to draw, `n`, the
    length of the segments, `length`, and the angle between them, `angle`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can rewrite `polygon` to use `polyline`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And we can use `polyline` to write `arc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`arc` is similar to `circle`, except that it computes `arc_length`, which is
    a fraction of the circumference of a circle.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can rewrite `circle` to use `arc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To check that these functions work as expected, we’ll use them to draw something
    like a snail. With `delay=0`, the turtle runs as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we started with working code and reorganized it with different
    functions. Changes like this, which improve the code without changing its behavior,
    are called **refactoring**.
  prefs: []
  type: TYPE_NORMAL
- en: If we had planned ahead, we might have written `polyline` first and avoided
    refactoring, but often you don’t know enough at the beginning of a project to
    design all the functions. Once you start coding, you understand the problem better.
    Sometimes refactoring is a sign that you have learned something.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6\. Stack diagram[#](#stack-diagram "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we call `circle`, it calls `arc`, which calls `polyline`. We can use a
    stack diagram to show this sequence of function calls and the parameters for each
    one.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/92e303702d06597847739633fef20d2b08ccd373273752d5cbf8c1c93eaeb26d.png](../Images/92d83d3a339d69adaf61582f205196f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the value of `angle` in `polyline` is different from the value of
    `angle` in `arc`. Parameters are local, which means you can use the same parameter
    name in different functions; it’s a different variable in each function, and it
    can refer to a different value.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7\. A development plan[#](#a-development-plan "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **development plan** is a process for writing programs. The process we used
    in this chapter is “encapsulation and generalization”. The steps of this process
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by writing a small program with no function definitions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you get the program working, identify a coherent piece of it, encapsulate
    the piece in a function and give it a name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generalize the function by adding appropriate parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat Steps 1 to 3 until you have a set of working functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for opportunities to improve the program by refactoring. For example, if
    you have similar code in several places, consider factoring it into an appropriately
    general function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process has some drawbacks – we will see alternatives later – but it can
    be useful if you don’t know ahead of time how to divide the program into functions.
    This approach lets you design as you go along.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design of a function has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The **interface** is how the function is used, including its name, the parameters
    it takes and what the function is supposed to do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **implementation** is how the function does what it’s supposed to do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, here’s the first version of `circle` we wrote, which uses `polygon`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: And here’s the refactored version that uses `arc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These two functions have the same interface – they take the same parameters
    and do the same thing – but they have different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '## 4.8\. Docstrings[#](#docstrings "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **docstring** is a string at the beginning of a function that explains the
    interface (“doc” is short for “documentation”). Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: By convention, docstrings are triple-quoted strings, also known as **multiline
    strings** because the triple quotes allow the string to span more than one line.
  prefs: []
  type: TYPE_NORMAL
- en: 'A docstring should:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain concisely what the function does, without getting into the details of
    how it works,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain what effect each parameter has on the behavior of the function, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indicate what type each parameter should be, if it is not obvious.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing this kind of documentation is an important part of interface design.
    A well-designed interface should be simple to explain; if you have a hard time
    explaining one of your functions, maybe the interface could be improved.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9\. Debugging[#](#debugging "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interface is like a contract between a function and a caller. The caller
    agrees to provide certain arguments and the function agrees to do certain work.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `polyline` requires three arguments: `n` has to be an integer;
    `length` should be a positive number; and `angle` has to be a number, which is
    understood to be in degrees.'
  prefs: []
  type: TYPE_NORMAL
- en: These requirements are called **preconditions** because they are supposed to
    be true before the function starts executing. Conversely, conditions at the end
    of the function are **postconditions**. Postconditions include the intended effect
    of the function (like drawing line segments) and any side effects (like moving
    the turtle or making other changes).
  prefs: []
  type: TYPE_NORMAL
- en: Preconditions are the responsibility of the caller. If the caller violates a
    precondition and the function doesn’t work correctly, the bug is in the caller,
    not the function.
  prefs: []
  type: TYPE_NORMAL
- en: If the preconditions are satisfied and the postconditions are not, the bug is
    in the function. If your pre- and postconditions are clear, they can help with
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 4.10\. Glossary[#](#glossary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**interface design:** A process for designing the interface of a function,
    which includes the parameters it should take.'
  prefs: []
  type: TYPE_NORMAL
- en: '**canvas:** A window used to display graphical elements including lines, circles,
    rectangles, and other shapes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**encapsulation:** The process of transforming a sequence of statements into
    a function definition.'
  prefs: []
  type: TYPE_NORMAL
- en: '**generalization:** The process of replacing something unnecessarily specific
    (like a number) with something appropriately general (like a variable or parameter).'
  prefs: []
  type: TYPE_NORMAL
- en: '**keyword argument:** An argument that includes the name of the parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**refactoring:** The process of modifying a working program to improve function
    interfaces and other qualities of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**development plan:** A process for writing programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**docstring:** A string that appears at the top of a function definition to
    document the function’s interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '**multiline string:** A string enclosed in triple quotes that can span more
    than one line of a program.'
  prefs: []
  type: TYPE_NORMAL
- en: '**precondition:** A requirement that should be satisfied by the caller before
    a function starts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**postcondition:** A requirement that should be satisfied by the function before
    it ends.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.11\. Exercises[#](#exercises "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For the exercises below, there are a few more turtle functions you might want
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: '`penup` lifts the turtle’s imaginary pen so it doesn’t leave a trail when it
    moves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pendown` puts the pen back down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following function uses `penup` and `pendown` to move the turtle without
    leaving a trail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 4.11.1\. Exercise[#](#exercise "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a function called `rectangle` that draws a rectangle with given side lengths.
    For example, here’s a rectangle that’s `80` units wide and `40` units tall.
  prefs: []
  type: TYPE_NORMAL
- en: 4.11.2\. Exercise[#](#id1 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a function called `rhombus` that draws a rhombus with a given side length
    and a given interior angle. For example, here’s a rhombus with side length `50`
    and an interior angle of `60` degrees.
  prefs: []
  type: TYPE_NORMAL
- en: 4.11.3\. Exercise[#](#id2 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now write a more general function called `parallelogram` that draws a quadrilateral
    with parallel sides. Then rewrite `rectangle` and `rhombus` to use `parallelogram`.
  prefs: []
  type: TYPE_NORMAL
- en: 4.11.4\. Exercise[#](#id3 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write an appropriately general set of functions that can draw shapes like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/73a457cfb8b88465b8d35a8d99cfe5fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hint: Write a function called `triangle` that draws one triangular segment,
    and then a function called `draw_pie` that uses `triangle`.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.11.5\. Exercise[#](#id4 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write an appropriately general set of functions that can draw flowers like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/04840afbf96285b3c181f739f961b9d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hint: Use `arc` to write a function called `petal` that draws one flower petal.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.11.6\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several modules like `jupyturtle` in Python, and the one we used
    in this chapter has been customized for this book. So if you ask a virtual assistant
    for help, it won’t know which module to use. But if you give it a few examples
    to work with, it can probably figure it out. For example, try this prompt and
    see if it can write a function that draws a spiral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the result might use features we have not seen yet, and it
    might have errors. Copy the code from the VA and see if you can get it working.
    If you didn’t get what you wanted, try modifying the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
