- en: Chapter 12\. Subtyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of [Part II](part0011.html#part_2) has focused on creating your own types
    and defining interfaces. These types do not exist in isolation; types are often
    related to one another. So far, you’ve seen *composition*, where types use other
    types as members. In this chapter, you’ll learn about *subtyping*, or creating
    types based on other types.
  prefs: []
  type: TYPE_NORMAL
- en: When applied correctly, subtyping makes it incredibly easy to extend your codebase.
    You can introduce new behaviors without ever worrying about breaking the rest
    of your codebase. However, you must be dilligent when creating a subtyping relationship;
    if you do it poorly, you can decrease the robustness of your codebase in unexpected
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start with one of the most common subtype relationships: inheritance.
    Inheritance is seen as a traditional pillar of object-oriented programming (OOP).^([1](part0016_split_007.html#idm45644737734424))
    Inheritance can be tricky if not applied correctly. I’ll then move on to other
    forms of subtyping present in the Python programming language. You’ll also learn
    about one of the more fundamental SOLID design principles, the Liskov Substitution
    Principle. This chapter will help you make sense of when and where subtyping is
    appropriate and where it is not.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most developers immediately think of inheritance when they talk about subtyping.
    *Inheritance* is a way of creating a new type from another type, copying all the
    behaviors into the new type. This new type is known as a *child class*, *derived
    class*, or *subclass*. In contrast, the type being inherited from is known as
    a *parent class*, *base class*, or *superclass*. When talking about types in this
    way, we say that the relationship is an *is-a* relationship. Any object of a derived
    class is also an instance of a base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, you are going to design an app that helps owners of restaurants
    organize operations (tracking finances, customizing menus, etc.). For this scenario,
    a restaurant has the following behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A restaurant has the following attributes: a name, a location, a list of employees
    and their schedules, inventory, a menu, and current finances. All of these attributes
    are mutable; even a restaurant can be renamed or change locations. When a restaurant
    changes locations, its location attribute reflects its final destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An owner can own multiple restaurants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employees can be moved from one restaurant to another, but they cannot work
    at two restaurants at the same time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a dish is ordered, the ingredients used are removed from the inventory.
    When a specific item is depleted in the inventory, any dish requiring the ingredient
    is no longer available through the menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever a menu item is sold, the restaurant’s funds increase. Whenever new
    inventory is purchased, the restaurant’s funds decrease. For every hour that an
    employee works at that restaurant, the restaurant’s funds decrease according to
    the employee’s salary and/or wage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restaurant owners will use this app to view all their restaurants, manage their
    inventory, and track profits in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there are specific invariants about the restaurant, I’ll use a class
    to represent a restaurant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to a “standard” restaurant, as described above, there are a few
    “specialized” restaurants: a food truck and a pop-up stall.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Food trucks are mobile: they drive around to different spots and change their
    menu based on the occasion. Pop-up stalls are transient; they appear for a limited
    time with a limited menu (typically for some sort of event like a festival or
    fair). While slightly different in how they operate, both a food truck and pop-up
    stall are still restaurants. This is what I mean when I say an *is-a* relationship—a
    food truck *is a* restaurant and a pop-up stall *is a* restaurant. Because this
    is an *is-a* relationship, inheritance is an appropriate construct to use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You denote inheritance by specifying the base class when you define your derived
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 12-1](part0016_split_001.html#inheritance_uml) shows how this relationship
    is typically drawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inheritance tree of restaurants](../images/00016.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. Inheritance tree of restaurants
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By defining inheritance in this fashion, you ensure that the derived classes
    will inherit all the methods and attributes from the base class, without needing
    to redefine them.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if you were to instantiate one of the derived classes, such
    as `FoodTruck`, you would be able to use all the same methods as if you were interacting
    with a `Restaurant`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s really nice about this is that a derived class can be passed to a function
    expecting a base class and the typechecker will not complain one bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By default, the derived class operates exactly like the base class. If you’d
    like the derived class to do something different, you can override methods or
    redefine the methods in the derived class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose I want my food truck to automatically drive to the next location when
    the location changes. For this use case, however, when asking for restaurant data,
    I only want the final location, not the location while the food truck is en route.
    Developers can call a separate method to show the current location (for use in
    a separate food truck–only map). I’ll set up a GPS locator in the `FoodTruck`’s
    constructor, and override `move_location` to start the automatic driving:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I am using a special function, `super()`, to access the base class. When I call
    `super().__init__()`, I am actually calling `Restaurant`’s constructor. When I
    call `super().move_location`, I am calling `Restaurant`’s `move_location`, not
    `FoodTruck`’s `move_location`. This way, the code can behave exactly like the
    base class.
  prefs: []
  type: TYPE_NORMAL
- en: Take a moment and reflect on the implications of extending code through subclassing.
    You can insert new behaviors into existing code without ever modifying that existing
    code. If you avoid modifying existing code, you drastically reduce the chance
    of introducing new bugs; you won’t inadvertently break consumers’ assumptions
    if you aren’t changing the code they depend on. A well-designed inheritance structure
    can greatly improve maintainability. Unfortunately, the inverse is true as well;
    design your inheritance poorly, and maintainability suffers. When working with
    inheritance, you always need to be thinking about how easy it is to substitute
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Substitutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described earlier, inheritance is all about modeling an *is-a* relationship.
    Describing something with an *is-a* relationship may sound simple, but you’d be
    surprised just how wrong things can go. To model *is-a* relationships properly,
    you need to understand substitutability.
  prefs: []
  type: TYPE_NORMAL
- en: '*Substitutability* states that when you derive from a base class, you should
    be able to use that derived class in every instance that you use a base class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If I were to create a function that could display relevant restaurant data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I should be able to pass a `Restaurant`, a `FoodTruck`, or a `PopUpStall`, and
    this function should be none the wiser. Again, this sounds simple; what’s the
    catch?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is indeed a catch. To show you, I’d like to step away from the food concept
    for a second, and go back to a fundamental question that any first grader should
    be able to answer: is a square a rectangle?'
  prefs: []
  type: TYPE_NORMAL
- en: From your early days of school, you probably know the answer as “yes, a square
    is a rectangle.” A rectangle is a polygon that has four sides, and each intersection
    of two sides is a 90-degree angle. A square is the same, with the extra requirement
    that each side must be the exact same length.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I were to model this with inheritance, I might do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So yes, from a geometry perspective a square is indeed a rectangle. But this
    assumption when mapped to *is-a* relationships is flawed. Take a few moments and
    see if you can catch where my assumptions break down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still don’t see it? Here’s a hint: what if I asked you if a `Square` is *substitutable*
    for a `Rectangle` for every use case? Can you construct a use case for a rectangle
    that a square would not be substitutable for?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the user of the app selects squares and rectangles on a map of restaurants
    to gauge market size. A user can draw a shape on the map, and then expand it as
    needed. One of the functions to handle this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this code, what would happen if I were to pass a `Square` as the argument?
    All of a sudden, a previously passing assertion would start to fail, since the
    height of a square changes when the length changes. This is catastrophic; the
    whole intention of inheritance is to extend functionality without breaking existing
    code. In this case, by passing in a `Square` (since it’s also a `Rectangle`, the
    type checker won’t complain), I have introduced a bug just waiting to happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sort of mistake impacts the derived class as well. The error above stems
    from overriding `set_width` in `Square` so that the height is changed as well.
    What if `set_width` were not overridden and the `Rectangle`’s `set_width function`
    were invoked? Well, if this were the case, and you passed a `Square` into the
    function, the assertion would not fail. Instead, something far less obvious but
    much more detrimental happens: the function succeeds. No longer do you receive
    an `AssertionError` with a stack trace that leads you to the bug. Now, you create
    a square that is no longer a square; the width is changed, but the height has
    not. You have committed a cardinal sin and have broken the invariants of that
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: What makes this so sinister is that the goal of inheritance is to decouple,
    or remove dependencies from, existing code and new code. Implementers and consumers
    of the base class have no view into different derived classes at runtime. It might
    be that the derived class definitions live in a completely different codebase,
    owned by a different organization. With this error case, you make it so that every
    time a derived class changes, you need to look at every invocation and use of
    the base class and assess whether or not your changes will break code.
  prefs: []
  type: TYPE_NORMAL
- en: In order to solve this, you have a few options available to you. First, you
    can not inherit `Square` from `Rectangle` in the first place and avoid the whole
    problem. Second, you can restrict the methods of `Rectangle` so that the `Square`
    does not contradict it (such as making the fields immutable). Last, you can abolish
    the class hierarchy altogether and provide an `is_square` method in the `Rectangle`.
  prefs: []
  type: TYPE_NORMAL
- en: These sorts of errors can break your codebase in subtle ways. Consider the use
    case where I want to franchise my restaurants; franchisees are allowed to create
    their own menu, but must always have a common set of dishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a potential implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the function returns early if any of the restricted items aren’t
    in the new menu. What seems sensible in isolation completely falls apart when
    put in an inheritance hierarchy. Put yourself in another developer’s shoes, one
    who wants to implement the UI for changing menus in the app. They see a `Restaurant`
    class, and code against that interface. When a `RestrictedMenuRestaurant` inevitably
    gets used in place of a `Restaurant`, the UI will try to change a menu and have
    no indication that the update didn’t actually occur. The only way this bug could
    have been caught earlier would be for a developer to trawl through the codebase
    looking for derived classes that broke invariants. And if there’s any theme to
    this book, it’s that any time a developer has to go searching through a codebase
    to understand one piece of code, it’s a sure sign of fragility.
  prefs: []
  type: TYPE_NORMAL
- en: What if I wrote the code to throw an exception instead of just returning? Unfortunately,
    this doesn’t solve any problems either. Now, when users change the menu of a `Restaurant`,
    they are liable to receive an exception. If they look at the `Restaurant` class’s
    code, there is no indication that they would ever need to think about an exception.
    Nor should they be paranoid and wrap every call in a `try...except` block, worried
    that a derived class somewhere might throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both of these cases, subtle errors are introduced when a class inherits
    from a base class but does not behave exactly as that base class does. These errors
    require a specific combination of conditions to occur: code must execute methods
    on the base class, it must depend on specific behavior of that base class, and
    a derived class breaking that behavior has to be substituted as a base class.
    The tricky thing is that any of these conditions can be introduced long after
    the original code was written. This is why substitutability is so important. As
    a matter of fact, the importance of substitutability is embodied in a very important
    principle: the Liskov Substitution Principle.'
  prefs: []
  type: TYPE_NORMAL
- en: The Liskov Substitution Principle (LSP), named after Barbara Liskov, states
    the following:^([2](part0016_split_007.html#idm45644736586104))
  prefs: []
  type: TYPE_NORMAL
- en: '*Subtype Requirement*: Let `Φ(X)` be a property provable about objects `X`
    of type `T`. Then `Φ(Y)` should be true for objects `Y` of type `S` where `S`
    is a subtype of `T`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Don’t let the formal notation scare you. The LSP is quite simple: in order
    for a subtype to exist, it must adhere to all the same properties (behaviors)
    as the supertype. It all comes back to substitutability. You should keep the LSP
    in mind whenever you think about properties of supertypes and what they mean for
    subtypes. When designing with inheritance, think through the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Invariants
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](part0014_split_000.html#classes) focused mostly on invariants
    (truths about your types that must not be violated). When you’re subtyping from
    other types, the subtypes *must* preserve all invariants. When I subtyped `Square`
    from `Rectangle`, I disregarded the invariant that heights and widths can be set
    independent of one another.'
  prefs: []
  type: TYPE_NORMAL
- en: Preconditions
  prefs: []
  type: TYPE_NORMAL
- en: A precondition is anything that must be true before interacting with a type’s
    property (such as calling a function). If the supertype defines preconditions
    that happen, the subtype *must not* be more restrictive. This is what happened
    when I subtyped `RestrictedMenuRestaurant` from `Restaurant`. I added an extra
    precondition that certain ingredients were mandatory when changing the menu. By
    throwing an exception, I’ve made it so that previously good data would now fail.
  prefs: []
  type: TYPE_NORMAL
- en: Postcondition
  prefs: []
  type: TYPE_NORMAL
- en: A postcondition is anything that must be true after interacting with a type’s
    property. If a supertype defines postconditions, the subtype must not *weaken*
    those postconditions. A postcondition is weakened if any of its guarantees are
    not met. When I subtyped `RestrictedMenuRestaurant` from `Restaurant` and returned
    early instead of changing the menu, I violated a postcondition. The base class
    guaranteed a postcondition that the menu would be updated, regardless of the menu
    contents. When subtyped like I did, I could no longer guarantee that postcondition.
  prefs: []
  type: TYPE_NORMAL
- en: 'If at any time you break an invariant, precondition, or postcondition in an
    overridden function, you are begging for an error to show up. Here are some red
    flags that I look for in the derived class’s overridden functions when evaluating
    inheritance relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally checking arguments
  prefs: []
  type: TYPE_NORMAL
- en: A good way to know if a precondition is more restrictive is to see if there
    are any `if` statements at the beginning of the function checking the arguments
    being passed in. If there are, there’s a good chance they are different from the
    base class’s checks, typically meaning that the derived class is restricting the
    arguments further.
  prefs: []
  type: TYPE_NORMAL
- en: Early return statements
  prefs: []
  type: TYPE_NORMAL
- en: If a subtype’s function returns early (in the middle of the function block),
    this indicates that the latter part of the function is not going to execute. Check
    that latter part for any postcondition guarantees; you don’t want to omit those
    by returning early.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing an exception
  prefs: []
  type: TYPE_NORMAL
- en: Subtypes should only throw exceptions that match what the supertype throws (either
    exactly or a derived exception type). If any exceptions are different, callers
    are not going to expect them, let alone write code to catch them. It’s even worse
    if you throw an exception when the base class doesn’t indicate any possibility
    of an exception at all. The most flagrant violation of this that I’ve seen is
    throwing `NotImplementedError` exceptions (or similar).
  prefs: []
  type: TYPE_NORMAL
- en: Not calling `super()`
  prefs: []
  type: TYPE_NORMAL
- en: By definition of substitutability, the subtype must offer the same behavior
    as the supertype. If you aren’t calling `super()` as part of your subtype’s overridden
    functions, your subtype has no defined relationship to that behavior in code.
    Even if you were to copy-paste the supertype’s code into your subtype, there’s
    no guarantee that these will stay synchronized; a developer could make an innocuous
    change to the supertype’s function and not even realize that there is a subtype
    that needs to change as well.
  prefs: []
  type: TYPE_NORMAL
- en: You need to be extra careful when modeling types with inheritance. Any mistake
    can introduce subtle bugs that could have catastrophic effects. When designing
    with inheritance, tread with utmost caution.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you encountered any of the red flags in your codebase? Has it led to surprising
    behavior when inheriting from other classes? Discuss why these break assumptions
    and what errors can happen in those cases.
  prefs: []
  type: TYPE_NORMAL
- en: Design Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take precautions whenever you are writing classes intended to be derived from.
    Your goal is to make it as easy as possible for other developers to write derived
    classes. Here are a few guidelines for writing base classes (I’ll cover guidelines
    for derived classes afterward):'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t change invariants
  prefs: []
  type: TYPE_NORMAL
- en: Normally, changing invariants is a bad idea in the first place. Countless pieces
    of code can depend on your types, and changing an invariant will break assumptions
    made on your code. Unfortunately, derived classes can break if a base class changes
    invariants as well. If you have to change your base class, try to only add new
    functionality, not modify existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Be cautious tying invariants to protected fields
  prefs: []
  type: TYPE_NORMAL
- en: Protected fields are inherently meant to be interacted with by derived classes.
    If you tie invariants to these fields, you are fundamentally restricting what
    operations should be invoked. This creates a tension that other developers may
    not be aware of. It’s better to keep invariants to private data and force derived
    classes to interact with public or protected methods in order to interact with
    that private data.
  prefs: []
  type: TYPE_NORMAL
- en: Document your invariants
  prefs: []
  type: TYPE_NORMAL
- en: This is the number one most important thing you can do to help your other developers.
    While some invariants are representable in code (as you saw in [Chapter 10](part0014_split_000.html#classes)),
    there are simply some invariants that cannot be mathematically proven by a computer,
    such as guarantees around exceptions being thrown or not. You must document these
    invariants when you design your base class, and make it easy for derived classes
    to discover them, such as in a docstring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, it is the derived class’s responsibility to adhere to the base
    class’s invariants. If you are writing a derived class, heed the following guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Know the base class invariants
  prefs: []
  type: TYPE_NORMAL
- en: You can’t write a derived class properly without knowing the invariants. It
    is your job to understand all the base class’s invariants in order to preserve
    them. Look through code, documentation, and anything else related to the class
    to understand what you should and should not be doing.
  prefs: []
  type: TYPE_NORMAL
- en: Extend functionality in the base class
  prefs: []
  type: TYPE_NORMAL
- en: If you need to write code that doesn’t jive with your current invariants, you
    may want to put that functionality in the base class instead. Take the example
    of not supporting an overridable method. Rather than throw a `NotImplementedError`,
    you could create a Boolean flag indicating functionality support in the base class
    instead. If you do this, take note of all the guidelines earlier in this chapter
    for modifying the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Every overridden method should contain `super()`
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t call `super()` in an overridden method, you have no guarantee that
    your subclass is behaving exactly like the base class, especially if the base
    class changes at all in the future. If you are going to override a method, make
    sure you call `super()`. The only time you can get away with this is when the
    base method is empty (such as an abstract base class) and you are sure it will
    remain empty for the remainder of the codebase’s life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s also important to know when not to use inheritance. One of the biggest
    mistakes I’ve seen is using inheritance solely for the purpose of code reuse.
    Don’t get me wrong, inheritance is a great way to reuse code, but the primary
    reason for inheritance is modeling a relationship where subtypes are used in place
    of the supertype. If you never interact with the subtype in the code that assumes
    the supertype, you aren’t modeling an *is-a* relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'In such cases, you want to use composition, also known as a *has-a* relationship.
    *Composition* is when you put member variables inside a type. I have primarily
    used composition to group types together. For instance, the restaurant from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where in your codebase have you overused inheritance? Are you using it anywhere
    as a conduit for reuse only? Discuss how to transform this to use composition
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the member fields set in the constructor is an example of composition.
    It doesn’t make sense for a `Restaurant` to be substitutable for a `Menu` (*is-a*
    relationship), but it does make sense for a restaurant to be composed of a menu
    (*has-a* relationship), among other things. You should prefer composition to inheritance
    anytime you need to reuse code but aren’t going to substitute types for one another.
  prefs: []
  type: TYPE_NORMAL
- en: Composition is preferable to inheritance as a reuse mechanism because it is
    a weaker form of *coupling*, which is another term for dependencies between entities.
    All other things being equal, you want weaker forms of coupling, as it makes it
    easier to reorganize classes and refactor functionality. If classes have high
    coupling between them, changes in one more directly affect the behavior of the
    other.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Mixins are the exception to preferring composition over inheritance, as they
    are classes explicitly meant to be inherited to provide additions to a type’s
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'With inheritance, a derived class is beholden to the base class’s changes.
    A developer must be cognizant of not only the public interface changing, but also
    changes to invariants and protected members. By contrast, when another class has
    an instance of your class, that class is only affected by a subset of changes:
    those impacting the public methods and invariants it depends on. By limiting the
    impact of changes, you lessen the chance of broken assumptions, decreasing fragility.
    To write robust code, use inheritance judiciously.'
  prefs: []
  type: TYPE_NORMAL
- en: Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subtyped relationships are a very powerful concept in programming. You can use
    them to extend existing functionality without modifying it. However, inheritance
    is often overused, or used improperly. Subtypes should only be used if they are
    directly substitutable for their supertype. If this isn’t the case, reach for
    composition instead.
  prefs: []
  type: TYPE_NORMAL
- en: Special care should be taken when introducing supertypes or subtypes. It may
    not be easy for developers to know of all the subtypes associated with a single
    supertype; some subtypes may even live in other codebases. Supertypes and subtypes
    are very closely coupled, so be cautious whenever you make changes. With the proper
    diligence, you can reap all the benefits of subtyping without introducing a slew
    of headaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, I’m going to focus on a specific application of subtyping
    known as protocols. These are the missing link between the typechecker and duck
    typing. Protocols bridge the gap in an important way: they help your typechecker
    catch some of the errors introduced in a supertype/subtype relationship. Any time
    you catch more errors, especially through a typechecker, you are contributing
    to the robustness of your codebase.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](part0016_split_000.html#idm45644737734424-marker)) Object-oriented programming
    is a programming paradigm where you organize your code around encapsulated data
    and their behaviors. If you’d like an introduction to OOP, I suggest [*Head First
    Object-Oriented Analysis and Design*](https://oreil.ly/6djy9) by Brett McLaughlin,
    Gary Pollice, and Dave West (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](part0016_split_002.html#idm45644736586104-marker)) Barbara H. Liskov and
    Jeannette M. Wing. “A Behavioral Notion of Subtyping.” *ACM Trans. Program. Lang.
    Syst.* 16, 6 (Nov. 1994), 1811–41\. [*https://doi.org/10.1145/197320.197383*](https://doi.org/10.1145/197320.197383).
  prefs: []
  type: TYPE_NORMAL
