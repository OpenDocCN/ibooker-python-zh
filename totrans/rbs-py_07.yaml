- en: Chapter 6\. Customizing Your Typechecker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章\. 自定义您的类型检查器
- en: 'Typecheckers are one of your best resources for building robust codebases.
    Jukka Lehtosalo, the lead developer of mypy, offers a beautifully concise definition
    of typecheckers: “In essence, [a typechecker] provides verified documentation.”^([1](part0009_split_008.html#idm45644746850088))
    Type annotations provide documentation about your codebase, allowing other developers
    the ability to reason about your intentions. Typecheckers use those annotations
    to verify that the documentation matches the behavior.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器是构建健壮代码库的最佳资源之一。Jukka Lehtosalo，mypy 的主要开发者，对类型检查器给出了一个精炼的定义：“本质上，[类型检查器]
    提供了验证过的文档。”^([1](part0009_split_008.html#idm45644746850088)) 类型注解提供了关于代码库的文档，允许其他开发者理解您的意图。类型检查器使用这些注解来验证文档是否与实际行为一致。
- en: As such, a typechecker is invaluable. Confucius once said, “The mechanic, who
    wishes to do his work well, must first sharpen his tools.”^([2](part0009_split_008.html#idm45644746847016))
    This chapter is all about sharpening your typechecker. Great coding techniques
    can get you far, but it’s your surrounding tooling that takes you to the next
    level. Don’t stop with just learning your editor, compiler, or operating system.
    Learn your typechecker too. I will show you some of the more useful options to
    get the most out of your tools.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，类型检查器是无价的。孔子曾说过：“工欲善其事，必先利其器。”^([2](part0009_split_008.html#idm45644746847016))
    本章旨在帮助您磨练您的类型检查器。优秀的编码技术可以带您走得更远，但是您周围的工具才能将您带入下一个水平。不要止步于学习您的编辑器、编译器或操作系统，也要学会您的类型检查器。我将向您展示一些更有用的选项，以充分发挥您的工具的潜力。
- en: Configuring Your Typechecker
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置您的类型检查器
- en: 'I will focus on one of the most popular typecheckers out there: mypy. When
    you run a typechecker in an IDE (such as PyCharm), it typically runs mypy underneath
    the hood (although many IDEs will allow you to change the default typechecker).
    Anytime you configure mypy (or whatever your default typechecker is), your IDE
    will use that configuration as well.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我将专注于目前最受欢迎的类型检查器之一：mypy。当您在 IDE 中运行类型检查器（如 PyCharm）时，通常在幕后运行 mypy（尽管许多 IDE
    允许您更改默认的类型检查器）。每当配置 mypy（或您的默认类型检查器）时，您的 IDE 也会使用该配置。
- en: Mypy offers quite a few configuration options to control the typechecker’s *strictness*,
    or the amount of errors reported. The stricter you make your typechecker, the
    more type annotations you need to write, which provides better documentation and
    creates fewer bugs. However, make the typechecker too strict, and you will find
    the minimum bar for developing code too high, incurring high costs to make changes.
    Mypy configuration options control these strictness levels. I’ll go through the
    different options available to you, and you can decide where that bar lies for
    you and your codebase.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: mypy 提供了许多配置选项来控制类型检查器的*严格性*或报告的错误数量。您使类型检查器越严格，就需要编写更多类型注解，这提供了更好的文档，并减少了错误。但是，如果类型检查器过于严格，您将发现开发代码的最低要求过高，导致进行更改的成本很高。mypy
    配置选项控制这些严格性水平。我将介绍一些可供您选择的不同选项，您可以决定您和您的代码库所在的最低要求。
- en: 'First, you need to install mypy (if you haven’t already). The easiest way is
    through `pip` on the command line:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果您尚未安装 mypy，则需要安装它。最简单的方法是通过命令行上的 `pip`：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you have mypy installed, you you can control configuration in one of three
    ways:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 mypy 后，您可以以三种方式之一控制配置：
- en: Command line
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行
- en: When instantiating mypy from a terminal, you can pass various options to configure
    behavior. This is great for exploring new checks in your codebase.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当从终端实例化 mypy 时，您可以传递各种选项来配置行为。这对于在代码库中探索新的检查非常有用。
- en: Inline configuration
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 内联配置
- en: 'You can specify configuration values at the top of a file to indicate any options
    you may want to set. For example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文件顶部指定配置值，以指示您可能想设置的任何选项。例如：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Putting this line at the top of your file will tell mypy to explicitly fail
    if it finds any generic type annotated with `Any`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将此行放在文件顶部将告诉 mypy 明确地失败，如果它发现带有 `Any` 泛型类型注释。
- en: Configuration file
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件
- en: You can set up a configuration file to use the same options every time mypy
    runs. This is extremely useful when needing to share the same options across a
    team. This file is typically stored in version control alongside the code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以设置一个配置文件，以便每次运行 mypy 时都使用相同的选项。在团队需要共享相同选项时，这非常有用。该文件通常与代码一起存储在版本控制中。
- en: Configuring mypy
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 mypy
- en: 'When running mypy, it looks in your current directory for a configuration file
    named *mypy.ini*. This file will define which options you have set up for the
    project. Some options will be global, applied to every file, and other options
    will be per-module. A sample *mypy.ini* file might look as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 运行mypy时，它会在当前目录中查找名为*mypy.ini*的配置文件。此文件将定义您为项目设置的选项。一些选项是全局的，适用于每个文件，而其他选项是每个模块的。一个示例的*mypy.ini*文件可能如下所示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can use the `--config-file` command-line option to specify config files
    in different places. Also, mypy will look for configuration files in specific
    home directories if it can’t find a local config file, in case you want the same
    settings across multiple projects. For more information, check out the [mypy documentation](https://oreil.ly/U1JO9).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`--config-file`命令行选项来指定不同位置的配置文件。此外，如果找不到本地配置文件，mypy将在特定的主目录中查找配置文件，以便在多个项目中使用相同的设置。要获取更多信息，请查看[mypy文档](https://oreil.ly/U1JO9)。
- en: As a note, I won’t cover too much more about the configuration file. Most options
    that I’ll talk about work in both a configuration file and on the command line,
    and for the sake of simplicity, I’ll show you how to run the commands on mypy
    invocations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，我不会详细讨论配置文件。我将讨论的大多数选项都可以在配置文件和命令行中使用，为了简单起见，我将向您展示如何在mypy调用中运行命令。
- en: In the following pages, I will cover a multitude of typechcecker configurations;
    you do not need to apply every single one of them to see value in a typechecker.
    Most typecheckers provide immense value right out of the box. However, feel free
    to consider the following options to improve a typechecker’s likelihood of finding
    errors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的页面中，我将涵盖多种类型检查器配置；您不需要应用每一个配置项，即可看到类型检查器的价值。大多数类型检查器在开箱即用时提供了巨大的价值。不过，随时考虑以下选项以提高类型检查器发现错误的可能性。
- en: Catching dynamic behavior
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕捉动态行为
- en: 'As mentioned before, Python’s dynamically typed nature will make maintenance
    hard on codebases that last a long time. Variables are free to be rebound to values
    with different types at any time. When this happens, the variable is essentially
    an `Any` type. `Any` types indicate that you should make no assumptions about
    what type that variable is. This makes it tricky to reason about: your typechecker
    won’t be of much use in preventing errors and you aren’t communicating anything
    special to future developers.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python的动态类型特性将使得长期维护的代码库变得困难。变量可以随时重新绑定到具有不同类型的值。当发生这种情况时，变量本质上是`Any`类型。`Any`类型表明您不应做任何关于变量类型的假设。这使得推理变得棘手：您的类型检查器在防止错误方面没有太多用处，也无法向未来的开发人员传达任何特殊信息。
- en: Mypy comes with a set of flags that you can turn on to flag instances of the
    `Any` type.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy带有一组标志，您可以打开它们来标记`Any`类型的实例。
- en: 'For instance, you can turn on the `--disallow-any-expr` option to flag any
    expression that has an `Any` type. The following code will fail with that option
    turned on:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以打开`--disallow-any-expr`选项来标记具有`Any`类型的任何表达式。在打开此选项时，以下代码将无法通过类型检查：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Another option I like for disallowing `Any` in type declarations (such as in
    collections) is `--disallow-any-generics`. This catches the use of `Any` for anything
    using a generic (such as collection types). The following code fails to typecheck
    with this option turned on:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我喜欢的选项是在类型声明中禁用`Any`（例如在集合中）是`--disallow-any-generics`。这可以捕捉到使用泛型（例如集合类型）的`Any`的使用。在打开此选项时，以下代码将无法通过类型检查：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You would need to use `list[int]` explicitly to get this code to work.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要明确使用`list[int]`以使此代码正常工作。
- en: You can check out all the ways to disable the use of `Any` in the [mypy dynamic
    typing documentation](https://oreil.ly/Fmspo).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看所有禁用`Any`的方法在[mypy动态类型文档](https://oreil.ly/Fmspo)中。
- en: Be careful with disabling `Any` too broadly, though. There is a valid use case
    of `Any` that you don’t want to flag erroneously. `Any` should be reserved for
    when you absolutely don’t care what type something is and that it is up to the
    caller to verify the type. A prime example is a heterogeneous key-value store
    (perhaps a general-purpose cache).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但是要小心过于广泛地禁用`Any`。`Any`的一个有效用例是，您不希望错误地标记类型。`Any`应保留给绝对不关心某个变量类型并且由调用者验证类型的情况。一个主要的例子是异构键值存储（也许是通用缓存）。
- en: Requiring types
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需要类型
- en: An expression is *untyped* if there is no type annotation. In these cases, mypy
    treats the result of that expression as an `Any` type if it can’t otherwise infer
    the type. However, the previous checks for disallowing `Any` will not catch where
    a function is left untyped. There is a separate set of flags for checking for
    untyped functions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有类型注释，表达式就是*未类型化*的。在这些情况下，如果`mypy`无法推断类型，它将把该表达式的结果视为`Any`类型。然而，用于禁止`Any`的先前检查不会捕捉到函数未带类型注释的情况。有一组独立的标志用于检查未带类型注释的函数。
- en: 'This code will not error out in a typechecker unless the `--disallow-untyped-defs`
    option is set:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将不会在类型检查器中报错，除非设置了`--disallow-untyped-defs`选项：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With that option set, you receive the following error:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了该选项，你将收到以下错误：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If this is too severe for you, you might want to check out `--disallow-incomplete-defs`,
    which only flags functions if they only have some variables/return values annotated
    (but not all), or `--disallow-untyped-calls`, which only flags calls from annotated
    functions to unannotated functions. You’ll find all the different options concerning
    untyped functions in the [mypy documentation](https://oreil.ly/pOvWs).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你来说太严格了，你可以考虑查看`--disallow-incomplete-defs`，它只会标记函数，如果它们只有部分变量/返回值被注释（但不是全部），或者`--disallow-untyped-calls`，它只会标记从带注释函数到未带注释函数的调用。你可以在[mypy文档](https://oreil.ly/pOvWs)中找到关于未类型化函数的所有不同选项。
- en: Handling None/Optional
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理`None`/`Optional`
- en: In [Chapter 4](part0007_split_000.html#constraints), you learned how easy it
    was to make the “billion-dollar mistake” when using `None` values. If you turn
    on no other options, make sure that you have `--strict-optional` turned on in
    your typechecker to catch these costly errors. You absolutely want to be checking
    that your use of `None` is not hiding any latent bugs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](part0007_split_000.html#constraints)中，你学会了在使用`None`值时如何轻松犯下“十亿美元的错误”。如果你没有打开其他选项，请确保你的类型检查器已经打开了`--strict-optional`以捕捉这些代价高昂的错误。你绝对希望检查你对`None`的使用是否隐藏了潜在的错误。
- en: When using `--strict-optional`, you must explicitly perform `is None` checks;
    otherwise, your code will fail typechecking.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--strict-optional`时，你必须显式执行`is None`检查；否则，你的代码将在类型检查时失败。
- en: 'If `--strict-optional` is set (the default is different depending on the mypy
    version, so be sure to double-check), this code should fail:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`--strict-optional`（默认值因`mypy`版本而异，请务必仔细检查），此代码应该失败：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It’s worth noting that mypy also treats `None` values as `Optional`s implicitly.
    I recommend turning this off, so that you are being more explicit in your code.
    For example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`mypy`也将`None`值隐式地视为`Optional`。我建议关闭这个选项，这样在你的代码中就更明确。例如：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The parameter `x` is implicitly converted to an `Optional[int]`, since `None`
    is a valid value for it. If you were to do any integer operations on `x`, the
    typechecker would flag it. However, it’s better to be more explicit and express
    that a value can be `None` (to disambiguate for future readers).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`x`会被隐式转换为`Optional[int]`，因为`None`是其有效值。如果你对`x`执行任何整数操作，类型检查器会标记它。然而，最好更明确地表达一个值可以是`None`（以便未来的读者消除歧义）。
- en: 'You can set `--no-implicit-optional` in order to get an error, forcing you
    to specify `Optional`. If you were to typecheck the above code with this option
    set, you would see:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以设置`--no-implicit-optional`以获取错误，强制你指定`Optional`。如果你使用此选项来对上述代码进行类型检查，你将看到：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Mypy Reporting
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`mypy`报告'
- en: If a typechecker fails in the forest and nobody is around to see it, does it
    print an error message? How do you know that mypy is actually checking your files,
    and that it will actually catch errors? Use mypy’s built-in reporting techniques
    to better visualize results.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型检查失败而且周围没有人看到，它会打印错误消息吗？你如何知道`mypy`确实在检查你的文件，并且它确实会捕捉到错误？使用`mypy`的内置报告技术来更好地可视化结果。
- en: First, you can get an HTML report about how many lines of code mypy was able
    to check by passing in `--html-report` to mypy. This produces a HTML file that
    will provide a table similar to the one pictured in [Figure 6-1](part0009_split_003.html#mypy_report).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以通过将`--html-report`传递给`mypy`来获取一个关于`mypy`能够检查多少行代码的HTML报告。这将生成一个HTML文件，其中提供了类似于[图6-1](part0009_split_003.html#mypy_report)中所示的表格。
- en: '![HTML report from running mypy on the mypy source code](../images/00009.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![运行`mypy`对`mypy`源代码进行的HTML报告](../images/00009.jpeg)'
- en: Figure 6-1\. HTML report from running mypy on the mypy source code
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1\. 运行`mypy`对`mypy`源代码进行的HTML报告
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you want a plain-text file, you can use `--linecount-report` instead.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个纯文本文件，你可以使用`--linecount-report`替代。
- en: 'Mypy also allows you to track explicit `Any` expressions to understand how
    you are doing on a line-by-line basis. When using the `--any-exprs-report` command-line
    option, mypy will create a text file enumerating per-module statistics for how
    many times you use `Any`. This is very useful for seeing how explicit your type
    annotations are across a codebase. Here are the first few lines from running the
    `--any-exprs-report` option on the mypy codebase itself:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy 还允许您跟踪显式的 `Any` 表达式，以便逐行了解您的进展情况。当使用 `--any-exprs-report` 命令行选项时，mypy 将创建一个文本文件，列出每个模块中使用
    `Any` 的统计信息。这对于查看代码库中类型注解的显式程度非常有用。这里是在 mypy 代码库本身上运行 `--any-exprs-report` 选项时的前几行内容：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you’d like more machine-readable formats, you can use the `--junit-xml` option
    to create an XML file in the JUnit format. Most continuous integration systems
    can parse this format, making it ideal for automated report generation as part
    of your build system. To learn about all the different reporting options, check
    out the mypy [report-generation documentation](https://oreil.ly/vVRsm).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多的机器可读格式，可以使用 `--junit-xml` 选项创建一个符合 JUnit 格式的 XML 文件。大多数持续集成系统可以解析这种格式，使其成为构建系统自动报告生成的理想选择。要了解所有不同的报告选项，请查阅
    mypy 的[报告生成文档](https://oreil.ly/vVRsm)。
- en: Speeding Up mypy
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加速 mypy
- en: One of the common complaints about mypy is the time it takes to typecheck large
    codebases. By default, mypy *incrementally* checks files. That is, it uses a cache
    (typically a *.mypy_cache* folder, but the location is also configurable) to check
    only what has changed since last typecheck. This does speed up typechecking, but
    as your codebase gets larger, your typechecker will take longer to run, no matter
    what. This is detrimental for fast feedback during development cycles. The longer
    a tool takes to provide useful feedback to developers, the less often developers
    will run the tool, thus defeating the purpose. It is in everyone’s interest for
    typecheckers to run as fast as possible, so that developers are getting type errors
    at near real time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: mypy 的一个常见抱怨是其对大型代码库进行类型检查所花费的时间。默认情况下，mypy *增量地*检查文件。也就是说，它使用一个缓存（通常是一个 *.mypy_cache*
    文件夹，但位置也是可配置的）来仅检查自上次类型检查以来发生了什么变化。这确实加快了类型检查的速度，但随着代码库的扩大，无论如何，您的类型检查器都会花费更长的时间运行。这对于开发周期中快速反馈是有害的。工具提供有用反馈给开发者所需时间越长，开发者运行工具的频率就会越低，从而达不到目的。尽可能快地运行类型检查器符合每个人的利益，这样开发者可以接近实时地获取类型错误信息。
- en: In order to speed up mypy even more, you may want to consider a *remote cache*.
    A remote cache provides a way of caching your mypy typechecks somewhere accessible
    to your entire team. This way, you can cache results based on specific commit
    IDs in your version control and share typechecker information. Building this system
    is outside the scope of this book, but the [remote cache documentation](https://oreil.ly/5gO9N)
    in mypy will provide a solid start.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步加快 mypy 的速度，您可能需要考虑使用*远程缓存*。远程缓存提供了一种将您的 mypy 类型检查缓存到整个团队都能访问的地方的方式。这样，您可以基于特定的提交
    ID 缓存版本控制中的结果，并共享类型检查器信息。建立这个系统超出了本书的范围，但是在 mypy 的[远程缓存文档](https://oreil.ly/5gO9N)中会提供一个坚实的起点。
- en: You also should consider mypy in daemon mode. Daemon mode is when mypy runs
    as a standalone process, and keeps the previous mypy state in memory rather than
    on a file system (or across a network link). You can start a mypy daemon by running
    `dmypy run -- mypy-flags <mypy-files>`. Once the daemon is running, you can run
    the exact same command to check the files again.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该考虑将 mypy 设置为守护进程模式。守护进程模式是指 mypy 作为一个独立的进程运行，并将先前的 mypy 状态保留在内存中，而不是文件系统（或网络链接）上。您可以通过运行
    `dmypy run -- mypy-flags <mypy-files>` 来启动 mypy 守护进程。一旦守护进程运行起来，您可以再次运行完全相同的命令来检查文件。
- en: For instance, I ran mypy on the mypy source code itself. My initial run took
    23 seconds. Subsequent typechecks on my system took between 16 and 18 seconds.
    This is *technically* faster, but I would not consider it fast. When I use the
    mypy daemon, though, my subsequent runs ended up being under half a second. With
    times like that, I can run my typechecker much more often to get feedback faster.
    Check out more about dmypy in the [mypy daemon mode documentation](https://oreil.ly/6Coxe).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我在 mypy 源代码上运行了 mypy。我的初始运行花费了 23 秒。系统上的后续类型检查花费了 16 到 18 秒之间。这在*技术上*更快，但我不认为它很快。然而，当我使用
    mypy 守护进程时，我的后续运行时间缩短到不到半秒。有了这样的速度，我可以更频繁地运行我的类型检查器以获得更快的反馈。了解更多有关 dmypy 的信息，请查阅[mypy
    守护进程模式文档](https://oreil.ly/6Coxe)。
- en: Alternative Typecheckers
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代型检查工具
- en: 'Mypy is highly configurable, and its wealth of options will let you decide
    on the exact behavior you are looking for, but it won’t meet all of your needs
    all of the time. It isn’t the only typechecker out there. I’d like to introduce
    two other typecheckers: Pyre (written by Facebook) and Pyright (written by Microsoft).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy是高度可配置的，它丰富的选项将让您决定您寻找的精确行为，但它不会始终满足您的所有需求。它并非唯一的类型检查器。我想介绍另外两个类型检查器：Pyre（由Facebook编写）和Pyright（由Microsoft编写）。
- en: Pyre
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pyre
- en: 'You can install Pyre with `pip`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`pip`安装Pyre：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Pyre](https://pyre-check.org) runs very similarly to mypy’s daemon mode. A
    separate process will run, from which you can ask for typechecking results. To
    typecheck your code, you need to set up Pyre (by running `pyre init`) in your
    project directory, and then run `pyre` to start the daemon. From here, the information
    you receive is pretty similar to mypy. However, there are two features that set
    Pyre apart from other typecheckers: codebase querying and the Python Static Analyzer
    (Pysa) framework.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[Pyre](https://pyre-check.org)运行方式与mypy的守护程序模式非常相似。一个独立的进程将运行，您可以向其请求类型检查结果。要对您的代码进行类型检查，您需要在项目目录中设置Pyre（通过运行`pyre
    init`），然后运行`pyre`来启动守护程序。从这里，您收到的信息与mypy非常相似。然而，有两个功能使Pyre与其他类型检查器不同：代码库查询和Python静态分析器（Pysa）框架。'
- en: Codebase querying
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码库查询
- en: Once the `pyre` daemon is running, there are a lot of cool queries you can make
    to inspect your codebase. I’ll use the mypy codebase as an example codebase for
    all of the following queries.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`pyre`守护程序运行起来，你可以进行许多很酷的查询来检查你的代码库。我将使用mypy代码库作为以下所有查询的示例代码库。
- en: 'For instance, I can learn about the attributes of any class in my codebase:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我可以了解代码库中任何类的属性：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](../images/00002.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-1)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](../images/00002.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-1)'
- en: Pyre query for attributes
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Pyre查询属性
- en: '[![2](../images/00005.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-2)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](../images/00005.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-2)'
- en: A description of the constructor
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的描述
- en: '[![3](../images/00006.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-3)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](../images/00006.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-3)'
- en: A list of strings for messages
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一组消息的字符串列表
- en: '[![4](../images/00007.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-4)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](../images/00007.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-4)'
- en: An `Optional` string describing a module with blocker
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个描述具有阻塞器的模块的可选字符串
- en: '[![5](../images/00008.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-5)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](../images/00008.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO1-5)'
- en: A flag indicating printing to a screen
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 指示将打印到屏幕的标志
- en: Look at all this information I can find out about the attributes in a class!
    I can see their type annotations to understand how the tool sees these attributes.
    This is incredibly handy in exploring classes as well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我可以找出关于类属性的所有这些信息！我可以看到它们的类型注释，以了解工具如何看待这些属性。这在探索类时非常方便。
- en: 'Another cool query is the `callees` of any function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很酷的查询是任何函数的`callees`：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](../images/00002.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO2-1)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](../images/00002.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO2-1)'
- en: Calls the length function
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 调用长度函数
- en: '[![2](../images/00005.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO2-2)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](../images/00005.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO2-2)'
- en: Calls the string.*getitem* function (such as `str[0]`)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串上调用string.*getitem*函数（例如`str[0]`）
- en: '[![3](../images/00006.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO2-3)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](../images/00006.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO2-3)'
- en: Calls the `startswith` function on a string
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串上调用`startswith`函数
- en: '[![4](../images/00007.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO2-4)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](../images/00007.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO2-4)'
- en: Initializes a list slice (such as `str[3:8]`)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化列表切片（例如`str[3:8]`）
- en: The typechecker needs to store all this information to do its job. It’s a huge
    bonus that you can query the information as well. I could write a whole extra
    book on what you can do with this information, but for now, check out the [Pyre
    query documentation](https://oreil.ly/X4h0h). You will learn about different queries
    you can execute, such as observing class hierarchies, call graphs, and more. These
    queries allow you to learn more about your codebase or to build new tools to better
    understand your codebase (and catch other types of errors that a typechecker can’t,
    such as temporal dependencies, which I’ll cover in [Part III](part0019.html#part_3)).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器需要存储所有这些信息以完成其工作。能够查询这些信息是一个巨大的优势。我可以写一整本关于你可以如何利用这些信息的书，但现在，先查看[Pyre查询文档](https://oreil.ly/X4h0h)。你将了解到可以执行的不同查询，比如观察类层次结构、调用图等。这些查询可以帮助你更多地了解你的代码库，或者构建新工具以更好地理解你的代码库（并捕获类型检查器无法捕获的其他类型错误，比如时间依赖性，我将在[第三部分](part0019.html#part_3)中讨论）。
- en: Python Static Analyzer (Pysa)
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python静态分析器（Pysa）
- en: '*Pysa* (pronounced like the Leaning Tower of Pisa) is a static code analyzer
    built into Pyre. Pysa specializes in a type of security static analysis known
    as *taint analysis*. Taint analysis is the tracking of potentially tainted data,
    such as user-supplied input. The tainted data is tracked for the entire life cycle
    of the data; Pyre makes sure that any tainted data cannot propagate to a system
    in an insecure fashion.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pysa*（发音类似比萨斜塔）是内置在Pyre中的静态代码分析器。Pysa专注于一种称为*taint analysis*的安全静态分析类型。污点分析是追踪潜在污染数据（如用户提供的输入）的过程。这些污点数据在整个数据生命周期中被追踪；Pyre确保任何污点数据都不能以不安全的方式传播到系统中。'
- en: 'Let me walk you through the process to catch a simple security flaw (modified
    from the [Pyre documentation](https://oreil.ly/l8gK8)). Consider the case where
    a user creates a new recipe in a filesystem:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我带你走过捕获简单安全缺陷的过程（修改自[Pyre文档](https://oreil.ly/l8gK8)）。考虑一个用户在文件系统中创建新食谱的情况：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This looks pretty innocuous. A user can enter in `carrots` to create the file
    *~/food_data/carrots.json*. But what if a user enters in `carrots; ls ~;`? If
    this were entered, it would print out the entire home directory (the command becomes
    `touch ~/food_data/carrots; ls ~;.json`). Based on input, a malicious user could
    enter in arbitrary commands on your server (this is known as remote code execution
    [RCE]), which is a huge security risk.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常无害。用户可以输入`carrots`以创建文件*~/food_data/carrots.json*。但是如果用户输入`carrots; ls
    ~;`呢？如果输入这个命令，它会打印出整个家目录（命令变为`touch ~/food_data/carrots; ls ~;.json`）。根据输入，恶意用户可以在您的服务器上输入任意命令（这称为远程代码执行[RCE]），这是一个巨大的安全风险。
- en: 'Pysa provides tools to check this. I can specify that anything coming from
    `input()` is potentially tainted data (known as a *taint source*), and anything
    passed to `os.system` should not be tainted (known as a *taint sink*). With this
    information, I need to build a *taint model*, which is a set of rules for detecting
    potential security holes. First, I must specify a *taint.config* file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Pysa提供工具来检查这一点。我可以指定从`input()`输入的任何内容都是潜在的污点数据（称为*污点源*），并且传递给`os.system`的任何内容都不应该是污点数据（称为*污点汇*）。有了这些信息，我需要构建一个*污点模型*，即一组用于检测潜在安全漏洞的规则。首先，我必须指定一个*taint.config*文件：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](../images/00002.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO3-1)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](../images/00002.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO3-1)'
- en: Specify an annotation for user-controlled input.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 指定用户控制输入的注释。
- en: '[![2](../images/00005.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO3-2)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](../images/00005.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO3-2)'
- en: Specify an annotation for RCE flaws.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为RCE缺陷指定注释。
- en: '[![3](../images/00006.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO3-3)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](../images/00006.gif)](part0009_split_006.html#co_customizing_your_typechecker_CO3-3)'
- en: Specify a rule that makes any tainted data from `UserControlled` sources an
    error if it ends up in a `RemoteCodeExecution` sink.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 指定一个规则，如果来自`UserControlled`来源的任何污点数据最终进入`RemoteCodeExecution`汇，就会产生错误。
- en: 'From there, I must specify a taint model to annotate these sources as tainted:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我必须指定一个污点模型以注释这些来源为污点：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These stubs tell Pysa through type annotations about where your taint sources
    and sinks are in your system.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些存根通过类型注解告诉Pysa您系统中的污点来源和污点汇。
- en: 'Finally, you need to tell Pyre to detect tainted information by modifying the
    `.pyre_configuration` to add in your directory:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要修改`.pyre_configuration`以告知Pyre检测污点信息的位置。
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, when I run `pyre analyze` on that code, Pysa flags an error.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我运行 `pyre analyze` 时，Pysa 发现了一个错误。
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In order to fix this, I either need to make this data flow impossible or run
    tainted data through a *sanitizer* function. Sanitizer functions take untrusted
    data and inspect/modify it so that it can be trusted. Pysa allows you decorate
    functions with `@sanitize` to specify your sanitizers.^([3](part0009_split_008.html#idm45644746190568))
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我要么需要使这些数据流变得不可能，要么通过 *sanitizer* 函数运行受污染的数据。Sanitizer 函数接收不受信任的数据并检查/修改它，使其可以信任。Pysa
    允许你使用 `@sanitize` 装饰函数以指定你的净化器。^([3](part0009_split_008.html#idm45644746190568))
- en: This was admittedly a simple example, but Pysa allows you to annotate your codebase
    to catch more complicated problems (such as SQL injection and cookie mismanagement).
    To learn everything that Pysa can do (including built-in common security flaw
    checking), check out the [complete documentation](https://oreil.ly/lw7BP).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个简单的例子，但 Pysa 允许你对代码库进行注释，以捕获更复杂的问题（例如 SQL 注入和 cookie 管理不当）。要了解 Pysa 能做什么（包括内置的常见安全漏洞检查），请查阅
    [完整文档](https://oreil.ly/lw7BP)。
- en: Pyright
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pyright
- en: '[Pyright](https://oreil.ly/VhZBj) is a typechecker designed by Microsoft. I
    have found it to be the most configurable of the typecheckers I’ve come across.
    If you would like more control than your current typechecker, explore the [Pyright
    configuration documentation](https://oreil.ly/nwkne) for all that you can do.
    However, Pyright has an additional awesome feature: VS Code integration.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[Pyright](https://oreil.ly/VhZBj) 是由 Microsoft 设计的一种类型检查器。我发现它是我遇到的类型检查器中最可配置的。如果你想比当前的类型检查器有更多的控制权，探索
    [Pyright 配置文档](https://oreil.ly/nwkne)。然而，Pyright 还有一个额外的很棒的特性：VS Code 集成。'
- en: 'VS Code (also built by Microsoft) is an immensely popular code editor for developers.
    Microsoft leveraged the ownership of both tools to create a VS Code extension
    called [Pylance](https://oreil.ly/Y6WAC). You can install Pylance from your VS
    Code extensions browser. Pylance is built upon Pyright and uses type annotations
    to provide a better code-editing experience. Before, I mentioned that autocomplete
    was a benefit of type annotations in IDEs, but Pylance takes it to the next level.
    Pylance offers the following features:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code（也由 Microsoft 构建）是开发者中极其流行的代码编辑器。Microsoft 充分利用了这两个工具的所有权，创建了一个名为 [Pylance](https://oreil.ly/Y6WAC)
    的 VS Code 扩展。你可以从你的 VS Code 扩展浏览器安装 Pylance。Pylance 是建立在 Pyright 之上的，使用类型注解提供更好的代码编辑体验。之前我提到过自动补全是
    IDE 中类型注解的一个好处，但 Pylance 将其提升到了一个新水平。Pylance 提供以下功能：
- en: Automatic insertion of imports based on your types
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于你的类型自动插入导入语句
- en: Tooltips with full type annotations based on signatures
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于签名的完整类型注释的工具提示
- en: Codebase browsing such as finding references or browsing a call graph
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码库浏览，例如找到引用或浏览调用图
- en: Real-time diagnostic checking
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时诊断检查
- en: It’s this last feature that sells Pylance/Pyright for me. Pylance has a setting
    that allows you to constantly run diagnostics in your whole workspace. This means
    that every time you edit a file, `pyright` will run across your entire workspace
    (and it runs fast, too) to look for additional areas that you broke. You don’t
    need to manually run any commands; it happens automatically. As someone who likes
    to refactor often, I find this tool invaluable for finding breakages early. Remember,
    you want to find your errors in as close to real time as possible.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这一特性让我选择了 Pylance/Pyright。Pylance 有一个设置，允许你在整个工作区中持续运行诊断。这意味着每次你编辑文件时，`pyright`
    将会在整个工作区（而且运行速度很快）查找你可能破坏的其他区域。你无需手动运行任何命令；它会自动发生。作为一个喜欢经常重构的人，我发现这个工具在及早发现问题方面非常宝贵。记住，你希望尽可能地实时找到错误。
- en: I’ve pulled up the mypy source codebase again and have Pylance enabled and in
    workplace diagnostics mode. I want to change one type on line 19 from a `sequence`
    to a `tuple` and see how Pylance handles the change. The code snippet I’m changing
    is shown in [Figure 6-2](part0009_split_007.html#VS_code_before_editing).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我再次查看了 mypy 源代码库，并启用了 Pylance 并处于工作区诊断模式。我想将第 19 行的一个类型从 `sequence` 改为 `tuple`，并看看
    Pylance 如何处理这个变化。我正在改变的代码片段显示在 [图 6-2](part0009_split_007.html#VS_code_before_editing)
    中。
- en: '![Problems in VS Code before editing](../images/00010.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![编辑前 VS Code 中的问题](../images/00010.jpeg)'
- en: Figure 6-2\. Problems in VS Code before editing
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 编辑前的 VS Code 中的问题
- en: Notice at the bottom where my “Problems” are listed. The current view is showing
    issues in another file that imports and uses the current function I’m editing.
    Once I change the `paths` parameter from `sequence` to a `tuple`, see how the
    “Problems” change in [Figure 6-3](part0009_split_007.html#VS_code_after_editing).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意底部列出的我的“问题”。当前视图显示的是另一个文件中的问题，该文件导入并使用我正在编辑的当前函数。一旦我将`paths`参数从`sequence`更改为`tuple`，就可以看到“问题”在[图 6-3](part0009_split_007.html#VS_code_after_editing)中如何更改。
- en: Within half a second of saving my file, new errors have shown up in my “Problems”
    pane, telling me that I’ve just broken assumptions in calling code. I don’t have
    to wait to run a typechecker manually, or wait for a continuous integration (CI)
    process to yell at me; my errors show up right in my editor. If that doesn’t lead
    me to finding errors earlier, I don’t know what will.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存文件的半秒钟内，我的“问题”窗格中就出现了新的错误，告诉我我刚刚在调用代码中破坏了假设。我不必手动运行类型检查器，也不必等待持续集成（CI）过程指责我；我的错误就出现在我的编辑器中。如果这不能让我更早地发现错误，我不知道还有什么能。
- en: '![Problems in VS Code after editing](../images/00011.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![编辑后的VS Code中的问题](../images/00011.jpeg)'
- en: Figure 6-3\. Problems in VS Code after editing
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 编辑后的VS Code中的问题
- en: Closing Thoughts
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结语
- en: Python typecheckers put a wealth of options at your disposal, and you need to
    be comfortable with advanced configuration to get the most out of your tooling.
    You can control severity options and reporting, or even use different typecheckers
    to reap benefits. As you evaluate tools and options, ask yourself how strict you
    want your typecheckers to be. As you increase the scope of errors that can be
    caught, you will increase the amount of time and effort needed to make your codebase
    compliant. However, the more informative you can make your code, the more robust
    it will be in its lifetime.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Python类型检查器为您提供了丰富的选项，您需要熟悉高级配置，以充分利用您的工具。您可以控制严重性选项和报告，甚至使用不同的类型检查器来获得收益。在评估工具和选项时，问问自己您希望您的类型检查器有多严格。随着您可以捕获的错误范围的增加，您将需要增加使您的代码库符合规范所需的时间和精力。然而，您的代码越具有信息量，它在其生命周期中就越健壮。
- en: In the next chapter, I will talk about how to assess the trade-offs between
    benefits and costs associated with typechecking. You’ll learn how to identify
    important areas to typecheck and use strategies to mitigate your pain.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将讨论如何评估与类型检查相关的收益和成本之间的权衡。您将学习如何确定重要的类型检查区域，并使用策略来减轻您的痛苦。
- en: ^([1](part0009_split_000.html#idm45644746850088-marker)) Jukka Lehtosalo. “Our
    Journey to Type Checking 4 Million Lines of Python.” *Dropbox.Tech* (blog). Dropbox,
    September 5, 2019\. [*https://oreil.ly/4BK3k*](https://oreil.ly/4BK3k).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](part0009_split_000.html#idm45644746850088-marker)) Jukka Lehtosalo。“我们对检查4百万行Python代码的旅程。”
    *Dropbox.Tech*（博客）。Dropbox，2019年9月5日。[*https://oreil.ly/4BK3k*](https://oreil.ly/4BK3k)。
- en: '^([2](part0009_split_000.html#idm45644746847016-marker)) Confucius and Arthur
    Waley. *The Analects of Confucius*. New York, NY: Random House, 1938.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](part0009_split_000.html#idm45644746847016-marker)) 孔子和阿瑟·韦利。 *论语*。纽约，纽约州：随机之家，1938年。
- en: ^([3](part0009_split_006.html#idm45644746190568-marker)) You can learn more
    about sanitizers at [*https://oreil.ly/AghGg*](https://oreil.ly/AghGg).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](part0009_split_006.html#idm45644746190568-marker)) 您可以在[*https://oreil.ly/AghGg*](https://oreil.ly/AghGg)了解更多关于**消毒剂**的信息。
