- en: Chapter 3\. Working with the Command Line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command line is where the rubber hits the road. Although there are many
    powerful tools with graphical interfaces, the command line is still home for DevOps
    work. Interacting with your shell environment from within Python and creating
    Python command-line tools are both necessary when using Python for DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers tools for interacting with systems and shells. You should become
    familiar with the `sys`, `os`, and `subprocess` modules, as all are essential
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Talking to the Interpreter with the sys Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sys` module offers access to variables and methods closely tied to the
    Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are two dominant ways to interpret bytes during reading. The first, *little
    endian*, interprets each subsequent byte as having higher significance (representing
    a larger digit). The other, *big endian*, assumes the first byte has the greatest
    significance and moves down from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `sys.byteorder` attribute to see the byte order of your current
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `sys.getsizeof` to see the size of Python objects. This is useful
    if you are dealing with limited memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to perform different behaviors, depending on the underlying operating
    system, you can use `sys.platform` to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A more common situation is that you want to use a language feature or module
    that is only available in specific versions of Python. You can use the `sys.version_info`
    to control behavior based on the running Python interpreter. Here we print different
    messages for Python 3.7, a Python version 3 that is below 3.7, and Python versions
    lower than 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We cover more `sys` usage later in this chapter when we write command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with the Operating System Using the os Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have seen the `os` module used in [Chapter 2](ch02.html#automating_files_and_the_filesystem)
    for dealing with the filesystem. It also has a grab bag of various attributes
    and functions related to dealing with the operating system. In [Example 3-1](#Example-3-1)
    we demonstrate some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1\. os module examples
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_the_command_line_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_the_command_line_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Change the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_the_command_line_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `os.environ` holds the environment variables that were set when the `os`
    module was loaded.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_working_with_the_command_line_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the setting and environment variable. This setting exists for subprocesses
    spawned from this code.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_working_with_the_command_line_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the login of the user in the terminal that spawned this process.
  prefs: []
  type: TYPE_NORMAL
- en: The most common usage of the `os` module is to get settings from environment
    variables. These could be the level to set your logging, or secrets such as API
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: Spawn Processes with the subprocess Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many instances when you need to run applications outside of Python
    from within your Python code. This could be built-in shell commands, Bash scripts,
    or any other command-line application. To do this, you spawn a new *process* (instance
    of the application). The `subprocess` module is the right choice when you want
    to spawn a process and run commands within it. With `subprocess`, you can run
    your favorite shell command or other command-line software and collect its output
    from within Python. For the majority of use cases, you should use the `subprocess.run`
    function to spawn processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `subprocess.run` function returns a `CompletedProcess` instance once the
    process completes. In this case, we run the shell command `ls` with the argument
    `-l` to see the contents of the current directory. We set it to capture `stdout`
    and `stderr` with the `capture_output` parameter. We then access the results using
    `cp.stdout`. If we run our `ls` command on a nonexistent directory, causing it
    to return an error, we can see the output in `cp.stderr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can better integrate the handling of errors by using the `check` parameter.
    This raises an exception if the subprocess reports an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this way, you don’t have to check `stderr` for failures. You can treat errors
    from your subprocess much as you would other Python exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Command-Line Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to invoke a Python script on the command line is to invoke
    it using Python. When you construct a Python script, any statements at the top
    level (not nested in code blocks) run whenever the script is invoked or imported.
    If you have a function you want to run whenever your code is loaded, you can invoke
    it at the top level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This function runs whenever the script runs on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, when the file is imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This should only be done with the most straightforward scripts, however. A
    significant downside to this approach is that if you want to import your module
    into other Python modules, the code runs during import instead of waiting to be
    invoked by the calling module. Someone who is importing your module usually wants
    control over when its contents are invoked. You can add functionality that only
    happens when called from the command line by using the global `*name*` variable.
    You have seen that this variable reports the name of the module during import.
    If the module is called directly on the command line, this sets it to the string
    `**main**`. The convention for modules running on the command line is to end with
    a block testing for this and run command-line specific code from this block. To
    modify the script to run a function automatically only when invoked on the command
    line, but not during import, put the function invocation into the block after
    the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When you import this function, this block does not run, as the `__name__` variable
    reflects the module path as imported. It runs when the module is run directly,
    however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first step in creating command-line tools is separating code that should
    only run when invoked on the command line. The next step is to accept command-line
    arguments. Unless your tool only does one thing, you need to accept commands to
    know what to do. Also, command-line tools that do more than the simplest tasks
    accept optional flags to configure their workings. Remember that these commands
    and flags are the *user interface* (UI) for anyone using your tools. You need
    to consider how easy they are to use and understand. Providing documentation is
    an essential part of making your code understandable.
  prefs: []
  type: TYPE_NORMAL
- en: Using sys.argv
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest and most basic way to process arguments from the command line
    is to use the `argv` attribute of the `sys` module. This attribute is a list of
    arguments passed to a Python script at runtime. If the script runs on the command
    line, the first argument is the name of the script. The rest of the items in the
    list are any remaining command-line arguments, represented as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it on the command line and see the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can use these arguments to write your own argument parser. To see what this
    might look like, check out [Example 3-2](#Example-3-2).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-2\. Parsing with sys.argv
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_the_command_line_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here we test to see if we are running from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_the_command_line_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Default values are set in these two lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_the_command_line_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the string `--help` is in the list of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_working_with_the_command_line_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Exit the program after printing the help message.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_working_with_the_command_line_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We need the position of the value after the flag, which should be the associated
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_working_with_the_command_line_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Test that the arguments list is long enough. It will not be if the flag was
    provided without a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_working_with_the_command_line_CO2-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Call the function with the values as modified by the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-2](#Example-3-2) goes far enough to print out a simple help message
    and accept arguments to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This approach is fraught with complication and potential bugs. [Example 3-2](#Example-3-2)
    fails to handle many situations. If a user misspells or miscapitalizes a flag,
    the flag is ignored with no useful feedback. If they use commands that are not
    supported or try to use more than one value with a flag, once again the error
    is ignored. You should be aware of the `argv` parsing approach, but do not use
    it for any production code unless you specifically set out to write an argument
    parser. Luckily there are modules and packages designed for the creation of command-line
    tools. These packages provide frameworks to design the user interface for your
    module when running in a shell. Three popular solutions are *argparse*, *click*,
    and *python-fire*. All three include ways to design required arguments, optional
    flags, and means to display help documentation. The first, `argparse`, is part
    of the Python standard library, and the other two are third-party packages that
    need to be installed separately (using `pip`).
  prefs: []
  type: TYPE_NORMAL
- en: Using argparse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`argparse` abstracts away many of the details of parsing arguments. With it,
    you design your command-line user interface in detail, defining commands and flags
    along with their help messages. It uses the idea of parser objects, to which you
    attach commands and flags. The parser then parses the arguments, and you use the
    results to call your code. You construct your interface using `ArgumentParser`
    objects that parse user input for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You add position-based commands or optional flags to the parser using the `add_argument`
    method (see [Example 3-3](#Example-3-3)). The first argument to this method is
    the name of the new argument (command or flag). If the name begins with a dash,
    it is treated as an optional flag argument; otherwise it is treated as a position-dependent
    command. The parser creates a parsed-arguments object, with the arguments as attributes
    that you can then use to access input. [Example 3-3](#Example-3-3) is a simple
    program that echoes a users input and shows the basics of how `argparse` works.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-3\. simple_parse.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_the_command_line_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the parser object, with its documentation message.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_the_command_line_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Add a position-based command with its help message.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_the_command_line_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Add an optional argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_working_with_the_command_line_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Store the optional argument as a boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_working_with_the_command_line_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the parser to parse the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_working_with_the_command_line_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Access the argument values by name. The optional argument’s name has the *--*
    removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run it with the `--twice` flag, the input message prints twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`argparse` automatically sets up help and usage messages based on the help
    and description text you supply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Many command-line tools use nested levels of commands to group command areas
    of control. Think of `git`. It has top-level commands, such as `git stash`, which
    have separate commands under them, such as `git stash pop`. With `argparse`, you
    create subcommands by creating subparsers under your main parser. You can create
    a hierarchy of commands using subparsers. In [Example 3-4](#Example-3-4), we implement
    a maritime application that has commands for ships and sailors. Two subparsers
    are added to the main parser; each subparser has its own commands.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-4\. argparse_example.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_the_command_line_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the top-level parser.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_the_command_line_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Add a top-level argument that can be used along with any command under this
    parser’s hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_the_command_line_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a subparser object to hold the subparsers. The `dest` is the name of
    the attribute used to choose a subparser.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_working_with_the_command_line_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Add a subparser for *ships*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_working_with_the_command_line_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Add a command to the *ships* subparser. The `choices` parameter gives a list
    of possible choices for the command.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_working_with_the_command_line_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Add a subparser for *sailors*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_working_with_the_command_line_CO4-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Add a required positional argument to the *sailors* subparser.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_working_with_the_command_line_CO4-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Check which subparser is used by checking the `func` value.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-4](#Example-3-4) has one top-level optional argument (`twice`) and
    two subparsers. Each subparser has its own commands and flags. `argparse` automatically
    creates a hierarchy of help messages and displays them with the `--help` flag.
    The top-level help commands, including the subparsers and the top-level `twice`
    argument, are documented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can dig into the subcommands (subparsers) by using the `help` flag after
    the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `argparse` gives you a lot of control over your command-line
    interface. You can design a multilayered interface with built-in documentation
    with many options to fine-tune your design. Doing so takes a lot of work on your
    part, however, so let’s look at some easier options.
  prefs: []
  type: TYPE_NORMAL
- en: Using click
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `click` package was first developed to work with web framework `flask`.
    It uses Python *function decorators* to bind the command-line interface directly
    with your functions. Unlike `argparse`, `click` interweaves your interface decisions
    directly with the rest of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that you tie your flags and options directly to the parameters of
    the functions that they expose. You can create a simple command-line tool from
    your functions using click’s `command` and `option` functions as decorators before
    your function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`click.command` indicates that a function should be exposed to command-line
    access. `click.option` adds an argument to the command-line, automatically linking
    it to the function parameter of the same name (`--greeting` to `greet` and `--name`
    to `name`). `click` does some work behind the scenes so that we can call our `greet`
    method in our main block without parameters that are covered by the `options`
    decorators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These decorators handle parsing command-line arguments and automatically produce
    help messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can see that with `click` you can expose your functions for command-line
    use with much less code than `argparse`. You can concentrate on the business logic
    of your code rather than designing the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at a more complicated example with nested commands. Commands
    are nested by using `click.group` creating functions that represent the groups.
    In [Example 3-5](#Example-3-5) we nest commands with `argparse`, using an interface
    that is very similar to the one from [Example 3-4](#Example-3-4).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-5\. click_example.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_the_command_line_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a top-level group under which other groups and commands will reside.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_the_command_line_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function to act as the top-level group. The `click.group` method transforms
    the function into a group.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_the_command_line_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a group to hold the `ships` commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_working_with_the_command_line_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `ships` group as a command to the top-level group. Note that the `cli`
    function is now a group with an `add_command` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_working_with_the_command_line_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Add a command to the `ships` group. Notice that `ships.command` is used instead
    of `click.command`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_working_with_the_command_line_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Add a command to the `cli` group.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_working_with_the_command_line_CO5-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Call the top-level group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level help messages generated by `click` look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can dig into the help for a subgroup like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you compare [Example 3-4](#Example-3-4) and [Example 3-5](#Example-3-5),
    you will see some of the differences between using `argparse` and `click`. The
    `click` approach certainly requires less code, almost half in these examples.
    The user interface (UI) code is interspersed throughout the whole program; it
    is especially important when creating functions that solely act as groups. If
    you have a complex program, with a complex interface, you should try as best as
    possible to isolate different functionality. By doing so, you make individual
    pieces easier to test and debug. In such a case, you might choose `argparse` to
    keep your interface code separate.
  prefs: []
  type: TYPE_NORMAL
- en: fire
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s take a step farther down the road of making a command-line tool
    with minimal UI code. The `fire` package uses introspection of your code to create
    interfaces automatically. If you have a simple function you want to expose, you
    call `fire.Fire` with it as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`fire` then creates the UI based on the method’s name and arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In simple cases, you can expose multiple methods automatically by invoking
    `fire` with no arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`fire` creates a command from each function and documents automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is really convenient if you are trying to understand someone else’s code
    or debug your own. With one line of additional code, you can interact with all
    of a module’s functions from the command-line. That is powerful. Because `fire`
    uses the structure of your program itself to determine the interface, it is even
    more tied to your non-interface code than `argparse` or `click`. To mimic our
    nest command interface, you need to define classes with the structure of the interface
    you want to expose. To see an approach to this, check out [Example 3-6](#Example-3-6).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-6\. fire_example.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_the_command_line_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a class for the ships commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_the_command_line_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`sailors` has no subcommands, so it can be defined as a function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_the_command_line_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a class to act as the top group. Add the `sailors` function and the `Ships`
    as attributes of the class.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_working_with_the_command_line_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Call `fire.Fire` on the class acting as the top-level group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The automatically generated documentation at the top level represents the `Ships`
    class as a group, and the `sailors` command as a command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The documentation for the `ships` group shows the commands representing the
    methods attached to the `Ships` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters for the `sailors` function are turned into positional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call the commands and subcommands as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'An exciting feature of `fire` is the ability to enter an interactive mode easily.
    By using the `--interactive` flag, `fire` opens an IPython shell with the object
    and functions of your script available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here we run the maritime program’s `sailors` command in interactive mode. An
    IPython shell opens, and you have access to the `sailors` function. This interactive
    mode, in combination with the ease of exposing objects with `fire`, makes it the
    right tool both for debugging and introducing yourself to new code.
  prefs: []
  type: TYPE_NORMAL
- en: You have now run the gamut in command-line tool building libraries, from the
    very hands-on `argparse`, to the less verbose `click`, and lastly to the minimal
    `fire`. So which one should you use? We recommend `click` for most use cases.
    It balances ease and control. In the case of complex interfaces where you want
    to separate the UI code from business logic, `argparse` is the way to go. Moreover,
    if you need to access code that does not have a command-line interface quickly,
    `fire` is right for you.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Plug-ins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve implemented your application’s command-line user interface, you
    might want to consider a plug-in system. Plug-ins are pieces of code supplied
    by the user of your program to extend functionality. Plug-in systems are used
    in all sorts of applications, from large applications like Autodesk’s Maya to
    minimal web frameworks like Flask. You could write a tool that handles walking
    a filesystem and allows a user to provide plug-ins to operate on its contents.
    A key part of any plug-in system is plug-in discover. Your program needs to know
    what plug-ins are available to load and run. In [Example 3-7](#Example-3-7), we
    write a simple application that discovers and runs plug-ins. It uses a user-supplied
    prefix to search for, load, and run plug-ins.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-7\. simple_plugins.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_with_the_command_line_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`pkgutil.iter_modules` returns all modules available in the current `sys.path`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_with_the_command_line_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the module uses our plug-in prefix.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_working_with_the_command_line_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `importlib` to load the module, saving it in a `dict` for later use.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_working_with_the_command_line_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Call the `run` method on the plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing supplying plug-ins to [Example 3-7](#Example-3-7) is as simple as supplying
    modules whose names use a shared prefix and whose functionality is accessed using
    a method named `run`. If you write two files using the prefix `foo_plugin` with
    individual run methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can discover and run them with our plugin application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can easily extend this simple example to create plug-in systems for your
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case Study: Turbocharging Python with Command-Line Tools'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s as good a time as ever to be writing code these days; a little bit of code
    goes a long way. Just a single function is capable of performing incredible things.
    Thanks to GPUs, machine learning, the cloud, and Python, it’s easy to create “turbocharged”
    command-line tools. Think of it as upgrading your code from using a basic internal
    combustion engine to a jet engine. What’s the basic recipe for the upgrade? One
    function, a sprinkle of powerful logic, and, finally, a decorator to route it
    to the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and maintaining traditional GUI applications—web or desktop—is a Sisyphean
    task at best. It all starts with the best of intentions, but can quickly turn
    into a soul crushing, time-consuming ordeal where you end up asking yourself why
    you thought becoming a programmer was a good idea in the first place. Why did
    you run that web framework setup utility that essentially automated a 1970s technology—the
    relational database—into series of Python files? The old Ford Pinto with the exploding
    rear gas tank has newer technology than your web framework. There has got to be
    a better way to make a living.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is simple: stop writing web applications and start writing jet-powered
    command-line tools instead. The turbocharged command-line tools discussed in the
    following sections are focused on fast results vis-à-vis minimal lines of code.
    They can do things like learn from data (machine learning), make your code run
    two thousand times faster, and best of all, generate colored terminal output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the raw ingredients that will be used to make several solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Click framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python CUDA framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numba framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scikit-learn machine learning framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Numba Just-in-Time (JIT) Compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has a reputation for slow performance because it’s fundamentally a scripting
    language. One way to get around this problem is to use the Numba Just-in-Time
    (JIT) compiler. Let’s take a look at what that code looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, use a timing decorator to get a grasp on the runtime of your functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Next, add a `numba.jit` decorator with the `nopython` keyword argument and set
    it to `True`. This will ensure that the code will be run by JIT instead of regular
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run it, you can see both a `jit` as well as a regular version being
    run via the command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'How does that work? Just a few lines of code allow for this simple toggle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, a JIT version could make code run thousands of times faster,
    but benchmarking is key. Another item to point out is this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This script allows for colored terminal output, which can be very helpful when
    creating sophisticated tools.
  prefs: []
  type: TYPE_NORMAL
- en: Using the GPU with CUDA Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to turbocharge your code is to run it straight on a GPU. This example
    requires you run it on a machine with a CUDA enabled. Here’s what that code looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s useful to point out that if the Numpy array is first moved to the GPU,
    then a vectorized function does the work on the GPU. After that work is completed,
    the data is moved from the GPU. By using a GPU, there could be a monumental improvement
    to the code, depending on what it’s running. The output from the command-line
    tool is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Running True Multicore Multithreaded Python Using Numba
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One common performance problem with Python is the lack of true, multithreaded
    performance. This also can be fixed with Numba. Here’s an example of some basic
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note that the key difference between the parallel version is that it uses `@numba.jit(parallel=True)`
    and `numba.prange` to spawn threads for iteration. As you can see in [Figure 3-1](#Figure-3-1),
    all of the CPUs are maxed out on the machine, but when almost the exact same code
    is run without the parallelization, it only uses a core.
  prefs: []
  type: TYPE_NORMAL
- en: '![pydo 0301](assets/pydo_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Using all of the cores
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: KMeans Clustering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another powerful thing that can be accomplished with a command-line tool is
    machine learning. In the example below, a KMeans clustering function is created
    with just a few lines of code. This clusters a Pandas DataFrame into a default
    of three clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The cluster number can be changed by passing in another number (as shown below)
    using `click`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the output of the Pandas DataFrame with the cluster assignment is
    shown next. Note that it now has cluster assignment as a column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use `sys` to write a script that prints *command line* only when run from the
    command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `click` to create a command-line tool that takes a name as an argument and
    prints it if it does not begin with a *p*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `fire` to access methods in an existing Python script from the command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
