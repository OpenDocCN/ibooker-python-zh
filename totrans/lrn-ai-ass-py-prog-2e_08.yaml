- en: 9 *Automating tedious tasks*
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 *自动化繁琐任务*
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章内容包括
- en: Understanding why programmers write tools
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么程序员编写工具
- en: Determining which modules we need to write a given tool
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定我们需要编写哪些模块来制作一个给定的工具
- en: Automating cleaning up emails that have > > > symbols
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化清理包含 > > > 符号的电子邮件
- en: Automating manipulating PDF files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化处理PDF文件
- en: Automating removing duplicate pictures across multiple image libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化移除多个图片库中的重复图片
- en: Suppose that you’re responsible for creating 100 reports, one for each of 100
    people. Perhaps you’re a teacher and need to send a report to each of your students.
    Perhaps you work for HR and need to send an annual assessment report to each employee.
    Regardless of your role, you have the problem of having to create these reports,
    and you decided to prepare your reports as .pdf files. You need a customized cover
    page for each report too, and those cover pages are designed by one of your colleagues
    (a graphic design artist).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你负责为100个人创建100份报告。也许你是老师，需要给每个学生发送一份报告。也许你在HR工作，需要给每位员工发送年度评估报告。不管你是什么角色，你面临的都是需要创建这些报告的问题，而且你决定将报告准备为.pdf文件。你还需要为每份报告准备定制化的封面页，这些封面页是由你的同事（一个平面设计师）设计的。
- en: You and your colleague work independently, and, finally, the job is done. Or
    wait, not so fast. Because now you have to put each cover page at the beginning
    of each report.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你和你的同事独立工作，最后，工作完成了。等等，别急。因为现在你必须把每个封面页放到每份报告的开头。
- en: At this point, a nonprogrammer might grit their teeth and start on the job,
    manually merging the cover page with the first report, the second cover page with
    the second report, and so on. That could take hours. Not knowing that there may
    be another way, a nonprogrammer may just power ahead until the job is done.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，非程序员可能会咬紧牙关，开始手动处理这个任务，将封面页与第一份报告合并，第二个封面页与第二份报告合并，依此类推。这可能需要几个小时。如果他们没有意识到可能有其他方法，非程序员可能会继续推进，直到任务完成。
- en: But you’re a programmer now. And most programmers, the two of us included, would
    never power ahead with manual work like this.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在你是程序员了。而大多数程序员，包括我们俩在内，绝不会继续手动做这种工作。
- en: In this chapter, we’re going to show you how to write programs to automate tedious
    tasks. The second example in the chapter will automate the “merging cover pages
    with reports” situation. But we’ll do others as well. Received an email that’s
    been forwarded so many times
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向你展示如何编写程序来自动化繁琐的任务。本章中的第二个例子将自动化“合并封面页和报告”的情况。但我们还会展示其他例子。收到一封被转发了很多次的电子邮件
- en: that it looks
  id: totrans-12
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它看起来
- en: like
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 像
- en: this?
  id: totrans-14
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这样吗？
- en: Or does your family have several phones, each with hundreds of images, and you
    just want to get the images all in the same place so that you can archive them
    without losing anything? In this chapter, we’ll show you how to automate tasks
    like that.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你们家有好几部手机，每部手机里都有数百张图片，而你只想把这些图片集中到一个地方，这样就可以归档而不丢失任何内容？在本章中，我们将向你展示如何自动化这样的任务。
- en: 9.1 Why programmers make tools
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 为什么程序员制作工具
- en: 'There’s a common sentiment that programmers often express: we’re lazy. This
    doesn’t mean that we don’t want to do our work. It means that we don’t want to
    do *repetitive, boring, tedious* work because that’s what computers are good at.
    Programmers develop a sort of spidey-sense for this kind of drudgery. Suppose
    Leo has a few hundred photos, and he wants to delete any photos that are duplicates.
    There’s no way he’d do this by hand. Or suppose that Dan has to send out a customized
    email to each of his students. If it’s more than a few students, there’s no way
    he’s doing this by hand. As soon as programmers start noticing that they’re repeating
    the same keys on the keyboard or working through the same steps over and over,
    they’ll stop and make a tool to automate it.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个程序员常常表达的普遍观点：我们很懒。这并不意味着我们不想做工作，而是说我们不想做*重复、无聊、繁琐*的工作，因为这些正是计算机擅长的。程序员们会对这种辛苦的工作产生一种类似蜘蛛感应的敏锐感觉。假设Leo有几百张照片，他想要删除所有重复的照片。没有人会手动去做这件事。又比如Dan需要给他的每个学生发送定制化的邮件。如果学生人数不多也就算了，但如果是几位以上的学生，他绝对不会手动去做这件事。一旦程序员们开始意识到自己反复按相同的键盘或执行同样的步骤，他们就会停下来，编写工具来自动化这一过程。
- en: When programmers talk about tools, they’re talking about programs that do something
    that saves them time. A tool often isn’t the end goal, and writing one can itself
    feel tedious and not glamorous. But once we have a tool, we can use it to save
    us time. Sometimes, we’ll use a tool once, for one specific job, and then never
    again. Commonly, though, a tool ends up being useful over and over, whether we
    use the tool exactly as we wrote it or by making some small changes. For example,
    after Dan finishes teaching each course, he uses a program he wrote to collate
    all student grades and submit them to the university. He makes small changes to
    the tool each time—changing the weights of each assignment, for example—but then
    Dan can use that slightly modified tool to do the work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员谈论工具时，他们是在谈论那些可以节省时间的程序。工具通常不是最终目标，编写工具本身可能感觉枯燥乏味，也不怎么光彩。但一旦我们有了工具，我们就可以用它来节省时间。有时，我们会用工具一次，处理一个特定的任务，然后再也不使用它了。然而，通常情况下，工具会反复派上用场，无论我们是按照原样使用它，还是进行一些小修改。例如，在
    Dan 完成每一门课程的教学后，他会使用自己编写的程序将所有学生的成绩整理并提交给学校。他每次都对工具进行小修改——比如改变每个作业的权重——然后 Dan
    就可以使用这个略微修改过的工具来完成工作。
- en: 'The great thing about using Copilot is that it makes cranking out these tools
    easier. Here’s how one software engineer explains it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Copilot 的一个伟大之处在于，它让编写这些工具变得更加轻松。以下是一位软件工程师对这一点的解释：
- en: We all know that tools are important, that effective tools are challenging to
    create, and that management doesn’t care or understand the need for tools. . .
    . I can’t express how fundamentally different programming feels now that I can
    build two quality tools per day, for every single itch I want to scratch. [1]
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们都知道工具的重要性，知道有效的工具难以创建，也知道管理层并不关心或理解工具的需求……我无法表达现在我每天可以构建两个高质量工具，满足我每个想解决的问题时，编程的感觉是多么根本性的不同。[1]
- en: 9.2 How to use Copilot to write tools
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 如何使用 Copilot 编写工具
- en: As we learned in chapter 5 when talking about modules, sometimes we need to
    use a module to help us write the program we want. Some modules are built into
    Python. For example, in chapter 5, we used the built-in zipfile module to help
    us create a .zip file. Other modules aren’t built in, and we need to install them
    first before we can use them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第五章讨论模块时所学到的那样，有时我们需要使用模块来帮助我们编写所需的程序。有些模块是 Python 内置的。例如，在第五章中，我们使用了内置的
    zipfile 模块来帮助我们创建一个 .zip 文件。其他模块则不是内置的，我们需要先安装它们，然后才能使用。
- en: When writing a tool, it’s often the case that we’ll be working with some specialized
    data format (zip files, PDF files, Microsoft Excel spreadsheets, images) or performing
    some specialized task (sending email, interacting with a website, moving files
    around). For most of this, we’re going to need to use a module. Which module,
    though? And is it built in, or do we need to install it? These are the first questions
    we need to get answers to.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写工具时，我们通常会处理一些专业化的数据格式（如 zip 文件、PDF 文件、Microsoft Excel 表格、图片），或者执行一些特定的任务（如发送电子邮件、与网站互动、移动文件）。对于这些大多数情况，我们需要使用某个模块。那么，使用哪个模块呢？它是内置的，还是需要我们安装的？这些是我们需要首先回答的问题。
- en: Fortunately, we can use Copilot Chat (or ChatGPT) to help us get started. As
    a reminder, we’re using the Copilot Chat feature because it’s built into our Visual
    Studio Code (VS Code) IDE and because Copilot Chat has access to the very code
    we’re currently writing so it can incorporate what we’re doing into its answers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以使用 Copilot Chat（或 ChatGPT）来帮助我们入门。作为提醒，我们使用 Copilot Chat 功能是因为它已经内置于我们的
    Visual Studio Code (VS Code) 集成开发环境（IDE）中，并且 Copilot Chat 可以访问我们当前正在编写的代码，因此它能够将我们正在做的事情融入到它的回答中。
- en: 'The plan is to have a conversation with Copilot to determine which module we
    need to use. Once we know that and install the module, if necessary, then we can
    get down to the business of writing the code for our tool. We’ll do that the way
    we’ve always done it: by writing the function header and a docstring and having
    Copilot fill in the code for us. Once Copilot starts writing code, we need to
    follow the same steps as in previous chapters, including checking code correctness,
    fixing bugs, and maybe even doing some problem decomposition. To focus our attention
    on writing tools to automate tasks, we’ll minimize the time we spend on these
    additional tasks here.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是与 Copilot 进行对话，确定我们需要使用哪个模块。一旦我们知道了，并且安装了该模块（如果需要的话），我们就可以开始编写工具的代码了。我们会按照以往的方式进行：编写函数头和文档字符串，然后让
    Copilot 为我们填充代码。一旦 Copilot 开始编写代码，我们需要按照之前章节中的相同步骤进行，包括检查代码的正确性、修复错误，甚至可能需要进行一些问题分解。为了将我们的注意力集中在编写自动化任务工具上，我们将尽量减少在这些额外任务上花费的时间。
- en: It may be possible to ask Copilot or ChatGPT to write the entire tool for us,
    without even having to put it inside of a function. We won’t do that here, though,
    because we still think that the benefits of functions are worthwhile. A function
    will help us document our code so that we know what it does, and it enables flexibility
    if we later decide, for example, to add additional parameters to our function
    to change the behavior of the tool.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能可以让 Copilot 或 ChatGPT 为我们编写整个工具，甚至不需要将它放入函数中。不过我们在这里不会这么做，因为我们仍然认为函数的好处是值得的。一个函数将帮助我们记录代码，以便我们知道它的功能，并且如果我们后来决定，比如说，添加额外的参数来改变工具的行为，它也能提供灵活性。
- en: '9.3 Example 1: Cleaning up email text'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 示例 1：清理电子邮件文本
- en: 'Sometimes, an email gets replied to and forwarded so many times that it becomes
    a mess, with many greater than (>) signs and spaces on some of the lines. Here’s
    a sample email of what we mean:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一封电子邮件被回复并转发多次，结果变得很混乱，某些行前面有很多大于号（>）和空格。以下是我们所说的示例邮件：
- en: Hi Leo,
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 嗨，Leo，
- en: Dan -- any luck with your natural language research?
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dan——你的自然语言研究有进展吗？
- en: Yes! That website you showed me
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是的！你给我看的那个网站
- en: '[https://www.kaggle.com/](https://www.kaggle.com/)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.kaggle.com/](https://www.kaggle.com/)'
- en: is very useful. I found a dataset on there that collects
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 非常有用。我在这里找到了一组数据集，收集了
- en: a lot
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢
- en: of questions and answers that might be useful to my research.
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可能对我的研究有用的问答。
- en: Thank you,
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 谢谢，
- en: Dan
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dan
- en: 'Suppose that you wanted to save this email information for future use. You
    might like to clean up the > and space symbols at the start of lines. You could
    start manually deleting them—this email isn’t that long, after all—but don’t do
    that because here you have an opportunity to design a general-purpose tool that
    you can use whenever you need to perform this task. Whether your email has five
    lines, a hundred lines, or a million lines, it won’t matter: just use the tool
    and be done.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想保存这封电子邮件中的信息以备将来使用。你可能想清理每行开头的 > 和空格符号。你可以手动删除它们——毕竟这封邮件并不长——但不要这么做，因为你现在有机会设计一个通用工具，以后每当你需要执行这个任务时都可以使用它。无论你的邮件有五行、一百行，还是一百万行，都没关系：只需要使用工具，轻松完成。
- en: 9.3.1 Conversing with Copilot
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 与 Copilot 对话
- en: We need to make the messy email available to our tool so that the tool can clean
    it up. One way we can do this is to first copy the text of an email to the clipboard
    (using your Copy to Clipboard command on your operating system, such as Ctrl-C).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要让工具能够处理凌乱的电子邮件，以便它可以清理这些邮件。我们可以通过首先将电子邮件的文本复制到剪贴板（使用操作系统上的复制到剪贴板命令，比如 Ctrl-C）来实现这一点。
- en: Each computer operating system has a clipboard to store the last thing copied.
    If you’ve ever used Copy-Paste, you’ve used that clipboard. We’re going to use
    the clipboard for temporary storage of text so we can edit the text in the clipboard
    and then paste it where we need it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个计算机操作系统都有一个剪贴板，用来存储最后复制的内容。如果你曾经使用过复制粘贴功能，那你就使用过剪贴板。我们将使用剪贴板暂时存储文本，以便我们可以编辑剪贴板中的文本，然后粘贴到需要的地方。
- en: After copying the text from the messy email to the clipboard, we could then
    run the tool on the text in the clipboard, and the tool could clean up the email
    and replace the clipboard contents with the cleaned-up version. For the tool to
    do something reasonable, we assume that your clipboard has email text on it. The
    tool will remove the > and space characters at the start of each line so that
    you can paste (using your operating system Paste command, such as Ctrl-V) the
    newly cleaned-up email wherever you want. In terms of Python, it will need to
    pull the clipboard contents into a string (i.e., copy the contents of the clipboard),
    clean it up, and then put that new cleaned-up text back on the clipboard (i.e.,
    paste to the clipboard), replacing the junky version of the email that was there
    before.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将杂乱的电子邮件文本复制到剪贴板后，我们可以在剪贴板中的文本上运行工具，工具将清理电子邮件并用清理后的版本替换剪贴板中的内容。为了让工具执行合理的操作，我们假设你的剪贴板中有电子邮件文本。该工具将删除每行开头的`>`和空格字符，以便你可以将清理后的电子邮件粘贴（使用操作系统的粘贴命令，如Ctrl-V）到你想要的位置。在Python中，它需要将剪贴板内容读取到字符串中（即复制剪贴板内容），进行清理，然后将清理后的新文本放回剪贴板（即粘贴到剪贴板），替换掉之前存在的杂乱电子邮件版本。
- en: So, how do we access the clipboard in our Python program? That’s what we need
    to figure out, so that will frame the conversation that we have with Copilot.
    Similar to chapter 8, we’re going to use “Human” for the prompts that we type
    and “GitHub Copilot” for Copilot’s responses. You can use the Copilot Chat feature
    or ChatGPT to have a similar conversation. We’re typing our prompts into the Copilot
    Chat window.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何在Python程序中访问剪贴板呢？这是我们需要弄明白的，因此这将构成我们与Copilot对话的框架。与第8章类似，我们将使用“Human”表示我们输入的提示，使用“GitHub
    Copilot”表示Copilot的回答。你也可以使用Copilot Chat功能或ChatGPT进行类似的对话。我们将提示输入到Copilot Chat窗口。
- en: In our chats with Copilot, we’re going to explore widely before settling on
    a solution. We’ll explain why we’re doing this once we’ve gotten the hang of things
    through one example, but we note this here so that you’ll be ready for this seemingly
    less direct approach. Copilot provides quite a bit of sample code in its responses.
    As we’re exploring, feel free to skim that code, but don’t get bogged down in
    it. We’ll look at more particulars of the code once we finish exploring and settle
    on a plan. Let’s start learning!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在与Copilot的对话中，我们会广泛探索，然后才会定下一个解决方案。我们会在通过一个示例掌握操作后解释为什么这样做，但在此先说明一下，以便你为这种看似间接的方法做好准备。Copilot在回答中提供了不少示例代码。在探索过程中，可以浏览这些代码，但不要在其中迷失。我们将在确定方案并进行详细讨论后，再仔细查看代码的具体内容。让我们开始学习吧！
- en: LPHumanI would like to write a Python program that accesses the clipboard and
    lets me copy and paste using the clipboard. How can I do this?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我想编写一个Python程序，能够访问剪贴板并让我使用剪贴板进行复制和粘贴。我该怎么做？
- en: '![chatGpt](../Images/chatGpt.png)GitHub CopilotYou can use the pyperclip module
    to access the clipboard in Python. Here’s an example program that lets you copy
    and paste using the clipboard:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot你可以使用pyperclip模块在Python中访问剪贴板。下面是一个示例程序，演示如何使用剪贴板进行复制和粘贴：'
- en: '[PRE0]`*[PRE1]`*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]`*[PRE1]`*'
- en: '*`*import pyperclip*`*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import pyperclip*`*'
- en: '*`*# Copy to clipboard*`*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 复制到剪贴板*`*'
- en: '*`*pyperclip.copy(''Hello, world!'')*`*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pyperclip.copy(''Hello, world!'')*`*'
- en: '*`*# Paste from clipboard*`*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 从剪贴板粘贴*`*'
- en: '*`*text = pyperclip.paste()*`*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*text = pyperclip.paste()*`*'
- en: '*`*print(text)*`*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(text)*`*'
- en: '*[PRE2]*[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE2]*[PRE3]'
- en: This program first imports the pyperclip module. It then copies the string `'Hello,`
    `world!'` to the clipboard using the `copy()` function. Finally, it pastes the
    contents of the clipboard into the “text” variable using the `paste()` function
    and prints the result.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序首先导入pyperclip模块。然后，它使用`copy()`函数将字符串`'Hello, world!'`复制到剪贴板。最后，它使用`paste()`函数将剪贴板的内容粘贴到“text”变量中，并打印出结果。
- en: You can install the pyperclip module using pip by running `pip` `install` `pyperclip`
    in your terminal.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在终端中运行`pip install pyperclip`来安装pyperclip模块。
- en: Copilot’s response teaches us that we can use the pyperclip module to interact
    with the clipboard in our Python program. The sample code that it provided even
    showed us how to copy stuff from our program to the clipboard and paste stuff
    from the clipboard into a variable (`text`). We’re making great progress!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot的回答教会了我们如何在Python程序中使用pyperclip模块与剪贴板进行交互。它提供的示例代码甚至向我们展示了如何从程序中复制内容到剪贴板，并将剪贴板中的内容粘贴到变量（`text`）中。我们正在取得很大的进展！
- en: The final paragraph of the response tells us how to install pyperclip. Aha!
    So pyperclip doesn’t come with Python by default. While we’ll learn how to install
    modules later, it might be nice to not have to worry about that. So, let’s continue
    the conversation, asking Copilot if we can do better.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的最后一段告诉我们如何安装pyperclip。啊哈！所以pyperclip默认并不包含在Python中。虽然我们稍后会学习如何安装模块，但最好还是不要担心这个问题。那么，让我们继续讨论，询问Copilot是否有更好的解决办法。
- en: LPHuman Is there a way I can do it without having to install a Python module?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman 有没有一种方法可以在不安装Python模块的情况下完成？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, you can use the tkinter
    module that comes with Python to access the clipboard. Here’s an example program
    that lets you copy and paste using the clipboard without installing any additional
    modules:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 是的，你可以使用Python自带的tkinter模块来访问剪贴板。下面是一个示例程序，它让你无需安装任何额外的模块就可以通过剪贴板进行复制和粘贴：'
- en: '[PRE4]`*[PRE5]`*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]`*[PRE5]`*'
- en: '*`*import tkinter as tk*`*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import tkinter as tk*`*'
- en: '*`*# Create a Tkinter window*`*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 创建一个Tkinter窗口*`*'
- en: '*`*root = tk.Tk()*`*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*root = tk.Tk()*`*'
- en: '*`*# Hide the window*`*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 隐藏窗口*`*'
- en: '*`*root.withdraw()*`*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*root.withdraw()*`*'
- en: '*`*# Copy to clipboard*`*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 复制到剪贴板*`*'
- en: '*`*root.clipboard_clear()*`*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*root.clipboard_clear()*`*'
- en: '*`*root.clipboard_append(''Hello, world!'')*`*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*root.clipboard_append(''Hello, world!'')*`*'
- en: '*`*# Paste from clipboard*`*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 从剪贴板粘贴*`*'
- en: '*`*text = root.clipboard_get()*`*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*text = root.clipboard_get()*`*'
- en: '*`*print(text)*`*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(text)*`*'
- en: '*[PRE6]*[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE6]*[PRE7]'
- en: This program first creates a hidden Tkinter window using the `Tk()` function
    and hides it using the `withdraw()` method. It then clears the clipboard using
    the `clipboard_ clear()` method and appends the string `'Hello,` `world!'` to
    the clipboard using the `clipboard_append()` method. Finally, it retrieves the
    contents of the clipboard using the `clipboard_get()` method and prints the result.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序首先使用`Tk()`函数创建一个隐藏的Tkinter窗口，并通过`withdraw()`方法将其隐藏。接着，使用`clipboard_clear()`方法清空剪贴板，并使用`clipboard_append()`方法将字符串`'Hello,
    world!'`添加到剪贴板中。最后，使用`clipboard_get()`方法获取剪贴板的内容并打印结果。
- en: Note that this method only works if you have a graphical environment available,
    such as a desktop environment on Linux or macOS, or the Windows desktop on Windows.
    If you’re running Python in a terminal-only environment, you’ll need to use a
    different method to access the clipboard.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个方法只有在你有图形环境的情况下才有效，例如在Linux或macOS上的桌面环境，或Windows上的Windows桌面。如果你在一个仅有终端的环境中运行Python，你需要使用其他方法来访问剪贴板。
- en: It seems that we’ve won something and lost something else. The win is that this
    tkinter module is built into Python. The loss is that “the method only works if
    you have a graphical environment available.” Do we have a graphical environment
    available in our Python setup? While we could certainly try the code to find out,
    this requirement gives us pause. After all, the pyperclip solution didn’t have
    that requirement, so we might not need it (whatever it happens to mean). Let’s
    try again.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们得到了一些东西，同时也失去了一些东西。收获是这个tkinter模块是内置于Python中的。失去的是“这个方法只有在你有图形环境的情况下才有效。”我们在Python环境中是否有图形环境呢？虽然我们可以尝试运行代码来找出答案，但这个要求让我们犹豫不决。毕竟，pyperclip解决方案没有这个要求，所以我们也许不需要它（无论它是什么意思）。让我们再试一次。
- en: LPHumanIs there another way I can do it without having to install a Python module?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman 有没有不需要安装Python模块的其他方法？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, you can access the clipboard
    using the win32clipboard module, which is included in the standard library on
    Windows. Here’s an example program that allows you to copy and paste using the
    clipboard without installing any additional modules:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 是的，你可以使用win32clipboard模块来访问剪贴板，这个模块在Windows的标准库中包含。下面是一个示例程序，它让你无需安装任何额外的模块就可以通过剪贴板进行复制和粘贴：'
- en: '[PRE8]`*[PRE9]`*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]`*[PRE9]`*'
- en: '*`*import win32clipboard*`*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import win32clipboard*`*'
- en: '*`*# Copy to clipboard*`*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 复制到剪贴板*`*'
- en: '*`*text = "Hello, world!"*`*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*text = "Hello, world!"*`*'
- en: '*`*win32clipboard.OpenClipboard()*`*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.OpenClipboard()*`*'
- en: '*`*win32clipboard.EmptyClipboard()*`*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.EmptyClipboard()*`*'
- en: '*`*win32clipboard.SetClipboardText(text)*`*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.SetClipboardText(text)*`*'
- en: '*`*win32clipboard.CloseClipboard()*`*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.CloseClipboard()*`*'
- en: '*`*# Paste from clipboard*`*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 从剪贴板粘贴*`*'
- en: '*`*win32clipboard.OpenClipboard()*`*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.OpenClipboard()*`*'
- en: '*`*pasted_text = win32clipboard.GetClipboardData()*`*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pasted_text = win32clipboard.GetClipboardData()*`*'
- en: '*`*win32clipboard.CloseClipboard()*`*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*win32clipboard.CloseClipboard()*`*'
- en: '*`*print(pasted_text)*`*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(pasted_text)*`*'
- en: '*[PRE10]*[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE10]*[PRE11]'
- en: This program first imports the win32clipboard module. To copy text to the clipboard,
    you can call the `OpenClipboard()` function to open the clipboard, then call `EmptyClipboard()`
    to clear any existing data, and finally call `SetClipboardText()` to set the text
    on the clipboard. After setting the text, you should call `CloseClipboard()` to
    close the clipboard.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序首先导入了 win32clipboard 模块。要将文本复制到剪贴板，可以调用 `OpenClipboard()` 函数打开剪贴板，然后调用 `EmptyClipboard()`
    清除现有数据，最后调用 `SetClipboardText()` 设置剪贴板上的文本。设置文本后，应调用 `CloseClipboard()` 关闭剪贴板。
- en: To paste from the clipboard, you can call `OpenClipboard()` to open the clipboard,
    then call `GetClipboardData()` to get the text from the clipboard. After getting
    the text, you should call `CloseClipboard()` to close the clipboard. In this example,
    the program copies the text `"Hello,` `world!"` to the clipboard, then pastes
    it and prints it to the console.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要从剪贴板粘贴，可以调用 `OpenClipboard()` 打开剪贴板，然后调用 `GetClipboardData()` 获取剪贴板中的文本。获取文本后，应调用
    `CloseClipboard()` 关闭剪贴板。在这个示例中，程序将文本 `"Hello,` `world!"` 复制到剪贴板，然后将其粘贴并打印到控制台。
- en: “Standard library on Windows,” eh? That’s concerning because it means that our
    tool might not work on other operating systems. Let’s see about that.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: “Windows 上的标准库，”嗯？这令人担忧，因为这意味着我们的工具可能无法在其他操作系统上运行。让我们来看看这个问题。
- en: LPHumanDoes that work on Linux or macOS too?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman：这也能在 Linux 或 macOS 上工作吗？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot No, the win32clipboard module
    is specific to Windows and won’t work on Linux or macOS. On Linux, you can use
    the `xclip` command-line utility to access the clipboard. Here’s an example program
    that allows you to copy and paste using the clipboard on Linux:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 不，win32clipboard 模块是专门为 Windows
    设计的，在 Linux 或 macOS 上无法使用。在 Linux 上，你可以使用 `xclip` 命令行工具来访问剪贴板。以下是一个示例程序，演示如何在
    Linux 上使用剪贴板进行复制和粘贴：'
- en: '[PRE12]`*[PRE13]`*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]`*[PRE13]`*'
- en: '*`*import subprocess*`*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import subprocess*`*'
- en: '*`*# Copy to clipboard*`*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 复制到剪贴板*`*'
- en: '*`*text = "Hello, world!"*`*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*text = "Hello, world!"*`*'
- en: '*`*subprocess.run([''xclip'', ''-selection'', ''clipboard''], input=text.encode(''utf-8''))*`*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*subprocess.run([''xclip'', ''-selection'', ''clipboard''], input=text.encode(''utf-8''))*`*'
- en: '*`*# Paste from clipboard*`*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 从剪贴板粘贴*`*'
- en: '*`*p = subprocess.Popen([''xclip'', ''-selection'', ''clipboard'', ''-o''],
    stdout=subprocess.PIPE)*`*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*p = subprocess.Popen([''xclip'', ''-selection'', ''clipboard'', ''-o''],
    stdout=subprocess.PIPE)*`*'
- en: '*`*pasted_text = p.stdout.read().decode(''utf-8'')*`*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pasted_text = p.stdout.read().decode(''utf-8'')*`*'
- en: '*`*print(pasted_text)*`*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(pasted_text)*`*'
- en: '*[PRE14]*[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE14]*[PRE15]'
- en: This program uses the subprocess module to run the `xclip` command-line utility.
    To copy text to the clipboard, you can call `subprocess.run()` and pass in the
    `xclip` command with the `-selection` `clipboard` option to specify the clipboard
    selection, and the `input` parameter to pass in the text you want to copy. To
    paste from the clipboard, you can call `subprocess.Popen()` and pass in the `xclip`
    command with the `-selection` `clipboard` `-o` options to read the text from the
    clipboard, and then read the output of the command using the `stdout` attribute
    of the `Popen` object. In this example, the program copies the text `"Hello,`
    `world!"` to the clipboard, then pastes it and prints it to the console.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序使用 subprocess 模块来运行 `xclip` 命令行工具。要将文本复制到剪贴板，可以调用 `subprocess.run()` 并传入带有
    `-selection` `clipboard` 选项的 `xclip` 命令，以指定剪贴板选择，并通过 `input` 参数传入你想复制的文本。要从剪贴板粘贴，可以调用
    `subprocess.Popen()` 并传入带有 `-selection` `clipboard` `-o` 选项的 `xclip` 命令来读取剪贴板中的文本，然后使用
    `Popen` 对象的 `stdout` 属性读取命令的输出。在这个示例中，程序将文本 `"Hello,` `world!"` 复制到剪贴板，然后将其粘贴并打印到控制台。
- en: On macOS, you can use the `pbcopy` and `pbpaste` command-line utilities to access
    the clipboard. The usage is similar to `xclip`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，你可以使用 `pbcopy` 和 `pbpaste` 命令行工具来访问剪贴板。使用方法与 `xclip` 类似。
- en: We’ve gotten some solutions that are specific to different operating systems.
    We don’t like this! We want our tool to work no matter which operating system
    we’re using. (Even if we’re using only Windows ourselves, maybe one day, we’ll
    share this tool with others who use different operating systems.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经获得了一些针对不同操作系统的解决方案。我们不喜欢这样！我们希望我们的工具能够在任何操作系统上都能工作。（即使我们自己只使用 Windows，也许有一天，我们会与使用不同操作系统的其他人分享这个工具。）
- en: We could continue our conversation, but in retrospect, having to install that
    single pyperclip module doesn’t seem so bad. Let’s go ahead with it. In general,
    it can be valuable to explore your options when deciding how to start writing
    a tool, and conversing with Copilot is helpful for carrying out this exploration.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以继续讨论，但回头看，安装那个单独的pyperclip模块似乎也没那么糟糕。我们就继续吧。一般来说，在决定如何开始编写工具时，探索你的选项是有价值的，而与Copilot的对话有助于进行这种探索。
- en: Why we should explore and understand our options
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为什么我们应该探索并理解我们的选项
- en: 'There are several reasons why you shouldn’t just use the first module that
    Copilot chat tells you to use:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因说明你不应该仅仅使用Copilot聊天告诉你使用的第一个模块：
- en: It may not work on all operating systems. In general, we want to find modules
    that work across multiple operating systems so that the tool can be used by you
    (if you later switch operating systems) or others with whom you’ve shared the
    tool.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能无法在所有操作系统上运行。一般来说，我们希望找到在多个操作系统上都能使用的模块，这样无论你（如果以后切换操作系统）还是你分享工具的其他人都能使用该工具。
- en: It may turn out not to work for our use case after all, or we may struggle to
    get the code to work. If we have other options, we can start trying those before
    sinking too much time into a strategy that may or may not ultimately work out.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果可能是它最终不适用于我们的使用场景，或者我们可能会很难让代码正常运行。如果我们有其他选择，我们可以先尝试那些选项，而不是把太多时间花在一个可能最终无法成功的策略上。
- en: Modules are updated frequently. Usually this is to add new features and fix
    bugs, but sometimes, functions are removed or changed in this process as well.
    When the author of a module removes a function, it’s known as *deprecating that
    function**.* Once a function is deprecated,it may no longer work, and we need
    to find a replacement. Copilot is trained only every once in a while, not continuously,
    so if a new version of a module comes out after Copilot was trained on it, Copilot
    won’t know about the updates. This can lead to Copilot suggesting code that depends
    on an older version of the module than the one you have. There are ways to address
    this, as we’ll see later in the chapter. But if you run into trouble, having other
    options to explore is useful.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块会频繁更新。通常，这是为了添加新功能和修复错误，但有时在这个过程中，某些功能也会被移除或更改。当模块的作者移除某个功能时，称为*废弃该功能*。一旦某个功能被废弃，它可能不再工作，我们需要找到替代品。Copilot仅会间歇性地进行训练，而不是持续训练，因此，如果在Copilot接受训练后有新版本的模块发布，Copilot就不了解这些更新。这可能导致Copilot建议的代码依赖于比你实际拥有的模块版本更旧的版本。我们稍后会在本章中看到解决这个问题的方法。但如果遇到麻烦，拥有其他选项可供探索是非常有用的。
- en: 9.3.2 Writing the tool to clean up email
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 编写清理邮件的工具
- en: 'The first thing we need to do is to install the pyperclip module. How do we
    install it, though? The good news is that Python has made it easy to install new
    modules. Go to the Terminal at the bottom right of VS Code and type the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是安装pyperclip模块。但是我们该如何安装呢？好消息是，Python让安装新模块变得非常容易。进入VS Code右下角的终端，输入以下命令：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note  For some operating systems, you may need to use `pip3` rather than `pip`.
    On Windows machines, we recommend using `pip` if you followed our installation
    instructions from chapter 2\. On Mac or Linux machines, we recommend using `pip3`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意  对于某些操作系统，你可能需要使用`pip3`而不是`pip`。在Windows机器上，如果你按照第2章的安装说明进行安装，我们建议使用`pip`。在Mac或Linux机器上，我们建议使用`pip3`。
- en: 'When you run this command, you might see that other modules get installed too.
    Don’t worry about that: sometimes modules need other modules to be able to do
    their work, and Python just installs them all so that you don’t have to worry
    about installing those dependencies yourself.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个命令时，你可能会看到其他模块也被安装。别担心：有时模块需要其他模块才能正常工作，Python会将它们一起安装，这样你就不必自己担心安装这些依赖项。
- en: Once that’s installed, we can import the module and then write the header and
    docstring for our function that will remove the > and space characters from the
    start of lines. The reason we’re importing the module here is to influence Copilot
    to use that module when writing the code for the function. Here’s the prompt we
    used and the code that Copilot gave us.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 安装好后，我们可以导入模块，然后编写我们用于删除行首的`>`和空格字符的函数的头部和文档字符串。我们在这里导入模块的原因是为了影响Copilot在为我们编写函数代码时使用该模块。以下是我们使用的提示和Copilot提供的代码。
- en: 'Listing 9.1 First try: Clean up email text in the clipboard'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1 第一次尝试：清理剪贴板中的邮件文本
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#1 Puts the current contents of the clipboard into the text string'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将剪贴板的当前内容放入文本字符串中'
- en: '#2 Splits the string into a list of its lines'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 将字符串拆分为行的列表'
- en: '#3 Loops through each line'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 遍历每一行'
- en: '#4 Removes spaces and &gt; symbols from the start of the line'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 从行的开头删除空格和 `>` 符号'
- en: '#5 This looks odd.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 这看起来很奇怪。'
- en: '#6 Copies the cleaned-up text to the clipboard'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 将清理后的文本复制到剪贴板'
- en: '#7 Note a common Python convention (see the following discussion).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 注意一个常见的 Python 约定（参见以下讨论）。'
- en: '#8 Calls our function to automatically clean up the clipboard!'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 调用我们的函数来自动清理剪贴板！'
- en: 'We can see that the program is carrying out the correct sequence of steps:
    it’s obtaining the clipboard contents, cleaning up that text, and then copying
    the cleaned-up text back to the clipboard. As we learned from our earlier chat
    with Copilot, we want Copilot to write code that uses the `paste` and `copy` functions
    of `pyperclip`, and that’s exactly what it’s doing. The second-to-last line of
    the program is something we haven’t seen before in this book:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，程序正在按照正确的步骤顺序执行：它获取剪贴板内容，清理文本，然后将清理后的文本复制回剪贴板。正如我们之前与 Copilot 的对话中学到的那样，我们希望
    Copilot 编写的代码使用 `pyperclip` 的 `paste` 和 `copy` 函数，而它确实是在这么做。程序中的倒数第二行是我们在本书中从未见过的：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can actually remove this line if you like (and if you do, also unindent
    the line below it). It ensures that the `clean_email` function is only called
    when you run your program, not when you import it as a module. After all, if you
    did want to import this as a module (to be used as part of a larger program),
    you would call `clean_email` whenever you needed that functionality, not necessarily
    as soon as the module was imported. (And, in general, whenever you’re interested
    in understanding a line of code more fully, you can ask Copilot about it!) Unfortunately,
    this code doesn’t work. If you run it, you’ll receive this error:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，其实可以删除这一行（如果你删除，也请取消缩进下面的那一行）。它确保 `clean_email` 函数只有在你运行程序时才会被调用，而不是在你作为模块导入时调用。毕竟，如果你确实想将其作为模块导入（作为更大程序的一部分使用），你会在需要该功能时调用
    `clean_email`，而不一定是在模块导入后立即调用。（而且，一般来说，任何时候你想更深入理解一行代码时，都可以向 Copilot 询问！）不幸的是，这段代码不能正常工作。如果你运行它，你会收到以下错误：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The syntax error means that we have a program that isn’t written in valid Python
    code. We’re going to fix this now! We have a couple of options for how to do so.
    One is to highlight your code and ask Copilot Chat to fix the bug. For us, this
    did fix the problem. You could also try asking ChatGPT in conversation: “Propose
    a fix for the bugs in my code <insert your code>.” This is a useful tip to keep
    in mind whenever the code that you get back from Copilot doesn’t work as expected.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误意味着我们的程序并不是有效的 Python 代码。我们现在要修复这个问题！我们有几种方式来解决这个问题。一种是高亮显示你的代码并要求 Copilot
    Chat 修复错误。对我们来说，这确实修复了问题。你也可以尝试向 ChatGPT 提出问题：“为我的代码 `<insert your code>` 提供修复建议。”这是一个有用的技巧，当
    Copilot 返回的代码无法按预期工作时，可以考虑使用。
- en: Copilot fixed the code for us by fixing the line with the syntax error. The
    new code is shown in the following listing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 通过修复语法错误的那一行代码为我们修正了程序。新的代码如下所示。
- en: 'Listing 9.2 Second try: Clean up email text in the clipboard'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2 第二次尝试：清理剪贴板中的电子邮件文本
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#1 Joins the individual lines back into one string'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将各个行重新连接成一个字符串'
- en: The new line of code, changed from the odd line of code that we had previously,
    is
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码行，已经从我们之前那行奇怪的代码改动过来，是
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The goal of this line is to join all the lines of text together into a single
    string that the program will later copy to the clipboard. What does that `\n`
    mean? That represents the start of a newline in code. What is the `join` method?
    It takes all the items in a list (lines) and joins them together into a single
    string.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行的目标是将所有文本行连接成一个单一的字符串，程序稍后会将该字符串复制到剪贴板。`\n` 代表什么？它表示代码中的换行符。`join` 方法是什么？它将列表中的所有项（行）连接成一个单一的字符串。
- en: 'We can understand how this works in more detail by experimenting a little with
    `join`. Here’s an example of using `join` with an empty string rather than the
    `''\n''` string:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过稍微实验一下 `join` 来更详细地了解它是如何工作的。这里是一个使用空字符串而不是 `'\n'` 字符串的 `join` 示例：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Shows the list of three lines'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 显示包含三行的列表'
- en: '#2 Calls join on the empty string'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 在空字符串上调用 `join` 方法'
- en: 'Notice that some of the words are squished together. That’s not exactly what
    we want—we need something between them. How about a space? Let’s try using `join`
    again, this time with a space in the string rather than the empty string:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有些词语被挤在一起了。这并不是我们想要的——我们需要在它们之间加点东西。怎么加一个空格呢？我们再试试使用 `join`，这次在字符串中使用空格，而不是空字符串：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Or, we could use `''*''`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `'*'`：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That fixes our squished words. And, the `*s` tells us where each line ends,
    but it would be nicer to actually maintain the fact that the email is three lines.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了我们紧凑的词语问题。而且，`*s` 告诉我们每行的结尾位置，但如果能够保持邮件是三行的事实就更好了。
- en: 'We need a way in Python to use a line break or newline character, rather than
    a space or `*`. We can’t just press Enter because that would split the string
    over two lines and that isn’t valid Python syntax. The way to do it is by using
    `''\n''`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 Python 中找到一种使用换行符或新行字符的方法，而不是空格或 `*`。我们不能直接按 Enter，因为那样会把字符串分成两行，这不是有效的
    Python 语法。解决方法是使用 `'\n'`：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now our tool is ready to be used. If you copy some messy email text to your
    clipboard, run our program, and paste the clipboard, you’ll see that the email
    has been cleaned up. For example, if we run it on our previous sample email, we
    get the following cleaned-up version:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的工具准备好使用了。如果你把一些杂乱的邮件文本复制到剪贴板，运行我们的程序并粘贴剪贴板，你会看到邮件已经被清理好了。例如，如果我们运行它处理之前的样本邮件，得到的清理后版本如下：
- en: Hi Leo,
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，Leo，
- en: Dan -- any luck with your natural language research?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Dan —— 你的自然语言研究有进展吗？
- en: Yes! That website you showed me
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！你给我看的那个网站
- en: '[https://www.kaggle.com/](https://www.kaggle.com/)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.kaggle.com/](https://www.kaggle.com/)'
- en: is very useful. I found a dataset on there that collects
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 非常有用。我在上面找到了一个数据集，收集了
- en: a lot
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 很多
- en: of questions and answers that might be useful to my research.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 可能对我的研究有用的问答数据集。
- en: Thank you,
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢，
- en: Dan
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Dan
- en: Of course, we could still do more. The line breaks in that email aren’t great
    (the line “a lot” is extremely and needlessly short), and you might want to clean
    that up as well. You could begin to make these kinds of improvements by adding
    new requirements to your prompts to Copilot. We’ll stop here because we’ve accomplished
    our initial goal of email cleanup, but we encourage you to continue exploring
    more robust solutions on your own.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还可以做得更多。那封电子邮件中的换行不太理想（“a lot”这一行非常短且不必要地短），你可能也想把它清理一下。你可以通过在给 Copilot
    的提示中加入新要求，开始进行这些改进。我们在这里停下，因为我们已经完成了初步的邮件清理，但我们鼓励你继续探索更强大的解决方案。
- en: '9.4 Example 2: Adding cover pages to PDF files'
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 示例 2：为 PDF 文件添加封面
- en: Let’s return to the scenario from the start of the chapter. We have written
    100 reports that are in .pdf format. Our colleague has designed 100 covers for
    those reports that are also in .pdf format, and we need to merge the covers with
    the reports so that each finalized .pdf file starts with the cover and continues
    with the report. Figure 9.1 provides an illustration of the desired process.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到本章开始时的场景。我们已经写了 100 份 .pdf 格式的报告。我们的同事为这些报告设计了 100 个封面，封面也是 .pdf 格式的，我们需要将封面和报告合并，使每个最终的
    .pdf 文件都以封面开始，接着是报告内容。图 9.1 提供了所需流程的示意图。
- en: '![figure](../Images/9-1.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/9-1.png)'
- en: Figure 9.1 Illustration of the desired process of creating combined .pdfs by
    merging the report cover in the cover directory with the report in the report’s
    directory. Note that the reports may be more than one page.
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.1 创建合并后的 .pdf 文件的期望过程示意图，方法是将封面目录中的报告封面与报告目录中的报告合并。请注意，报告可能不止一页。
- en: PDF files (and Microsoft Word and Excel files) aren’t text files
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: PDF 文件（以及 Microsoft Word 和 Excel 文件）不是文本文件
- en: You might wonder why we can’t simply use Python methods such as `read` and `write`
    to manipulate .pdf files. After all, that’s just what we did when working with
    .csv files in chapter 2.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么我们不能像操作 .csv 文件那样，直接使用 Python 的 `read` 和 `write` 方法来处理 .pdf 文件呢？毕竟，在第
    2 章处理 .csv 文件时我们就是这么做的。
- en: 'The big difference is that .csv files are text files, which are files readable
    by humans with no formatting or special commands. However, many other file formats
    aren’t text files. A .pdf file, for example, isn’t human-readable and needs to
    be processed by code that is aware of the .pdf format. This is true of Microsoft
    Word files and Microsoft Excel files as well: they’re not text files, so we need
    specialized tools to work with them.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的区别在于.csv文件是文本文件，这些文件是人类可读的，不带格式或特殊命令。然而，许多其他文件格式不是文本文件。例如，.pdf文件不是人类可读的，需要通过理解.pdf格式的代码来处理。Microsoft
    Word文件和Microsoft Excel文件也是如此：它们不是文本文件，所以我们需要专门的工具来处理它们。
- en: 'In the resources for this book, in the ch9 folder, you’ll find two subfolders:
    the reports subfolder contains 100 reports as .pdf files, and the covers subfolder
    contains 100 covers as .pdf files, one for each report. The reports are named
    1.pdf, 2.pdf, 3.pdf, and so on; the respective covers are named cover1.pdf, cover2.pdf,
    cover3.pdf, and so on. We’ll merge these reports and covers together in this section.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的资源中，在ch9文件夹内，你会找到两个子文件夹：报告子文件夹包含100个报告，格式为.pdf文件，封面子文件夹包含100个封面，格式为.pdf文件，每个报告都有一个封面。报告的命名方式为1.pdf、2.pdf、3.pdf，依此类推；对应的封面命名为cover1.pdf、cover2.pdf、cover3.pdf，依此类推。我们将在本节中将这些报告和封面合并在一起。
- en: Open some of the cover .pdf files and some of the report .pdf files. You can
    do that using a program such as Adobe Acrobat or however you typically open .pdf
    files on your computer. You’ll notice that the covers are always exactly one page,
    but the reports can be more than one page. When we get to the code, we should
    take care to tell Copilot that reports can be more than one page; otherwise, Copilot
    might write code assuming that the reports, like the covers, are only one page.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一些封面.pdf文件和一些报告.pdf文件。你可以使用Adobe Acrobat等程序，或者用你通常在电脑上打开.pdf文件的方法。你会注意到封面总是恰好一页，而报告可能不止一页。当我们编写代码时，我们应该注意告诉Copilot，报告可能有多页；否则，Copilot可能会假设报告像封面一样只有一页。
- en: You might be wondering how we created these 100 covers and reports. You’d be
    disappointed if we made them manually, one at a time, right? Don’t worry. We automated
    that creation process in much the same way we’ll automate the merging process
    next.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道我们是如何创建这些100个封面和报告的。如果我们是手动制作它们，一次一个，你一定会感到失望，对吧？别担心，我们自动化了这个创建过程，就像我们接下来将自动化合并过程一样。
- en: 9.4.1 Conversing with Copilot
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 与Copilot对话
- en: We need our tool to find all reports and covers, add the cover to the front
    of each report, and produce a finalized .pdf for each report that contains both
    the cover page and report pages. How do we merge .pdf files using Python? Let’s
    find out.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要我们的工具来找到所有报告和封面，将封面添加到每个报告的前面，并生成一个包含封面和报告页面的最终.pdf文件。我们如何使用Python合并.pdf文件呢？让我们来看看。
- en: LPHumanI need to write a **Python program that merges .pdf files. How do I do
    this?**
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我需要编写一个**合并.pdf文件的Python程序。我该怎么做？**
- en: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the PyPDF2 library
    to merge PDF files in Python. Here is an example code snippet that shows how to
    merge two PDF files:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot 你可以使用PyPDF2库在Python中合并PDF文件。下面是一个示例代码片段，展示了如何合并两个PDF文件：'
- en: '[PRE26]`*[PRE27]`*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE26]`*[PRE27]`*'
- en: '*`*import PyPDF2*`*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import PyPDF2*`*'
- en: '*`*# Open the PDF files to be merged*`*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 打开需要合并的PDF文件*`*'
- en: '*`*pdf1 = open(''file1.pdf'', ''rb'')*`*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf1 = open(''file1.pdf'', ''rb'')*`*'
- en: '*`*pdf2 = open(''file2.pdf'', ''rb'')*`*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf2 = open(''file2.pdf'', ''rb'')*`*'
- en: '*`*# Create a PDF reader object for each file*`*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 为每个文件创建一个PDF读取对象*`*'
- en: '*`*reader1 = PyPDF2.PdfFileReader(pdf1)*`*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*reader1 = PyPDF2.PdfFileReader(pdf1)*`*'
- en: '*`*reader2 = PyPDF2.PdfFileReader(pdf2)*`*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*reader2 = PyPDF2.PdfFileReader(pdf2)*`*'
- en: '*`*# Create a PDF writer object*`*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 创建一个PDF写入对象*`*'
- en: '*`*writer = PyPDF2.PdfFileWriter()*`*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*writer = PyPDF2.PdfFileWriter()*`*'
- en: '*`*# Loop through the pages of each PDF and add them to the writer object*`*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 循环遍历每个PDF的页面并将它们添加到写入对象*`*'
- en: '*`*for i in range(reader1.getNumPages()):*`*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*for i in range(reader1.getNumPages()):*`*'
- en: '*`*page = reader1.getPage(i)*`*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*page = reader1.getPage(i)*`*'
- en: '*`*writer.addPage(page)*`*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*writer.addPage(page)*`*'
- en: '*`*for i in range(reader2.getNumPages()):*`*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*for i in range(reader2.getNumPages()):*`*'
- en: '*`*page = reader2.getPage(i)*`*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*page = reader2.getPage(i)*`*'
- en: '*`*writer.addPage(page)*`*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*writer.addPage(page)*`*'
- en: '*`*# Write the merged PDF to a file*`*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 将合并后的PDF写入文件*`*'
- en: '*`*output = open(''merged.pdf'', ''wb'')*`*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*output = open(''merged.pdf'', ''wb'')*`*'
- en: '*`*writer.write(output)*`*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*writer.write(output)*`*'
- en: '*`*# Close the input and output files*`*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 关闭输入和输出文件*`*'
- en: '*`*pdf1.close()*`*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf1.close()*`*'
- en: '*`*pdf2.close()*`*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf2.close()*`*'
- en: '*`*output.close()*`*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*output.close()*`*'
- en: '*[PRE28]*[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE28]*[PRE29]'
- en: In this example, we first open the two PDF files to be merged using the `open()`
    function. We then create a PDF reader object for each file using the `PdfFileReader()`
    function from PyPDF2.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先使用 `open()` 函数打开要合并的两个 PDF 文件。然后，我们使用 PyPDF2 中的 `PdfFileReader()`
    函数为每个文件创建一个 PDF 阅读器对象。
- en: Next, we create a PDF writer object using the `PdfFileWriter()` function. We
    then loop through the pages of each PDF file using the `getNumPages()` and `getPage()`
    methods of the reader objects and add each page to the writer object using the
    `addPage()` method.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `PdfFileWriter()` 函数创建一个 PDF 写入对象。然后，我们通过每个 PDF 文件的页面，使用阅读器对象的 `getNumPages()`
    和 `getPage()` 方法，并使用 `addPage()` 方法将每一页添加到写入对象中。
- en: Finally, we write the merged PDF to a file using the `write()` method of the
    writer object and close all the input and output files using the `close()` method.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用写入对象的 `write()` 方法将合并后的 PDF 写入文件，并使用 `close()` 方法关闭所有输入和输出文件。
- en: We have a lead! This PyPDF2 module seems to do what we need. It looks like it
    gives us `PdfFileReader` to read an existing .pdf file and `PdfFileWriter` to
    create a new .pdf file. We see the code using `getPage` to get a page from an
    existing .pdf file and `addPage` to write it to the new .pdf file—very promising.
    Is there something built-in to Python that we could use, so that we don’t have
    to worry about installing PyPDF2?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了线索！这个 PyPDF2 模块似乎做到了我们需要的功能。它看起来提供了 `PdfFileReader` 来读取现有的 .pdf 文件和 `PdfFileWriter`
    来创建新的 .pdf 文件。我们看到代码使用 `getPage` 从现有的 .pdf 文件中获取页面，并用 `addPage` 将其写入新 .pdf 文件——非常有前景。有没有什么
    Python 内置的功能可以使用，这样我们就不必担心安装 PyPDF2？
- en: LPHumanIs there a way I can do it without having to install a Python module?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman 是否有方法不需要安装 Python 模块就能做到这一点？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, you can use the subprocess
    module to call a command-line tool like `pdftk` to merge PDF files. Here is an
    example code snippet that shows how to merge two PDF files using `pdftk`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 是的，你可以使用 subprocess 模块来调用像
    `pdftk` 这样的命令行工具来合并 PDF 文件。下面是一个示例代码片段，展示如何使用 `pdftk` 合并两个 PDF 文件：'
- en: '[PRE30]`*[PRE31]`*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]`*[PRE31]`*'
- en: '*`*import subprocess*`*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import subprocess*`*'
- en: '*`*# Call pdftk to merge the PDF files*`*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 调用 pdftk 合并 PDF 文件*`*'
- en: '*`*subprocess.call([''pdftk'', ''file1.pdf'', ''file2.pdf'',*`*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*subprocess.call([''pdftk'', ''file1.pdf'', ''file2.pdf'',*`*'
- en: '*`*''cat'', ''output'', ''merged.pdf''])*`*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*''cat'', ''output'', ''merged.pdf''])*`*'
- en: '*[PRE32]*[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE32]*[PRE33]'
- en: In this example, we use the `subprocess.call()` function to call `pdftk` with
    the appropriate arguments to merge the two PDF files `file1.pdf` and `file2.pdf`.
    The `cat` argument tells `pdftk` to concatenate the input files, and the `output`
    argument specifies the output file name as `merged.pdf`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用 `subprocess.call()` 函数来调用 `pdftk`，并传递适当的参数以合并两个 PDF 文件 `file1.pdf`
    和 `file2.pdf`。`cat` 参数告诉 `pdftk` 连接输入文件，而 `output` 参数指定输出文件名为 `merged.pdf`。
- en: 'Note that you will need to have `pdftk` installed on your system for this code
    to work. If you don’t have `pdftk` installed, you can download it from the official
    website: [https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/](https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你需要在系统中安装 `pdftk` 才能使这段代码正常工作。如果你没有安装 `pdftk`，可以从官方网站下载：[https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/](https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/)。
- en: This approach may ultimately end up being valuable, but it’s not exactly a built-in
    solution. After all, the final paragraph talks about us having to install some
    new software called `pdftk`!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能最终会有价值，但它并不是一个内置的解决方案。毕竟，最后一段提到我们需要安装一个叫做 `pdftk` 的新软件！
- en: At this point, we’d probably go with the first option of using PyPDF2\. But
    let’s press forward once more with Copilot to make sure we don’t miss any good
    options.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可能会选择使用 PyPDF2 的第一种选项。但让我们继续使用 Copilot，以确保不会错过任何好的选择。
- en: LPHumanAre there other Python .pdf libraries that I should consider?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman 是否有其他 Python 的 PDF 库我应该考虑使用？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, there are several other
    Python libraries that you can use to work with PDF files. Here are some popular
    ones:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 是的，确实有几个其他的 Python 库可以用来处理
    PDF 文件。以下是一些流行的库：'
- en: ReportLab—a library for creating PDF documents from scratch, with support for
    text, graphics, and images.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ReportLab——一个用于从零开始创建 PDF 文档的库，支持文本、图形和图片。
- en: FPDF—a library for creating PDF documents from scratch, with support for text,
    graphics, and images.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FPDF——一个用于从零开始创建 PDF 文档的库，支持文本、图形和图片。
- en: PDFMiner—a library for extracting text and metadata from PDF files.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PDFMiner——一个用于从 PDF 文件中提取文本和元数据的库。
- en: PyMuPDF—a library for working with PDF files, with support for text, graphics,
    and images.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyMuPDF——一个用于处理PDF文件的库，支持文本、图形和图像。
- en: pdfrw—a library for reading and writing PDF files, with support for text, graphics,
    and images.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: pdfrw——一个用于读取和写入PDF文件的库，支持文本、图形和图像。
- en: Each library has its own strengths and weaknesses, so you should choose the
    one that best fits your needs. If you only need to merge PDF files, then PyPDF2
    or pdftk may be sufficient. However, if you need to create or manipulate PDF files
    in more complex ways, then one of the other libraries may be a better choice.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每个库都有其优缺点，因此你应选择最适合自己需求的库。如果你只需要合并PDF文件，那么PyPDF2或pdftk可能就足够了。然而，如果你需要更复杂地创建或操作PDF文件，那么其他一些库可能会是更好的选择。
- en: The last paragraph tells us that we’re probably in good shape using PyPDF2 if
    all we need to do is merge .pdf files. But let’s finish our conversation here
    by understanding the pros and cons of all of these tools. That way, if we get
    stuck with PyPDF2, we know where to turn to next.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段告诉我们，如果我们只需要合并.pdf文件，使用PyPDF2可能已经足够了。但是，让我们通过了解所有这些工具的优缺点来结束这个对话。这样，如果我们在使用PyPDF2时遇到问题，就能知道接下来该去哪里寻求帮助。
- en: LPHumanCan you summarize the **strengths and weaknesses of these libraries?**
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman能总结一下这些库的**优缺点**吗？
- en: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot Certainly! Here is a summary
    of the strengths and weaknesses of the libraries I mentioned:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot 当然！以下是我提到的这些库的优缺点总结：'
- en: PyPDF2—a library for working with PDF files, with support for text, graphics,
    and images.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: PyPDF2——一个用于处理PDF文件的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Easy to use for simple tasks like merging PDF files.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于简单任务（如合并PDF文件）时易于使用。
- en: Good documentation and examples available.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: Supports a wide range of PDF features.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: 'Weaknesses:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Limited support for advanced PDF features like forms and annotations.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对像表单和注释这样的高级PDF功能支持有限。
- en: Can be slow for large PDF files.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于大型PDF文件可能较慢。
- en: ReportLab—a library for creating PDF documents from scratch, with support for
    text, graphics, and images.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ReportLab——一个用于从头创建PDF文档的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Very powerful and flexible for creating complex PDF documents.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建复杂PDF文档时非常强大和灵活。
- en: Supports a wide range of PDF features.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: Good documentation and examples available.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: 'Weaknesses:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Steep learning curve for beginners.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对初学者来说有较高的学习曲线。
- en: Can be slow for large PDF files.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于大型PDF文件可能较慢。
- en: FPDF—a library for creating PDF documents from scratch, with support for text,
    graphics, and images.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: FPDF——一个用于从头创建PDF文档的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Lightweight and easy to use.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轻量且易于使用。
- en: Good documentation and examples available.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: Supports a wide range of PDF features.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: 'Weaknesses:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Limited support for advanced PDF features like forms and annotations.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对像表单和注释这样的高级PDF功能支持有限。
- en: Can be slow for large PDF files.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于大型PDF文件可能较慢。
- en: PDFMiner—a library for extracting text and metadata from PDF files.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: PDFMiner——一个用于从PDF文件中提取文本和元数据的库。
- en: 'Strengths:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Very powerful and flexible for extracting text and metadata from PDF files.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从PDF文件中提取文本和元数据时非常强大和灵活。
- en: Supports a wide range of PDF features.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: Good documentation and examples available.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: 'Weaknesses:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Steep learning curve for beginners.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对初学者来说有较高的学习曲线。
- en: Limited support for creating or manipulating PDF files.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对创建或操作PDF文件的支持有限。
- en: PyMuPDF—a library for working with PDF files, with support for text, graphics,
    and images.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: PyMuPDF——一个用于处理PDF文件的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Very fast and efficient for working with PDF files.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理PDF文件时非常快速高效。
- en: Supports a wide range of PDF features.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: Good documentation and examples available.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: 'Weaknesses:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Steep learning curve for beginners.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对初学者来说有较高的学习曲线。
- en: Limited support for creating or manipulating PDF files.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对创建或操作PDF文件的支持有限。
- en: pdfrw—a library for reading and writing PDF files, with support for text, graphics,
    and images.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: pdfrw——一个用于读取和写入PDF文件的库，支持文本、图形和图像。
- en: 'Strengths:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Very powerful and flexible for reading and writing PDF files.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在读取和写入PDF文件时非常强大和灵活。
- en: Supports a wide range of PDF features.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支持广泛的PDF功能。
- en: Good documentation and examples available.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供良好的文档和示例。
- en: 'Weaknesses:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Steep learning curve for beginners.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初学者面临陡峭的学习曲线。
- en: Can be slow for large PDF files.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理大型 PDF 文件时可能会比较慢。
- en: Don’t be too intimidated by the “Steep learning curve for beginners” cautions
    in there. If Copilot has been trained on the library, then you may still be successful.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被其中的“初学者陡峭的学习曲线”警告吓到。如果 Copilot 已经对这个库进行了训练，那么你仍然可能会成功。
- en: Based on what we’ve learned here, we might eliminate PDFMiner because it apparently
    has “limited support for creating or manipulating PDF files,” but we’d keep all
    others in contention just in case we need them. For now, we’re going to proceed
    with PyPDF2 and see how it goes.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在这里学到的内容，我们可能会去掉 PDFMiner，因为它显然“对创建或操作 PDF 文件的支持有限”，但我们会保留其他所有库，以防我们需要它们。目前，我们将继续使用
    PyPDF2，看看效果如何。
- en: 9.4.2 Writing the tool
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 编写工具
- en: 'Go ahead and install the PyPDF2 module. Be careful with the capitalization:
    the module is called exactly PyPDF2, not pypdf2, pyPDF2, or any other capitalization.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续安装 PyPDF2 模块。注意大小写：这个模块叫做 PyPDF2，而不是 pypdf2、pyPDF2 或其他任何大小写形式。
- en: 'In our previous example, we wrote a function to clean up an email that was
    on the clipboard. We didn’t need to pass any information to that function, so
    the function had no parameters. Here, our function will need three parameters:
    the name of the directory with the reports, the name of the directory with the
    covers, and the name of the directory where we want to write our finalized (merged)
    .pdf files.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们编写了一个函数来清理剪贴板上的电子邮件。我们不需要向那个函数传递任何信息，因此函数没有参数。在这里，我们的函数需要三个参数：包含报告的目录名、包含封面的目录名，以及我们希望写入最终（合并）.pdf
    文件的目录名。
- en: In our docstring, we need to explain what each of these directories is for and
    also the pattern of the filenames in the directories. After all, Copilot will
    need to know how the reports match up with the cover pages.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文档字符串中，我们需要解释这些目录的用途，以及目录中文件名的模式。毕竟，Copilot 需要知道报告是如何与封面页匹配的。
- en: Trying PyPDF2
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尝试 PyPDF2
- en: We’re going to use the PyPDF2 Python library to try to get the job done. Look
    back to what Copilot Chat told us about the PyPDF2 library. The sample code it
    gave us used `PdfFileReader` to read existing .pdf files and `PdfFileWriter` to
    create a new .pdf file. It also used `getPage` and `addPage` to manipulate pages.
    Look out for these in the code that Copilot produces—they’re telltale signs that
    Copilot is generating code that’s on the right track. Here’s the prompt that we
    used and the code that Copilot gave us.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 PyPDF2 Python 库来尝试完成这个任务。回顾一下 Copilot Chat 告诉我们的关于 PyPDF2 库的信息。它提供的示例代码使用了
    `PdfFileReader` 来读取现有的 .pdf 文件，并使用 `PdfFileWriter` 创建一个新的 .pdf 文件。它还使用了 `getPage`
    和 `addPage` 来操作页面。注意这些代码，它们是 Copilot 正在生成正确代码的标志。下面是我们使用的提示和 Copilot 给我们的代码。
- en: Listing 9.3 Function to add covers to .pdf documents
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3 添加封面到 .pdf 文档的函数
- en: '[PRE34]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '#1 Gets list of the .pdf reports'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 获取 .pdf 报告的列表'
- en: '#2 Loops through the .pdf reports'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 遍历 .pdf 报告'
- en: '#3 We can use report_reader to read the pages of the report.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 我们可以使用 report_reader 来读取报告的页面。'
- en: '#4 We can use report_writer to write pages into a new .pdf file'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 我们可以使用 report_writer 将页面写入新的 .pdf 文件'
- en: '#5 Loops through each page of the report'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 遍历报告的每一页'
- en: '#6 Adds the page to our new .pdf file'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 将页面添加到我们的新 .pdf 文件中'
- en: '#7 Opens the cover associated with this report'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 打开与该报告相关的封面'
- en: '#8 We can use cover_reader to read the cover.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 我们可以使用 cover_reader 来读取封面。'
- en: '#9 Adds the cover to the start of our new .pdf file'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '#9 将封面添加到我们新 .pdf 文件的开头'
- en: '#10 Saves our new .pdf file'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '#10 保存我们的新 .pdf 文件'
- en: '#11 Calls our function to do all the merging!'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '#11 调用我们的函数来完成所有合并！'
- en: Be careful with automation programs
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小心自动化程序
- en: Programs like the one we’ve written to merge .pdf files can rip through hundreds
    or thousands of files very quickly. If they aren’t operating correctly, they can
    easily result in damaged or lost files. Any time we use `open` with `'w'` or `'wb'`
    as the second parameter, it means that we’re overwriting a file.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的像合并 .pdf 文件这样的程序，可以非常快速地处理成百上千个文件。如果它们没有正确运行，可能会导致文件损坏或丢失。每当我们使用`open`并且将`'w'`或`'wb'`作为第二个参数时，就意味着我们正在覆盖一个文件。
- en: 'Let’s focus on this line from our program in listing 9.3:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注我们程序中第 9.3 列表中的这一行：
- en: '[PRE35]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It’s using the `open` function to open a file. Specifically, it’s opening the
    current `report_file` file in the `final_dir` directory. The second argument to
    `open` here, `'wb'`, means that we want to open the file so we can write to it
    (that’s the `'w'`) and that the file we’re writing is a binary file (that’s the
    `'b'`), not a text file. If the file doesn’t already exist, then the `'w'` we’ve
    included will result in the file being created. That’s not the dangerous part.
    The dangerous part is what happens when the file already exists. In that case,
    `'w'` wipes out its contents and gives us an empty file that we can start writing
    to. Now, if our program is working correctly and only doing this in our `final_dir`,
    then we’re OK. But this is what we need to carefully verify before letting our
    program loose.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`open`函数打开一个文件。具体来说，它在`final_dir`目录中打开当前的`report_file`文件。`open`函数的第二个参数`'wb'`表示我们想以写入模式（`'w'`）打开文件，并且文件是二进制文件（`'b'`），而不是文本文件。如果文件不存在，`'w'`会导致文件被创建。那并不是危险的部分。危险的部分在于，当文件已经存在时，`'w'`会清空文件的内容，给我们一个空文件来开始写入。现在，如果我们的程序正常工作并且只在`final_dir`中进行此操作，那么我们是安全的。但是这正是我们在放开程序之前需要仔细验证的部分。
- en: 'We highly recommend that you first test on a small directory of files that
    you don’t care about. Further, we recommend changing lines of code that open files
    using `''w''` or `''wb''` to print a harmless output message instead, so that
    you can see exactly which files are going to be overwritten or created. For example,
    in our program here, we need to comment out these two lines:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您首先在一个不重要的小文件目录中进行测试。此外，我们建议将打开文件的代码行（使用`'w'`或`'wb'`）改为打印一个无害的输出消息，这样您就能清楚地看到哪些文件将被覆盖或创建。例如，在我们的程序中，我们需要注释掉以下两行：
- en: '[PRE36]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Instead, we’ll use `print` to print out the file that we would have created
    or overwritten:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用`print`来打印出本来会被创建或覆盖的文件。
- en: '[PRE37]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Then, when you run your program, you’ll see the names of files that the program
    *intended* to write. If the output looks good—that is, the program is operating
    exactly on the files that you wanted it to operate on—then you can uncomment the
    code that actually does the work.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当您运行程序时，您会看到程序*计划*写入的文件名。如果输出看起来正常——也就是说，程序正好作用于您想要它作用的文件——那么您就可以取消注释实际执行操作的代码。
- en: Exercise caution, and *always* keep backups of your important files!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 请小心，并*始终*保留重要文件的备份！
- en: The last line of the program in listing 9.3 makes the assumption that the directory
    of reports is called `reports`, the directory of cover pages is called `covers`,
    and the directory where the final .pdf files should go is called `final`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9.3 中程序的最后一行假设报告目录叫做`reports`，封面目录叫做`covers`，最终的.pdf文件应该存放在`final`目录中。
- en: Now, create the `final` directory. It should be there along with your `reports`
    and `covers` directories.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建`final`目录。它应该和`reports`、`covers`目录一起存在。
- en: 'The overall structure of the code looks promising to us: it’s getting a list
    of the .pdf reports, and then, for each one, it’s merging those pages with the
    cover page. It’s using a `for` loop to loop through the pages of the report, which
    is good because it can grab all the pages that way. By contrast, it’s *not* using
    a `for` loop on the cover .pdf file, which again is good because we know that
    the cover has only one page anyway.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的整体结构对我们来说看起来很有前景：它获取了一份.pdf报告的列表，然后对于每一份报告，它将这些页面与封面页合并。它使用`for`循环遍历报告的各个页面，这是一个不错的做法，因为这样可以抓取所有的页面。相比之下，它*没有*对封面.pdf文件使用`for`循环，这也是正确的做法，因为我们知道封面只有一页。
- en: 'However, the first line of code it gave us looks like it’s using a function
    called `listdir` in a module called os. There are other lines that use this module
    as well. Do we need to be importing that os module? Indeed, we do! And we can
    prove it by running the code. If you run the code, you’ll get an error:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它给我们的第一行代码看起来是使用了一个名为`listdir`的函数，它位于一个名为os的模块中。还有其他几行代码也使用了这个模块。我们需要导入这个os模块吗？确实需要！我们可以通过运行代码来证明这一点。如果您运行代码，您会得到一个错误：
- en: '[PRE38]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We need to add `import os` at the start of our program to fix this. The updated
    code is in the following listing.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在程序开头添加`import os`来修复这个问题。更新后的代码如下。
- en: Listing 9.4 Improved function to add covers to .pdf documents
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 9.4 改进后的函数，用于将封面添加到.pdf文档
- en: '[PRE39]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '#1 We were missing this import before.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们之前缺少了这个导入。'
- en: 'We’re not out of the woods yet, though. Our updated program still doesn’t work.
    Here’s the error we get when we run our program:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们仍然未能摆脱困境。当我们运行我们的程序时，我们得到以下错误：
- en: '[PRE40]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '#1 The line in our code that’s causing an error'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 在我们的代码中，导致错误的那一行'
- en: '#2 We can’t use PdfFileReader anymore—it’s gone!'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们不能再使用 PdfFileReader 了 —— 它已经消失了！'
- en: 'We’ve run into the problem where Copilot thinks, “Hey, let’s use `PdfFileReader`,
    since I’ve been trained that this is part of PyPDF2,” but between Copilot being
    trained and the time of our writing, the PyPDF2 maintainers have removed `PdfFileReader`
    and replaced it with something else (`PdfReader`, according to the final line
    of the error message). This discrepancy may very well be fixed for you by the
    time you read this book, but we want to pretend it’s still messed up so that we
    can teach you what to do if this does happen to you in the future. At this point,
    we have three options:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了一个问题，Copilot 认为：“嘿，让我们使用 `PdfFileReader`，因为我被训练过这是 PyPDF2 的一部分”，但在 Copilot
    受训和我们写作的时间之间，PyPDF2 的维护者已经移除了 `PdfFileReader`，并用其他东西替换了它（根据错误消息的最后一行，应该是 `PdfReader`）。如果你读到这本书的时候，这个差异可能已经被修复了，但我们希望假装它仍然混乱，这样我们就可以教你如果未来发生这种情况时应该怎么做。此时，我们有三个选择：
- en: '*Install an earlier version of PyPDF2.* The last two lines of the error message
    tell us that `PdfFileReader`, the function we need from PyPDF2, was removed in
    PyPDF2 3.0.0\. As a result, if we install a version of PyPDF2 earlier than 3.0.0,
    we should have our function back. In general, installing earlier versions of libraries
    isn’t advisable because security concerns may be present in those versions that
    have since been fixed in more recent versions. In addition, there may be bugs
    present in the older versions that have since been fixed. It’s worth googling
    what has been changed in the library recently to determine whether using an older
    version is safe. In this case, we have done that homework and see no obvious risk
    in using an older version of PyPDF2\.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安装 PyPDF2 的早期版本。* 错误消息的最后两行告诉我们，我们从 PyPDF2 需要的函数 `PdfFileReader` 已在 PyPDF2
    3.0.0 中被移除。因此，如果我们安装比 3.0.0 早的版本，我们应该可以恢复我们的功能。一般来说，安装库的早期版本并不建议，因为安全问题可能存在于那些后来在更近期版本中修复的版本中。此外，旧版本可能存在已经在较新版本中修复的
    bug。值得 Google 一下最近库中的变化，以确定使用旧版本是否安全。在这种情况下，我们已经做了这项工作，看不出使用 PyPDF2 的旧版本存在明显风险。'
- en: '*Fix the code ourselves using the suggestion in the error message.* That is,
    we would replace `PdfFileReader` with `PdfReader` and run the program again. In
    this case, we would be told about other deprecations, and we’d need to fix those
    following the same process. It’s very nice of the authors of PyPDF2 to tell us
    what to do inside the error messages. For practice, you might like to work through
    this, making each update suggested by the error message. We wish all error messages
    were so useful, but this won’t always be the case. Sometimes, a function will
    be removed without giving us any recourse. In that case, it may be easier to consider
    our next option.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*按照错误消息中的建议自行修复代码。* 也就是说，我们会将 `PdfFileReader` 替换为 `PdfReader` 并再次运行程序。在这种情况下，我们将被告知其他已弃用的内容，我们需要按照相同的过程进行修复。PyPDF2
    的作者告诉我们如何在错误消息中做这些更新，这非常好。为了练习，你可能会喜欢按照错误消息建议的每次更新来进行。我们希望所有错误消息都这么有用，但情况并非总是如此。有时，一个函数将被移除而我们没有任何后路。在这种情况下，考虑下一步可能会更容易。'
- en: '*Use a different library.* Earlier, we asked Copilot for other possible .pdf
    Python libraries we could use, and we received many suggestions. If the first
    two of our options here aren’t satisfactory, we could jump to trying one of those.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用不同的库。* 之前，我们向 Copilot 请求了其他可能的 .pdf Python 库的建议，我们收到了许多建议。如果这里的前两个选项不令人满意，我们可以尝试其中之一。'
- en: We’re going to illustrate how to solve the problem and get our code running
    with the first option (using an earlier version of PyPDF2) and the third option
    (using a different library entirely).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将说明如何通过第一选项（使用 PyPDF2 的早期版本）和第三选项（完全使用不同的库）来解决问题并使我们的代码运行。
- en: Using an earlier version of PyPDF2
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 PyPDF2 的早期版本
- en: When using `pip install` to install a Python library, by default, we get the
    most current version of the library. That’s usually what we want—the latest and
    greatest—but it’s also possible to explicitly request an older version of the
    library.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `pip install` 安装 Python 库时，默认情况下会获取库的最新版本。通常这是我们想要的——最新和最好的——但也可以显式请求库的旧版本。
- en: Here, we need a version of PyPDF2 prior to version 3.0.0\. Rather than the standard
    usage of pip,
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们需要一个 PyPDF2 版本低于 3.0.0 的版本。与标准的 pip 使用方法不同，
- en: '[PRE41]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: we can instead use
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改用
- en: '[PRE42]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `< 3.0.0` is what we use to ask for the most recent version of the library
    that’s less than version 3.0.0\. The command should result in output like the
    following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`< 3.0.0` 是我们用来请求版本小于 3.0.0 的库的命令。执行此命令时，应该会输出类似以下内容：'
- en: '[PRE43]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '#1 We had an existing version that is &gt;= 3.0.0.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们曾有一个版本 &gt;= 3.0.0 的版本。'
- en: '#2 That version is being removed . . .'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 正在移除该版本……'
- en: '#3 . . . and version 2.12.1 is being installed.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 ……并且正在安装版本 2.12.1。'
- en: 'Now we have an older version of PyPDF2 installed. At this point, you should
    be able to run our program. It’ll take a few seconds, and then the job will be
    done. You can check your final directory for the newly created .pdf files. Open
    a few of them to make sure that our program has done the right thing: each .pdf
    file should start with a cover page and contain all the pages of the report (not
    just the first page if the report has multiple pages).'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们安装了旧版本的 PyPDF2。此时，你应该能够运行我们的程序。它只需要几秒钟，任务就完成了。你可以检查最终目录，找到新创建的 .pdf 文件。打开其中几个文件，确保程序已经正确处理：每个
    .pdf 文件应该以封面页开始，并包含报告的所有页面（如果报告有多页，不只是第一页）。
- en: Think of how tedious this would have been by hand, and we’ve gotten the computer
    to do it for us. Moreover, the next time we have to do the same thing at work
    (more reports for more people), we’ve got a tool all set to help us get it done
    quickly.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 想想手动做这件事会多么繁琐，而现在我们已经让计算机为我们完成了这项工作。而且，下次我们需要做同样的事情（更多的报告给更多的人）时，我们已经有了一个工具，可以帮助我们快速完成任务。
- en: Using a different .pdf library
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用不同的 .pdf 库
- en: Now let’s try solving our problem with PyPDF2 by using another library—one of
    those that Copilot told us about in our initial conversation about .pdf libraries.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们试着用 PyPDF2 来解决问题，使用另一个库——其中一个是 Copilot 在我们关于 .pdf 库的初始对话中提到的。
- en: 'We won’t go through all the gory details with you on how we decided which library
    to try next, but we’ll walk through the highlights of our journey. We started
    by asking Copilot Chat how we can use the ReportLab Python module to merge .pdf
    files, but that redirected us back to using PyPDF2\. We received the same response
    for FPDF: we were told that FPDF can’t merge .pdf files but that PyPDF2 can. We
    then moved on to asking about PyMuPDF, and this part of the conversation was productive:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会向你详细说明我们如何决定尝试哪个库，但我们会简要回顾我们旅程的亮点。我们首先向 Copilot Chat 询问如何使用 ReportLab Python
    模块来合并 .pdf 文件，但这将我们引导回使用 PyPDF2。对于 FPDF，我们得到了相同的回应：我们被告知 FPDF 无法合并 .pdf 文件，但 PyPDF2
    可以。然后我们转向询问 PyMuPDF，并且这部分对话很有成效：
- en: LPHumanHow can I use the Python PyMuPDF library to merge .pdf files?
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman如何使用 Python 的 PyMuPDF 库合并 .pdf 文件？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the fitz module
    from the PyMuPDF library to merge PDF files. Here’s an example code snippet that
    shows how to merge two PDF files using PyMuPDF:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 你可以使用 PyMuPDF 库中的 fitz 模块来合并
    PDF 文件。以下是一个示例代码片段，展示了如何使用 PyMuPDF 合并两个 PDF 文件：'
- en: '[PRE44]`*[PRE45]`*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE44]`*[PRE45]`*'
- en: '*`*import fitz*`*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import fitz*`*'
- en: '*`*# Merge the two PDF files*`*'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 合并两个 PDF 文件*`*'
- en: '*`*pdf_files = [''file1.pdf'', ''file2.pdf'']*`*'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf_files = [''file1.pdf'', ''file2.pdf'']*`*'
- en: '*`*pdf_writer = fitz.Document()*`*'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf_writer = fitz.Document()*`*'
- en: '*`*for pdf_file in pdf_files:*`*'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*for pdf_file in pdf_files:*`*'
- en: '*`*pdf_reader = fitz.open(pdf_file)*`*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf_reader = fitz.open(pdf_file)*`*'
- en: '*`*for page in pdf_reader:*`*'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*for page in pdf_reader:*`*'
- en: '*`*pdf_writer.insert_pdf(page)*`*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf_writer.insert_pdf(page)*`*'
- en: '*`*pdf_writer.save(''merged.pdf'')*`*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf_writer.save(''merged.pdf'')*`*'
- en: '*`*pdf_writer.close()*`*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*pdf_writer.close()*`*'
- en: '*[PRE46]*[PRE47]'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE46]*[PRE47]'
- en: This code first creates a list of PDF files to merge (`file1.pdf` and `file2.pdf`).
    It then creates a new `Document` object using `fitz`, which represents the merged
    PDF. It loops through each PDF file in the list, opens it using `fitz`, and inserts
    each page of the PDF file into the `pdf_writer` object using the `insert_pdf()`
    method. Finally, it saves the merged PDF to a new file called `merged.pdf` using
    the `save()` method.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先创建一个要合并的 PDF 文件列表（`file1.pdf` 和 `file2.pdf`）。然后它使用 `fitz` 创建一个新的 `Document`
    对象，代表合并后的 PDF。它遍历列表中的每个 PDF 文件，使用 `fitz` 打开，并通过 `insert_pdf()` 方法将每一页 PDF 文件插入到
    `pdf_writer` 对象中。最后，使用 `save()` 方法将合并后的 PDF 保存到一个名为 `merged.pdf` 的新文件中。
- en: You can modify this code to add any additional content to the merged PDF using
    PyMuPDF. Just create a new `Page` object, add the content to the page, and insert
    the page into the `pdf_writer` object using the `insert_page()` method.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以修改此代码，以使用 PyMuPDF 向合并的 PDF 中添加任何额外的内容。只需创建一个新的 `Page` 对象，将内容添加到页面中，然后使用 `insert_page()`
    方法将该页面插入到 `pdf_writer` 对象中。
- en: The sample code here is using `insert_pdf` to add each .pdf file to the merged
    .pdf file. We should be on the lookout for our code using `insert_pdf` as well.
    The library is called PyMuPDF, so we need to install it with
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的示例代码使用`insert_pdf`将每个 .pdf 文件添加到合并后的 .pdf 文件中。我们也应该关注我们的代码是否使用了`insert_pdf`。这个库叫做
    PyMuPDF，因此我们需要通过以下方式安装它：
- en: '[PRE48]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: But then we have to use `import fitz`? Why `import fitz` and not `import PyMuPDF`?
    Apparently, the designers of this library liked fitz more than PyMuPDF, so we’ll
    need to go with it. It’s rare indeed, but occasionally we use one name to install
    the library and another to import it!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们为什么要使用 `import fitz`？为什么用 `import fitz` 而不是 `import PyMuPDF`？显然，这个库的设计者更喜欢
    fitz 而不是 PyMuPDF，所以我们需要使用 fitz。虽然这种情况很少见，但偶尔我们会遇到安装库时使用一个名字，而导入时用另一个名字！
- en: If you encounter NameError when you import
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 如果在导入时遇到 NameError
- en: If Python gives you a `NameError` referring to the library that you’re trying
    to import, it’s a good bet that you haven’t successfully imported that library.
    It could be that the library isn’t in fact installed, or that you need to use
    a different name to import it. Use Copilot Chat to have a conversation if you
    ever find that you’ve installed a library but can’t seem to import it.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Python 提示您 `NameError`，并且该错误指向您尝试导入的库，那么很可能是您没有成功导入该库。可能是该库实际上没有安装，或者您需要使用不同的名称来导入它。如果您发现已经安装了库，但似乎无法导入它，请使用
    Copilot Chat 与我们对话。
- en: Now we’re ready to generate some code. The following listing shows the prompt
    that we used and the code that Copilot gave us.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备生成一些代码。以下清单显示了我们使用的提示和 Copilot 给出的代码。
- en: Listing 9.5 Improved function to add covers to .pdf documents
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 9.5 改进的函数，用于将封面添加到 .pdf 文档中
- en: '[PRE49]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '#1 If the final_dir directory doesn’t exist, . . .'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 如果 final_dir 目录不存在，. . .'
- en: '#2 . . . create the final_dir directory.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 . . . 创建 final_dir 目录。'
- en: '#3 Loops through the .pdf reports'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 遍历 .pdf 报告'
- en: '#4 Used to read the cover'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 用于读取封面'
- en: '#5 Used to read the report'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 用于读取报告'
- en: '#6 Used as our new output file'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 用作我们的新输出文件'
- en: '#7 Adds the cover to our new .pdf file'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 将封面添加到我们的新 .pdf 文件'
- en: '#8 Adds the report to our new .pdf file'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 将报告添加到我们的新 .pdf 文件'
- en: '#9 Saves our new .pdf file'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '#9 保存我们新的 .pdf 文件'
- en: This program happens to start with some code that creates the output directory
    if it doesn’t already exist. After that, the steps are similar to those in our
    earlier program that used PyPDF2, although the functions called by each program
    are different. (That makes sense because PyPDF2 and PyMuPDF are different libraries,
    with different features and functions.) In both cases, we’re using `listdir` to
    get a list of the report .pdf filenames. In the `for` loop, we go through each
    of those reports; the code in the loop is responsible for creating a new .pdf
    file that contains the cover followed by the report. In our PyPDF2 code, there
    was an inner `for` loop that we needed to loop through all the pages of the report.
    In our current program, we don’t need that because Copilot used the `insert_pdf`
    function, which inserts a .pdf file into another .pdf file in one shot (not page
    by page). Whether you took the approach of installing the older library or you
    chose to use a different library, we’ve solved our problem and automated what
    would have been an unpleasantly tedious task.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序恰好从一些代码开始，如果输出目录尚不存在，它会创建该目录。之后，步骤与我们早前使用 PyPDF2 的程序类似，尽管每个程序调用的函数不同。（这是有道理的，因为
    PyPDF2 和 PyMuPDF 是不同的库，具有不同的功能和特性。）在这两种情况下，我们都使用 `listdir` 来获取报告 .pdf 文件名的列表。在
    `for` 循环中，我们遍历这些报告；循环中的代码负责创建一个新的 .pdf 文件，其中包含封面，随后是报告。在我们的 PyPDF2 代码中，有一个内层 `for`
    循环，我们需要循环遍历报告的所有页面。在当前的程序中，我们不需要这样做，因为 Copilot 使用了 `insert_pdf` 函数，它可以一次性将 .pdf
    文件插入到另一个 .pdf 文件中（而不是逐页插入）。无论你是选择安装旧版库，还是选择使用其他库，我们都解决了问题，并自动化了本可能非常繁琐的任务。
- en: Notice that we’ve slightly altered the workflow that we described in the previous
    chapter to take into account handling the different Python modules that could
    aid you with your task. A modified workflow is provided in figure 9.2.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们稍微修改了上一章中描述的工作流程，以考虑处理可能帮助您完成任务的不同 Python 模块。修改后的工作流程见图 9.2。
- en: '![figure](../Images/9-2.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/9-2.png)'
- en: Figure 9.2 Additions to our workflow to account for working with different Python
    modules
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2 对我们的工作流程的补充，以应对使用不同Python模块的情况
- en: '9.5 Example 3: Merging phone picture libraries'
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 示例 3：合并手机图片库
- en: Now suppose that you take a lot of pictures on your phone. Your partner (or
    sibling, parent, or child) also takes a lot of pictures on their phone. You each
    have hundreds or thousands of pictures! Sometimes you send pictures to your partner,
    and they send pictures to you, so that you and your partner have some but not
    all of each other’s pictures.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你在手机上拍了很多照片。你的伴侣（或兄弟姐妹、父母或孩子）也在他们的手机上拍了很多照片。你们每个人都有成百上千张照片！有时你把照片发给你的伴侣，他们也会把照片发给你，这样你和你的伴侣就有了对方的一部分照片，但并不是全部。
- en: You live life like this for a while, but honestly, it’s becoming a mess. Half
    the time when you want a picture, you can’t find it because it’s a picture that
    your partner took on their phone that they didn’t send you. And, you’re starting
    to have many duplicate pictures all over the place.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你过了一段时间这样的生活，但老实说，这开始变得有点混乱了。每当你想找一张照片时，半数时候你找不到，因为那是你伴侣在他们手机上拍的照片，他们没发给你。而且，你开始在各处看到很多重复的照片。
- en: 'You then have an idea: “What if we take all the pictures from my phone and
    all the pictures from your phone, and we create a combined library of all the
    pictures! Then we’ll have all the pictures in one place!” Remember that both of
    your phones may have hundreds of pictures, so doing this manually is out of the
    question. We’re going to automate this!'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你有了一个想法：“如果我们把我手机里的所有照片和你手机里的所有照片都拿出来，然后创建一个合并后的照片库！这样我们就能把所有照片都集中在一个地方！”记住，你们两个的手机可能都有数百张照片，所以手动操作是不现实的。我们要自动化这个过程！
- en: To specify our task more precisely, we’ll say that we have two directories of
    pictures (think of each directory as the contents of a phone) that we want to
    combine into a new directory. A common file format for pictures is a .png file,
    so we’ll work with those files here. Your actual phone might use .jpg files rather
    than .png files, but don’t worry. You can adapt what we do here to that picture
    file format (or any other picture file format) if you like.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更精确地描述我们的任务，我们可以说我们有两个图片目录（可以把每个目录想象成一部手机的内容），我们想将它们合并到一个新目录里。图片的常见文件格式是.png格式，所以我们在这里将处理这些文件。你的手机实际可能使用的是.jpg格式，而不是.png格式，但不用担心。如果你愿意，你可以根据我们在这里做的操作，适应其他图片文件格式（或任何其他图片格式）。
- en: In the resources for this book, in the ch9 directory, you’ll find two subdirectories
    of picture files. These subdirectories are named pictures1 and pictures2\. You
    can imagine that pictures1 has the pictures from your phone (98 pictures) and
    pictures2 has the pictures from your partner’s phone (112 pictures). We’re going
    to combine these two phone directories into a new directory.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的资源中，在ch9目录下，你会找到两个子目录，里面是图片文件。这些子目录名为pictures1和pictures2。你可以想象，pictures1是你手机上的照片（98张），而pictures2是你伴侣手机上的照片（112张）。我们将把这两个手机目录合并成一个新的目录。
- en: Open some of the .png files in the same way that you open pictures or photos
    on your computer. The pictures we’ve generated are just some random shapes, but
    the program we write here will work no matter what’s inside the pictures.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 以你在电脑上打开图片或照片的方式打开一些.png文件。我们生成的图片只是一些随机的形状，但我们在这里编写的程序无论图片里是什么内容，都能正常工作。
- en: At the outset, we said that the same picture might be on both phones, so we’ve
    generated some duplicate files in our pictures. (We have a total of 210 picture
    files, but 10 of them are duplicates, so there are only 200 unique pictures.)
    For example, in the pictures1 directory, there’s a file called 1566.png, and in
    the pictures2 directory, there’s a file called 2471.png. These two files are identical,
    and when we generate our directory of files from both phones, we’ll only want
    to keep one of these. What’s tricky here is that these pictures are the same even
    though their filenames are not.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始我们说过，同一张照片可能出现在两部手机上，所以我们在照片中生成了一些重复的文件。（我们总共有210个图片文件，但其中有10个是重复的，所以实际上只有200张独特的照片。）例如，在pictures1目录下，有一个名为1566.png的文件，而在pictures2目录下，有一个名为2471.png的文件。这两张文件是相同的，当我们从两部手机生成文件目录时，我们只想保留其中一张。这里的问题是，这些图片是相同的，尽管它们的文件名不同。
- en: 'What if two filenames are the same? Does that mean that the pictures are the
    same? For example, notice that each directory, pictures1 and pictures2, has a
    file called 9595.png. You might think that filenames being the same means that
    the pictures inside will be the same too. But no, if you open these pictures,
    you’ll see that they’re different! This could happen in real life too: you and
    your partner could both take different pictures, and, however remote, it’s possible
    that the filenames your phones choose for those pictures just happen to be the
    same.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个文件名相同呢？这是否意味着这些图片是相同的？举个例子，注意到每个目录，pictures1 和 pictures2，都有一个叫做 9595.png
    的文件。你可能认为文件名相同意味着里面的图片也会是一样的。但不，打开这些图片你会发现它们是不同的！这在现实生活中也可能发生：你和你的伙伴可能各自拍了不同的照片，虽然可能性微小，但你们的手机选择的文件名恰好可能相同。
- en: If we’re not careful, we’ll end up copying 9595.png from pictures1 into our
    new directory and then overwriting it later by copying 9595.png from pictures2
    into our new directory. We need to be sure that when we copy a file, we’re not
    overwriting a different picture that may already be there with the same filename.
    We provide an example of this process in figure 9.3.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不小心，我们可能会把 pictures1 中的 9595.png 复制到新目录，然后再把 pictures2 中的 9595.png 覆盖过去。我们需要确保在复制文件时，不会覆盖掉已经存在的同名不同图片。我们在图
    9.3 中提供了这个过程的示例。
- en: '![figure](../Images/9-3.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/9-3.png)'
- en: Figure 9.3 Example of merging the photos in the pictures1 and pictures2 folders
    into the pictures–combined folder and managing the removal of duplicates
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.3 示例：将 pictures1 和 pictures2 文件夹中的照片合并到 pictures–combined 文件夹中，并管理重复项的删除
- en: We’re working with directories, not actual phones
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 我们处理的是目录，而不是实际的手机
- en: We’re assuming here that you have two directories of pictures already on your
    computer. These directories could have come from anywhere, and nothing we do here
    has anything specific to do with cell phones.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你已经在电脑上有两个图片目录。这些目录可能来自任何地方，且我们在这里所做的与手机无关。
- en: But if you wanted to do this task for real, with pictures on your phones, you’d
    need to get those pictures onto your computer first. You could use ChatGPT to
    have that discussion! As the details are specific to different phones and go beyond
    what we want to use Copilot to automate, we won’t go further into this here.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你想真正执行这个任务，处理手机上的图片，你首先需要把这些图片传到你的电脑上。你可以用 ChatGPT 讨论如何实现！由于这些细节与不同手机相关，超出了我们使用
    Copilot 自动化的范围，所以我们这里不会深入探讨。
- en: 9.5.1 Conversing with Copilot
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 与 Copilot 的对话
- en: Our tool is going to create a combined directory of pictures from pictures1
    and pictures2, but without duplicate pictures. If our combined original picture
    directories have the same picture multiple times, we want only one of those copies
    of the picture to survive in our new directory.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具将从 pictures1 和 pictures2 中创建一个合并的图片目录，但不会有重复的图片。如果我们的原始合并图片目录中有相同的图片多次，我们希望在新目录中只保留其中一张。
- en: 'At this point, there are at least two things we might like to know: How do
    we copy a file using Python, and how do we know whether two files are the same
    picture? Let’s start by asking Copilot Chat how we can copy a file:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，我们至少有两个问题需要解答：如何使用 Python 复制文件，如何判断两个文件是否是同一张图片？我们可以先向 Copilot Chat 询问如何复制文件：
- en: LPHumanI need to write a Python program that copies files. How do I do this?
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我需要写一个 Python 程序来复制文件。怎么做？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the shutil module
    in Python to copy files. Here’s an example:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 你可以使用 Python 中的 shutil 模块来复制文件。以下是一个示例：'
- en: '[PRE50]`*[PRE51]`*'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE50]`*[PRE51]`*'
- en: '*`*import shutil*`*'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import shutil*`*'
- en: '*`*# Replace the source and destination paths with your own*`*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 用你自己的源路径和目标路径替换这里*`*'
- en: '*`*source = ''/path/to/source/file''*`*'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*source = ''/path/to/source/file''*`*'
- en: '*`*destination = ''/path/to/destination/file''*`*'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*destination = ''/path/to/destination/file''*`*'
- en: '*`*# Copy the file*`*'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 复制文件*`*'
- en: '*`*shutil.copy(source, destination)*`*'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*shutil.copy(source, destination)*`*'
- en: '*[PRE52]*[PRE53]'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE52]*[PRE53]'
- en: This will copy the file from the source path to the destination path. If the
    destination file already exists, it will be overwritten.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把文件从源路径复制到目标路径。如果目标文件已经存在，它将被覆盖。
- en: Excellent. We can use that shutil module to copy a file; we’ll need to remember
    to import that module. The final sentence that Copilot gave us is an important
    warning. We should be careful to avoid copying a file over the top of another
    file that already exists. Next, let’s determine whether this shutil module is
    built-in to Python.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。我们可以使用 shutil 模块来复制文件；我们需要记得导入这个模块。Copilot 给出的最后一句话是一个重要的警告。我们应当小心，避免将文件覆盖到已经存在的文件上。接下来，让我们确认这个
    shutil 模块是否是 Python 内置的。
- en: LPHumanIs this shutil module built into Python?
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman这个 shutil 模块是 Python 内置的吗？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, the shutil module is a
    built-in module in Python, so you don’t need to install anything extra to use
    it.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 是的，shutil 模块是 Python 内置的模块，因此你不需要额外安装任何东西来使用它。'
- en: You might wonder why we’re focusing on making copies of files and putting them
    into our new directory, rather than moving them from our original directories
    into the new directory. The reason is that we want to leave our original directories
    alone just in case we have a bug and fail to get all the files into our new directory.
    If anything goes wrong in our new directory, it won’t matter because our original
    directories will still be intact.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会疑惑，为什么我们要将文件复制到新的目录中，而不是直接从原始目录移动到新目录。原因是我们希望保留原始目录，以防出现 bug，导致无法将所有文件成功移动到新目录。如果新目录出了问题也无妨，因为原始目录依然完好无损。
- en: That wraps up what we need to know about copying files. Now let’s move on to
    learn how we can determine whether two files are the same picture.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于复制文件我们需要了解的全部内容。现在，让我们继续学习如何判断两个文件是否是相同的图片。
- en: As we’ve already said, it’s not sufficient to use filenames to determine whether
    pictures are the same. How can we do it, then?
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，光凭文件名无法判断图片是否相同。那么我们该怎么做呢？
- en: LPHumanUsing Python, how can I determine whether .png files are the same?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman使用 Python，我如何判断 .png 文件是否相同？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the filecmp module
    in Python to compare two files and check if they are the same. Here’s an example
    code snippet that compares two .png files:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 你可以使用 Python 中的 filecmp 模块来比较两个文件，检查它们是否相同。以下是一个示例代码片段，用于比较两个
    .png 文件：'
- en: '[PRE54]`*[PRE55]`*'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE54]`*[PRE55]`*'
- en: '*`*import filecmp*`*'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import filecmp*`*'
- en: '*`*# Replace these file paths with the actual file paths of the .png files*`*'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 将这些文件路径替换为实际的 .png 文件路径*`*'
- en: '*`*# you want to compare*`*'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 你想要比较的文件*`*'
- en: '*`*file1 = ''/path/to/file1.png''*`*'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*file1 = ''/path/to/file1.png''*`*'
- en: '*`*file2 = ''/path/to/file2.png''*`*'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*file2 = ''/path/to/file2.png''*`*'
- en: '*`*if filecmp.cmp(file1, file2):*`*'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*if filecmp.cmp(file1, file2):*`*'
- en: '*`*print(''The files are the same.'')*`*'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(''这些文件是相同的。'')*`*'
- en: '*`*else:*`*'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*else:*`*'
- en: '*`*print(''The files are different.'')*`*'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(''这些文件不同。'')*`*'
- en: '*[PRE56]*[PRE57]'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE56]*[PRE57]*'
- en: This code will compare the contents of the two files and return `True` if they
    are the same, and `False` if they are different.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将比较两个文件的内容，如果它们相同，将返回 `True`，如果不同，则返回 `False`。
- en: As a quick aside, the last sentence from Copilot is wrong. That code isn’t returning
    `True` or `False` anywhere. Just like Copilot can generate faulty code for us
    in our Python file, Copilot Chat can produce faulty explanations.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，Copilot 的最后一句话是错的。那段代码并没有返回 `True` 或 `False`。就像 Copilot 在我们的 Python 文件中可能会生成错误的代码一样，Copilot
    Chat 也可能会产生错误的解释。
- en: Our prompt wasn’t precise about the number of files that we need to compare.
    Do we want to compare two files? Hundreds of files? Our prompt doesn’t say. Copilot
    has told us what to do if we want to compare two files, which is a reasonable
    thing to tell us. But that’s not quite what we need. We need to be able to determine,
    among hundreds of files, which files are duplicates of other files. That way,
    we can detect a duplicate file and not copy it into our new directory. Let’s try
    again.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的提示没有明确说明需要比较多少个文件。是两个文件？数百个文件？提示中并没有说明。Copilot 告诉我们如果要比较两个文件应该怎么做，这是一种合理的做法。但这并不是我们需要的。我们需要能够在成百上千的文件中判断哪些文件是重复的。这样，我们就能检测到重复的文件，并避免将其复制到新目录中。让我们再试一次。
- en: LPHumanWhat if I have hundreds of .png files and I want to find duplicates—is
    that approach you gave me still good?
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman如果我有数百个 .png 文件，想找到重复的文件——你给的方法还适用吗？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot If you have hundreds of .png
    files and you want to find duplicates, you can use the os module to iterate over
    all the files in a directory and compare each file to every other file in the
    directory. Here’s an example code snippet that does that:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 如果你有成百上千个 .png 文件并想找出重复文件，你可以使用
    os 模块遍历目录中的所有文件，并将每个文件与目录中的其他文件进行比较。下面是一个执行此操作的代码示例：'
- en: '[PRE58]`*[PRE59]`*'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE58]`*[PRE59]`*'
- en: '*`*import os*`*'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import os*`*'
- en: '*`*import filecmp*`*'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*import filecmp*`*'
- en: '*`*# Replace this with the actual directory path where your .png*`*'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 将此替换为实际的目录路径，其中包含您的 .png*`*'
- en: '*`*# files are located*`*'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 文件所在位置*`*'
- en: '*`*directory = ''/path/to/directory''*`*'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*directory = ''/path/to/directory''*`*'
- en: '*`*# Iterate over all the files in the directory*`*'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*# 遍历目录中的所有文件*`*'
- en: '*`*for filename1 in os.listdir(directory):*`*'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*for filename1 in os.listdir(directory):*`*'
- en: '*`*if filename1.endswith(''.png''):*`*'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*if filename1.endswith(''.png''):*`*'
- en: '*`*for filename2 in os.listdir(directory):*`*'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*for filename2 in os.listdir(directory):*`*'
- en: '*`*if filename2.endswith(''.png'') and filename1 != filename2:*`*'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*if filename2.endswith(''.png'') and filename1 != filename2:*`*'
- en: '*`*file1 = os.path.join(directory, filename1)*`*'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*file1 = os.path.join(directory, filename1)*`*'
- en: '*`*file2 = os.path.join(directory, filename2)*`*'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*file2 = os.path.join(directory, filename2)*`*'
- en: '*`*if filecmp.cmp(file1, file2):*`*'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*if filecmp.cmp(file1, file2):*`*'
- en: '*`*print(f''{filename1} and {filename2} are duplicates.'')*`*'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '*`*print(f''{filename1} 和 {filename2} 是重复的。'')*`*'
- en: '*[PRE60]*[PRE61]'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE60]*[PRE61]'
- en: This code will iterate over all the files in the directory and compare each
    `.png` file to every other `.png` file in the directory. If two files are the
    same, it will print a message indicating that they are duplicates. Note that this
    approach can be slow for large directories with many files.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将遍历目录中的所有文件，并将每个`.png`文件与目录中的其他`.png`文件进行比较。如果两个文件相同，它将打印一条消息，表示它们是重复的。请注意，对于包含大量文件的大目录，这种方法可能会比较慢。
- en: 'The outer `for` loop goes through each file in the directory. How do we know
    whether the current file has a duplicate? Well, we can go through each other file
    in the directory and compare it to the current file. That’s the role of the inner
    `for` loop: it uses `filecmp.cmp` to compare the current file (`file1`) to each
    other file (`file2`).'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 外部 `for` 循环遍历目录中的每个文件。我们如何知道当前文件是否有重复呢？好吧，我们可以遍历目录中的每个文件并将其与当前文件进行比较。这就是内部 `for`
    循环的作用：它使用 `filecmp.cmp` 来比较当前文件（`file1`）与每个其他文件（`file2`）。
- en: We didn’t mention in our prompt that we care about finding duplicates across
    multiple directories, so Copilot has focused on a single directory here. If that
    difference turns out to be a roadblock, we could make our prompt more precise.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在提示中没有提到我们关心的是跨多个目录查找重复项，所以 Copilot 在这里只专注于单个目录。如果这个差异成了障碍，我们可以使我们的提示更精确。
- en: Copilot is using two other modules here, os and filecmp. We could ask Copilot
    if these are built-in Python modules or not, but we’ll save a little time and
    just tell you here that they are built-in.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 在这里使用了另外两个模块，os 和 filecmp。我们本可以问 Copilot 这些模块是否是 Python 内置的，但为了节省时间，我们直接告诉你它们是内置模块。
- en: 'We now want you to focus on the final sentence from Copilot: “Note that this
    approach can be slow for large directories with many files.” How slow is “slow”?
    How many is “many”? We don’t know.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们希望你关注 Copilot 最后一句话：“请注意，这种方法对于包含大量文件的大目录可能会比较慢。” 什么是“慢”？什么是“多”？我们并不知道。
- en: You might be tempted to ask Copilot for a better solution, one that isn’t “slow
    for large directories with many files.” But many programmers wouldn’t do that.
    It’s often a mistake to optimize our solution before we have even tried out our
    (unoptimized, apparently slow) approach for two reasons. First, maybe our “slow”
    program turns out to be fast enough! We may as well try it. Second, more optimized
    programs are often more sophisticated programs, and they may be more difficult
    for us to get right. That isn’t always the case, but it can be. And again, if
    our unoptimized program gets the job done, we don’t even have to worry about a
    more optimized version at all.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想让 Copilot 提供一个更好的解决方案，一个不会在“大目录和许多文件”中变慢的解决方案。但是许多程序员不会那样做。在我们尝试（未优化的，看似较慢的）方法之前，优化解决方案往往是一个错误，原因有两个。首先，也许我们的“慢”程序实际上足够快！我们完全可以先试试。其次，更优化的程序通常是更复杂的程序，而且它们可能更难以正确实现。虽然这并不总是如此，但它确实有可能。而且，再说一遍，如果我们的未优化程序已经完成了任务，我们根本不必担心更优化的版本。
- en: Now, if it turns out that our program really is too slow or you find yourself
    using the program repeatedly, then it may be worth the extra investment in continuing
    to work with Copilot on a faster solution. For now, though, we’re good.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们的程序真的太慢，或者你发现自己反复使用这个程序，那么继续与Copilot一起工作，寻找更快的解决方案可能是值得的。但目前来说，我们的程序足够用了。
- en: 9.5.2 Top-down design
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.2 自上而下的设计
- en: There’s a little more going on in this task than in our prior two tasks. For
    one, we need to be careful not to overwrite a file that already exists in our
    new directory. For another, we need to determine which files to copy in the first
    place (remember that we only want to copy files that don’t already match a file
    in our new directory). Compare this to the .pdf merging task we just accomplished,
    where we didn’t have these extra concerns.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务比我们之前的两个任务稍微复杂一些。一方面，我们需要小心不要覆盖新目录中已经存在的文件。另一方面，我们需要先确定哪些文件需要复制（记住，我们只想复制那些在新目录中没有相同文件的文件）。与我们刚完成的.pdf合并任务相比，我们没有这些额外的考虑。
- en: To that end, we’re going to use top-down design and problem decomposition here.
    Don’t worry, it won’t be a full-on top-down design example like we did in chapter
    7\. Our task here is much smaller than our spelling suggestions task from that
    chapter. We’ll just do a little top-down design and that will help Copilot get
    us what we want.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将在这里使用自上而下的设计和问题分解。别担心，这不会是像第7章那样的完整自上而下设计示例。我们这里的任务比那一章中的拼写建议任务要小得多。我们只会做一些简单的自上而下设计，这将帮助Copilot为我们提供我们需要的内容。
- en: 'Our top-level function will be responsible for solving our overall task: taking
    the pictures1 and pictures2 directories and putting all unique pictures into a
    target directory. Back in chapter 3, we learned that we should make functions
    as general as we can, to make them more useful or generalizable to other tasks.
    Here, we’ve been thinking about combining two picture directories together. But
    why not 3, 5, or 50 directories? Who cares how many directories we have; we should
    be able to just combine as many directories as we want.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的顶级函数将负责解决我们的整体任务：将pictures1和pictures2目录中的所有独特图片放入目标目录中。在第3章中，我们学到了应该尽可能地让函数更通用，以便使其在其他任务中也能更有用或更具通用性。在这里，我们一直在考虑将两个图片目录合并在一起。但为什么不合并3个、5个或50个目录呢？目录的数量不重要；我们应该能够合并任意数量的目录。
- en: So, instead of designing our top-level function to take two strings (directory
    names) as parameters, we’ll have the function take a list of strings. That way,
    we can use it on as many picture directories as we want. And, we can still readily
    use it on two picture directories—we’ll just pass a list containing the names
    of the two directories.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们不再设计一个顶级函数，它接受两个字符串（目录名称）作为参数，而是让这个函数接受一个字符串列表。这样，我们可以在任意数量的图片目录上使用它。而且，我们仍然可以在两个图片目录上方便地使用它——我们只需传递一个包含两个目录名称的列表。
- en: 'We’ll name our top-level function `make_copies`. We’ll need two parameters:
    the list of directory names that we just discussed, and the name of our target
    directory where we want all the files to go.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为顶级函数命名为`make_copies`。我们需要两个参数：我们刚才讨论过的目录名称列表，以及我们希望所有文件存放的目标目录名称。
- en: What’s this function going to do? It’s going to loop through each directory
    in the list of directories, and then, for each directory, it’s going to loop through
    each file. For each file, we need to determine whether to copy it or not and,
    if we need to copy it, to do the actual copying.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会做什么呢？它将遍历目录列表中的每个目录，然后对于每个目录，它会遍历其中的每个文件。对于每个文件，我们需要判断是否需要复制它，如果需要复制，就进行实际的复制操作。
- en: 'Determining whether to copy the file, and then possibly copying it, is a subtask
    that we can split out of `make_copies`. We’ll name our function for this subtask
    `make_copy`. Our `make_copy` function will take two parameters: the name of a
    file and the target directory. If the file isn’t identical to any file in the
    target directory, then the function will copy the file into the target directory.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 判断是否需要复制文件，并且可能执行复制操作，这是一个可以从`make_copies`中拆分出来的子任务。我们将为这个子任务命名函数为`make_copy`。我们的`make_copy`函数将接受两个参数：文件名和目标目录。如果文件与目标目录中的任何文件不相同，则该函数将把文件复制到目标目录。
- en: Say we want to copy a file called 9595.png from one of our picture directories
    into our target directory but that file already exists in the target directory.
    We don’t want to overwrite the file that’s already there, so we’ll need to come
    up with a new filename. We might try adding an _ (underscore) character prior
    to the .png part of the filename. That would give us 9595_.png. That one probably
    wouldn’t exist in the target directory, but if it did, we could then try 9595__.png,
    9595___.png, and so on, until we find a filename that doesn’t already exist in
    there.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想把名为9595.png的文件从我们的某个图片目录复制到目标目录，但该文件已经存在于目标目录中。我们不想覆盖已经存在的文件，因此需要想出一个新的文件名。我们可以尝试在文件名的.png部分前面添加一个_（下划线）字符。这样我们就得到了9595_.png。这个文件可能在目标目录中不存在，但如果存在，我们可以尝试9595__.png、9595___.png，依此类推，直到找到一个在目标目录中不存在的文件名。
- en: Generating a unique filename is a task that we can split out of our `make_copy`
    function. We’ll call it `get_good_filename`. It will take a filename as a parameter
    and return a version of that filename that doesn’t already exist.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 生成唯一文件名是一个可以从`make_copy`函数中拆分出来的任务。我们将把它命名为`get_good_filename`。它将接受一个文件名作为参数，并返回一个该文件名的版本，该版本在目标目录中不存在。
- en: And with that, our top-down design is done. Figure 9.4 depicts our work as a
    tree (well, at least the trunk of a tree), showing which function is called by
    which other function.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们的自上而下设计完成了。图9.4将我们的工作展示为一棵树（好吧，至少是树干），显示了哪个函数由哪个其他函数调用。
- en: '![figure](../Images/9-4.png)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/9-4.png)'
- en: Figure 9.4 Top-down design for image merging. The top-most (left-most) function
    is `make_copies`, the child of that is `make_copy`, and the child of that is `get_good_filename`.
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4 图像合并的自上而下设计。最顶部（最左侧）的函数是`make_copies`，它的子函数是`make_copy`，而它的子函数是`get_good_filename`。
- en: 9.5.3 Writing the tool
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.3 编写工具
- en: We don’t have any modules to install this time around. We do know from our Copilot
    conversation that we’ll use the built-in shutil module to copy files. We’ll also
    use the built-in filecmp module to compare files and the built-in os module to
    get a list of the files in a directory. We’ll therefore import these three modules
    at the top of our Python program.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们不需要安装任何模块。我们从与 Copilot 的对话中知道，我们将使用内建的shutil模块来复制文件。我们还将使用内建的filecmp模块来比较文件，使用内建的os模块来获取目录中的文件列表。因此，我们将在
    Python 程序的顶部导入这三个模块。
- en: As in chapter 7, we’re going to solve our problem by starting at the bottom
    of our function tree and working toward the top. We do that so Copilot can call
    our already-written functions when writing code for a parent function. For each
    function, we provide the `def` line and docstring, and Copilot writes the code.
    We’ve also provided some annotations to explain how the code works.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 和第七章一样，我们将通过从函数树的底部开始，逐步向上解决问题。我们这么做是为了让 Copilot 在为父函数编写代码时能调用我们已经写好的函数。对于每个函数，我们提供`def`行和文档字符串，Copilot
    编写代码。我们还提供了一些注释来解释代码的工作原理。
- en: Looking again at figure 9.4, we see that the first function we need to implement
    is `get_good_filename`. Let’s get that one done now in the following listing.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看图9.4，我们看到我们需要实现的第一个函数是`get_good_filename`。让我们在以下列表中完成它。
- en: Listing 9.6 `get_good_filename` function for our picture merge task
  id: totrans-477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.6 用于我们的图片合并任务的`get_good_filename`函数
- en: '[PRE62]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '#1 While the filename exists . . .'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 当文件名存在时 . . .'
- en: '#2 . . . insert an _ prior to .png by replacing .png with _.png.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 . . . 在.png之前插入一个_，通过将.png替换为_.png。'
- en: '#3 Returns the filename that we know now doesn’t exist'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 返回我们现在知道不存在的文件名'
- en: 'The next function we need to write is `make_copy`. This is the function that
    copies a file into a target directory but only if the file isn’t identical to
    a file that we’ve already copied. We’re looking for Copilot to do several things
    in its code here:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写的下一个函数是`make_copy`。这个函数用于将文件复制到目标目录，但仅在该文件与我们已复制的文件不相同时进行复制。我们希望 Copilot
    在编写代码时做几件事情：
- en: Use `os.listdir` to get a list of files in the target directory.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`os.listdir`获取目标目录中文件的列表。
- en: Use `filecmp.cmp` to determine whether two files are identical.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`filecmp.cmp`来判断两个文件是否相同。
- en: Use `shutil.copy` to copy the file if there was no identical file.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有相同的文件，使用`shutil.copy`来复制文件。
- en: Call the function `get_good_filename` that we just wrote.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用我们刚刚编写的`get_good_filename`函数。
- en: The following listing shows our prompt and the code that Copilot provided. Notice
    that the code is doing everything that we wanted it to do.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了我们的提示和 Copilot 提供的代码。请注意，代码做了我们想要它做的一切。
- en: Listing 9.7 `make_copy` function for our pictures merge task
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 9.7 `make_copy` 函数用于我们的图片合并任务
- en: '[PRE63]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '#1 Loops through the files in the target directory'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历目标目录中的文件'
- en: '#2 If the file is the same as one of the files in the target directory, . .
    .'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 如果文件与目标目录中的文件相同，. . .'
- en: '#3 . . . returns from the function without having copied the file.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 . . . 从函数返回，而没有复制文件。'
- en: '#4 Otherwise, copies the file and uses a good filename that doesn’t already
    exist.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 否则，复制文件并使用一个不存在的合适文件名。'
- en: There’s only one function to go, and it’s our top-level `make_copies` function.
    For each file in each of our picture directories, we’re expecting the code to
    call `make_copy` to copy the file if needed, as shown in the following listing.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下一个函数了，那就是我们的顶级 `make_copies` 函数。对于我们每个图片目录中的每个文件，我们期望代码调用 `make_copy` 来复制文件（如果需要），如下所示。
- en: Listing 9.8 `make_copies` function for our picture merge task
  id: totrans-495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 9.8 `make_copies` 函数用于我们的图片合并任务
- en: '[PRE64]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '#1 Loops through our picture directories'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历我们的图片目录'
- en: '#2 Loops through the files in the current picture directory'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 遍历当前图片目录中的文件'
- en: '#3 Copies the current file into the target directory, if needed'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 如果需要，将当前文件复制到目标目录'
- en: '#4 Runs our program on our two picture directories and the given target directory'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 在我们的两个图片目录和给定目标目录上运行程序'
- en: The final line of code from Copilot, beneath the `make_copies` function, makes
    the assumption that our target directory will be named pictures_combined. Create
    that directory now so that it sits alongside your pictures1 and pictures2 directories
    of pictures.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot 的最后一行代码，在 `make_copies` 函数下面，假设我们的目标目录将命名为 pictures_combined。现在创建该目录，使其与
    pictures1 和 pictures2 图片目录并列。
- en: As we discussed when working with .pdf files earlier in the chapter, it’s important
    that you first test the program on sample directories that you don’t care about.
    Your sample directories should have only a few files in them, so that you can
    manually determine whether the program is working as expected. You should also
    include important edge cases, such as having the same filename in each directory.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章早些时候处理 .pdf 文件时所讨论的，首先在你不关心的样本目录上测试程序是非常重要的。你的样本目录应该只有几个文件，这样你就可以手动判断程序是否按预期工作。你还应该包括一些重要的边界情况，比如在每个目录中都有相同的文件名。
- en: Once you have your sample directories, you should create a “harmless” version
    of the program that simply outputs messages rather than actually copying files.
    For our program here, you would change the line in `make_copy` to use `print`
    rather than `shutil.copy`.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了样本目录，你应该创建一个“无害”的版本，该版本仅输出消息，而不实际复制文件。对于我们的程序，你应该将 `make_copy` 中的行改为使用
    `print` 而不是 `shutil.copy`。
- en: If the output looks good after you check the results carefully, only then should
    you run the real program on your real directories. Remember that our program is
    copying (rather than moving) files, so even in our real directories, if something
    goes wrong, there’s a good chance that the problem will be in our new directory
    and not the original directories that we actually care about.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出结果检查无误，只有在此之后，你才应在实际目录上运行真正的程序。记住，我们的程序是复制文件（而非移动文件），所以即使在实际目录中，如果出现问题，很可能是新目录出了问题，而不是我们真正关心的原始目录。
- en: We’ll assume that you’re now ready to run the program on the pictures1 and pictures2
    directories. Once you run it, you can check your pictures_combined directory for
    the results. You should see that the directory has 200 files, which is exactly
    the number of unique pictures that we had across our two picture directories.
    Did we correctly handle the situation where the same filename existed in both
    picture directories but were different pictures? Yes, you can see that we have
    files named 9595.png and 9595_.png and that we therefore haven’t overwritten one
    with the other.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你现在已经准备好在 pictures1 和 pictures2 目录上运行程序。运行后，你可以检查你的 pictures_combined 目录中的结果。你应该看到该目录下有
    200 个文件，正好是我们在两个图片目录中独有的图片数量。我们是否正确处理了同名文件存在于两个图片目录中的情况，但它们是不同的图片？是的，你可以看到我们有名为
    9595.png 和 9595_.png 的文件，因此我们没有将一个文件覆盖成另一个文件。
- en: Oh, and how long did the program take to run on your computer? At most a few
    seconds, right? It turns out that Copilot’s warning that “this approach can be
    slow for large directories with many files” didn’t matter for us.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，程序在你计算机上运行了多久？最多几秒钟，对吧？事实证明，Copilot 提出的“对于包含许多文件的大目录，这种方法可能很慢”并没有对我们产生影响。
- en: Now, we all know that people tend to have thousands of pictures on their phones,
    not hundreds. If you ran this program on two real phone picture libraries, you
    would again need to determine whether it completes in an acceptable amount of
    time. You could run the program and let it run for a minute or two or however
    long you’re willing to wait. For fun, we also tested our program on a total of
    10,000 small image files (a more realistic scenario than the 210 pictures across
    our pictures1 and pictures2 directories that we used in this chapter), and we
    found that it only took 1 minute to complete. At some point, our program will
    become too slow to be practical, and that’s when you’d need to do further research
    with Copilot Chat to arrive at a more efficient program.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们都知道人们往往在手机上拥有成千上万张照片，而不是几百张。如果你在两个真实的手机图片库上运行这个程序，你仍然需要确定它是否在可接受的时间内完成。你可以运行程序并让它运行一两分钟，或者等待你愿意等的时间。为了有趣，我们还在总共10,000个小图像文件上测试了我们的程序（这比我们在本章中使用的210张照片更具现实意义），结果发现它只用了1分钟就完成了。在某个时刻，我们的程序会变得过于缓慢，无法实际使用，那时你需要通过Copilot
    Chat进行进一步研究，找到一个更高效的程序。
- en: 'In this chapter, we succeeded in automating three tedious tasks: cleaning up
    an email, adding covers to hundreds of .pdf files, and wrangling multiple picture
    libraries into one. The approach in each case was the same: use Copilot Chat to
    determine which module(s) to use, then follow the approach that we’ve honed throughout
    the book to have Copilot write the required code.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们成功地实现了自动化三个繁琐的任务：清理电子邮件、为数百个.pdf文件添加封面，以及将多个图片库合并成一个。每个案例的处理方法都是相同的：使用Copilot
    Chat确定需要使用的模块，然后按照我们在本书中总结的方法，让Copilot编写所需的代码。
- en: Remember, whenever you find yourself repeating the same task, it’s worth trying
    to automate it using Copilot and Python. There are many helpful Python modules
    for doing so, beyond what we showed in this chapter. For example, there are modules
    to manipulate images, work with Microsoft Excel or Microsoft Word files, send
    email, scrape data from websites, and more. If it’s a tedious task, chances are
    that someone has made a Python module to help with it and that Copilot will be
    able to help you use that module effectively.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每当你发现自己在重复同样的任务时，值得尝试使用Copilot和Python将其自动化。除了本章展示的内容之外，还有许多有用的Python模块可以帮助完成此类任务。例如，有用于处理图像、操作Microsoft
    Excel或Microsoft Word文件、发送电子邮件、抓取网站数据等的模块。如果是繁琐的任务，很可能有人已经创建了一个Python模块来帮助你处理，并且Copilot能够帮助你有效地使用该模块。
- en: 9.6 Exercises
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 练习
- en: You already have a tool that cleans up email text by removing any `>` or space
    characters from the beginning of each line. What steps will you take to enhance
    this tool to also remove lines that are excessively short (e.g., lines with fewer
    than five characters, excluding spaces)?
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经有一个工具，可以通过删除每行开头的`>`或空格字符来清理电子邮件文本。你将采取哪些步骤来增强此工具，以便也能删除过短的行（例如，删除字符少于五个的行，排除空格）？
- en: 'You’re writing a Python program to clean up a bunch of images that you have
    stored on your computer, and you’ve decided to use the Pillow library (a fork
    of the Python Image Library [PIL]). After installing the latest version of Pillow,
    you run your program but encounter the following error:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在编写一个Python程序来清理存储在计算机上的一堆图片，决定使用Pillow库（Python图像库[PIL]的一个分支）。在安装了最新版本的Pillow后，你运行程序时遇到了以下错误：
- en: '[PRE65]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: What steps can you take to fix this problem?
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采取哪些步骤来解决这个问题？
- en: 3\. You’ve been given an Excel file named sales_data.xlsx that contains monthly
    sales data for different products. Your task is to write a Python program that
    reads the sales data, calculates the total sales for each product, and writes
    the results to a new Excel file named total_sales.xlsx. The sales_data.xlsx file
    has columns for each month (January, February, etc.).
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 你被提供了一个名为sales_data.xlsx的Excel文件，其中包含不同产品的月度销售数据。你的任务是编写一个Python程序，读取销售数据，计算每个产品的总销售额，并将结果写入一个名为total_sales.xlsx的新Excel文件。sales_data.xlsx文件包含每个月（1月、2月等）的列。
- en: 'Your program should do the following:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序应执行以下操作：
- en: Read the data from `sales_data.xlsx`.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`销售数据.xlsx`中读取数据。
- en: Calculate the total sales for each product across all months.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每个产品在所有月份中的总销售额。
- en: Write the product names and their total sales to `total_sales.xlsx`.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将产品名称及其总销售额写入`total_sales.xlsx`。
- en: 'Hints: make reasonable assumptions about the input file and you may need to
    import libraries to help you work with the .xlsx files. If you don’t have Excel
    or OpenOffice to read/write .xlsx files, feel free to do the task with .csv files
    instead.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：对输入文件做合理假设，你可能需要导入一些库来帮助你处理.xlsx文件。如果你没有Excel或OpenOffice来读写.xlsx文件，可以改用.csv文件来完成任务。
- en: 4\. It can be tedious to find news articles from different sources to read every
    day. Your task is to write a webscraper in Python that extracts and display the
    titles and URLs of the latest articles from a news website. You’ll need the beautifulsoup4
    and requests modules.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 每天从不同来源寻找新闻文章阅读可能会非常繁琐。你的任务是用Python编写一个网页爬虫，从新闻网站提取并显示最新文章的标题和网址。你需要使用beautifulsoup4和requests模块。
- en: Summary
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Programmers often make tools to automate tedious tasks.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员经常创建工具来自动化繁琐的任务。
- en: It’s often necessary to use a Python module to help us write our tool.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python模块来帮助我们编写工具是很常见的。
- en: We can use Copilot Chat to determine which Python modules we should be using.
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过Copilot Chat来确定应使用哪些Python模块。
- en: It’s helpful to converse with Copilot to understand the pros and cons of various
    Python modules that may be available to us.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Copilot交流有助于理解各种可能适用的Python模块的优缺点。
- en: There are Python modules for working with the clipboard, working with .pdf files
    and other file formats, copying files, and more.****
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多Python模块可以用来处理剪贴板、.pdf文件和其他文件格式、复制文件等任务。****
