- en: 9\. Lists#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkPython/chap09.html](https://allendowney.github.io/ThinkPython/chap09.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This chapter presents one of Python’s most useful built-in types, lists. You
    will also learn more about objects and what can happen when multiple variables
    refer to the same object.
  prefs: []
  type: TYPE_NORMAL
- en: In the exercises at the end of the chapter, we’ll make a word list and use it
    to search for special words like palindromes and anagrams.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1\. A list is a sequence[#](#a-list-is-a-sequence "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like a string, a **list** is a sequence of values. In a string, the values are
    characters; in a list, they can be any type. The values in a list are called **elements**.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to create a new list; the simplest is to enclose the
    elements in square brackets (`[` and `]`). For example, here is a list of two
    integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And here’s a list of three strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The elements of a list don’t have to be the same type. The following list contains
    a string, a float, an integer, and even another list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A list within another list is **nested**.
  prefs: []
  type: TYPE_NORMAL
- en: A list that contains no elements is called an empty list; you can create one
    with empty brackets, `[]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `len` function returns the length of a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The length of an empty list is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows the state diagram for `cheeses`, `numbers` and `empty`.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/957063a97a11b84c82fcc4b0a736a796b5d1a3da6dc4f71db1409a9e25d1a570.png](../Images/7a76c4015360d2c859efe99a405dc889.png)'
  prefs: []
  type: TYPE_IMG
- en: Lists are represented by boxes with the word “list” outside and the numbered
    elements of the list inside.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2\. Lists are mutable[#](#lists-are-mutable "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To read an element of a list, we can use the bracket operator. The index of
    the first element is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Unlike strings, lists are mutable. When the bracket operator appears on the
    left side of an assignment, it identifies the element of the list that will be
    assigned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The second element of `numbers`, which used to be `123`, is now `17`.
  prefs: []
  type: TYPE_NORMAL
- en: 'List indices work the same way as string indices:'
  prefs: []
  type: TYPE_NORMAL
- en: Any integer expression can be used as an index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you try to read or write an element that does not exist, you get an `IndexError`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an index has a negative value, it counts backward from the end of the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `in` operator works on lists – it checks whether a given element appears
    anywhere in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Although a list can contain another list, the nested list still counts as a
    single element – so in the following list, there are only four elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And `10` is not considered to be an element of `t` because it is an element
    of a nested list, not `t`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 9.3\. List slices[#](#list-slices "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The slice operator works on lists the same way it works on strings. The following
    example selects the second and third elements from a list of four letters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you omit the first index, the slice starts at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you omit the second, the slice goes to the end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So if you omit both, the slice is a copy of the whole list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Another way to copy a list is to use the `list` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Because `list` is the name of a built-in function, you should avoid using it
    as a variable name.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4\. List operations[#](#list-operations "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `+` operator concatenates lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `*` operator repeats a list a given number of times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: No other mathematical operators work with lists, but the built-in function `sum`
    adds up the elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: And `min` and `max` find the smallest and largest elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 9.5\. List methods[#](#list-methods "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python provides methods that operate on lists. For example, `append` adds a
    new element to the end of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`extend` takes a list as an argument and appends all of the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There are two methods that remove elements from a list. If you know the index
    of the element you want, you can use `pop`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The return value is the element that was removed. And we can confirm that the
    list has been modified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you know the element you want to remove (but not the index), you can use
    `remove`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The return value from `remove` is `None`. But we can confirm that the list has
    been modified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If the element you ask for is not in the list, that’s a ValueError.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 9.6\. Lists and strings[#](#lists-and-strings "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A string is a sequence of characters and a list is a sequence of values, but
    a list of characters is not the same as a string. To convert from a string to
    a list of characters, you can use the `list` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `list` function breaks a string into individual letters. If you want to
    break a string into words, you can use the `split` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: An optional argument called a **delimiter** specifies which characters to use
    as word boundaries. The following example uses a hyphen as a delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If you have a list of strings, you can concatenate them into a single string
    using `join`. `join` is a string method, so you have to invoke it on the delimiter
    and pass the list as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this case the delimiter is a space character, so `join` puts a space between
    words. To join strings without spaces, you can use the empty string, `''`, as
    a delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7\. Looping through a list[#](#looping-through-a-list "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use a `for` statement to loop through the elements of a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: For example, after using `split` to make a list of words, we can use `for` to
    loop through them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: A `for` loop over an empty list never runs the indented statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 9.8\. Sorting lists[#](#sorting-lists "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python provides a built-in function called `sorted` that sorts the elements
    of a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The original list is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '`sorted` works with any kind of sequence, not just lists. So we can sort the
    letters in a string like this.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The result is a list. To convert the list to a string, we can use `join`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: With an empty string as the delimiter, the elements of the list are joined with
    nothing between them.
  prefs: []
  type: TYPE_NORMAL
- en: 9.9\. Objects and values[#](#objects-and-values "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we run these assignment statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We know that `a` and `b` both refer to a string, but we don’t know whether they
    refer to the *same* string. There are two possible states, shown in the following
    figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/2e5ee2dabd4af114f59b1130cfa488eb144238c577461e791df9db8984a2de95.png](../Images/d47075b35980a553f7e01bc56e1e6c1f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the diagram on the left, `a` and `b` refer to two different objects that
    have the same value. In the diagram on the right, they refer to the same object.
    To check whether two variables refer to the same object, you can use the `is`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In this example, Python only created one string object, and both `a` and `b`
    refer to it. But when you create two lists, you get two objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: So the state diagram looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/c8cfa39ca5b7bb5dc02b5731f4e053972e409045852e63845c82d4f14657fb77.png](../Images/32a99d0796e7c6eb18f5b3038069d04e.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case we would say that the two lists are **equivalent**, because they
    have the same elements, but not **identical**, because they are not the same object.
    If two objects are identical, they are also equivalent, but if they are equivalent,
    they are not necessarily identical.
  prefs: []
  type: TYPE_NORMAL
- en: 9.10\. Aliasing[#](#aliasing "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If `a` refers to an object and you assign `b = a`, then both variables refer
    to the same object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: So the state diagram looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/bdf2f2d164766afae1abfc341924bf22fd6235f7db44edc4d5ab322d1a5323a1.png](../Images/90be22db2df1a3c8bf4e0ef5ba93a2a5.png)'
  prefs: []
  type: TYPE_IMG
- en: The association of a variable with an object is called a **reference**. In this
    example, there are two references to the same object.
  prefs: []
  type: TYPE_NORMAL
- en: An object with more than one reference has more than one name, so we say the
    object is **aliased**. If the aliased object is mutable, changes made with one
    name affect the other. In this example, if we change the object `b` refers to,
    we are also changing the object `a` refers to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: So we would say that `a` “sees” this change. Although this behavior can be useful,
    it is error-prone. In general, it is safer to avoid aliasing when you are working
    with mutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For immutable objects like strings, aliasing is not as much of a problem. In
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: It almost never makes a difference whether `a` and `b` refer to the same string
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: 9.11\. List arguments[#](#list-arguments "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you pass a list to a function, the function gets a reference to the list.
    If the function modifies the list, the caller sees the change. For example, `pop_first`
    uses the list method `pop` to remove the first element from a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We can use it like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The return value is the first element, which has been removed from the list
    – as we can see by displaying the modified list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the parameter `lst` and the variable `letters` are aliases
    for the same object, so the state diagram looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/afbc48196f8175d6ba5fc8d3b6406623158939478a7457ea70ae7c0aab651eb8.png](../Images/7f7d1aba33d53ebfe1703790b81777d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Passing a reference to an object as an argument to a function creates a form
    of aliasing. If the function modifies the object, those changes persist after
    the function is done.
  prefs: []
  type: TYPE_NORMAL
- en: '## 9.12\. Making a word list[#](#making-a-word-list "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we read the file `words.txt` and searched for words
    with certain properties, like using the letter `e`. But we read the entire file
    many times, which is not efficient. It is better to read the file once and put
    the words in a list. The following loop shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Before the loop, `word_list` is initialized with an empty list. Each time through
    the loop, the `append` method adds a word to the end. When the loop is done, there
    are more than 113,000 words in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to do the same thing is to use `read` to read the entire file into
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The result is a single string with more than a million characters. We can use
    the `split` method to split it into a list of words.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Now, to check whether a string appears in the list, we can use the `in` operator.
    For example, `'demotic'` is in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: But `'contrafibularities'` is not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: And I have to say, I’m anaspeptic about it.
  prefs: []
  type: TYPE_NORMAL
- en: 9.13\. Debugging[#](#debugging "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that most list methods modify the argument and return `None`. This is the
    opposite of the string methods, which return a new string and leave the original
    alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are used to writing string code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'It is tempting to write list code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '`remove` modifies the list and returns `None`, so next operation you perform
    with `t` is likely to fail.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This error message takes some explaining. An **attribute** of an object is a
    variable or method associated with it. In this case, the value of `t` is `None`,
    which is a `NoneType` object, which does not have a attribute named `remove`,
    so the result is an `AttributeError`.
  prefs: []
  type: TYPE_NORMAL
- en: If you see an error message like this, you should look backward through the
    program and see if you might have called a list method incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: 9.14\. Glossary[#](#glossary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**list:** An object that contains a sequence of values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**element:** One of the values in a list or other sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: '**nested list:** A list that is an element of another list.'
  prefs: []
  type: TYPE_NORMAL
- en: '**delimiter:** A character or string used to indicate where a string should
    be split.'
  prefs: []
  type: TYPE_NORMAL
- en: '**equivalent:** Having the same value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**identical:** Being the same object (which implies equivalence).'
  prefs: []
  type: TYPE_NORMAL
- en: '**reference:** The association between a variable and its value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**aliased:** If there is more than one variable that refers to an object, the
    object is aliased.'
  prefs: []
  type: TYPE_NORMAL
- en: '**attribute:** One of the named values associated with an object.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.15\. Exercises[#](#exercises "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 9.15.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I used the words “contrafibularities” and “anaspeptic”, but
    they are not actually English words. They were used in the British television
    show *Black Adder*, Season 3, Episode 2, “Ink and Incapability”.
  prefs: []
  type: TYPE_NORMAL
- en: However, when I asked ChatGPT 3.5 (August 3, 2023 version) where those words
    came from, it initially claimed they are from Monty Python, and later claimed
    they are from the Tom Stoppard play *Rosencrantz and Guildenstern Are Dead*.
  prefs: []
  type: TYPE_NORMAL
- en: If you ask now, you might get different results. But this example is a reminder
    that virtual assistants are not always accurate, so you should check whether the
    results are correct. As you gain experience, you will get a sense of which questions
    virtual assistants can answer reliably. In this example, a conventional web search
    can identify the source of these words quickly.
  prefs: []
  type: TYPE_NORMAL
- en: If you get stuck on any of the exercises in this chapter, consider asking a
    virtual assistant for help. If you get a result that uses features we haven’t
    learned yet, you can assign the VA a “role”.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, before you ask a question try typing “Role: Basic Python Programming
    Instructor”. After that, the responses you get should use only basic features.
    If you still see features we you haven’t learned, you can follow up with “Can
    you write that using only basic Python features?”'
  prefs: []
  type: TYPE_NORMAL
- en: 9.15.2\. Exercise[#](#exercise "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two words are anagrams if you can rearrange the letters from one to spell the
    other. For example, `tops` is an anagram of `stop`.
  prefs: []
  type: TYPE_NORMAL
- en: One way to check whether two words are anagrams is to sort the letters in both
    words. If the lists of sorted letters are the same, the words are anagrams.
  prefs: []
  type: TYPE_NORMAL
- en: Write a function called `is_anagram` that takes two strings and returns `True`
    if they are anagrams.
  prefs: []
  type: TYPE_NORMAL
- en: Using your function and the word list, find all the anagrams of `takes`.
  prefs: []
  type: TYPE_NORMAL
- en: 9.15.3\. Exercise[#](#id1 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python provides a built-in function called `reversed` that takes as an argument
    a sequence of elements – like a list or string – and returns a `reversed` object
    that contains the elements in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: If you want the reversed elements in a list, you can use the `list` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Or if you want them in a string, you can use the `join` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: So we can write a function that reverses a word like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: A palindrome is a word that is spelled the same backward and forward, like “noon”
    and “rotator”. Write a function called `is_palindrome` that takes a string argument
    and returns `True` if it is a palindrome and `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the following loop to find all of the palindromes in the word list
    with at least 7 letters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 9.15.4\. Exercise[#](#id2 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a function called `reverse_sentence` that takes as an argument a string
    that contains any number of words separated by spaces. It should return a new
    string that contains the same words in reverse order. For example, if the argument
    is “Reverse this sentence”, the result should be “Sentence this reverse”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: You can use the `capitalize` methods to capitalize the first word and
    convert the other words to lowercase.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.15.5\. Exercise[#](#id3 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a function called `total_length` that takes a list of strings and returns
    the total length of the strings. The total length of the words in `word_list`
    should be \(902{,}728\).
  prefs: []
  type: TYPE_NORMAL
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
