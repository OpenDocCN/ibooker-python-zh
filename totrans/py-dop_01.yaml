- en: Chapter 1\. Python Essentials for DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DevOps, the combination of software development with information technology
    operations, has been a hot field during the last decade. Traditional boundaries
    among software development, deployment, maintenance, and quality assurance have
    been broken, enabling more integrated teams. Python has been a popular language
    both in traditional IT operations and in DevOps due to its combination of flexibility,
    power, and ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: The Python programming language was publicly released in the early 1990s for
    use in system administration. It has been a great success in this area and has
    gained wide adoption. Python is a general-purpose programming language used in
    just about every domain. The visual effects and the motion picture industries
    embraced it. More recently, it has become the de facto language of data science
    and machine learning (ML). It has been used across industries from aviation to
    bioinformatics. Python has an extensive arsenal of tools to cover the wide-ranging
    needs of its users. Learning the whole Python Standard Library (the capabilities
    that come with any Python installation) would be a daunting task. Trying to learn
    all the third-party packages that enliven the Python ecosystem would be an immense
    undertaking. The good news is that you don’t need to do those things. You can
    become a powerful DevOps practitioner by learning only a small subset of Python.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we draw on our decades of Python DevOps experience to teach
    only the elements of the language that you need. These are the parts of Python
    DevOps that are used daily. They form the essential toolbox to get things done.
    Once you have these core concepts down, you can add more complicated tools, as
    you’ll see in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and Running Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to try the code in this overview, you need Python 3.7 or later
    installed (the latest release is 3.8.0 as of this writing) and access to a shell.
    In macOS X, Windows, and most Linux distributions, you can open the terminal application
    to access a shell. To see what version of Python you are using, open a shell,
    and type `python` `--version`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Python installers can be downloaded directly from the [Python.org website](https://www.python.org/downloads).
    Alternatively, you can use a package manager such as Apt, RPM, MacPorts, Homebrew,
    Chocolatey, or many others.
  prefs: []
  type: TYPE_NORMAL
- en: The Python Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to run Python is to use the built-in interactive interpreter.
    Just type `python` in a shell. You can then interactively run Python statements.
    Type `exit()` to exit the shell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Python scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python code runs from a file with the *.py* extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this code to a file named *hello.py*. To invoke the script, in a shell
    run `python` followed by the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Python scripts are how most production Python code runs.
  prefs: []
  type: TYPE_NORMAL
- en: IPython
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides the built-in interactive shell, several third-party interactive shells
    run Python code. One of the most popular is [IPython](https://ipython.org). IPython
    offers *introspection* (the ability to dynamically get information about objects),
    syntax highlighting, special *magic* commands (which we touch on later in this
    chapter), and many more features, making it a pleasure to use for exploring Python.
    To install IPython, use the Python package manager, `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running is similar to running the built-in interactive shell described in the
    previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Jupyter Notebooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A spin-off from the iPython project, the Jupyter project allows documents containing
    text, code, and visualizations. These documents are powerful tools for combining
    running code, output, and formatted text. Jupyter enables the delivery of documentation
    along with the code. It has achieved widespread popularity, especially in the
    data science world. Here is how to install and run Jupyter notebooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command opens a web browser tab showing the current working directory.
    From here, you can open existing notebooks in the current project or create new
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: Procedural Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’ve been around programming at all, you’ve probably heard terms like
    object-oriented programming (OOP) and functional programming. These are different
    architectural paradigms used to organize programs. One of the most basic paradigms,
    procedural programming, is an excellent place to start. *Procedural programming*
    is the issuing of instructions to a computer in an ordered sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this example, there are three statements that are executed
    in order from the first line to the last. Each statement uses the state produced
    by the previous ones. In this case, the first statement assigns the value 3 to
    a variable named `i`. In the second statement, this variable’s value is used to
    assign a value to a variable named `j`, and in the third statement, the values
    from both variables are added together. Don’t worry about the details of these
    statements yet; notice that they are executed in order and rely on the state created
    by the previous statements.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variable is a name that points to some value. In the previous example, the
    variables are `i` and `j` . Variables in Python can be assigned to new values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Python variables use dynamic typing. In practice, this means that they can
    be reassigned to values of different types or classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here the same variable is set to a string, a number, and a dictionary. Variables
    can be reassigned to values of any type.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Math
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Basic math operations such as addition, subtraction, multiplication, and division
    can all be performed using built-in math operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that a `//` symbol is for integer division. The symbol `**` creates an
    exponent, and `%` is the modulo operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comments are text ignored by the Python interpreter. They are useful for documentation
    of code and can be mined by some services to provide standalone documentation.
    Single-line comments are delineated by prepending with `#`. A single-line comment
    can start at the beginning of a line, or at any point thereafter. Everything after
    the `#` is part of the comment until a new line break occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiline comments are enclosed themselves in blocks beginning and ending with
    either `"""` or `''''''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Built-in Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are statements grouped as a unit. You invoke a function by typing
    the function name, followed by parentheses. If the function takes arguments, the
    arguments appear within the parentheses. Python has many built-in functions. Two
    of the most widely used built-in functions are `print` and `range`.
  prefs: []
  type: TYPE_NORMAL
- en: Print
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `print` function produces output that a user of a program can view. It
    is less relevant in interactive environments but is a fundamental tool when writing
    Python scripts. In the previous example, the argument to the `print` function
    is written as output when the script runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`print` can be used to see the value of a variable or to give feedback as to
    the state of a program. `print` generally outputs the standard output stream and
    is visible as program output in a shell.'
  prefs: []
  type: TYPE_NORMAL
- en: Range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though `range` is a built-in function, it is technically not a function at all.
    It is a type representing a sequence of numbers. When calling the `range()` constructor,
    an object representing a sequence of numbers is returned. Range objects count
    through a sequence of numbers. The `range` function takes up to three integer
    arguments. If only one argument appears, then the sequence is represented by the
    numbers from zero up to, but not including, that number. If a second argument
    appears, it represents the starting point, rather than the default of starting
    from 0\. The third argument can be used to specify the step distance, and it defaults
    to 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`range` maintains a small memory footprint, even over extended sequences, as
    it only stores the start, stop, and step values. The `range` function can iterate
    through long sequences of numbers without performance constraints.'
  prefs: []
  type: TYPE_NORMAL
- en: Execution Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has many constructs to control the flow of statement execution. You can
    group statements you wish to run together as a block of code. These blocks can
    be run multiple times using `for` and `while` loops or only run under certain
    conditions using `if` statements, `while` loops, or `try-except` blocks. Using
    these constructs is the first step to taking advantage of the power of programming.
    Different languages demarcate blocks of code using different conventions. Many
    languages with syntax similar to the C language (a very influential language used
    in writing Unix) use curly brackets around a group of statements to define a block.
    In Python, indentation is used to indicate a block. Statements are grouped by
    indentation into blocks that execute as a unit.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Python interpreter does not care if you use tabs or spaces to indent, as
    long as you are consistent. The Python style guide, [PEP-8](https://oreil.ly/b5yU4),
    however, recommends using four whitespaces for each level of indentation.
  prefs: []
  type: TYPE_NORMAL
- en: if/elif/else
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`if/elif/else` statements are common ways to branch between decisions in code.
    A block directly after an `if` statement runs if that statement evaluates to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we used the `==` operator, which returns `True` if items are equal and
    `False` if not. Optionally, this block can follow an `elif` or `else` statement
    with an accompanying block. In the case of an `elif` statement, this block only
    executes if the `elif` evaluates to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple `elif` loops can append together. If you are familiar with `switch`
    statements in other languages, this simulates that same behavior of choosing from
    multiple choices. Adding an `else` statement at the end runs a block if none of
    the other conditions evaluate as `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can nest `if` statements, creating blocks containing `if` statements that
    only execute if an outer `if` statement is `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: for Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`for` loops allow you to repeat a block of statements (a code block) once for
    each member of a *sequence* (ordered group of items). As you iterate through the
    sequence, the current item can be accessed by the code block. One of most common
    uses of loops is to iterate through a `range` object to do a task a set number
    of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, our block of code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We repeat this code 10 times, each time assigning the variable `i` to the next
    number in the sequence of integers from 0–9\. `for` loops can be used to iterate
    through any of the Python sequence types. You will see these later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: continue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `continue` statement skips a step in a loop, jumping to the next item in
    the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: while Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`while` loops repeat a block as long as a condition evaluates to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It is essential to define a way for your loop to end. Otherwise, you will be
    stuck in the loop until your program crashes. One way to handle this is to define
    your conditional statement such that it eventually evaluates to `False`. An alternative
    pattern uses the `break` statement to exit a loop using a nested conditional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Handling Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exceptions are a type of error causing your program to crash if not handled
    (caught). Catching them with a `try-except` block allows the program to continue.
    These blocks are created by indenting the block in which the exception might be
    raised, putting a `try` statement before it and an `except` statement after it,
    followed by a code block that should run when the error occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There are many built-in exceptions, such as `IOError`, `KeyError`, and `ImportError`.
    Many third-party packages also define their own exception classes. They indicate
    that something has gone very wrong, so it only pays to catch them if you are confident
    that the problem won’t be fatal to your software. You can specify explicitly which
    exception type you will catch. Ideally, you should catch the exact exception type
    (in our example, this was the exception `IndexError`).
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this overview, we will not be covering OOP. The Python language, however,
    comes with quite a few built-in classes.
  prefs: []
  type: TYPE_NORMAL
- en: What Is an Object?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In OOP, data or state and functionality appear together. The essential concepts
    to understand when working with objects are *class instantiation* (creating objects
    from classes) and *dot syntax* (the syntax for accessing an object’s attributes
    and methods). A class defines attributes and methods shared by its objects. Think
    of it as the technical drawing of a car model. The class can then be instantiated
    to create an instance. The instance, or object, is a single car built based on
    those drawings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You don’t need to worry about creating your own classes at this point. Just
    understand that each object is an instantiation of a class.
  prefs: []
  type: TYPE_NORMAL
- en: Object Methods and Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects store data in attributes. These attributes are variables attached to
    the object or object class. Objects define functionality in *object methods* (methods
    defined for all objects in a class) and *class methods* (methods attached to a
    class and shared by all objects in the class), which are functions attached to
    the object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Python documentation, functions attached to objects and classes are referred
    to as methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions have access to the object’s attributes and can modify and use
    the object’s data. To call an object’s method or access one of its attributes,
    we use dot syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So here our `FancyCar` class defines a method called `driveFast` and an attribute
    `wheels`. When you instantiate an instance of `FancyCar` named `my_car`, you can
    access the attribute and invoke the method using the dot syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sequences are a family of built-in types, including the *list*, *tuple*, *range*,
    *string*, and *binary* types. Sequences represent ordered and finite collections
    of items.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many operations that work across all of the types of sequences. We
    cover some of the most commonly used operations here.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `in` and `not in` operators to test whether or not an item
    exists in a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can reference the contents of a sequence by using its index number. To
    access the item at some index, use square brackets with the index number as an
    argument. The first item indexed is at position 0, the second at 1, and so forth
    up to the number one less than the number of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Indexing can appear from the end of a sequence rather than from the front using
    negative numbers. The last item has the index of –1, the second to last has the
    index of –2, and so forth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The index of an item results from the `index` method. By default, it returns
    the index of the first occurrence of the item, but optional arguments can define
    a subrange in which to search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can produce a new sequence from a sequence using slicing. A slice appears
    by invoking a sequence with brackets containing optional `start`, `stop`, and
    `step` arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`start` is the index of the first item to use in the new sequence, `stop` the
    first index beyond that point, and `step`, the distance between items. These arguments
    are all optional and are replaced with default values if omitted. This statement
    produces a copy of the original sequence. The default value for `start` is 0,
    for `stop` is the length of the sequence, and for `step` is 1\. Note that if the
    step does not appear, the corresponding *:* can also be dropped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Negative numbers can be used to index backward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Sequences share many operations for getting information about them and their
    contents. `len` returns the length of the sequence, `min` the smallest member,
    `max` the largest, and `count` the number of a particular item. `min` and `max`
    work only on sequences with items that are comparable. Remember that these work
    with any sequence type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists, one of the most commonly used Python data structures, represent an ordered
    collection of items of any type. The use of square brackets indicates a list syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `list()` can be used to create an empty list or a list based on
    another finite iterable object (such as another sequence):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Lists created by using square brackets directly are the most common form. Items
    in the list need to be enumerated explicitly in this case. Remember that the items
    in a list can be of different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The most efficient way to add a single item to a list is to `append` the item
    to the end of the list. A less efficient method, `insert`, allows you to insert
    an item at the index position of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of one list can be added to another using the `extend` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The most efficient and common way of removing the last item from a list and
    returning its value is to `pop` it. An index argument can be supplied to this
    method, removing and returning the item at that index. This technique is less
    efficient, as the list needs to be re-indexed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: There is also a `remove` method, which removes the first occurrence of an item.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the most potent and idiomatic Python features, list comprehensions,
    allows you to use the functionality of a `for` loop in a single line. Let’s look
    at a simple example, starting with a `for` loop squaring all of the numbers from
    0–9 and appending them to a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to replace this with a list comprehension, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the functionality of the inner block is put first, followed by the
    `for` statement. You can also add conditionals to list comprehensions, filtering
    the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Other techniques for list comprehensions include nesting them and using multiple
    variables, but the more straightforward form shown here is the most common.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The string sequence type is a collection of ordered characters surrounded by
    quotation marks. As of Python 3, strings default to using *UTF-8* encoding.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create strings either by using the string constructor method, `str(),`
    or by directly enclosing the text in quotation marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The string constructor can be used to make strings from other objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create multiline strings by using triple quotes around the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the methods shared by all sequences, strings have quite a few
    methods distinct to their class.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is relatively common for user text to have trailing or leading whitespace.
    If someone types " yes " in a form instead of “yes” you usually want to treat
    them the same. Python strings have a `strip` method just for this case. It returns
    a string with the whitespace removed from the beginning and end. There are also
    methods to remove the whitespace from only the right or left side of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if you want to add padding to a string, you can use the
    `ljust` or `rjust` methods. Either one pads with whitespace by default, or takes
    a character argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes you want to break a string up into a list of substrings. Perhaps
    you have a sentence you want to turn into a list of words, or a string of words
    separated by commas. The `split` method breaks a string into a list of strings.
    By default, it uses whitespace as the token to make the breaks. An optional argument
    can be used to add in another character where the split can break:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily create a new string from a sequence of strings and `join` them
    into a single string. This method inserts a string as a separator between a list
    of other strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the case of text is a common occurrence, whether it is making the
    case uniform for comparison or changing in preparation for user consumption. Python
    strings have several methods to make this an easy process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Python also provides methods to understand a string’s content. Whether it’s
    checking the case of the text, or seeing if it represents a number, there are
    quite a few built-in methods for interrogation. Here are just a few of the most
    commonly used methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You can insert content into a string and control its format at runtime. Your
    program can use the values of variables or other calculated content in strings.
    This approach is used in both creating user-consumed text and for writing software
    logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The older form of string formatting in Python comes from the C language `printf`
    function. You can use the modulus operator, `%`, to insert formatted values into
    a string. This technique applies to the form `string % values`, where values can
    be a single nontuple or a tuple of multiple values. The string itself must have
    a conversion specifier for each value. The conversion specifier, at a minimum,
    starts with a `%` and is followed by a character representing the type of value
    inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Additional format arguments include the conversion specifier. For example,
    you can control the number of places a float, `%f`, prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This mechanism for string formatting was the dominant one in Python for years,
    and you encounter it in legacy code. This approach offers some compelling features,
    such as sharing syntax with other languages. It also has some pitfalls. In particular,
    due to the use of a sequence to hold the arguments, errors related to displaying
    `tuple` and `dict` objects are common. We recommend adopting newer formatting
    options, such as the string `format` method, template strings, and f-strings,
    to both avoid these errors and increase the simplicity and readability of your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python 3 introduced a new way of formatting strings using the string method
    `format`. This way of formatting has been backported to Python 2 as well. This
    specification uses curly brackets in the string to indicate replacement fields
    rather than the modulus-based conversion specifiers of the old-style formatting.
    The insert values become arguments to the string `format` method. The order of
    the arguments determines their placement order in the target string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify index numbers in the brackets to insert values in an order
    different than that in the argument list. You can also repeat a value by specifying
    the same index number in multiple replacement fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'An even more powerful feature is that the insert values can be specified by
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here a `dict` works to supply the key values for name-based replacement fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify format specification arguments. Here they add left and
    right padding using `>` and `<`. In the second example, we specify a character
    to use in the padding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Format specifications are done using [the format specification mini-language](https://oreil.ly/ZOFJg).
    Our topic also uses another type of language called *f-strings*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python f-strings use the same formatting language as the `format` method, but
    offer a more straightforward and intuitive mechanism for using them. f-strings
    are prepended with either *f* or *F* before the first quotation mark. Like the
    `format` string previously described, f-strings use curly braces to demarcate
    replacement fields. In an f-string, however, the content of the replacement field
    is an expression. This approach means it can refer to variables defined in the
    current scope or involve calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As in `format` strings, format specifications in f-strings happen within the
    curly brackets after the value expression and start with a `:`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The value expression can contain nested expressions, referencing variables,
    and expressions in the construction of the parent expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We highly recommend using f-strings for the majority of your string formatting.
    They combine the power of the specification mini-language with a simple and intuitive
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Template strings are designed to offer a straightforward string substitution
    mechanism. These built-in methods work for tasks such as internationalization,
    where simple word substitutions are necessary. They use `$` as a substitution
    character, with optional curly braces surrounding them. The characters directly
    following the `$` identify the value to be inserted. When the `substitute` method
    of the string template executes, these names are used to assign values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Built-in types and functions are available whenever you run Python code, but
    to access the broader world of functionality available in the Python ecosystem,
    you need to use the `import` statement. This approach lets you add functionality
    from the Python Standard Library or third-party services into your environment.
    You can selectively import parts of a package by using the `from` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Dicts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Aside from strings and lists, dicts may be the most used of the Python built-in
    classes. A *dict* is a mapping of keys to values. The lookup of any particular
    value using a key is highly efficient and fast. The keys can be strings, numbers,
    custom objects, or any other nonmutable type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *mutable* object is one whose contents can change in place. Lists are a primary
    example; the contents of the list can change without the list’s identity changing.
    Strings are not mutable. You create a new string each time you change the contents
    of an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: Dicts are represented as comma–separated key/value pairs surrounded by curly
    braces. The key/value pairs consist of a key, a colon (*:*), and then a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a dict object using the `dict()` constructor. With no arguments,
    it creates an empty dict. It takes a sequence of key/value pairs as an argument
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create a *dict* directly using curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access the value associated with a key using square bracket syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the same syntax to set a value. If the key is not in the dict,
    it adds as a new entry. If it already exists, the value changes to the new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to access a key that has not been defined in a dict, a `KeyError`
    exception will be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check to see if the key exists in a dict using the `in` syntax we saw
    with sequences. In the case of dicts, it checks for the existence of keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'A more intuitive solution is to use the `get()` method. If you have not defined
    a key in a dict, it returns a supplied default value. If you have not supplied
    a default value, it returns `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `del` to remove a key-value pair from a dict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keys()` method returns a `dict_keys` object with the dict’s keys. The
    `values()` method returns an `dict_values` object, and the `items()` method returns
    key-value pairs. This last method is useful for iterating through the contents
    of a dict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to list comprehensions, dict comprehensions are one-line statements
    returning a dict by iterating through a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen some Python built-in functions already. Now move on to writing
    your own. Remember, a *function* is a mechanism for encapsulating a block of code.
    You can repeat the behavior of this block in multiple spots without having to
    duplicate the code. Your code will be better organized, more testable, maintainable,
    and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first line of a function definition starts with the keyword `def`, followed
    by the function name, function parameters enclosed in parentheses, and then `:`.
    The rest of the function is a code block and is indented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'If a string using multiline syntax is provided first in the indented block,
    it acts as documentation. Use these to describe what your function does, how parameters
    work, and what it can be expected to return. You will find these docstrings are
    invaluable for communicating with future users of your code. Various programs
    and services also use them to create documentation. Providing docstrings is considered
    a best practice and is highly recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Function arguments occur in the parentheses following the function name. They
    can be either positional or keyword. Positional arguments use the order of the
    arguments to assign value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'With keyword arguments, assign each argument a default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The default values are used when no values are passed during function invocation.
    The keyword parameters can be called by name during function invocation, in which
    case the order will not matter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'When using keyword parameters, all parameters defined after a keyword parameter
    must be keyword parameters as well. All functions return a value. The `return`
    keyword is used to set this value. If not set from a function definition, the
    function returns `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Functions as Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions are objects. They can be passed around, or stored in data structures.
    You can define two functions, put them in a list, and then iterate through the
    list to invoke them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Anonymous Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you need to create a very limited function, you can create an unnamed
    (anonymous) one using the `lambda` keyword. Generally, you should limit their
    use to situations where a function expects a small function as a argument. In
    this example, you take a list of lists and sort it. The default sorting mechanism
    compares based on the first item of each sublist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort based on something other than the first entry, you can define a method
    which returns the item’s second entry and pass it into the sorting function’s
    `key` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `lambda` keyword, you can do the same thing without the full function
    definition. Lambdas work with the `lambda` keyword followed by a parameter name,
    a colon, and a return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Sort using lambdas, first using the second entry and then using the third:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Be cautious of using lambdas more generally, as they can create code that is
    poorly documented and confusing to read if used in place of general functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The need to match patterns in strings comes up again and again. You could be
    looking for an identifier in a log file or checking user input for keywords or
    a myriad of other cases. You have already seen simple pattern matching using the
    `in` operation for sequences, or the string `.endswith` and `.startswith` methods.
    To do more sophisticated matching, you need a more powerful tool. Regular expressions,
    often referred to as regex, are the answer. Regular expressions use a string of
    characters to define search patterns. The Python `re` package offers regular expression
    operations similar to those found in Perl. The `re` module uses backslashes (*\*)
    to delineate special characters used in matching. To avoid confusion with regular
    string escape sequences, raw strings are recommended when defining regular expression
    patterns. Raw strings are prepended with an *r* before the first quotation mark.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Python strings have several escape sequences. Among the most common are line-feed
    `\n` and tab `\t`.
  prefs: []
  type: TYPE_NORMAL
- en: Searching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let say you have a cc list from an email as a text and you want to understand
    more about who is in this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to know whether a name is in this text, you could use the `in`
    sequence membership syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'To get similar behavior, you can use the `re.search` function, which returns
    a `re.Match` object only if there is a match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this as a condition to test for membership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Character Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far `re` hasn’t given you anything you couldn’t get using the `in` operator.
    However, what if you are looking for a person in a text, but you can’t remember
    if the name is *Bobbi* or *Robby*?
  prefs: []
  type: TYPE_NORMAL
- en: 'With regular expressions, you can use groups of characters, any one of which
    could appear in a spot. These are called character sets. The characters from which
    a match should be chosen are enclosed by square brackets in the regular expression
    definition. You can match on *B* or *R*, followed by *obb*, and either *i* or
    *y*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'You can put comma-separated individual characters in a character set or use
    ranges. The range *A–Z* includes all the capitalized letters; the range *0–9*
    includes the digits from zero to nine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The *+* after an item in a regular expression matches one or more of that item.
    A number in brackets matches an exact number of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We can construct a match using a combination of character sets and other characters
    to make a naive match of an email address. The *.* character has a special meaning.
    It is a wildcard and matches any character. To match against the actual *.* character,
    you must escape it using a backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This example is just a demonstration of character sets. It does not represent
    the full complexity of a production-ready regular expressions for emails.
  prefs: []
  type: TYPE_NORMAL
- en: Character Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to character sets, Python’s `re` offers character classes. These
    are premade character sets. Some commonly used ones are `\w`, which is equivalent
    to `[a-zA-Z0-9_]` and `\d`, which is equivalent to `[0-9]`. You can use the *+*
    modifier to match for multiple characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can replace our primative email matcher with `\w`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use parentheses to define groups in a match. These groups can be accessed
    from the match object. They are numbered in the order they appear, with the zero
    group being the full match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Named Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also supply names for the groups by adding `?P<NAME>` in the group
    definition. Then you can access the groups by name instead of number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Find All
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up until now, we have demonstrated returning just the first match found. We
    can also use `findall` to return all of the matches as a list of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Find Iterator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When dealing with large texts, such as logs, it is useful to not process the
    text all at once. You can produce an *iterator* object using the `finditer` method.
    This object processes text until it finds a match and then stops. Passing it to
    the `next` function returns the current match and continues processing until finding
    the next match. In this way, you can deal with each match individually without
    devoting resources to process all of the input at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The iterator object, `matched`, can be used in a `for` loop as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Substitution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides searching and matching, regexes can be used to substitute part or all
    of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Compiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the examples so far have called methods on the `re` module directly.
    This is adequate for many cases, but if the same match is going to happen many
    times, performance gains can be had by compiling the regular expression into an
    object. This object can be reused for matches without recompiling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions offer many more features than we have dealt with here. Indeed
    many books have been written on their use, but you should now be prepared for
    most basic cases.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy Evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Lazy evaluation* is the idea that, especially when dealing with large amounts
    of data, you do not want process all of the data before using the results. You
    have already seen this with the `range` type, where the memory footprint is the
    same, even for one representing a large group of numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use generators in a similar way as `range` objects. They perform some
    operation on data in chunks as requested. They pause their state in between calls.
    This means that you can store variables that are needed to calculate output, and
    they are accessed every time the generator is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a generator function, use the `yield` keyword rather than a return
    statement. Every time the generator is called, it returns the value specified
    by `yield` and then pauses its state until it is next called. Let’s write a generator
    that simply counts, returning each subsequent number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the generator keeps track of its state, and hence the variable `n`
    in each call to the generator reflects the value previously set. Let’s implement
    a Fibonacci generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also iterate using the generator in a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Generator Comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use generator comprehensions to create one-line generators. They are
    created using a syntax similar to list comprehensions, but parentheses are used
    rather than square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Even with this small example, we can see the difference in memory used by using
    the `sys.getsizeof` method, which returns the size of an object, in bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: More IPython Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You saw some of IPython’s features at the beginning of the chapter. Now let’s
    look at some more advanced features, such as running shell commands from within
    the IPython interpreter and using magic functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using IPython to Run Unix Shell Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use IPython to run shell commands. This is one of the most compelling
    reasons to perform DevOps actions in the IPython shell. Let’s take a look at a
    very simple example where the `!` character, which IPython uses to identify shell
    commands, is put in front of the command `ls`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is assigned to a Python variable `var_ls`. The `type`
    of this variable is `IPython.utils.text.SList`. The `SList` type converts a regular
    shell command into an object that has three main methods: `fields`, `grep`, and
    `sort`. Here is an example in action using the Unix `df` command. The `sort` method
    can interpret the whitespace from this Unix command and then sort the third column
    by size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at `SList` and `.grep` next. Here is an example that searches
    for what commands with `kill` as part of their names are installed in the */usr/bin*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The key take away here is that IPython is a dream environment for hacking around
    with little shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Using IPython magic commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you get in the habit of using IPython, you should also get in the habit
    of using built-in magic commands. They are essentially shortcuts that pack a big
    punch. Magic commands are indicated by prepending them with `%%`. Here is an example
    of how to write inline Bash inside of IPython. Note, this is just a small command,
    but it could be an entire Bash script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The `%%writefile` is pretty tricky because you can write and test Python or
    Bash scripts on the fly, using IPython to execute them. That’s not a bad party
    trick at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Another very useful command, `%who`, will show you what is loaded into memory.
    It comes in quite handy when you have been working in a terminal that has been
    running for a long time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a Python function that takes a name as an argument and prints that name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a Python function that takes a string as an argument and prints whether
    it is upper- or lowercase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a list comprehension that results in a list of every letter in the word
    *smogtether* capitalized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a generator that alternates between returning *Even* and *Odd*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
