<html><head></head><body>
<div id="sbo-rt-content"><section data-nutshell-tab="Modules and Packages" data-pdf-bookmark="Chapter 7. Modules and Packages" data-type="chapter" epub:type="chapter"><div class="chapter" id="modules_and_packages">
<h1><span class="label">Chapter 7. </span>Modules and Packages</h1>
<p>A<a contenteditable="false" data-primary="modules" data-secondary="definition of term" data-type="indexterm" id="idm44924567810912"/> typical Python program is made up of several source files. Each source file is a <em>module</em>, grouping code and data for reuse. Modules are normally independent of each other, so that other programs can reuse the specific modules they need. Sometimes, to manage complexity, developers group together related modules into a<a contenteditable="false" data-primary="packages" data-secondary="definition of term" data-type="indexterm" id="idm44924567808960"/> <em>package</em>—a hierarchical, tree-like structure of related modules and subpackages.</p>
<p>A<a contenteditable="false" data-primary="modules" data-secondary="basics of" data-type="indexterm" id="idm44924567806592"/> module explicitly establishes dependencies upon other modules by using <span class="code"><strong>import</strong></span> or <span class="code"><strong>from</strong></span> statements. In some programming languages, global variables provide a hidden conduit for coupling between modules. In Python, global variables are not global to all modules, but rather are attributes of a single module object. Thus, Python modules always communicate in explicit and maintainable ways, clarifying the couplings between them by making them explicit.</p>
<p>Python<a contenteditable="false" data-primary="extension modules" data-secondary="benefits of" data-type="indexterm" id="idm44924567802752"/> also supports <em>extension modules</em>—modules coded in other languages such as C, C++, Java, C#, or Rust. For the Python code importing a module, it does not matter whether the module is pure Python or an extension. You can always start by coding a module in Python. Should you need more speed later, you can refactor and recode some parts of your module in lower-level languages, without changing the client code that uses the module. <a data-type="xref" href="ch25.xhtml#extending_and_embedding_classic_python">Chapter 25</a> (available <a href="https://oreil.ly/python-nutshell-25">online</a>) shows how to write extensions in C and <a contenteditable="false" data-primary="Cython" data-type="indexterm" id="idm44924567799136"/>Cython.</p>
<p>This chapter discusses module creation and loading. It also covers grouping modules into packages, using <a href="https://oreil.ly/c4JWE"><span class="code">setuptools</span></a> to install packages, and how to prepare packages for distribution; this latter subject is more thoroughly covered in <a data-type="xref" href="ch24.xhtml#packaging_programs_and_extensions">Chapter 24</a> (also available <a href="https://oreil.ly/python-nutshell-24">online</a>). We close this chapter with a discussion of how best to manage your Python <span class="keep-together">environment(s)</span> .</p>
<section data-pdf-bookmark="Module Objects" data-type="sect1"><div class="sect1" id="module_objects">
<h1>Module Objects</h1>
<p>In<a contenteditable="false" data-primary="modules" data-secondary="module objects" data-type="indexterm" id="Mobje07"/> Python, a module is an object with arbitrarily named attributes that you can bind and reference. Modules in Python are handled like other objects. Thus, you can pass a module as an argument in a call to a function. Similarly, a function can return a module as the result of a call. A module, just like any other object, can be bound to a variable, an item in a container, or an attribute of an object. Modules can be keys or values in a dictionary, and can be members of a set. For example, the <span class="code">sys.modules</span> dictionary, discussed in <a data-type="xref" href="#module_loading">“Module Loading”</a>, holds module objects as its values. The fact that modules can be treated like other values in Python is often expressed by saying that modules are <em>first-class</em> objects.</p>
<section data-pdf-bookmark="The import Statement" data-type="sect2"><div class="sect2" id="the_import_statement">
<h2>The import Statement</h2>
<p>The<a contenteditable="false" data-primary="import" data-secondary="import statement" data-type="indexterm" id="importstat07"/> Python code for a module named <span class="code"><em>aname</em></span> usually lives in a file named <em>aname.py</em>, as covered in <a data-type="xref" href="#searching_the_filesystem_for_a_module">“Searching the Filesystem for a Module”</a>. You can use any Python source file<sup><a data-type="noteref" href="ch07.xhtml#ch01fn81" id="ch01fn81-marker">1</a></sup> as a module by executing an <span class="code"><strong>import</strong></span> statement in another Python source file. <span class="code"><strong>import</strong></span> has the following syntax:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><em><code class="nn">modname</code></em><code> </code><code class="p">[</code><strong><code class="k">as</code></strong><code> </code><em><code class="n">varname</code></em><code class="p">]</code><code class="p">[</code><code class="p">,</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code class="p">]</code></pre>
<p>After the <span class="code"><strong>import</strong></span> keyword come one or more module specifiers separated by commas. In the simplest, most common case, a module specifier is just <span class="code"><em>modname</em></span>, an identifier—a variable that Python binds to the module object when the <span class="code"><strong>import</strong></span> statement finishes. In this case, Python looks for the module of the same name to satisfy the <span class="code"><strong>import</strong></span> request. For example, this statement:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">mymodule</code></pre>
<p>looks for the module named <span class="code">mymodule</span> and binds the variable named <span class="code">mymodule</span> in the current scope to the module object. <span class="code"><em>modname</em></span> can also be a sequence of identifiers separated by<a contenteditable="false" data-primary=". (period)" data-secondary="import statement" data-type="indexterm" id="idm44924567730880"/><a contenteditable="false" data-primary="period (.)" data-secondary="import statement" data-type="indexterm" id="idm44924567729536"/> dots (<span class="code">.</span>) to name a module contained in a package, as covered in <a data-type="xref" href="#packages">“Packages”</a>.</p>
<p>When <span class="code"><strong>as</strong></span> <span class="code"><em>varname</em></span> is part of a module specifier, Python looks for a module named <span class="code"><em>modname</em></span> and binds the module object to the variable <span class="code"><em>varname</em></span>. For example, this:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">mymodule</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="nn">alias</code></pre>
<p>looks for the module named <span class="code">mymodule</span> and binds the module object to the variable <span class="code"><em>alias</em></span> in the current scope. <span class="code"><em>varname</em></span> must always be a simple identifier.</p>
<section data-pdf-bookmark="The module body" data-type="sect3"><div class="sect3" id="the_module_body">
<h3>The module body</h3>
<p>The <em>body</em> of a module is the sequence of statements in the module’s source file. There is no special syntax required to indicate that a source file is a module; as mentioned previously, you can use any valid Python source file as a module. A module’s body executes immediately the first time a given run of a program imports it. When the body starts executing, the module object has already been created, with an entry in <span class="code">sys.modules</span> already bound to the module object. The module’s (global) namespace is gradually populated as the module’s body executes.</p>
</div></section>
<section data-pdf-bookmark="Attributes of module objects" data-type="sect3"><div class="sect3" id="attributes_of_module_objects">
<h3>Attributes of module objects</h3>
<p>An <span class="code"><strong>import</strong></span> statement creates a new namespace containing all the attributes of the module. To access an attribute in this namespace, use the name or alias of the module as a prefix:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">mymodule</code><code>
</code><code class="n">a</code><code> </code><code class="o">=</code><code> </code><code class="n">mymodule</code><code class="o">.</code><code class="n">f</code><code class="p">(</code><code class="p">)</code></pre>
<p>or:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">mymodule</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="nn">alias</code><code>
</code><code class="n">a</code><code> </code><code class="o">=</code><code> </code><code class="n">alias</code><code class="o">.</code><code class="n">f</code><code class="p">(</code><code class="p">)</code></pre>
<p>This reduces the time it takes to import the module and ensures that only those applications that use that module incur the overhead of creating it.</p>
<p>Normally, it is the statements in the module body that bind the attributes of a module object. When a statement in the module body binds a (global) variable, what gets bound is an attribute of the module object.</p>
<div data-type="tip">
<h1>A Module Body Exists to Bind the Module’s Attributes</h1>
<p>The normal purpose of a module body is to create the module’s attributes: <span class="code"><strong>def</strong></span> statements create and bind functions, <span class="code"><strong>class</strong></span> statements create and bind classes, and assignment statements can bind attributes of any type. For clarity and cleanliness in your code, be wary about doing anything else in the top logical level of the module’s body <em>except</em> binding the module’s attributes.</p>
</div>
<p>A<a contenteditable="false" data-primary="__getattr__ (special method)" data-type="indexterm" id="idm44924567623008"/> <span class="code">__getattr__</span> function defined at module scope can dynamically create new module attributes. One possible reason for doing so would be to lazily define attributes that are time-consuming to create; defining them in a module-level <span class="code">__getattr__</span> function defers the creation of the attributes until they are actually referenced, if ever. For instance, this code could be added to <em>mymodule.py</em> to defer the creation of a list containing the first million prime numbers, which can take some time to compute:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="fm">__getattr__</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">if</code></strong><code> </code><code class="n">name</code><code> </code><code class="o">==</code><code> </code><code class="s1">'</code><code class="s1">first_million_primes</code><code class="s1">'</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">def</code></strong><code> </code><code class="nf">generate_n_primes</code><code class="p">(</code><code class="n">n</code><code class="p">)</code><code class="p">:</code><code>
</code><code>            </code><em><code class="c1"># ... code to generate 'n' prime numbers ...</code></em><code>
</code><code>
</code><code>        </code><strong><code class="kn">import</code></strong><code> </code><code class="nn">sys</code><code>
</code><code>        </code><em><code class="c1"># Look up __name__ in sys.modules to get current module</code></em><code>
</code><code>        </code><code class="n">this_module</code><code> </code><code class="o">=</code><code> </code><code class="n">sys</code><code class="o">.</code><code class="n">modules</code><code class="p">[</code><code class="vm">__name__</code><code class="p">]</code><code>
</code><code>        </code><code class="n">this_module</code><code class="o">.</code><code class="n">first_million_primes</code><code> </code><code class="o">=</code><code> </code><code class="n">generate_n_primes</code><code class="p">(</code><code class="mi">1_000_000</code><code class="p">)</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="n">this_module</code><code class="o">.</code><code class="n">first_million_primes</code><code>
</code><code>
</code><code>    </code><strong><code class="k">raise</code></strong><code> </code><code class="ne">AttributeError</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">module </code><code class="si">{</code><code class="vm">__name__</code><code class="si">!r}</code><code>
</code><code>	                  </code><code class="sa">f</code><code class="s1">'</code><code class="s1"> has no attribute </code><code class="si">{</code><code class="n">name</code><code class="si">!r}</code><code class="s1">'</code><code class="p">)</code></pre>
<p>Using a module-level <span class="code">__getattr__</span> function has only a small impact on the time to import <em>mymodule.py</em>, and only those applications that actually use <span class="code keep-together">mymodule.first_million_primes</span> will incur the overhead of creating it.</p>
<p>You can also bind module attributes in code outside the body (i.e., in other modules); just assign a value to the attribute reference syntax <span class="code"><em>M.name</em></span> (where <span class="code"><em>M</em></span> is any expression whose value is the module, and the identifier <span class="code"><em>name</em></span> is the attribute name). For clarity, however, it’s best to bind module attributes only in the module’s own body.</p>
<p>The <span class="code"><strong>import</strong></span> statement binds some module attributes as soon as it creates the module object, before the module’s body executes. The <span class="code">__dict__</span> attribute is the <span class="code">dict</span> object that the module uses as the namespace for its attributes. Unlike other attributes of the module, <span class="code">__dict__</span> is not available to code in the module as a global variable. All other attributes in the module are items in <span class="code">__dict__</span> and are available to code in the module as global variables. The <span class="code">__name__</span> attribute is the module’s name, and <span class="code">__file__</span> is the filename from which the module was loaded; other<a contenteditable="false" data-primary="dunder (double underscore)" data-secondary="module metadata" data-type="indexterm" id="idm44924567481536"/> dunder-named attributes hold other module metadata. (See also <a data-type="xref" href="#special_attributes_of_package_objects">“Special Attributes of Package Objects”</a> for details on the attribute <span class="code">__path__</span>, in packages only.)</p>
<p>For any module object <span class="code"><em>M</em></span>, any object <span class="code"><em>x</em></span>, and any identifier string <span class="code"><em>S</em></span> (except <span class="code">__dict__</span>), binding <span class="code"><em>M.S = x</em></span> is equivalent to binding <span class="code"><em>M</em></span><span class="code">.__dict__['<em>S</em>'] =</span> <span class="code"><em>x</em></span>. An attribute reference such as <span class="code"><em>M.S</em></span> is also substantially equivalent to <span class="code"><em>M.__dict__</em></span><span class="code">['<em>S</em>']</span>. The only difference is that, when <span class="code"><em>S</em></span> is not a key in <span class="code"><em>M</em></span><span class="code">.__dict__</span>, accessing <span class="code"><em>M</em></span><span class="code">.__dict__['<em>S</em>']</span> raises <span class="code">KeyError</span>, while accessing <span class="code"><em>M.S</em></span> raises <span class="code">AttributeError</span>. Module attributes are also available to all code in the module’s body as global variables. In other words, within the module body, <span class="code"><em>S</em></span> used as a global variable is equivalent to <span class="code"><em>M.S</em></span> (i.e., <span class="code"><em>M</em></span><span class="code">.__dict__['<em>S</em>']</span>) for both binding and reference (when <span class="code"><em>S</em></span> is <em>not</em> a key in <span class="code"><em>M</em></span><span class="code">.__dict__</span>, however, referring to <span class="code"><em>S</em></span> as a global variable raises <span class="code">NameError</span>).</p>
</div></section>
<section data-pdf-bookmark="Python built-ins" data-type="sect3"><div class="sect3" id="python_built_ins">
<h3>Python built-ins</h3>
<p>Python<a contenteditable="false" data-primary="objects" data-secondary="built-in object type" data-type="indexterm" id="idm44924567452880"/> supplies many built-in objects (covered in <a data-type="xref" href="ch08.xhtml#core_built_ins_and_standard_library_mod">Chapter 8</a>). All built-in objects are attributes of a preloaded module named <span class="code">builtins</span>. When Python loads a module, the module automatically gets an extra attribute named <span class="code">__builtins__</span>, which refers either to the module <span class="code">builtins</span> or to its dictionary. Python may choose either, so don’t rely<a contenteditable="false" data-primary="__builtins__ dictionary" data-type="indexterm" id="idm44924567448064"/> on <span class="code">__builtins__</span>. If you need to access the module <span class="code">builtins</span> directly (a rare need), use an <span class="code"><strong>import</strong></span> <span class="code">builtins</span> statement. When you access a variable found neither in the local namespace nor in the global namespace of the current module, Python looks for the identifier in the current module’s <span class="code">__builtins__</span> before raising <span class="code">NameError</span>.</p>
<p>The lookup is the only mechanism that Python uses to let your code access built-ins. Your own code can use the access mechanism directly (do so in moderation, however, or your program’s clarity and simplicity will suffer). The built-ins’ names are not reserved, nor are they hardwired in Python itself—you can add your own built-ins or substitute your functions for the normal built-in ones, in which case all modules see the added or replaced ones. Since Python accesses built-ins only when it cannot resolve a name in the local or module namespace, it is usually sufficient to define a replacement in one of those namespaces. The following toy example shows how you can wrap a built-in function with your own function, allowing <span class="code">abs</span> to take a string argument (and return a rather arbitrary mangling of the string):</p>
<pre data-code-language="python" data-type="programlisting">
<em><code class="c1"># abs takes a numeric argument; let's make it accept a string as well</code></em><code>
</code><strong><code class="kn">import</code></strong><code> </code><code class="nn">builtins</code><code>
</code><code class="n">_abs</code><code> </code><code class="o">=</code><code> </code><code class="n">builtins</code><code class="o">.</code><code class="n">abs</code><code>                       </code><em><code class="c1"># save original built-in</code></em><code>
</code><strong><code class="k">def</code></strong><code> </code><code class="nf">abs</code><code class="p">(</code><code class="n">str_or_num</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">if</code></strong><code> </code><code class="nb">isinstance</code><code class="p">(</code><code class="n">str_or_num</code><code class="p">,</code><code> </code><code class="nb">str</code><code class="p">)</code><code class="p">:</code><code>       </code><em><code class="c1"># if arg is a string</code></em><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="s1">'</code><code class="s1">'</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="nb">sorted</code><code class="p">(</code><code class="nb">set</code><code class="p">(</code><code class="n">str_or_num</code><code class="p">)</code><code class="p">)</code><code class="p">)</code><code>  </code><em><code class="c1"># get this instead</code></em><code>
</code><code>    </code><strong><code class="k">return</code></strong><code> </code><code class="n">_abs</code><code class="p">(</code><code class="n">str_or_num</code><code class="p">)</code><code>               </code><em><code class="c1"># call real built-in</code></em><code>
</code><code class="n">builtins</code><code class="o">.</code><code class="n">abs</code><code> </code><code class="o">=</code><code> </code><code class="nb">abs</code><code>                        </code><em><code class="c1"># override built-in w/wrapper</code></em></pre>
</div></section>
<section data-pdf-bookmark="Module documentation strings" data-type="sect3"><div class="sect3" id="module_documentation_strings">
<h3>Module documentation strings</h3>
<p>If<a contenteditable="false" data-primary="__doc__ attribute" data-type="indexterm" id="idm44924567361840"/> the first statement in the module body is a string literal, Python binds that string as the module’s documentation string attribute, named <span class="code">__doc__</span>. For more information on documentation strings, see <a data-type="xref" href="ch03.xhtml#docstrings">“Docstrings”</a>.</p>
</div></section>
<section data-pdf-bookmark="Module-private variables" data-type="sect3"><div class="sect3" id="module_private_variables">
<h3>Module-private variables</h3>
<p>No<a contenteditable="false" data-primary="variables and other references" data-secondary="module-private variables" data-type="indexterm" id="idm44924567371872"/><a contenteditable="false" data-primary="private versus public variables" data-type="indexterm" id="idm44924567370528"/> variable of a module is truly private. However, by convention, every identifier starting with a<a contenteditable="false" data-primary="underscore (_)" data-secondary="module-private variables" data-type="indexterm" id="idm44924567369216"/><a contenteditable="false" data-primary="_ (underscore)" data-secondary="module-private variables" data-type="indexterm" id="idm44924567338720"/> single underscore (<span class="code">_</span>), such as <span class="code">_secret</span>, is <em>meant</em> to be private. In other words, the leading underscore communicates to client-code programmers that they should not access the identifier directly.</p>
<p>Development environments and other tools rely on the leading underscore naming convention to discern which attributes of a module are public (i.e., part of the module’s interface) and which are private (i.e., to be used only within the module).</p>
<div data-type="tip">
<h1>Respect the “Leading Underscore Means Private” Convention</h1>
<p>It’s important to respect the convention that a leading underscore means private, particularly when you write client code that uses modules written by others. Avoid using any attributes in such modules whose names start with <span class="code">_</span>. Future releases of the modules will strive to maintain their public interface, but are quite likely to change private implementation details: private attributes are meant exactly for such details.<a contenteditable="false" data-primary="" data-startref="importstat07" data-type="indexterm" id="idm44924567332752"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="The from Statement" data-type="sect2"><div class="sect2" id="the_from_statement">
<h2>The from Statement</h2>
<p>Python’s<a contenteditable="false" data-primary="as (import statement)" data-type="indexterm" id="idm44924567329392"/><a contenteditable="false" data-primary="from ... import" data-type="indexterm" id="frmimp07"/> <span class="code"><strong>from</strong></span> statement lets you import specific attributes from a module into the current namespace. <span class="code"><strong>from</strong></span> has two syntax variants:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">from</code></strong><code> </code><em><code class="nn">modname</code></em><code> </code><strong><code class="kn">import</code></strong><code> </code><em><code class="n">attrname</code></em><code> </code><code class="p">[</code><strong><code class="k">as</code></strong><code> </code><em><code class="n">varname</code></em><code class="p">]</code><code class="p">[</code><code class="p">,</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code class="p">]</code><code>
</code><strong><code class="kn">from</code></strong><code> </code><em><code class="nn">modname</code></em><code> </code><strong><code class="kn">import</code></strong><code> </code><code class="o">*</code></pre>
<p>A <span class="code"><strong>from</strong></span> statement specifies a module name, followed by one or more attribute specifiers separated by commas. In the simplest and most common case, an attribute specifier is just an identifier <span class="code"><em>attrname</em></span>, which is a variable that Python binds to the attribute of the same name in the module named <span class="code"><em>modname</em></span>. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">from</code></strong><code> </code><code class="nn">mymodule</code><code> </code><strong><code class="kn">import</code></strong><code> </code><code class="n">f</code></pre>
<p><span class="code"><em>modname</em></span> can also be a sequence of identifiers separated by dots (<span class="code">.</span>) to name a module within a package, as covered in <a data-type="xref" href="#packages">“Packages”</a>.</p>
<p>When <span class="code"><strong>as</strong></span> <span class="code"><em>varname</em></span> is part of an attribute specifier, Python gets the value of the attribute <span class="code"><em>attrname</em></span> from the module and binds it to the variable <span class="code"><em>varname</em></span>. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">from</code></strong><code> </code><code class="nn">mymodule</code><code> </code><strong><code class="kn">import</code></strong><code> </code><code class="n">f</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">foo</code></pre>
<p><span class="code"><em>attrname</em></span> and <span class="code"><em>varname</em></span> are always simple identifiers.</p>
<p>You may optionally enclose in parentheses all the attribute specifiers that follow the keyword <span class="code"><strong>import</strong></span> in a <span class="code"><strong>from</strong></span> statement. This can be useful when you have many attribute specifiers, in order to split the single logical line of the <span class="code"><strong>from</strong></span> statement into multiple logical lines more elegantly than by using backslashes (<span class="code">\</span>):</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">from</code></strong><code> </code><code class="nn">some_module_with_a_long_name</code><code> </code><strong><code class="kn">import</code></strong><code> </code><code class="p">(</code><code>
</code><code>    </code><code class="n">another_name</code><code class="p">,</code><code> </code><code class="n">and_another</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">x</code><code class="p">,</code><code> </code><code class="n">one_more</code><code class="p">,</code><code> </code><code class="n">and_yet_another</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">y</code><code class="p">)</code></pre>
<section data-pdf-bookmark="from...import *" data-type="sect3"><div class="sect3" id="fromdotdotdotimport_asterisk">
<h3>from...import *</h3>
<p>Code that is directly inside a module body (not in the body of a function or class) may use an<a contenteditable="false" data-primary="asterisk (*)" data-secondary="import statement" data-type="indexterm" id="idm44924567186016"/><a contenteditable="false" data-primary="* (asterisk)" data-secondary="import statement" data-type="indexterm" id="idm44924567184640"/> asterisk (<span class="code">*</span>) in a <span class="code"><strong>from</strong></span> statement:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">from</code></strong><code> </code><code class="nn">mymodule</code><code> </code><strong><code class="kn">import</code></strong><code> </code><code class="o">*</code></pre>
<p>The <span class="code">*</span> requests that “all” attributes of module <span class="code"><em>modname</em></span> be bound as global variables in the importing module. When module <span class="code"><em>modname</em></span> has an attribute named <span class="code">__all__</span>, the attribute’s value is the list of the attribute names that this type of <span class="code"><strong>from</strong></span> statement binds. Otherwise, this type of <span class="code"><strong>from</strong></span> statement binds all attributes of <span class="code"><em>modname</em></span> except those beginning with underscores.</p>
<div data-type="warning" epub:type="warning">
<h1>Beware Using “from M import *” in Your Code</h1>
<p>Since<a contenteditable="false" data-primary="import" data-secondary="from M import" data-type="indexterm" id="idm44924567142512"/> <span class="code"><strong>from</strong></span> <span class="code"><em>M</em></span> <span class="code"><strong>import</strong></span> <span class="code">*</span> may bind an arbitrary set of global variables, it can have unforeseen, undesired side effects, such as hiding built-ins and rebinding variables you still need. Use the <span class="code">*</span> form of <span class="code"><strong>from</strong></span> very sparingly, if at all, and only to import modules that are explicitly documented as supporting such usage. Your code is most likely better off <em>never</em> using this form, which is meant mostly as a convenience for occasional use in interactive Python sessions.</p>
</div>
</div></section>
<section data-pdf-bookmark="from versus import" data-type="sect3"><div class="sect3" id="from_versus_import">
<h3>from versus import</h3>
<p>The<a contenteditable="false" data-primary="import" data-secondary="import statement" data-type="indexterm" id="idm44924567117264"/> <span class="code"><strong>import</strong></span> statement is often a better choice than the <span class="code"><strong>from</strong></span> statement. When you always access module <span class="code"><em>M</em></span> with the statement <span class="code"><strong>import</strong></span> <span class="code"><em>M</em></span>, and always access <span class="code"><em>M</em></span>’s attributes with the explicit syntax <span class="code"><em>M.A</em></span>, your code is slightly less concise but far clearer and more readable. One good use of <span class="code"><strong>from</strong></span> is to import specific modules from a package, as we discuss in <a data-type="xref" href="#packages">“Packages”</a>. In most other cases, <span class="code"><strong>import</strong></span> is better style than <span class="code"><strong>from</strong></span>.<a contenteditable="false" data-primary="" data-startref="Mobje07" data-type="indexterm" id="idm44924567105888"/></p>
</div></section>
<section data-pdf-bookmark="Handling import failures" data-type="sect3"><div class="sect3" id="handling_import_failures">
<h3>Handling import failures</h3>
<p>If<a contenteditable="false" data-primary="import" data-secondary="import failures" data-type="indexterm" id="idm44924567102928"/> you are importing a module that is not part of standard Python and wish to handle import failures, you can do so by catching the <span class="code">ImportError</span> exception. For instance, if your code does optional output formatting using the third-party <span class="code">rich</span> module, but falls back to regular output if that module has not been installed, you would import the module using:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="k">try</code><code class="p">:</code><code>
</code><strong><code>    </code><code class="kn">import</code></strong><code> </code><code class="nn">rich</code><code>
</code><strong><code class="k">except</code></strong><code> </code><code class="ne">ImportError</code><strong><code class="p">:</code></strong><code>
</code><strong><code>   </code></strong><code> </code><code class="n">rich</code><code> </code><code class="o">=</code><code> </code><strong><code class="kc">None</code></strong></pre>
<p>Then, in the output portion of your program, you would<a contenteditable="false" data-primary="" data-startref="frmimp07" data-type="indexterm" id="idm44924567078880"/> write:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">if</code></strong><code> </code><code class="n">rich</code><code> </code><strong><code class="ow">is</code><code> </code><code class="ow">not</code><code> </code><code class="kc">None</code></strong><code class="p">:</code><code>
</code><code>	</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code> </code><code class="n">output</code><code> </code><code class="n">using</code><code> </code><code class="n">rich</code><code> </code><code class="n">module</code><code> </code><code class="n">features</code><code> </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><strong><code class="k">else</code></strong><code class="p">:</code><code>
</code><code>	</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code> </code><code class="n">output</code><code> </code><code class="n">using</code><code> </code><code class="n">normal</code><code> </code><code class="nb">print</code><code class="p">(</code><code class="p">)</code><code> </code><code class="n">statements</code><code> </code><code class="o">.</code><code class="o">.</code><code class="o">.</code></pre>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Module Loading" data-type="sect1"><div class="sect1" id="module_loading">
<h1>Module Loading</h1>
<p>Module-loading operations<a contenteditable="false" data-primary="modules" data-secondary="module-loading operations" data-type="indexterm" id="Mload07"/> rely on attributes of the built-in <span class="code">sys</span> module (covered in <a data-type="xref" href="ch08.xhtml#the_sys_module">“The sys Module”</a>) and are implemented in the built-in function <span class="code">__import__</span>. Your code could call <span class="code">__import__</span> directly, but this is strongly discouraged in modern Python; rather, <span class="code"><strong>import</strong></span> <span class="code">importlib</span> and call <span class="code">importlib.import_module</span> with the module name string as the argument. <span class="code">import_module</span> returns the module object or, should the import fail, raises <span class="code">ImportError</span>. However, it’s best to have a clear understanding of the semantics of <span class="code">__import__</span>, because <span class="code">import_module</span> and <span class="code"><strong>import</strong></span> statements both depend on it.</p>
<p>To import a module named <span class="code"><em>M</em></span>, <span class="code">__import__</span> first checks the dictionary <span class="code">sys.modules</span>, using the string <span class="code"><em>M</em></span> as the key. When the key <span class="code"><em>M</em></span> is in the dictionary, <span class="code">__import__</span> returns the corresponding value as the requested module object. Otherwise, <span class="code">__import__</span> binds <span class="code">sys.modules[<em>M</em>]</span> to a new empty module object with a <span class="code">__name__</span> of <span class="code"><em>M</em></span>, then looks for the right way to initialize (load) the module, as covered in the upcoming section on searching the filesystem for a module.</p>
<p>Thanks to this mechanism, the relatively slow loading operation takes place only the first time a module is imported in a given run of the program. When a module is imported again, the module is not reloaded, since <span class="code">__import__</span> rapidly finds and returns the module’s entry in <span class="code">sys.modules</span>. Thus, all imports of a given module after the first one are very fast: they’re just dictionary lookups. (To <em>force</em> a reload, see <a data-type="xref" href="#reloading_modules">“Reloading Modules”</a>.)</p>
<section data-pdf-bookmark="Built-in Modules" data-type="sect2"><div class="sect2" id="built_in_modules">
<h2>Built-in Modules</h2>
<p>When<a contenteditable="false" data-primary="__import__ (built-in function)" data-type="indexterm" id="idm44924566969072"/> a module is loaded, <span class="code">__import__</span> first checks whether the module is a built-in. The tuple <span class="code">sys.builtin_module_names</span> names all built-in modules, but rebinding that tuple does not affect module loading. When it loads a built-in module, as when it loads any other extension, Python calls the module’s initialization function. The search for built-in modules also looks for modules in platform-specific locations, such as the Registry in Windows.</p>
</div></section>
<section data-pdf-bookmark="Searching the Filesystem for a Module" data-type="sect2"><div class="sect2" id="searching_the_filesystem_for_a_module">
<h2>Searching the Filesystem for a Module</h2>
<p>If<a contenteditable="false" data-primary="filesystem" data-secondary="searching for modules" data-type="indexterm" id="FSmod07"/> module <span class="code"><em>M</em></span> is not a built-in, <span class="code">__import__</span> looks for <span class="code"><em>M</em></span>’s code as a file on the filesystem. <span class="code">__import__</span> looks at the items of the list <span class="code">sys.path</span>, which are strings, in order. Each item is the path of a directory, or the path of an archive file in the popular <a href="https://oreil.ly/QrFfL">ZIP format</a>. <span class="code">sys.path</span> is initialized at program startup, using the environment variable <span class="code">PYTHONPATH</span> (covered in <a data-type="xref" href="ch02.xhtml#environment_variables">“Environment Variables”</a>), if present. The first item in <span class="code">sys.path</span> is always the directory from which the main program is loaded. An empty string in <span class="code">sys.path</span> indicates the current directory.</p>
<p>Your code can mutate or rebind <span class="code">sys.path</span>, and such changes affect which directories and ZIP archives <span class="code">__import__</span> searches to load modules. Changing <span class="code">sys.path</span> does <em>not</em> affect modules that are already loaded (and thus already recorded in <span class="code">sys.modules</span>).</p>
<p>If there is a text file with the extension <em>.pth</em> in the <span class="code">PYTHONHOME</span> directory at startup, Python adds the file’s contents to <span class="code">sys.path</span>, one item per line. <em>.pth</em> files can contain blank lines and comment lines starting with the character <span class="code">#</span>; Python ignores any such lines. <em>.pth</em> files can also contain <span class="code"><strong>import</strong></span> statements (which Python executes before your program starts to execute), but no other kinds of statements.</p>
<p>When looking for the file for module <span class="code"><em>M</em></span> in each directory and ZIP archive along <span class="code">sys.path</span>, Python considers the following extensions in this order:</p>
<ol>
<li>
<p><em>.pyd</em> and <em>.dll</em> (Windows) or <em>.so</em> (most Unix-like platforms), which indicate Python extension modules. (Some Unix dialects use different extensions; e.g., <em>.sl</em> on HP-UX.) On most platforms, extensions cannot be loaded from a ZIP archive—only source or bytecode-compiled Python modules can.</p>
</li>
<li>
<p><em>.py</em>, which indicates Python source modules.</p>
</li>
<li>
<p><em>.pyc</em>, which indicates bytecode-compiled Python modules.</p>
</li>
<li>
<p>When it finds a <em>.py</em> file, Python also looks for a directory called <em>__pycache__</em>. If it finds such a directory, Python looks in that directory for the extension <em>.&lt;tag&gt;.pyc</em>, where <em>&lt;tag&gt;</em> is a string specific to the version of Python that is looking for the module.</p>
</li>
</ol>
<p>One last path in which Python looks for the file for module <span class="code"><em>M</em></span> is <em>M</em><span class="code"><em>/</em></span><em>__init__.py</em>: a file named <em>__init__.py</em> in a directory named <em>M</em>, as covered in <a data-type="xref" href="#packages">“Packages”</a>.</p>
<p>Upon finding the source file <em>M.py</em>, Python compiles it to <em>M.&lt;tag&gt;.pyc</em>, unless the bytecode file is already present, is newer than <em>M.py</em>, and was compiled by the same version of Python. If <em>M.py</em> is compiled from a writable directory, Python creates a <em>__pycache__</em> subdirectory if necessary and saves the bytecode file to the filesystem in that subdirectory so that future runs won’t needlessly recompile it. When the bytecode file is newer than the source file (based on an internal timestamp in the bytecode file, not on trusting the date as recorded in the filesystem), Python does not recompile the module.</p>
<p>Once Python has the bytecode, whether built anew by compilation or read from the filesystem, Python executes the module body to initialize the module object. If the module is an extension, Python calls the module’s initialization function.</p>
<div data-type="warning" epub:type="warning">
<h1>Be Careful About Naming Your Project’s .py Files</h1>
<p>A<a contenteditable="false" data-primary="names and naming" data-secondary="project .py files" data-type="indexterm" id="idm44924566926080"/> common problem for beginners occurs when programmers writing their first few projects accidentally name one of their <em>.py</em> files with the same name as an imported package, or a module in the standard library (stdlib). For example, an easy mistake when learning the <span class="code">turtle</span> module is to name your program <em>turtle.py</em>. When Python then tries to import the <span class="code">turtle</span> module from the stdlib, it will load the local module instead, and usually raise some unexpected <span class="code">AttributeError</span>s shortly thereafter (since the local module does not include all the classes, functions, and variables defined in the stdlib module). Do not name your project <em>.py</em> files the same as imported or stdlib modules!</p>
<p>You can check whether a module name already exists using a command of the form <span class="code"><strong>python -m</strong></span> <span class="code"><strong><em>testname</em></strong></span>. If the message <span class="code">'no module</span> <span class="code"><em>testname</em></span><span class="code">'</span> is displayed, then you should be safe to name your module <em>testname.py</em>.</p>
<p>In general, as you become familiar with the modules in the stdlib and common package names, you will come to know what names to avoid.<a contenteditable="false" data-primary="" data-startref="FSmod07" data-type="indexterm" id="idm44924566915536"/></p>
</div>
</div></section>
<section data-pdf-bookmark="The Main Program" data-type="sect2"><div class="sect2" id="the_main_program">
<h2>The Main Program</h2>
<p>Execution<a contenteditable="false" data-primary="main program" data-type="indexterm" id="idm44924566912160"/> of a Python application starts with a top-level script (known as the <em>main program</em>), as explained in <a data-type="xref" href="ch02.xhtml#the_python_program">“The python Program”</a>. The main program executes like any other module being loaded, except that Python keeps the bytecode in memory, not saving it to disk. The module name for the main program is <span class="code">'__main__'</span>, both as the <span class="code">__name__</span> variable (module attribute) and as the key in <span class="code">sys.modules</span>.</p>
<div data-type="warning" epub:type="warning">
<h1>Don’t Import the .py File You’re Using as the Main Program</h1>
<p>You should not import the same <em>.py</em> file that is the main program. If you do, Python loads the module again, and the body executes again in a separate module object with a different <span class="code">__name__</span>.</p>
</div>
<p>Code in a Python module can test if the module is being used as the main program by checking if the global variable <span class="code">__name__</span> has the value <span class="code">'__main__'</span>. The idiom:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">if</code></strong><code> </code><code class="vm">__name__</code><code> </code><code class="o">==</code><code> </code><code class="s1">'</code><code class="s1">__main__</code><code class="s1">'</code><code class="p">:</code></pre>
<p>is often used to guard some code so that it executes only when the module runs as the main program. If a module is meant only to be imported, it should normally execute unit tests when run as the main program, as covered in <a data-type="xref" href="ch17.xhtml#unit_testing_and_system_testing">“Unit Testing and System Testing”</a>.</p>
</div></section>
<section data-pdf-bookmark="Reloading Modules" data-type="sect2"><div class="sect2" id="reloading_modules">
<h2>Reloading Modules</h2>
<p>Python loads a module only the first time you import the module during a program run. When you develop interactively, you need to <em>reload</em> your modules after editing them (some development environments provide automatic reloading).</p>
<p>To reload a module, pass the module object (<em>not</em> the module name) as the only argument to the function <span class="code">reload</span> from the <span class="code">importlib</span> module. <span class="code">importlib.reload(<em>M</em>)</span> ensures the reloaded version of <span class="code"><em>M</em></span> is used by client code that relies on <span class="code">import</span> <span class="code"><em>M</em></span> and accesses attributes with the syntax <span class="code"><em>M.A</em></span>. However, <span class="code">importlib.reload(<em>M</em>)</span> has no effect on other existing references bound to previous values of <span class="code"><em>M</em></span>’s attributes (e.g., with a <span class="code"><strong>from</strong></span> statement). In other words, already-bound variables remain bound as they were, unaffected by <span class="code">reload</span>. <span class="code">reload</span>’s inability to rebind such variables is a further incentive to use <span class="code"><strong>import</strong></span> rather than <span class="code"><strong>from</strong></span>.</p>
<p><span class="code">reload</span> is not recursive: when you reload module <span class="code"><em>M</em></span>, this does not imply that other modules imported by <span class="code"><em>M</em></span> get reloaded in turn. You must reload, by explicit calls to <span class="code">reload</span>, every module you have modified. Be sure to take into account any module reference dependencies, so that reloads are done in the proper order.</p>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Circular Imports" data-type="sect2"><div class="sect2" id="circular_imports">
<h2 class="less_space">Circular Imports</h2>
<p>Python<a contenteditable="false" data-primary="circular imports" data-type="indexterm" id="idm44924566850192"/> lets you specify circular imports. For example, you can write a module <em>a.py</em> that contains <span class="code"><strong>import</strong></span> <span class="code">b</span>, while module <em>b.py</em> contains <span class="code"><strong>import</strong></span> <span class="code">a</span>.</p>
<p>If you decide to use a circular import for some reason, you need to understand how circular imports work in order to avoid errors in your code.</p>
<div data-type="warning" epub:type="warning">
<h1>Avoid Circular Imports</h1>
<p>In practice, you are nearly always better off avoiding circular imports, since circular dependencies are fragile and hard to manage.</p>
</div>
<p>Say that the main script executes <span class="code"><strong>import</strong></span> <span class="code">a</span>. As discussed earlier, this <span class="code"><strong>import</strong></span> statement creates a new empty module object as <span class="code">sys.modules['a']</span>, then the body of module <span class="code">a</span> starts executing. When <span class="code">a</span> executes <span class="code"><strong>import</strong></span> <span class="code">b</span>, this creates a new empty module object as <span class="code">sys.modules['b']</span>, and then the body of module <span class="code">b</span> starts executing. <span class="code">a</span>’s module body cannot proceed until <span class="code">b</span>’s module body finishes.</p>
<p>Now, when <span class="code">b</span> executes <span class="code"><strong>import</strong></span> <span class="code">a</span>, the <span class="code"><strong>import</strong></span> statement finds <span class="code">sys.modules['a']</span> already bound, and therefore binds global variable <span class="code">a</span> in module <span class="code">b</span> to the module object for module <span class="code">a</span>. Since the execution of <span class="code">a</span>’s module body is currently blocked, module <span class="code">a</span> is usually only partly populated at this time. Should the code in <span class="code">b</span>’s module body try to access some attribute of module <span class="code">a</span> that is not yet bound, an error results.</p>
<p>If you keep a circular import, you must carefully manage the order in which each module binds its own globals, imports other modules, and accesses globals of other modules. You get greater control over the sequence in which things happen by grouping your statements into functions, and calling those functions in a controlled order, rather than just relying on sequential execution of top-level statements in module bodies. Removing circular dependencies (for example, by moving an import away from module scope and into a referencing function) is easier than ensuring bombproof ordering to deal with circular dependencies.</p>
<div data-type="note" epub:type="note">
<h1>sys.modules Entries</h1>
<p><span class="code">__import__</span> never binds anything other than a module object as a value in <span class="code">sys.modules</span>. However, if <span class="code">__import__</span> finds an entry already in <span class="code">sys.modules</span>, it returns that value, whatever type it may be. <span class="code"><strong>import</strong></span> and <span class="code"><strong>from</strong></span> statements rely on <span class="code">__import__</span>, so they too can use objects that are not modules.</p>
</div>
</div></section>
<section data-pdf-bookmark="Custom Importers" data-type="sect2"><div class="sect2" id="custom_importers">
<h2>Custom Importers</h2>
<p>Another<a contenteditable="false" data-primary="custom importers" data-type="indexterm" id="idm44924566815088"/> advanced, rarely needed functionality that Python offers is the ability to change the semantics of some or all <span class="code"><strong>import</strong></span> and <span class="code"><strong>from</strong></span> statements.</p>
<section data-pdf-bookmark="Rebinding __import__" data-type="sect3"><div class="sect3" id="rebinding___import_">
<h3>Rebinding __import__</h3>
<p>You<a contenteditable="false" data-primary="__import__ (built-in function)" data-type="indexterm" id="idm44924566810048"/> can rebind the <span class="code">__import__</span> attribute of the <span class="code">builtin</span> module to your own custom importer function—for example, one using the generic built-in-wrapping technique shown in <a data-type="xref" href="#python_built_ins">“Python built-ins”</a>. Such a rebinding affects all <span class="code"><strong>import</strong></span> and <span class="code"><strong>from</strong></span> statements that execute after the rebinding and thus can have an undesired global impact. A custom importer built by rebinding <span class="code">__import__</span> must implement the same interface and semantics as the built-in <span class="code">__import__</span>, and, in particular, it is responsible for supporting the correct use of <span class="code">sys.modules</span>.</p>
<div data-type="warning" epub:type="warning">
<h1>Avoid Rebinding the Built-in __import__</h1>
<p>While rebinding <span class="code">__import__</span> may initially look like an attractive approach, in most cases where custom importers are necessary, you’re better off implementing them via <em>import hooks</em> (discussed next).</p>
</div>
</div></section>
<section data-pdf-bookmark="Import hooks" data-type="sect3"><div class="sect3" id="import_hooks">
<h3>Import hooks</h3>
<p>Python<a contenteditable="false" data-primary="import" data-secondary="import hooks" data-type="indexterm" id="idm44924566797600"/> offers rich support for selectively changing the details of imports’ behavior. Custom importers are an advanced and rarely called for technique, yet some applications may need them for purposes such as importing code from archives other than ZIP files, databases, network servers, and so on.</p>
<p>The most suitable approach for such highly advanced needs is to record<a contenteditable="false" data-primary="import" data-secondary="importer factory" data-type="indexterm" id="idm44924566795424"/> <em>importer factory</em> callables as items in the <span class="code">meta_path</span> and/or <span class="code">path_hooks</span> attributes of the module <span class="code">sys</span>, as detailed in <a href="https://oreil.ly/9Wd9A">PEP 451</a>. This is how Python hooks up the standard library module <span class="code">zipimport</span> to allow seamless importing of modules from ZIP files, as previously mentioned. A full study of the details of PEP 451 is indispensable for any substantial use of <span class="code">sys.path_hooks</span> and friends, but here’s a toy-level example to help understand the possibilities, should you ever need them.</p>
<p>Suppose that, while developing the first outline of some program, we want to be able to use <span class="code"><strong>import</strong></span> statements for modules that we haven’t written yet, getting just messages (and empty modules) as a consequence. We can obtain such functionality (leaving aside the complexities connected with packages, and dealing with simple modules only) by coding a custom importer module as follows:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">sys</code><code class="o">,</code><code> </code><code class="nn">types</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">ImporterAndLoader</code><code class="p">:</code><code>
</code><code>     </code><em><code class="sd">"""importer and loader can be a single class"""</code></em><code>
</code><code>     </code><code class="n">fake_path</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">!dummy!</code><code class="s1">'</code><code>
</code><code>     </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">path</code><code class="p">)</code><code class="p">:</code><code>
</code><code>         </code><em><code class="c1"># only handle our own fake-path marker</code></em><code>
</code><code>         </code><strong><code class="k">if</code></strong><code> </code><code class="n">path</code><code> </code><code class="o">!=</code><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">fake_path</code><code class="p">:</code><code>
</code><code>             </code><strong><code class="k">raise</code></strong><code> </code><code class="ne">ImportError</code><code>
</code><code>     </code><strong><code class="k">def</code></strong><code> </code><code class="nf">find_module</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">fullname</code><code class="p">)</code><code class="p">:</code><code>
</code><code>         </code><em><code class="c1"># don't even try to handle any qualified module name</code></em><code>
</code><code>         </code><strong><code class="k">if</code></strong><code> </code><code class="s1">'</code><code class="s1">.</code><code class="s1">'</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">fullname</code><code class="p">:</code><code>
</code><code>             </code><strong><code class="k">return</code><code> </code><code class="kc">None</code></strong><code>
</code><code>         </code><strong><code class="k">return</code></strong><code> </code><code class="bp">self</code><code>
</code><code>     </code><strong><code class="k">def</code></strong><code> </code><code class="nf">create_module</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">spec</code><code class="p">)</code><code class="p">:</code><code>
</code><code>         </code><em><code class="c1"># returning None will have Python fall back and</code></em><code>
</code><em><code>         </code><code class="c1"># create the module "the default way"</code></em><code>
</code><strong><code>         </code><code class="k">return</code><code> </code><code class="kc">None</code></strong><code>
</code><code>     </code><strong><code class="k">def</code></strong><code> </code><code class="nf">exec_module</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">mod</code><code class="p">)</code><code class="p">:</code><code>
</code><code>         </code><em><code class="c1"># populate the already initialized module</code></em><code>
</code><code>         </code><em><code class="c1"># just print a message in this toy example</code></em><code>
</code><code>         </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">NOTE: module </code><code class="si">{</code><code class="n">mod</code><code class="si">!r}</code><code class="s1"> not yet written</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">sys</code><code class="o">.</code><code class="n">path_hooks</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">ImporterAndLoader</code><code class="p">)</code><code>
</code><code class="n">sys</code><code class="o">.</code><code class="n">path</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">ImporterAndLoader</code><code class="o">.</code><code class="n">fake_path</code><code class="p">)</code><code>
</code><strong><code class="k">if</code></strong><code> </code><code class="vm">__name__</code><code> </code><code class="o">==</code><code> </code><code class="s1">'</code><code class="s1">__main__</code><code class="s1">'</code><code class="p">:</code><code>      </code><em><code class="c1"># self-test when run as main script</code></em><code>
</code><code>    </code><strong><code class="kn">import</code></strong><code> </code><code class="nn">missing_module</code><code>       </code><em><code class="c1"># importing a simple *missing* module</code></em><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">missing_module</code><code class="p">)</code><code>       </code><em><code class="c1"># ...should succeed</code></em><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">sys</code><code class="o">.</code><code class="n">modules</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s1">'</code><code class="s1">missing_module</code><code class="s1">'</code><code class="p">)</code><code class="p">)</code><code>  </code><em><code class="c1"># ...should also succeed</code></em></pre>
<p>We just wrote trivial versions of <span class="code">create_module</span> (which in this case just returns <span class="code">None</span>, asking the system to create the module object in the “default way”) and <span class="code">exec_module</span> (which receives the module object already initialized with<a contenteditable="false" data-primary="dunder (double underscore)" data-secondary="import hooks" data-type="indexterm" id="idm44924530060560"/> dunder attributes, and whose task would normally be to populate it appropriately).</p>
<p>We could, alternatively, have used the powerful new<a contenteditable="false" data-primary="module spec concept" data-type="indexterm" id="idm44924530058832"/> <em>module spec</em> concept, as detailed in PEP 451. However, that requires the standard library module <span class="code">importlib</span>; for this toy example, we don’t need all that extra power. Therefore, we chose instead to implement the method <span class="code">find_module</span>, which, although now deprecated, still works fine for backward compatibility.<a contenteditable="false" data-primary="" data-startref="Mload07" data-type="indexterm" id="idm44924530081904"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Packages" data-type="sect1"><div class="sect1" id="packages">
<h1>Packages</h1>
<p>As mentioned at the beginning of this chapter, a <em>package<a contenteditable="false" data-primary="packages" data-secondary="basics of" data-type="indexterm" id="idm44924530078592"/></em> is a module containing other modules. Some or all of the modules in a package may be<a contenteditable="false" data-primary="subpackages" data-type="indexterm" id="idm44924530077248"/> <em>subpackages</em>, resulting in a hierarchical tree-like structure. A package named <span class="code"><em>P</em></span> typically resides in a subdirectory, also called <em>P</em>, of some directory in <span class="code">sys.path</span>. Packages can also live in ZIP files; in this section we explain the case in which the package lives on the filesystem, but the case in which a package is in a ZIP file is similar, relying on <span class="keep-together">the hierarchical</span> filesystem-like structure within the ZIP file.</p>
<p>The module body of <span class="code"><em>P</em></span> is in the file <em>P/__init__.py</em>. This file <em>must</em> exist (except in the case of namespace packages, described in <a href="https://oreil.ly/cVzGw">PEP 420</a>), even if it’s empty (representing an empty module body), in order to tell Python that directory <em>P</em> is indeed a package. Python loads the module body of a package when you first import the package (or any of the package’s modules), just like with any other Python module. The other <em>.py</em> files in the directory <em>P</em> are the modules of package <span class="code"><em>P</em></span>. Subdirectories of <em>P</em> containing <em>__init__.py</em> files are subpackages of <span class="code"><em>P</em></span>. Nesting can proceed to any depth.</p>
<p>You can import a module named <span class="code"><em>M</em></span> in package <span class="code"><em>P</em></span> as <span class="code"><em>P.M</em></span><em>.</em> More dots let you navigate a hierarchical package structure. (A package’s module body always loads <em>before</em> any module in the package.) If you use the syntax <span class="code"><strong>import</strong></span> <span class="code"><em>P.M</em></span>, the variable <span class="code"><em>P</em></span> is bound to the module object of package <span class="code"><em>P</em></span>, and the attribute <span class="code"><em>M</em></span> of object <span class="code"><em>P</em></span> is bound to the module <span class="code"><em>P.M</em></span><em>.</em> If you use the syntax <span class="code"><strong>import</strong></span> <span class="code"><em>P.M</em></span> as <span class="code"><em>V</em></span>, the variable <span class="code"><em>V</em></span> is bound directly to the module <span class="code"><em>P.M</em></span>.</p>
<p>Using <span class="code"><strong>from</strong></span> <span class="code"><em>P</em></span> <span class="code"><strong>import</strong></span> <span class="code"><em>M</em></span> to import a specific module <span class="code"><em>M</em></span> from package <span class="code"><em>P</em></span> is a perfectly acceptable and indeed highly recommended practice: the <span class="code"><strong>from</strong></span> statement is specifically OK in this case. <span class="code"><strong>from</strong></span> <span class="code"><em>P</em></span> <span class="code"><strong>import</strong></span> <span class="code"><em>M</em></span> <span class="code"><strong>as</strong></span> <span class="code"><em>V</em></span> is also just fine, and exactly equivalent to <span class="code"><strong>import</strong></span> <span class="code"><em>P.M</em></span> <span class="code"><strong>as</strong></span> <span class="code"><em>V</em></span>. You can also use<a contenteditable="false" data-primary="relative paths" data-type="indexterm" id="idm44924529973536"/> <em>relative</em> paths: that is, module <span class="code"><em>M</em></span> in package <span class="code"><em>P</em></span> can import its “sibling” module <span class="code"><em>X</em></span> (also in package <span class="code"><em>P</em></span>) with <span class="code"><strong>from</strong></span> <span class="code">.</span> <span class="code"><strong>import</strong></span> <span class="code">X</span>.</p>
<div data-type="tip">
<h1>Sharing Objects Among Modules in a Package</h1>
<p>The<a contenteditable="false" data-primary="modules" data-secondary="sharing objects among" data-type="indexterm" id="idm44924529965648"/><a contenteditable="false" data-primary="packages" data-secondary="sharing objects among modules in" data-type="indexterm" id="idm44924529964016"/> simplest, cleanest way to share objects (e.g., functions or constants) among modules in a package <span class="code"><em>P</em></span> is to group the shared objects in a module conventionally named <em>common.py</em>. That way, you can use <span class="code"><strong>from</strong></span> <span class="code">.</span> <span class="code"><strong>import</strong></span> <span class="code">common</span> in every module in the package that needs to access some of the common objects, and then refer to the objects as <span class="code">common.</span><span class="code"><em>f</em></span>, <span class="code">common.</span><span class="code"><em>K</em></span>, and so on.</p>
</div>
<section data-pdf-bookmark="Special Attributes of Package Objects" data-type="sect2"><div class="sect2" id="special_attributes_of_package_objects">
<h2>Special Attributes of Package Objects</h2>
<p>A<a contenteditable="false" data-primary="packages" data-secondary="special attributes of package objects" data-type="indexterm" id="idm44924529954272"/><a contenteditable="false" data-primary="attributes" data-secondary="special attributes of package objects" data-type="indexterm" id="idm44924529953056"/> package <span class="code"><em>P</em></span>’s <span class="code">__file__</span> attribute is the string that is the path of <span class="code"><em>P</em></span>’s module body—that is, the path of the file <em>P/__init__.py</em>. <span class="code"><em>P</em></span>’s <span class="code">__package__</span> attribute is the name of <span class="code"><em>P</em></span>’s package.</p>
<p>A package <span class="code"><em>P</em></span>’s module body—that is, the Python source that is in the file <em>P/__init__.py</em>—can optionally set a global variable named <span class="code">__all__</span> (just like any other module can) to control what happens if some other Python code executes the statement <span class="code"><strong>from</strong></span> <span class="code"><em>P</em></span> <span class="code"><strong>import</strong></span> <span class="code">*</span>. In particular, if <span class="code">__all__</span> is not set, <span class="code"><strong>from</strong></span> <span class="code"><em>P</em></span> <span class="code"><strong>import</strong></span> <span class="code">*</span> does not import <span class="code"><em>P</em></span>’s modules, but only names that are set in <span class="code"><em>P</em></span>’s module body and lack a leading <span class="code">_</span>. In any case, this is <em>not</em> recommended usage.</p>
<p>A package <span class="code"><em>P</em></span>’s <span class="code">__path__</span> attribute is the list of strings that are the paths to the directories from which <span class="code"><em>P</em></span>’s modules and subpackages are loaded. Initially, Python sets <span class="code">__path__</span> to a list with a single element: the path of the directory containing the file <em>__init__.py</em> that is the module body of the package. Your code can modify this list to affect future searches for modules and subpackages of this package. This advanced technique is rarely necessary, but can be useful when you want to place a package’s modules in multiple directories (a namespace package is, however, the usual way to accomplish this goal).</p>
</div></section>
<section data-pdf-bookmark="Absolute Versus Relative Imports" data-type="sect2"><div class="sect2" id="absolute_versus_relative_imports">
<h2>Absolute Versus Relative Imports</h2>
<p>As<a contenteditable="false" data-primary="import" data-secondary="absolute versus relative imports" data-type="indexterm" id="idm44924529930752"/><a contenteditable="false" data-primary="packages" data-secondary="absolute versus relative imports" data-type="indexterm" id="idm44924529928720"/><a contenteditable="false" data-primary="absolute imports" data-type="indexterm" id="idm44924529927504"/><a contenteditable="false" data-primary="relative imports" data-type="indexterm" id="idm44924529926528"/> mentioned previously, an <span class="code"><strong>import</strong></span> statement normally expects to find its target somewhere on <span class="code">sys.path</span>—a behavior known as an <em>absolute</em> import. Alternatively, you can explicitly use a <em>relative</em> import, meaning an import of an object from within the current package. Using relative imports can make it easier for you to refactor or restructure the subpackages within your package. Relative imports use module or package names beginning with one or more dots, and are only available within the <span class="code"><strong>from</strong></span> statement. <span class="code"><strong>from</strong></span> <span class="code">.</span> <span class="code"><strong>import</strong></span> <span class="code"><em>X</em></span> looks for the module or object named <span class="code"><em>X</em></span> in the current package; <span class="code"><strong>from</strong></span> <span class="code">.</span><span class="code"><em>X</em></span> <span class="code"><strong>import</strong></span> <span class="code"><em>y</em></span> looks in module or subpackage <span class="code"><em>X</em></span> within the current package for the module or object named <span class="code"><em>y</em></span>. If your package has subpackages, their code can access higher-up objects in the package by using multiple dots at the start of the module or subpackage name you place between <span class="code"><strong>from</strong></span> and <span class="code"><strong>import</strong></span>. Each additional dot ascends the directory hierarchy one level. Getting too fancy with this feature can easily damage your code’s clarity, so use it with care, and only when necessary.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Distribution Utilities (distutils) and setuptools" data-type="sect1"><div class="sect1" id="distribution_utilities_left_parenthesis">
<h1>Distribution Utilities (distutils) and setuptools</h1>
<p>Python<a contenteditable="false" data-primary="modules" data-secondary="distutils and setuptools" data-type="indexterm" id="Mdist07"/><a contenteditable="false" data-primary="distribution utilities (distutils)" data-type="indexterm" id="dist07"/><a contenteditable="false" data-primary="setuptools" data-type="indexterm" id="seetuptools07"/><a contenteditable="false" data-primary="packages" data-secondary="distutils and setuptools" data-type="indexterm" id="PCKdist07"/> modules, extensions, and applications can be packaged and distributed in several forms:</p>
<dl>
<dt>Compressed archive files</dt>
<dd>Generally <em>.zip</em>, <em>.tar.gz</em> (aka <em>.tgz</em>), <em>.tar.bz2</em>, or <em>.tar.xz</em> files—all these forms are portable, and many other forms of compressed archives of trees of files and directories exist</dd>
<dt>Self-unpacking or self-installing executables</dt>
<dd>Normally <em>.exe</em> for Windows</dd>
<dt>Self-contained, ready-to-run executables that require no installation</dt>
<dd>For example, <em>.exe</em> for Windows, ZIP archives with a short script prefix on Unix, <em>.app</em> for the Mac, and so on</dd>
<dt>Platform-specific installers</dt>
<dd>For example, <em>.rpm</em> and <em>.srpm</em> on many Linux distributions, <em>.deb</em> on Debian GNU/Linux and Ubuntu, <em>.pkg</em> on macOS</dd>
<dt>Python wheels</dt>
<dd>
<p>Popular third-party extensions, covered in the following note</p>
<div data-type="note" epub:type="note">
<h1>Python Wheels</h1>
<p>A Python <em>wheel<a contenteditable="false" data-primary="Python wheels" data-type="indexterm" id="idm44924529894352"/></em> is an archive file including structured metadata as well as Python code. Wheels offer an excellent way to package and distribute your Python packages, and <span class="code">setuptools</span> (with the <span class="code">wheel</span> extension, easily installed with <span class="code"><strong>pip install wheel</strong></span>) works seamlessly with them. Read all about them at <a href="http://pythonwheels.com">PythonWheels.com</a> and in <a data-type="xref" href="ch24.xhtml#packaging_programs_and_extensions">Chapter 24</a> (available <a href="https://oreil.ly/python-nutshell-24">online</a>).</p>
</div>
</dd>
</dl>
<p>When you distribute a package as a self-installing executable or platform-specific installer, a user simply runs the installer. How to run such a program depends on the platform, but it doesn’t matter which language the program was written in. We cover building self-contained, runnable executables for various platforms in <a href="https://oreil.ly/python-nutshell-24">Chapter 24</a>.</p>
<p>When you distribute a package as an archive file or as an executable that unpacks but does not install itself, it <em>does</em> matter that the package was coded in Python. In this case, the user must first unpack the archive file into some appropriate directory, say <em>C:\Temp\MyPack</em> on a Windows machine or <em>~/MyPack</em> on a Unix-like machine. Among the extracted files there should be a script, conventionally named <em>setup.py</em>, that uses the Python facility known as the <em>distribution utilities</em> (the now deprecated, but still functioning, standard library package <span class="code">distutils</span><sup><a data-type="noteref" href="ch07.xhtml#ch01fn82" id="ch01fn82-marker">2</a></sup>) or, better, the more popular, modern, and powerful third-party package <a href="https://oreil.ly/MHZby">setuptools</a>. The distributed package is then almost as easy to install as a self-installing executable; the user simply opens a command prompt window, changes to the directory into which the archive is unpacked, then runs, for example:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">C</code><code class="p">:</code><code>\</code><code class="n">Temp</code><code>\</code><code class="n">MyPack</code><code class="o">&gt;</code><code> </code><strong><code class="n">python</code><code> </code><code class="n">setup</code><code class="o">.</code><code class="n">py</code><code> </code><code class="n">install</code></strong></pre>
<p>(Another, often preferable, option is to use <span class="code">pip</span>; we’ll describe that momentarily.) The <em>setup.py</em> script run with this <span class="code"><strong>install</strong></span> command installs the package as a part of the user’s Python installation, according to the options specified by the package’s author in the setup script. Of course, the user needs appropriate permissions to write into the directories of the Python installation, so permission-raising commands such as <span class="code">sudo</span> may also be needed; or, better yet, you can install into a <em>virtual environment</em>, as described in the next section. <span class="code">distutils</span> and <span class="code">setuptools</span>, by default, print some information when the user runs <em>setup.py</em>. Including the option <span class="code"><strong>--quiet</strong></span> right before the <span class="code"><strong>install</strong></span> command hides most details (the user still sees error messages, if any). The following command gives detailed help on <span class="code">distutils</span> or <span class="code">setuptools</span>, depending on which toolset the package author used in their <em>setup.py</em>:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">C</code><code class="p">:</code><code>\</code><code class="n">Temp</code><code>\</code><code class="n">MyPack</code><code class="o">&gt;</code><code> </code><strong><code class="n">python</code><code> </code><code class="n">setup</code><code class="o">.</code><code class="n">py</code><code> </code><code class="o">-</code><code class="o">-</code><code class="n">help</code></strong></pre>
<p>An alternative to this process, and the preferred way to install packages nowadays, is to use the excellent installer <span class="code">pip</span> that comes with Python. <span class="code">pip</span>—a recursive acronym for “<span class="code">pip</span> installs packages”—is copiously documented <a href="https://oreil.ly/G7zMK">online</a>, yet very simple to use in most cases. <span class="code"><strong>pip install</strong></span> <span class="code"><strong><em>package</em></strong></span> finds the online version of <span class="code"><em>package</em></span> (usually in the huge <a href="https://oreil.ly/PGIim">PyPI</a> repository, hosting more than 400,000 packages at the time of this writing), downloads it, and installs it for you (in a virtual environment, if one is active; see the next section for details). This books’ authors have been using that simple, powerful approach for well over 90% of their installs for quite a while now.</p>
<p>Even if you have downloaded the package locally (say to <em>/tmp/mypack</em>), for whatever reason (maybe it’s not on PyPI, or you’re trying out an experimental version that is not yet there), <span class="code">pip</span> can still install it for you: just run <span class="code"><strong>pip install --no-index --find-links=/tmp/mypack</strong></span> and <span class="code">pip</span> does the rest.<a contenteditable="false" data-primary="" data-startref="Mdist07" data-type="indexterm" id="idm44924529796400"/><a contenteditable="false" data-primary="" data-startref="dist07" data-type="indexterm" id="idm44924529795184"/><a contenteditable="false" data-primary="" data-startref="seetuptools07" data-type="indexterm" id="idm44924529793968"/><a contenteditable="false" data-primary="" data-startref="PCKdist07" data-type="indexterm" id="idm44924529792752"/></p>
</div></section>
<section data-pdf-bookmark="Python Environments" data-type="sect1"><div class="sect1" id="python_environments">
<h1>Python Environments</h1>
<p>A<a contenteditable="false" data-primary="modules" data-secondary="Python environments" data-type="indexterm" id="MDpenv07"/><a contenteditable="false" data-primary="Python interpreter" data-secondary="for multiple environments" data-secondary-sortas="multiple environments" data-type="indexterm" id="idm44924529788144"/><a contenteditable="false" data-primary="packages" data-secondary="Python environments" data-type="indexterm" id="PCKpyenv07"/><a contenteditable="false" data-primary="Python environments" data-type="indexterm" id="pyenv07"/> typical Python programmer works on several projects concurrently, each with its own list of dependencies (typically, third-party libraries and data files). When the dependencies for all projects are installed into the same Python interpreter, it is very difficult to determine which projects use which dependencies, and impossible to handle projects with conflicting versions of certain dependencies.</p>
<p>Early Python interpreters were built on the assumption that each computer system would have “a Python interpreter” installed on it, to be used to run any Python program on that system. Operating system distributions soon started to include Python in their base installations, but, because Python has always been under active development, users often complained that they would like to use a more up-to-date version of the language than the one their operating system provided.</p>
<p>Techniques arose to let multiple versions of the language be installed on a system, but installation of third-party software remained nonstandard and intrusive. This problem was eased by the introduction of the<a contenteditable="false" data-primary="site-packages directory" data-type="indexterm" id="idm44924529783120"/> <em>site-packages</em> directory as the repository for modules added to a Python installation, but it was still not possible to maintain multiple projects with conflicting requirements using the same interpreter.</p>
<p>Programmers accustomed to command-line operations are familiar with the concept of a<a contenteditable="false" data-primary="shell environments" data-type="indexterm" id="idm44924529781152"/> <em>shell environment</em>. A shell program running in a process has a current directory, variables that you can set with shell commands (very similar to a Python namespace), and various other pieces of process-specific state data. Python programs have access to the shell environment through <span class="code">os.environ</span>.</p>
<p>Various aspects of the shell environment affect Python’s operation, as mentioned in <a data-type="xref" href="ch02.xhtml#environment_variables">“Environment Variables”</a>. For example, the<a contenteditable="false" data-primary="PATH environment variable" data-type="indexterm" id="idm44924529777152"/> <span class="code">PATH</span> environment variable determines which program, exactly, executes in response to <span class="code"><strong>python</strong></span> and other commands. You can think of those aspects of your shell environment that affect Python’s operation as your <em>Python environment</em>. By modifying it you can determine which Python interpreter runs in response to the <span class="code"><strong>python</strong></span> command, which packages and modules are available under certain names, and so on.</p>
<div data-type="warning" epub:type="warning">
<h1>Leave the System’s Python to the System</h1>
<p>We recommend taking control of your Python environment. In particular, do not build applications on top of a system-distributed Python. Instead, install another Python distribution independently, and adjust your shell environment so that the <span class="code"><strong>python</strong></span> command runs your locally installed Python rather than the system’s Python.</p>
</div>
<section data-pdf-bookmark="Enter the Virtual Environment" data-type="sect2"><div class="sect2" id="enter_the_virtual_environment">
<h2>Enter the Virtual Environment</h2>
<p>The<a contenteditable="false" data-primary="virtual environments" data-secondary="benefits of" data-type="indexterm" id="idm44924529768688"/> introduction of the <span class="code">pip</span> utility created a simple way to install (and, for the first time, to uninstall) packages and modules in a Python environment. Modifying the system Python’s <em>site-packages</em> still requires administrative privileges, and hence so does <span class="code">pip</span> (although it can optionally install somewhere other than <em>site-packages</em>). Modules installed in the central <em>site-packages</em> are visible to all programs.</p>
<p>The missing piece is the ability to make controlled changes to the Python environment, to direct the use of a specific interpreter and a specific set of Python libraries. That functionality is just what <em>virtual environments</em> (<em>virtualenvs</em>) give you. Creating a virtualenv based on a specific Python interpreter copies or links to components from that interpreter’s installation. Critically, though, each one has its own <em>site-packages</em> directory, into which you can install the Python resources of your choice.</p>
<p>Creating a virtualenv is <em>much</em> simpler than installing Python, and requires far less system resources (a typical newly created virtualenv takes up less than 20 MB). You can easily create and activate virtualenvs on demand, and deactivate and destroy them just as easily. You can activate and deactivate a virtualenv as many times as you like during its lifetime, and if necessary use <span class="code">pip</span> to update the installed resources. When you are done with it, removing its directory tree reclaims all storage occupied by the virtualenv. A virtualenv’s lifetime can span minutes or months.</p>
</div></section>
<section data-pdf-bookmark="What Is a Virtual Environment?" data-type="sect2"><div class="sect2" id="what_is_a_virtual_environmentquestion_m">
<h2>What Is a Virtual Environment?</h2>
<p>A virtualenv is essentially a self-contained subset of your Python environment that you can switch in or out on demand. For a Python 3.<em>x</em> interpreter it includes, among other things, a <em>bin</em> directory containing a Python 3.<em>x</em> interpreter, and a <em>lib/python3.x/site-packages</em> directory containing preinstalled versions of <span class="code">easy-install</span>, <span class="code">pip</span>, <span class="code">pkg_resources</span>, and <span class="code">setuptools</span>. Maintaining separate copies of these important distribution-related resources lets you update them as necessary rather than forcing you to rely on the base Python distribution.</p>
<p>A virtualenv has its own copies of (on Windows) or symbolic links to (on other platforms) Python distribution files. It adjusts the values of <span class="code">sys.prefix</span> and <span class="code">sys.exec_prefix</span>, from which the interpreter and various installation utilities determine the locations of some libraries. This means that <span class="code">pip</span> can install dependencies in isolation from other environments, in the virtualenv’s <em>site-packages</em> directory. In effect, the virtualenv redefines which interpreter runs when you run the <span class="code"><strong>python</strong></span> command and which libraries are available to it, but leaves most aspects of your Python environment (such as the <span class="code">PYTHONPATH</span> and <span class="code">PYTHONHOME</span> variables) alone. Since its changes affect your shell environment, they also affect any subshells in which you run commands.</p>
<p>With separate virtualenvs you can, for example, test two different versions of the same library with a project, or test your project with multiple versions of Python. You can also add dependencies to your Python projects without needing any special privileges, since you normally create your virtualenvs somewhere you have write permission.</p>
<p>The modern way to deal with virtualenvs is with the <span class="code">venv</span> module of the standard library: just run <span class="code"><strong>python -m venv</strong></span> <span class="code"><em>envpath</em></span>.</p>
</div></section>
<section data-pdf-bookmark="Creating and Deleting Virtual Environments" data-type="sect2"><div class="sect2" id="creating_and_deleting_virtual_environme">
<h2>Creating and Deleting Virtual Environments</h2>
<p>The<a contenteditable="false" data-primary="virtual environments" data-secondary="creating and deleting" data-type="indexterm" id="VEcre07"/> command <span class="code"><strong>python -m venv</strong></span> <span class="code"><em>envpath</em></span> creates a virtual environment (in the <em>envpath</em> directory, which it also creates if necessary) based on the Python interpreter used to run the command. You can give multiple directory arguments to create, with a single command, several virtual environments (running the same Python interpreter); you can then install different sets of dependencies in each virtualenv. <span class="code">venv</span> can take a number of options, as shown in <a data-type="xref" href="#venv_options">Table 7-1</a>.</p>
<table class="border" id="venv_options">
<caption><span class="label">Table 7-1. </span><span class="code">venv</span> options</caption>
<thead>
<tr>
<th>Option</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code"><strong>--clear</strong></span></td>
<td>Removes any existing directory content before installing the virtual environment</td>
</tr>
<tr>
<td><span class="code"><strong>--copies</strong></span></td>
<td>Installs files by copying on the Unix-like platforms where using symbolic links is the default</td>
</tr>
<tr>
<td><span class="code"><strong>--h</strong></span> or <span class="code"><strong>--help</strong></span></td>
<td>Prints out a command-line summary and a list of available options</td>
</tr>
<tr>
<td><span class="code"><strong>--symlinks</strong></span></td>
<td>Installs files by using symbolic links on platforms where copying is the system default</td>
</tr>
<tr>
<td><span class="code"><strong>--system-site-packages</strong></span></td>
<td>Adds the standard system <em>site-packages</em> directory to the environment’s search path, making modules already installed in the base Python available inside the environment</td>
</tr>
<tr>
<td><span class="code"><strong>--upgrade</strong></span></td>
<td>Installs the running Python in the virtual environment, replacing whichever version had originally created the environment</td>
</tr>
<tr>
<td><span class="code"><strong>--without-pip</strong></span></td>
<td>Inhibits the usual behavior of calling <span class="code">ensurepip</span> to bootstrap the <span class="code">pip</span> installer utility into the environment</td>
</tr>
</tbody>
</table>
<div data-type="tip">
<h1>Know Which Python You’re Running</h1>
<p>When you enter the command <span class="code"><strong>python</strong></span> at the command line, your shell has rules (which differ among Windows, Linux, and macOS) that determine which program you run. If you are clear on those rules, you always know which interpreter you are using.</p>
<p>Using <span class="code"><strong>python -m venv</strong></span> <em><span class="code">directory_path</span></em> to create a virtual environment guarantees that it’s based on the same Python version as the interpreter used to create it. Similarly, using <span class="code"><strong>python -m pip</strong></span> <em><span class="code">package_name</span></em> will install the package for the interpreter associated with the <span class="code"><strong>python</strong></span> command. Activating a virtual environment changes the association with the <span class="code"><strong>python</strong></span> command: this is the simplest way to ensure packages are installed into the virtual environment.</p>
</div>
<p>The following Unix terminal session shows the creation of a virtualenv and the structure of the created directory tree. The listing of the <em>bin</em> subdirectory shows that this particular user, by default, uses an interpreter installed in <em>/usr/local/bin</em>.<sup><a data-type="noteref" href="ch07.xhtml#ch01fn83" id="ch01fn83-marker">3</a></sup></p>
<pre data-type="programlisting">
$ <strong>python3 -m venv /tmp/tempenv</strong>
$ <strong>tree -dL 4 /tmp/tempenv</strong>
/tmp/tempenv
|--- bin
|--- include
|___ lib
     |___ python3.5
          |___ site-packages
               |--- __pycache__
               |--- pip
               |--- pip-8.1.1.dist-info
               |--- pkg_resources
               |--- setuptools
               |___ setuptools-20.10.1.dist-info

11 directories
$ <strong>ls -l /tmp/tempenv/bin/</strong>
total 80
-rw-r--r-- 1 sh wheel 2134 Oct 24 15:26 activate
-rw-r--r-- 1 sh wheel 1250 Oct 24 15:26 activate.csh
-rw-r--r-- 1 sh wheel 2388 Oct 24 15:26 activate.fish
-rwxr-xr-x 1 sh wheel  249 Oct 24 15:26 easy_install
-rwxr-xr-x 1 sh wheel  249 Oct 24 15:26 easy_install-3.5
-rwxr-xr-x 1 sh wheel  221 Oct 24 15:26 pip
-rwxr-xr-x 1 sh wheel  221 Oct 24 15:26 pip3
-rwxr-xr-x 1 sh wheel  221 Oct 24 15:26 pip3.5
lrwxr-xr-x 1 sh wheel    7 Oct 24 15:26 python-&gt;python3
lrwxr-xr-x 1 sh wheel   22 Oct 24 15:26 python3-&gt;/usr/local/bin/python3</pre>
<p>Deleting a virtualenv is as simple as removing the directory in which it resides (and all subdirectories and files in the tree: <span class="code"><strong>rm -rf</strong></span> <span class="code"><em>envpath</em></span> in Unix-like systems). Ease of removal is a helpful aspect of using virtualenvs.</p>
<p>The <span class="code">venv</span> module includes features to help the programmed creation of tailored environments (e.g., by preinstalling certain modules in the environment or performing other post-creation steps). It is comprehensively documented <a href="https://oreil.ly/DVwfT">online</a>; we do not cover the API further in this book.<a contenteditable="false" data-primary="" data-startref="VEcre07" data-type="indexterm" id="idm44924529700032"/></p>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Working with Virtual Environments" data-type="sect2"><div class="sect2" id="working_with_virtual_environments">
<h2 class="less_space">Working with Virtual Environments</h2>
<p>To<a contenteditable="false" data-primary="virtual environments" data-secondary="working with" data-type="indexterm" id="idm44924529695776"/> use a virtualenv, you <em>activate</em> it from your normal shell environment. Only one virtualenv can be active at a time—activations don’t “stack” like function calls. Activation tells your Python environment to use the virtualenv’s Python interpreter and<a contenteditable="false" data-primary="site-packages directory" data-type="indexterm" id="idm44924529693792"/> <em>site-packages</em> (along with the interpreter’s full standard library). When you want to stop using those dependencies, deactivate the virtualenv, and your standard Python environment is once again available. The virtualenv directory tree continues to exist until deleted, so you can activate and deactivate it at will.</p>
<p>Activating a virtualenv in Unix-based environments requires using the <span class="code"><strong>source</strong></span> shell command so that the commands in the activation script make changes to the current shell environment. Simply running the script would mean its commands were executed in a subshell, and the changes would be lost when the subshell terminated. For bash, <span class="code">zsh</span>, and similar shells, you activate an environment located at path <span class="code"><em>envpath</em></span> with the command:</p>
<pre data-type="programlisting">
$ <strong>source</strong> <em>envpath</em><strong>/bin/activate</strong></pre>
<p>or:</p>
<pre data-type="programlisting">
$ <em>. envpath</em><strong>/bin/activate</strong></pre>
<p>Users of other shells are supported by the scripts <em>activate.csh</em> and <em>activate.fish</em>, located in the same directory. On Windows systems, use <em>activate.bat</em> (or, if using Powershell, <em>Activate.ps1</em>):</p>
<pre data-type="programlisting">
C:\&gt; <em>envpath</em><strong>/Scripts/activate.bat</strong></pre>
<p>Activation does many things. Most importantly, it:</p>
<ul>
<li>
<p>Adds the virtualenv’s <em>bin</em> directory at the beginning of the shell’s <span class="code">PATH</span> environment variable, so its commands get run in preference to anything of the same name already on the <span class="code">PATH</span></p>
</li>
<li>
<p>Defines a <span class="code">deactivate</span> command to remove all effects of activation and return the Python environment to its former state</p>
</li>
<li>
<p>Modifies the shell prompt to include the virtualenv’s name at the start</p>
</li>
<li>
<p>Defines a <span class="code">VIRTUAL_ENV</span> environment variable as the path to the virtualenv’s root directory (scripts can use this to introspect the virtualenv)</p>
</li>
</ul>
<p>As a result of these actions, once a virtualenv is activated, the <span class="code"><strong>python</strong></span> command runs the interpreter associated with that virtualenv. The interpreter sees the libraries (modules and packages) installed in that environment, and <span class="code">pip</span>—now the one from the virtualenv, since installing the module also installed the command in the virtualenv’s <em>bin</em> directory—by default installs new packages and modules in the environment’s <em>site-packages</em> directory.</p>
<p>Those new to virtualenvs should understand that a virtualenv is not tied to any project directory. It’s perfectly possible to work on several projects, each with its own source tree, using the same virtualenv. Activate it, then move around your filesystem as necessary to accomplish your programming tasks, with the same libraries available (because the virtualenv determines the Python environment).</p>
<p>When you want to disable the virtualenv and stop using that set of resources, simply issue the command <span class="code"><strong>deactivate</strong></span>. This undoes the changes made on activation, removing the virtualenv’s <em>bin</em> directory from your <span class="code">PATH</span>, so the <span class="code"><strong>python</strong></span> command once again runs your usual interpreter. As long as you don’t delete it, the virtualenv remains available for future use: just repeat the command to activate it.</p>
<div data-type="warning" epub:type="warning">
<h1>Do Not Use py –3.x in a Virtualenv on Windows</h1>
<p>The Windows<a contenteditable="false" data-primary="Microsoft Windows" data-secondary="virtual environments" data-type="indexterm" id="idm44924529665392"/> py launcher provides mixed support for virtualenvs. It makes it very easy to define a virtualenv using a specific Python version, using a command like the following:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">C</code><code class="p">:</code><code>\</code><code class="o">&gt;</code><code> </code><strong><code class="n">py</code><code> </code><code class="o">-</code><code class="mf">3.7</code><code> </code><code class="o">-</code><code class="n">m</code><code> </code><code class="n">venv</code><code> </code><code class="n">C</code><code class="p">:</code><code>\</code><code class="n">path</code><code>\</code><code class="n">to</code><code>\</code><code class="n">new_virtualenv</code></strong></pre>
<p>This creates a new virtualenv, running the installed Python 3.7.</p>
<p>Once activated, you can run the Python interpreter in the virtualenv using either the <span class="code"><strong>python</strong></span> command or the bare <span class="code"><strong>py</strong></span> command with no version specified. However, if you specify the <span class="code"><strong>py</strong></span> command using a version option, even if it is the same version used to construct the virtualenv, you will <em>not</em> run the <em>virtualenv</em> Python. Instead, you will run the corresponding <em>system-installed</em> version of Python.</p>
</div>
</div></section>
<section data-pdf-bookmark="Managing Dependency Requirements" data-type="sect2"><div class="sect2" id="managing_dependency_requirements">
<h2>Managing Dependency Requirements</h2>
<p>Since<a contenteditable="false" data-primary="virtual environments" data-secondary="dependency requirements" data-type="indexterm" id="idm44924529636304"/> virtualenvs were designed to complement installation with <span class="code">pip</span>, it should come as no surprise that <span class="code">pip</span> is the preferred way to maintain dependencies in a virtualenv. Because <span class="code">pip</span> is already extensively documented, we mention only enough here to demonstrate its advantages in virtual environments. Having created a virtualenv, activated it, and installed dependencies, you can use the <span class="code"><strong>pip freeze</strong></span> command to learn the exact versions of those dependencies:</p>
<pre data-type="programlisting">
(tempenv) $ <strong>pip freeze</strong>
appnope==0.1.0
decorator==4.0.10
ipython==5.1.0
ipython-genutils==0.1.0
pexpect==4.2.1
pickleshare==0.7.4
prompt-toolkit==1.0.8
ptyprocess==0.5.1
Pygments==2.1.3
requests==2.11.1
simplegeneric==0.8.1
six==1.10.0
traitlets==4.3.1
wcwidth==0.1.7</pre>
<p>If you redirect the output of this command to a file called <em>filename</em>, you can re-create the same set of dependencies in a different virtualenv with the command <span class="code"><strong>pip</strong></span> <span class="code"><strong>install</strong></span> <span class="code"><strong>-r</strong></span> <span class="code"><em>filename</em></span>.</p>
<p>When distributing code for use by others, Python developers conventionally include a <em>requirements.txt</em> file listing the necessary dependencies. <span class="code">pip</span> installs any indicated dependencies along with the packages you request when you install software from PyPI. While you’re developing software it’s also convenient to have a requirements file, as you can use it to add the necessary dependencies to the active virtualenv (unless they are already installed) with a simple <span class="code"><strong>pip install -r requirements.txt</strong></span>.</p>
<p>To maintain the same set of dependencies in several virtualenvs, use the same requirements file to add dependencies to each one. This is a convenient way to develop projects to run on multiple Python versions: create virtualenvs based on each of your required versions, then install from the same requirements file in each. While the preceding example uses exactly versioned dependency specifications as produced by <span class="code"><strong>pip freeze</strong></span>, in practice you can specify dependencies and version requirements in quite complex ways; see the <a href="https://oreil.ly/wB9LB">documentation</a> for details.</p>
</div></section>
<section data-pdf-bookmark="Other Environment Management Solutions" data-type="sect2"><div class="sect2" id="other_environment_management_solutions">
<h2>Other Environment Management Solutions</h2>
<p>Python<a contenteditable="false" data-primary="Python environments" data-secondary="other environment solutions" data-type="indexterm" id="idm44924529597616"/><a contenteditable="false" data-primary="virtual environments" data-secondary="other environment solutions" data-type="indexterm" id="idm44924529596176"/> virtual environments are focused on providing an isolated Python interpreter, into which you can install dependencies for one or more Python applications. The<a contenteditable="false" data-primary="virtualenv package" data-type="indexterm" id="idm44924529594672"/> <a href="https://oreil.ly/bUfe0"><span class="code">virtualenv</span></a> package was the original way to create and manage virtualenvs. It has extensive facilities, including the ability to create environments from any available Python interpreter. Now maintained by the Python Packaging Authority team, a subset of its functionality has been extracted as the standard library <span class="code">venv</span> module covered earlier, but <span class="code">virtualenv</span> is worth learning about if you need more control.</p>
<p>The<a contenteditable="false" data-primary="pipenv package" data-type="indexterm" id="idm44924529590464"/> <a href="https://oreil.ly/vfi9I"><span class="code">pipenv</span></a> package is another dependency manager for Python environments. It maintains virtual environments whose contents are recorded in a file named <em>Pipfile</em>. Much in the manner of similar JavaScript tools, it provides deterministic environments through the use of a <em>Pipfile.lock</em> file, allowing the exact same dependencies to be deployed as in the original installation.</p>
<p><span class="code">conda</span>, <a contenteditable="false" data-primary="conda package management system" data-type="indexterm" id="idm44924529585648"/>mentioned in <a data-type="xref" href="ch01.xhtml#anaconda_and_miniconda">“Anaconda and Miniconda”</a>, has a rather broader scope and can provide package, environment, and dependency management for any language. <span class="code">conda</span> is written in Python, and installs its own Python interpreter in the base environment. Whereas a standard Python virtualenv normally uses the Python interpreter with which it was created; in <span class="code">conda</span>, Python itself (when it is included in the environment) is simply another dependency. This makes it practical to update the version of Python used in the environment, if necessary. You can also, if you wish, use <span class="code">pip</span> to install packages in a Python-based <span class="code">conda</span> environment. <span class="code">conda</span> can dump an environment’s contents as a YAML file, and you can use the file to replicate the environment elsewhere.</p>
<p>Because<a contenteditable="false" data-primary="Anaconda" data-type="indexterm" id="idm44924529578960"/> of its additional flexibility, coupled with comprehensive open source support led by its originator, Anaconda, Inc. (formerly Continuum), <span class="code">conda</span> is widely used in academic environments, particularly in data science and engineering, artificial intelligence, and financial analytics. It installs software from what it calls <em>channels</em>. The default channel maintained by Anaconda contains a wide range of packages, and third parties maintain specialized channels (such as the <em>bioconda</em> channel for bioinformatics software). There is also a community-based <a href="https://oreil.ly/fEBZo"><em>conda-forge</em> channel</a>, open to anyone who wants to join up and add software. Signing up for an account on <a href="https://anaconda.org">Anaconda.org</a> lets you create your own channel and distribute software through the <em>conda-forge</em> channel.<a contenteditable="false" data-primary="" data-startref="pyenv07" data-type="indexterm" id="idm44924529573616"/></p>
</div></section>
<section data-pdf-bookmark="Best Practices with Virtualenvs" data-type="sect2"><div class="sect2" id="best_practices_with_virtualenvs">
<h2>Best Practices with Virtualenvs</h2>
<p>There<a contenteditable="false" data-primary="virtual environments" data-secondary="best practices" data-type="indexterm" id="idm44924529570000"/> is remarkably little advice on how best to manage your work with virtualenvs, though there are several sound tutorials: any good search engine will give you access to the most current ones. We can, however, offer a modest amount of advice that we hope will help you to get the most out of virtual environments.</p>
<p>When you are working with the same dependencies in multiple Python versions, it is useful to indicate the version in the environment name and use a common prefix. So, for the project <em>mutex</em> you might maintain environments called <em>mutex_39</em> and <em>mutex_310</em> for development under two different versions of Python. When it’s obvious which Python is involved (remember, you see the environment name in your shell prompt), there’s less risk of testing with the wrong version. You can maintain dependencies using common requirements to control resource installation in both.</p>
<p>Keep the requirements file(s) under source control, not the whole environment. Given the requirements file it’s easy to re-create a virtualenv, which depends only on the Python release and the requirements. You distribute your project, and let your users decide which version(s) of Python to run it on and create the appropriate virtual environment(s).</p>
<p>Keep your virtualenvs outside your project directories. This avoids the need to explicitly force source code control systems to ignore them. It really doesn’t matter where else you store them.</p>
<p>Your Python environment is independent of your projects’ locations in the filesystem. You can activate a virtual environment and then switch branches and move around a change-controlled source tree to use it wherever is convenient.</p>
<p>To investigate a new module or package, create and activate a new virtualenv and then <span class="code"><strong>pip install</strong></span> the resources that interest you. You can play with this new environment to your heart’s content, confident in the knowledge that you won’t be installing unwanted dependencies into other projects.</p>
<p>You may find that experiments in a virtualenv require installation of resources that aren’t currently project requirements. Rather than “pollute” your development environment, fork it: create a new virtualenv from the same requirements plus the testing functionality. Later, to make these changes permanent, use change control to merge your source and requirements changes back in from the forked branch.</p>
<p>If you are so inclined, you can create virtual environments based on debug builds of Python, giving you access to a wealth of information about the performance of your Python code (and, of course, of the interpreter itself).</p>
<p>Developing a virtual environment also requires change control, and the ease of virtualenv creation helps here too. Suppose that you recently released version 4.3 of a module, and you want to test your code with new versions of two of its dependencies. You <em>could</em>, with sufficient skill, persuade <span class="code">pip</span> to replace the existing copies of dependencies in your existing virtualenv. It’s much easier, though, to branch your project using source control tools, update the requirements, and create an entirely new virtual environment based on the updated requirements. The original virtualenv remains intact, and you can switch between virtualenvs to investigate specific aspects of any migration issues that might arise. Once you have adjusted your code so that all tests pass with the updated dependencies, you can check in your code <em>and</em> requirement changes and merge into version 4.4 to complete the update, advising your colleagues that your code is now ready for the updated versions of the dependencies.</p>
<p>Virtual environments won’t solve all of a Python programmer’s problems: tools can always be made more sophisticated, or more general. But, by golly, virtualenvs work, and we should take all the advantage of them that we can.<a contenteditable="false" data-primary="" data-startref="MDpenv07" data-type="indexterm" id="idm44924529560640"/><a contenteditable="false" data-primary="" data-startref="PCKpyenv07" data-type="indexterm" id="idm44924529559264"/></p>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn81"><sup><a href="ch07.xhtml#ch01fn81-marker">1</a></sup> One of our tech reviewers reports that <em>.pyw</em> files on Windows are an exception to this.</p><p data-type="footnote" id="ch01fn82"><sup><a href="ch07.xhtml#ch01fn82-marker">2</a></sup> <span class="code">distutils</span> is scheduled for deletion in Python 3.12.</p><p data-type="footnote" id="ch01fn83"><sup><a href="ch07.xhtml#ch01fn83-marker">3</a></sup> When running these commands on reduced-footprint Linux distributions, you may need to separately install <span class="code">venv</span> or other supporting packages first.</p></div></div></section></div></body></html>