["```py\ndef add_authors_cookbooks(author_name: str, cookbooks: list[str] = []) -> bool:\n\n    author = find_author(author_name)\n    if author is None:\n        assert False, \"Author does not exist\"\n    else:\n        for cookbook in author.get_cookbooks():\n            cookbooks.append(cookbook)\n        return True\n```", "```py\npip install pylint\n```", "```py\npylint code_examples/chapter20/lint_example.py\n************* Module lint_example\n\ncode_examples/chapter20/lint_example.py:11:0: W0102:\n    Dangerous default value [] as argument (dangerous-default-value)\ncode_examples/chapter20/lint_example.py:11:0: R1710:\n    Either all return statements in a function should return an expression,\n    or none of them should. (inconsistent-return-statements)\n```", "```py\nReadyToServeHotDog = NewType(\"ReadyToServeHotDog\", HotDog)\n\ndef prepare_for_serving() -> ReadyToServeHotDog:\n    # snip preparation\n    return ReadyToServeHotDog(hotdog)\n```", "```py\nfrom typing import Optional\n\nimport astroid\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.interfaces import IAstroidChecker\nfrom pylint.lint.pylinter import PyLinter\n\nclass ServableHotDogChecker(BaseChecker):\n    __implements__ = IAstroidChecker\n\n    name = 'unverified-ready-to-serve-hotdog'\n    priority = -1\n    msgs = {\n      'W0001': (\n        'ReadyToServeHotDog created outside of hotdog.prepare_for_serving.',\n        'unverified-ready-to-serve-hotdog',\n        'Only create a ReadyToServeHotDog through hotdog.prepare_for_serving.'\n      ),\n    }\n\n    def __init__(self, linter: Optional[PyLinter] = None):\n        super(ServableHotDogChecker, self).__init__(linter)\n        self._is_in_prepare_for_serving = False\n\n    def visit_functiondef(self, node: astroid.scoped_nodes.FunctionDef):\n        if (node.name == \"prepare_for_serving\" and\n            node.parent.name ==\"hotdog\" and\n            isinstance(node.parent, astroid.scoped_nodes.Module)):\n\n            self._is_in_prepare_for_serving = True\n\n    def leave_functiondef(self, node: astroid.scoped_nodes.FunctionDef):\n        if (node.name == \"prepare_for_serving\" and\n            node.parent.name ==\"hotdog\" and\n            isinstance(node.parent, astroid.scoped_nodes.Module)):\n\n            self._is_in_prepare_for_serving = False\n\n    def visit_call(self, node: astroid.node_classes.Call):\n        if node.func.name != 'ReadyToServeHotDog':\n            return\n\n        if self._is_in_prepare_for_serving:\n            return\n\n        self.add_message(\n            'unverified-ready-to-serve-hotdog', node=node,\n        )\n\ndef register(linter: PyLinter):\n    linter.register_checker(ServableHotDogChecker(linter))\n```", "```py\ndef create_hot_dog() -> ReadyToServeHotDog:\n    hot_dog = HotDog()\n    return ReadyToServeHotDog(hot_dog)\n```", "```py\n PYTHONPATH=code_examples/chapter20 pylint --load-plugins \\\n        hotdog_checker code_examples/chapter20/hotdog.py\n```", "```py\n************* Module hotdog\ncode_examples/chapter20/hotdog.py:13:12: W0001:\n    ReadyToServeHotDog created outside of prepare_for_serving.\n        (unverified-ready-to-serve-hotdog)\n```", "```py\nimport astroid\n\nfrom pylint.checkers import BaseChecker\nfrom pylint.interfaces import IAstroidChecker\n\nclass ReadyToServeHotDogChecker(BaseChecker):\n    __implements__ = IAstroidChecker\n```", "```py\n    name = 'unverified-ready-to-serve-hotdog'\n    priority = -1\n    msgs = {\n     'W0001': ( # this is an arbitrary number I've assigned as an identifier\n        'ReadyToServeHotDog created outside of hotdog.prepare_for_serving.',\n        'unverified-ready-to-serve-hotdog',\n        'Only create a ReadyToServeHotDog through hotdog.prepare_for_serving.'\n     ),\n    }\n```", "```py\n    def __init__(self, linter: Optional[PyLinter] = None):\n        super(ReadyToServeHotDogChecker, self).__init__(linter)\n        self._is_in_prepare_for_serving = False\n\n    def visit_functiondef(self, node: astroid.scoped_nodes.FunctionDef):\n        if (node.name == \"prepare_for_serving\" and\n            node.parent.name ==\"hotdog\" and\n            isinstance(node.parent, astroid.scoped_nodes.Module)):\n                self._is_in_prepare_for_serving = True\n\n    def leave_functiondef(self, node: astroid.scoped_nodes.FunctionDef):\n        if (node.name == \"prepare_for_serving\" and\n            node.parent.name ==\"hotdog\" and\n            isinstance(node.parent, astroid.scoped_nodes.Module)):\n\n            self._is_in_prepare_for_serving = False\n```", "```py\n    def visit_call(self, node: astroid.node_classes.Call):\n        if node.func.name != 'ReadyToServeHotDog':\n            return\n\n        if self._is_in_prepare_for_serving:\n            return\n\n        self.add_message(\n            'unverified-ready-to-serve-hotdog', node=node,\n        )\n```", "```py\n    def register(linter: PyLinter):\n        linter.register_checker(ReadyToServeHotDogChecker(linter))\n```", "```py\npip install mccabe\n```", "```py\npython -m mccabe --min 5 mccabe.py\n192:4: 'PathGraphingAstVisitor._subgraph_parse' 5\n273:0: 'get_code_complexity' 5\n298:0: '_read' 5\n315:0: 'main' 7\n```", "```py\ndef _subgraph_parse(self, node, pathnode, extra_blocks):\n       \"\"\"parse the body and any `else` block of `if` and `for` statements\"\"\"\n       loose_ends = []\n       self.tail = pathnode\n       self.dispatch_list(node.body)\n       loose_ends.append(self.tail)\n       for extra in extra_blocks:\n           self.tail = pathnode\n           self.dispatch_list(extra.body)\n           loose_ends.append(self.tail)\n       if node.orelse:\n           self.tail = pathnode\n           self.dispatch_list(node.orelse)\n           loose_ends.append(self.tail)\n       else:\n           loose_ends.append(pathnode)\n       if pathnode:\n           bottom = PathNode(\"\", look='point')\n           for le in loose_ends:\n               self.graph.connect(le, bottom)\n           self.tail = bottom\n```", "```py\ndef get_amount_of_preceding_whitespace(line: str) -> int:\n    # replace tabs with 4 spaces (and start tab/spaces flame-war)\n    tab_normalized_text = line.replace(\"\\t\", \"    \")\n    return len(tab_normalized_text) - len(tab_normalized_text.lstrip())\n\ndef get_average_whitespace(filename: str):\n    with open(filename) as file_to_check:\n        whitespace_count = [get_amount_of_preceding_whitespace(line)\n                            for line in file_to_check\n                            if line != \"\"]\n        average = sum(whitespace_count) / len(whitespace_count) / 4\n        print(f\"Avg indentation level for {filename}: {average}\")\n```", "```py\npip install bandit\nbandit -r path/to/your/code\n```"]