- en: Chapter 19\. Client-Side Network Protocol Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章 客户端网络协议模块
- en: Python’s standard library supplies several modules to simplify the use of internet
    protocols on both the client and server sides. These days, the [Python Package
    Index](https://oreil.ly/PGIim), best known as *PyPI*, offers many more such packages.
    Because many of the standard library modules date back to the previous century,
    you will find that nowadays third-party packages support a wider array of protocols,
    and several offer better APIs than the standard library’s equivalents. When you
    need to use a network protocol that’s missing from the standard library, or covered
    by the standard library in a way you think is not satisfactory, be sure to search
    PyPI—you’re likely to find better solutions there.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的标准库提供了几个模块，简化了客户端和服务器端使用互联网协议的过程。如今，被称为 *PyPI* 的 [Python 包索引](https://oreil.ly/PGIim)
    提供了更多类似的包。因为许多标准库模块可以追溯到上个世纪，您会发现现在第三方包支持更多的协议，并且一些比标准库提供的 API 更好。当您需要使用标准库中缺少的或者您认为标准库中的方式不尽如人意的网络协议时，请务必搜索
    PyPI——您很可能会在那里找到更好的解决方案。
- en: 'In this chapter, we cover some standard library packages that allow relatively
    simple uses of network protocols: these let you code without requiring third-party
    packages, making your application or library easier to install on other machines.
    You may therefore come across them when dealing with legacy code, and their simplicity
    also makes them interesting reading for the Python student. We also mention a
    few third-party packages covering important network protocols not included in
    the standard library, but we do not cover third-party packages using asynchronous
    programming.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些标准库包，允许相对简单地使用网络协议：这些包使您可以在不需要第三方包的情况下编码，使您的应用程序或库更容易安装在其他计算机上。因此，在处理遗留代码时可能会遇到它们，它们的简单性也使它们成为
    Python 学习者感兴趣的阅读材料。
- en: For the very frequent use case of HTTP clients and other network resources (such
    as anonymous FTP sites) best accessed via URLs, the third-party [requests package](https://oreil.ly/t4X8r)
    is even recommended in the Python documentation, so we cover that and recommend
    its use instead of standard library modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 HTTP 客户端和其他最好通过 URL 访问的网络资源（如匿名 FTP 站点）的频繁使用情况，第三方 [requests 包](https://oreil.ly/t4X8r)
    甚至被 Python 文档推荐，因此我们涵盖了它并推荐使用，而不是使用标准库模块。
- en: Email Protocols
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件协议
- en: Most email today is *sent* via servers implementing the Simple Mail Transport
    Protocol (SMTP) and *received* via servers and clients using Post Office Protocol
    version 3 (POP3) and/or Internet Message Access Protocol version 4 (IMAP4).^([1](ch19.xhtml#ch01fn140))
    Clients for these protocols are supported by the Python standard library modules
    smtplib, poplib, and imaplib, respectively, the first two of which we cover in
    this book. When you need to handle *parsing* or *generating* email messages, use
    the email package, covered in [Chapter 21](ch21.xhtml#emailcomma_mimecomma_and_other_network).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，大多数电子邮件是通过实现简单邮件传输协议（SMTP）的服务器*发送*，并通过使用邮局协议版本3（POP3）和/或互联网消息访问协议版本4（IMAP4）的服务器和客户端*接收*。^([1](ch19.xhtml#ch01fn140))
    这些协议的客户端由 Python 标准库模块smtplib、poplib和imaplib支持，我们在本书中介绍了前两者。当您需要处理电子邮件消息的*解析*或*生成*时，请使用电子邮件包，本书在
    [第21章](ch21.xhtml#emailcomma_mimecomma_and_other_network) 中有所介绍。
- en: 'If you need to write a client that can connect via either POP3 or IMAP4, a
    standard recommendation would be to pick IMAP4, since it is more powerful and—according
    to Python’s own online docs—often more accurately implemented on the server side.
    Unfortunately, imaplib is very complex, and far too vast to cover in this book.
    If you do choose to go that route, use the [online docs](https://oreil.ly/3ncIi),
    inevitably complemented by the IMAP RFCs, and possibly other related RFCs, such
    as 5161 and 6855 for capabilities and 2342 for namespaces. Using the RFCs in addition
    to the online docs for the standard library module can’t be avoided: many of the
    arguments passed to imaplib functions and methods, and results from calling them,
    are strings with formats that are only documented in the RFCs, not in Python’s
    own docs. A highly recommended alternative is to use the simpler, higher-abstraction-level
    third-party package [IMAPClient](https://oreil.ly/xTc4T), available with a **pip
    install** and well documented [online](https://oreil.ly/SuiI_).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要编写一个既可以通过POP3也可以通过IMAP4连接的客户端，一个标准的建议是选择IMAP4，因为它更强大，并且——根据Python自己的在线文档——通常在服务器端实现得更精确。不幸的是，imaplib非常复杂，远超过本书的涵盖范围。如果你选择这条路，需要使用[在线文档](https://oreil.ly/3ncIi)，并且不可避免地要补充IMAP
    RFCs，可能还包括其他相关的RFCs，如5161和6855（用于能力）以及2342（用于命名空间）。除了标准库模块的在线文档外，还必须使用RFCs：imaplib函数和方法传递的许多参数以及调用它们的结果，都是字符串格式，只有RFCs中有详细说明，而Python的文档中没有。一个强烈推荐的替代方案是使用更简单、更高抽象级别的第三方包[IMAPClient](https://oreil.ly/xTc4T)，可以通过**pip
    install**安装，并且有很好的[在线文档](https://oreil.ly/SuiI_)。
- en: The poplib Module
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: poplib模块
- en: 'The poplib module supplies a class, POP3, to access a POP mailbox.^([2](ch19.xhtml#ch01fn141))
    The constructor has the following signature:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: poplib模块提供了一个访问POP邮箱的POP3类。^([2](ch19.xhtml#ch01fn141)) 构造函数具有以下签名：
- en: '| POP3 | **class** POP3(*host*, port=110) Returns an instance *p* of class
    POP3 connected to the specified *host* and port. The class POP3_SSL behaves just
    the same, but connects to the host (by default on port 995) over a secure TLS
    channel; it’s needed to connect to email servers that demand some minimum security,
    such as pop.gmail.com.^([a](ch19.xhtml#ch01fn142)) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| POP3 | **class** POP3(*host*, port=110) 返回一个连接到指定*host*和端口的POP3类实例*p*。类POP3_SSL的行为完全相同，但通过安全的TLS通道连接到主机（默认端口995）；这对需要连接到要求一定最小安全性的电子邮件服务器（如pop.gmail.com）是必需的。^([a](ch19.xhtml#ch01fn142-marker))
    |'
- en: '| ^([a](ch19.xhtml#ch01fn142-marker)) To connect to a Gmail account, in particular,
    you need to configure that account to enable POP, “allow less secure apps,” and
    avoid two-step verification—things that in general we don’t recommend, as they
    weaken your email’s security. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch19.xhtml#ch01fn142-marker)) 要连接到Gmail账户，特别是，你需要配置该账户以启用POP，“允许不安全的应用程序”，并避免两步验证——这些一般情况下我们不推荐，因为它们会削弱你的电子邮件安全性。
    |'
- en: An instance *p* of the class POP3 supplies many methods; the most frequently
    used are listed in [Table 19-1](#methods_of_an_instance_p_of_popthree). In each
    case, *msgnum*, the identifying number of a message, can be a string containing
    an integer value or an int.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 类POP3的实例*p*提供了许多方法；最常用的列在[表 19-1](#methods_of_an_instance_p_of_popthree)中。在每种情况下，*msgnum*，一个消息的标识号，可以是包含整数值的字符串或整数。
- en: Table 19-1\. Methods of an instance p of POP3
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表 19-1\. POP3类实例*p*的方法
- en: '| dele | *p*.dele(*msgnum*) Marks message *msgnum* for deletion and returns
    the server response string. The server queues such deletion requests, and executes
    them only when you terminate this connection by calling *p*.quit.^([a](ch19.xhtml#ch01fn143))
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| dele | *p*.dele(*msgnum*) 标记消息*msgnum*以便删除，并返回服务器响应字符串。服务器会排队这样的删除请求，只有在你通过调用*p*.quit终止连接时才执行。^([a](ch19.xhtml#ch01fn143))
    |'
- en: '| list | *p*.list(*msgnum*=**None**) Returns a three-item tuple (*response*,
    *messages*, *octets*), where *response* is the server response string; *messages*
    a list of bytestrings, each of two words b''*msgnum* *bytes*'', the message number
    and length, in bytes, of each message in the mailbox; and *octets* is the length,
    in bytes, of the total response. When *msgnum* is not **None**, list returns a
    string, the response for the given *msgnum*, not a tuple. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| list | *p*.list(*msgnum*=**None**) 返回一个三元组(*response*, *messages*, *octets*)，其中*response*是服务器响应字符串；*messages*是一个由字节串组成的列表，每个字节串由两个词组成b''*msgnum*
    *bytes*''，每个消息的消息编号和字节长度；*octets*是总响应的字节长度。当*msgnum*不为**None**时，list返回一个字符串，给定*msgnum*的响应，而不是一个元组。'
- en: '| pass_ | *p*.pass_(*password*) Sends the password to the server, and returns
    the server response string. Must be called after *p*.user. The trailing underscore
    in the name is needed because **pass** is a Python keyword. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| pass_ | *p*.pass_(*password*) 向服务器发送密码，并返回服务器响应字符串。必须在 *p*.user 之后调用。名称中的下划线是因为
    **pass** 是 Python 的关键字。 |'
- en: '| quit | *p*.quit() Ends the session and tells the server to perform deletions
    that were requested by calls to *p*.dele. Returns the server response string.
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| quit | *p*.quit() 结束会话并告知服务器执行调用 *p*.dele 请求的删除操作。返回服务器响应字符串。 |'
- en: '| retr | *p*.retr(*msgnum*) Returns a three-item tuple (*response*, *lines*,
    *bytes*), where *response* is the server response string, *lines* is the list
    of all lines in message *msgnum* as bytestrings, and *bytes* is the total number
    of bytes in the message. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| retr | *p*.retr(*msgnum*) 返回一个三元组（*response*, *lines*, *bytes*），其中 *response*
    是服务器响应字符串，*lines* 是消息 *msgnum* 的所有行的列表（以字节串形式），*bytes* 是消息的总字节数。 |'
- en: '| s⁠e⁠t⁠_​d⁠e⁠b⁠u⁠g⁠l⁠e⁠v⁠e⁠l | *p*.set_debuglevel(*debug_level*) Sets the
    debug level to *debug_level*, an int with value 0 (the default) for no debugging,
    1 for a modest amount of debugging output, or 2 or more for a complete output
    trace of all control information exchanged with the server. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| s⁠e⁠t⁠_​d⁠e⁠b⁠u⁠g⁠l⁠e⁠v⁠e⁠l | *p*.set_debuglevel(*debug_level*) 将调试级别设置为
    *debug_level*，一个整数，值为 0（默认）表示无调试输出，1 表示适量的调试输出，2 或更高表示所有与服务器交换的控制信息的完整输出跟踪。 |'
- en: '| stat | *p*.stat() Returns a pair (*num_msgs*, *bytes*), where *num_msgs*
    is the number of messages in the mailbox and *bytes* is the total number of bytes.
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| stat | *p*.stat() 返回一个二元组（*num_msgs*, *bytes*），其中 *num_msgs* 是邮箱中的消息数，*bytes*
    是总字节数。 |'
- en: '| top | *p*.top(*msgnum*, *maxlines*) Like retr, but returns at most *maxlines*
    lines from the message’s body (in addition to all the lines from the headers).
    Can be useful for peeking at the start of long messages. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| top | *p*.top(*msgnum*, *maxlines*) 类似 retr，但最多返回消息体的 *maxlines* 行（除了所有的头部行）。对于查看长消息开头很有用。
    |'
- en: '| user | *p*.user(*username*) Sends the server the username; invariably followed
    up by a call to *p*.pass_. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| user | *p*.user(*username*) 向服务器发送用户名；随后必然调用 *p*.pass_。 |'
- en: '| ^([a](ch19.xhtml#ch01fn143-marker)) The standard states that if disconnection
    occurs before the quit call, the deletions should not be actioned. Despite this,
    some servers will perform the deletion after any disconnection, planned or unplanned.
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch19.xhtml#ch01fn143-marker)) 标准规定，如果在 quit 调用之前发生断开连接，不应执行删除操作。尽管如此，某些服务器在任何断开连接后（计划或非计划）都会执行删除操作。
    |'
- en: The smtplib Module
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: smtplib 模块
- en: 'The smtplib module supplies a class, SMTP, to send mail via an SMTP server.^([3](ch19.xhtml#ch01fn144))
    The constructor has the following signature:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: smtplib 模块提供一个 SMTP 类来通过 SMTP 服务器发送邮件。^([3](ch19.xhtml#ch01fn144)) 构造函数的签名如下：
- en: '| SMTP | class SMTP([*host*, port=25]) Returns an instance *s* of the class
    SMTP. When *host* (and optionally port) is given, implicitly calls *s*.connect(*host*,
    port). The class SMTP_SSL behaves just the same, but connects to the host (by
    default on port 465) over a secure TLS channel; it’s needed to connect to email
    servers that demand some minimum security, such as smtp.gmail.com. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| SMTP | class SMTP([*host*, port=25]) 返回 SMTP 类的实例 *s*。当给定 *host*（和可选的 port）时，隐式调用
    *s*.connect(*host*, port)。SMTP_SSL 类的行为完全相同，但通过安全的 TLS 通道连接到主机（默认端口 465），用于连接要求一定最小安全性的电子邮件服务器，如
    smtp.gmail.com。 |'
- en: An instance *s* of the class SMTP supplies many methods. The most frequently
    used of these are listed in [Table 19-2](#methods_of_an_instance_s_of_smtp).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP 类的实例 *s* 提供许多方法。其中最常用的列在 [表 19-2](#methods_of_an_instance_s_of_smtp) 中。
- en: Table 19-2\. Methods of an instance s of SMTP
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表 19-2\. SMTP 实例 s 的方法
- en: '| connect | *s*.connect(host=127.0.0.1, port=25) Connects to an SMTP server
    on the given host (by default, the local host) and port (port 25 is the default
    port for the SMTP service; 465 is the default port for the more secure “SMTP over
    TLS”). |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| connect | *s*.connect(host=127.0.0.1, port=25) 连接到给定主机（默认为本地主机）和端口的 SMTP
    服务器（SMTP 服务的默认端口为 25；更安全的“SMTP over TLS”默认端口为 465）。 |'
- en: '| login | *s*.login(*user*, *password*) Logs in to the server with the given
    *user* and *password*. Needed only if the SMTP server requires authentication
    (as just about all do). |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| login | *s*.login(*user*, *password*) 使用给定的 *user* 和 *password* 登录服务器。只有在
    SMTP 服务器需要身份验证时才需要（几乎所有服务器都需要）。 |'
- en: '| quit | *s*.quit() Terminates the SMTP session. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| quit | *s*.quit() 终止 SMTP 会话。 |'
- en: '| sendmail | *s*.sendmail(*from_addr*, *to_addrs*, *msg_string*) Sends mail
    message *msg_string* from the sender whose address is in string *from_addr* to
    each of the recipients in the list *to_addrs*.^([a](ch19.xhtml#ch01fn145)) *msg_string*
    must be a complete RFC 822 message in a single multiline bytestring: the headers,
    an empty line for separation, then the body. The mail transport mechanism uses
    only *from_addr* and *to_addrs* to determine routing, ignoring any headers in
    *msg_string*.^([b](ch19.xhtml#ch01fn146)) To prepare RFC 822–compliant messages,
    use the package email, covered in [“MIME and Email Format Handling”](ch21.xhtml#mime_and_email_format_handling).
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| sendmail | *s*.sendmail(*from_addr*, *to_addrs*, *msg_string*) 从字符串*from_addr*中发送邮件消息*msg_string*，并分别发送给列表*to_addrs*中的每个收件人。^([a](ch19.xhtml#ch01fn145))
    *msg_string*必须是一个完整的RFC 822消息，是一个多行的字节字符串：包括头部、用于分隔的空行，然后是正文。邮件传输机制仅使用*from_addr*和*to_addrs*来确定路由，忽略*msg_string*中的任何头部。^([b](ch19.xhtml#ch01fn146))
    要准备符合RFC 822的消息，请使用email包，该包在[“MIME和电子邮件格式处理”](ch21.xhtml#mime_and_email_format_handling)中介绍。
    |'
- en: '| send_message | *s.*send_message(*msg,* from_addr=**None**, to_addrs=**None**)
    A convenience function taking an email.message.Message object as its first argument.
    If either or both of from_addr and to_addrs are **None**, they are extracted from
    the message instead. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| send_message | *s.*send_message(*msg,* from_addr=**None**, to_addrs=**None**)
    这是一个便捷函数，第一个参数为email.message.Message对象。如果*from_addr*和*to_addrs*中任一或两者为**None**，则会从消息中提取它们。
    |'
- en: '| ^([a](ch19.xhtml#ch01fn145-marker)) While the standard places no limits on
    the number of recipients in *from_addr*, individual mail servers may well do so,
    often making it advisable to batch messages with a maximum number of recipients
    in each one.^([b](ch19.xhtml#ch01fn146-marker)) This allows email systems to implement
    Bcc (blind copy) emails, for example, as the routing does not depend on the message
    envelope. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch19.xhtml#ch01fn145-marker)) 标准并未限制*from_addr*中收件人的数量，但是各个邮件服务器可能会限制，因此建议每个批处理消息中的收件人数量不要太多。^([b](ch19.xhtml#ch01fn146-marker))
    这样做可以支持邮件系统实现密送（Bcc）邮件，因为路由不依赖于消息信封。 |'
- en: HTTP and URL Clients
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP和URL客户端
- en: 'Most of the time, your code uses the HTTP and FTP protocols through the higher-abstraction
    URL layer, supported by the modules and packages covered in the following sections.
    Python’s standard library also offers lower-level, protocol-specific modules that
    are less often used: for FTP clients, [ftplib](https://oreil.ly/O_XHc); for HTTP
    clients, http.client (we cover HTTP servers in [Chapter 20](ch20.xhtml#serving_http)).
    If you need to write an FTP server, look at the third-party module [pyftpdlib](https://oreil.ly/Qrvcn).
    Implementations of the newer [HTTP/2](https://http2.github.io) may not be fully
    mature, but your best bet as of this writing is the third-party module [HTTPX](https://www.python-httpx.org).
    We do not cover any of these lower-level modules in this book: we focus on higher-abstraction,
    URL-level access throughout the following sections.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 绝大多数情况下，您的代码会通过更高级别的URL层使用HTTP和FTP协议，这些协议由下一节介绍的模块和包支持。Python标准库还提供了较低级别的、特定于协议的模块，不过这些模块使用频率较低：对于FTP客户端，使用[ftplib](https://oreil.ly/O_XHc)；对于HTTP客户端，使用http.client（我们在[第20章](ch20.xhtml#serving_http)介绍HTTP服务器）。如果需要编写FTP服务器，请考虑第三方模块[pyftpdlib](https://oreil.ly/Qrvcn)。在撰写本书时，较新的[HTTP/2](https://http2.github.io)实现可能尚不完全成熟，但目前最佳选择是第三方模块[HTTPX](https://www.python-httpx.org)。我们在本书中不涉及这些较低级别的模块，而是专注于整个下一节的更高级别、URL级别的访问。
- en: URL Access
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL访问
- en: 'A URL is a type of uniform resource identifier (URI). A URI is a string that
    *identifies* a resource (but does not necessarily *locate* it), while a URL *locates*
    a resource on the internet. A URL is a string composed of several parts (some
    optional), called *components*: the *scheme, location, path, query*, and *fragment.*
    (The second component is sometimes also known as a *net location*, or *netloc*
    for short.) A URL with all parts looks like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: URI是一种统一资源标识符（URI）的一种类型。URI是一个字符串，用于*标识*资源（但不一定*定位*资源），而URL用于在互联网上*定位*资源。URL由几个部分（某些可选）组成，称为*组件*：*scheme,
    location, path, query*和*fragment*。（第二个组件有时也被称为*网络位置*或简称*netloc*。）具有所有部分的URL看起来像这样：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In *https://www.python.org/community/awards/psf-awards/#october-2016*, for
    example, the scheme is *http*, the location is *www.python.org*, the path is */community/awards/psf-awards/*,
    there is no query, and the fragment is *#october-2016.* (Most schemes default
    to a *well-known port* when the port is not explicitly specified; for example,
    80 is the well-known port for the HTTP scheme.) Some punctuation is part of one
    of the components it separates; other punctuation characters are just separators,
    not part of any component. Omitting punctuation implies missing components. For
    example, in *mailto:me@you.com*, the scheme is *mailto*, the path is *me@you.com*
    (*mailto:me@you.com*), and there is no location, query, or fragment. No // means
    the URI has no location, no ? means it has no query, and no # means it has no
    fragment.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在*https://www.python.org/community/awards/psf-awards/#october-2016*中，方案为*http*，位置为*www.python.org*，路径为*/community/awards/psf-awards/*，无查询，片段为*#october-2016*。（大多数方案在未明确指定端口时会默认使用一个*众所周知的端口*；例如，HTTP方案的众所周知端口为80。）某些标点符号是其分隔的组件的一部分；其他标点字符只是分隔符，并非任何组件的一部分。省略标点符号意味着缺少组件。例如，在*mailto:me@you.com*中，方案为*mailto*，路径为*me@you.com*（*mailto:me@you.com*），无位置、查询或片段。没有//表示URI无位置，没有？表示URI无查询，没有#表示URI无片段。
- en: If the location ends with a colon followed by a number, this denotes a TCP port
    for the endpoint. Otherwise, the connection uses the well-known port associated
    with the scheme (e.g., port 80 for HTTP).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果位置以冒号结尾，后跟一个数字，则表示终点的TCP端口。否则，连接使用与方案关联的众所周知端口（例如，HTTP的端口80）。
- en: The urllib Package
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: urllib包
- en: The urllib package supplies several modules for parsing and utilizing URL strings
    and associated resources. In addition to the urllib.parse and urllib.request modules
    described here, these include the module urllib.robotparser (for the specific
    purpose of parsing a site’s *robots.txt* file as per [RFC 9309](https://oreil.ly/QI7CQ))
    and the module urllib.error, containing all exception types raised by other urllib
    modules.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: urllib包提供了几个模块来解析和利用URL字符串及其相关资源。除了这里描述的urllib.parse和urllib.request模块外，还包括urllib.robotparser模块（专门用于根据[RFC
    9309](https://oreil.ly/QI7CQ)解析站点的*robots.txt*文件）和urllib.error模块，包含其他urllib模块引发的所有异常类型。
- en: The urllib.parse module
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: urllib.parse模块
- en: The urllib.parse module supplies functions for analyzing and synthesizing URL
    strings, and is typically imported with **from** urllib **import** parse **as**
    urlparse. Its most frequently used functions are listed in [Table 19-3](#useful_functions_of_the_urllibdotparse).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: urllib.parse模块提供了用于分析和合成URL字符串的函数，并通常使用**from** urllib **import** parse **as**
    urlparse导入。其最常用的函数列在[表 19-3](#useful_functions_of_the_urllibdotparse)中。
- en: Table 19-3\. Useful functions of the urllib.parse module
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表19-3\. urllib.parse模块的常用函数
- en: '| urljoin | urljoin(*base_url_string*, *relative_url_string*) Returns a URL
    string *u*, obtained by joining *relative_url_string*, which may be relative,
    with *base_url_string*. The joining procedure that urljoin performs to obtain
    its result may be summarized as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '| urljoin | urljoin(*base_url_string*, *relative_url_string*) 返回一个URL字符串*u*，该字符串通过将*relative_url_string*（可能是相对的）与*base_url_string*连接而得到。urljoin执行的连接过程可总结如下：'
- en: When either of the argument strings is empty, *u* is the other argument.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任一参数字符串为空时，*u*即为另一个参数。
- en: When *relative_url_string* explicitly specifies a scheme that is different from
    that of *base_url_string**,* *u* is *relative_url_string*. Otherwise, *u*’s scheme
    is that of *base_url_string*.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当*relative_url_string*明确指定与*base_url_string*不同的方案时，*u*为*relative_url_string*。否则，*u*的方案为*base_url_string*的方案。
- en: When the scheme does not allow relative URLs (e.g., mailto), or when *relative_url_string*
    explicitly specifies a location (even when it is the same as the location of *base_url_string*),
    all other components of *u* are those of *relative_url_string*. Otherwise, *u*’s
    location is that of *base_url_string*.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当方案不允许相对URL（例如，mailto）或*relative_url_string*明确指定位置（即使与*base_url_string*的位置相同）时，*u*的所有其他组件均为*relative_url_string*的组件。否则，*u*的位置为*base_url_string*的位置。
- en: '*u*’s path is obtained by joining the paths of *base_url_string* and *relative_url_string*
    according to standard syntax for absolute and relative URL paths.^([a](ch19.xhtml#ch01fn147))
    For example:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*u*的路径通过根据绝对和相对URL路径的标准语法连接*base_url_string*和*relative_url_string*的路径而获得。^([a](ch19.xhtml#ch01fn147))
    例如：'
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| urlsplit | urlsplit(*url_string*, default_scheme='''', allow_fragments=**True**)
    Analyzes *url_string* and returns a tuple (actually an instance of SplitResult,
    which you can treat as a tuple or use with named attributes) with five string
    items: *scheme*, *netloc*, *path*, *query*, and *fragment**.* *default_scheme*
    is the first item when the *url_string* lacks an explicit scheme. When allow_fragments
    is **False**, the tuple’s last item is always '''', whether or not *url_string*
    has a fragment. Items corresponding to missing parts are also ''''. For example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '| urlsplit | urlsplit(*url_string*, default_scheme='''', allow_fragments=**True**)
    分析 *url_string* 并返回一个五个字符串项的元组（实际上是 SplitResult 实例，可以将其视为元组或与命名属性一起使用）：*scheme*、*netloc*、*path*、*query*
    和 *fragment**。当 allow_fragments 为 **False** 时，无论 *url_string* 是否具有片段，元组的最后一项始终为''''。对应缺少部分的项也为''''。例如：'
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| urlunsplit | urlunsplit(*url_tuple*) *url_tuple* is any iterable with exactly
    five items, all strings. Any return value from a urlsplit call is an acceptable
    argument for urlunsplit. urlunsplit returns a URL string with the given components
    and the needed separators, but with no redundant separators (e.g., there is no
    # in the result when the fragment, *url_tuple*’s last item, is '''' ). For example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '| urlunsplit | urlunsplit(*url_tuple*) *url_tuple* 是任何具有确切五个项的可迭代对象，全部为字符串。从
    urlsplit 调用的任何返回值都是 urlunsplit 的可接受参数。urlunsplit 返回具有给定组件和所需分隔符但无冗余分隔符的 URL 字符串（例如，当
    fragment，*url_tuple* 的最后一项为''''时，结果中没有 #）。例如：'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'urlunsplit(urlsplit(*x*)) returns a normalized form of URL string *x*, which
    is not necessarily equal to *x* because *x* need not be normalized. For example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: urlunsplit(urlsplit(*x*)) 返回 URL 字符串 *x* 的规范形式，这不一定等于 *x*，因为 *x* 不一定是规范化的。例如：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, the normalization ensures that redundant separators, such as the
    trailing ? in the argument to urlsplit, are not present in the result. |
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，规范化确保结果中不存在冗余分隔符，例如在 urlsplit 参数中的尾部 ?。
- en: '| ^([a](ch19.xhtml#ch01fn147-marker)) Per [RFC 1808](https://oreil.ly/T9v1p).
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch19.xhtml#ch01fn147-marker)) 根据 [RFC 1808](https://oreil.ly/T9v1p)。'
- en: The urllib.request module
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: urllib.request 模块
- en: The urllib.request module supplies functions for accessing data resources over
    standard internet protocols, the most commonly used of which are listed in [Table 19-4](#useful_functions_of_the_urllibdotreques).
    (The examples in the table assume you’ve imported the module.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: urllib.request 模块提供了访问标准互联网协议上的数据资源的函数，其中最常用的列在 [Table 19-4](#useful_functions_of_the_urllibdotreques)
    中（表中的示例假定您已导入了该模块）。
- en: Table 19-4\. Useful functions of the urllib.request module
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表 19-4\. urllib.request 模块的有用函数
- en: '| urlopen | urlopen(*url*, data=**None***,* timeout*,* context=**None**) Returns
    a response object whose type depends on the scheme in *url*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '| urlopen | urlopen(*url*, data=**None***,* timeout*,* context=**None**) 返回一个响应对象，其类型取决于
    *url* 中的方案：'
- en: HTTP and HTTPS URLs return an http.client.HTTPResponse object (with the msg
    attribute modified to contain the same data as the reason attribute; for details,
    see the [online docs](https://oreil.ly/gWFcH)). Your code can use this object
    like an iterable, and as a context manager in a **with** statement.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 和 HTTPS URL 返回一个 http.client.HTTPResponse 对象（具有修改的 msg 属性以包含与 reason 属性相同的数据；详情请参阅[在线文档](https://oreil.ly/gWFcH)）。您的代码可以像处理可迭代对象一样使用此对象，并作为上下文管理器在
    **with** 语句中使用。
- en: FTP, file, and data URLs return a urllib.response.addinfourl object.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTP、文件和数据 URL 返回一个 urllib.response.addinfourl 对象。
- en: '*url* is the string or urllib.request.Request object for the URL to open. *data*
    is an optional bytes object, file-like object, or iterable of bytes, encoding
    additional data to send to the URL following *application/x-www-form-urlencoded*
    format. *timeout* is an optional argument for specifying, in seconds, a timeout
    for blocking operations of the URL opening process, applicable only for HTTP,
    HTTPS, and FTP URLs. When *context* is given, it must contain an ssl.SSLContext
    object specifying SSL options; *context* replaces the deprecated *cafile*, *capath*,
    and *cadefault* arguments. The following example downloads a file from an HTTPS
    URL and extracts it into a local bytes object, unicode_db:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*url* 是要打开的 URL 的字符串或 urllib.request.Request 对象。*data* 是一个可选的 bytes 对象、类文件对象或
    bytes 的可迭代对象，用于编码发送到 URL 的额外数据，格式为 *application/x-www-form-urlencoded*。*timeout*
    是一个可选参数，用于指定 URL 打开过程中阻塞操作的超时时间，单位为秒，仅适用于 HTTP、HTTPS 和 FTP URL。当给出 *context* 时，必须包含一个
    ssl.SSLContext 对象，指定 SSL 选项；*context* 取代了已弃用的 *cafile*、*capath* 和 *cadefault*
    参数。以下示例从 HTTPS URL 下载文件并提取为本地的 bytes 对象，unicode_db：'
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| u⁠r⁠l​r⁠e⁠t⁠r⁠i⁠e⁠v⁠e | urlretrieve(*url_string*, filename=**None**, report_hook=**None**,
    data=**None**) A compatibility function to support migration from Python 2 legacy
    code. *url_string* gives the URL of the resource to download. filename is an optional
    string naming the local file in which to store the data retrieved from the URL.
    report_hook is a callable to support progress reporting during downloading, called
    once as each block of data is retrieved. data is similar to the data argument
    for urlopen. In its simplest form, urlretrieve is equivalent to:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '| u⁠r⁠l​r⁠e⁠t⁠r⁠i⁠e⁠v⁠e | urlretrieve(*url_string*, filename=**None**, report_hook=**None**,
    data=**None**) 一个兼容性函数，用于支持从 Python 2 遗留代码的迁移。*url_string* 给出要下载资源的 URL。filename
    是一个可选的字符串，用于命名从 URL 检索的数据存储在本地文件中。report_hook 是一个可调用对象，支持在下载过程中报告进度，每次检索数据块时调用一次。data
    类似于 urlopen 的 data 参数。在其最简单的形式下，urlretrieve 等效于：'
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since this function was developed for Python 2 compatibility, you may still
    see it in existing codebases. New code should use urlopen. |
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个函数是为了 Python 2 的兼容性而开发的，您可能仍然会在现有的代码库中看到它。新代码应该使用 urlopen。
- en: For full coverage of urllib.request see the [online docs](https://oreil.ly/Vz9IV)
    and Michael Foord’s [HOWTO](https://oreil.ly/6Lrem), which includes examples on
    downloading files given a URL. There’s a short example using urllib.request in
    [“An HTML Parsing Example with BeautifulSoup”](ch22.xhtml#an_html_parsing_example_with_beautifuls).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面了解 urllib.request，请参阅[在线文档](https://oreil.ly/Vz9IV)和 Michael Foord 的 [HOWTO](https://oreil.ly/6Lrem)，其中包括根据
    URL 下载文件的示例。在 [“使用 BeautifulSoup 进行 HTML 解析的示例”](ch22.xhtml#an_html_parsing_example_with_beautifuls)
    中有一个使用 urllib.request 的简短示例。
- en: The Third-Party requests Package
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方 requests 包
- en: The third-party [requests package](https://oreil.ly/cOiit) (very well documented
    [online](https://oreil.ly/MiQ76)) is how we recommend you access HTTP URLs. As
    usual for third-party packages, it’s best installed with a simple **pip install
    requests**. In this section, we summarize how best to use it for reasonably simple
    cases.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方 [requests package](https://oreil.ly/cOiit)（非常好地[在线文档](https://oreil.ly/MiQ76)记录）是我们推荐您访问
    HTTP URL 的方式。像其他第三方包一样，最好通过简单的 **pip install requests** 进行安装。在本节中，我们总结了如何在相对简单的情况下最佳地使用它。
- en: Natively, requests only supports the HTTP and HTTPS transport protocols; to
    access URLs using other protocols, you need to install other third-party packages
    (known as *protocol adapters*), such as [requests-ftp](https://oreil.ly/efT73)
    for FTP URLs, or others supplied as part of the rich [requests-toolbelt](https://oreil.ly/_6nQe)
    package of requests utilities.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请求模块本地仅支持 HTTP 和 HTTPS 传输协议；要访问其他协议的 URL，您需要安装其他第三方包（称为*协议适配器*），例如 [requests-ftp](https://oreil.ly/efT73)
    用于 FTP URL，或作为丰富的 [requests-toolbelt](https://oreil.ly/_6nQe) 包的一部分提供的其他实用工具包。
- en: 'The requests package’s functionality hinges mostly on three classes it supplies:
    Request, modeling an HTTP request to be sent to a server; Response, modeling a
    server’s HTTP response to a request; and Session, offering continuity across a
    sequence of requests, also known as a *session.* For the common use case of a
    single request/response interaction, you don’t need continuity, so you may often
    just ignore Session.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: requests 包的功能主要依赖于它提供的三个类：Request，模拟发送到服务器的 HTTP 请求；Response，模拟服务器对请求的 HTTP
    响应；以及 Session，提供在一系列请求中的连续性，也称为*会话*。对于单个请求/响应交互的常见用例，您不需要连续性，因此通常可以忽略 Session。
- en: Sending requests
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送请求
- en: 'Typically, you don’t need to explicitly consider the Request class: rather,
    you call the utility function request, which internally prepares and sends the
    Request and returns the Response instance. request has two mandatory positional
    arguments, both strs: method, the HTTP method to use, and url, the URL to address.
    Then, many optional named parameters may follow (in the next section, we cover
    the most commonly used named parameters to the request function).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您不需要显式考虑 Request 类：而是调用实用函数 request，它内部准备并发送请求，并返回 Response 实例。request
    有两个必需的位置参数，都是字符串：method，要使用的 HTTP 方法，和 url，要访问的 URL。然后，可能会跟随许多可选的命名参数（在下一节中，我们涵盖了
    request 函数最常用的命名参数）。
- en: For further convenience, the requests module also supplies functions whose names
    are those of the HTTP methods delete, get, head, options, patch, post, and put;
    each takes a single mandatory positional argument, url, then the same optional
    named arguments as the function request.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步方便，requests 模块还提供了一些函数，它们的名称与 HTTP 方法 delete、get、head、options、patch、post
    和 put 相同；每个函数都接受一个必需的位置参数 url，然后是与函数 request 相同的可选命名参数。
- en: When you want some continuity across multiple requests, call Session to make
    an instance *s*, then use *s*’s methods request, get, post, and so on, which are
    just like the functions with the same names directly supplied by the requests
    module (however, *s*’s methods merge *s*’s settings with the optional named parameters
    to prepare each request to send to the given url).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望在多个请求中保持一致性时，调用 Session 创建一个实例 *s*，然后使用 *s* 的方法 request、get、post 等，它们就像直接由
    requests 模块提供的同名函数一样（然而，*s* 的方法将 *s* 的设置与准备发送到给定 url 的每个请求的可选命名参数合并）。
- en: request’s optional named parameters
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: request 的可选命名参数
- en: The function request (just like the functions get, post, and so on, and methods
    with the same names on an instance *s* of class Session) accepts many optional
    named parameters. Refer to the requests package’s excellent [online docs](https://oreil.ly/0rIwn)
    for the full set if you need advanced functionality such as control over proxies,
    authentication, special treatment of redirection, streaming, cookies, and so on.
    [Table 19-5](#named_parameters_accepted_by_the_reques) lists the most frequently
    used named parameters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 request（就像函数 get、post 等以及类 Session 的实例 *s* 上的同名方法一样）接受许多可选的命名参数。如果您需要高级功能，比如控制代理、身份验证、特殊的重定向处理、流式传输、cookies
    等，请参阅 requests 包的优秀[在线文档](https://oreil.ly/0rIwn)获取完整的参数集合。[表 19-5](#named_parameters_accepted_by_the_reques)
    列出了最常用的命名参数。
- en: Table 19-5\. Named parameters accepted by the request function
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表 19-5\. request 函数接受的命名参数列表
- en: '| data | A dict, a sequence of key/value pairs, a bytestring, or a file-like
    object to use as the body of the request |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| data | 一个字典、一组键值对、一个字节串或者一个类似文件的对象，用作请求的主体 |'
- en: '| files | A dict with names as keys and file-like objects or *file tuples*
    as values, used with the POST method to specify a multipart-encoding file upload
    (we cover the format of values for files in the next section) |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| files | 一个以名称为键、文件对象或*文件元组*为值的字典，与 POST 方法一起使用，用于指定多部分编码文件上传（我们将在下一节中讨论文件值的格式）
    |'
- en: '| headers | A dict of HTTP headers to send in the request |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| headers | 发送到请求中的 HTTP 头的字典 |'
- en: '| json | Python data (usually a dict) to encode as JSON as the body of the
    request |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| json | Python 数据（通常是一个字典）编码为 JSON 作为请求主体 |'
- en: '| params | A dict of (*name*, *value*) items, or a bytestring to send as the
    query string with the request |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| params | 一个(*name*, *value*)项的字典，或者作为查询字符串发送的字节串与请求一起 |'
- en: '| timeout | A float number of seconds, the maximum time to wait for the response
    before raising an exception |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| timeout | 秒数的浮点数，等待响应的最长时间，在引发异常之前 |'
- en: 'data, json, and files are mutually incompatible ways to specify a body for
    the request; you should normally use at most one of them, and only for HTTP methods
    that do use a body (namely PATCH, POST, and PUT). The one exception is that you
    can have both a data argument passing a dict and a files argument. That is very
    common usage: in this case, both the key/value pairs in the dict and the files
    form the body of the request as a single *multipart/form-data* whole.^([4](ch19.xhtml#ch01fn148))'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: data、json 和 files 是用于指定请求主体的相互不兼容的方式；通常您应该最多使用其中一个，只用于使用主体的 HTTP 方法（即 PATCH、POST
    和 PUT）。唯一的例外是您可以同时使用传递一个字典的 data 参数和一个 files 参数。这是非常常见的用法：在这种情况下，字典中的键值对和文件形成一个请求主体，作为一个*multipart/form-data*整体。^([4](ch19.xhtml#ch01fn148))
- en: The files argument (and other ways to specify the request’s body)
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: files 参数（以及其他指定请求主体的方法）
- en: When you specify the request’s body with json or data (passing a bytestring
    or a file-like object, which must be open for reading, usually in binary mode),
    the resulting bytes are directly used as the request’s body. When you specify
    it with data (passing a dict or a sequence of key/value pairs), the body is built
    as a *form*, from the key/value pairs formatted in *application/x-www-form-urlencoded*
    format, according to the relevant [web standard](https://oreil.ly/hHKp4).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 json 或 data（传递一个字节串或者一个必须打开以供读取的类文件对象，通常在二进制模式下）指定请求主体时，生成的字节直接用作请求的主体。当您使用
    data（传递一个字典或者一组键值对）指定时，主体以*表单*的形式构建，从键值对按*application/x-www-form-urlencoded*格式进行格式化，根据相关的[网络标准](https://oreil.ly/hHKp4)。
- en: When you specify the request’s body with files, the body is also built as a
    form, in this case with the format set to *multipart/form-data* (the only way
    to upload files in a PATCH, POST, or PUT HTTP request). Each file you’re uploading
    is formatted into its own part of the form; if, in addition, you want the form
    to give to the server further nonfile parameters, then in addition to files, you
    need to pass a data argument with a dict value (or a sequence of key/value pairs)
    for the further parameters. Those parameters get encoded into a supplementary
    part of the multipart form.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用 files 指定请求的主体时，该主体也作为一个表单构建，在这种情况下格式设置为*multipart/form-data*（在 PATCH、POST
    或 PUT HTTP 请求中上传文件的唯一方式）。你上传的每个文件都被格式化为表单的一个单独部分；如果你还希望表单向服务器提供进一步的非文件参数，则除了 files
    外，还需要传递一个数据参数，其值为字典（或键/值对序列）用于这些进一步的参数。这些参数被编码为多部分表单的补充部分。
- en: For flexibility, the value of the files argument can be a dict (its items are
    taken as a sequence of (*name*, *value*) pairs), or a sequence of (*name*, *value*)
    pairs (order is maintained in the resulting request body).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了灵活性，files 参数的值可以是一个字典（其条目被视为(*name*, *value*)对的序列），或者是(*name*, *value*)对的序列（结果请求体中的顺序保持不变）。
- en: Either way, each value in a (*name*, *value*) pair can be a str (or, better,^([5](ch19.xhtml#ch01fn149))
    a bytes or bytearray) to be used directly as the uploaded file’s contents, or
    a file-like object open for reading (then, requests calls .read() on it and uses
    the result as the uploaded file’s contents; we strongly urge that in such cases
    you open the file in binary mode to avoid any ambiguity regarding content length).
    When any of these conditions apply, requests uses the *name* part of the pair
    (e.g., the key into the dict) as the file’s name (unless it can improve on that
    because the open file object is able to reveal its underlying filename), takes
    its best guess at a content type, and uses minimal headers for the file’s form
    part.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，(*name*, *value*)对中的每个值可以是一个 str（或者更好地，^([5](ch19.xhtml#ch01fn149)) 是一个字节或字节数组），直接用作上传文件的内容，或者是一个打开用于读取的类文件对象（此时，requests
    调用 .read() 方法并使用结果作为上传文件的内容；我们强烈建议在这种情况下以二进制模式打开文件，以避免任何关于内容长度的歧义）。当满足这些条件之一时，requests
    使用对的 *name* 部分（例如，字典中的键）作为文件的名称（除非它能够改进这一点，因为打开的文件对象能够显示其基础文件名），尝试猜测内容类型，并为文件的表单部分使用最小的标头。
- en: Alternatively, the value in each (*name*, *value*) pair can be a tuple with
    two to four items, (*fn*, *fp*[, *ft*[, *fh*]]) (using square brackets as metasyntax
    to indicate optional parts). In this case, *fn* is the file’s name, *fp* provides
    the contents (in just the same way as in the previous paragraph), optional *ft*
    provides the content type (if missing, requests guesses it, as in the previous
    paragraph), and the optional dict *fh* provides extra headers for the file’s form
    part.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，每个(*name*, *value*)对中的值可以是一个包含两到四个项目的元组，(*fn*, *fp*[, *ft*[, *fh*]])（使用方括号作为元语法来表示可选部分）。在这种情况下，*fn*
    是文件的名称，*fp* 提供内容（与前一段中的方式相同），可选的 *ft* 提供内容类型（如果缺失，requests 将猜测它，如前一段中所示），可选的字典
    *fh* 提供文件表单部分的额外标头。
- en: How to interpret requests examples
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何解释 requests 的示例
- en: 'In practical applications, you don’t usually need to consider the internal
    instance *r* of the class requests.Request, which functions like requests.post
    is building, preparing, and then sending on your behalf. However, to understand
    exactly what requests is doing, working at a lower level of abstraction (building,
    preparing, and examining *r*—no need to send it!) is instructive. For example,
    after importing requests, passing data as in the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，通常不需要考虑类 requests.Request 的内部实例 *r*，该类函数类似于 requests.post 在你的代表中构建、准备，然后发送。然而，为了确切了解
    requests 的操作，以较低的抽象级别（构建、准备和检查 *r* —— 无需发送它！）是有益的。例如，在导入 requests 后，传递数据如下示例中所示：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'prints out (splitting the *p*.headers dict’s printout for readability):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（为了可读性，将 *p*.headers 字典的输出拆分）：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, when passing files:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在传递文件时：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'this prints out (with several lines split for readability):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出（几行被拆分以提高可读性）：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Happy interactive exploring!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 愉快的交互式探索！
- en: The Response class
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应类
- en: 'The one class from the requests module that you always have to consider is
    Response: every request, once sent to the server (typically, that’s done implicitly
    by methods such as get), returns an instance *r* of requests.Response.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: requests 模块中你总是需要考虑的一个类是 Response：每个请求，一旦发送到服务器（通常是通过 get 等方法隐式完成），都会返回一个 requests.Response
    实例 *r*。
- en: 'The first thing you usually want to do is to check *r*.status_code, an int
    that tells you how the request went, in typical “HTTPese”: 200 means “everything’s
    fine,” 404 means “not found,” and so on. If you’d rather just get an exception
    for status codes indicating some kind of error, call *r*.raise_for_status; that
    does nothing if the request went fine, but raises requests.exceptions.HTTPError
    otherwise. (Other exceptions, not corresponding to any specific HTTP status code,
    can and do get raised without requiring any such explicit call: e.g., ConnectionError
    for any kind of network problem, or TimeoutError for a timeout.)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常想要做的第一件事是检查*r*.status_code，一个告诉你请求进行情况的整数，在典型的“HTTPese”中：200表示“一切正常”，404表示“未找到”，等等。如果你希望对指示某种错误的状态码只获取异常，请调用*r*.raise_for_status；如果请求成功，它将不执行任何操作，但否则将引发requests.exceptions.HTTPError异常（其他异常，不对应任何特定的HTTP状态码，可能会被引发，而不需要任何明确的调用：例如任何网络问题的ConnectionError，或者超时的TimeoutError）。
- en: 'Next, you may want to check the response’s HTTP headers: for that, use *r*.headers,
    a dict (with the special feature of having case-insensitive string-only keys indicating
    the header names as listed, e.g., in [Wikipedia](https://oreil.ly/_nJRX), per
    the HTTP specs). Most headers can be safely ignored, but sometimes you’d rather
    check. For example, you can verify whether the response specifies which natural
    language its body is written in, via *r*.headers.get(''content-language''), to
    offer different presentation choices, such as the option to use some kind of language
    translation service to make the response more usable for the user.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可能想要检查响应的HTTP头：为此，请使用*r*.headers，一个字典（具有特殊功能，其大小写不敏感的字符串键指示头名称，例如在[Wikipedia](https://oreil.ly/_nJRX)中列出的HTTP规范）。大多数头部可以安全地忽略，但有时你可能更愿意检查。例如，你可以通过*r*.headers.get('content-language')验证响应是否指定了其主体所写的自然语言，以提供不同的呈现选择，例如使用某种语言翻译服务使响应对用户更有用。
- en: 'You don’t usually need to make specific status or header checks for redirects:
    by default, requests automatically follows redirects for all methods except HEAD
    (you can explicitly pass the allow_redirection named parameter in the request
    to alter that behavior). If you allow redirects, you may want to check *r*.history,
    a list of all Response instances accumulated along the way, oldest to newest,
    up to but excluding *r* itself (*r*.history is empty if there have been no redirects).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你不需要对重定向进行特定的状态或头检查：默认情况下，requests会自动对除HEAD以外的所有方法进行重定向（你可以在请求中显式传递allow_redirection命名参数来更改该行为）。如果允许重定向，你可能需要检查*r*.history，一个沿途累积的Response实例列表，从最旧到最新，但不包括*r*本身（如果没有重定向，*r*.history为空）。
- en: Most often, maybe after checking status and headers, you want to use the response’s
    body. In simple cases, just access the response’s body as a bytestring, *r*.content,
    or decode it as JSON (once you’ve checked that’s how it’s encoded, e.g., via *r*.headers.get('content-type'))
    by calling *r*.json.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，可能在检查状态和头之后，你想使用响应的主体。在简单情况下，只需将响应的主体作为字节字符串访问，*r*.content，或者通过调用*r*.json将其解码为JSON（一旦你检查到它是如何编码的，例如通过*r*.headers.get('content-type')）。
- en: Often, you’d rather access the response’s body as (Unicode) text, with the property
    *r*.text. The latter gets decoded (from the octets that actually make up the response’s
    body) with the codec requests thinks is best, based on the Content-Type header
    and a cursory examination of the body itself. You can check what codec has been
    used (or is about to be used) via the attribute *r*.encoding; its value will be
    the name of a codec registered with the codecs module, covered in [“The codecs
    Module”](ch09.xhtml#the_codecs_module). You can even *override* the choice of
    codec to use by *assigning* to *r*.encoding the name of the codec you choose.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你更倾向于将响应的主体作为（Unicode）文本访问，使用属性*r*.text。后者使用编解码器解码（从实际构成响应主体的八位字节），编解码器由请求根据Content-Type头和对主体本身的粗略检查认为最佳来确定。你可以通过属性*r*.encoding检查使用的（或即将使用的）编解码器；其值将是与codecs模块注册的编解码器名称，详见[“codecs模块”](ch09.xhtml#the_codecs_module)。你甚至可以通过将*r*.encoding分配为你选择的编解码器的名称来*覆盖*编解码器的选择。
- en: We do not cover other advanced issues, such as streaming, in this book; see
    the requests package’s [online docs](https://oreil.ly/4St1s) for further information.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不在本书中涵盖其他高级问题，例如流式传输；请参阅requests包的[在线文档](https://oreil.ly/4St1s)获取更多信息。
- en: Other Network Protocols
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他网络协议
- en: Many, *many* other network protocols are in use—a few are best supported by
    Python’s standard library, but for most of them you’ll find better and more recent
    third-party modules on [PyPI](https://oreil.ly/PGIim).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 许多，*许多* 其他网络协议在使用中—一些最好由 Python 标准库支持，但大多数你会在 [PyPI](https://oreil.ly/PGIim)
    上找到更好和更新的第三方模块。
- en: To connect as if you were logging in to another machine (or a separate login
    session on your own node), you can use the [Secure Shell (SSH)](https://oreil.ly/HazNC)
    protocol, supported by the third-party module [paramiko](http://www.paramiko.org)
    or the higher abstraction layer wrapper around it, the third-party module [spur](https://oreil.ly/vdmrN).
    (You can also, with some likely security risks, still use classic [Telnet](https://oreil.ly/5fw-y),
    supported by the standard library module [telnetlib](https://oreil.ly/GYdGi).)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要像登录到另一台机器（或自己节点上的单独登录会话）一样连接，可以使用 [Secure Shell (SSH)](https://oreil.ly/HazNC)
    协议，由第三方模块 [paramiko](http://www.paramiko.org) 或围绕它的更高抽象层包装器，第三方模块 [spur](https://oreil.ly/vdmrN)
    支持。（你也可以，虽然可能存在某些安全风险，仍然使用经典的 [Telnet](https://oreil.ly/5fw-y)，由标准库模块 [telnetlib](https://oreil.ly/GYdGi)
    支持。）
- en: 'Other network protocols include, among many others:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 其他网络协议包括，但不限于：
- en: '[NNTP](https://oreil.ly/zCBov), to access Usenet News servers, supported by
    the standard library module nntplib'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NNTP](https://oreil.ly/zCBov)，用于访问 Usenet 新闻服务器，由标准库模块 nntplib 支持。'
- en: '[XML-RPC](https://oreil.ly/7vRm0), for a rudimentary remote procedure call
    functionality, supported by [xmlrpc.client](https://oreil.ly/K3oDj)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[XML-RPC](https://oreil.ly/7vRm0)，用于基本的远程过程调用功能，由 [xmlrpc.client](https://oreil.ly/K3oDj)
    支持。'
- en: '[gRPC](http://www.grpc.io), for a more modern remote procedure functionality,
    supported by third-party module [grpcio](https://oreil.ly/KHQHs)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[gRPC](http://www.grpc.io)，用于更现代的远程过程功能，由第三方模块 [grpcio](https://oreil.ly/KHQHs)
    支持。'
- en: '[NTP](http://www.ntp.org), to get precise time off the network, supported by
    third-party module [ntplib](https://oreil.ly/R5SDp)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NTP](http://www.ntp.org)，用于通过网络获取精确时间，由第三方模块 [ntplib](https://oreil.ly/R5SDp)
    支持。'
- en: '[SNMP](https://oreil.ly/nlhqH), for network management, supported by third-party
    module [pysnmp](https://oreil.ly/syh0_)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SNMP](https://oreil.ly/nlhqH)，用于网络管理，由第三方模块 [pysnmp](https://oreil.ly/syh0_)
    支持。'
- en: 'No single book (not even this one!) could possibly cover all these protocols
    and their supporting modules. Rather, our best suggestion in the matter is a strategic
    one: whenever you decide that your application needs to interact with some other
    system via a certain networking protocol, don’t rush to implement your own modules
    to support that protocol. Instead, search and ask around, and you’re likely to
    find excellent existing Python modules (third-party or standard-library ones)
    supporting that protocol.^([6](ch19.xhtml#ch01fn150))'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 没有单一的书籍（甚至包括本书！）能够涵盖所有这些协议及其支持模块。相反，我们在这个问题上的最佳建议是战略性的：每当你决定通过某种网络协议使你的应用程序与其他系统交互时，不要急于实现自己的模块来支持该协议。而是搜索并询问，你很可能会找到优秀的现有
    Python 模块（第三方或标准库），支持该协议。^([6](ch19.xhtml#ch01fn150))
- en: 'Should you find some bug or missing feature in such modules, open a bug or
    feature request (and, ideally, supply a patch or pull request that would fix the
    problem and satisfy your application’s needs). In other words, become an active
    member of the open source community, rather than just a passive user: you will
    be welcome there, scratch your own itch, and help many others in the process.
    “Give forward,” since you cannot “give back” to all the awesome people who contributed
    to give you most of the tools you’re using!'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现这些模块中存在错误或缺失功能，请提交错误或功能请求（并且最好提供一个修复问题并满足你应用程序需求的补丁或拉取请求）。换句话说，成为开源社区的积极成员，而不仅仅是被动用户：你将会受到欢迎，解决你自己的问题，并在此过程中帮助许多其他人。“给予回馈”，因为你无法“回馈”给所有为你提供大部分工具的了不起的人们！
- en: ^([1](ch19.xhtml#ch01fn140-marker)) IMAP4, per [RFC 1730](https://oreil.ly/fn5aH);
    or IMAP4rev1, per [RFC 2060](https://oreil.ly/C5N0w).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch19.xhtml#ch01fn140-marker)) IMAP4，参见 [RFC 1730](https://oreil.ly/fn5aH)；或
    IMAP4rev1，参见 [RFC 2060](https://oreil.ly/C5N0w)。
- en: ^([2](ch19.xhtml#ch01fn141-marker)) The specification of the POP protocol can
    be found in [RFC 1939](https://oreil.ly/NLl6b).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch19.xhtml#ch01fn141-marker)) POP 协议的规范可在 [RFC 1939](https://oreil.ly/NLl6b)
    中找到。
- en: ^([3](ch19.xhtml#ch01fn144-marker)) The specification of the SMTP protocol can
    be found in [RFC 2821](https://oreil.ly/J9aCH).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch19.xhtml#ch01fn144-marker)) SMTP 协议的规范可在 [RFC 2821](https://oreil.ly/J9aCH)
    中找到。
- en: ^([4](ch19.xhtml#ch01fn148-marker)) According to [RFC 2388](https://oreil.ly/7xsOe).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch19.xhtml#ch01fn148-marker)) 根据 [RFC 2388](https://oreil.ly/7xsOe)。
- en: ^([5](ch19.xhtml#ch01fn149-marker)) As it gives you complete, explicit control
    of exactly what octets are uploaded.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch19.xhtml#ch01fn149-marker)) 它能让你完全、明确地控制上传的八位字节。
- en: '^([6](ch19.xhtml#ch01fn150-marker)) Even more importantly, if you think you
    need to invent a brand-new protocol and implement it on top of sockets, think
    again, and search carefully: it’s far more likely that one or more of the huge
    number of existing internet protocols meets your needs just fine!'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch19.xhtml#ch01fn150-marker)) 更重要的是，如果你认为需要发明一个全新的协议并在套接字之上实现它，再三考虑，并仔细搜索：很可能已经有大量现有的互联网协议完全符合你的需求！
