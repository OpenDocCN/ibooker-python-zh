- en: 'Chapter 11\. Container Technologies: Docker and Docker Compose'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 容器技术：Docker和Docker Compose
- en: Virtualization technologies have been around since the days of the IBM mainframes.
    Most people have not had a chance to work on a mainframe, but we are sure some
    readers of this book remember the days when they had to set up or use a bare-metal
    server from a manufacturer such as HP or Dell. These manufacturers are still around
    today, and you can still use bare-metal servers hosted in a colocation facility,
    like in the good old days of the dot-com era.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化技术自IBM大型机时代就已存在。大多数人没有机会使用过大型机，但我们相信本书的一些读者还记得他们曾经在惠普或戴尔等制造商那里设置或使用裸金属服务器的日子。这些制造商今天仍然存在，你仍然可以在像互联网泡沫时代那样的机房中使用裸金属服务器。
- en: When most people think of virtualization, however, they do not automatically
    have a mainframe in mind. Instead, they most likely imagine a virtual machine
    (VM) running a guest operating system (OS) such as Fedora or Ubuntu on top of
    a hypervisor such as VMware ESX or Citrix/Xen. The big advantage of VMs over regular
    bare-metal servers is that by using VMs, you can optimize the server’s resources
    (CPU, memory, disk) by splitting them across several virtual machines. You can
    also run several operating systems, each in its own VM, on top of one shared bare-metal
    server, instead of buying a dedicated server per targeted OS. Cloud computing
    services such as Amazon EC2 would not have been possible without hypervisors and
    virtual machines. This type of virtualization can be called kernel-level because
    each virtual machine runs its own OS kernel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当大多数人想到虚拟化时，他们不会自动想到大型机。相反，他们很可能想象的是在虚拟化管理程序（如VMware ESX或Citrix/Xen）上运行的虚拟机（VM），并且运行了Fedora或Ubuntu等客户操作系统（OS）。虚拟机相对于普通裸金属服务器的一大优势是，通过使用虚拟机，你可以通过在几个虚拟机之间分割它们来优化服务器的资源（CPU、内存、磁盘）。你还可以在一个共享的裸金属服务器上运行几个操作系统，每个操作系统在自己的虚拟机中运行，而不是为每个目标操作系统购买专用服务器。像亚马逊EC2这样的云计算服务如果没有虚拟化管理程序和虚拟机是不可能的。这种类型的虚拟化可以称为内核级，因为每个虚拟机运行其自己的操作系统内核。
- en: In the never-ending quest for more bang for their buck, people realized that
    virtual machines were still wasteful in terms of resources. The next logical step
    was to isolate an individual application into its own virtual environment. This
    was achieved by running containers within the same OS kernel. In this case, they
    were isolated at the file-system level. Linux containers (LXC) and Sun Solaris
    zones were early examples of such technologies. Their disadvantage was that they
    were hard to use and were tightly coupled to the OS they were running on. The
    big breakthrough in container usage came when Docker started to offer an easy
    way to manage and run filesystem-level containers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在对资源追求更大回报的不懈努力中，人们意识到虚拟机在资源利用上仍然是浪费的。下一个逻辑步骤是将单个应用程序隔离到自己的虚拟环境中。通过在同一个操作系统内核中运行容器来实现这一目标。在这种情况下，它们在文件系统级别被隔离。Linux容器（LXC）和Sun
    Solaris zones是这种技术的早期示例。它们的缺点是使用起来很困难，并且与它们运行的操作系统紧密耦合。在容器使用方面的重大突破是当Docker开始提供一种简便的方法来管理和运行文件系统级容器。
- en: What Is a Docker Container?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Docker容器？
- en: A Docker container encapsulates an application together with other software
    packages and libraries it requires to run. People sometimes use the terms Docker
    container and Docker image interchangeably, but there is a difference. The filesystem-level
    object that encapsulates the application is called a Docker image. When you run
    the image, it becomes a Docker container.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Docker容器封装了一个应用程序以及它运行所需的其他软件包和库。人们有时会将Docker容器和Docker镜像的术语互换使用，但它们之间是有区别的。封装应用程序的文件系统级对象称为Docker镜像。当你运行该镜像时，它就成为了一个Docker容器。
- en: You can run many Docker containers, all using the same OS kernel. The only requirement
    is that you must install a server-side component called the Docker engine or the
    Docker daemon on the host where you want to run the containers. In this way, the
    host resources can be split and utilized in a more granular way across the containers,
    giving you more bang for your buck.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行许多Docker容器，它们都使用相同的操作系统内核。唯一的要求是你必须在要运行容器的主机上安装一个称为Docker引擎或Docker守护程序的服务器端组件。通过这种方式，主机资源可以在容器之间以更精细的方式分割和利用，让你的投资得到更大的回报。
- en: Docker containers provide more isolation and resource control than regular Linux
    processes, but provide less than full-fledged virtual machines would. To achieve
    these properties of isolation and resource control, the Docker engine makes use
    of Linux kernel features such as namespaces, control groups (or cgroups), and
    Union File Systems (UnionFS).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器提供了比常规 Linux 进程更多的隔离和资源控制，但提供的功能不及完整的虚拟机。为了实现这些隔离和资源控制的特性，Docker 引擎利用了
    Linux 内核功能，如命名空间、控制组（或 cgroups）和联合文件系统（UnionFS）。
- en: 'The main advantage of Docker containers is portability. Once you create a Docker
    image, you can run it as a Docker container on any host OS where the Docker server-side
    daemon is available. These days, all the major operating systems run the Docker
    daemon: Linux, Windows, and macOS.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器的主要优势是可移植性。一旦创建了 Docker 镜像，您可以在任何安装有 Docker 服务器端守护程序的主机操作系统上作为 Docker
    容器运行它。如今，所有主要操作系统都运行 Docker 守护程序：Linux、Windows 和 macOS。
- en: All this can sound too theoretical, so it is time for some concrete examples.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些可能听起来太理论化，所以现在是一些具体示例的时候了。
- en: Creating, Building, Running, and Removing Docker Images and Containers
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、构建、运行和删除 Docker 镜像和容器
- en: Since this is a book on Python and DevOps, we will take the canonical Flask
    “Hello World” as the first example of an application that runs in a Docker container.
    The examples shown in this section use the Docker for Mac package. Subsequent
    sections will show how to install Docker on Linux.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本关于 Python 和 DevOps 的书籍，我们将以经典的 Flask “Hello World” 作为在 Docker 容器中运行的应用程序的第一个示例。本节中显示的示例使用
    Docker for Mac 包。后续章节将展示如何在 Linux 上安装 Docker。
- en: 'Here is the main file of the Flask application:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Flask 应用程序的主文件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We also need a requirements file that specifies the version of the Flask package
    to be installed with `pip`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个需求文件，其中指定了要与 `pip` 安装的 Flask 包的版本：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Trying to run the *app.py* file directly with Python on a macOS laptop without
    first installing the requirements results in an error:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 笔记本电脑上直接使用 Python 运行 *app.py* 文件，而不先安装要求，会导致错误：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One obvious way to get past this issue is to install the requirements with `pip`
    on your local machine. This would make everything specific to the operating system
    you are running locally. What if the application needs to be deployed on a server
    running a different OS? The well-known issue of “works on my machine” could arise,
    where everything works beautifully on a macOS laptop, but for some mysterious
    reason, usually related to OS-specific versions of Python libraries, everything
    breaks on the staging or production servers running other operating systems, such
    as Ubuntu or Red Hat Linux.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题的一个明显方法是在本地机器上使用 `pip` 安装需求。这将使一切都与您本地运行的操作系统具体相关。如果应用程序需要部署到运行不同操作系统的服务器上，该怎么办？众所周知的“在我的机器上能运行”的问题可能会出现，即在
    macOS 笔记本电脑上一切运行良好，但由于操作系统特定版本的 Python 库，一切在运行其他操作系统（如 Ubuntu 或 Red Hat Linux）的暂存或生产服务器上却突然崩溃。
- en: Docker offers an elegant solution to this conundrum. We can still do our development
    locally, using our beloved editors and toolchains, but we package our application’s
    dependencies inside a portable Docker container.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 为这个难题提供了一个优雅的解决方案。我们仍然可以在本地进行开发，使用我们喜爱的编辑器和工具链，但是我们将应用程序的依赖项打包到一个可移植的
    Docker 容器中。
- en: 'Here is the Dockerfile describing the Docker image that is going to be built:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是描述将要构建的 Docker 镜像的 Dockerfile：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A few notes about this Dockerfile:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个 Dockerfile 的一些说明：
- en: Use a prebuilt Docker image for Python 3.7.3 based on the Alpine distribution
    that produces slimmer Docker images; this Docker image already contains executables
    such as `python` and `pip`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于 Alpine 发行版的 Python 3.7.3 预构建 Docker 镜像，这样可以生成更轻量的 Docker 镜像；这个 Docker 镜像已经包含了诸如
    `python` 和 `pip` 等可执行文件。
- en: Install the required packages with `pip`.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pip` 安装所需的包。
- en: Specify an ENTRYPOINT and a CMD. The difference between the two is that when
    the Docker container runs the image built from this Dockerfile, the program it
    runs is the ENTRYPOINT, followed by any arguments specified in CMD; in this case,
    it will run `python app.py`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定一个 ENTRYPOINT 和一个 CMD。两者的区别在于，当 Docker 容器运行从这个 Dockerfile 构建的镜像时，它运行的程序是 ENTRYPOINT，后面跟着在
    CMD 中指定的任何参数；在本例中，它将运行 `python app.py`。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you do not specify an ENTRYPOINT in your Dockerfile, the following default
    will be used: `/bin/sh -c`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有在您的 Dockerfile 中指定 ENTRYPOINT，则将使用以下默认值：`/bin/sh -c`。
- en: 'To create the Docker image for this application, run `docker build`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要为这个应用程序创建 Docker 镜像，运行 `docker build`：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To verify that the Docker image was saved locally, run `docker images` followed
    by the name of the image:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证 Docker 镜像是否已保存在本地，请运行`docker images`，然后输入镜像名称：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To run the Docker image as a Docker container, use the `docker run` command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Docker 镜像作为 Docker 容器运行，请使用`docker run`命令：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A few notes about the `docker run` command arguments:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`docker run`命令参数的几点说明：
- en: The `--rm` argument tells the Docker server to remove this container once it
    stops running. This is useful to prevent old containers from clogging the local
    filesystem.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--rm`参数告诉 Docker 服务器在停止运行后删除此容器。这对于防止旧容器堵塞本地文件系统非常有用。'
- en: The `-d` argument tells the Docker server to run this container in the background.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`参数告诉 Docker 服务器在后台运行此容器。'
- en: The `-v` argument specifies that the current directory (*pwd*) is mapped to
    the */app* directory inside the Docker container. This is essential for the local
    development workflow we want to achieve because it enables us to edit the application
    files locally and have them be auto-reloaded by the Flask development server running
    inside the container.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`参数指定当前目录（*pwd*）映射到 Docker 容器内的*/app*目录。这对于我们想要实现的本地开发工作流至关重要，因为它使我们能够在本地编辑应用程序文件，并通过运行在容器内部的
    Flask 开发服务器进行自动重新加载。'
- en: The `-p 5000:5000` argument maps the first port (5000) locally to the second
    port (5000) inside the container.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p 5000:5000`参数将本地的第一个端口（5000）映射到容器内部的第二个端口（5000）。'
- en: 'To list running containers, run `docker ps` and note the container ID because
    it will be used in other `docker` commands:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出运行中的容器，请运行`docker ps`并注意容器 ID，因为它将在其他`docker`命令中使用：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To inspect the logs for a given container, run `docker logs` and specify the
    container name or ID:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查特定容器的日志，请运行`docker logs`并指定容器名称或 ID：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Hit the endpoint URL with `curl` to verify that the application works. Because
    port 5000 of the application running inside the Docker container was mapped to
    port 5000 on the local machine with the `-p` command-line flag, you can use the
    local IP address 127.0.0.1 with port 5000 as the endpoint for the application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`curl`命中端点 URL 以验证应用程序是否正常工作。由于使用`-p`命令行标志将运行在 Docker 容器内部的应用程序的端口 5000 映射到本地机器的端口
    5000，因此可以使用本地 IP 地址 127.0.0.1 作为应用程序的端点地址。
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now modify the code in *app.py* with your favorite editor. Change the greeting
    text to *Hello, World! (from a Docker container with modified code)*. Save *app.py*
    and notice lines similar to these in the Docker container logs:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用你喜欢的编辑器修改*app.py*中的代码。将问候文本更改为*Hello, World! (from a Docker container with
    modified code)*。保存*app.py*并注意 Docker 容器日志中类似以下行：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This shows that the Flask development server running inside the container has
    detected the change in *app.py* and has reloaded the application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明运行在容器内部的 Flask 开发服务器已检测到*app.py*中的更改，并重新加载了应用程序。
- en: 'Hitting the application endpoint with `curl` will show the modified greeting:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`curl`命中应用程序端点将显示修改后的问候语：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To stop a running container, run `docker stop` or `docker kill` and specify
    the container ID as the argument:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止运行中的容器，请运行`docker stop`或`docker kill`，并指定容器 ID 作为参数：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To delete a Docker image from local disk, run `docker rmi`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要从本地磁盘中删除 Docker 镜像，请运行`docker rmi`：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This output shows the different filesystem layers comprising a Docker image.
    When the image is removed, the layers are deleted as well. Consult the [Docker
    storage drivers](https://oreil.ly/wqNve) documentation for more details on how
    Docker uses filesystem layers to build its images.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示组成 Docker 镜像的不同文件系统层。当删除镜像时，这些层也将被删除。有关 Docker 如何使用文件系统层构建其镜像的详细信息，请参阅[Docker
    存储驱动程序](https://oreil.ly/wqNve)文档。
- en: Publishing Docker Images to a Docker Registry
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布 Docker 镜像到 Docker 注册表
- en: Once you have a Docker image built locally, you can publish it to what is called
    a Docker registry. There are several public registries to choose from, and for
    this example we will use Docker Hub. The purpose of these registries is to allow
    people and organizations to share pre-built Docker images that can be reused across
    different machines and operating systems.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在本地构建了 Docker 镜像，就可以将其发布到所谓的 Docker 注册表中。有几个公共注册表可供选择，本示例将使用 Docker Hub。这些注册表的目的是允许个人和组织共享可在不同机器和操作系统上重复使用的预构建
    Docker 镜像。
- en: First, create a free account on [Docker Hub](https://hub.docker.com) and then
    create a repository, either public or private. We created a private repository
    called `flask-hello-world` under our `griggheo` Docker Hub account.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在[Docker Hub](https://hub.docker.com)上创建一个免费帐户，然后创建一个仓库，可以是公共的或私有的。我们在`griggheo`的
    Docker Hub 帐户下创建了一个名为`flask-hello-world`的私有仓库。
- en: Then, at the command line, run `docker login` and specify the email and password
    for your account. At this point, you can interact with Docker Hub via the `docker`
    client.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在命令行上运行`docker login`并指定您帐户的电子邮件和密码。此时，您可以通过`docker`客户端与 Docker Hub 进行交互。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before showing you how to publish your locally built Docker image to Docker
    Hub, we want to point out that best practice is to tag your image with a unique
    tag. If you don’t tag it specifically, the image will be tagged as `latest` by
    default. Pushing a new image version with no tag will move the `latest` tag to
    the newest image version. When using a Docker image, if you do not specify the
    exact tag you need, you will get the `latest` version of the image, which might
    contain modifications and updates that might break your dependencies. As always,
    the principle of least surprise should apply: you should use tags both when pushing
    images to a registry, and when referring to images in a Dockerfile. That being
    said, you can also tag your desired version of the image as `latest` so that people
    who are interested in the latest and greatest can use it without specifying a
    tag.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在向 Docker Hub 发布您本地构建的 Docker 镜像之前，我们要指出的最佳实践是使用唯一标签对镜像进行标记。如果不明确打标签，默认情况下镜像将标记为`latest`。发布不带标签的新镜像版本将把`latest`标签移至最新镜像版本。在使用
    Docker 镜像时，如果不指定所需的确切标签，将获取`latest`版本的镜像，其中可能包含可能破坏依赖关系的修改和更新。始终应用最小惊讶原则：在推送镜像到注册表时和在
    Dockerfile 中引用镜像时都应使用标签。话虽如此，您也可以将所需版本的镜像标记为`latest`，以便对最新和最伟大的人感兴趣的人使用而不需要指定标签。
- en: 'When building the Docker image in the previous section, it was automatically
    tagged as `latest`, and the repository was set to the name of the image, signifying
    that the image is local:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中构建 Docker 镜像时，它会自动标记为`latest`，并且仓库被设置为镜像的名称，表示该镜像是本地的：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To tag a Docker image, run `docker tag`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 Docker 镜像打标签，请运行`docker tag`：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now you can see both tags for the `hello-world-docker` image:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到`hello-world-docker`镜像的两个标签：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Before you can publish the `hello-world-docker` image to Docker Hub, you also
    need to tag it with the Docker Hub repository name, which contains your username
    or your organization name. In our case, this repository is `griggheo/hello-world-docker`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`hello-world-docker`镜像发布到 Docker Hub 之前，您还需要使用包含您的用户名或组织名称的 Docker Hub 仓库名称对其进行标记。在我们的情况下，这个仓库是`griggheo/hello-world-docker`：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Publish both image tags to Docker Hub with `docker push`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker push`将两个镜像标签发布到 Docker Hub：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you followed along, you should now be able to see your Docker image published
    with both tags to the Docker Hub repository you created under your account.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您跟随进行，现在应该能够看到您的 Docker 镜像已发布到您在帐户下创建的 Docker Hub 仓库，并带有两个标签。
- en: Running a Docker Container with the Same Image on a Different Host
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同主机上使用相同镜像运行 Docker 容器
- en: Now that the Docker image is published to Docker Hub, we are ready to show off
    the portability of Docker by running a container based on the published image
    on a different host. The scenario considered here is that of collaborating with
    a colleague who doesn’t have macOS but likes to develop on a laptop running Fedora.
    The scenario includes checking out the application code and modifying it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Docker 镜像已发布到 Docker Hub，我们可以展示 Docker 的可移植性，通过在不同主机上基于已发布镜像运行容器来展示。这里考虑的场景是与一位没有
    macOS 但喜欢在运行 Fedora 的笔记本上开发的同事合作。该场景包括检出应用程序代码并进行修改。
- en: 'Launch an EC2 instance in AWS based on the Linux 2 AMI, which is based on RedHat/CentOS/Fedora,
    and then install the Docker engine. Add the default user on the EC2 Linux AMI,
    called `ec2-user`, to the `docker` group so it can run `docker` client commands:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 上启动基于 Linux 2 AMI 的 EC2 实例，该 AMI 基于 RedHat/CentOS/Fedora，并安装 Docker 引擎。将
    EC2 Linux AMI 上的默认用户`ec2-user`添加到`docker`组，以便可以运行`docker`客户端命令。
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Make sure to check out the application code on the remote EC2 instance. In this
    case, the code consists only of *app.py* file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在远程 EC2 实例上检出应用程序代码。在这种情况下，代码仅包括*app.py*文件。
- en: Next, run the Docker container based on the image published to Docker Hub. The
    only difference is that the image used as an argument to the `docker run` command
    was `griggheo/hello-world-docker:v1` instead of simply `hello-world-docker`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行基于发布到Docker Hub的镜像的Docker容器。唯一的区别是，作为`docker run`命令参数使用的镜像是`griggheo/hello-world-docker:v1`，而不仅仅是`hello-world-docker`。
- en: 'Run `docker login`, then:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker login`，然后：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the Docker engine on the EC2 instance recognizes that it does not
    have the Docker image locally, so it downloads it from Docker Hub, then runs a
    container based on the newly downloaded image.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，EC2实例上的Docker引擎会意识到本地没有Docker镜像，因此会从Docker Hub下载镜像，然后基于新下载的镜像运行容器。
- en: At this point, access to port 5000 was granted by adding a rule to the security
    group associated with the EC2 instance. Visit http://54.187.189.51:5000^([1](ch11.html#idm46691322287592))
    (with 54.187.189.51 being the external IP of the EC2 instance) and see the greeting
    *Hello, World! (from a Docker container with modified code)*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，通过向与EC2实例关联的安全组添加规则来授予对端口5000的访问权限。访问http://54.187.189.51:5000^([1](ch11.html#idm46691322287592))（其中54.187.189.51是EC2实例的外部IP）并查看问候语*Hello,
    World! (from a Docker container with modified code)*。
- en: 'When modifying the application code on the remote EC2 instance, the Flask server
    running inside the Docker container will auto-reload the modified code. Change
    the greeting to *Hello, World! (from a Docker container on an EC2 Linux 2 AMI
    instance)* and notice that the Flask server reloaded the application by inspecting
    the logs of the Docker container:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程EC2实例上修改应用程序代码时，运行在Docker容器内部的Flask服务器将自动重新加载修改后的代码。将问候语更改为*Hello, World!
    (from a Docker container on an EC2 Linux 2 AMI instance)*，并注意Flask服务器通过检查Docker容器的日志重新加载了应用程序：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Hitting http://54.187.189.51:5000^([2](ch11.html#idm46691322283160)) now shows
    the new greeting *Hello, World! (from a Docker container on an EC2 Linux 2 AMI
    instance)*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 点击http://54.187.189.51:5000^([2](ch11.html#idm46691322283160))现在显示新的问候语*Hello,
    World! (from a Docker container on an EC2 Linux 2 AMI instance)*。
- en: It is worth noting that we did not have to install anything related to Python
    or Flask to get our application to run. By simply running our application inside
    a container, we were able to take advantage of the portability of Docker. It is
    not for nothing that Docker chose the name “container” to popularize its technology—one
    inspiration was how the shipping container revolutionized the global transportation
    industry.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，为了使我们的应用程序运行，我们没有必要安装任何与Python或Flask相关的东西。通过简单地在容器内运行我们的应用程序，我们能够利用Docker的可移植性。Docker选择“容器”作为技术的名字并不是没有原因的，其中一个灵感来源于运输容器如何革命了全球运输行业。
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Read [“Production-ready Docker images”](https://pythonspeed.com/docker) by Itamar
    Turner-Trauring for an extensive collection of articles on Docker container packaging
    for Python applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读[“Production-ready Docker images”](https://pythonspeed.com/docker)一书，由Itamar
    Turner-Trauring编写，涵盖了关于Python应用程序Docker容器打包的大量文章。
- en: Running Multiple Docker Containers with Docker Compose
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose运行多个Docker容器
- en: In this section we will use the [“Flask By Example”](https://oreil.ly/prNg7)
    tutorial that describes how to build a Flask application that calculates word-frequency
    pairs based on the text from a given URL.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用[“Flask By Example”](https://oreil.ly/prNg7)教程，该教程描述了如何构建一个Flask应用程序，根据给定URL的文本计算单词频率对。
- en: 'Start by cloning the [Flask By Example GitHub repository](https://oreil.ly/M-pvc):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先克隆[Flask By Example GitHub存储库](https://oreil.ly/M-pvc)：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We will use `compose` to run multiple Docker containers representing the different
    parts of the example application. With Compose, you use a YAML file to define
    and configure the services comprising an application, then you use the `docker-compose`
    command-line utility to create, start, and stop these services that will run as
    Docker containers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`compose`来运行代表示例应用程序不同部分的多个Docker容器。使用Compose，您可以使用YAML文件定义和配置组成应用程序的服务，然后使用`docker-compose`命令行实用程序来创建、启动和停止这些将作为Docker容器运行的服务。
- en: The first dependency to consider for the example application is PostgreSQL,
    as described in [Part 2 of the tutorial](https://oreil.ly/iobKp).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序的第一个依赖项是PostgreSQL，在[教程第2部分](https://oreil.ly/iobKp)中有描述。
- en: 'Here is how to run PostgreSQL in a Docker container inside a *docker-compose.yaml*
    file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何在*docker-compose.yaml*文件中运行PostgreSQL Docker容器的方法：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A few things to note about this file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个文件的几个注意事项：
- en: Define a service called `db` based on the `postgres:11` image published on Docker
    Hub.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个名为`db`的服务，基于在Docker Hub上发布的`postgres:11`镜像。
- en: Specify a port mapping from local port 5432 to the container port 5432.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将本地端口5432映射到容器端口5432。
- en: Specify a Docker volume for the directory where PostgreSQL stores its data,
    which is */var/lib/postgresql/data*. This is so that the data stored in PostgreSQL
    will persist across restarts of the container.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为PostgreSQL存储其数据的目录（*/var/lib/postgresql/data*）指定一个Docker卷。这样做是为了确保PostgreSQL中存储的数据在容器重新启动后仍然存在。
- en: The `docker-compose` utility is not part of the Docker engine, so it needs to
    be installed separately. See the [official documentation](https://docs.docker.com/compose/install)
    for instructions on installing it on various operating systems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`工具不是Docker引擎的一部分，因此需要单独安装。请参阅[官方文档](https://docs.docker.com/compose/install)以获取在各种操作系统上安装的说明。'
- en: 'To bring up the `db` service defined in *docker-compose.yaml*, run the `docker-compose
    up -d db` command, which will launch the Docker container for the `db` service
    in the background (the `-d` flag):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动*docker-compose.yaml*中定义的`db`服务，请运行`docker-compose up -d db`命令，该命令将在后台启动`db`服务的Docker容器（使用了`-d`标志）。
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inspect the logs for the `db` service with the `docker-compose logs db` command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker-compose logs db`命令检查`db`服务的日志：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running `docker ps` shows the container running the PostgreSQL database:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker ps`命令可以显示运行PostgreSQL数据库的容器：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Running `docker volume ls` shows the `dbdata` Docker volume mounted for the
    PostgreSQL */var/lib/postgresql/data* directory:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker volume ls`命令显示已为PostgreSQL */var/lib/postgresql/data*目录挂载的`dbdata`
    Docker卷：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To connect to the PostgreSQL database running in the Docker container associated
    with the `db` service, run the command `docker-compose exec db` and pass it the
    command line `psql -U postgres`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到运行在与`db`服务相关联的Docker容器中的PostgreSQL数据库，运行命令`docker-compose exec db`并传递`psql
    -U postgres`命令行：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Following [“Flask by Example, Part 2”](https://oreil.ly/iobKp), create a database
    called `wordcount`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 参照[“Flask by Example, Part 2”](https://oreil.ly/iobKp)，创建一个名为`wordcount`的数据库：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Connect to the `wordcount` database and create a role called `wordcount_dbadmin`
    that will be used by the Flask application:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到`wordcount`数据库并创建一个名为`wordcount_dbadmin`的角色，该角色将被Flask应用程序使用：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The next step is to create a Dockerfile for installing all the prerequisites
    for the Flask application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为Flask应用程序创建一个Dockerfile，安装所有的先决条件。
- en: 'Make the following modifications to the *requirements.txt* file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对*requirements.txt*文件进行以下修改：
- en: Modify the version of the `psycopg2` package from `2.6.1` to `2.7` so that it
    supports PostgreSQL 11
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`psycopg2`包的版本从`2.6.1`修改为`2.7`以支持PostgreSQL 11。
- en: Modify the version of the `redis` package from `2.10.5` to `3.2.1` for better
    Python 3.7 support
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`redis`包的版本从`2.10.5`修改为`3.2.1`以提供更好的Python 3.7支持。
- en: Modify the version of the `rq` package from `0.5.6` to `1.0` for better Python
    3.7 support
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`rq`包的版本从`0.5.6`修改为`1.0`以提供更好的Python 3.7支持。
- en: 'Here is the Dockerfile:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Dockerfile的内容：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There is an important difference between this Dockerfile and the version used
    in the first *hello-world-docker* example. Here the contents of the current directory,
    which includes the application files, are copied into the Docker image. This is
    done to illustrate a scenario different from the development workflow shown earlier.
    In this case, we are more interested in running the application in the most portable
    way, for example, in a staging or production environment, where we do not want
    to modify application files via mounted volumes as was done in the development
    scenario. It is possible and even common to use `docker-compose` with locally
    mounted volumes for development purposes, but the focus in this section is on
    the portability of Docker containers across environments, such as development,
    staging, and production.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Dockerfile与第一个*hello-world-docker*示例中使用的版本有一个重要的区别。这里将当前目录的内容（包括应用程序文件）复制到Docker镜像中。这样做是为了展示与之前开发工作流不同的场景。在这种情况下，我们更关注以最便携的方式运行应用程序，例如在暂存或生产环境中，我们不希望像在开发场景中通过挂载卷来修改应用程序文件。在开发目的上通常可以使用`docker-compose`与本地挂载卷，但本节重点是讨论Docker容器在不同环境（如开发、暂存和生产）中的可移植性。
- en: Run `docker build -t flask-by-example:v1 .` to build a local Docker image. The
    output of this command is not shown because it is quite lengthy.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker build -t flask-by-example:v1 .`来构建一个本地Docker镜像。由于该命令的输出内容相当长，因此这里不显示。
- en: The next step in the “Flask By Example” tutorial is to run the Flask migrations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: “Flask By Example”教程的下一步是运行Flask迁移。
- en: 'In the *docker-compose.yaml* file, define a new service called `migrations`
    and specify its `image`, its `command`, its `environment` variables, and the fact
    that it depends on the `db` service being up and running:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在*docker-compose.yaml*文件中，定义一个名为`migrations`的新服务，并指定其`image`、`command`、`environment`变量以及它依赖于`db`服务正在运行的事实：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `DATABASE_URL` variable uses the name `db` for the PostgreSQL database host.
    This is because the name `db` is defined as a service name in the *docker-compose.yaml*
    file, and `docker-compose` knows how to link one service to another by creating
    an overlay network where all services defined in the *docker-compose.yaml* file
    can interact with each other by their names. See the [docker-compose networking
    reference](https://oreil.ly/Io80N) for more details.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`DATABASE_URL`变量使用`db`作为PostgreSQL数据库主机的名称。这是因为在*docker-compose.yaml*文件中将`db`定义为服务名称，并且`docker-compose`知道如何通过创建一个覆盖网络使所有在*docker-compose.yaml*文件中定义的服务能够通过其名称互相交互。有关更多详细信息，请参阅[docker-compose网络参考](https://oreil.ly/Io80N)。'
- en: The `DATABASE_URL` variable definition refers to another variable called `DBPASS`,
    instead of hardcoding the password for the `wordcount_dbadmin` user. The *docker-compose.yaml*
    file is usually checked into source control, and best practices are not to commit
    secrets such as database credentials to GitHub. Instead, use an encryption tool
    such as [`sops`](https://github.com/mozilla/sops) to manage a secrets file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`DATABASE_URL`变量定义引用了另一个名为`DBPASS`的变量，而不是直接硬编码`wordcount_dbadmin`用户的密码。*docker-compose.yaml*文件通常提交到源代码控制，最佳实践是不要将诸如数据库凭据之类的机密信息提交到GitHub。相反，使用诸如[`sops`](https://github.com/mozilla/sops)之类的加密工具管理密钥文件。'
- en: Here is an example of how to create an encrypted file using `sops` with PGP
    encryption.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`sops`和PGP加密创建加密文件的示例。
- en: 'First, install `gpg` on macOS via `brew install gpg`, then generate a new PGP
    key with an empty passphrase:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在macOS上通过`brew install gpg`安装`gpg`，然后使用空密码生成新的PGP密钥：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next, download `sops` from its [release page](https://github.com/mozilla/sops/releases).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从其[发布页面](https://github.com/mozilla/sops/releases)下载`sops`。
- en: 'To create a new encrypted file called, for example, *environment.secrets*,
    run `sops` with the `-pgp` flag and give it the fingerprint of the key generated
    above:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个名为*environment.secrets*的新加密文件，例如，运行带有`-pgp`标志的`sops`并提供上述生成的密钥的指纹：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will open the default editor and allow for the input of the plain-text
    secrets. In this example, the contents of the *environment.secrets* file are:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开默认编辑器，并允许输入纯文本密钥。在此示例中，*environment.secrets*文件的内容是：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After saving the *environment.secrets* file, inspect the file to see that it
    is encrypted, which makes it safe to add to source control:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 保存*environment.secrets*文件后，请检查文件以确保其已加密，这样可以安全地添加到源代码控制中：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To decrypt the file, run:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密文件，请运行：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is an issue with `sops` interacting with `gpg` on a Macintosh. You will
    need to run the following commands before being able to decrypt the file with
    `sops`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Macintosh上使用`sops`与`gpg`交互存在问题。在能够使用`sops`解密文件之前，您需要运行以下命令：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The goal here is to run the `migrations` service defined previously in the
    `docker-compose.yaml_ file. To tie the +sops` secret management method into `docker-compose`,
    decrypt the *environments.secrets* file with `sops -d`, source its contents into
    the current shell, then invoke `docker-compose up -d migrations` using one command
    line that will not expose the secret to the shell history:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是运行先前在`docker-compose.yaml`文件中定义的`migrations`服务。为了将`sops`密钥管理方法集成到`docker-compose`中，使用`sops
    -d`解密*environments.secrets*文件，将其内容源化到当前shell中，然后使用一个命令调用`docker-compose up -d
    migrations`，该命令不会将密钥暴露给shell历史记录：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Verify that the migrations were successfully run by inspecting the database
    and verifying that two tables were created: `alembic_version` and `results`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查数据库并验证是否创建了两个表`alembic_version`和`results`来验证迁移是否成功运行：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[Part 4](https://oreil.ly/UY2yw) in the “Flask By Example” tutorial is to deploy
    a Python worker process based on Python RQ that talks to an instance of Redis.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[第四部分](https://oreil.ly/UY2yw) 在“Flask实例”教程中是部署一个基于Python RQ的Python工作进程，该进程与Redis实例通信。'
- en: 'First, Redis needs to run. Add it as a service called `redis` into the *docker_compose.yaml*
    file, and make sure that its internal port 6379 is mapped to port 6379 on the
    local OS:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要运行Redis。将其作为名为`redis`的服务添加到*docker_compose.yaml*文件中，并确保其内部端口6379映射到本地操作系统的端口6379：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Start the `redis` service on its own by specifying it as an argument to `docker-compose
    up -d`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其作为参数指定给 `docker-compose up -d` 单独启动 `redis` 服务：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run `docker ps` to see a new Docker container running based on the `redis:alpine`
    image:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `docker ps` 查看基于 `redis:alpine` 镜像运行的新 Docker 容器：
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Use the `docker-compose logs` command to inspect the logs of the `redis` service:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker-compose logs` 命令检查 `redis` 服务的日志：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The next step is to create a service called `worker` for the Python RQ worker
    process in *docker-compose.yaml*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在 *docker-compose.yaml* 中为 Python RQ 工作进程创建一个名为 `worker` 的服务：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Run the worker service just like the `redis` service, with `docker-compose
    up -d`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 运行工作服务，就像`redis`服务一样，使用`docker-compose up -d`：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Running `docker ps` will show the worker container:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `docker ps` 将显示工作容器：
- en: '[PRE49]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Look at the worker container logs with `docker-compose logs`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker-compose logs`查看工作容器日志：
- en: '[PRE50]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now launch the main Flask application in its own container. Create a new service
    called `app` in *docker-compose.yaml*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在自己的容器中启动主 Flask 应用程序。在 *docker-compose.yaml* 中创建一个名为 `app` 的新服务：
- en: '[PRE51]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Map port 5000 from the application container (the default port for a Flask application)
    to port 5000 on the local machine. Pass the command `manage.py runserver --host=0.0.0.0`
    to the application container to ensure that port 5000 is exposed correctly by
    the Flask application inside the container.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序容器中的端口 5000（Flask 应用程序的默认端口）映射到本地机器的端口 5000。在应用程序容器中传递命令 `manage.py runserver
    --host=0.0.0.0`，以确保 Flask 应用程序在容器内正确地暴露端口 5000。
- en: 'Start up the `app` service with `docker compose up -d`, while also running
    `sops -d` on the encrypted file containing `DBPASS`, then sourcing the decrypted
    file before calling `docker-compose`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker compose up -d` 启动 `app` 服务，同时在包含 `DBPASS` 的加密文件上运行 `sops -d`，然后在调用
    `docker-compose` 之前源化解密文件：
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Notice the new Docker container running the application in the list returned
    by `docker ps`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到新的 Docker 容器正在运行应用程序，列表由 `docker ps` 返回：
- en: '[PRE53]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Inspect the logs of the application container with `docker-compose logs`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker-compose logs` 检查应用程序容器的日志：
- en: '[PRE54]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Running `docker-compose logs` with no other arguments allows us to inspect
    the logs of all the services defined in the *docker-compose.yaml* file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `docker-compose logs` 而不带其他参数允许我们检查 *docker-compose.yaml* 文件中定义的所有服务的日志：
- en: '[PRE55]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The final step is to test the application. Visit http://127.0.0.1:5000 and enter
    `python.org` in the URL field. At that point, the application sends a job to the
    worker process, asking it to execute the function `count_and_save_words` against
    the home page of `python.org`. The application periodically polls the job for
    the results, and upon completion, it displays the word frequencies on the home
    page.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是测试应用程序。访问 http://127.0.0.1:5000 并在 URL 字段中输入 `python.org`。此时，应用程序向工作进程发送一个作业，要求其对
    `python.org` 的主页执行函数 `count_and_save_words`。应用程序定期轮询作业以获取结果，完成后在主页上显示单词频率。
- en: To make the *docker-compose.yaml* file more portable, push the `flask-by-example`
    Docker image to Docker Hub, and reference the Docker Hub image in the container
    section for the `app` and `worker` services.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 *docker-compose.yaml* 文件更具可移植性，将 `flask-by-example` Docker 镜像推送到 Docker
    Hub，并在 `app` 和 `worker` 服务的容器部分引用 Docker Hub 镜像。
- en: 'Tag the existing local Docker image `flask-by-example:v1` with a name prefixed
    by a Docker Hub username, then push the newly tagged image to Docker Hub:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker Hub 用户名前缀为现有的本地 Docker 镜像 `flask-by-example:v1` 打标签，然后将新标记的镜像推送到 Docker
    Hub：
- en: '[PRE56]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Change *docker-compose.yaml* to reference the new Docker Hub image. Here is
    the final version of *docker-compose.yaml*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 *docker-compose.yaml* 以引用新的 Docker Hub 镜像。以下是 *docker-compose.yaml* 的最终版本：
- en: '[PRE57]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To restart the local Docker containers, run `docker-compose down` followed
    by `docker-compose up -d`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新启动本地 Docker 容器，请运行 `docker-compose down`，然后跟着 `docker-compose up -d`：
- en: '[PRE58]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note how easy it is to bring up and down a set of Docker containers with `docker-compose`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 `docker-compose` 轻松启动和关闭一组 Docker 容器。
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Even if you want to run a single Docker container, it is still a good idea to
    include it in a *docker-compose.yaml* file and launch it with the `docker-compose
    up -d` command. It will make your life easier when you want to add a second container
    into the mix, and it will also serve as a mini Infrastructure as Code example,
    with the *docker-compose.yaml* file reflecting the state of your local Docker
    setup for your application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您只想运行单个 Docker 容器，将其包含在 *docker-compose.yaml* 文件中并使用 `docker-compose up -d`
    命令启动它仍然是个好主意。当您想要添加第二个容器时，这将使您的生活更加轻松，并且还将作为基础设施即代码的一个小例子，*docker-compose.yaml*
    文件反映了您的应用程序的本地 Docker 设置状态。
- en: Porting the docker-compose Services to a New Host and Operating System
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 docker-compose 服务迁移到新主机和操作系统
- en: We will now show how to take the `docker-compose` setup from the preceding section
    and port it to a server running Ubuntu 18.04.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将展示如何将前一节的 `docker-compose` 设置迁移到运行 Ubuntu 18.04 的服务器。
- en: 'Launch an Amazon EC2 instance running Ubuntu 18.04 and install `docker-engine`
    and `docker-compose`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 启动运行 Ubuntu 18.04 的 Amazon EC2 实例并安装 `docker-engine` 和 `docker-compose`：
- en: '[PRE59]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Copy the *docker-compose.yaml* file to the remote EC2 instance and start the
    `db` service first, so that the database used by the application can be created:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *docker-compose.yaml* 文件复制到远程 EC2 实例并首先启动 `db` 服务，以便可以创建应用程序使用的数据库：
- en: '[PRE60]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Use `docker exec` to run the `psql -U postgres` command inside the running
    Docker container for the PostgreSQL database. At the PostgreSQL prompt, create
    the `wordcount` database and `wordcount_dbadmin` role:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker exec` 在正在运行的 Docker 容器中运行 `psql -U postgres` 命令访问 PostgreSQL 数据库。在
    PostgreSQL 提示符下，创建 `wordcount` 数据库和 `wordcount_dbadmin` 角色：
- en: '[PRE61]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Before launching the containers for the services defined in *docker-compose.yaml*,
    two things are necessary:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动在 *docker-compose.yaml* 中定义的服务的容器之前，有两件事是必需的：
- en: 'Run `docker login` to be able to pull the Docker image pushed previously to
    Docker Hub:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `docker login` 以能够拉取之前推送到 Docker Hub 的 Docker 镜像：
- en: '[PRE62]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Set the `DBPASS` environment variable to the correct value in the current shell.
    The `sops` method described in the local macOS setup can be used, but for this
    example, set it directly in the shell:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前 Shell 中设置`DBPASS`环境变量的正确值。在本地 macOS 设置中描述的`sops`方法可用，但是在本示例中，直接在 Shell 中设置：
- en: '[PRE63]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now launch all the services necessary for the application by running `docker-compose
    up -d`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过运行 `docker-compose up -d` 启动应用程序所需的所有服务：
- en: '[PRE64]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: At this point, after allowing access to port 5000 in the AWS security group
    associated with our Ubuntu EC2 instance, you can hit the external IP of the instance
    on port 5000 and use the application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，在允许 AWS 安全组中与我们的 Ubuntu EC2 实例关联的端口 5000 的访问后，您可以在该实例的外部 IP 上的 5000 端口访问并使用该应用程序。
- en: 'It’s worth emphasizing one more time how much Docker simplifies the deployment
    of applications. The portability of Docker containers and images means that you
    can run your application on any operating system where the Docker engine runs.
    In the example shown here, none of the prerequisites needed to be installed on
    the Ubuntu server: not Flask, not PostgreSQL, and not Redis. It was also not necessary
    to copy the application code over from the local development machine to the Ubuntu
    server. The only file needed on the Ubuntu server was *docker-compose.yaml*. Then,
    the whole set of services comprising the application was launched with just one
    command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调一下 Docker 简化应用部署的重要性。Docker 容器和镜像的可移植性意味着您可以在任何安装了 Docker 引擎的操作系统上运行您的应用程序。在这里展示的示例中，在
    Ubuntu 服务器上不需要安装任何先决条件：不需要 Flask，不需要 PostgreSQL，也不需要 Redis。也不需要将应用程序代码从本地开发机器复制到
    Ubuntu 服务器上。在 Ubuntu 服务器上唯一需要的文件是 *docker-compose.yaml*。然后，只需一条命令就可以启动应用程序的整套服务：
- en: '`$ docker-compose up -d`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker-compose up -d`'
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Beware of downloading and using Docker images from public Docker repositories,
    because many of them include serious security vulnerabilities, the most serious
    of which can allow an attacker to break through the isolation of a Docker container
    and take over the host operating system. A good practice here is to start with
    a trusted, pre-built image, or build your own image from scratch. Stay abreast
    of the latest security patches and software updates, and rebuild your image whenever
    any of these patches or updates are available. Another good practice is to scan
    all of your Docker images with one of the many Docker scanning tools available,
    among them [Clair](https://oreil.ly/OBkkx), [Anchore](https://oreil.ly/uRI_1),
    and [Falco](https://oreil.ly/QXRg6). Such scanning can be performed as part of
    a continuous integration/continuous deployment pipeline, when the Docker images
    usually get built.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 警惕从公共 Docker 仓库下载和使用 Docker 镜像，因为其中许多镜像存在严重的安全漏洞，其中最严重的可以允许攻击者突破 Docker 容器的隔离性并接管主机操作系统。一个良好的实践是从一个受信任的、预构建的镜像开始，或者从头开始构建你自己的镜像。随时关注最新的安全补丁和软件更新，并在这些补丁或更新可用时重新构建你的镜像。另一个良好的实践是使用众多可用的
    Docker 扫描工具之一（其中包括 [Clair](https://oreil.ly/OBkkx)、[Anchore](https://oreil.ly/uRI_1)
    和 [Falco](https://oreil.ly/QXRg6)）扫描所有的 Docker 镜像。这样的扫描可以作为持续集成/持续部署流水线的一部分进行，通常在构建
    Docker 镜像时执行。
- en: Although `docker-compose` makes it easy to run several containerized services
    as part of the same application, it is only meant to be run on a single machine,
    which limits its usefulness in production scenarios. You can really only consider
    an application deployed with `docker-compose` to be “production ready” if you
    are not worried about downtime and you are willing to run everything on a single
    machine (this being said, Grig has seen hosting providers running Dockerized applications
    in production with `docker-compose`). For true “production ready” scenarios, you
    need a container orchestration engine such as Kubernetes, which will be discussed
    in the next chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `docker-compose` 可以轻松地运行多个容器化服务作为同一应用的一部分，但它只适用于单台机器，这在生产环境中的实用性受到限制。如果你不担心停机时间并愿意在单台机器上运行所有内容，那么只能认为使用
    `docker-compose` 部署的应用程序是“生产就绪”的（尽管如此，格里格看到一些托管提供者使用 `docker-compose` 在生产环境中运行
    Docker 化应用程序）。对于真正的“生产就绪”场景，你需要一个像 Kubernetes 这样的容器编排引擎，这将在下一章讨论。
- en: Exercises
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Familiarize yourself with the [Dockerfile reference](https://oreil.ly/kA8ZF).
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉 [Dockerfile 参考](https://oreil.ly/kA8ZF)。
- en: Familiarize yourself with the [Docker Compose configuration reference](https://oreil.ly/ENMsQ).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉 [Docker Compose 配置参考](https://oreil.ly/ENMsQ)。
- en: Create an AWS KMS key and use it with `sops` instead of a local `PGP` key. This
    allows you to apply AWS IAM permissions to the key, and restrict access to the
    key to only the developers who need it.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 AWS KMS 密钥，并在 `sops` 中使用它，而不是本地的 `PGP` 密钥。这允许你将 AWS IAM 权限应用到密钥上，并将对密钥的访问限制为仅需要的开发人员。
- en: Write a shell script that uses `docker exec` or `docker-compose exec` to run
    the PostgreSQL commands necessary for creating a database and a role.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 shell 脚本，使用 `docker exec` 或 `docker-compose exec` 来运行 PostgreSQL 命令，创建数据库和角色。
- en: Experiment with other container technologies, such as [Podman](https://podman.io).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试其他容器技术，例如 [Podman](https://podman.io)。
- en: ^([1](ch11.html#idm46691322287592-marker)) This is an example URL address—your
    IP address will be different.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.html#idm46691322287592-marker)) 这是一个示例 URL 地址——你的 IP 地址将会不同。
- en: ^([2](ch11.html#idm46691322283160-marker)) Again, your IP address will be different.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch11.html#idm46691322283160-marker)) 你的 IP 地址将会不同。
