# 附录 A. 初学者的硬件和软件

有些东西是直观的。有些我们在自然界中看到，而其他的是人类的发明，如轮子或披萨。

其他需要更大的信仰跳跃。电视是如何将空中的看不见的摇晃转换成声音和动态图像的？

计算机是一个难以接受的想法之一。你怎么能够输入东西，然后让机器按照你的意愿去做呢？

当我学习编程时，有些基本问题的答案很难找到。例如：一些书籍用图书馆书架上的书的类比来解释计算机存储器。我曾想知道，如果你*从内存中读取*，类比意味着你从书架上取出一本书。那么，这会把它从内存中删除吗？实际上不会。更像是从书架上复制一本书。

如果你是相对新手，本附录简要回顾了计算机硬件和软件。我尝试解释那些最终变得“显而易见”的事物，但可能在一开始时会成为障碍。

# 硬件

## 穴居人的计算机

当穴居人 Og 和 Thog 从狩猎归来时，他们每杀死一头猛犸象，就会在自己的堆里加一块石头。但除了比谁的堆显著更大，他们不能做什么。

Og 的远裔（Thog 有一天被猛犸象踩死，试图增加他的堆），学会了数数、写字和使用算盘。但要超越这些工具，进入计算机的概念，需要一些想象力和技术的飞跃。第一个必要的技术是电力。

## 电力

本杰明·富兰克林认为电是一种从流体量较多的地方（*正极*）流向量较少的地方（*负极*）的流动的某种看不见的液体。他是对的，但术语搞反了。电子从他的“负极”流向“正极”，但电子直到后来才被发现 —— 太迟了，不能改变术语。因此，自那时起，我们一直需要记住电子流动的方向和*电流*定义的流动方式是相反的。

我们都熟悉自然电现象，如静电和闪电。在人们发现如何通过导线推动电子形成电路后，我们离制造计算机又近了一步。

我曾经以为电线中的电流是由兴奋的电子在轨道上做圈圈引起的。实际情况大不相同。电子会从一个原子跳到另一个原子。它们的行为有点像管子中的球轴承（或者珍珠奶茶吸管中的珍珠）。当你在一端推动一颗球时，它会推动它的邻居，依此类推，直到另一端的球被推出来。虽然一个普通电子的移动速度很慢（电线中的漂移速度仅约为每小时三英寸），但这种几乎同时的撞击使得生成的电磁波传播非常迅速：速度达到光速的 50%到 99%，取决于导体。

## 发明

我们仍然需要：

+   记忆事物的一种方法

+   一种方法是利用我们记住的东西进行操作

一个存储概念是*开关*：一种只能处于开或关状态，并且保持不变直到有东西将其翻转到另一状态的物品。电开关通过打开或关闭电路来工作，允许电子流动或阻止电子流动。我们经常使用开关来控制灯和其他电气设备。需要的是一种能够通过电来控制开关本身的方法。

最早的计算机（和电视）使用真空管来实现这一目的，但它们又大又经常烧坏。导致现代计算机出现的单一关键发明是*晶体管*：它更小、更高效、更可靠。最后的关键步骤是将晶体管做得更小，并将它们连接成*集成电路*。多年来，随着计算机变得越来越小，它们变得越来越快速和价格越来越低廉。当组件越接近时，信号传输速度更快。

但是我们能够将东西放得越来越小的极限是有限的。这种电子的调皮会遇到*电阻*，产生热量。我们在超过 10 年前达到了这个下限，制造商通过在同一板上放置多个“芯片”来补偿。这增加了*分布式计算*的需求，我稍后会讨论。

不管这些细节如何，有了这些发明，我们已经能够构建*计算机*：能够记住事物并对其进行处理的机器。

## 理想化的计算机

真正的计算机有许多复杂的功能。让我们专注于关键部分。

电路“板”包含 CPU、存储器和连接它们彼此以及外部设备插头的电线。

## CPU

*CPU*（中央处理单元）或“芯片”执行实际的“计算”：

+   数学任务如加法

+   比较值

## 存储器和高速缓存

*RAM*（随机存取存储器）进行“记忆”。它速度快，但是*易失性*（如果断电则会丢失数据）。

CPU 比内存速度更快，因此计算机设计者一直在添加*缓存*：位于 CPU 和主内存之间的较小、更快的内存。当 CPU 尝试从内存读取一些字节时，它首先尝试最接近的缓存（称为*L1*缓存），然后是下一个（*L2*），最后到主 RAM。

## 存储

因为主存储器会丢失数据，我们还需要*非易失性*存储。这些设备比内存便宜，能够存储更多数据，但速度也慢得多。

传统的存储方法是“旋转锈”：*磁盘*（或*硬盘*或*HDD*）带有可移动读写头，有点像黑胶唱片和唱针。

一种称为*固态硬盘*（Solid State Drive，SSD）的混合技术是由类似 RAM 的半导体组成，但像磁盘一样是非易失性的。价格和速度介于这两者之间。

## 输入

如何将数据输入计算机？对于人类来说，主要选择是键盘、鼠标和触摸屏。

## 输出

人们通常通过显示器和打印机看到计算机的输出。

## 相对访问时间

从任何这些组件获取数据并将数据传输出去所需的时间差异巨大。这对实际应用有着重大的影响，例如，软件需要在内存中运行并访问数据，但它还需要将数据安全地存储在像磁盘这样的非易失性设备上。问题在于磁盘慢了成千上万倍，网络甚至更慢。这意味着程序员花费了大量时间来在速度和成本之间进行最佳权衡。

在 [《人类尺度下的计算机延迟》](https://oreil.ly/G36qD) 中，大卫·杰普森对它们进行了比较。我从他的数据和其他数据推导出了 表 A-1。最后三列——比率、相对时间（CPU = 一秒）和相对距离（CPU = 一英寸）——比具体的时间更容易理解。

表 A-1\. 相对访问时间

| 地点 | 时间 | 比率 | 相对时间 | 相对距离 |
| --- | --- | --- | --- | --- |
| CPU | 0.4 纳秒 | 1 | 1 秒 | 1 英寸 |
| L1 缓存 | 0.9 纳秒 | 2 | 2 秒 | 2 英寸 |
| L2 缓存 | 2.8 纳秒 | 7 | 7 秒 | 7 英寸 |
| L3 缓存 | 28 纳秒 | 70 | 1 分钟 | 6 英尺 |
| RAM | 100 纳秒 | 250 | 4 分钟 | 20 英尺 |
| SSD | 100 微秒 | 250,000 | 3 天 | 4 英里 |
| 磁盘 | 10 毫秒 | 25,000,000 | 9 个月 | 400 英里 |
| 互联网：SF→NY | 65 毫秒 | 162,500,000 | 5 年 | 2,500 英里 |

庆幸的是，CPU 指令实际上只需要不到一纳秒的时间，而不是整整一秒，否则你可能在访问磁盘的时间里生个孩子。因为磁盘和网络的时间比 CPU 和 RAM 慢得多，所以尽可能多地在内存中进行工作是有帮助的。而且由于 CPU 本身比 RAM 快得多，所以将数据保持连续是有意义的，这样字节就可以由更快（但更小）的缓存服务，靠近 CPU。

# 软件

鉴于所有这些计算机硬件，我们将如何控制它？首先，我们既有*指令*（告诉 CPU 要做什么的东西），也有*数据*（指令的输入和输出）。在*存储程序计算机*中，一切都可以被视为数据，这简化了设计。但是如何表示指令和数据呢？什么是你在一个地方保存并在另一个地方处理的东西？遥远的原始人 Og 的后代们想知道。

## 起初是比特

让我们重新思考一下*开关*的概念：维持两个值之一的东西。这些值可以是开或关、高或低电压、正或负——只要是可以设置的东西，不会忘记，并且以后可以向任何要求它的人提供其值的东西。集成电路给了我们一种将数十亿个小开关集成和连接到小芯片中的方法。

如果一个开关只能有两个值，它可以用来表示一个*比特*，或二进制位。这可以被视为微小的整数 `0` 和 `1`，是和否、真和假，或者任何我们想要的东西。

然而，对于 `0` 和 `1` 以外的任何东西来说，比特都太小了。我们怎么能说服比特表示更大的事物呢？

要获得答案，请看您的手指。我们在日常生活中只使用 10 个数字（0 到 9），但通过*位的位置表示法*可以创建比 9 更大的数字。如果我给数字`38`加`1`，则`8`变成`9`，整个值现在是`39`。如果我再加`1`，则`9`变成`0`，我*向左进位*，将`3`增加到`4`，得到最终的数字`40`。最右边的数字在“个位”，左边的在“十位”，依此类推向左乘以 10。使用三个十进制数字，可以表示一千（10 * 10 * 10）个数字，从`000`到`999`。

我们可以使用位的位置表示法来组合更大的位集合。*字节*由八位组成，有 2⁸（256）种可能的位组合。例如，您可以使用一个字节存储小整数`0`到`255`（在位的位置表示法中需要为零保留空间）。

一个字节看起来像是一排八个位，每个位的值要么是`0`（关闭或假），要么是`1`（打开或真）。最右边的位是*最低有效位*，最左边的是*最高有效位*。

## 机器语言

每台计算机的 CPU 都设计有一组位模式（也称为操作码）的*指令集*，它理解这些指令。每个操作码执行特定的功能，从一个地方获取输入值并将输出值传输到另一个地方。CPU 有称为*寄存器*的特殊内部位置来存储这些操作码和值。

让我们使用一个仅处理字节的简化计算机，它有四个字节大小的寄存器，分别称为`A`、`B`、`C`和`D`。假设：

+   命令的操作码放入寄存器`A`中。

+   该指令从寄存器`B`和`C`获取其字节输入。

+   该指令将其字节结果存储在寄存器`D`中。

（两个字节相加可能会*溢出*到一个字节的结果，但这里我忽略了这一点，以展示发生了什么。）

假设

+   寄存器`A`包含*加两个整数*的操作码：十进制`1`（二进制`00000001`）。

+   寄存器`B`中有十进制值`5`（二进制`00000101`）。

+   寄存器`C`中有十进制值`3`（二进制`00000011`）。

CPU 发现指令已经到达寄存器`A`。它解码并执行该指令，从寄存器`B`和`C`读取值，并将它们传递给内部硬件电路，可以添加字节。完成后，我们应该在寄存器`D`中看到十进制值`8`（二进制`00001000`）。

CPU 使用寄存器进行加法和其他数学功能。它*解码*操作码并将控制传递给 CPU 内特定的电路。它还可以比较事物，比如“寄存器`B`中的值是否大于寄存器`C`中的值？”重要的是，它还从内存中*获取*值到 CPU，从 CPU 中*存储*值到内存。

计算机将*程序*（机器语言指令和数据）存储在内存中，并处理将指令和数据输入到 CPU，并从 CPU 中读取指令和数据。

## 汇编器

用机器语言编程很难。你必须精确指定每一位，这非常耗时。因此，人们提出了一种稍微可读性更高的语言级别，称为*汇编语言*，或者简称*汇编器*。这些语言特定于 CPU 设计，并允许你使用变量名来定义指令流和数据。

## 高级语言

汇编仍然是一项繁琐的工作，所以人们设计了更高级别的语言，更容易供人们使用。这些语言将由称为*编译器*的程序转换为汇编语言，或者由*解释器*直接运行。其中最早的语言包括 FORTRAN、LISP 和 C——在设计和预期使用方面大相径庭，但在计算机架构中的位置相似。

在实际工作中，你往往会看到不同的软件“堆栈”：

大型计算机

IBM，COBOL，FORTRAN 和其他语言

微软

Windows，ASP，C＃，SQL Server

JVM

Java，Scala，Groovy

开源软件

Linux，语言（Python，PHP，Perl，C，C++，Go），数据库（MySQL，PostgreSQL），Web（apache，nginx）

程序员倾向于留在这些世界中的一个，使用其中的语言和工具。一些技术，如 TCP/IP 和 Web，允许不同堆栈之间的互联。

## 操作系统

每一个创新都是在前面的基础上构建的，通常我们不知道也不关心更底层的工作原理。工具构建工具，进而构建更多工具，我们习以为常。

主要的操作系统有：

Windows（微软）

商业软件，多个版本

macOS（苹果）

商业软件

Linux

开源软件

Unix

许多商业版本，大部分已被 Linux 取代

操作系统包含：

内核

调度和控制程序和 I/O

设备驱动程序

被内核用于访问 RAM、磁盘和其他设备

库

开发人员使用的源代码和二进制文件

应用程序

独立程序

同一台计算机硬件可以支持多个操作系统，但一次只能运行一个。当一个操作系统启动时，称为*启动*，¹ 因此*重新启动*是重新启动它。这些术语甚至出现在电影营销中，因为制片厂会“重启”之前未成功的尝试。你可以通过安装多个操作系统并排运行来*双重启动*你的计算机，但一次只能启动和运行一个。

如果你看到术语*裸金属*，它指的是单台运行操作系统的计算机。在接下来的几节中，我们将从裸金属中逐步升级。

## 虚拟机

操作系统有点像一个大程序，所以最终有人想出了如何在*主机*机器上作为*虚拟机*（客户程序）运行外部操作系统。所以你可以在你的 PC 上运行 Microsoft Windows，同时又在其上启动一个 Linux 虚拟机，而无需购买第二台计算机或双重启动。

## 容器

一个更近期的概念是*容器*——一种同时运行多个操作系统的方式，只要它们共享相同的内核。这个想法是由[Docker](https://www.docker.com)推广的，它利用了一些鲜为人知的 Linux 内核功能并增加了有用的管理功能。他们对运输集装箱的类比（它们彻底改变了运输业，并为我们所有人节省了金钱）是清晰而吸引人的。通过将代码作为开源发布，Docker 使容器能够在整个计算机行业中迅速被采用。

谷歌和其他云提供商多年来一直悄悄地在 Linux 中添加基础内核支持，并在他们的数据中心中使用容器。容器使用的资源比虚拟机少，让你能够在每个物理计算机箱中装更多的程序。

## 分布式计算与网络

当企业开始使用个人电脑时，它们需要一种使它们互相交流以及与打印机等设备通信的方式。最初使用专有的网络软件，如诺维尔（Novell）的，但随着因特网在 90 年代中期到 90 年代末的出现，最终被 TCP/IP 所取代。微软从一种名为*BSD*的免费 Unix 变体中获取了它的 TCP/IP 堆栈。²

因互联网繁荣而带来的一个影响是对*服务器*的需求：运行所有那些网络、聊天和电子邮件服务的机器和软件。旧式的*系统管理员*（系统管理）是手动安装和管理所有硬件和软件。不久之后，很明显地对每个人来说都需要自动化。2006 年，微软的比尔·贝克尔提出了关于服务器管理的*宠物与牛*的类比，自那时起它已经成为一个行业迷因（有时更通用地称为*宠物与牲畜*）；见表 A-2。

表 A-2\. 宠物与牲畜

| 宠物 | 牲畜 |
| --- | --- |
| 分别命名 | 自动编号 |
| 定制关怀 | 标准化 |
| 护理至健康 | 替换 |

作为“系统管理员”的继任者，您经常会看到术语*DevOps*：开发加运维，一种支持对服务进行快速更改而不会炸掉的技术混合。云服务非常庞大和复杂，即使像亚马逊和谷歌这样的大公司也偶尔会出现故障。

## 云

多年来，人们一直在建立计算机*集群*，使用许多技术。一个早期的概念是*贝奥武夫集群*：由相同的商用计算机（戴尔或类似的，而不是太阳或惠普等工作站）通过本地网络连接起来。

术语*云计算*意味着使用数据中心中的计算机来执行计算任务和存储数据——但不仅仅是为拥有这些后端资源的公司。这些服务向任何人提供，费用基于 CPU 时间、磁盘存储量等。亚马逊及其*AWS*（亚马逊网络服务）是最突出的，但*Azure*（微软）和*Google Cloud*也是大公司。

在幕后，这些云使用裸金属、虚拟机和容器——全部被视为家畜，而非宠物。

## Kubernetes

需要管理多个数据中心中的大型计算机集群的公司，如谷歌、亚马逊和 Facebook，都借用或构建了帮助它们扩展的解决方案：

部署

如何使新的计算硬件和软件可用？它们失败时如何替换？

配置

这些系统应该如何运行？它们需要诸如其他计算机的名称和地址、密码和安全设置等内容。

编排

如何管理所有这些计算机、虚拟机和容器？您能根据负载变化进行扩展或收缩吗？

服务发现

您如何找出谁在做什么，以及它在哪里？

一些竞争解决方案由 Docker 和其他公司开发。但在过去几年中，看起来[Kubernetes](http://kubernetes.io)已经获胜。

谷歌开发了大型内部管理框架，代号为 Borg 和 Omega。当员工们提出开源这些“皇家珍宝”的想法时，管理层需要考虑一下，但他们迈出了这一步。谷歌在 2015 年发布了 Kubernetes 1.0 版本，其生态系统和影响力自那时以来不断增长。

¹ 这指的是“通过自己的靴带提升自己”，这似乎和一台计算机一样不可能。

² 您仍然可以在一些微软文件中看到加州大学的版权声明。
