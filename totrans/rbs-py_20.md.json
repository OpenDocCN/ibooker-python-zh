["```py\nclass ImperialMeasure(Enum):\n    TEASPOON = auto()\n    TABLESPOON = auto()\n    CUP = auto()\n\nclass Broth(Enum):\n    VEGETABLE = auto()\n    CHICKEN = auto()\n    BEEF = auto()\n    FISH = auto()\n\n@dataclass(frozen=True)\n# Ingredients added into the broth\nclass Ingredient:\n    name: str\n    amount: float = 1\n    units: ImperialMeasure = ImperialMeasure.CUP\n\n@dataclass\nclass Recipe:\n    aromatics: set[Ingredient]\n    broth: Broth\n    vegetables: set[Ingredient]\n    meats: set[Ingredient]\n    starches: set[Ingredient]\n    garnishes: set[Ingredient]\n    time_to_cook: datetime.timedelta\n```", "```py\nlogging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG)\nlogger.warning(\"Family did not match any restaurants: Lookup code A1503\")\n```", "```py\nimport bacon_preparer\nimport veg_cheese_preparer\n\ndef make_potato_leek_and_bacon_soup():\n    bacon = bacon_preparer.make_bacon(slices=2)\n    potatoes = veg_cheese_preparer.cube_potatoes(grams=300)\n    leeks = veg_cheese_preparer.slice(ingredient=Vegetable.LEEKS, grams=250)\n\n    chopped_bacon = chop(bacon)\n\n    # the following methods are provided by soup preparer\n    add_chicken_stock()\n    add(potatoes)\n    add(leeks)\n    cook_for(minutes=30)\n    blend()\n    garnish(chopped_bacon)\n    garnish(Garnish.BLACK_PEPPER)\n```", "```py\nfrom typing import Callable\ndef do_twice(func: Callable, *args, **kwargs):\n    func(*args, **kwargs)\n    func(*args, **kwargs)\n```", "```py\ndef repeat(func: Callable, times: int = 1) -> Callable:\n    ''' this is a function that calls the wrapped function\n a specified number of times\n '''\n    def _wrapper(*args, **kwargs):\n        for _ in range(times):\n            func(*args, **kwargs)\n    return _wrapper\n\n@repeat(times=3)\ndef say_hello():\n    print(\"Hello\")\n\nsay_hello()\n>>> \"Hello\"\n\"Hello\"\n\"Hello\"\n```", "```py\n# setting properties of self.*_db objects will\n# update data in the database\ndef on_dish_ordered(dish: Dish):\n    dish_db[dish].count += 1\n\ndef save_inventory_counts(inventory):\n    for ingredient in inventory:\n        inventory_db[ingredient.name] = ingredient.count\n\ndef log_time_per_dish(dish: Dish, number_of_seconds: int):\n    dish_db[dish].time_spent.append(number_of_seconds)\n```", "```py\nimport backoff\nimport requests\nfrom autokitchen.database import OperationException\n# setting properties of self.*_db objects will\n# update data in the database\n@backoff.on_exception(backoff.expo,\n                      OperationException,\n                      max_tries=5)\ndef on_dish_ordered(dish: Dish):\n    self.dish_db[dish].count += 1\n\n@backoff.on_exception(backoff.expo,\n                      OperationException,\n                      max_tries=5)\n@backoff.on_exception(backoff.expo,\n                      requests.exceptions.HTTPError,\n                      max_time=60)\ndef save_inventory_counts(inventory):\n    for ingredient in inventory:\n        self.inventory_db[ingredient.name] = ingredient.count\n\n@backoff.on_exception(backoff.expo,\n                      OperationException,\n                      max_time=60)\ndef log_time_per_dish(dish: Dish, number_of_seconds: int):\n    self.dish_db[dish].time_spent.append(number_of_seconds)\n```", "```py\n@backoff.on_exception(backoff.expo,\n                      OperationException,\n                      max_tries=5)\n@backoff.on_exception(backoff.expo,\n                      requests.exceptions.HTTPError,\n                      max_time=60)\ndef save_inventory_counts(inventory):\n    # ...\n```", "```py\ndef save_inventory_counts(inventory):\n    retry = True\n    retry_counter = 0\n    time_to_sleep = 1\n    while retry:\n        try:\n            for ingredient in inventory:\n                self.inventory_db[ingredient.name] = ingredient.count\n        except OperationException:\n            retry_counter += 1\n            if retry_counter == 5:\n                retry = False\n        except requests.exception.HTTPError:\n            time.sleep(time_to_sleep)\n            time_to_sleep *= 2\n            if time_to_sleep > 60:\n                retry = False\n```", "```py\nRecommendation Algorithm #1\n\nLook at all daily specials\nSort based on number of matching surplus ingredients\nSelect the meals with the highest number of surplus ingredients\nSort by proximity to last meal ordered\n    (proximity is defined by number of ingredients that match)\nTake only results that are above 75% proximity\nReturn up to top 3 results\n```", "```py\ndef recommend_meal(last_meal: Meal,\n                   specials: list[Meal],\n                   surplus: list[Ingredient]) -> list[Meal]:\n    highest_proximity = 0\n    for special in specials:\n        if (proximity := get_proximity(special, surplus)) > highest_proximity:\n            highest_proximity = proximity\n\n    grouped_by_surplus_matching = []\n    for special in specials:\n        if get_proximity(special, surplus) == highest_proximity:\n            grouped_by_surplus_matching.append(special)\n\n    filtered_meals = []\n    for meal in grouped_by_surplus_matching:\n        if get_proximity(meal, last_meal) > .75:\n            filtered_meals.append(meal)\n\n    sorted_meals = sorted(filtered_meals,\n                          key=lambda meal: get_proximity(meal, last_meal),\n                          reverse=True)\n\n    return sorted_meals[:3]\n```", "```py\nRecommendation Algorithm #2\n\nLook at all meals available\nSort based on proximity to last meal\nSelect the meals with the highest proximity\nSort the meals by number of surplus ingredients\nTake only results that are a special or have more than 3 surplus ingredients\nReturn up to top 5 results\n```", "```py\nLook at <a list of meals>\nSort based on <initial sorting criteria>\nSelect the meals with the <grouping criteria>\nSort the meals by <secondary sorting criteria>\nTake top results that match <selection criteria>\nReturn up to top <number> results\n```", "```py\nimport itertools\ndef recommend_meal(policy: RecommendationPolicy) -> list[Meal]:\n    meals = policy.meals\n    sorted_meals = sorted(meals, key=policy.initial_sorting_criteria,\n                          reverse=True)\n    grouped_meals = itertools.groupby(sorted_meals, key=policy.grouping_criteria)\n    _, top_grouped = next(grouped_meals)\n    secondary_sorted = sorted(top_grouped, key=policy.secondary_sorting_criteria,\n                              reverse=True)\n    candidates = itertools.takewhile(policy.selection_criteria, secondary_sorted)\n    return list(candidates)[:policy.desired_number_of_recommendations]\n```", "```py\n# I've used named functions to increase readability in the following example\n# instead of lambda functions\nrecommend_meal(RecommendationPolicy(\n    meals=get_specials(),\n    initial_sorting_criteria=get_proximity_to_surplus_ingredients,\n    grouping_criteria=get_proximity_to_surplus_ingredients,\n    secondary_sorting_criteria=get_proximity_to_last_meal,\n    selection_criteria=proximity_greater_than_75_percent,\n    desired_number_of_recommendations=3)\n)\n```"]