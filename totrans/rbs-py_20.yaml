- en: Chapter 17\. Composability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest challenges you face as a developer is predicting how future
    developers will change your system. Businesses evolve, and the assertions of today
    become the legacy systems of the future. How would you support such a system?
    How do you reduce the friction that future developers will face when adapting
    your system? You will need to develop your code so that it can perform in all
    sorts of circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you are going to learn how to develop that code by thinking
    in terms of composability. When you write with composability in mind, you create
    your code to be small, discrete, and reusable. I’ll show you an architecture that
    is not composable and how that can hinder development. You’ll then learn how to
    fix it with composability in mind. You’ll learn how to compose objects, functions,
    and algorithms to make your codebase more extensible. But first, let’s examine
    how composability increases maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Composability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Composability* focuses on building small components with minimal inter-dependencies
    and little business logic embedded inside. The goal is that future developers
    can use any one of these components to build their own solutions. By making them
    small, you make them easier to read and understand. By reducing dependencies,
    you save future developers from worrying about all the costs involved in pulling
    new code (such as the costs you learned about in [Chapter 16](part0021_split_000.html#dependencies)).
    By keeping the components mostly free of business logic, you allow your code to
    solve new problems, even if those new problems look nothing like the problems
    you encounter today. As the number of composable components increases, developers
    can mix’n’match your code to create brand-new applications with the utmost ease.
    By focusing on composability, you make it easier to reuse and extend your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the lowly spice rack in a kitchen. What sort of meals would you create
    if you were to stock your spice rack exclusively with blends of spices, such as
    pumpkin pie spice (cinnamon, nutmeg, ginger, and cloves) or Chinese five-spice
    (cinnamon, fennel, star anise, Sichuan peppercorns, and cloves)? You’d end up
    predominantly making recipes that centered on these spice mixes, such as pumpkin
    pie or five-spice chicken. While these blends make specialized meals incredibly
    easy to prepare, what happens if you need to make something that just uses individual
    ingredients, such as a cinnamon-clove syrup? You could try to substitute pumpkin
    pie spice or five-spice powder and hope that the extra ingredients don’t clash,
    or you could buy cinnamon and cloves individually.
  prefs: []
  type: TYPE_NORMAL
- en: The individual spices are analagous to small, composable bits of software. You
    don’t know what dishes you might want to make in the future, nor do you know what
    business needs you will have in the future. By focusing on discrete components,
    you give your collaborators flexibility in using what they need, without trying
    to make suboptimal substitutions or pulling other components along for the ride.
    And if you need a specialized blend of components (such as a pumpkin pie spice),
    you are free to build your application from those components. Software doesn’t
    expire like spice mixes; you can have your cake (or pumpkin pie) and eat it too.
    Build the specialized applications from small, discrete, composable software,
    and you’ll find that you can reuse those components in brand new ways next week
    or next year.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve actually seen composability before when you learned about building your
    own types in [Part II](part0011.html#part_2). I built up an array of small, discrete
    types that could be reused in multiple scenarios. Each type contributed to a vocabulary
    of concepts in the codebase. Developers could use these types to represent domain
    ideas, but also to build upon to define new concepts. Take a look at a definition
    of a soup from [Chapter 9](part0013_split_000.html#dataclasses):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I was able to create a `Recipe` out of `Ingredient`, `Broth`, and `ImperialMeasure`
    objects. All of these concepts could have been embedded in `Recipe` itself, but
    this would have make reuse tougher (if somebody wanted to use an `ImperialMeasure`,
    it’d be confusing to depend on `Recipe` to do so.) By keeping each of these types
    disparate, I allow future maintainers to build new types, such as non–soup-related
    concepts, without needing to find ways to tease apart dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: This was an example of *type composition*, where I created discrete types that
    could be mixed and matched in new ways. In this chapter, I’m going to focus on
    other common composition types in Python, such as composing functionality, functions,
    and algorithms. Take, for instance, the simple menu at a sandwich shop, like the
    one in [Figure 17-1](part0022_split_001.html#menu).
  prefs: []
  type: TYPE_NORMAL
- en: '![A fictional menu, containing various wraps, sandwiches, sides and drinks.
    The menu advertises a pick-2 combo](../images/00029.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-1\. A fictional menu
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This menu is another example of composability. Diners pick two entries off the
    first part of the menu, plus a side and a drink. They *compose* different parts
    of the menu to get the exact lunch they want. If this menu were not composable,
    you would have to list every single option to represent all the combinations possible
    (and with 1,120 options, that’s a menu that puts most restaurants to shame). This
    is not tractable for any restaurant to handle; it’s easier to break the menu into
    parts that can be pieced together.
  prefs: []
  type: TYPE_NORMAL
- en: I want you to think about your code in the same way. Code doesn’t become composable
    just by existing; you have to actively design with composability in mind. You
    want to look at the classes, functions, and data types that you create and ask
    how you can write them so that future developers can reuse them.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an automated kitchen, creatively named AutoKitchen, that serves as
    the backbone of Pat’s Café. It is a fully automated system that is able to make
    any dish on the menu. I want it to be easy to add new dishes to this system; Pat’s
    Café boasts an ever-changing menu, and the developers are tired of having to spend
    a lot of time modifying large chunks of the system each time. The design of AutoKitchen
    is shown in [Figure 17-2](part0022_split_001.html#auto_kitchen).
  prefs: []
  type: TYPE_NORMAL
- en: '![AutoKitchen design](../images/00030.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-2\. AutoKitchen design
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This design is fairly straightforward. The AutoKitchen depends on various preparation
    mechanisms, known as *preparers*. Each preparer depends on kitchen elements to
    turn ingredients into a dish component (such as turning ground beef into a cooked
    hamburger). Kitchen elements, such as the oven or grill, are issued commands to
    cook various ingredients; they have no knowledge of the specific ingredients being
    used or the resulting dish component. [Figure 17-3](part0022_split_001.html#sandwich_maker)
    illustrates what a specific preparer might look like.
  prefs: []
  type: TYPE_NORMAL
- en: This design is extensible, which is a good thing. Adding a new sandwich type
    is simple, because I don’t have to modify any of the existing sandwich code. However,
    this is not very composable. If I wanted to take dish components and reuse them
    for new dishes (such as cooking bacon for a BLT wrap, or cooking hamburgers for
    cheeseburger soup), I would have to bring the entire `BLT Maker` or `Patty Melt
    Maker` with me. If I do that, I’d have to take a `Bread Maker` and `Database`
    with me as well. This is what I want to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sandwich Preparer](../images/00031.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-3\. Sandwich Preparer
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, I want to introduce a new soup: potato, leek, and bacon. The `Soup Preparer`
    already knows how to handle leeks and potatoes from other soups; I now want the
    `Soup Preparer` to know how to make bacon. While modifying `Soup Preparer`, I
    have a few options: introduce a dependency on a `BLT Maker`, write my own bacon-handling
    code, or find a way to reuse just the bacon-handling part separately from the
    `BLT Maker`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option has issues: if I depend on a `BLT Maker`, I need to depend
    on all of its physical dependencies, such as a `Bread Maker`. A `Soup Preparer`
    might not want all that baggage. The second option is not great either, because
    now I have duplication of bacon handling in my codebase (and once you have two,
    don’t be surprised if a third pops up eventually). The only good option is to
    find a way to split the bacon making from the `BLT Maker`.'
  prefs: []
  type: TYPE_NORMAL
- en: However, code doesn’t become reusable just because you wish it to be (it would
    be nice, though). You have to consciously design your code to be reusable. You
    need to make it small, discrete, and mostly independent from business logic to
    make it composable. And to do that, you need to separate policies from mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Policy Versus Mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Policies* are your business logic, or the code directly responsible for solving
    your business needs. The *mechanisms* are the pieces of code that provide *how*
    you will enact the policies. In the previous example, the policies of the system
    are the specific recipes. In contrast, *how* it makes those recipes are the mechanisms.'
  prefs: []
  type: TYPE_NORMAL
- en: When you focus on making code composable, you need to separate the policies
    from the mechanisms. The mechanisms are often the thing you want to reuse; it
    doesn’t help when they are linked together with a policy. It’s this reason why
    a `Soup Preparer` depending on a `BLT Maker` doesn’t make sense. You end up with
    policy depending on a completely separate and unrelated policy.
  prefs: []
  type: TYPE_NORMAL
- en: When you link two unrelated policies, you start creating a dependency that becomes
    tough to break later on. As you link more and more policies, you create spaghetti
    code. You get a tangled mess of dependencies, and extricating any one dependency
    becomes problematic. This is why you need to be cognizant of which parts of your
    codebase are policies and which are mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: A great example of policy versus mechanisms is the [`logging` module](https://oreil.ly/xNhjh)
    in Python. The policy outlines what you need logged and where to log it; the mechanisms
    are what let you set log levels, filter log messages, and format logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mechanically, any module can call logging methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `logging` module does not care what it is logging or about the format of
    the log message. The `logging` module simply provides the *how* of logging. It’s
    up to any consuming application to define the policies, or the *what*, which outline
    what needs to get logged. Separating the policy from the mechanism makes the `logging`
    module reusable. You can easily extend your codebase’s functionality without pulling
    along heaps of baggage. This is the model you should strive for in the mechanisms
    present in your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous café example, I can change the code’s architecture to split
    out the mechanisms. My goal is to design a system such that making any dish component
    is standalone and I can compose these components together to create a recipe.
    This will allow me to reuse code across systems and have flexibility in creating
    new recipes. [Figure 17-4](part0022_split_002.html#composable_arch) demonstrates
    a more composable architecture (note that I have elided some systems in the interest
    of space).
  prefs: []
  type: TYPE_NORMAL
- en: '![Composable architecture](../images/00032.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-4\. Composable architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By breaking out specific preparers into their own systems, I have both extensibility
    and composability. Not only is it easy to extend new dishes such as a new sandwich,
    but it becomes easy for new connections to be defined, such as letting the `Soup
    Preparer` reuse the bacon preparation code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your mechanisms are split out like this, you find that writing your policies
    becomes much simpler. With none of the mechanisms tied to the policy, you can
    start to write *declaratively*, or in a style where you simply make declarations
    about what to do. Take a look at the following potato, leek, and bacon soup definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By focusing solely on what a recipe is in code, I don’t have to get bogged down
    with extraneous details such as how to make bacon or cube potatoes. I composed
    the `Bacon Preparer` and `Vegetable/Cheese Preparer` together with the `Soup Preparer`
    to define the new recipe. If a new soup (or any other dish) comes in tomorrow,
    it will be just as easy to define it as a linear set of instructions. Policies
    will change much more often than your mechanisms; make them easy to add, modify,
    or delete to meet your business needs.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What parts of your codebase have been easy to reuse? Which have been difficult?
    Have you wanted to reuse the policies or the mechanisms of the code? Discuss strategies
    for making your code more composable and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Try to make your mechanisms composable if you foresee a reason for reuse. You
    will accelerate development in the future because developers will be able to truly
    reuse your code with very few strings attached. You are increasing flexibility
    and reusability, which will make the code more maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: There is a cost attached to composability, though. You reduce readability by
    spreading out functionality across more files, and you introduce more moving parts,
    which means a greater chance of a change having a negative impact. Look for opportunities
    to introduce composability, but beware making your code *too* flexible, requiring
    developers to explore entire codebases just to find out how to code simple workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Composing on a Smaller Scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AutoKitchen example showed you how to compose different modules and subsystems,
    but you can also apply composability principles at a smaller scale. You can write
    functions and algorithms to be composable, allowing you to build new code with
    ease.
  prefs: []
  type: TYPE_NORMAL
- en: Composing Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of this book focuses on OOP principles (such as SOLID and class-based
    designs), but it’s important to learn from other software paradigms as well. An
    increasingly popular paradigm is *functional programming* (FP). Where OOP’s first-class
    citizens are objects, FP focuses on *pure functions*. A pure function is a function
    whose output is solely derived from the inputs. Given a pure function and a set
    of input arguments, it will always return the same output, regardless of any global
    state or environment change.
  prefs: []
  type: TYPE_NORMAL
- en: What makes functional programming so attractive is that pure functions are much
    easier to compose than functions laden with side effects. A *side effect* is anything
    a function does that is outside of its returned values, such as logging a message,
    making a network call, or mutating variables. By removing side effects from your
    functions, you make them easier to reuse. There are no hidden dependencies or
    surprising outcomes; the entire function is dependent on the input data, and the
    only observable effect is the data that is returned.
  prefs: []
  type: TYPE_NORMAL
- en: However, when you attempt to reuse code, you must pull in all of that code’s
    physical dependencies as well (and provide logical dependencies at runtime if
    needed). With pure functions, you don’t have any physical dependencies outside
    of a function call graph. You don’t need to pull in extra objects with complicated
    setup or global variables. FP encourages developers to write short, single-purpose
    functions that are inherently composable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers get used to treating functions just like any other variable. They
    create *higher-order* functions, which are functions that take other functions
    as arguments, or functions that return other functions as a return value. The
    simplest example is something that takes a function and calls it twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn’t a very exciting example, but it opens the door for some very interesting
    ways of composing functions. In fact, there is an entire Python module dedicated
    to higher-order functions: `functools`. Most of `functools`, as well as any function
    composition you write, will be in the form of decorators.'
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Decorators* are functions that take another function and *wrap* it, or specify
    behavior that must execute before the function executes. It provides a way for
    you to compose functions together without requiring the function bodies to know
    about each other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decorators are one of the main ways of wrapping functions in Python. I can
    rewrite the `do_twice` function into a more generic `repeat` function like such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once again, I’ve separated the policy (saying hello repeatedly) from the mechanisms
    (actually repeating the function calls). That mechanism is something I can use
    throughout other codebases without any repercussions. I can apply this decorator
    to all sorts of functions in my codebase, such as making two hamburger patties
    at once for a double cheeseburger or mass-producing specific orders for a catering
    event.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, decorators can do so much more than simply repeating a function invocation.
    One of my favorite decorators comes from the [`backoff` library](https://oreil.ly/4V6Ro).
    `backoff` helps you define *retry logic*, or the actions you take to retry nondeterministic
    parts of your code. Consider the `AutoKitchen` from earlier needing to save data
    in a database. It will save orders taken, current inventory levels, and time spent
    making each dish.
  prefs: []
  type: TYPE_NORMAL
- en: 'At its simplest, the code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you work with a database (or any other I/O request), you always need
    to be prepared for errors. The database may be down, the network might be out,
    there might be a conflict with the data you are entering, or any other error might
    pop up. You can’t always rely on this code executing without errors. The business
    doesn’t want the code to give up on the first error; these operations should retry
    a set number of times or for a certain time period before giving up.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can use the `backoff.on_exception` to specify that these functions should
    be retried if they throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Through the use of decorators, I am able to modify behavior without messing
    with the function body. Each function will now back off exponentially (take longer
    between each retry) when specific exceptions are raised. Each function also has
    its own conditions for how much time to take or how many times to retry before
    giving up completely. I’ve defined the policy in this code, but left the actual
    *how* to do it, the mechanisms, abstracted away in the `backoff` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take special note of the `save_inventory_counts` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: I have two decorators defined here. In this case, I’ll retry up to five times
    on an `OperationException` or up to 60 seconds for a `requests.exceptions.HTTPError`.
    This is composability at work; I can mix’n’match completely separate `backoff`
    decorators to define the policies however I want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast this with writing the mechanisms directly into the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The amount of code needed to handle retry mechanisms ends up obscuring the actual
    intent of the function. It is difficult to ascertain what this function is doing
    at a quick glance. Furthermore, you would need to write similar retry logic into
    every function that needs to handle nondeterministic operations. It is far easier
    to compose decorators to define your business needs, and avoid tedious repetition
    throughout your code.
  prefs: []
  type: TYPE_NORMAL
- en: '`backoff` is not the only useful decorator out there. There is a bevy of composable
    decorators that you can use to simplify your code, such as `functools.lru_cache`
    for saving function results, `click.command` from the [`click` library](https://oreil.ly/FlBcj)
    for command-line applications, or `timeout_decorator.timeout` from the [`timeout_decorator`
    library](https://oreil.ly/H5FcA) for limiting execution time of functions. Don’t
    be afraid to write your own decorators either. Find areas of your code that have
    similar program structure, and look for ways to abstract the mechanisms away from
    the policies.'
  prefs: []
  type: TYPE_NORMAL
- en: Composing Algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are not the only small-scale composition you can make; you also can
    compose *algorithms*. Algorithms are a description of defined steps needed to
    solve a problem, like sorting a collection or diffing snippets of text. To make
    an algorithm composable, you again need to divorce the policies from the mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the meal recommendation for a café meal in the last section. Suppose
    the algorithm is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If I wrote this all out with `for` loops, it might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s not the prettiest code. If I didn’t list out the steps in text beforehand,
    it would take a little longer to understand the code and make sure it is bug free.
    Now, suppose a developer comes to you and tells you that not enough customers
    are picking recommendations and they want to try out a different algorithm. The
    new algorithm goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The catch is that this developer wants to A/B test these algorithms (and any
    other algorithm they come up with). With A/B testing, they want 75% of customers
    to be presented recommendations from the first algorithm and 25% of customers
    from the second. That way, they can measure how well the new algorithm works in
    relation to the old. This means your codebase has to support both algorithms (and
    be flexible to support new algorithms in the future). You don’t want to see your
    codebase littered with ugly recommendation algorithm methods.
  prefs: []
  type: TYPE_NORMAL
- en: You need to apply composability principles to the algorithm itself. Copy-pasting
    the `for` loop code snippet and tweaking it is not a viable answer. To solve this,
    you once again need to separate your policies and mechanisms. This will help you
    break down the problem and improve the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your policy this time is the actual details of the algorithm: what you’re sorting,
    how you’re filtering, and what you’re ultimately selecting. The mechanisms are
    the iteration patterns that describe how we’re shaping the data. In fact, I’ve
    already used an iteration mechanism in my code above: sorting. Instead of manually
    sorting (and forcing readers to understand what I’m doing), I used the `sorted`
    method. I indicated what I want sorted and in the key to sort by, but I really
    don’t care (nor do I expect my readers to care) about the actual sorting algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If I were to compare the two algorithms, I can break down the mechanisms into
    the following (I’ll mark policies with <angle brackets>):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The [`itertools` module](https://oreil.ly/NZCCG) is a fantastic source of composable
    algorithms, all centered on iteration. It serves as a great example of what you
    can do when you create abstract mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, and the help of the `itertools` module, I’ll take another
    crack at writing the recommendation algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to use this with an algorithm, I do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Think of how nice it would be to be able to tweak the algorithm on the fly here.
    I created a different `RecommendationPolicy` and passed it into `recommend_meal`.
    By separating the algorithm’s policy from the mechanism, I’ve provided a number
    of benefits. I’ve made the code easier to read, easier to extend, and more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composable code is reusable code. When you build small, discrete units of work,
    you’ll find that they are easy to introduce into new contexts or programs. To
    make your code composable, focus on separating your policies and your mechanisms.
    It doesn’t matter if you’re working with subsystems, algorithms, or even functions.
    You will find that your mechanisms benefit from greater reuse, and policies become
    easier to modify. Your system’s robustness will greatly improve as you identify
    composable code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’re going to learn how to apply extensibility and composability
    at an architectural level with event-based architectures. Event-based architectures
    help you decouple your code into publishers and consumers of information. They
    provide a way for you to minimize dependencies while still retaining extensibility.
  prefs: []
  type: TYPE_NORMAL
