- en: Chapter 4\. Useful Linux Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The command line and its tooling were one of the main reasons Alfredo felt
    attached to Linux servers when he started his career. One of his first jobs as
    a system administrator in a medium-sized company involved taking care of everything
    that was Linux-related. The small IT department was focused on the Windows servers
    and desktops, and they thoroughly disliked using the command line. At one point,
    the IT manager told him that he understood graphical user interfaces (GUIs), installing
    utilities, and tooling in general to solve problems: *“I am not a coder, if it
    doesn’t exist as a GUI, I can’t use it,”* he said.'
  prefs: []
  type: TYPE_NORMAL
- en: Alfredo was hired as a contractor to help out with the few Linux servers the
    company had. At the time, [Subversion (SVN) was all the rage for version control](https://subversion.apache.org),
    and the developers depended on this single SVN server to push their work. Instead
    of using the centralized identity server, provided by two *domain controllers*,
    it used a text-based authentication system that mapped a user to a hash representing
    the password. This meant that usernames didn’t necessarily map to those in the
    domain controller and that passwords could be anything. Often, a developer would
    ask to reset the password, and someone had to edit this text file with the hash.
    A project manager asked Alfredo to integrate the SVN authentication with the domain
    controller (Microsoft’s Active Directory). The first question he asked was why
    hadn’t the IT department done this already? *“They say it is not possible, but
    Alfredo, this is a lie, SVN can integrate with Active Directory.”*
  prefs: []
  type: TYPE_NORMAL
- en: 'He had never used an authentication service like Active Directory and barely
    understood SVN, but he was determined to make this work. Alfredo set out to read
    all about SVN and Active Directory, tinkered his way around a virtual machine
    with an SVN server running, and tried to get this authentication to work. It took
    about two weeks to read up on all the pieces involved and to get it to work. He
    succeeded in the end and was able to get this system into production. This felt
    incredibly powerful; he had acquired unique knowledge and was now ready to be
    fully in charge of this system. The IT manager, as well as the rest of the department,
    were ecstatic. Alfredo tried to share this newly acquired knowledge with others
    and was always met with an excuse: *“no time,”* *“too busy,”* *“other priorities,”*
    and *“perhaps some other time—maybe next week.”*'
  prefs: []
  type: TYPE_NORMAL
- en: 'An apt description for technologists is: *knowledge workers*. Your curiosity
    and a never-ending pursuit of knowledge will continue to make you, and the environments
    you work on, much better. Don’t ever let a coworker (or a whole IT department,
    as in Alfredo’s case) be a deterrent for improving systems. If there is an opportunity
    to learn something new, jump on it! The worst that can happen is that you have
    acquired knowledge that perhaps won’t be used often, but on the other hand, might
    change your professional career.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux does have desktop environments, but its real power comes from understanding
    and using the command line, and ultimately, by extending it. When there are no
    pre-made tools to solve a problem, seasoned DevOps people will craft their own.
    This notion of being able to come up with solutions by putting together the core
    pieces is incredibly powerful, and is what ultimately happened at that job where
    it felt productive to complete tasks without having to install off-the-shelf software
    to fix things.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will go through some common patterns in the shell and will include
    some useful Python commands that should enhance the ability to interact with a
    machine. We find that creating aliases and *one-liners* is the most fun one can
    have at work, and sometimes they are so useful that they end up as plug-ins or
    standalone pieces of software.
  prefs: []
  type: TYPE_NORMAL
- en: Disk Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several different utilities that you can use to get information about
    devices in a system. A lot of them have feature overlap, and some have an interactive
    session to deal with disk operations, such as `fdisk` and `parted`.
  prefs: []
  type: TYPE_NORMAL
- en: It is *crucial* to have a good grasp on disk utilities, not only to retrieve
    information and manipulate partitions, but also to accurately measure performance.
    Performance, in particular, is one of the tough things to accomplish correctly.
    The best answer to the question *How do I measure the performance of a device?*
    is *It depends*, because it is difficult to do for the specific metric one is
    looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we had to work in an isolated environment with a server that doesn’t have
    access to the internet or that we don’t control and therefore can’t install packages,
    we would have to say that the `dd` tool (which should be readily available on
    all major Linux distributions) would help provide some answers. If at all possible,
    pair it with `iostat` to isolate the command that hammers the device versus the
    one that gets the report.
  prefs: []
  type: TYPE_NORMAL
- en: As a seasoned performance engineer once said, it depends on what is measured
    and how. For example `dd` is single threaded and has limitations, such as being
    unable to do multiple random reads and writes; it also measures throughput and
    not input/output operations per second (IOPS). What are you measuring? Throughput
    or IOPS?
  prefs: []
  type: TYPE_NORMAL
- en: Caution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A word of warning on these examples. They can destroy your system, don’t follow
    them blindly, and make sure to use devices that can get erased.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple one-liner will run `dd` to get some numbers of a brand-new device
    (*/dev/sdc* in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It writes 10 records of 100 megabytes at a rate of 1 GB/s. This is throughput.
    An easy way to get IOPS with `dd` is to use `iostat`. In this example, `iostat`
    runs only on the device getting hammered with `dd`, with the `-d` flag only to
    give the device information, and with an interval of one second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iostat` output will repeat itself for every second until a `Ctrl-C` is
    issued to cancel the operation. The second column in the output is `tps`, which
    stands for transactions per second and is the same as IOPS. A nicer way to visualize
    the output, which avoids the clutter that a repeating command produces, is to
    clear the terminal on each run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Accurate tests with fio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `dd` and `iostat` aren’t sufficient, the most commonly used tool for performance
    testing is `fio`. It can help clarify the performance behavior of a device in
    a read-heavy or write-heavy environment (and even adjust the percentages of reads
    versus writes).
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from `fio` is quite verbose. The example below trims it to emphasize
    the IOPS found on both read and write operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The flags used in the example name the *job* `sdc-performance`, point to the
    */dev/sdc* device directly (will require superuser permissions), use the native
    Linux asynchronous I/O library, set the `iodepth` to `1` (number of sequential
    I/O requests to be sent at a time), and define random read and write operations
    of 32 kilobytes for the buffer size using buffered I/O (can be set to 1 to use
    unbuffered I/O) on a 64-megabyte file. Quite the lengthy command here!
  prefs: []
  type: TYPE_NORMAL
- en: The `fio` tool has a tremendous number of additional options that can help with
    most any case where accurate IOPS measurements are needed. For example, it can
    span the test across many devices at once, do some *I/O warm up*, and even set
    I/O thresholds for the test if a defined limit shouldn’t be surpassed. Finally,
    the many options in the command line can be configured with INI-style files so
    that the execution of jobs can be scripted nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Partitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We tend to default to `fdisk` with its interactive session to create partitions,
    but in some cases, `fdisk` doesn’t work well, such as with large partitions (two
    terabytes or larger). In those cases, your fallback should be to use `parted`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick interactive session shows how to create a primary partition with `fdisk`,
    with the default start value and four gibibytes of size. At the end the `w` key
    is sent to *write* the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`parted` accomplishes the same, but with a different interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, you quit with the `q` key. For programmatic creation of partitions
    on the command line without any interactive prompts, you accomplish the same result
    with a couple of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving Specific Device Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes when specific information for a device is needed, either `lsblk`
    or `blkid` are well suited. `fdisk` doesn’t like to work without superuser permissions.
    Here `fdisk` lists the information about the */dev/sda* device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`blkid` is a bit similar in that it wants superuser permissions as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`lsblk` allows to get information without higher permissions, and provides
    the same informational output regardless:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This command, which uses the `-p` flag for low-level device probing, is *very
    thorough* and should give you good enough information for a device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`lsblk` has some default properties to look for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But it also allows you to set specific flags to request a particular property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To access a property in this way makes it easy to script and even consume from
    the Python side of things.
  prefs: []
  type: TYPE_NORMAL
- en: Network Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network tooling keeps improving as more and more servers need to be interconnected.
    A lot of the utilities in this section cover useful one-liners like Secure Shell
    (SSH) tunneling, but some others go into the details of testing network performance,
    such as using the Apache Bench tool.
  prefs: []
  type: TYPE_NORMAL
- en: SSH Tunneling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever tried to reach an HTTP service that runs on a remote server that
    is not accessible except via SSH? This situation occurs when the HTTP service
    is enabled but not needed publicly. The last time we saw this happen was when
    a production instance of [RabbitMQ](https://www.rabbitmq.com) had the management
    plug-in enabled, which starts an HTTP service on port 15672\. The service isn’t
    exposed and with good reason; there is no need to have it publicly available since
    it is rarely used, and besides, one can use SSH’s tunneling capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works by creating an SSH connection with the remote server and then forwarding
    the remote port (15672, in my case) to a local port on the originating machine.
    The remote machine has a custom SSH port, which complicates the command slightly.
    This is is how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are three flags, three numbers, and two addresses. Let’s dissect the command
    to make what is going on here much clearer. The `-L` flag is the one that signals
    that we want forwarding enabled and a local port (9998) to bind to a remote port
    (RabbitMQ’s default of 15672). Next, the `-p` flag indicates that the custom SSH
    port of the remote server is 2223, and then the username and address are specified.
    Lastly, the `-N` means that it shouldn’t get us to a remote shell and do the forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: 'When executed correctly, the command will appear to hang, but it allows you
    to go into [*http://localhost:9998/*](http://localhost:9998/) and see the login
    page for the remote RabbitMQ instance. A useful flag to know when tunneling is
    `-f`: it will send the process into the background, which is helpful if this connection
    isn’t temporary, leaving the terminal ready and clean to do more work.'
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking HTTP with Apache Benchmark (ab)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We *really* love to hammer servers we work with to ensure they handle load correctly,
    especially before they get promoted to production. Sometimes we even try to trigger
    some odd race condition that may happen under heavy load. The Apache Benchmark
    tool (`ab` in the command line) is one of those tiny tools that can get you going
    quickly with just a few flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will create 100 requests at a time, for a total of 10,000 requests,
    to a local instance where Nginx is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'That is pretty brutal to handle in a system, but this is a local server, and
    the requests are just an HTTP `GET`. The detailed output from `ab` is very comprehensive
    and looks like this (trimmed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This type of information and how it is presented is tremendous. At a glance,
    you can quickly tell if a production server drops connections (in the `Failed
    requests` field) and what the averages are. A `GET` request is used, but `ab`
    allows you to use other HTTP verbs, such as `POST`, and even do a `HEAD` request.
    You need to exercise caution with this type of tool because it can easily overload
    a server. Below are more realistic numbers from an HTTP service in production
    (trimmed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now the numbers look different, it hits a service with SSL enabled, and `ab`
    lists what the protocols are. At 83 requests per second, we think it could do
    better, but this is an API server that produces JSON, and it typically doesn’t
    get much load at once, as was just generated.
  prefs: []
  type: TYPE_NORMAL
- en: Load Testing with molotov
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Molotov](https://molotov.readthedocs.io) project is an interesting project
    geared towards load testing. Some of its features are similar to those of Apache
    Benchmark, but being a Python project, it provides a way to write scenarios with
    Python and the `asyncio` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the simplest example for `molotov` looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file as *load_test.py*, create a small Flask application that handles
    both `POST` and `GET` requests at its main URL, and save it as *small.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the Flask application with `FLASK_APP=small.py flask run`, and then run
    `molotov` with the *load_test.py* file created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'One hundred requests on a single worker ran against the local Flask instance.
    The tool really shines when the load testing is extended to do more per request.
    It has concepts similar to unit testing, such as setup, teardown, and even code,
    that can react to certain events. Since the small Flask application can handle
    a `POST` that redirects to a Google search, add another scenario to the *load_test*.py_
    file. This time change the weight so that 100% of the requests do a `POST`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this new scenario for a single request to show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A single request (with `-r 1`) was enough to make this fail. The assertion
    needs to be updated to check for a `302` instead of a `301`. Once that status
    is updated, change the weight of the `POST` scenario to `80` so that other requests
    (with a `GET`) are sent to the Flask application. This is how the file looks in
    the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run *load_test.py* for 10 requests to distribute the requests, two for a `GET`
    and the rest with a `POST`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `molotov` is easily extensible with pure Python and can be modified
    to suit other, more complex, needs. These examples scratch the surface of what
    the tool can do.
  prefs: []
  type: TYPE_NORMAL
- en: CPU Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two important CPU utilities: `top` and `htop`. You can find `top`
    preinstalled in most Linux distributions today, but if you are able to install
    packages, `htop` is fantastic to work with and we prefer its customizable interface
    over `top`. There are a few other tools out there that provide CPU visualization
    and perhaps even monitoring, but none are as complete and as widely available
    as both `top` and `htop`. For example, it is entirely possible to get CPU utilization
    from the `ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `ps` command takes some custom fields. The first one is `pcpu`, which gives
    the CPU usage, followed by the process ID, the user, and finally, the command.
    That *pipes* into a sorted reverse because by default it goes from less CPU usage
    to more, and you need to have the most CPU usage at the top. Finally, since the
    command displays this information for every single process, it filters the top
    10 results with the `head` command.
  prefs: []
  type: TYPE_NORMAL
- en: But the command is quite a mouthful, is a challenge to remember, and is not
    updated on the fly. Even if aliased, you are better off with `top` or `htop`.
    As you will see, both have extensive features.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing Processes with htop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `htop` tool is just like `top` (an interactive process viewer) but is fully
    cross-platform (works on OS X, FreeBSD, OpenBSD, and Linux), offers support for
    better visualizations (see [Figure 4-1](#Figure-4-1)), and is a pleasure to use.
    Visit [*https://hisham.hm/htop*](https://hisham.hm/htop) for a screenshot of `htop`
    running on a server. One of the main caveats of `htop` is that all the shortcuts
    you may know about `top` are not compatible, so you will have to rewire your brain
    to understand and use them for `htop`.
  prefs: []
  type: TYPE_NORMAL
- en: '![pydo 0401](assets/pydo_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. htop running on a server
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Right away, the look and feel of the information displayed in [Figure 4-1](#Figure-4-1)
    is different. The CPU, Memory, and Swap are nicely shown at the top left, and
    they move as the system changes. The arrow keys scroll up or down and even left
    to right, providing a view of the whole command of the process.
  prefs: []
  type: TYPE_NORMAL
- en: Want to kill a process? Move to it with the arrow keys, or hit `/` to incrementally
    search (and filter) the process, and then press `k`. A new menu will show all
    the signals that can be sent to the process—for example, `SIGTERM` instead of
    `SIGKILL`. It is possible to *“tag”* more than one process to kill. Press the
    space bar to tag the selected process, highlighting it with a different color.
    Made a mistake and want to un-tag? Press the space bar again. This all feels very
    intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with `htop` is that it has lots of actions mapped to `F` keys, and
    you may not have any. For example, `F1` is for help. The alternative is to use
    the equivalent mappings when possible. To access the help menu, use the `h` key;
    to access the setup, use `Shift s` instead of F2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `t` (again, how intuitive!) enables (toggles) the process list as a tree.
    Probably the most used functionality is sorting. Press `>` and a menu appears
    to select what type of sorting you want: PID, user, memory, priority, and CPU
    percentage are just a few. There are also shortcuts to sort directly (skips the
    menu selection) by memory (`Shift i`), CPU (`Shift p`), and Time (`Shift t`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, two incredible features: you can run `strace` or `lsof` directly in
    the selected process as long as these are installed and available to the user.
    If the processes require superuser permissions, `htop` will report that, and it
    will require `sudo` to run as a privileged user. To run `strace` on a selected
    process, use the `s` key; for `lsof`, use the `l` key.'
  prefs: []
  type: TYPE_NORMAL
- en: If either `strace` or `lsof` is used, the search and filter options are available
    with the `/` character. What an incredibly useful tool! Hopefully, one day other
    non-`F` key mappings will be possible, even though most work can be done with
    the alternative mappings.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If `htop` is customized via its interactive session, the changes get persisted
    in a configuration file that is usually located at *~/.config/htop/htoprc*. If
    you define configurations there and later change them in the session, then the
    session will overwrite whatever was defined previously in the *htoprc* file.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Bash and ZSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It all starts with customization. Both Bash and ZSH will usually come with a
    *“dotfile,”* a file prefixed with a dot that holds configuration but by default
    is hidden when directory contents are listed, and lives in the home directory
    of the user. For Bash this is *.bashrc*, and for ZSH it is *.zshrc*. Both shells
    support several layers of places that will get loaded in a predefined order, which
    ends in the configuration file for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'When ZSH is installed, a `.zshrc` is usually not created. This is how a minimal
    version of it looks in a CentOS distro (all comments removed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Bash has a couple of additional items in it but nothing surprising. You will
    no doubt get to the point of being extremely annoyed at some behavior or thing
    you saw in some other server that you want to replicate. We can’t live without
    colors in the terminal, so whatever the shell, it has to have color enabled. Before
    you know it, you are deep into configurations and want to add a bunch of useful
    aliases and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Soon after, the text editor configurations come in, and it all feels unmanageable
    on different machines or when new ones are added and all those useful aliases
    are not set up, and it is *unbelievable*, but no one has enabled color support
    anywhere. Everyone has a way to solve this problem in an entirely nontransferable,
    ad hoc way: Alfredo uses a *Makefile* at some point, and his coworkers use either
    nothing at all or a Bash script. A new project called [Dotdrop](https://deadc0de.re/dotdrop)
    has lots of features to get all those dotfiles in working order, with features
    such as copying, symlinking, and keeping separate *profiles* for development and
    other machines—pretty useful when you move from one machine to another.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use Dotdrop for a Python project, and although you can install it via
    the regular `virtualenv` and `pip` tooling, it is recommended to include it as
    a submodule to your repository of dotfiles. If you haven’t done so already, it
    is very convenient to keep all your dotfiles in version control to keep track
    of changes. Alfredo’s [dotfiles](https://oreil.ly/LV1AH) are publicly available,
    and he tries to keep them as up-to-date as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Independent of what is used, keeping track of changes via version control, and
    making sure everything is always updated, is a good strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Python Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can customize the Python shell with helpers and import useful modules in
    a Python file that then has to be exported as an environment variable. I keep
    my configuration files in a repository called *dotfiles*, so in my shell configuration
    file (*$HOME/.zshrc* for me) I define the following export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To try this out, create a new Python file called *pythonstartup.py* (although
    it can be named anything) that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open up a new Python shell and specify the newly created *pythonstartup.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `helpers` object is immediately available. Since we added the `uuid4` property,
    we can access it as `helpers.uuid4()`. As you may be able to tell, all the imports
    and definitions are going to be available in the Python shell. This is a convenient
    way to extend behavior that can be useful with the default shell.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Globbing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recursive globbing is enabled in ZSH by default, but Bash (versions 4 and higher)
    requires `shopt` to set it. Recursive globbing is a cool setting that allows you
    to traverse a path with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'That snippet would go through each file and directory recursively and list
    every single file that ends in `.py`. This is how to enable it in Bash 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Searching and Replacing with Confirmation Prompts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vim has a nice feature in its search and replace engine that prompts for confirmation
    to perform the replacement or skip it. This is particularly useful when you can’t
    nail the exact regular expression that matches what you need but want to ignore
    some other close matches. We know regular expressions, but we’ve tried to avoid
    being an expert at them because it would be very tempting to use them for everything.
    Most of the time, you will want to perform a simple search and replace and not
    bang your head against the wall to come up with the perfect regex.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `c` flag needs to be appended at the end of the command to enable the confirmation
    prompt in Vim:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The above translates to: search for *original term* in the whole file and replace
    it with *replacement term*, but at each instance, prompt so that one can decide
    to change it or skip it. If a match is found, Vim will display a message like
    this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole confirmation workflow might seem silly but allows you to relax the
    constraints on the regular expression, or even not use one at all for a simpler
    match and replace. A quick example of this is a recent API change in a production
    tool that changed an object’s attribute for a callable. The code returned `True`
    or `False` to inform if superuser permissions were required or not. The actual
    replacement in a single file would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The added difficulty here is that `needs_root` was also splattered in comments
    and doc strings, so it wasn’t easy to come up with a regular expression that would
    allow skipping the replacement when inside a comment block or in part of a doc
    string. With the `c` flag, you can just hit `Y` or `N` and move on. No regular
    expression needed at all!
  prefs: []
  type: TYPE_NORMAL
- en: 'With recursive globbing enabled (`shopt -s globstar` in Bash 4), this powerful
    one-liner will go through all the matching files, perform the search, and replace
    the item according to the prompts if the pattern is found inside the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot to unpack here, but the above example will traverse recursively
    to find all the files ending in `.py`, load them into Vim, and perform the search
    and replace with confirmation only if there is a match. If there isn’t a match,
    it skips the file. The `set eventignore-=Syntax` is used because otherwise Vim
    will not load the syntax files when executing it this way; we like syntax highlighting
    and expect it to work when this type of replacement is used. The next part after
    the `|` character is the replacement with the confirmation flag and the `e` flag,
    which helps ignore any errors that would prevent a smooth workflow from being
    interrupted with errors.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are numerous other flags and variations that you can use to enhance the
    replacement command. To learn more about the special flags with a search and replace
    in Vim, take a look at `:help substitute`, specifically at the `s_flags` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the complicated one-liner easier to remember with a function that takes
    two parameters (search and replace terms) and the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Name it `vsed`, as a mix of Vim and the `sed` tool, so that it is easier to
    remember. In the terminal, it looks straightforward and allows you to make changes
    to multiple files easily and with confidence, since you can accept or deny each
    replacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Removing Temporary Python Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python’s `pyc`, and more recently its `*pycache*` directories, can sometimes
    get in the way. This simple one-liner aliased to `pyclean` uses the `find` command
    to remove `pyc`, then goes on to find `*pycache*` directories and recursively
    deletes them with the tool’s built-in delete flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Listing and Filtering Processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Process listing to view what runs in a machine and then filtering to check on
    a specific application is one of the things that you’ll do several times a day
    at the very least. It is not at all surprising that everyone has a variation on
    either the flags or the order of the flags for the `ps` tool (we usually use `aux`).
    It is something you end up doing so many times a day that the order and the flags
    get ingrained in your brain and it is hard to do it any other way.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a good starting point to list the processes and some information, such as
    process IDs, try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This command lists all processes with the *BSD-style* flags (flags that aren’t
    prefixed with a dash `-`) regardless or whether they have a terminal (tty) or
    not, and includes the user that owns the process. Finally, it gives more space
    to the output (`w` flag).
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the times, you are filtering with `grep` to get information about a
    specific process. For example, if you want to check if Nginx is running, you pipe
    the output into grep and pass `nginx` as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'That is great, but it is annoying to have the `grep` command included. This
    is particularly maddening when there are no results except for the `grep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'No `apache` process is found, but the visuals may mislead you to think it is,
    and double-checking that this is indeed just `grep` being included because of
    the argument can get tiring pretty quickly. A way to solve this is to add another
    pipe to `grep` to filter itself from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To have to always remember to add that extra `grep` can be equally annoying,
    so an alias comes to the rescue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The new alias will filter the first `grep` line out and leave only the interesting
    output (if any):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Unix Timestamp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get the widely used Unix timestamp in Python is very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'But in the shell, it can be a bit more involved. This alias works in OS X,
    which has the BSD-flavored version of the `date` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'OS X can be awkward with its tooling, and it may be confusing to never remember
    why a given utility (like `date` in this case) behaves completely differently.
    In the Linux version of `date`, a far simpler approach works the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Mixing Python with Bash and ZSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It never occurred to us to try and mix Python with a shell, like ZSH or Bash.
    It feels like going against common sense, but there are a few good cases here
    that you can use almost daily. In general, our rule of thumb is that 10 lines
    of shell script is the limit; anything beyond that is a bug waiting to make you
    waste time because the error reporting isn’t there to help you out.
  prefs: []
  type: TYPE_NORMAL
- en: Random Password Generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The amount of accounts and passwords that you need on a week-to-week basis
    is only going to keep increasing, even for throwaway accounts that you can use
    Python for to generate robust passwords. Create a useful, randomized password
    generator that sends the contents to the clipboard to easily paste it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Porting that to a shell function that can take an arbitrary length (useful
    when a site restricts length to a certain number) looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now the `mpass` function defaults to generate 12-character passwords by slicing
    the output, and then sends the contents of the generated string to `xclip` so
    that it gets copied to the clipboard for easy pasting.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`xclip` is not installed by default in many distros, so you need to ensure
    that it is installed for the function to work properly. If `xclip` is not available,
    any other utility that can help manage the system clipboard will work fine.'
  prefs: []
  type: TYPE_NORMAL
- en: Does My Module Exist?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Find out if a module exists, and if it does, get the path to that module. This
    is useful when reused for other functions that can take that output for processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Changing Directories to a Module’s Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*“Where does this module live?”* is often asked when debugging libraries and
    dependencies, or even when poking around at the source of modules. Python’s way
    to install and distribute modules isn’t straightforward, and in different Linux
    distributions the paths are entirely different and have separate conventions.
    You can find out the path of a module if you import it and then use `print`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'It isn’t convenient if all you want is the path so that you can change directories
    to it and look at the module. This function will try to import the module as an
    argument, print it out (this is shell, so `return` doesn’t do anything for us),
    and then change directory to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s make it more robust, in case the package name has a dash and the module
    uses an underscore, by adding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If the input has a dash, the little function can solve this on the fly and
    get us to where we need to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Converting a CSV File to JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python comes with a few built-ins that are surprising if you’ve never dealt
    with them. It can handle JSON natively, as well as CSV files. It only takes a
    couple of lines to load a CSV file and then *“dump”* its contents as JSON. Use
    the following CSV file (*addresses.csv*) to see the contents when JSON is dumped
    in the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Port the interactive session to a function that can do this on the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Use it in the shell, which is much simpler than remembering all the calls and
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Python One-Liners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, writing a long, single line of Python is not considered good practice.
    The [PEP 8](https://oreil.ly/3P_qQ) guide even frowns on compounding statements
    with a semicolon (it is possible to use semicolons in Python!). But quick debug
    statements and calls to a debugger are fine. They are, after all, temporary.
  prefs: []
  type: TYPE_NORMAL
- en: Debuggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A few programmers out there swear by the `print()` statement as the best strategy
    to debug running code. In some cases, that might work fine, but most of the time
    we use the Python debugger (with the `pdb` module) or `ipdb`, which uses IPython
    as a backend. By creating a break point, you can poke around at variables and
    go up and down the stack. These single-line statements are important enough that
    you should memorize them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set a break point and drop to the Python debugger (`pdb`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a break point and drop to a Python debugger based on IPython (`ipdb`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Although not technically a debugger (you can’t move forward or backward in
    the stack), this one-liner allows you to start an IPython session when the execution
    gets to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Everyone seems to have a favorite debugger tool. We find `pdb` to be too rough
    (no auto-completion, no syntax highlighting), so we tend to like `ipdb` better.
    Don’t be surprised if someone comes along with a different debugger! In the end,
    it’s useful to know how `pdb` works, as it’s the base needed to be proficient
    regardless of the debugger. In systems you can’t control, use `pdb` directly because
    you can’t install dependencies; you may not like it, but you can still manage
    your way around.
  prefs: []
  type: TYPE_NORMAL
- en: How Fast Is this Snippet?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has a module to run a piece of code several times over and get some performance
    metrics from it. Lots of users like to ask if there are efficient ways to handle
    a loop or update a dictionary, and there are lots of knowledgeable people that
    love the `timeit` module to prove performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you have probably seen, we are fans of [IPython](https://ipython.org), and
    its interactive shell comes with a *“magic”* special function for the `timeit`
    module. “Magic” functions are prefixed with the `%` character and perform a distinct
    operation within the shell. An all-time favorite regarding performance is whether
    list comprehension is faster than just appending to a list. The two examples below
    use the `timeit` module to find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the standard Python shell (or interpreter), you import the module and access
    it directly. The invocation looks a bit different in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is a bit odd, but that’s because it’s meant to be processed by another
    module or library, and is not meant for human readability. The averages favor
    the list comprehension. This is how it looks in IPython:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Because IPython exposes `timeit` as a special command (notice the prefix with
    `%`), the output is human readable and more helpful to view, and it doesn’t require
    the weird import, as in the standard Python shell.
  prefs: []
  type: TYPE_NORMAL
- en: strace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to tell how a program is interacting with the operating system becomes
    crucial when applications aren’t logging the interesting parts or not logging
    at all. Output from `strace` can be rough, but with some understanding of the
    basics, it becomes easier to understand what is going on with a problematic application.
    One time, Alfredo was trying to understand why permission to access a file was
    being denied. This file was inside of a symlink that seemed to have all the right
    permissions. What was going on? It was difficult to tell by just looking at logs,
    since those weren’t particularly useful in displaying permissions as they tried
    to access files.
  prefs: []
  type: TYPE_NORMAL
- en: '`strace` included these two lines in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The program was setting ownership on the parent directory, which happened to
    be a link, and *block.db*, which in this case was also a link to a block device.
    The block device itself had the right permissions, so what was the problem? It
    turns out that the link in the directory had a *sticky bit* that prevented other
    links from changing the path—including the block device. The `chown` tool has
    a special flag (`-h` or `--no-dereference`) to indicate that the change in ownership
    should also affect the links.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of debugging would be difficult (if not impossible) without something
    like `strace`. To try it out, create a file called *follow.py* with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'It imports the `subprocess` module to do a system call. It will output the
    contents of the system call to `ls`. Instead of a direct call with Python, prefix
    the command with `strace` to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot of output should’ve filled the terminal, and probably most of it will
    look very foreign. Force yourself to go through each line, regardless of whether
    you understand what is going on. Some lines will be easier to tell apart than
    others. There are a lot of `read` and `fstat` calls; you’ll see actual system
    calls and what the process is doing at each step. There are also `open` and `close`
    operations on some files, and there is a particular section that should show up
    with a few `stat` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This system is pretty old, and `python` in the output means `python2.7`, so
    it pokes around the filesystem to try and find the right executable. It goes through
    a few until it reaches */usr/bin/python*, which is a link that points to */usr/bin/python2*,
    which in turn is another link that sends the process to */usr/bin/python2.7*.
    It then calls `stat` on */usr/bin/Modules/Setup*, which we’ve never heard of as
    Python developers, only to continue to the `os` module.
  prefs: []
  type: TYPE_NORMAL
- en: It continues to *pybuilddir.txt* and *lib-dynload*. What a trip. Without `strace`
    we would’ve probably tried to read the code that executes this to try and figure
    out where it goes next. But `strace` makes this tremendously easier, including
    all the interesting steps along the way, with useful information for each call.
  prefs: []
  type: TYPE_NORMAL
- en: The tool has many flags that are worth looking into; for example, it can *attach
    itself to a PID*. If you know the PID of a process, you can tell `strace` to produce
    output on what exactly is going on with it.
  prefs: []
  type: TYPE_NORMAL
- en: One of those useful flags is `-f`; it will follow child processes as they are
    created by the initial program. In the example Python file, a call to `subprocess`
    is made, and it calls out to `ls`; if the command to `strace` is modified to use
    `-f`, the output becomes richer, with details about that call.
  prefs: []
  type: TYPE_NORMAL
- en: 'When *follow.py* runs in the home directory, there are a quite a few differences
    with the `-f` flag. You can see calls to `lstat` and `readlink` for the dotfiles
    (some of which are symlinked):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Not only do the calls to these files show, but the PID is prefixed in the output,
    which helps identify which (child) process is doing what. A call to `strace` without
    the `-f` flag would not show a PID, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to analyze the output in detail, it can be helpful to save it to a
    file. This is possible with the `-o` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Define what IOPS is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain what the difference is between throughput and IOPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name a limitation with `fdisk` for creating partitions that `parted` doesn’t
    have.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name three tools that can provide disk information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What can an SSH tunnel do? When is it useful?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case Study Question
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a load test using the `molotov` tool that tests a `JSON` response from
    a server with an HTTP status of `200`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
