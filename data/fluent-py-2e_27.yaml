- en: Chapter 22\. Dynamic Attributes and Properties
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第22章。动态属性和属性
- en: The crucial importance of properties is that their existence makes it perfectly
    safe and indeed advisable for you to expose public data attributes as part of
    your class’s public interface.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 属性的关键重要性在于，它们的存在使得将公共数据属性作为类的公共接口的一部分完全安全且确实可取。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Martelli, Ravenscroft, and Holden, “Why properties are important”^([1](ch22.html#idm46582379330800))
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Martelli、Ravenscroft和Holden，“为什么属性很重要”^([1](ch22.html#idm46582379330800))
- en: 'Data attributes and methods are collectively known as *attributes* in Python.
    A method is an attribute that is *callable*. *Dynamic attributes* present the
    same interface as data attributes—i.e., `obj.attr`—but are computed on demand.
    This follows Bertrand Meyer’s *Uniform Access Principle*:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，数据属性和方法统称为*属性*。方法是*可调用*的属性。*动态属性*呈现与数据属性相同的接口——即，`obj.attr`——但是根据需要计算。这遵循Bertrand
    Meyer的*统一访问原则*：
- en: All services offered by a module should be available through a uniform notation,
    which does not betray whether they are implemented through storage or through
    computation.^([2](ch22.html#idm46582379323104))
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块提供的所有服务都应通过统一的表示法可用，这种表示法不会泄露它们是通过存储还是计算实现的。^([2](ch22.html#idm46582379323104))
- en: 'There are several ways to implement dynamic attributes in Python. This chapter
    covers the simplest ways: the `@property` decorator and the `__getattr__` special
    method.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中有几种实现动态属性的方法。本章涵盖了最简单的方法：`@property`装饰器和`__getattr__`特殊方法。
- en: 'A user-defined class implementing `__getattr__` can implement a variation of
    dynamic attributes that I call *virtual attributes*: attributes that are not explicitly
    declared anywhere in the source code of the class, and are not present in the
    instance `__dict__`, but may be retrieved elsewhere or computed on the fly whenever
    a user tries to read a nonexistent attribute like `obj.no_such_attr`.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`__getattr__`的用户定义类可以实现我称之为*虚拟属性*的动态属性变体：这些属性在类的源代码中没有明确声明，也不在实例`__dict__`中存在，但可能在用户尝试读取不存在的属性时在其他地方检索或在需要时动态计算，例如`obj.no_such_attr`。
- en: Coding dynamic and virtual attributes is the kind of metaprogramming that framework
    authors do. However, in Python the basic techniques are straightforward, so we
    can use them in everyday data wrangling tasks. That’s how we’ll start this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 编写动态和虚拟属性是框架作者所做的元编程。然而，在Python中，基本技术很简单，因此我们可以在日常数据整理任务中使用它们。这就是我们将在本章开始的方式。
- en: What’s New in This Chapter
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的新内容
- en: Most of the updates to this chapter were motivated by a discussion of `@functools.cached_property`
    (introduced in Python 3.8), as well as the combined use of `@property` with `@functools.cache`
    (new in 3.9). This affected the code for the `Record` and `Event` classes that
    appear in [“Computed Properties”](#computed_props_sec). I also added a refactoring
    to leverage the [PEP 412—Key-Sharing Dictionary](https://fpy.li/pep412) optimization.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章大部分更新的动机来自对`@functools.cached_property`（Python 3.8中引入）的讨论，以及`@property`与`@functools.cache`（3.9中新引入）的联合使用。这影响了出现在[“计算属性”](#computed_props_sec)中的`Record`和`Event`类的代码。我还添加了一项重构以利用[PEP
    412—共享键字典](https://fpy.li/pep412)优化。
- en: To highlight more relevant features while keeping the examples readable, I removed
    some nonessential code—merging the old `DbRecord` class into `Record`, replacing
    `shelve.Shelve` with a `dict`, and deleting the logic to download the OSCON dataset—which
    the examples now read from a local file included in the [*Fluent Python* code
    repository](https://fpy.li/code).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出更相关的特性，同时保持示例的可读性，我删除了一些非必要的代码——将旧的`DbRecord`类合并到`Record`中，用`dict`替换`shelve.Shelve`，并删除了下载OSCON数据集的逻辑——示例现在从[*Fluent
    Python*代码库](https://fpy.li/code)中的本地文件中读取。
- en: Data Wrangling with Dynamic Attributes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态属性进行数据整理
- en: In the next few examples, we’ll leverage dynamic attributes to work with a JSON
    dataset published by O’Reilly for the OSCON 2014 conference. [Example 22-1](#ex_osconfeed_json)
    shows four records from that dataset.^([3](ch22.html#idm46582379300144))
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个示例中，我们将利用动态属性处理O’Reilly为OSCON 2014会议发布的JSON数据集。[示例 22-1](#ex_osconfeed_json)展示了该数据集中的四条记录。^([3](ch22.html#idm46582379300144))
- en: Example 22-1\. Sample records from osconfeed.json; some field contents abbreviated
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例22-1。来自osconfeed.json的示例记录；一些字段内容已缩写
- en: '[PRE0][PRE1][PRE2][PRE3][PRE4]``'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0][PRE1][PRE2][PRE3][PRE4]``'
- en: '[PRE5]We will implement an `Event` class with `venue` and `speakers` properties
    to return the linked data automatically—in other words, “dereferencing” the serial
    number. Given an `Event` instance, [Example 22-7](#ex22-7-added-uuid) shows the
    desired behavior.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]我们将实现一个具有`venue`和`speakers`属性的`Event`类，以便自动返回链接数据，换句话说，“解引用”序列号。给定一个`Event`实例，[示例 22-7](#ex22-7-added-uuid)展示了期望的行为。'
- en: Example 22-7\. Reading `venue` and `speakers` returns `Record` objects
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例22-7。读取`venue`和`speakers`返回`Record`对象
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO6-1)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO6-1)'
- en: Given an `Event` instance…
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个`Event`实例…
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO6-2)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO6-2)'
- en: …reading `event.venue` returns a `Record` object instead of a serial number.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: …读取`event.venue`返回一个`Record`对象，而不是一个序列号。
- en: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO6-3)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO6-3)'
- en: Now it’s easy to get the name of the `venue`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易获取`venue`的名称。
- en: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO6-4)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO6-4)'
- en: The `event.speakers` property returns a list of `Record` instances.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`event.speakers`属性返回一个`Record`实例列表。'
- en: As usual, we will build the code step-by-step, starting with the `Record` class
    and a function to read the JSON data and return a `dict` with `Record` instances.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将逐步构建代码，从`Record`类和一个函数开始，该函数读取JSON数据并返回一个带有`Record`实例的`dict`。
- en: 'Step 1: Data-Driven Attribute Creation'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤1：基于数据创建属性
- en: '[Example 22-8](#ex_schedule_v1_demo) shows the doctest to guide this first
    step.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22-8](#ex_schedule_v1_demo)展示了指导这一步骤的doctest。'
- en: Example 22-8\. Test-driving schedule_v1.py (from [Example 22-9](#ex_schedule_v1))
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-8\. 测试schedule_v1.py（来自[示例 22-9](#ex_schedule_v1)）
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO7-1)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO7-1)'
- en: '`load` a `dict` with the JSON data.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`load`一个带有JSON数据的`dict`。'
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO7-2)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO7-2)'
- en: The keys in `records` are strings built from the record type and serial number.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`records`中的键是由记录类型和序列号构建的字符串。'
- en: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO7-3)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO7-3)'
- en: '`speaker` is an instance of the `Record` class defined in [Example 22-9](#ex_schedule_v1).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`speaker`是在[示例 22-9](#ex_schedule_v1)中定义的`Record`类的实例。'
- en: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO7-4)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO7-4)'
- en: Fields from the original JSON can be retrieved as `Record` instance attributes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将原始JSON中的字段作为`Record`实例属性检索。
- en: The code for *schedule_v1.py* is in [Example 22-9](#ex_schedule_v1).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*schedule_v1.py*的代码在[示例 22-9](#ex_schedule_v1)中。'
- en: 'Example 22-9\. schedule_v1.py: reorganizing the OSCON schedule data'
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-9\. schedule_v1.py：重新组织OSCON日程数据
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO8-1)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO8-1)'
- en: This is a common shortcut to build an instance with attributes created from
    keyword arguments (detailed explanation follows).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的快捷方式，用关键字参数构建属性的实例（详细解释如下）。
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO8-2)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO8-2)'
- en: Use the `serial` field to build the custom `Record` representation shown in
    [Example 22-8](#ex_schedule_v1_demo).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`serial`字段构建自定义的`Record`表示，如[示例 22-8](#ex_schedule_v1_demo)所示。
- en: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO8-3)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO8-3)'
- en: '`load` will ultimately return a `dict` of `Record` instances.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`load`最终将返回`Record`实例的`dict`。'
- en: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO8-4)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO8-4)'
- en: 'Parse the JSON, returning native Python objects: lists, dicts, strings, numbers,
    etc.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解析JSON，返回本机Python对象：列表、字典、字符串、数字等。
- en: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO8-5)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO8-5)'
- en: Iterate over the four top-level lists named `'conferences'`, `'events'`, `'speakers'`,
    and `'venues'`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代四个名为`'conferences'`、`'events'`、`'speakers'`和`'venues'`的顶级列表。
- en: '[![6](assets/6.png)](#co_dynamic_attributes_and_properties_CO8-6)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dynamic_attributes_and_properties_CO8-6)'
- en: '`record_type` is the list name without the last character, so `speakers` becomes
    `speaker`. In Python ≥ 3.9 we can do this more explicitly with `collection.removesuffix(''s'')`—see
    [PEP 616—String methods to remove prefixes and suffixes](https://fpy.li/pep616).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`record_type`是列表名称去掉最后一个字符，所以`speakers`变成`speaker`。在Python ≥ 3.9中，我们可以更明确地使用`collection.removesuffix(''s'')`来做到这一点——参见[PEP
    616—删除前缀和后缀的字符串方法](https://fpy.li/pep616)。'
- en: '[![7](assets/7.png)](#co_dynamic_attributes_and_properties_CO8-7)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_dynamic_attributes_and_properties_CO8-7)'
- en: Build the `key` in the format `'speaker.3471'`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 构建格式为`'speaker.3471'`的`key`。
- en: '[![8](assets/8.png)](#co_dynamic_attributes_and_properties_CO8-8)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_dynamic_attributes_and_properties_CO8-8)'
- en: Create a `Record` instance and save it in `records` with the `key`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Record`实例，并将其保存在带有`key`的`records`中。
- en: The `Record.__init__` method illustrates an old Python hack. Recall that the
    `__dict__` of an object is where its attributes are kept—unless `__slots__` is
    declared in the class, as we saw in [“Saving Memory with __slots__”](ch11.html#slots_section).
    So, updating an instance `__dict__` with a mapping is a quick way to create a
    bunch of attributes in that instance.^([7](ch22.html#idm46582376904944))
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Record.__init__`方法展示了一个古老的Python技巧。回想一下，对象的`__dict__`是其属性所在的地方——除非在类中声明了`__slots__`，就像我们在[“使用__slots__节省内存”](ch11.html#slots_section)中看到的那样。因此，使用映射更新实例`__dict__`是一种快速创建该实例中一堆属性的方法。^([7](ch22.html#idm46582376904944))'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on the application, the `Record` class may need to deal with keys
    that are not valid attribute names, as we saw in [“The Invalid Attribute Name
    Problem”](#dynamic_names_sec). Dealing with that issue would distract from the
    key idea of this example, and is not a problem in the dataset we are reading.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序的不同，`Record`类可能需要处理不是有效属性名称的键，就像我们在[“无效属性名称问题”](#dynamic_names_sec)中看到的那样。处理这个问题会分散这个示例的关键思想，并且在我们正在读取的数据集中并不是一个问题。
- en: 'The definition of `Record` in [Example 22-9](#ex_schedule_v1) is so simple
    that you may be wondering why I did not use it before, instead of the more complicated
    `FrozenJSON`. There are two reasons. First, `FrozenJSON` works by recursively
    converting the nested mappings and lists; `Record` doesn’t need that because our
    converted dataset doesn’t have mappings nested in mappings or lists. The records
    contain only strings, integers, lists of strings, and lists of integers. Second
    reason: `FrozenJSON` provides access to the embedded `__data` `dict` attributes—which
    we used to invoke methods like `.keys()`—and now we don’t need that functionality
    either.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 22-9](#ex_schedule_v1)中`Record`的定义是如此简单，以至于你可能会想为什么我没有在之前使用它，而是使用更复杂的`FrozenJSON`。有两个原因。首先，`FrozenJSON`通过递归转换嵌套映射和列表来工作；`Record`不需要这样做，因为我们转换的数据集中没有映射嵌套在映射或列表中。记录只包含字符串、整数、字符串列表和整数列表。第二个原因：`FrozenJSON`提供对嵌入的`__data`
    `dict`属性的访问——我们用它来调用像`.keys()`这样的方法——现在我们也不需要那个功能了。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Python standard library provides classes similar to `Record`, where each
    instance has an arbitrary set of attributes built from keyword arguments given
    to `__init__`: [`types.SimpleNamespace`](https://fpy.li/22-5), [`argparse.Namespace`](https://fpy.li/22-6),
    and [`multiprocessing.managers.Namespace`](https://fpy.li/22-7). I wrote the simpler
    `Record` class to highlight the essential idea: `__init__` updating the instance
    `__dict__`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库提供了类似于`Record`的类，其中每个实例都有一个从给定给`__init__`的关键字参数构建的任意属性集：[`types.SimpleNamespace`](https://fpy.li/22-5)、[`argparse.Namespace`](https://fpy.li/22-6)和[`multiprocessing.managers.Namespace`](https://fpy.li/22-7)。我编写了更简单的`Record`类来突出显示基本思想：`__init__`更新���例`__dict__`。
- en: After reorganizing the schedule dataset, we can enhance the `Record` class to
    automatically retrieve `venue` and `speaker` records referenced in an `event`
    record. We’ll use properties to do that in the next examples.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重新组织日程数据集后，我们可以增强`Record`类，自动检索`event`记录中引用的`venue`和`speaker`记录。我们将在接下来的示例中使用属性来实现这一点。
- en: 'Step 2: Property to Retrieve a Linked Record'
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步：检索链接记录的属性
- en: 'The goal of this next version is: given an `event` record, reading its `venue`
    property will return a `Record`. This is similar to what the Django ORM does when
    you access a `ForeignKey` field: instead of the key, you get the linked model
    object.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个版本的目标是：给定一个`event`记录，读取其`venue`属性将返回一个`Record`。这类似于Django ORM在访问`ForeignKey`字段时的操作：您将获得链接的模型对象，而不是键。
- en: We’ll start with the `venue` property. See the partial interaction in [Example 22-10](#ex_schedule_v2_demo)
    as an example.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`venue`属性开始。查看[示例22-10](#ex_schedule_v2_demo)中的部分交互作为示例。
- en: Example 22-10\. Extract from the doctests of schedule_v2.py
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例22-10\. 从schedule_v2.py的doctests中提取
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO9-1)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO9-1)'
- en: The `Record.fetch` static method gets a `Record` or an `Event` from the dataset.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Record.fetch`静态方法从数据集中获取一个`Record`或一个`Event`。'
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO9-2)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO9-2)'
- en: Note that `event` is an instance of the `Event` class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`event`是`Event`类的一个实例。
- en: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO9-3)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO9-3)'
- en: Accessing `event.venue` returns a `Record` instance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`event.venue`将返回一个`Record`实例。
- en: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO9-4)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO9-4)'
- en: Now it’s easy to find out the name of an `event.venue`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易找出`event.venue`的名称。
- en: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO9-5)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO9-5)'
- en: The `Event` instance also has a `venue_serial` attribute, from the JSON data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event`实例还具有来自JSON数据的`venue_serial`属性。'
- en: '`Event` is a subclass of `Record` adding a `venue` to retrieve linked records,
    and a specialized `__repr__` method.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event`是`Record`的一个子类，添加了一个`venue`来检索链接的记录，以及一个专门的`__repr__`方法。'
- en: The code for this section is in the [*schedule_v2.py*](https://fpy.li/22-8)
    module in the [*Fluent Python* code repository](https://fpy.li/code). The example
    has nearly 60 lines, so I’ll present it in parts, starting with the enhanced `Record`
    class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的代码位于[*schedule_v2.py*](https://fpy.li/22-8)模块中，位于[*Fluent Python*代码库](https://fpy.li/code)中。示例有近60行，所以我将分部分呈现，从增强的`Record`类开始。
- en: 'Example 22-11\. schedule_v2.py: `Record` class with a new `fetch` method'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例22-11\. schedule_v2.py：具有新`fetch`方法的`Record`类
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO10-1)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO10-1)'
- en: '`inspect` will be used in `load`, listed in [Example 22-13](#ex_schedule_v2_load).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect`将在[示例22-13](#ex_schedule_v2_load)中使用。'
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO10-2)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO10-2)'
- en: The `__index` private class attribute will eventually hold a reference to the
    `dict` returned by `load`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`__index`私有类属性最终将保存对`load`返回的`dict`的引用。'
- en: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO10-3)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO10-3)'
- en: '`fetch` is a `staticmethod` to make it explicit that its effect is not influenced
    by the instance or class on which it is called.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch`是一个`staticmethod`，明确表示其效果不受调用它的实例或类的影响。'
- en: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO10-4)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO10-4)'
- en: Populate the `Record.__index`, if needed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如有需要，填充`Record.__index`。
- en: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO10-5)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO10-5)'
- en: Use it to retrieve the record with the given `key`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它来检索具有给定`key`的记录。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: This is one example where the use of `staticmethod` makes sense. The `fetch`
    method always acts on the `Record.__index` class attribute, even if invoked from
    a subclass, like `Event.fetch()`—which we’ll soon explore. It would be misleading
    to code it as a class method because the `cls` first argument would not be used.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`staticmethod`的例子。`fetch`方法始终作用于`Record.__index`类属性，即使从子类调用，如`Event.fetch()`—我们很快会探讨。将其编码为类方法会产生误导，因为不会使用`cls`第一个参数。
- en: Now we get to the use of a property in the `Event` class, listed in [Example 22-12](#ex_schedule_v2_event).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看`Event`类中属性的使用，列在[示例22-12](#ex_schedule_v2_event)中。
- en: 'Example 22-12\. schedule_v2.py: the `Event` class'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-12\. schedule_v2.py：`Event`类
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO11-1)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO11-1)'
- en: '`Event` extends `Record`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event`扩展了`Record`。'
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO11-2)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO11-2)'
- en: If the instance has a `name` attribute, it is used to produce a custom representation.
    Otherwise, delegate to the `__repr__` from `Record`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实例具有`name`属性，则用于生成自定义表示。否则，委托给`Record`的`__repr__`。
- en: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO11-3)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO11-3)'
- en: The `venue` property builds a `key` from the `venue_serial` attribute, and passes
    it to the `fetch` class method, inherited from `Record` (the reason for using
    `self.__class__` is explained shortly).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`venue`属性从`venue_serial`属性构建一个`key`，并将其传递给从`Record`继承的`fetch`类方法（使用`self.__class__`的原因将很快解释）。'
- en: The second line of the `venue` method of [Example 22-12](#ex_schedule_v2_event)
    returns `self​.__class__.fetch(key)`. Why not simply call `self.fetch(key)`? The
    simpler form works with the specific OSCON dataset because there is no event record
    with a `'fetch'` key. But, if an event record had a key named `'fetch'`, then
    within that specific `Event` instance, the reference `self.fetch` would retrieve
    the value of that field, instead of the `fetch` class method that `Event` inherits
    from `Record`. This is a subtle bug, and it could easily sneak through testing
    because it depends on the dataset.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 22-12](#ex_schedule_v2_event)的`venue`方法的第二行返回`self​.__class__.fetch(key)`。为什么不简单地调用`self.fetch(key)`？简单形式适用于特定的OSCON数据集，因为没有带有`''fetch''`键的事件记录。但是，如果事件记录有一个名为`''fetch''`的键，那么在特定的`Event`实例内，引用`self.fetch`将检索该字段的值，而不是`Event`从`Record`继承的`fetch`类方法。这是一个微妙的错误，它很容易在测试中被忽略，因为它取决于数据集。'
- en: Warning
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: When creating instance attribute names from data, there is always the risk of
    bugs due to shadowing of class attributes—such as methods—or data loss through
    accidental overwriting of existing instance attributes. These problems may explain
    why Python dicts are not like JavaScript objects in the first place.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在从数据创建实例属性名称时，总是存在由于类属性（如方法）的遮蔽或由于意外覆盖现有实例属性而导致的错误风险。这些问题可能解释了为什么Python字典一开始就不像JavaScript对象。
- en: If the `Record` class behaved more like a mapping, implementing a dynamic `__getitem__`
    instead of a dynamic `__getattr__`, there would be no risk of bugs from overwriting
    or shadowing. A custom mapping is probably the Pythonic way to implement `Record`.
    But if I took that road, we’d not be studying the tricks and traps of dynamic
    attribute programming.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Record`类的行为更像映射，实现动态的`__getitem__`而不是动态的`__getattr__`，那么就不会有由于覆盖或遮蔽而导致的错误风险。自定义映射可能是实现`Record`的Pythonic方式。但是如果我选择这条路，我们就不会研究动态属性编程的技��和陷阱。
- en: The final piece of this example is the revised `load` function in [Example 22-13](#ex_schedule_v2_load).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例的最后一部分是[Example 22-13](#ex_schedule_v2_load)中修改后的`load`函数。
- en: 'Example 22-13\. schedule_v2.py: the `load` function'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例22-13\. schedule_v2.py：`load`函数
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO12-1)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO12-1)'
- en: So far, no changes from the `load` in *schedule_v1.py* ([Example 22-9](#ex_schedule_v1)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，与*schedule_v1.py*中的`load`没有任何变化（[Example 22-9](#ex_schedule_v1)）。
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO12-2)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO12-2)'
- en: Capitalize the `record_type` to get a possible class name; e.g., `'event'` becomes
    `'Event'`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将`record_type`大写以获得可能的类名；例如，`'event'`变为`'Event'`。
- en: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO12-3)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO12-3)'
- en: Get an object by that name from the module global scope; get the `Record` class
    if there’s no such object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从模块全局范围获取该名称的对象；如果没有这样的对象，则获取`Record`类。
- en: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO12-4)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO12-4)'
- en: If the object just retrieved is a class, and is a subclass of `Record`…
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果刚刚检索到的对象是一个类，并且是`Record`的子类…
- en: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO12-5)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO12-5)'
- en: …bind the `factory` name to it. This means `factory` may be any subclass of
    `Record`, depending on the `record_type`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: …将`factory`名称绑定到它。这意味着`factory`可以是`Record`的任何子类，取决于`record_type`。
- en: '[![6](assets/6.png)](#co_dynamic_attributes_and_properties_CO12-6)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dynamic_attributes_and_properties_CO12-6)'
- en: Otherwise, bind the `factory` name to `Record`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，将`factory`名称绑定到`Record`。
- en: '[![7](assets/7.png)](#co_dynamic_attributes_and_properties_CO12-7)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_dynamic_attributes_and_properties_CO12-7)'
- en: The `for` loop that creates the `key` and saves the records is the same as before,
    except that…
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`key`并保存记录的`for`循环与以前相同，只是…
- en: '[![8](assets/8.png)](#co_dynamic_attributes_and_properties_CO12-8)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_dynamic_attributes_and_properties_CO12-8)'
- en: …the object stored in `records` is constructed by `factory`, which may be `Record`
    or a subclass like `Event`, selected according to the `record_type`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: …存储在`records`中的对象由`factory`构造，该`factory`可以是`Record`或根据`record_type`选择的`Event`等子类。
- en: Note that the only `record_type` that has a custom class is `Event`, but if
    classes named `Speaker` or `Venue` are coded, `load` will automatically use those
    classes when building and saving records, instead of the default `Record` class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，唯一具有自定义类的`record_type`是`Event`，但如果编写了名为`Speaker`或`Venue`的类，`load`将在构建和保存记录时自动使用这些类，而不是默认的`Record`类。
- en: We’ll now apply the same idea to a new `speakers` property in the `Events` class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将相同的想法应用于`Events`类中的新`speakers`属性。
- en: 'Step 3: Property Overriding an Existing Attribute'
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三步：覆盖现有属性
- en: The name of the `venue` property in [Example 22-12](#ex_schedule_v2_event) does
    not match a field name in records of the `"events"` collection. Its data comes
    from a `venue_serial` field name. In contrast, each record in the `events` collection
    has a `speakers` field with a list of serial numbers. We want to expose that information
    as a `speakers` property in `Event` instances, which returns a list of `Record`
    instances. This name clash requires some special attention, as [Example 22-14](#ex_schedule_v3_speakers)
    reveals.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 22-12](#ex_schedule_v2_event)中`venue`属性的名称与`"events"`集合中的记录字段名称不匹配。它的数据来自`venue_serial`字段名称。相比之下，`events`集合中的每个记录都有一个`speakers`字段，其中包含一系列序列号。我们希望将该信息作为`Event`实例中的`speakers`属性公开，该属性返回`Record`实例的列表。这种名称冲突需要特别注意，正如[Example 22-14](#ex_schedule_v3_speakers)所示。'
- en: 'Example 22-14\. schedule_v3.py: the `speakers` property'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例22-14\. schedule_v3.py：`speakers`属性
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO13-1)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO13-1)'
- en: The data we want is in a `speakers` attribute, but we must retrieve it directly
    from the instance `__dict__` to avoid a recursive call to the `speakers` property.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的数据在`speakers`属性中，但我们必须直接从实例`__dict__`中检索它，以避免对`speakers`属性的递归调用。
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO13-2)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO13-2)'
- en: Return a list of all records with keys corresponding to the numbers in `spkr_serials`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个具有与 `spkr_serials` 中数字对应的键的所有记录列表。
- en: Inside the `speakers` method, trying to read `self.speakers` will invoke the
    property itself, quickly raising a `RecursionError`. However, if we read the same
    data via `self.__dict__['speakers']`, Python’s usual algorithm for retrieving
    attributes is bypassed, the property is not called, and the recursion is avoided.
    For this reason, reading or writing data directly to an object’s `__dict__` is
    a common Python metaprogramming trick.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `speakers` 方法内部，尝试读取 `self.speakers` 将会快速引发 `RecursionError`。然而，如果通过 `self.__dict__['speakers']`
    读取相同的数据，Python 通常用于检索属性的算法将被绕过，属性不会被调用，递归被避免。因此，直接读取或写入对象的 `__dict__` 中的数据是一种常见的
    Python 元编程技巧。
- en: Warning
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The interpreter evaluates `obj.my_attr` by first looking at the class of `obj`.
    If the class has a property with the `my_attr` name, that property shadows an
    instance attribute by the same name. Examples in [“Properties Override Instance
    Attributes”](#prop_override_instance) will demonstrate this, and [Chapter 23](ch23.html#attribute_descriptors)
    will reveal that a property is implemented as a descriptor—a more powerful and
    general abstraction.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器通过首先查看 `obj` 的类来评估 `obj.my_attr`。如果类具有与 `my_attr` 名称相同的属性，则该属性会遮蔽同名的实例属性。[“���性覆盖实例属性”](#prop_override_instance)
    中的示例将演示这一点，而 [第 23 章](ch23.html#attribute_descriptors) 将揭示属性是作为描述符实现的——这是一种更强大和通用的抽象。
- en: 'As I coded the list comprehension in [Example 22-14](#ex_schedule_v3_speakers),
    my programmer’s lizard brain thought: “This may be expensive.” Not really, because
    events in the OSCON dataset have few speakers, so coding anything more complicated
    would be premature optimization. However, caching a property is a common need—and
    there are caveats. So let’s see how to do that in the next examples.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我编写 [示例 22-14](#ex_schedule_v3_speakers) 中的列表推导式时，我的程序员蜥蜴大脑想到：“这可能会很昂贵。” 实际上并不是，因为
    OSCON 数据集中的事件只有少数演讲者，所以编写任何更复杂的东西都会过早优化。然而，缓存属性是一个常见的需求，但也有一些注意事项。让我们在接下来的示例中看看如何做到这一点。
- en: 'Step 4: Bespoke Property Cache'
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 4：定制属性缓存
- en: Caching properties is a common need because there is an expectation that an
    expression like `event.venue` should be inexpensive.^([8](ch22.html#idm46582376098304))
    Some form of caching could become necessary if the `Record.fetch` method behind
    the `Event` properties needed to query a database or a web API.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存属性是一个常见的需求，因为人们期望像 `event.venue` 这样的表达式应该是廉价的。^([8](ch22.html#idm46582376098304))
    如果 `Record.fetch` 方法背后的 `Event` 属性需要查询数据库或 Web API，某种形式的缓存可能会变得必要。
- en: In the first edition *Fluent Python*, I coded the custom caching logic for the
    `speakers` method, as shown in [Example 22-15](#ex_schedule_v4_hasattr).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一版 *Fluent Python* 中，我为 `speakers` 方法编写了自定义缓存逻辑，如 [示例 22-15](#ex_schedule_v4_hasattr)
    所示。
- en: Example 22-15\. Custom caching logic using `hasattr` disables key-sharing optimization
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-15\. 使用 `hasattr` 的自定义缓存逻辑会禁用键共享优化
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO14-1)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO14-1)'
- en: If the instance doesn’t have an attribute named `__speaker_objs`, fetch the
    speaker objects and store them there.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实例没有名为 `__speaker_objs` 的属性，则获取演讲者对象并将它们存储在那里。
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO14-2)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO14-2)'
- en: Return `self.__speaker_objs`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `self.__speaker_objs`。
- en: The handmade caching in [Example 22-15](#ex_schedule_v4_hasattr) is straightforward,
    but creating an attribute after the instance is initialized defeats the [PEP 412—Key-Sharing
    Dictionary](https://fpy.li/pep412) optimization, as explained in [“Practical Consequences
    of How dict Works”](ch03.html#consequences_dict_internals). Depending on the size
    of the dataset, the difference in memory usage may be important.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 22-15](#ex_schedule_v4_hasattr) 中手动缓存是直接的，但在实例初始化后创建属性会破坏 [PEP 412—Key-Sharing
    Dictionary](https://fpy.li/pep412) 优化，如 [“dict 工作原理的实际后果”](ch03.html#consequences_dict_internals)
    中所解释的。根据数据集的大小，内存使用量的差异可能很重要。
- en: A similar hand-rolled solution that works well with the key-sharing optimization
    requires coding an `__init__` for the `Event` class, to create the necessary `__speaker_objs`
    initialized to `None`, and then checking for that in the `speakers` method. See
    [Example 22-16](#ex_schedule_v4).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似的手动解决方案，与键共享优化很好地配合使用，需要为 `Event` 类编写一个 `__init__`，以创建必要的 `__speaker_objs`
    并将其初始化为 `None`，然后在 `speakers` 方法中检查这一点。参见 [示例 22-16](#ex_schedule_v4)。
- en: Example 22-16\. Storage defined in `__init__` to leverage key-sharing optimization
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-16\. 在 `__init__` 中定义存储以利用键共享优化
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Examples [22-15](#ex_schedule_v4_hasattr) and [22-16](#ex_schedule_v4) illustrate
    simple caching techniques that are fairly common in legacy Python codebases. However,
    in multithreaded programs, handmade caches like those introduce race conditions
    that may lead to corrupted data. If two threads are reading a property that was
    not previously cached, the first thread will need to compute the data for the
    cache attribute (`__speaker_objs` in the examples) and the second thread may read
    a cached value that is not yet complete.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 [22-15](#ex_schedule_v4_hasattr) 和 [22-16](#ex_schedule_v4) 展示了在传统 Python
    代码库中相当常见的简单缓存技术。然而，在多线程程序中，像这样的手动缓存会引入可能导致数据损坏的竞争条件。如果两个线程正在读取以前未缓存的属性，则第一个线程将需要计算缓存属性的数据（示例中的
    `__speaker_objs`），而第二个线程可能会读取尚不完整的缓存值。
- en: Fortunately, Python 3.8 introduced the `@functools.cached_property` decorator,
    which is thread safe. Unfortunately, it comes with a couple of caveats, explained
    next.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python 3.8 引入了 `@functools.cached_property` 装饰器，它是线程安全的。不幸的是，它带来了一些注意事项，接下来会解释。
- en: 'Step 5: Caching Properties with functools'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 5：使用 functools 缓存属性
- en: The `functools` module provides three decorators for caching. We saw `@cache`
    and `@lru_cache` in [“Memoization with functools.cache”](ch09.html#memoization_sec)
    ([Chapter 9](ch09.html#closures_and_decorators)). Python 3.8 introduced `@cached_property`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`functools` 模块提供了三个用于缓存的装饰器。我们在 [“使用 functools.cache 进行记忆化”](ch09.html#memoization_sec)（[第
    9 章](ch09.html#closures_and_decorators)）中看到了 `@cache` 和 `@lru_cache`。Python 3.8
    引入了 `@cached_property`。'
- en: The `functools.cached_property` decorator caches the result of the method in
    an instance attribute with the same name. For example, in [Example 22-17](#ex_schedule_v5_cached_property),
    the value computed by the `venue` method is stored in a `venue` attribute in `self`.
    After that, when client code tries to read `venue`, the newly created `venue`
    instance attribute is used instead of the method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`functools.cached_property` 装饰器将方法的结果缓存到具有相同名称的实例属性中。例如，在 [示例 22-17](#ex_schedule_v5_cached_property)
    中，`venue` 方法计算的值存储在 `self` 中的 `venue` 属性中。之后，当客户端代码尝试读取 `venue` 时，新创建的 `venue`
    实例属性将被使用，而不是方法。'
- en: Example 22-17\. Simple use of a `@cached_property`
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-17\. 使用 `@cached_property` 的简单示例
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In [“Step 3: Property Overriding an Existing Attribute”](#property_overriding_sec),
    we saw that a property shadows an instance attribute by the same name. If that
    is true, how can `@cached_property` work? If the property overrides the instance
    attribute, the `venue` attribute will be ignored and the `venue` method will always
    be called, computing the `key` and running `fetch` every time!'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“第 3 步：覆盖现有属性的属性”](#property_overriding_sec) 中，我们看到属性通过相同名称的实例属性进行遮蔽。如果这是真的，那么
    `@cached_property` 如何工作呢？如果属性覆盖了实例属性，那么 `venue` 属性将被忽略，`venue` 方法将始终被调用，每次计算 `key`
    并运行 `fetch`！
- en: 'The answer is a bit sad: `cached_property` is a misnomer. The `@cached_property`
    decorator does not create a full-fledged property, it creates a *nonoverriding
    descriptor*. A descriptor is an object that manages the access to an attribute
    in another class. We will dive into descriptors in [Chapter 23](ch23.html#attribute_descriptors).
    The `property` decorator is a high-level API to create an *overriding descriptor*.
    [Chapter 23](ch23.html#attribute_descriptors) will include a through explanation
    about *overriding* versus *nonoverriding* descriptors.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 答案有点令人沮丧：`cached_property` 是一个误称。`@cached_property` 装饰器并不创建一个完整的属性，而是创建了一个 *非覆盖描述符*。描述符是一个管理另一个类中属性访问的对象。我们将在
    [第 23 章](ch23.html#attribute_descriptors) 中深入探讨描述符。`property` 装饰器是一个用于创建 *覆盖描述符*
    的高级 API。[第 23 章](ch23.html#attribute_descriptors) 将详细解释 *覆盖* 与 *非覆盖* 描述符的区别。
- en: 'For now, let us set aside the underlying implementation and focus on the differences
    between `cached_property` and `property` from a user’s point of view. Raymond
    Hettinger explains them very well in the [Python docs](https://fpy.li/22-9):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们暂时搁置底层实现，关注从用户角度看 `cached_property` 和 `property` 之间的区别。Raymond Hettinger
    在 [Python 文档](https://fpy.li/22-9) 中很好地解释了它们：
- en: The mechanics of `cached_property()` are somewhat different from `property()`.
    A regular property blocks attribute writes unless a setter is defined. In contrast,
    a `cached_property` allows writes.
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`cached_property()` 的机制与 `property()` 有所不同。普通属性会阻止属性写入，除非定义了 setter。相比之下，`cached_property`
    允许写入。'
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `cached_property` decorator only runs on lookups and only when an attribute
    of the same name doesn’t exist. When it does run, the `cached_property` writes
    to the attribute with the same name. Subsequent attribute reads and writes take
    precedence over the `cached_property` method and it works like a normal attribute.
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`cached_property` 装饰器仅在查找时运行，并且仅当同名属性不存在时才运行。当它运行时，`cached_property` 会写入具有相同名称的属性。随后的属性读取和写入优先于
    `cached_property` 方法，并且它的工作方式类似于普通属性。'
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The cached value can be cleared by deleting the attribute. This allows the `cached_property`
    method to run again.^([9](ch22.html#idm46582375804496))
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 缓存的值可以通过删除属性来清除。这允许 `cached_property` 方法再次运行。^([9](ch22.html#idm46582375804496))
- en: 'Back to our `Event` class: the specific behavior of `@cached_property` makes
    it unsuitable to decorate `speakers`, because that method relies on an existing
    attribute also named `speakers`, containing the serial numbers of the event speakers.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 `Event` 类：`@cached_property` 的具体行为使其不适合装饰 `speakers`，因为该方法依赖于一个名为 `speakers`
    的现有属性，其中包含活动演讲者的序列号。
- en: Warning
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '`@cached_property` has some important limitations:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`@cached_property` 有一些重要的限制：'
- en: It cannot be used as a drop-in replacement to `@property` if the decorated method
    already depends on an instance attribute with the same name.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果装饰的方法已经依赖于同名实例属性，则它不能作为 `@property` 的即插即用替代品。
- en: It cannot be used in a class that defines `__slots__`.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能在定义了 `__slots__` 的类中使用。
- en: It defeats the key-sharing optimization of the instance `__dict__`, because
    it creates an instance attribute after `__init__`.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它打败了实例 `__dict__` 的键共享优化，因为它在 `__init__` 之后创建了一个实例属性。
- en: Despite these limitations, `@cached_property` addresses a common need in a simple
    way, and it is thread safe. Its [Python code](https://fpy.li/22-13) is an example
    of using a [*reentrant lock*](https://fpy.li/22-14).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些限制，`@cached_property` 以简单的方式满足了常见需求，并且是线程安全的。它的 [Python 代码](https://fpy.li/22-13)
    是使用 [*可重入锁*](https://fpy.li/22-14) 的一个示例。
- en: 'The `@cached_property` [documentation](https://fpy.li/22-15) recommends an
    alternative solution that we can use with `speakers`: stacking `@property` and
    `@cache` decorators, as shown in [Example 22-18](#ex_schedule_v5_property_over_cache).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`@cached_property` 的 [文档](https://fpy.li/22-15) 建议了一个替代解决方案，我们可以在 `speakers`
    上使用 `@property` 和 `@cache` 装饰器叠加，就像 [示例 22-18](#ex_schedule_v5_property_over_cache)
    中展示的那样。'
- en: Example 22-18\. Stacking `@property` on `@cache`
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-18\. 在 `@property` 上叠加 `@cache`
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO15-1)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO15-1)'
- en: 'The order is important: `@property` goes on top…'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序很重要：`@property` 放在最上面…
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO15-2)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO15-2)'
- en: …of `@cache`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: …`@cache`。
- en: 'Recall from [“Stacked Decorators”](ch09.html#stacked_decorators_tip) the meaning
    of that syntax. The top three lines of [Example 22-18](#ex_schedule_v5_property_over_cache)
    are similar to:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从[“堆叠装饰器”](ch09.html#stacked_decorators_tip)中回想一下该语法的含义。[示例 22-18](#ex_schedule_v5_property_over_cache)的前三行类似于：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `@cache` is applied to `speakers`, returning a new function. That function
    then is decorated by `@property`, which replaces it with a newly constructed property.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`@cache`应用于`speakers`，返回一个新函数。然后，该函数被`@property`装饰，将其替换为一个新构造的属性。'
- en: This wraps up our discussion of read-only properties and caching decorators,
    exploring the OSCON dataset. In the next section, we start a new series of examples
    creating read/write properties.[PRE19]# Using a Property for Attribute Validation
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对只读属性和缓存装饰器的讨论，探索OSCON数据集。在下一节中，我们将开始一个新系列的示例，创建读/写属性。[PRE19]# 使用属性进行属性验证
- en: Besides computing attribute values, properties are also used to enforce business
    rules by changing a public attribute into an attribute protected by a getter and
    setter without affecting client code. Let’s work through an extended example.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 除了计算属性值外，属性还用于通过将公共属性更改为由getter和setter保护的属性来强制执行业务规则，而不影响客户端代码。让我们通过一个扩展示例来详细讨论。
- en: 'LineItem Take #1: Class for an Item in an Order'
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LineItem第一次尝试：订单中的商品类
- en: Imagine an app for a store that sells organic food in bulk, where customers
    can order nuts, dried fruit, or cereals by weight. In that system, each order
    would hold a sequence of line items, and each line item could be represented by
    an instance of a class, as in [Example 22-19](#lineitem_class_v1).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个销售散装有机食品的商店的应用程序，客户可以按重量订购坚果、干果或谷物。在该系统中，每个订单将包含一系列行项目，每个行项目可以由一个类的实例表示，如[示例
    22-19](#lineitem_class_v1)中所示。
- en: 'Example 22-19\. bulkfood_v1.py: the simplest `LineItem` class'
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-19。bulkfood_v1.py：最简单的`LineItem`类
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That’s nice and simple. Perhaps too simple. [Example 22-20](#lineitem_problem_v1)
    shows a problem.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单明了。也许太简单了。[示例 22-20](#lineitem_problem_v1)展示了一个问题。
- en: Example 22-20\. A negative weight results in a negative subtotal
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-20。负重导致负小计
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is a toy example, but not as fanciful as you may think. Here is a story
    from the early days of Amazon.com:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个玩具示例，但并不像你想象的那样幻想。这是亚马逊.com早期的一个故事：
- en: We found that customers could order a negative quantity of books! And we would
    credit their credit card with the price and, I assume, wait around for them to
    ship the books.
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们发现客户可以订购负数数量的书！然后我们会用价格给他们的信用卡记账，我猜，等待他们发货。
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Jeff Bezos, founder and CEO of Amazon.com^([10](ch22.html#idm46582375484704))
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 亚马逊.com创始人兼首席执行官杰夫·贝索斯^([10](ch22.html#idm46582375484704))
- en: How do we fix this? We could change the interface of `LineItem` to use a getter
    and a setter for the `weight` attribute. That would be the Java way, and it’s
    not wrong.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？我们可以改变`LineItem`的接口，使用getter和setter来处理`weight`属性。那将是Java的方式，这并不是错误的。
- en: On the other hand, it’s natural to be able to set the `weight` of an item by
    just assigning to it; and perhaps the system is in production with other parts
    already accessing `item.weight` directly. In this case, the Python way would be
    to replace the data attribute with a property.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，能够通过简单赋值来设置物品的`weight`是很自然的；也许系统已经在生产中，其他部分已经直接访问`item.weight`。在这种情况下，Python的做法是用属性替换数据属性。
- en: 'LineItem Take #2: A Validating Property'
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LineItem第二次尝试：一个验证属性
- en: Implementing a property will allow us to use a getter and a setter, but the
    interface of `LineItem` will not change (i.e., setting the `weight` of a `LineItem`
    will still be written as `raisins.weight = 12`).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个属性将允许我们使用一个getter和一个setter，但`LineItem`的接口不会改变（即，设置`LineItem`的`weight`仍然写作`raisins.weight
    = 12`）。
- en: '[Example 22-21](#lineitem_class_v2) lists the code for a read/write `weight`
    property.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22-21](#lineitem_class_v2)列出了一个读/写`weight`属性的代码。'
- en: 'Example 22-21\. bulkfood_v2.py: a `LineItem` with a `weight` property'
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-21。bulkfood_v2.py：带有`weight`属性的`LineItem`
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO16-1)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO16-1)'
- en: Here the property setter is already in use, making sure that no instances with
    negative `weight` can be created.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里属性setter已经在使用中，确保不会创建带有负`weight`的实例。
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO16-2)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO16-2)'
- en: '`@property` decorates the getter method.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`@property`装饰getter方法。'
- en: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO16-3)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO16-3)'
- en: 'All the methods that implement a property share the name of the public attribute:
    `weight`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所有实现属性的方法都共享公共属性的名称：`weight`。
- en: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO16-4)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO16-4)'
- en: The actual value is stored in a private attribute `__weight`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实际值存储在私有属性`__weight`中。
- en: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO16-5)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO16-5)'
- en: The decorated getter has a `.setter` attribute, which is also a decorator; this
    ties the getter and setter together.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰的getter具有`.setter`属性，这也是一个装饰器；这将getter和setter绑定在一起。
- en: '[![6](assets/6.png)](#co_dynamic_attributes_and_properties_CO16-6)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dynamic_attributes_and_properties_CO16-6)'
- en: If the value is greater than zero, we set the private `__weight`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值大于零，我们设置私有`__weight`。
- en: '[![7](assets/7.png)](#co_dynamic_attributes_and_properties_CO16-7)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_dynamic_attributes_and_properties_CO16-7)'
- en: Otherwise, `ValueError` is raised.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，将引发`ValueError`。
- en: 'Note how a `LineItem` with an invalid weight cannot be created now:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在无法创建具有无效重量的`LineItem`：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we have protected `weight` from users providing negative values. Although
    buyers usually can’t set the price of an item, a clerical error or a bug may create
    a `LineItem` with a negative `price`. To prevent that, we could also turn `price`
    into a property, but this would entail some repetition in our code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经保护了`weight`免受用户提供负值的影响。尽管买家通常不能设置物品的价格，但是文书错误或错误可能会创建一个具有负`price`的`LineItem`。为了防止这种情况，我们也可以将`price`转换为属性，但这将在我们的代码中产生一些重复。
- en: 'Remember the Paul Graham quote from [Chapter 17](ch17.html#iterables2generators):
    “When I see patterns in my programs, I consider it a sign of trouble.” The cure
    for repetition is abstraction. There are two ways to abstract away property definitions:
    using a property factory or a descriptor class. The descriptor class approach
    is more flexible, and we’ll devote [Chapter 23](ch23.html#attribute_descriptors)
    to a full discussion of it. Properties are in fact implemented as descriptor classes
    themselves. But here we will continue our exploration of properties by implementing
    a property factory as a function.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 记住保罗·格雷厄姆在[第17章](ch17.html#iterables2generators)中的引用：“当我在我的程序中看到模式时，我认为这是一个麻烦的迹象。”重复的治疗方法是抽象。有两种抽象属性定义的方法：使用属性工厂或描述符类。描述符类方法更灵活，我们将在[第23章](ch23.html#attribute_descriptors)中全面讨论它。实际上，属性本身是作为描述符类实现的。但在这里，我们将通过实现一个函数作为属性工厂来继续探讨属性。
- en: But before we can implement a property factory, we need to have a deeper understanding
    of properties.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们实现属性工厂之前，我们需要更深入地了解属性。
- en: A Proper Look at Properties
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对属性进行适当的查看
- en: Although often used as a decorator, the `property` built-in is actually a class.
    In Python, functions and classes are often interchangeable, because both are callable
    and there is no `new` operator for object instantiation, so invoking a constructor
    is no different from invoking a factory function. And both can be used as decorators,
    as long as they return a new callable that is a suitable replacement of the decorated
    callable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管经常被用作装饰器，但`property`内置实际上是一个类。在Python中，函数和类通常是可互换的，因为两者都是可调用的，而且没有用于对象实例化的`new`运算符，因此调用构造函数与调用工厂函数没有区别。并且两者都可以用作装饰器，只要它们返回一个适当替代被装饰的可调用对象。
- en: 'This is the full signature of the `property` constructor:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`property`��造函数的完整签名：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All arguments are optional, and if a function is not provided for one of them,
    the corresponding operation is not allowed by the resulting property object.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参数都是可选的，如果没有为其中一个参数提供函数，则生成的属性对象不允许相应的操作。
- en: The `property` type was added in Python 2.2, but the `@` decorator syntax appeared
    only in Python 2.4, so for a few years, properties were defined by passing the
    accessor functions as the first two arguments.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`property`类型是在Python 2.2中添加的，但`@`装饰器语法只在Python 2.4中出现，因此在几年内，属性是通过将访问器函数作为前两个参数来定义的。'
- en: The “classic” syntax for defining properties without decorators is illustrated
    in [Example 22-22](#lineitem_class_v2b).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 用装饰器的方式定义属性的“经典”语法在[示例22-22](#lineitem_class_v2b)中有所说明。
- en: 'Example 22-22\. bulkfood_v2b.py: same as [Example 22-21](#lineitem_class_v2),
    but without using decorators'
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例22-22。bulkfood_v2b.py：与[示例22-21](#lineitem_class_v2)相同，但不使用装饰器
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO17-1)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO17-1)'
- en: A plain getter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普通的getter。
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO17-2)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO17-2)'
- en: A plain setter.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普通的setter。
- en: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO17-3)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO17-3)'
- en: Build the `property` and assign it to a public class attribute.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 构建`property`并将其分配给一个公共类属性。
- en: The classic form is better than the decorator syntax in some situations; the
    code of the property factory we’ll discuss shortly is one example. On the other
    hand, in a class body with many methods, the decorators make it explicit which
    are the getters and setters, without depending on the convention of using `get`
    and `set` prefixes in their names.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，经典形式比装饰器语法更好；我们将很快讨论的属性工厂的代码就是一个例子。另一方面，在一个有许多方法的类体中，装饰器使得明确哪些是getter和setter，而不依赖于在它们的名称中使用`get`和`set`前缀的约定。
- en: The presence of a property in a class affects how attributes in instances of
    that class can be found in a way that may be surprising at first. The next section
    explains.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 类中存在属性会影响实例中属性的查找方式，这可能一开始会让人感到惊讶。下一节将解释。
- en: Properties Override Instance Attributes
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性覆盖实例属性
- en: Properties are always class attributes, but they actually manage attribute access
    in the instances of the class.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 属性始终是类属性，但实际上管理类的实例中的属性访问。
- en: In [“Overriding Class Attributes”](ch11.html#overriding_class_attributes) we
    saw that when an instance and its class both have a data attribute by the same
    name, the instance attribute overrides, or shadows, the class attribute—at least
    when read through that instance. [Example 22-23](#attr_override_demo1) illustrates
    this point.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“覆盖类属性”](ch11.html#overriding_class_attributes)中，我们看到当一个实例及其类都有相同名称的数据属性时，实例属性会覆盖或遮蔽类属性——至少在通过该实例读取时是这样的。[示例22-23](#attr_override_demo1)说明了这一点。
- en: Example 22-23\. Instance attribute shadows the class `data` attribute
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例22-23。实例属性遮蔽类`data`属性
- en: '[PRE26]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO18-1)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO18-1)'
- en: 'Define `Class` with two class attributes: the `data` attribute and the `prop`
    property.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个类属性`data`属性和`prop`属性定义`Class`。
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO18-2)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO18-2)'
- en: '`vars` returns the `__dict__` of `obj`, showing it has no instance attributes.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`vars`返回`obj`的`__dict__`，显示它没有实例属性。'
- en: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO18-3)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO18-3)'
- en: Reading from `obj.data` retrieves the value of `Class.data`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从`obj.data`中读取`Class.data`的值。
- en: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO18-4)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO18-4)'
- en: Writing to `obj.data` creates an instance attribute.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 `obj.data` 创建一个实例属性。
- en: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO18-5)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO18-5)'
- en: Inspect the instance to see the instance attribute.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 检查实例以查看实例属性。
- en: '[![6](assets/6.png)](#co_dynamic_attributes_and_properties_CO18-6)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dynamic_attributes_and_properties_CO18-6)'
- en: Now reading from `obj.data` retrieves the value of the instance attribute. When
    read from the `obj` instance, the instance `data` shadows the class `data`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从 `obj.data` 读取将检索实例属性的值。当从 `obj` 实例读取时，实例 `data` 遮蔽了类 `data`。
- en: '[![7](assets/7.png)](#co_dynamic_attributes_and_properties_CO18-7)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_dynamic_attributes_and_properties_CO18-7)'
- en: The `Class.data` attribute is intact.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`Class.data` 属性保持不变。'
- en: Now, let’s try to override the `prop` attribute on the `obj` instance. Resuming
    the previous console session, we have [Example 22-24](#attr_override_demo2).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试覆盖 `obj` 实例上的 `prop` 属性。继续之前的控制台会话，我们有[示例 22-24](#attr_override_demo2)。
- en: Example 22-24\. Instance attribute does not shadow the class property (continued
    from [Example 22-23](#attr_override_demo1))
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-24\. 实例属性不会遮蔽类属性（续自[示例 22-23](#attr_override_demo1))
- en: '[PRE27]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO19-1)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO19-1)'
- en: Reading `prop` directly from `Class` retrieves the property object itself, without
    running its getter method.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从 `Class` 中读取 `prop` 会检索属性对象本身，而不会运行其 getter 方法。
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO19-2)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO19-2)'
- en: Reading `obj.prop` executes the property getter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 读取 `obj.prop` 执行属性的 getter。
- en: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO19-3)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO19-3)'
- en: Trying to set an instance `prop` attribute fails.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试设置实例 `prop` 属性失败。
- en: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO19-4)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO19-4)'
- en: Putting `'prop'` directly in the `obj.__dict__` works.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将 `'prop'` 放入 `obj.__dict__` 中有效。
- en: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO19-5)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO19-5)'
- en: 'We can see that `obj` now has two instance attributes: `data` and `prop`.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `obj` 现在有两个实例属性：`data` 和 `prop`。
- en: '[![6](assets/6.png)](#co_dynamic_attributes_and_properties_CO19-6)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dynamic_attributes_and_properties_CO19-6)'
- en: However, reading `obj.prop` still runs the property getter. The property is
    not shadowed by an instance attribute.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，读取 `obj.prop` 仍然会运行属性的 getter。属性不会被实例属性遮蔽。
- en: '[![7](assets/7.png)](#co_dynamic_attributes_and_properties_CO19-7)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_dynamic_attributes_and_properties_CO19-7)'
- en: Overwriting `Class.prop` destroys the property object.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖 `Class.prop` 会销毁属性对象。
- en: '[![8](assets/8.png)](#co_dynamic_attributes_and_properties_CO19-8)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_dynamic_attributes_and_properties_CO19-8)'
- en: Now `obj.prop` retrieves the instance attribute. `Class.prop` is not a property
    anymore, so it no longer overrides `obj.prop`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `obj.prop` 检索实例属性。`Class.prop` 不再是属性，因此不再覆盖 `obj.prop`。
- en: As a final demonstration, we’ll add a new property to `Class`, and see it overriding
    an instance attribute. [Example 22-25](#attr_override_demo3) picks up where [Example 22-24](#attr_override_demo2)
    left off.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的演示，我们将向 `Class` 添加一个新属性，并看到它如何覆盖实例属性。[示例 22-25](#attr_override_demo3) 接续了[示例 22-24](#attr_override_demo2)。
- en: Example 22-25\. New class property shadows the existing instance attribute (continued
    from [Example 22-24](#attr_override_demo2))
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-25\. 新类属性遮蔽现有实例属性（续自[示例 22-24](#attr_override_demo2))
- en: '[PRE28]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO20-1)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO20-1)'
- en: '`obj.data` retrieves the instance `data` attribute.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj.data` 检索实例 `data` 属性。'
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO20-2)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO20-2)'
- en: '`Class.data` retrieves the class `data` attribute.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`Class.data` 检索类 `data` 属性。'
- en: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO20-3)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO20-3)'
- en: Overwrite `Class.data` with a new property.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 用新属性覆盖 `Class.data`。
- en: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO20-4)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO20-4)'
- en: '`obj.data` is now shadowed by the `Class.data` property.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj.data` 现在被 `Class.data` 属性遮蔽。'
- en: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO20-5)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO20-5)'
- en: Delete the property.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 删除属性。
- en: '[![6](assets/6.png)](#co_dynamic_attributes_and_properties_CO20-6)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dynamic_attributes_and_properties_CO20-6)'
- en: '`obj.data` now reads the instance `data` attribute again.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`obj.data` 现在再次读取实例 `data` 属性。'
- en: The main point of this section is that an expression like `obj.data` does not
    start the search for `data` in `obj`. The search actually starts at `obj.__class__`,
    and only if there is no property named `data` in the class, Python looks in the
    `obj` instance itself. This applies to *overriding descriptors* in general, of
    which properties are just one example. Further treatment of descriptors must wait
    for [Chapter 23](ch23.html#attribute_descriptors).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主要观点是，像 `obj.data` 这样的表达式并不会从 `obj` 开始搜索 `data`。搜索实际上从 `obj.__class__` 开始，只有在类中没有名为
    `data` 的属性时，Python 才会在 `obj` 实例本身中查找。这适用于一般的*覆盖描述符*，其中属性只是一个例子。对描述符的进一步处理必须等到[第
    23 章](ch23.html#attribute_descriptors)。
- en: Now back to properties. Every Python code unit—modules, functions, classes,
    methods—can have a docstring. The next topic is how to attach documentation to
    properties.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到属性。每个 Python 代码单元——模块、函数、类、方法——都可以有一个文档字符串。下一个主题是如何将文档附加到属性上。
- en: Property Documentation
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性文档
- en: When tools such as the console `help()` function or IDEs need to display the
    documentation of a property, they extract the information from the `__doc__` attribute
    of the property.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当工具如控制台的 `help()` 函数或 IDE 需要显示属性的文档时，它们会从属性的 `__doc__` 属性中提取信息。
- en: 'If used with the classic call syntax, `property` can get the documentation
    string as the `doc` argument:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与经典调用语法一起使用，`property` 可以将文档字符串作为 `doc` 参数：
- en: '[PRE29]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The docstring of the getter method—the one with the `@property` decorator itself—is
    used as the documentation of the property as a whole. [Figure 22-1](#help_foo_screens)
    shows the help screens generated from the code in [Example 22-26](#ex_foo_property_doc).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: getter 方法的文档字符串——带有 `@property` 装饰器本身——被用作整个属性的文档。[图 22-1](#help_foo_screens)
    展示了从[示例 22-26](#ex_foo_property_doc)中的代码生成的帮助屏幕。
- en: '![Screenshots of the Python console](assets/flpy_2201.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![Python控制台的屏幕截图](assets/flpy_2201.png)'
- en: Figure 22-1\. Screenshots of the Python console when issuing the commands `help(Foo.bar)`
    and `help(Foo)`. Source code is in [Example 22-26](#ex_foo_property_doc).
  id: totrans-305
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图22-1\. Python控制台的屏幕截图，当发出命令 `help(Foo.bar)` 和 `help(Foo)` 时。源代码在[示例 22-26](#ex_foo_property_doc)中。
- en: Example 22-26\. Documentation for a property
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-26\. 属性的文档
- en: '[PRE30]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that we have these property essentials covered, let’s go back to the issue
    of protecting both the `weight` and `price` attributes of `LineItem` so they only
    accept values greater than zero—but without implementing two nearly identical
    pairs of getters/setters by hand.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了这些属性的基本要点，让我们回到保护 `LineItem` 的 `weight` 和 `price` 属性只接受大于零的值的问题上来，但不需要手动实现两个几乎相同的
    getter/setter 对。
- en: Coding a Property Factory
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写属性工厂
- en: 'We’ll create a factory to create `quantity` properties—so named because the
    managed attributes represent quantities that can’t be negative or zero in the
    application. [Example 22-27](#lineitem_class_v2prop_class) shows the clean look
    of the `LineItem` class using two instances of `quantity` properties: one for
    managing the `weight` attribute, the other for `price`.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个工厂来创建 `quantity` 属性，因为受管属性代表应用程序中不能为负或零的数量。[示例 22-27](#lineitem_class_v2prop_class)
    展示了 `LineItem` 类使用两个 `quantity` 属性实例的清晰外观：一个用于管理 `weight` 属性，另一个用于 `price`。
- en: 'Example 22-27\. bulkfood_v2prop.py: the `quantity` property factory in use'
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-27\. bulkfood_v2prop.py：使用 `quantity` 属性工厂
- en: '[PRE31]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO21-1)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO21-1)'
- en: Use the factory to define the first custom property, `weight`, as a class attribute.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂定义第一个自定义属性 `weight` 作为类属性。
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO21-2)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO21-2)'
- en: This second call builds another custom property, `price`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这第二次调用构建了另一个自定义属性 `price`。
- en: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO21-3)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO21-3)'
- en: Here the property is already active, making sure a negative or `0` `weight`
    is rejected.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这里属性已经激活，确保拒绝负数或 `0` 的 `weight`。
- en: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO21-4)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO21-4)'
- en: The properties are also in use here, retrieving the values stored in the instance.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性也在此处使用，检索存储在实例中的值。
- en: 'Recall that properties are class attributes. When building each `quantity`
    property, we need to pass the name of the `LineItem` attribute that will be managed
    by that specific property. Having to type the word `weight` twice in this line
    is unfortunate:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住属性是类属性。在构建每个 `quantity` 属性时，我们需要传递将由该特定属性管理的 `LineItem` 属性的名称。在这一行中不得不两次输入单词
    `weight` 是不幸的：
- en: '[PRE32]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But avoiding that repetition is complicated because the property has no way
    of knowing which class attribute name will be bound to it. Remember: the righthand
    side of an assignment is evaluated first, so when `quantity()` is invoked, the
    `weight` class attribute doesn’t even exist.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 但避免重复是复杂的，因为属性无法知道将绑定到它的类属性名��。记住：赋值语句的右侧首先被评估，因此当调用 `quantity()` 时，`weight`
    类属性甚至不存在。
- en: Note
  id: totrans-324
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Improving the `quantity` property so that the user doesn’t need to retype the
    attribute name is a nontrivial metaprogramming problem. We’ll solve that problem
    in [Chapter 23](ch23.html#attribute_descriptors).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 改进 `quantity` 属性，使用户无需重新输入属性名称是一个非常棘手的元编程问题。我们将在[第23章](ch23.html#attribute_descriptors)中解决这个问题。
- en: '[Example 22-28](#lineitem_class_v2prop) lists the implementation of the `quantity`
    property factory.^([11](ch22.html#idm46582374317840))'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22-28](#lineitem_class_v2prop) 列出了 `quantity` 属性工厂的实现。^([11](ch22.html#idm46582374317840))'
- en: 'Example 22-28\. bulkfood_v2prop.py: the `quantity` property factory'
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-28\. bulkfood_v2prop.py：`quantity` 属性工厂
- en: '[PRE33]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO22-1)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO22-1)'
- en: The `storage_name` argument determines where the data for each property is stored;
    for the `weight`, the storage name will be `'weight'`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`storage_name` 参数确定每个属性的数据存储位置；对于 `weight`，存储名称将是 `''weight''`。'
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO22-2)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO22-2)'
- en: The first argument of the `qty_getter` could be named `self`, but that would
    be strange because this is not a class body; `instance` refers to the `LineItem`
    instance where the attribute will be stored.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`qty_getter` 的第一个参数可以命名为 `self`，但这将很奇怪，因为这不是一个类体；`instance` 指的是将存储属性的 `LineItem`
    实例。'
- en: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO22-3)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dynamic_attributes_and_properties_CO22-3)'
- en: '`qty_getter` references `storage_name`, so it will be preserved in the closure
    of this function; the value is retrieved directly from the `instance.__dict__`
    to bypass the property and avoid an infinite recursion.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`qty_getter` 引用 `storage_name`，因此它将在此函数的闭包中保留；值直接从 `instance.__dict__` 中检索，以绕过属性并避免无限递归。'
- en: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO22-4)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dynamic_attributes_and_properties_CO22-4)'
- en: '`qty_setter` is defined, also taking `instance` as first argument.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`qty_setter` 被定义，同时将 `instance` 作为第一个参数。'
- en: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO22-5)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dynamic_attributes_and_properties_CO22-5)'
- en: The `value` is stored directly in the `instance.__dict__`, again bypassing the
    property.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`value` 直接存储在 `instance.__dict__` 中，再次绕过属性。'
- en: '[![6](assets/6.png)](#co_dynamic_attributes_and_properties_CO22-6)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dynamic_attributes_and_properties_CO22-6)'
- en: Build a custom property object and return it.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自定义属性对象并返回它。
- en: The bits of [Example 22-28](#lineitem_class_v2prop) that deserve careful study
    revolve around the `storage_name` variable. When you code each property in the
    traditional way, the name of the attribute where you will store a value is hardcoded
    in the getter and setter methods. But here, the `qty_getter` and `qty_setter`
    functions are generic, and they depend on the `storage_name` variable to know
    where to get/set the managed attribute in the instance `__dict__`. Each time the
    `quantity` factory is called to build a property, the `storage_name` must be set
    to a unique value.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 值得仔细研究的 [示例 22-28](#lineitem_class_v2prop) 部分围绕着 `storage_name` 变量展开。当你以传统方式编写每个属性时，在
    getter 和 setter 方法中硬编码了存储值的属性名称。但在这里，`qty_getter` 和 `qty_setter` 函数是通用的，它们依赖于
    `storage_name` 变量来知道在实例 `__dict__` 中获取/设置托管属性的位置。每次调用 `quantity` 工厂来构建属性时，`storage_name`
    必须设置为一个唯一的值。
- en: The functions `qty_getter` and `qty_setter` will be wrapped by the `property`
    object created in the last line of the factory function. Later, when called to
    perform their duties, these functions will read the `storage_name` from their
    closures to determine where to retrieve/store the managed attribute values.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `qty_getter` 和 `qty_setter` 将被工厂函数最后一行创建的 `property` 对象包装。稍后，当调用执行它们的职责时，这些函数将从它们的闭包中读取
    `storage_name`，以确定从哪里检索/存储托管属性值。
- en: In [Example 22-29](#lineitem_class_v2prop_demo), I create and inspect a `LineItem`
    instance, exposing the storage attributes.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 22-29](#lineitem_class_v2prop_demo) 中，我创建并检查一个 `LineItem` 实例，暴露存储属性。
- en: 'Example 22-29\. bulkfood_v2prop.py: exploring properties and storage attributes'
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-29\. bulkfood_v2prop.py：探索属性和存储属性
- en: '[PRE34]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO23-1)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dynamic_attributes_and_properties_CO23-1)'
- en: Reading the `weight` and `price` through the properties shadowing the namesake
    instance attributes.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遮蔽同名实例属性的属性来读取 `weight` 和 `price`。
- en: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO23-2)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dynamic_attributes_and_properties_CO23-2)'
- en: 'Using `vars` to inspect the `nutmeg` instance: here we see the actual instance
    attributes used to store the values.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `vars` 检查 `nutmeg` 实例：这里我们看到用于存储值的实际实例属性。
- en: 'Note how the properties built by our factory leverage the behavior described
    in [“Properties Override Instance Attributes”](#prop_override_instance): the `weight`
    property overrides the `weight` instance attribute so that every reference to
    `self.weight` or `nutmeg.weight` is handled by the property functions, and the
    only way to bypass the property logic is to access the instance `__dict__` directly.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的工厂构建的属性如何利用 [“属性覆盖实例属性”](#prop_override_instance) 中描述的行为：`weight` 属性覆盖了
    `weight` 实例属性，以便每个对 `self.weight` 或 `nutmeg.weight` 的引用都由属性函数处理，而绕过属性逻辑的唯一方法是直接访问实例
    `__dict__`。
- en: 'The code in [Example 22-28](#lineitem_class_v2prop) may be a bit tricky, but
    it’s concise: it’s identical in length to the decorated getter/setter pair defining
    just the `weight` property in [Example 22-21](#lineitem_class_v2). The `LineItem`
    definition in [Example 22-27](#lineitem_class_v2prop_class) looks much better
    without the noise of the getter/setters.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22-28](#lineitem_class_v2prop) 中的代码可能有点棘手，但很简洁：它的长度与仅定义 `weight` 属性的装饰的
    getter/setter 对相同，如 [示例 22-21](#lineitem_class_v2) 中所示。在 [示例 22-27](#lineitem_class_v2prop_class)
    中，`LineItem` 定义看起来更好，没有 getter/setter 的干扰。'
- en: In a real system, that same kind of validation may appear in many fields, across
    several classes, and the `quantity` factory would be placed in a utility module
    to be used over and over again. Eventually that simple factory could be refactored
    into a more extensible descriptor class, with specialized subclasses performing
    different validations. We’ll do that in [Chapter 23](ch23.html#attribute_descriptors).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真实的系统中，同样类型的验证可能出现在许多字段中，跨越几个类，并且 `quantity` 工厂将被放置在一个实用模块中，以便反复使用。最终，这个简单的工厂可以重构为一个更可扩展的描述符类，具有执行不同验证的专门子类。我们将在
    [第 23 章](ch23.html#attribute_descriptors) 中进行这样的操作。
- en: Now let us wrap up the discussion of properties with the issue of attribute
    deletion.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们结束对属性的讨论，转向属性删除的问题。
- en: Handling Attribute Deletion
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理属性删除
- en: 'We can use the `del` statement to delete not only variables, but also attributes:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `del` 语句来删除变量，也可以删除属性：
- en: '[PRE35]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In practice, deleting attributes is not something we do every day in Python,
    and the requirement to handle it with a property is even more unusual. But it
    is supported, and I can think of a silly example to demonstrate it.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，删除属性并不是我们在 Python 中每天都做的事情，而且要求使用属性处理它更加不寻常。但是它是被支持的，我可以想到一个愚蠢的例子来演示它。
- en: In a property definition, the `@my_property.deleter` decorator wraps the method
    in charge of deleting the attribute managed by the property. As promised, silly
    [Example 22-30](#ex_black_knight) is inspired by the scene with the Black Knight
    from *Monty Python and the Holy Grail*.^([12](ch22.html#idm46582374013824))
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性定义中，`@my_property.deleter` 装饰器包装了负责删除属性的方法。正如承诺的那样，愚蠢的 [示例 22-30](#ex_black_knight)
    受到了《Monty Python and the Holy Grail》中黑骑士场景的启发。^([12](ch22.html#idm46582374013824))
- en: Example 22-30\. blackknight.py
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-30\. blackknight.py
- en: '[PRE36]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The doctests in *blackknight.py* are in [Example 22-31](#demo_black_knight).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*blackknight.py* 中的文档测试在 [示例 22-31](#demo_black_knight) 中。'
- en: 'Example 22-31\. blackknight.py: doctests for [Example 22-30](#ex_black_knight)
    (the Black Knight never concedes defeat)'
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 22-31\. blackknight.py：[示例 22-30](#ex_black_knight) 的文档测试（黑骑士永不认输）
- en: '[PRE37]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Using the classic call syntax instead of decorators, the `fdel` argument configures
    the deleter function. For example, the `member` property would be coded like this
    in the body of the `BlackKnight` class:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用经典的调用语法而不是装饰器，`fdel` 参数配置了删除函数。例如，在 `BlackKnight` 类的主体中，`member` 属性将被编码为：
- en: '[PRE38]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you are not using a property, attribute deletion can also be handled by implementing
    the lower-level `__delattr__` special method, presented in [“Special Methods for
    Attribute Handling”](#special_methods_for_attr_sec). Coding a silly class with
    `__delattr__` is left as an exercise to the procrastinating reader.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用属性，属性删除也可以通过实现更低级的`__delattr__`特殊方法来处理，如[“属性处理的特殊方法”](#special_methods_for_attr_sec)中所述。编写一个带有`__delattr__`的愚蠢类留给拖延的读者作为练习。
- en: Properties are a powerful feature, but sometimes simpler or lower-level alternatives
    are preferable. In the final section of this chapter, we’ll review some of the
    core APIs that Python offers for dynamic attribute programming.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是一个强大的功能，但有时更简单或更低级的替代方案更可取。在本章的最后一节中，我们将回顾Python为动态属性编程提供的一些核心API。
- en: Essential Attributes and Functions for Attribute Handling
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理属性的基本属性和函数
- en: Throughout this chapter, and even before in the book, we’ve used some of the
    built-in functions and special methods Python provides for dealing with dynamic
    attributes. This section gives an overview of them in one place, because their
    documentation is scattered in the official docs.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，甚至在本书之前，我们已经使用了Python提供的一些用于处理动态属性的内置函数和特殊方法。本节将它们的概述放在一个地方，因为它们的文档分散在官方文档中。
- en: Special Attributes that Affect Attribute Handling
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响属性处理的特殊属性
- en: 'The behavior of many of the functions and special methods listed in the following
    sections depend on three special attributes:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 下面列出的许多函数和特殊方法的行为取决于三个特殊属性：
- en: '`__class__`'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`__class__`'
- en: A reference to the object’s class (i.e., `obj.__class__` is the same as `type(obj)`).
    Python looks for special methods such as `__getattr__` only in an object’s class,
    and not in the instances themselves.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的类的引用（即`obj.__class__`与`type(obj)`相同）。Python仅在对象的类中查找`__getattr__`等特殊方法，而不在实例本身中查找。
- en: '`__dict__`'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`__dict__`'
- en: A mapping that stores the writable attributes of an object or class. An object
    that has a `__dict__` can have arbitrary new attributes set at any time. If a
    class has a `__slots__` attribute, then its instances may not have a `__dict__`.
    See `__slots__` (next).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 存储对象或类的可写属性的映射。具有`__dict__`的对象可以随时设置任意新属性。如果一个类具有`__slots__`属性，则其实例可能没有`__dict__`。请参阅`__slots__`（下一节）。
- en: '`__slots__`'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`__slots__`'
- en: An attribute that may be defined in a class to save memory. `__slots__` is a
    `tuple` of strings naming the allowed attributes.^([13](ch22.html#idm46582373809952))
    If the `'__dict__'` name is not in `__slots__`, then the instances of that class
    will not have a `__dict__` of their own, and only the attributes listed in `__slots__`
    will be allowed in those instances. Recall [“Saving Memory with __slots__”](ch11.html#slots_section)
    for more.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在类中定义的属性，用于节省内存。`__slots__`是一个命名允许的属性的字符串`tuple`。^([13](ch22.html#idm46582373809952))
    如果`__slots__`中没有`'__dict__'`名称，那么该类的实例将不会有自己的`__dict__`，并且只允许在这些实例中列出的属性。更多信息请参阅[“使用__slots__节省内存”](ch11.html#slots_section)。
- en: Built-In Functions for Attribute Handling
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于属性处理的内置函数
- en: 'These five built-in functions perform object attribute reading, writing, and
    introspection:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个内置函数执行对象属性的读取、写入和内省：
- en: '`dir([object])`'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`dir([object])`'
- en: Lists most attributes of the object. The [official docs](https://fpy.li/22-18)
    say `dir` is intended for interactive use so it does not provide a comprehensive
    list of attributes, but an “interesting” set of names. `dir` can inspect objects
    implemented with or without a `__dict__`. The `__dict__` attribute itself is not
    listed by `dir`, but the `__dict__` keys are listed. Several special attributes
    of classes, such as `__mro__`, `__bases__`, and `__name__`, are not listed by
    `dir` either. You can customize the output of `dir` by implementing the `__dir__`
    special method, as we saw in [Example 22-4](#ex_explore0). If the optional `object`
    argument is not given, `dir` lists the names in the current scope.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 列出对象的大多数属性。[官方文档](https://fpy.li/22-18)说`dir`用于交互使用，因此它不提供属性的全面列表，而是提供一个“有趣”的名称集。`dir`可以检查实现了`__dict__`或未实现`__dict__`的对象。`dir`本身不列出`__dict__`属性，但列出`__dict__`键。类的几个特殊属性，如`__mro__`、`__bases__`和`__name__`，也不被`dir`列出。您可以通过实现`__dir__`特殊方法来自定义`dir`的输出，就像我们在[��例22-4](#ex_explore0)中看到的那样。如果未提供可选的`object`参数，则`dir`列出当前范围中的名称。
- en: '`getattr(object, name[, default])`'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`getattr(object, name[, default])`'
- en: Gets the attribute identified by the `name` string from the `object`. The main
    use case is to retrieve attributes (or methods) whose names we don’t know beforehand.
    This may fetch an attribute from the object’s class or from a superclass. If no
    such attribute exists, `getattr` raises `AttributeError` or returns the `default`
    value, if given. One great example of using `gettatr` is in the [`Cmd.onecmd`
    method](https://fpy.li/22-19) in the `cmd` package of the standard library, where
    it is used to get and execute a user-defined command.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 从`object`中获取由`name`字符串标识的属性。主要用例是检索我们事先不知道的属性（或方法）。这可能会从对象的类或超类中获取属性。如果没有这样的属性存在，则`getattr`会引发`AttributeError`或返回`default`值（如果给定）。一个很好的使用`getattr`的例子是在标准库的`cmd`包中的[`Cmd.onecmd`方法](https://fpy.li/22-19)中，它用于获取和执行用户定义的命令。
- en: '`hasattr(object, name)`'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasattr(object, name)`'
- en: 'Returns `True` if the named attribute exists in the `object`, or can be somehow
    fetched through it (by inheritance, for example). The [documentation](https://fpy.li/22-20)
    explains: “This is implemented by calling getattr(object, name) and seeing whether
    it raises an AttributeError or not.”'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命名属性存在于`object`中，或者可以通过`object`（例如通过继承）获取，则返回`True`。[文档](https://fpy.li/22-20)解释说：“这是通过调用getattr(object,
    name)并查看它是否引发AttributeError来实现的。”
- en: '`setattr(object, name, value)`'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`setattr(object, name, value)`'
- en: Assigns the `value` to the named attribute of `object`, if the `object` allows
    it. This may create a new attribute or overwrite an existing one.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`object`允许，将`value`分配给`object`的命名属性。这可能会创建一个新属性或覆盖现有属性。
- en: '`vars([object])`'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`vars([object])`'
- en: 'Returns the `__dict__` of `object`; `vars` can’t deal with instances of classes
    that define `__slots__` and don’t have a `__dict__` (contrast with `dir`, which
    handles such instances). Without an argument, `vars()` does the same as `locals()`:
    returns a `dict` representing the local scope.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`object`的`__dict__`；`vars`无法处理定义了`__slots__`且没有`__dict__`的类的实例（与`dir`相反，后者处理这些实例）。如果没有参数，`vars()`与`locals()`执行相同的操作：返回表示局部作用域的`dict`。
- en: Special Methods for Attribute Handling
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于属性处理的特殊方法
- en: When implemented in a user-defined class, the special methods listed here handle
    attribute retrieval, setting, deletion, and listing.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当在用户定义的类中实现时，这里列出的特殊方法处理属性的检索、设置、删除和列出。
- en: Attribute access using either dot notation or the built-in functions `getattr`,
    `hasattr`, and `setattr` triggers the appropriate special methods listed here.
    Reading and writing attributes directly in the instance `__dict__` does not trigger
    these special methods—and that’s the usual way to bypass them if needed.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 使用点符号表示法或内置函数`getattr`、`hasattr`和`setattr`访问属性会触发这里列出的适当的特殊方法。直接在实例`__dict__`中读取和写入属性不会触发这些特殊方法——这是需要绕过它们的常用方式。
- en: 'Section [“3.3.11\. Special method lookup”](https://fpy.li/22-21) of the “Data
    model” chapter warns:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 章节[“3.3.11\. 特殊方法查找”](https://fpy.li/22-21)中的“数据模型”一章警告：
- en: For custom classes, implicit invocations of special methods are only guaranteed
    to work correctly if defined on an object’s type, not in the object’s instance
    dictionary.
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于自定义类，只有在对象的类型上定义了特殊方法时，隐式调用特殊方法才能保证正确工作，而不是在对象的实例字典中定义。
- en: In other words, assume that the special methods will be retrieved on the class
    itself, even when the target of the action is an instance. For this reason, special
    methods are not shadowed by instance attributes with the same name.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，假设特���方法将在类本身上检索，即使操作的目标是实例。因此，特殊方法不会被具有相同名称的实例属性遮蔽。
- en: In the following examples, assume there is a class named `Class`, `obj` is an
    instance of `Class`, and `attr` is an attribute of `obj`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，假设有一个名为`Class`的类，`obj`是`Class`的一个实例，`attr`是`obj`的一个属性。
- en: For every one of these special methods, it doesn’t matter if the attribute access
    is done using dot notation or one of the built-in functions listed in [“Built-In
    Functions for Attribute Handling”](#bif_attribute_handling). For example, both
    `obj.attr` and `getattr(obj, 'attr', 42)` trigger `Class.__getattribute__(obj,
    'attr')`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些特殊方法中的每一个，无论是使用点符号表示法还是[“用于属性处理的内置函数”](#bif_attribute_handling)中列出的内置函数之一，都没有关系。例如，`obj.attr`和`getattr(obj,
    'attr', 42)`都会触发`Class.__getattribute__(obj, 'attr')`。
- en: '`__delattr__(self, name)`'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`__delattr__(self, name)`'
- en: Always called when there is an attempt to delete an attribute using the `del`
    statement; e.g., `del obj.attr` triggers `Class.__delattr__(obj, 'attr')`. If
    `attr` is a property, its deleter method is never called if the class implements
    `__delattr__`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试使用`del`语句删除属性时始终调用；例如，`del obj.attr`触发`Class.__delattr__(obj, 'attr')`。如果`attr`是一个属性，则如果类实现了`__delattr__`，则其删除方法永远不会被调用。
- en: '`__dir__(self)`'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`__dir__(self)`'
- en: Called when `dir` is invoked on the object, to provide a listing of attributes;
    e.g., `dir(obj)` triggers `Class.__dir__(obj)`. Also used by tab-completion in
    all modern Python consoles.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象上调用`dir`时调用，以提供属性列表；例如，`dir(obj)`触发`Class.__dir__(obj)`。在所有现代 Python 控制台中，也被用于制表完成。
- en: '`__getattr__(self, name)`'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getattr__(self, name)`'
- en: Called only when an attempt to retrieve the named attribute fails, after the
    `obj`, `Class`, and its superclasses are searched. The expressions `obj.no_such_attr`,
    `getattr(obj, 'no_such_attr')`, and `hasattr(obj, 'no_such_attr')` may trigger
    `Class.__getattr__(obj, 'no_such_attr')`, but only if an attribute by that name
    cannot be found in `obj` or in `Class` and its superclasses.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在尝试检索命名属性失败时调用，之后搜索`obj`、`Class`及其超类。表达式`obj.no_such_attr`、`getattr(obj, 'no_such_attr')`和`hasattr(obj,
    'no_such_attr')`可能会触发`Class.__getattr__(obj, 'no_such_attr')`，但仅当在`obj`或`Class`及其超类中找不到该名称的属性时。
- en: '`__getattribute__(self, name)`'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getattribute__(self, name)`'
- en: Always called when there is an attempt to retrieve the named attribute directly
    from Python code (the interpreter may bypass this in some cases, for example,
    to get the `__repr__` method). Dot notation and the `getattr` and `hasattr` built-ins
    trigger this method. `__getattr__` is only invoked after `__getattribute__`, and
    only when `__getattribute__` raises `AttributeError`. To retrieve attributes of
    the instance `obj` without triggering an infinite recursion, implementations of
    `__getattribute__` should use `super().__getattribute__(obj, name)`.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试直接从 Python 代码中检索命名属性时始终调用（解释器在某些情况下可能会绕过此方法，例如获取`__repr__`方法）。点符号表示法和`getattr`以及`hasattr`内置函数会触发此方法。`__getattr__`仅在`__getattribute__`之后调用，并且仅在`__getattribute__`引发`AttributeError`时才会调用。为了检索实例`obj`的属性而不触发无限递归，`__getattribute__`的实现应该使用`super().__getattribute__(obj,
    name)`。
- en: '`__setattr__(self, name, value)`'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`__setattr__(self, name, value)`'
- en: Always called when there is an attempt to set the named attribute. Dot notation
    and the `setattr` built-in trigger this method; e.g., both `obj.attr = 42` and
    `setattr(obj, 'attr', 42)` trigger `Class.__setattr__(obj, 'attr', 42)`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试设置命名属性时始终调用。点符号和`setattr`内置触发此方法；例如，`obj.attr = 42`和`setattr(obj, 'attr',
    42)`都会触发`Class.__setattr__(obj, 'attr', 42)`。
- en: Warning
  id: totrans-408
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: In practice, because they are unconditionally called and affect practically
    every attribute access, the `__getattribute__` and `__setattr__` special methods
    are harder to use correctly than `__getattr__`, which only handles nonexisting
    attribute names. Using properties or descriptors is less error prone than defining
    these special methods.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，因为它们被无条件调用并影响几乎每个属性访问，`__getattribute__`和`__setattr__`特殊方法比`__getattr__`更难正确使用，后者仅处理不存在的属性名称。使用属性或描述符比定义这些特殊方法更不容易出错。
- en: This concludes our dive into properties, special methods, and other techniques
    for coding dynamic attributes.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对属性、特殊方法和其他编写动态属性技术的探讨。
- en: Chapter Summary
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: We started our coverage of dynamic attributes by showing practical examples
    of simple classes to make it easier to deal with a JSON dataset. The first example
    was the `FrozenJSON` class that converted nested dicts and lists into nested `FrozenJSON`
    instances and lists of them. The `FrozenJSON` code demonstrated the use of the
    `__getattr__` special method to convert data structures on the fly, whenever their
    attributes were read. The last version of `FrozenJSON` showcased the use of the
    `__new__` constructor method to transform a class into a flexible factory of objects,
    not limited to instances of itself.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过展示简单类的实际示例来开始动态属性的覆盖。第一个示例是`FrozenJSON`类，它将嵌套的字典和列表转换为嵌套的`FrozenJSON`实例和它们的列表。`FrozenJSON`代码演示了使用`__getattr__`特殊方法在读取属性时动态转换数据结构。`FrozenJSON`的最新版本展示了使用`__new__`构造方法将一个类转换为灵活的对象工厂，不限于自身的实例。
- en: 'We then converted the JSON dataset to a `dict` storing instances of a `Record`
    class. The first rendition of `Record` was a few lines long and introduced the
    “bunch” idiom: using `self.__dict__.update(**kwargs)` to build arbitrary attributes
    from keyword arguments passed to `__init__`. The second iteration added the `Event`
    class, implementing automatic retrieval of linked records through properties.
    Computed property values sometimes require caching, and we covered a few ways
    of doing that.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将JSON数据集转换为存储`Record`类实例的`dict`。`Record`的第一个版本只有几行代码，并引入了“bunch”习惯用法：使用`self.__dict__.update(**kwargs)`从传递给`__init__`的关键字参数构建任意属性。第二次迭代添加了`Event`类，通过属性实现自动检索链接记录。计算属性值有时需要缓存，我们介绍了几种方法。
- en: 'After realizing that `@functools.cached_property` is not always applicable,
    we learned about an alternative: combining `@property` on top of `@functools.cache`,
    in that order.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在意识到`@functools.cached_property`并非总是适用后，我们了解了一种替代方法：按顺序将`@property`与`@functools.cache`结合使用。
- en: Coverage of properties continued with the `LineItem` class, where a property
    was deployed to protect a `weight` attribute from negative or zero values that
    make no business sense. After a deeper look at property syntax and semantics,
    we created a property factory to enforce the same validation on `weight` and `price`,
    without coding multiple getters and setters. The property factory leveraged subtle
    concepts—such as closures, and instance attribute overriding by properties—to
    provide an elegant generic solution using the same number of lines as a single
    hand-coded property definition.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的覆盖继续在`LineItem`类中进行，其中部署了一个属性来保护`weight`属性免受没有业务意义的负值或零值的影响。在更深入地了解属性语法和语义之后，我们创建了一个属性工厂，以强制在`weight`和`price`上执行相同的验证，而无需编写多个getter和setter。属性工厂利用了微妙的概念——如闭包和属性覆盖实例属性——以使用与手动编码的单个属性定义相同数量的行提供优雅的通用解决方案。
- en: Finally, we had a brief look at handling attribute deletion with properties,
    followed by an overview of the key special attributes, built-in functions, and
    special methods that support attribute metaprogramming in the core Python language.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要介绍了使用属性处理属性删除的方法，然后概述了核心Python语言中支持属性元编程的关键特殊属性、内置函数和特殊方法。
- en: Further Reading
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The official documentation for the attribute handling and introspection built-in
    functions is [Chapter 2, “Built-in Functions”](https://fpy.li/22-22) of *The Python
    Standard Library*. The related special methods and the `__slots__` special attribute
    are documented in *The Python Language Reference* in [“3.3.2\. Customizing attribute
    access”](https://fpy.li/22-23). The semantics of how special methods are invoked
    bypassing instances is explained in [“3.3.9\. Special method lookup”](https://fpy.li/22-24).
    In Chapter 4, “Built-in Types,” of *The Python Standard Library*, [“4.13\. Special
    Attributes”](https://fpy.li/22-25) covers `__class__` and `__dict__` attributes.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 属性处理和内省内置函数的官方文档位于*Python标准库*的[第2章，“内置函数”](https://fpy.li/22-22)中。相关的特殊方法和`__slots__`特殊属性在*Python语言参考*的[“3.3.2\.
    自定义属性访问”](https://fpy.li/22-23)中有文档。解释了绕过实例调用特殊方法的语义在[“3.3.9\. 特殊方法查找”](https://fpy.li/22-24)中。在*Python标准库*的第4章，“内置类型”中，[“4.13\.
    特殊属性”](https://fpy.li/22-25)涵盖了`__class__`和`__dict__`属性。
- en: '*[Python Cookbook](https://fpy.li/pycook3)*, 3rd ed., by David Beazley and
    Brian K. Jones (O’Reilly) has several recipes covering the topics of this chapter,
    but I will highlight three that are outstanding: “Recipe 8.8\. Extending a Property
    in a Subclass” addresses the thorny issue of overriding the methods inside a property
    inherited from a superclass; “Recipe 8.15\. Delegating Attribute Access” implements
    a proxy class showcasing most special methods from [“Special Methods for Attribute
    Handling”](#special_methods_for_attr_sec) in this book; and the awesome “Recipe
    9.21\. Avoiding Repetitive Property Methods,” which was the basis for the property
    factory function presented in [Example 22-28](#lineitem_class_v2prop).'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Python Cookbook](https://fpy.li/pycook3)*，第3版，作者David Beazley和Brian K. Jones（O’Reilly）包含了本章主题的几个示例，但我将重点介绍三个杰出的示例：“Recipe
    8.8\. 在子类中扩展属性”解决了从超类继承的属性内部方法覆盖的棘手问题；“Recipe 8.15\. 委托属性访问”实现了一个代理类，展示了本书中[“属性处理的特殊方法”](#special_methods_for_attr_sec)中的大多数特殊方法；以及令人印象深刻的“Recipe
    9.21\. 避免重复的属性方法”，这是在[示例 22-28](#lineitem_class_v2prop)中呈现的属性工厂函数的基础。'
- en: '*[Python in a Nutshell,](https://fpy.li/pynut3)* 3rd ed., by Alex Martelli,
    Anna Ravenscroft, and Steve Holden (O’Reilly) is rigorous and objective. They
    devote only three pages to properties, but that’s because the book follows an
    axiomatic presentation style: the preceding 15 pages or so provide a thorough
    description of the semantics of Python classes from the ground up, including descriptors,
    which are how properties are actually implemented under the hood. So by the time
    Martelli et al., get to properties, they pack a lot of insights in those three
    pages—including what I selected to open this chapter.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Python in a Nutshell,](https://fpy.li/pynut3)* 第三版，由 Alex Martelli, Anna
    Ravenscroft, 和 Steve Holden (O’Reilly) 是严谨和客观的。他们只用了三页来讨论属性，但这是因为该书遵循了公理化的展示风格：前面的
    15 页左右提供了对 Python 类语义的彻底描述，包括描述符，这是属性在幕后实际上是如何实现的。所以当 Martelli 等人讨论属性时，他们在这三页中包含了许多见解—包括我选择用来开启本章的内容。'
- en: 'Bertrand Meyer—quoted in the Uniform Access Principle definition in this chapter
    opening—pioneered the Design by Contract methodology, designed the Eiffel language,
    and wrote the excellent *Object-Oriented Software Construction*, 2nd ed. (Pearson).
    The first six chapters provide one of the best conceptual introductions to OO
    analysis and design I’ve seen. Chapter 11 presents Design by Contract, and Chapter
    35 offers Meyer’s assessments of some influential object-oriented languages: Simula,
    Smalltalk, CLOS (the Common Lisp Object System), Objective-C, C++, and Java, with
    brief comments on some others. Only in the last page of the book does he reveal
    that the highly readable “notation” he uses as pseudocode is Eiffel.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Bertrand Meyer—在本章开头引用的统一访问原则定义中—开创了契约式设计方法，设计了 Eiffel 语言，并撰写了优秀的 *面向对象软件构造*，第二版
    (Pearson)。前六章提供了我见过的最好的面向对象分析和设计的概念介绍之一。第 11 章介绍了契约式设计，第 35 章提供了 Meyer 对一些有影响力的面向对象语言的评估：Simula、Smalltalk、CLOS
    (Common Lisp Object System)、Objective-C、C++ 和 Java，并简要评论了其他一些语言。直到书的最后一页，他才透露他所使用的易读的伪代码“符号”是
    Eiffel。
- en: ^([1](ch22.html#idm46582379330800-marker)) Alex Martelli, Anna Ravenscroft,
    and Steve Holden, *[Python in a Nutshell,](https://fpy.li/pynut3)* 3rd ed. (O’Reilly),
    p. 123.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch22.html#idm46582379330800-marker)) Alex Martelli, Anna Ravenscroft,
    和 Steve Holden, *[Python in a Nutshell,](https://fpy.li/pynut3)* 第三版 (O’Reilly),
    第 123 页。
- en: ^([2](ch22.html#idm46582379323104-marker)) Bertrand Meyer, *Object-Oriented
    Software Construction*, 2nd ed. (Pearson), p. 57.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch22.html#idm46582379323104-marker)) Bertrand Meyer, *面向对象软件构造*，第二版 (Pearson)，第
    57 页。
- en: ^([3](ch22.html#idm46582379300144-marker)) OSCON—O’Reilly Open Source Conference—was
    a casualty of the COVID-19 pandemic. The original 744 KB JSON file I used for
    these examples is no longer online as of January 10, 2021\. You’ll find a copy
    of [*osconfeed.json* in the example code repository](https://fpy.li/22-1).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch22.html#idm46582379300144-marker)) OSCON—O’Reilly 开源大会—成为了 COVID-19
    大流行的牺牲品。我用于这些示例的原始 744 KB JSON 文件在 2021 年 1 月 10 日之后不再在线。你可以在[*osconfeed.json*
    的示例代码库](https://fpy.li/22-1)中找到一份副本。
- en: ^([4](ch22.html#idm46582378756624-marker)) Two examples are [`AttrDict`](https://fpy.li/22-2)
    and [`addict`](https://fpy.li/22-3).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch22.html#idm46582378756624-marker)) 两个例子分别是[`AttrDict`](https://fpy.li/22-2)
    和 [`addict`](https://fpy.li/22-3)。
- en: ^([5](ch22.html#idm46582378146288-marker)) The expression `self.__data[name]`
    is where a `KeyError` exception may occur. Ideally, it should be handled and an
    `AttributeError` raised instead, because that’s what is expected from `__getattr__`.
    The diligent reader is invited to code the error handling as an exercise.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch22.html#idm46582378146288-marker)) 表达式 `self.__data[name]` 是可能发生 `KeyError`
    异常的地方。理想情况下，应该处理它并引发 `AttributeError`，因为这是从 `__getattr__` 中期望的。勤奋的读者被邀请将错误处理编码为练习。
- en: ^([6](ch22.html#idm46582378128320-marker)) The source of the data is JSON, and
    the only collection types in JSON data are `dict` and `list`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch22.html#idm46582378128320-marker)) 数据的来源是 JSON，而 JSON 数据中唯一的集合类型是 `dict`
    和 `list`。
- en: ^([7](ch22.html#idm46582376904944-marker)) By the way, `Bunch` is the name of
    the class used by Alex Martelli to share this tip in a recipe from 2001 titled
    [“The simple but handy ‘collector of a bunch of named stuff’ class”](https://fpy.li/22-4).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch22.html#idm46582376904944-marker)) 顺便说一句，`Bunch` 是 Alex Martelli 用来分享这个提示的类的名称，这个提示来自于
    2001 年的一篇名为[“简单但方便的‘一堆命名东西’类”的食谱](https://fpy.li/22-4)。
- en: ^([8](ch22.html#idm46582376098304-marker)) This is actually a downside of Meyer’s
    Uniform Access Principle, which I mentioned in the opening of this chapter. Read
    the optional [“Soapbox”](#properties_soapbox) if you’re interested in this discussion.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch22.html#idm46582376098304-marker)) 这实际上是 Meyer 的统一访问原则的一个缺点，我在本章开头提到过。如果你对这个讨论感兴趣，可以阅读可选的[“讲台”](#properties_soapbox)。
- en: '^([9](ch22.html#idm46582375804496-marker)) Source: [@functools.cached_property](https://fpy.li/22-9)
    documentation. I know Raymond Hettinger authored this explanation because he wrote
    it as a response to an issue I filed: [bpo42781—functools.cached_property docs
    should explain that it is non-overriding](https://fpy.li/22-11). Hettinger is
    a major contributor to the official Python docs and standard library. He also
    wrote the excellent [“Descriptor HowTo Guide”](https://fpy.li/22-12), a key resource
    for [Chapter 23](ch23.html#attribute_descriptors).'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch22.html#idm46582375804496-marker)) 来源：[@functools.cached_property](https://fpy.li/22-9)
    文档。我知道 Raymond Hettinger 撰写了这份解释，因为他是作为我提出问题的回应而撰写的：[bpo42781—functools.cached_property
    文档应该解释它是非覆盖的](https://fpy.li/22-11)。Hettinger 是官方 Python 文档和标准库的主要贡献者。他还撰写了优秀的[“描述符指南”](https://fpy.li/22-12)，这是[第
    23 章](ch23.html#attribute_descriptors)的重要资源。
- en: ^([10](ch22.html#idm46582375484704-marker)) Direct quote by Jeff Bezos in the
    *Wall Street Journal* story, [“Birth of a Salesman”](https://fpy.li/22-16) (October
    15, 2011). Note that as of 2021, you need a subscription to read the article.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch22.html#idm46582375484704-marker)) 杰夫·贝佐斯在 *华尔街日报* 的报道[“一个推销员的诞生”](https://fpy.li/22-16)中的直接引用（2011
    年 10 月 15 日）。请注意，截至 2021 年，您需要订阅才能阅读这篇文章。
- en: ^([11](ch22.html#idm46582374317840-marker)) This code is adapted from “Recipe
    9.21\. Avoiding Repetitive Property Methods” from *[Python Cookbook](https://fpy.li/pycook3)*,
    3rd ed., by David Beazley and Brian K. Jones (O’Reilly).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch22.html#idm46582374317840-marker)) 这段代码改编自《Python Cookbook》第3版的“食谱9.21。避免重复的属性方法”，作者是David
    Beazley和Brian K. Jones（O’Reilly）。
- en: ^([12](ch22.html#idm46582374013824-marker)) The bloody scene is [available on
    Youtube](https://fpy.li/22-17) as I review this in October 2021.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch22.html#idm46582374013824-marker)) 这血腥场面在2021年10月我审阅时在Youtube上[可供观看](https://fpy.li/22-17)。
- en: ^([13](ch22.html#idm46582373809952-marker)) Alex Martelli points out that, although
    `__slots__` can be coded as a `list`, it’s better to be explicit and always use
    a `tuple`, because changing the list in the `__slots__` after the class body is
    processed has no effect, so it would be misleading to use a mutable sequence there.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch22.html#idm46582373809952-marker)) Alex Martelli指出，虽然`__slots__`可以编码为一个`list`，但最好明确地始终使用一个`tuple`，因为在类体被处理后更改`__slots__`中的列表没有效果，因此在那里使用可变序列会产生误导。
- en: ^([14](ch22.html#idm46582373662736-marker)) Alex Martelli, *Python in a Nutshell*,
    2nd ed. (O’Reilly), p. 101.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch22.html#idm46582373662736-marker)) Alex Martelli，《Python速查手册》，第2版（O’Reilly），第101页。
- en: ^([15](ch22.html#idm46582373624752-marker)) The reasons I am about to mention
    are given in the Dr. Dobbs Journal article titled [“Java’s new Considered Harmful”](https://fpy.li/22-30),
    by Jonathan Amsterdam and in “Consider static factory methods instead of constructors,”
    which is Item 1 of the award-winning book *Effective Java*, 3rd ed., by Joshua
    Bloch (Addison-Wesley).``````
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch22.html#idm46582373624752-marker)) 我即将提到的原因在《Dr. Dobbs Journal》的文章中提到，标题为[“Java的新特性有害”](https://fpy.li/22-30)，作者是Jonathan
    Amsterdam，以及在屡获殊荣的书籍*Effective Java*第3版的“考虑使用静态工厂方法代替构造函数”中，作者是Joshua Bloch（Addison-Wesley）。
