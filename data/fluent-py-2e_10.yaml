- en: Chapter 8\. Type Hints in Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。函数中的类型提示
- en: It should also be emphasized that **Python will remain a dynamically typed language,
    and the authors have no desire to ever make type hints mandatory, even by convention.**
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还应强调**Python将保持动态类型语言，并且作者从未希望通过约定使类型提示成为强制要求。**
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Guido van Rossum, Jukka Lehtosalo, and Łukasz Langa, PEP 484—Type Hints^([1](ch08.html#idm46582445964528))
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Guido van Rossum，Jukka Lehtosalo和Łukasz Langa，PEP 484—类型提示^([1](ch08.html#idm46582445964528))
- en: Type hints are the biggest change in the history of Python since the [unification
    of types and classes](https://fpy.li/descr101) in Python 2.2, released in 2001.
    However, type hints do not benefit all Python users equally. That’s why they should
    always be optional.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示是自2001年发布的Python 2.2中的[类型和类的统一](https://fpy.li/descr101)以来Python历史上最大的变化。然而，并非所有Python用户都同等受益于类型提示。这就是为什么它们应该始终是可选的。
- en: '[PEP 484—Type Hints](https://fpy.li/pep484) introduced syntax and semantics
    for explicit type declarations in function arguments, return values, and variables.
    The goal is to help developer tools find bugs in Python codebases via static analysis,
    i.e., without actually running the code through tests.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 484—类型提示](https://fpy.li/pep484)引入了函数参数、返回值和变量的显式类型声明的语法和语义。其目标是通过静态分析帮助开发人员工具在不实际运行代码测试的情况下发现Python代码库中的错误。'
- en: The main beneficiaries are professional software engineers using IDEs (Integrated
    Development Environments) and CI (Continuous Integration). The cost-benefit analysis
    that makes type hints attractive to that group does not apply to all users of
    Python.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 主要受益者是使用IDE（集成开发环境）和CI（持续集成）的专业软件工程师。使类型提示对该群体具有吸引力的成本效益分析并不适用于所有Python用户。
- en: Python’s user base is much wider than that. It includes scientists, traders,
    journalists, artists, makers, analysts, and students in many fields—among others.
    For most of them, the cost of learning type hints is likely higher—unless they
    already know a language with static types, subtyping, and generics. The benefits
    will be lower for many of those users, given how they interact with Python, and
    the smaller size of their codebases and teams—often “teams” of one. Python’s default
    dynamic typing is simpler and more expressive when writing code for exploring
    data and ideas, as in data science, creative computing, and learning,
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python的用户群比这个宽广得多。它包括科学家、交易员、记者、艺术家、制造商、分析师和许多领域的学生等。对于他们中的大多数人来说，学习类型提示的成本可能更高——除非他们已经了解具有静态类型、子类型和泛型的语言。对于许多这些用户来说，由于他们与Python的交互方式以及他们的代码库和团队的规模较小——通常是“一个人的团队”，因此收益会较低。Python的��认动态类型在编写用于探索数据和想法的代码时更简单、更具表现力，比如数据科学、创意计算和学习，
- en: This chapter focuses on Python’s type hints in function signatures. [Chapter 15](ch15.html#more_types_ch)
    explores type hints in the context of classes, and other `typing` module features.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍Python函数签名中的类型提示。[第15章](ch15.html#more_types_ch)探讨了类的上下文中的类型提示，以及其他`typing`模块功能。
- en: 'The major topics in this chapter are:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要主题包括：
- en: A hands-on introduction to gradual typing with Mypy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个关于使用 Mypy 逐渐类型化的实践介绍
- en: The complementary perspectives of duck typing and nominal typing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鸭子类型和名义类型的互补视角
- en: Overview of the main categories of types that can appear in annotations—this
    is about 60% of the chapter
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解中可能出现的主要类型类别概述——这大约占了本章的60%
- en: Type hinting variadic parameters (`*args`, `**kwargs`)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提示可变参数（`*args`，`**kwargs`）
- en: Limitations and downsides of type hints and static typing
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提示和静态类型化的限制和缺点
- en: What’s New in This Chapter
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的新内容
- en: This chapter is completely new. Type hints appeared in Python 3.5 after I wrapped
    up the first edition of *Fluent Python*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是全新的。类型提示出现在我完成第一版*流畅的Python*之后的Python 3.5中。
- en: Given the limitations of a static type system, the best idea of PEP 484 was
    to introduce a *gradual type system*. Let’s begin by defining what that means.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于静态类型系统的局限性，PEP 484的最佳想法是引入*逐渐类型系统*。让我们从定义这个概念开始。
- en: About Gradual Typing
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于逐渐类型化
- en: 'PEP 484 introduced a *gradual type system* to Python. Other languages with
    gradual type systems are Microsoft’s TypeScript, Dart (the language of the Flutter
    SDK, created by Google), and Hack (a dialect of PHP supported by Facebook’s HHVM
    virtual machine). The Mypy type checker itself started as a language: a gradually
    typed dialect of Python with its own interpreter. Guido van Rossum convinced the
    creator of Mypy, Jukka Lehtosalo, to make it a tool for checking annotated Python
    code.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 484向Python引入了*逐渐类型系统*。其他具有逐渐类型系统的语言包括微软的TypeScript、Dart（由Google创建的Flutter
    SDK的语言）和Hack（Facebook的HHVM虚拟机支持的PHP方言）。Mypy类型检查器本身起初是一种语言：一种逐渐类型化的Python方言，带有自己的解释器。Guido
    van Rossum说服了Mypy的创造者Jukka Lehtosalo，使其成为检查带注释的Python代码的工具。
- en: 'A gradual type system:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 逐渐类型系统：
- en: Is optional
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 是可选的
- en: By default, the type checker should not emit warnings for code that has no type
    hints. Instead, the type checker assumes the `Any` type when it cannot determine
    the type of an object. The `Any` type is considered compatible with all other
    types.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，类型检查器不应对没有类型提示的代码发出警告。相反，当无法确定对象类型时，类型检查器会假定`Any`类型。`Any`类型被认为与所有其他类型兼容。
- en: Does not catch type errors at runtime
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不会在运行时捕获类型错误
- en: Type hints are used by static type checkers, linters, and IDEs to raise warnings.
    They do not prevent inconsistent values from being passed to functions or assigned
    to variables at runtime.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型检查器、linter和IDE使用类型提示来发出警告。它们不能阻止在运行时将不一致的值传递给函数或分配给变量。
- en: Does not enhance performance
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不会增强性能
- en: Type annotations provide data that could, in theory, allow optimizations in
    the generated bytecode, but such optimizations are not implemented in any Python
    runtime that I am aware in of July 2021.^([2](ch08.html#idm46582445928816))
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注释提供的数据理论上可以允许在生成的字节码中进行优化，但截至2021年7月，我所知道的任何Python运行时都没有实现这样的优化。^([2](ch08.html#idm46582445928816))
- en: The best usability feature of gradual typing is that annotations are always
    optional.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步类型化最好的可用性特性是注释始终是可选的。
- en: With static type systems, most type constraints are easy to express, many are
    cumbersome, some are hard, and a few are impossible.^([3](ch08.html#idm46582445926464))
    You may very well write an excellent piece of Python code, with good test coverage
    and passing tests, but still be unable to add type hints that satisfy a type checker.
    That’s OK; just leave out the problematic type hints and ship it!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态类型系统，大多数类型约束很容易表达，许多很繁琐，一些很困难，而一些则是不可能的。^([3](ch08.html#idm46582445926464))
    你很可能会写出一段优秀的 Python 代码，具有良好的测试覆盖率和通过的测试，但仍然无法添加满足类型检查器的类型提示。没关系；只需省略有问题的类型提示并发布！
- en: 'Type hints are optional at all levels: you can have entire packages with no
    type hints, you can silence the type checker when you import one of those packages
    into a module where you use type hints, and you can add special comments to make
    the type checker ignore specific lines in your code.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示在所有级别都是可选的：你可以有完全没有类型提示的整个包，当你将其中一个这样的包导入到使用类型提示的模块时，你可以让类型检查器保持沉默，并且你可以添加特殊注释来让类型检查器忽略代码中特定的行。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Seeking 100% coverage of type hints is likely to stimulate type hinting without
    proper thought, only to satisfy the metric. It will also prevent teams from making
    the most of the power and flexibility of Python. Code without type hints should
    naturally be accepted when annotations would make an API less user-friendly, or
    unduly complicate its implementation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 寻求 100% 的类型提示覆盖可能会刺激没有经过适当思考的类型提示，只是为了满足指标。这也会阻止团队充分利用 Python 的强大和灵活性。当注释会使
    API 不够用户友好，或者不必要地复杂化其实现时，应该自然地接受没有类型提示的代码。
- en: Gradual Typing in Practice
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的逐步类型化
- en: Let’s see how gradual typing works in practice, starting with a simple function
    and gradually adding type hints to it, guided by Mypy.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看逐步类型化在实践中是如何工作的，从一个简单的函数开始，逐渐添加类型提示，由 Mypy 指导。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are several Python type checkers compatible with PEP 484, including Google’s
    [pytype](https://fpy.li/8-4), Microsoft’s [Pyright](https://fpy.li/8-5), Facebook’s
    [Pyre](https://fpy.li/8-6)—in addition to type checkers embedded in IDEs such
    as PyCharm. I picked [Mypy](https://fpy.li/mypy) for the examples because it’s
    the best known. However, one of the others may be a better fit for some projects
    or teams. Pytype, for example, is designed to handle codebases with no type hints
    and still provide useful advice. It is more lenient than Mypy, and can also generate
    annotations for your code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个与 PEP 484 兼容的 Python 类型检查器，包括 Google 的 [pytype](https://fpy.li/8-4)、Microsoft
    的 [Pyright](https://fpy.li/8-5)、Facebook 的 [Pyre](https://fpy.li/8-6)—以及嵌入在 IDE
    中的类型检查器，如 PyCharm。我选择了 [Mypy](https://fpy.li/mypy) 作为示例，因为它是最知名的。然而，其他类型检查器可能更适合某些项目或团队。例如，Pytype
    设计用于处理没有类型提示的代码库，并仍然提供有用的建议。它比 Mypy 更宽松，还可以为您的代码生成注释。
- en: 'We will annotate a `show_count` function that returns a string with a count
    and a singular or plural word, depending on the count:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为一个返回带有计数和单数或复数词的字符串的 `show_count` 函数添加注释：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Example 8-1](#msgs_no_hints) shows the source code of `show_count`, without
    annotations.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-1](#msgs_no_hints)展示了`show_count`的源代码，没有注释。'
- en: Example 8-1\. `show_count` from *messages.py* without type hints
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-1\. *messages.py* 中没有类型提示的 `show_count`
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Starting with Mypy
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Mypy 开始
- en: 'To begin type checking, I run the `mypy` command on the *messages.py* module:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始类型检查，我在 *messages.py* 模块上运行 `mypy` 命令：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Mypy with default settings finds no problem with [Example 8-1](#msgs_no_hints).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认设置的 Mypy 在 [示例 8-1](#msgs_no_hints) 中没有发现任何问题。
- en: Warning
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: I am using Mypy 0.910, the most recent release as I review this in July 2021.
    The Mypy [“Introduction”](https://fpy.li/8-7) warns that it “is officially beta
    software. There will be occasional changes that break backward compatibility.”
    Mypy is giving me at least one report that is not the same I got when I wrote
    this chapter in April 2020. By the time you read this, you may get different results
    than shown here.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用 Mypy 0.910，在我审阅这篇文章时是最新版本（2021 年 7 月）。Mypy 的 [“介绍”](https://fpy.li/8-7)
    警告说它“正式是测试版软件。偶尔会有破坏向后兼容性的更改。” Mypy 给我至少一个与我在 2020 年 4 月写这一章时不同的报告。当你阅读这篇文章时，你可能会得到与这里显示的不同的结果。
- en: If a function signature has no annotations, Mypy ignores it by default—unless
    configured otherwise.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数签名没有注释，Mypy 默认会忽略它—除非另有配置。
- en: For [Example 8-2](#msgs_test_no_hints), I also have `pytest` unit tests. This
    is the code in *messages_test.py*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 [示例 8-2](#msgs_test_no_hints)，我还有 `pytest` 单元测试。这是 *messages_test.py* 中的代码。
- en: Example 8-2\. *messages_test.py* without type hints
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-2\. *messages_test.py* 中没有类型提示
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now let’s add type hints, guided by Mypy.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们根据 Mypy 添加类型提示。
- en: Making Mypy More Strict
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使 Mypy 更严格
- en: The command-line option `--disallow-untyped-defs` makes Mypy flag any function
    definition that does not have type hints for all its parameters and for its return
    value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行选项 `--disallow-untyped-defs` 会使 Mypy 标记任何没有为所有参数和返回值添加类型提示的函数定义。
- en: 'Using `--disallow-untyped-defs` on the test file produces three errors and
    a note:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试文件上使用 `--disallow-untyped-defs` 会产生三个错误和一个注意：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For the first steps with gradual typing, I prefer to use another option: `--disallow-incomplete-defs`.
    Initially, it tells me nothing:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于逐步类型化的第一步，我更喜欢使用另一个选项：`--disallow-incomplete-defs`。最初，它对我毫无意义：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now I can add just the return type to `show_count` in *messages.py*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以只为 *messages.py* 中的 `show_count` 添加返回类型：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is enough to make Mypy look at it. Using the same command line as before
    to check *messages_test.py* will lead Mypy to look at *messages.py* again:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经足够让 Mypy 查看它。使用与之前相同的命令行检查 *messages_test.py* 将导致 Mypy 再次查看 *messages.py*：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now I can gradually add type hints function by function, without getting warnings
    about functions that I haven’t annotated. This is a fully annotated signature
    that satisfies Mypy:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以逐步为每个函数添加类型提示，而不会收到关于我没有注释的函数的警告。这是一个完全注释的签名，满足了 Mypy：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Instead of typing command-line options like `--disallow-incomplete-defs`, you
    can save your favorite as described in the [Mypy configuration file](https://fpy.li/8-8)
    documentation. You can have global settings and per-module settings. Here is a
    simple *mypy.ini* to get started:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与其像`--disallow-incomplete-defs`这样输入命令行选项，你可以按照[Mypy配置文件](https://fpy.li/8-8)文档中描述的方式保存你喜欢的选项。你可以有全局设置和每个模块的设置。以下是一个简单的*mypy.ini*示例：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A Default Parameter Value
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数值
- en: 'The `show_count` function in [Example 8-1](#msgs_no_hints) only works with
    regular nouns. If the plural can’t be spelled by appending an `''s''`, we should
    let the user provide the plural form, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-1](#msgs_no_hints)中的`show_count`函数只适用于常规名词。如果复数不能通过添加`''s''`来拼写，我们应该让用户提供复数形式，就像这样：'
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let’s do a little “type-driven development.” First we add a test that uses that
    third argument. Don’t forget to add the return type hint to the test function,
    otherwise Mypy will not check it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一点“类型驱动的开发”。首先我们添加一个使用第三个参数的测试。不要忘记为测试函数添加返回类型提示，否则Mypy将不会检查它。
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Mypy detects the error:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy检测到了错误：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now I edit `show_count`, adding the optional `plural` parameter in [Example 8-3](#msgs_optional_str_param).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我编辑`show_count`，在[示例 8-3](#msgs_optional_str_param)中添加了可选的`plural`参数。
- en: Example 8-3\. `showcount` from *hints_2/messages.py* with an optional parameter
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-3\. *hints_2/messages.py*中带有可选参数的`showcount`
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now Mypy reports “Success.”
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Mypy报告“成功”。
- en: Warning
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Here is one typing mistake that Python does not catch. Can you spot it?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个Python无法捕捉的类型错误。你能发现吗？
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Mypy’s error report is not very helpful:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy的错误报告并不是很有帮助：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The type hint for the `color` argument should be `color: str`. I wrote `color=str`,
    which is not an annotation: it sets the default value of `color` to `str`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`color`参数的类型提示应为`color: str`。我写成了`color=str`，这不是一个注释：它将`color`的默认值设置为`str`。'
- en: In my experience, it’s a common mistake and easy to overlook, especially in
    complicated type hints.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，这是一个常见的错误，很容易忽视，特别是在复杂的类型提示中。
- en: 'The following details are considered good style for type hints:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下细节被认为是类型提示的良好风格：
- en: No space between the parameter name and the `:`; one space after the `:`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数名和`:`之间没有空格；`:`后有一个空格
- en: Spaces on both sides of the `=` that precedes a default parameter value
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在默认参数值之前的`=`两侧留有空格
- en: On the other hand, PEP 8 says there should be no spaces around the `=` if there
    is no type hint for that particular parameter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，PEP 8表示如果对于特定参数没有类型提示，则`=`周围不应有空格。
- en: Using None as a Default
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`None`作为默认值
- en: In [Example 8-3](#msgs_optional_str_param), the parameter `plural` is annotated
    as `str`, and the default value is `''`, so there is no type conflict.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 8-3](#msgs_optional_str_param)中，参数`plural`被注释为`str`，默认值为`''`，因此没有类型冲突。
- en: 'I like that solution, but in other contexts `None` is a better default. If
    the optional parameter expects a mutable type, then `None` is the only sensible
    default—as we saw in [“Mutable Types as Parameter Defaults: Bad Idea”](ch06.html#mutable_default_parameter_sec).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢那个解决方案，但在其他情况下，`None`是更好的默认值。如果可选参数期望一个可变类型，那么`None`是唯一明智的默认值——正如我们在[“可变类型作为参数默认值：不好的主意”](ch06.html#mutable_default_parameter_sec)中看到的。
- en: 'To have `None` as the default for the `plural` parameter, here is what the
    signature would look like:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`None`作为`plural`参数的默认值，签名将如下所示：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s unpack that:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解开这个问题：
- en: '`Optional[str]` means `plural` may be a `str` or `None`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional[str]`表示`plural`可以是`str`或`None`。'
- en: You must explicitly provide the default value `= None`.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须明确提供默认值`= None`。
- en: 'If you don’t assign a default value to `plural`, the Python runtime will treat
    it as a required parameter. Remember: at runtime, type hints are ignored.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为`plural`分配默认值，Python运行时将把它视为必需参数。记住：在运行时，类型提示会被忽略。
- en: Note that we need to import `Optional` from the `typing` module. When importing
    types, it’s good practice to use the syntax `from typing import X` to reduce the
    length of the function signatures.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要从`typing`模块导入`Optional`。在导入类型时，使用语法`from typing import X`是一个好习惯，可以缩短函数签名的长度。
- en: Warning
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '`Optional` is not a great name, because that annotation does not make the parameter
    optional. What makes it optional is assigning a default value to the parameter.
    `Optional[str]` just means: the type of this parameter may be `str` or `NoneType`.
    In the Haskell and Elm languages, a similar type is named `Maybe`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`不是一个很好的名称，因为该注释并不使参数变为可选的。使其可选的是为参数分配默认值。`Optional[str]`只是表示：该参数的类型可以是`str`或`NoneType`。在Haskell和Elm语言中，类似的类型被命名为`Maybe`。'
- en: Now that we’ve had a first practical view of gradual typing, let’s consider
    what the concept of *type* means in practice.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初步了解了渐进类型，让我们考虑在实践中“类型”这个概念意味着什么。
- en: Types Are Defined by Supported Operations
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型由支持的操作定义
- en: There are many definitions of the concept of type in the literature. Here we
    assume that type is a set of values and a set of functions that one can apply
    to these values.
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 文献中对类型概念有许多定义。在这里，我们假设类型是一组值和一组可以应用于这些值的函数。
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: PEP 483—The Theory of Type Hints
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: PEP 483—类型提示的理论
- en: In practice, it’s more useful to consider the set of supported operations as
    the defining characteristic of a type.^([4](ch08.html#idm46582445234336))
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，将支持的操作集合视为类型的定义特征更有用。^([4](ch08.html#idm46582445234336))
- en: For example, from the point of view of applicable operations, what are the valid
    types for `x` in the following function?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从适用操作的角度来看，在以下函数中`x`的有效类型是什么？
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `x` parameter type may be numeric (`int`, `complex`, `Fraction`, `numpy.uint32`,
    etc.) but it may also be a sequence (`str`, `tuple`, `list`, `array`), an N-dimensional
    `numpy.array`, or any other type that implements or inherits a `__mul__` method
    that accepts an `int` argument.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`参数类型可以是数值型（`int`、`complex`、`Fraction`、`numpy.uint32`等），但也可以是序列（`str`、`tuple`、`list`、`array`）、N维`numpy.array`，或者任何实现或继承接受`int`参数的`__mul__`方法的其他类型。'
- en: 'However, consider this annotated `double`. Please ignore the missing return
    type for now, let’s focus on the parameter type:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请考虑这个带注释的 `double`。现在请忽略缺失的返回类型，让我们专注于参数类型：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A type checker will reject that code. If you tell Mypy that `x` is of type `abc.Sequence`,
    it will flag `x * 2` as an error because the [`Sequence` ABC](https://fpy.li/8-13)
    does not implement or inherit the `__mul__` method. At runtime, that code will
    work with concrete sequences such as `str`, `tuple`, `list`, `array`, etc., as
    well as numbers, because at runtime the type hints are ignored. But the type checker
    only cares about what is explicitly declared, and `abc.Sequence` has no `__mul__`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器将拒绝该代码。如果告诉 Mypy `x` 的类型是 `abc.Sequence`，它将标记 `x * 2` 为错误，因为 [`Sequence`
    ABC](https://fpy.li/8-13) 没有实现或继承 `__mul__` 方法。在运行时，该代码将与具体序列（如 `str`、`tuple`、`list`、`array`
    等）以及数字一起工作，因为在运行时会忽略类型提示。但类型检查器只关心显式声明的内容，`abc.Sequence` 没有 `__mul__`。
- en: 'That’s why the title of this section is “Types Are Defined by Supported Operations.”
    The Python runtime accepts any object as the `x` argument for both versions of
    the `double` function. The computation `x * 2` may work, or it may raise `TypeError`
    if the operation is not supported by `x`. In contrast, Mypy will declare `x *
    2` as wrong while analyzing the annotated `double` source code, because it’s an
    unsupported operation for the declared type: `x: abc.Sequence`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '这就是为什么这一节的标题是“类型由支持的操作定义”。Python 运行时接受任何对象作为 `x` 参数传递给 `double` 函数的两个版本。计算
    `x * 2` 可能有效，也可能会引发 `TypeError`，如果 `x` 不支持该操作。相比之下，Mypy 在分析带注释的 `double` 源代码时会声明
    `x * 2` 为错误，因为它对于声明的类型 `x: abc.Sequence` 是不支持的操作。'
- en: 'In a gradual type system, we have the interplay of two different views of types:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在渐进式类型系统中，我们有两种不同类型观点的相互作用：
- en: Duck typing
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: The view adopted by Smalltalk—the pioneering object-oriented language—as well
    as Python, JavaScript, and Ruby. Objects have types, but variables (including
    parameters) are untyped. In practice, it doesn’t matter what the declared type
    of the object is, only what operations it actually supports. If I can invoke `birdie.quack()`,
    then `birdie` is a duck in this context. By definition, duck typing is only enforced
    at runtime, when operations on objects are attempted. This is more flexible than
    *nominal typing*, at the cost of allowing more errors at runtime.^([5](ch08.html#idm46582445162944))
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Smalltalk——开创性的面向对象语言——以及 Python、JavaScript 和 Ruby 采用的视角。对象具有类型，但变量（包括参数）是无类型的。实际上，对象的声明类型是什么并不重要，只有它实际支持的操作才重要。如果我可以调用
    `birdie.quack()`，那么在这个上下文中 `birdie` 就是一只鸭子。根据定义，鸭子类型只在运行时强制执行，当尝试对对象进行操作时。这比*名义类型*更灵活，但会在运行时允许更多的错误。^([5](ch08.html#idm46582445162944))
- en: Nominal typing
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 名义类型
- en: 'The view adopted by C++, Java, and C#, supported by annotated Python. Objects
    and variables have types. But objects only exist at runtime, and the type checker
    only cares about the source code where variables (including parameters) are annotated
    with type hints. If `Duck` is a subclass of `Bird`, you can assign a `Duck` instance
    to a parameter annotated as `birdie: Bird`. But in the body of the function, the
    type checker considers the call `birdie.quack()` illegal, because `birdie` is
    nominally a `Bird`, and that class does not provide the `.quack()` method. It
    doesn’t matter if the actual argument at runtime is a `Duck`, because nominal
    typing is enforced statically. The type checker doesn’t run any part of the program,
    it only reads the source code. This is more rigid than *duck typing*, with the
    advantage of catching some bugs earlier in a build pipeline, or even as the code
    is typed in an IDE.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'C++、Java 和 C# 采用的视角，由带注释的 Python 支持。对象和变量具有类型。但对象只在运行时存在，类型检查器只关心在变量（包括参数）被注释为类型提示的源代码中。如果
    `Duck` 是 `Bird` 的一个子类，你可以将一个 `Duck` 实例分配给一个被注释为 `birdie: Bird` 的参数。但在函数体内，类型检查器认为调用
    `birdie.quack()` 是非法的，因为 `birdie` 名义上是一个 `Bird`，而该类不提供 `.quack()` 方法。在运行时实际参数是
    `Duck` 也无关紧要，因为名义类型是静态强制的。类型检查器不运行程序的任何部分，它只读取源代码。这比*鸭子类型*更严格，优点是在构建流水线中更早地捕获一些错误，甚至在代码在
    IDE 中输入时。'
- en: '[Example 8-4](#birds_module_ex) is a silly example that contrasts duck typing
    and nominal typing, as well as static type checking and runtime behavior.^([6](ch08.html#idm46582445123568))'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 8-4](#birds_module_ex) 是一个愚蠢的例子，对比了鸭子类型和名义类型，以及静态类型检查和运行���行为。^([6](ch08.html#idm46582445123568))'
- en: Example 8-4\. *birds.py*
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-4\. *birds.py*
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_type_hints_in_functions_CO1-1)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_type_hints_in_functions_CO1-1)'
- en: '`Duck` is a subclass of `Bird`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Duck` 是 `Bird` 的一个子类。'
- en: '[![2](assets/2.png)](#co_type_hints_in_functions_CO1-2)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_type_hints_in_functions_CO1-2)'
- en: '`alert` has no type hints, so the type checker ignores it.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`alert` 没有类型提示，因此类型检查器会忽略它。'
- en: '[![3](assets/3.png)](#co_type_hints_in_functions_CO1-3)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_type_hints_in_functions_CO1-3)'
- en: '`alert_duck` takes one argument of type `Duck`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`alert_duck` 接受一个 `Duck` 类型的参数。'
- en: '[![4](assets/4.png)](#co_type_hints_in_functions_CO1-4)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_type_hints_in_functions_CO1-4)'
- en: '`alert_bird` takes one argument of type `Bird`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`alert_bird` 接受一个 `Bird` 类型的参数。'
- en: 'Type checking *birds.py* with Mypy, we see a problem:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Mypy 对 *birds.py* 进行类型检查，我们发现了一个问题：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Just by analyzing the source code, Mypy sees that `alert_bird` is problematic:
    the type hint declares the `birdie` parameter with type `Bird`, but the body of
    the function calls `birdie.quack()`—and the `Bird` class has no such method.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析源代码，Mypy 发现 `alert_bird` 是有问题的：类型提示声明了 `birdie` 参数的类型为 `Bird`，但函数体调用了 `birdie.quack()`，而
    `Bird` 类没有这样的方法。
- en: Now let’s try to use the `birds` module in *daffy.py* in [Example 8-5](#daffy_module_ex).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试在 *daffy.py* 中使用 `birds` 模块，参见 [Example 8-5](#daffy_module_ex)。
- en: Example 8-5\. *daffy.py*
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-5\. *daffy.py*
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_type_hints_in_functions_CO2-1)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_type_hints_in_functions_CO2-1)'
- en: Valid call, because `alert` has no type hints.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有效的调用，因为 `alert` 没有类型提示。
- en: '[![2](assets/2.png)](#co_type_hints_in_functions_CO2-2)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_type_hints_in_functions_CO2-2)'
- en: Valid call, because `alert_duck` takes a `Duck` argument, and `daffy` is a `Duck`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有效的调用，因为 `alert_duck` 接受一个 `Duck` 参数，而 `daffy` 是一个 `Duck`。
- en: '[![3](assets/3.png)](#co_type_hints_in_functions_CO2-3)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_type_hints_in_functions_CO2-3)'
- en: Valid call, because `alert_bird` takes a `Bird` argument, and `daffy` is also
    a `Bird`—the superclass of `Duck`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的调用，因为`alert_bird`接受一个`Bird`参数，而`daffy`也是一个`Bird`——`Duck`的超类。
- en: 'Running Mypy on *daffy.py* raises the same error about the `quack` call in
    the `alert_bird` function defined in *birds.py*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在*daffy.py*上运行Mypy会引发与在*birds.py*中定义的`alert_bird`函数中的`quack`调用相同的错误：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But Mypy sees no problem with *daffy.py* itself: the three function calls are
    OK.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但是Mypy对*daffy.py*本身没有任何问题：这三个函数调用都是正确的。
- en: 'Now, if you run *daffy.py*, this is what you get:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行*daffy.py*，你会得到以下结果：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Everything works! Duck typing FTW!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常！鸭子类型万岁！
- en: 'At runtime, Python doesn’t care about declared types. It uses duck typing only.
    Mypy flagged an error in `alert_bird`, but calling it with `daffy` works fine
    at runtime. This may surprise many Pythonistas at first: a static type checker
    will sometimes find errors in programs that we know will execute.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，Python不关心声明的类型。它只使用鸭子类型。Mypy在`alert_bird`中标记了一个错误，但在运行时使用`daffy`调用它是没有问题的。这可能会让许多Python爱好者感到惊讶：静态类型检查器有时会发现我们知道会执行的程序中的错误。
- en: However, if months from now you are tasked with extending the silly bird example,
    you may be grateful for Mypy. Consider this *woody.py* module, which also uses
    `birds`, in [Example 8-6](#woody_module_ex).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果几个月后你被要求扩展这个愚蠢的鸟类示例，你可能会感激Mypy。考虑一下*woody.py*模块，它也使用了`birds`，在[示例 8-6](#woody_module_ex)中。
- en: Example 8-6\. *woody.py*
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-6\. *woody.py*
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Mypy finds two errors while checking *woody.py*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy在检查*woody.py*时发现了两个错误：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first error is in *birds.py*: the `birdie.quack()` call in `alert_bird`,
    which we’ve seen before. The second error is in *woody.py*: `woody` is an instance
    of `Bird`, so the call `alert_duck(woody)` is invalid because that function requires
    a `Duck`. Every `Duck` is a `Bird`, but not every `Bird` is a `Duck`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个错误在*birds.py*中：在`alert_bird`中的`birdie.quack()`调用，我们之前已经看过了。第二个错误在*woody.py*中：`woody`是`Bird`的一个实例，所以调用`alert_duck(woody)`是无效的，因为该函数需要一个`Duck`。每个`Duck`都是一个`Bird`，但并非每个`Bird`都是一个`Duck`。
- en: At runtime, none of the calls in *woody.py* succeed. The succession of failures
    is best illustrated in a console session with callouts in [Example 8-7](#birdie_errors_ex).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，*woody.py*中的所有调用都失败了。这些失败的连续性在[示例 8-7](#birdie_errors_ex)中的控制台会话中最好地说明。
- en: Example 8-7\. Runtime errors and how Mypy could have helped
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-7\. 运行时错误以及Mypy如何帮助
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_type_hints_in_functions_CO3-1)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_type_hints_in_functions_CO3-1)'
- en: Mypy could not detect this error because there are no type hints in `alert`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy无法检测到这个错误，因为`alert`中没有类型提示。
- en: '[![2](assets/2.png)](#co_type_hints_in_functions_CO3-2)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_type_hints_in_functions_CO3-2)'
- en: 'Mypy reported the problem: `Argument 1 to "alert_duck" has incompatible type
    "Bird"; expected "Duck"`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy报告了问题："alert_duck"的第1个参数类型不兼容："Bird"；预期是"Duck"。
- en: '[![3](assets/3.png)](#co_type_hints_in_functions_CO3-3)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_type_hints_in_functions_CO3-3)'
- en: 'Mypy has been telling us since [Example 8-4](#birds_module_ex) that the body
    of the `alert_bird` function is wrong: `"Bird" has no attribute "quack"`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 自从[示例 8-4](#birds_module_ex)以来，Mypy一直在告诉我们`alert_bird`函数的主体是错误的："Bird"没有属性"quack"。
- en: 'This little experiment shows that duck typing is easier to get started and
    is more flexible, but allows unsupported operations to cause errors at runtime.
    Nominal typing detects errors before runtime, but sometimes can reject code that
    actually runs—such as the call `alert_bird(daffy)` in [Example 8-5](#daffy_module_ex).
    Even if it sometimes works, the `alert_bird` function is misnamed: its body does
    require an object that supports the `.quack()` method, which `Bird` doesn’t have.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小实验表明，鸭子类型更容易上手，更加灵活，但允许不支持的操作在运行时引发错误。名义类型在运行前检测错误，但有时可能会拒绝实际运行的代码，比如在[示例
    8-5](#daffy_module_ex)中的调用`alert_bird(daffy)`。即使有时候能够运行，`alert_bird`函数的命名是错误的：它的主体确实需要支持`.quack()`方法的对象，而`Bird`没有这个方法。
- en: In this silly example, the functions are one-liners. But in real code they could
    be longer; they could pass the `birdie` argument to more functions, and the origin
    of the `birdie` argument could be many function calls away, making it hard to
    pinpoint the cause of a runtime error. The type checker prevents many such errors
    from ever happening at runtime.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个愚蠢的例子中，函数只有一行。但在实际代码中，它们可能会更长；它们可能会将`birdie`参数传递给更多函数，并且`birdie`参数的来源可能相距多个函数调用，这使得很难准确定位运行时错误的原因。类型检查器可以防止许多这样的错误在运行时发生。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The value of type hints is questionable in the tiny examples that fit in a book.
    The benefits grow with the size of the codebase. That’s why companies with millions
    of lines of Python code—like Dropbox, Google, and Facebook—invested in teams and
    tools to support the company-wide adoption of type hints, and have significant
    and increasing portions of their Python codebases type checked in their CI pipelines.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示在适合放在书中的小例子中的价值是有争议的。随着代码库规模的增长，其好处也会增加。这就是为什么拥有数百万行Python代码的公司——如Dropbox、Google和Facebook——投资于团队和工具，支持公司范围内采用类型提示，并在CI管道中检查其Python代码库的重要部分。
- en: In this section we explored the relationship of types and operations in duck
    typing and nominal typing, starting with the simple `double()` function—which
    we left without proper type hints. Now we will tour the most important types used
    for annotating functions. We’ll see a good way to add type hints to `double()`
    when we reach [“Static Protocols”](#protocols_in_fn). But before we get to that,
    there are more fundamental types to know.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了鸭子类型和名义类型中类型和操作的关系，从简单的`double()`函数开始——我们没有为其添加适当的类型提示。当我们到达[“静态协议”](#protocols_in_fn)时，我们将看到如何为`double()`添加类型提示。但在那之前，还有更基本的类型需要了解。
- en: Types Usable in Annotations
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用于注释的类型
- en: Pretty much any Python type can be used in type hints, but there are restrictions
    and recommendations. In addition, the `typing` module introduced special constructs
    with semantics that are sometimes surprising.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何Python类型都可以用作类型提示，但存在限制和建议。此外，`typing`模块引入了有时令人惊讶的语义的特殊构造。
- en: 'This section covers all the major types you can use with annotations:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了您可以在注释中使用的所有主要类型：
- en: '`typing.Any`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typing.Any`'
- en: Simple types and classes
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单类型和类
- en: '`typing.Optional` and `typing.Union`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typing.Optional`和`typing.Union`'
- en: Generic collections, including tuples and mappings
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型集合，包括元组和映射
- en: Abstract base classes
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类
- en: Generic iterables
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用可迭代对象
- en: Parameterized generics and `TypeVar`
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化泛型和`TypeVar`
- en: '`typing.Protocols`—the key to *static duck typing*'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typing.Protocols`—*静态鸭子类型*的关键'
- en: '`typing.Callable`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typing.Callable`'
- en: '`typing.NoReturn`—a good way to end this list'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typing.NoReturn`—一个结束这个列表的好方法'
- en: We’ll cover each of these in turn, starting with a type that is strange, apparently
    useless, but crucially important.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次介绍每一个，从一个奇怪的、显然无用但至关重要的类型开始。
- en: The Any Type
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任意类型
- en: 'The keystone of any gradual type system is the `Any` type, also known as the
    *dynamic type*. When a type checker sees an untyped function like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 任何渐进式类型系统的基石是`Any`类型，也称为*动态类型*。当类型检查器看到这样一个未标记的函数时：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'it assumes this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 它假设这个：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That means the `x` argument and the return value can be of any type, including
    different types. `Any` is assumed to support every possible operation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`x`参数和返回值可以是任何类型，包括不同的类型。假定`Any`支持每种可能的操作。
- en: 'Contrast `Any` with `object`. Consider this signature:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Any`与`object`进行对比。考虑这个签名：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function also accepts arguments of every type, because every type is a
    *subtype-of* `object`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数也接受每种类型的参数，因为每种类型都是`object`的*子类型*。
- en: 'However, a type checker will reject this function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类型检查器将拒绝这个函数：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The problem is that `object` does not support the `__mul__` operation. This
    is what Mypy reports:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`object`不支持`__mul__`操作。这就是Mypy报告的内容：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: More general types have narrower interfaces, i.e., they support fewer operations.
    The `object` class implements fewer operations than `abc.Sequence`, which implements
    fewer operations than `abc.MutableSequence`, which implements fewer operations
    than `list`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般的类型具有更窄的接口，即它们支持更少的操作。`object`类实现的操作比`abc.Sequence`少，`abc.Sequence`实现的操作比`abc.MutableSequence`少，`abc.MutableSequence`实现的操作比`list`少。
- en: 'But `Any` is a magic type that sits at the top and the bottom of the type hierarchy.
    It’s simultaneously the most general type—so that an argument `n: Any` accepts
    values of every type—and the most specialized type, supporting every possible
    operation. At least, that’s how the type checker understands `Any`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '但`Any`是一个神奇的类型，它同时位于类型层次结构的顶部和底部。它同时是最一般的类型—所以一个参数`n: Any`接受每种类型的值—和最专门的类型，支持每种可能的操作。至少，这就是类型检查器如何理解`Any`。'
- en: 'Of course, no type can support every possible operation, so using `Any` prevents
    the type checker from fulfilling its core mission: detecting potentially illegal
    operations before your program crashes with a runtime exception.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有任何类型可以支持每种可能的操作，因此使用`Any`可以防止类��检查器实现其核心任务：在程序因运行时异常而崩溃之前检测潜在的非法操作。
- en: Subtype-of versus consistent-with
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子类型与一致性
- en: Traditional object-oriented nominal type systems rely on the is *subtype-of*
    relationship. Given a class `T1` and a subclass `T2`, then `T2` is *subtype-of*
    `T1`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的面向对象的名义类型系统依赖于*子类型*关系。给定一个类`T1`和一个子类`T2`，那么`T2`是`T1`的*子类型*。
- en: 'Consider this code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这段代码：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The call `f1(o2)` is an application of the Liskov Substitution Principle—LSP.
    Barbara Liskov^([7](ch08.html#idm46582444453504)) actually defined *is subtype-of*
    in terms of supported operations: if an object of type `T2` substitutes an object
    of type `T1` and the program still behaves correctly, then `T2` is *subtype-of*
    `T1`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`f1(o2)`是对Liskov替换原则—LSP的应用。Barbara Liskov^([7](ch08.html#idm46582444453504))实际上是根据支持的操作定义*是子类型*：如果类型`T2`的对象替代类型`T1`的对象并且程序仍然正确运行，那么`T2`就是`T1`的*子类型*。
- en: 'Continuing from the previous code, this shows a violation of the LSP:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上述代码，这显示了LSP的违反：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'From the point of view of supported operations, this makes perfect sense: as
    a subclass, `T2` inherits and must support all operations that `T1` does. So an
    instance of `T2` can be used anywhere an instance of `T1` is expected. But the
    reverse is not necessarily true: `T2` may implement additional methods, so an
    instance of `T1` may not be used everywhere an instance of `T2` is expected. This
    focus on supported operations is reflected in the name [*behavioral subtyping*](https://fpy.li/8-15),
    also used to refer to the LSP.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从支持的操作的角度来看，这是完全合理的：作为一个子类，`T2`继承并且必须支持`T1`支持的所有操作。因此，`T2`的实例可以在期望`T1`的实例的任何地方使用。但反之不一定成立：`T2`可能实现额外的方法，因此`T1`的实例可能无法在期望`T2`的实例的任何地方使用。这种对支持的操作的关注体现在名称[*行为子类型化*](https://fpy.li/8-15)中，也用于指代LSP。
- en: 'In a gradual type system, there is another relationship: *consistent-with*,
    which applies wherever *subtype-of* applies, with special provisions for type
    `Any`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在渐进式类型系统中，还有另一种关系：*与一致*，它适用于*子类型*适用的地方，对于类型`Any`有特殊规定。
- en: 'The rules for *consistent-with* are:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*与一致*的规则是：'
- en: Given `T1` and a subtype `T2`, then `T2` is *consistent-with* `T1` (Liskov substitution).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定`T1`和子类型`T2`，那么`T2`是*与*`T1`一致的（Liskov替换）。
- en: 'Every type is *consistent-with* `Any`: you can pass objects of every type to
    an argument declared of type `Any`.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每种类型都*与一致*`Any`：你可以将每种类型的对象传递给声明为`Any`类型的参数。
- en: '`Any` is *consistent-with* every type: you can always pass an object of type
    `Any` where an argument of another type is expected.'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Any`是*与每种类型一致*的：你总是可以在需要另一种类型的参数时传递一个`Any`类型的对象。'
- en: 'Considering the previous definitions of the objects `o1` and `o2`, here are
    examples of valid code, illustrating rules #2 and #3:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面定义的对象`o1`和`o2`，这里是有效代码的示例，说明规则#2和#3：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Every gradual type system needs a wildcard type like `Any`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 每个渐进类型系统都需要像`Any`这样的通配类型。
- en: Tip
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The verb “to infer” is a fancy synomym for “to guess,” used in the context of
    type analysis. Modern type checkers in Python and other languages don’t require
    type annotations everywhere because they can infer the type of many expressions.
    For example, if I write `x = len(s) * 10`, the type checker doesn’t need an explicit
    local declaration to know that `x` is an `int`, as long as it can find type hints
    for the `len` built-in.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 动词“推断”是“猜测”的花哨同义词，在类型分析的背景下使用。Python和其他语言中的现代类型检查器并不要求在每个地方都有类型注释，因为它们可以推断出许多表达式的类型。例如，如果我写`x
    = len(s) * 10`，类型检查器不需要一个显式的本地声明来知道`x`是一个`int`，只要它能找到`len`内置函数的类型提示即可。
- en: Now we can explore the rest of the types used in annotations.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以探索注解中使用的其余类型。
- en: Simple Types and Classes
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单类型和类
- en: Simple types like `int`, `float`, `str`, and `bytes` may be used directly in
    type hints. Concrete classes from the standard library, external packages, or
    user defined—`FrenchDeck`, `Vector2d`, and `Duck`—may also be used in type hints.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 像`int`、`float`、`str`和`bytes`这样的简单类型可以直接在类型提示中使用。标准库、外部包或用户定义的具体类——`FrenchDeck`、`Vector2d`和`Duck`——也可以在类型提示中使用。
- en: Abstract base classes are also useful in type hints. We’ll get back to them
    as we study collection types, and in [“Abstract Base Classes”](#type_hint_abc_sec).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类在类型提示中也很有用。当我们研究集合类型时，我们将回到它们，并在[“抽象基类”](#type_hint_abc_sec)中看到它们。
- en: 'Among classes, *consistent-with* is defined like *subtype-of*: a subclass is
    *consistent-with* all its superclasses.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在类之间，*一致*的定义类似于*子类型*：子类与其所有超类一致。
- en: However, “practicality beats purity,” so there is an important exception, which
    I discuss in the following tip.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，“实用性胜过纯粹性”，因此有一个重要的例外情况，我将在下面的提示中讨论。
- en: int Is Consistent-With complex
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: int与复杂一致
- en: 'There is no nominal subtype relationship between the built-in types `int`,
    `float`, and `complex`: they are direct subclasses of `object`. But PEP 484 [declares](https://fpy.li/cardxvi)
    that `int` is *consistent-with* `float`, and `float` is *consistent-with* `complex`.
    It makes sense in practice: `int` implements all operations that `float` does,
    and `int` implements additional ones as well—bitwise operations like `&`, `|`,
    `<<`, etc. The end result is: `int` is *consistent-with* `complex`. For `i = 3`,
    `i.real` is `3`, and `i.imag` is `0`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 内置类型`int`、`float`和`complex`之间没有名义子类型关系：它们是`object`的直接子类。但PEP 484[声明](https://fpy.li/cardxvi)
    `int`与`float`一致，`float`与`complex`一致。在实践中是有道理的：`int`实现了`float`的所有操作，而且`int`还实现了额外的操作——位运算如`&`、`|`、`<<`等。最终结果是：`int`与`complex`一致。对于`i
    = 3`，`i.real`是`3`，`i.imag`是`0`。
- en: Optional and Union Types
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选和联合类型
- en: 'We saw the `Optional` special type in [“Using None as a Default”](#dealing_with_none_sec).
    It solves the problem of having `None` as a default, as in this example from that
    section:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“使用None作为默认值”](#dealing_with_none_sec)中看到了`Optional`特殊类型。它解决了将`None`作为默认值的问题，就像这个部分中的示例一样：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The construct `Optional[str]` is actually a shortcut for `Union[str, None]`,
    which means the type of `plural` may be `str` or `None`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 构造`Optional[str]`实际上是`Union[str, None]`的快捷方式，这意味着`plural`的类型可以是`str`或`None`。
- en: Better Syntax for Optional and Union in Python 3.10
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 3.10中更好的可选和联合语法
- en: 'We can write `str | bytes` instead of `Union[str, bytes]` since Python 3.10.
    It’s less typing, and there’s no need to import `Optional` or `Union` from `typing`.
    Contrast the old and new syntax for the type hint of the `plural` parameter of
    `show_count`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.10起，我们可以写`str | bytes`而不是`Union[str, bytes]`。这样打字更少，而且不需要从`typing`导入`Optional`或`Union`。对比`show_count`的`plural`参数的类型提示的旧语法和新语法：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `|` operator also works with `isinstance` and `issubclass` to build the
    second argument: `isinstance(x, int | str)`. For more, see [PEP 604—Complementary
    syntax for Union[]](https://fpy.li/pep604).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`|`运算符也适用于`isinstance`和`issubclass`来构建第二个参数：`isinstance(x, int | str)`。更多信息，请参阅[PEP
    604—Union[]的补充语法](https://fpy.li/pep604)。'
- en: The `ord` built-in function’s signature is a simple example of `Union`—it accepts
    `str` or `bytes`, and returns an `int`:^([8](ch08.html#idm46582444129504))
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`ord`内置函数的签名是`Union`的一个简单示例——它接受`str`或`bytes`，并返回一个`int`:^([8](ch08.html#idm46582444129504))'
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here is an example of a function that takes a `str`, but may return a `str`
    or a `float`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受`str`但可能返回`str`或`float`的函数示例：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If possible, avoid creating functions that return `Union` types, as they put
    an extra burden on the user—forcing them to check the type of the returned value
    at runtime to know what to do with it. But the `parse_token` in the preceding
    code is a reasonable use case in the context of a simple expression evaluator.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，尽量避免创建返回`Union`类型的函数，因为这会给用户增加额外的负担——迫使他们在运行时检查返回值的类型以知道如何处理它。但在前面代码中的`parse_token`是一个简单表达式求值器上下文中合理的用例。
- en: Tip
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In [“Dual-Mode str and bytes APIs”](ch04.html#dual_mode_api_sec), we saw functions
    that accept either `str` or `bytes` arguments, but return `str` if the argument
    was `str` or `bytes` if the arguments was `bytes`. In those cases, the return
    type is determined by the input type, so `Union` is not an accurate solution.
    To properly annotate such functions, we need a type variable—presented in [“Parameterized
    Generics and TypeVar”](#param_generics_typevar_sec)—or overloading, which we’ll
    see in [“Overloaded Signatures”](ch15.html#overload_sec).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“双模式str和bytes API”](ch04.html#dual_mode_api_sec)中，我们看到接受`str`或`bytes`参数的函数，但如果参数是`str`则返回`str`，如果参数是`bytes`则返回`bytes`。在这些情况下，返回类型由输入类型确定，因此`Union`不是一个准确的解决方案。为了正确注释这样的函数，我们需要一个类型变量—在[“参数化泛型和TypeVar”](#param_generics_typevar_sec)中介绍—或重载，我们将在[“重载签名”](ch15.html#overload_sec)中看到。
- en: '`Union[]` requires at least two types. Nested `Union` types have the same effect
    as a flattened `Union`. So this type hint:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Union[]`需要至少两种类型。嵌套的`Union`类型与扁平化的`Union`具有相同的效果。因此，这种类型提示：'
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'is the same as:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与以下相同：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`Union` is more useful with types that are not consistent among themselves.
    For example: `Union[int, float]` is redundant because `int` is *consistent-with*
    `float`. If you just use `float` to annotate the parameter, it will accept `int`
    values as well.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`Union` 对于彼此不一致的类型更有用。例如：`Union[int, float]` 是多余的，因为 `int` 与 `float` 是一致的。如果只使用
    `float` 来注释参数，它也将接受 `int` 值。'
- en: Generic Collections
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型集合
- en: 'Most Python collections are heterogeneous. For example, you can put any mixture
    of different types in a `list`. However, in practice that’s not very useful: if
    you put objects in a collection, you are likely to want to operate on them later,
    and usually this means they must share at least one common method.^([9](ch08.html#idm46582443927296))'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Python 集合是异构的。例如，你可以在 `list` 中放入任何不同类型的混合物。然而，在实践中，这并不是非常有用：如果将对象放入集合中，你可能希望以后对它们进行操作，通常这意味着它们必须至少共享一个公共方法。^([9](ch08.html#idm46582443927296))
- en: Generic types can be declared with type parameters to specify the type of the
    items they can handle.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 可以声明带有类型参数的泛型类型，以指定它们可以处理的项目的类型。
- en: For example, a `list` can be parameterized to constrain the type of the elements
    in it, as you can see in [Example 8-8](#tokenize_ex).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个 `list` 可以被参数化以限制其中元素的类型，就像你在 [示例 8-8](#tokenize_ex) 中看到的那样。
- en: Example 8-8\. `tokenize` with type hints for Python ≥ 3.9
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-8\. `tokenize` 中的 Python ≥ 3.9 类型提示
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In Python ≥ 3.9, it means that `tokenize` returns a `list` where every item
    is of type `str`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python ≥ 3.9 中，这意味着 `tokenize` 返回一个每个项目都是 `str` 类型的 `list`。
- en: 'The annotations `stuff: list` and `stuff: list[Any]` mean the same thing: `stuff`
    is a list of objects of any type.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '注释 `stuff: list` 和 `stuff: list[Any]` 意味着相同的事情：`stuff` 是任意类型对象的列表。'
- en: Tip
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you are using Python 3.8 or earlier, the concept is the same, but you need
    more code to make it work—as explained in the optional box [“Legacy Support and
    Deprecated Collection Types”](#legacy_deprecated_typing_box).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Python 3.8 或更早版本，概念是相同的，但你需要更多的代码来使其工作，如可选框中所解释的 [“遗留支持和已弃用的集合类型”](#legacy_deprecated_typing_box)。
- en: '[PEP 585—Type Hinting Generics In Standard Collections](https://fpy.li/8-16)
    lists collections from the standard library accepting generic type hints. The
    following list shows only those collections that use the simplest form of generic
    type hint, `container[item]`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 585—标准集合中的泛型类型提示](https://fpy.li/8-16) 列出了接受泛型类型提示的标准库集合。以下列表仅显示那些使用最简单形式的泛型类型提示
    `container[item]` 的集合：'
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `tuple` and mapping types support more complex type hints, as we’ll see
    in their respective sections.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple` 和映射类型支持更复杂的类型提示，我们将在各自的部分中看到。'
- en: As of Python 3.10, there is no good way to annotate `array.array`, taking into
    account the `typecode` constructor argument, which determines whether integers
    or floats are stored in the array. An even harder problem is how to type check
    integer ranges to prevent `OverflowError` at runtime when adding elements to arrays.
    For example, an `array` with `typecode='B'` can only hold `int` values from 0
    to 255. Currently, Python’s static type system is not up to this challenge.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Python 3.10，目前还没有很好的方法来注释 `array.array`，考虑到 `typecode` 构造参数，该参数确定数组中存储的是整数还是浮点数。更难的问题是如何对整数范围进行类型检查，以防止在向数组添加元素时在运行时出现
    `OverflowError`。例如，具有 `typecode='B'` 的 `array` 只能容纳从 0 到 255 的 `int` 值。目前，Python
    的静态类型系统还无法应对这一挑战。
- en: Now let’s see how to annotate generic tuples.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何注释泛型元组。
- en: Tuple Types
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组类型
- en: 'There are three ways to annotate tuple types:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种注释元组类型的方法：
- en: Tuples as records
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组作为记录
- en: Tuples as records with named fields
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有命名字段的元组作为记录
- en: Tuples as immutable sequences
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组作为不可变序列
- en: Tuples as records
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组作为记录
- en: If you’re using a `tuple` as a record, use the `tuple` built-in and declare
    the types of the fields within `[]`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 `tuple` 用作记录，则使用内置的 `tuple` 并在 `[]` 中声明字段的类型。
- en: 'For example, the type hint would be `tuple[str, float, str]` to accept a tuple
    with city name, population, and country: `(''Shanghai'', 24.28, ''China'')`.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，类型提示将是 `tuple[str, float, str]`，以接受包含城市名称、人口和国家的元组：`('上海', 24.28, '中国')`。
- en: 'Consider a function that takes a pair of geographic coordinates and returns
    a [Geohash](https://fpy.li/8-18), used like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个接受一对地理坐标并返回 [Geohash](https://fpy.li/8-18) 的函数，用法如下：
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[Example 8-11](#geohash_ex_1) shows how `geohash` is defined, using the `geolib`
    package from PyPI.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-11](#geohash_ex_1) 展示了如何定义 `geohash`，使用了来自 PyPI 的 `geolib` 包。'
- en: Example 8-11\. *coordinates.py* with the `geohash` function
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-11\. *coordinates.py* 中的 `geohash` 函数
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[![1](assets/1.png)](#co_type_hints_in_functions_CO4-1)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_type_hints_in_functions_CO4-1)'
- en: This comment stops Mypy from reporting that the `geolib` package doesn’t have
    type hints.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此注释阻止 Mypy 报告 `geolib` 包没有类型提示。
- en: '[![2](assets/2.png)](#co_type_hints_in_functions_CO4-2)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_type_hints_in_functions_CO4-2)'
- en: '`lat_lon` parameter annotated as a `tuple` with two `float` fields.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`lat_lon` 参数注释为具有两个 `float` 字段的 `tuple`。'
- en: Tip
  id: totrans-277
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: For Python < 3.9, import and use `typing.Tuple` in type hints. It is deprecated
    but will remain in the standard library at least until 2024.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python < 3.9，导入并在类型提示中使用 `typing.Tuple`。它已被弃用，但至少会保留在标准库中直到 2024 年。
- en: Tuples as records with named fields
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有命名字段的元组作为记录
- en: To annotate a tuple with many fields, or specific types of tuple your code uses
    in many places, I highly recommend using `typing.NamedTuple`, as seen in [Chapter 5](ch05.html#data_class_ch).
    [Example 8-12](#geohash_ex_2) shows a variation of [Example 8-11](#geohash_ex_1)
    with `NamedTuple`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要为具有许多字段的元组或代码中多处使用的特定类型的元组添加注释，我强烈建议使用 `typing.NamedTuple`，如 [第 5 章](ch05.html#data_class_ch)
    中所示。[示例 8-12](#geohash_ex_2) 展示了使用 `NamedTuple` 对 [示例 8-11](#geohash_ex_1) 进行变体的情况。
- en: Example 8-12\. *coordinates_named.py* with the `NamedTuple` `Coordinates` and
    the `geohash` function
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-12\. *coordinates_named.py* 中的 `NamedTuple` `Coordinates` 和 `geohash` 函数
- en: '[PRE45]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As explained in [“Overview of Data Class Builders”](ch05.html#data_class_overview_sec),
    `typing.NamedTuple` is a factory for `tuple` subclasses, so `Coordinate` is *consistent-with*
    `tuple[float, float]` but the reverse is not true—after all, `Coordinate` has
    extra methods added by `NamedTuple`, like `._asdict()`, and could also have user-defined
    methods.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如[“数据类构建器概述”](ch05.html#data_class_overview_sec)中所解释的，`typing.NamedTuple`是`tuple`子类的工厂，因此`Coordinate`与`tuple[float,
    float]`是*一致的*，但反之则不成立——毕竟，`Coordinate`具有`NamedTuple`添加的额外方法，如`._asdict()`，还可以有用户定义的方法。
- en: 'In practice, this means that it is type safe to pass a `Coordinate` instance
    to the `display` function defined in the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这意味着将`Coordinate`实例传递给以下定义的`display`函数是类型安全的：
- en: '[PRE46]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Tuples as immutable sequences
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组作为不可变序列
- en: To annotate tuples of unspecified length that are used as immutable lists, you
    must specify a single type, followed by a comma and `...` (that’s Python’s ellipsis
    token, made of three periods, not Unicode `U+2026`—`HORIZONTAL ELLIPSIS`).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要注释用作不可变列表的未指定长度元组，必须指定一个类型，后跟逗号和`...`（这是Python的省略号标记，由三个句点组成，而不是Unicode `U+2026`—`水平省略号`）。
- en: For example, `tuple[int, ...]` is a tuple with `int` items.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`tuple[int, ...]`是一个具有`int`项的元组。
- en: The ellipsis indicates that any number of elements >= 1 is acceptable. There
    is no way to specify fields of different types for tuples of arbitrary length.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 省略号表示接受任意数量的元素>= 1。无法指定任意长度元组的不同类型字段。
- en: 'The annotations `stuff: tuple[Any, ...]` and `stuff: tuple` mean the same thing:
    `stuff` is a tuple of unspecified length with objects of any type.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '注释`stuff: tuple[Any, ...]`和`stuff: tuple`意思相同：`stuff`是一个未指定长度的包含任何类型对象的元组。'
- en: 'Here is a `columnize` function that transforms a sequence into a table of rows
    and cells in the form of a list of tuples with unspecified lengths. This is useful
    to display items in columns, like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个`columnize`函数，它将一个序列转换为行和单元格的表格，形式为未指定长度的元组列表。这对于以列形式显示项目很有用，就像这样：
- en: '[PRE47]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[Example 8-13](#columnize_ex) shows the implementation of `columnize`. Note
    the return type:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-13](#columnize_ex)展示了`columnize`的实现。注意返回类型：'
- en: '[PRE48]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Example 8-13\. *columnize.py* returns a list of tuples of strings
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-13\. *columnize.py*返回一个字符串元组列表
- en: '[PRE49]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Generic Mappings
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用映射
- en: Generic mapping types are annotated as `MappingType[KeyType, ValueType]`. The
    built-in `dict` and the mapping types in `collections` and `collections.abc` accept
    that notation in Python ≥ 3.9\. For earlier versions, you must use `typing.Dict`
    and other mapping types from the `typing` module, as described in [“Legacy Support
    and Deprecated Collection Types”](#legacy_deprecated_typing_box).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通用映射类型被注释为`MappingType[KeyType, ValueType]`。内置的`dict`和`collections`以及`collections.abc`中的映射类型在Python
    ≥ 3.9中接受该表示法。对于早期版本，必须使用`typing.Dict`和`typing`模块中的其他映射类型，如[“遗留支持和已弃用的集合类型”](#legacy_deprecated_typing_box)中所述。
- en: '[Example 8-14](#charindex_ex) shows a practical use of a function returning
    an [inverted index](https://fpy.li/8-19) to search Unicode characters by name—a
    variation of [Example 4-21](ch04.html#ex_cfpy) more suitable for server-side code
    that we’ll study in [Chapter 21](ch21.html#async_ch).'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-14](#charindex_ex)展示了一个函数返回[倒排索引](https://fpy.li/8-19)以通过名称搜索Unicode字符的实际用途——这是[示例 4-21](ch04.html#ex_cfpy)的一个变体，更适合我们将在[第21章](ch21.html#async_ch)中学习的服务器端代码。'
- en: 'Given starting and ending Unicode character codes, `name_index` returns a `dict[str,
    set[str]]`, which is an inverted index mapping each word to a set of characters
    that have that word in their names. For example, after indexing ASCII characters
    from 32 to 64, here are the sets of characters mapped to the words `''SIGN''`
    and `''DIGIT''`, and how to find the character named `''DIGIT EIGHT''`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 给定起始和结束的Unicode字符代码，`name_index`返回一个`dict[str, set[str]]`，这是一个将每个单词映射到具有该单词在其名称中的字符集的倒排索引。例如，在对ASCII字符从32到64进行索引后，这里是映射到单词`'SIGN'`和`'DIGIT'`的字符集，以及如何找到名为`'DIGIT
    EIGHT'`的字符：
- en: '[PRE50]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[Example 8-14](#charindex_ex) shows the source code for *charindex.py* with
    the `name_index` function. Besides a `dict[]` type hint, this example has three
    features appearing for the first time in the book.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-14](#charindex_ex)展示了带有`name_index`函数的*charindex.py*源代码。除了`dict[]`类型提示外，这个示例还有三个本书中首次出现的特性。'
- en: Example 8-14\. *charindex.py*
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-14\. *charindex.py*
- en: '[PRE51]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[![1](assets/1.png)](#co_type_hints_in_functions_CO5-1)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_type_hints_in_functions_CO5-1)'
- en: '`tokenize` is a generator function. [Chapter 17](ch17.html#iterables2generators)
    is about generators.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokenize`是一个生成器函数。[第17章](ch17.html#iterables2generators)是关于生成器的。'
- en: '[![2](assets/2.png)](#co_type_hints_in_functions_CO5-2)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_type_hints_in_functions_CO5-2)'
- en: 'The local variable `index` is annotated. Without the hint, Mypy says: `Need
    type annotation for ''index'' (hint: "index: dict[<type>, <type>] = ...")`.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '局部变量`index`已经被注释。没有提示，Mypy会说：`需要为''index''注释类型（提示：“index: dict[<type>, <type>]
    = ...”）`。'
- en: '[![3](assets/3.png)](#co_type_hints_in_functions_CO5-3)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_type_hints_in_functions_CO5-3)'
- en: I used the walrus operator `:=` in the `if` condition. It assigns the result
    of the `unicodedata.name()` call to `name`, and the whole expression evaluates
    to that result. When the result is `''`, that’s falsy, and the `index` is not
    updated.^([11](ch08.html#idm46582442856960))
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`if`条件中使用了海象操作符`:=`。它将`unicodedata.name()`调用的结果赋给`name`，整个表达式的值就是该结果。当结果为`''`时，为假值，`index`不会被更新。^([11](ch08.html#idm46582442856960))
- en: Note
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When using a `dict` as a record, it is common to have all keys of the `str`
    type, with values of different types depending on the keys. That is covered in
    [“TypedDict”](ch15.html#typeddict_sec).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`dict`用作记录时，通常所有键都是`str`类型，具体取决于键的不同类型的值。这在[“TypedDict”](ch15.html#typeddict_sec)中有所涵盖。
- en: Abstract Base Classes
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象基类
- en: Be conservative in what you send, be liberal in what you accept.
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在发送内容时要保守，在接收内容时要开放。
- en: ''
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Postel’s law, a.k.a. the Robustness Principle
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 波斯特尔法则，又称韧性原则
- en: '[Table 8-1](#generic_collections_tbl) lists several abstract classes from `collections.abc`.
    Ideally, a function should accept arguments of those abstract types—or their `typing`
    equivalents before Python 3.9—and not concrete types. This gives more flexibility
    to the caller.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-1](#generic_collections_tbl) 列出了几个来自 `collections.abc` 的抽象类。理想情况下，一个函数应该接受这些抽象类型的参数，或者在
    Python 3.9 之前使用它们的 `typing` 等效类型，而不是具体类型。这样可以给调用者更多的灵活性。'
- en: 'Consider this function signature:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个函数签名：
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Using `abc.Mapping` allows the caller to provide an instance of `dict`, `defaultdict`,
    `ChainMap`, a `UserDict` subclass, or any other type that is a *subtype-of* `Mapping`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `abc.Mapping` 允许调用者提供 `dict`、`defaultdict`、`ChainMap`、`UserDict` 子类或任何其他是
    `Mapping` 的*子类型*的类型的实例。
- en: 'In contrast, consider this signature:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，考虑这个签名：
- en: '[PRE53]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now `color_map` must be a `dict` or one of its subtypes, such as `defaultDict`
    or `OrderedDict`. In particular, a subclass of `collections.UserDict` would not
    pass the type check for `color_map`, despite being the recommended way to create
    user-defined mappings, as we saw in [“Subclassing UserDict Instead of dict”](ch03.html#sublcassing_userdict_sec).
    Mypy would reject a `UserDict` or an instance of a class derived from it, because
    `UserDict` is not a subclass of `dict`; they are siblings. Both are subclasses
    of `abc.MutableMapping`.^([12](ch08.html#idm46582442746032))
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `color_map` 必须是一个 `dict` 或其子类型之一，比如 `defaultDict` 或 `OrderedDict`。特别是，`collections.UserDict`
    的子类不会通过 `color_map` 的类型检查，尽管这是创建用户定义映射的推荐方式，正如我们在 [“子类化 UserDict 而不是 dict”](ch03.html#sublcassing_userdict_sec)
    中看到的那样。Mypy 会拒绝 `UserDict` 或从它派生的类的实例，因为 `UserDict` 不是 `dict` 的子类；它们是同级。两者都是 `abc.MutableMapping`
    的子类。^([12](ch08.html#idm46582442746032))
- en: 'Therefore, in general it’s better to use `abc.Mapping` or `abc.MutableMapping`
    in parameter type hints, instead of `dict` (or `typing.Dict` in legacy code).
    If the `name2hex` function doesn’t need to mutate the given `color_map`, the most
    accurate type hint for `color_map` is `abc.Mapping`. That way, the caller doesn’t
    need to provide an object that implements methods like `setdefault`, `pop`, and
    `update`, which are part of the `MutableMapping` interface, but not of `Mapping`.
    This has to do with the second part of Postel’s law: “Be liberal in what you accept.”'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一般来说最好在参数类型提示中使用 `abc.Mapping` 或 `abc.MutableMapping`，而不是 `dict`（或在旧代码中使用
    `typing.Dict`）。如果 `name2hex` 函数不需要改变给定的 `color_map`，那么 `color_map` 的最准确的类型提示是
    `abc.Mapping`。这样，调用者不需要提供实现 `setdefault`、`pop` 和 `update` 等方法的对象，这些方法是 `MutableMapping`
    接口的一部分，但不是 `Mapping` 的一部分。这与 Postel 法则的第二部分有关：“在接受输入时要宽容。”
- en: 'Postel’s law also tells us to be conservative in what we send. The return value
    of a function is always a concrete object, so the return type hint should be a
    concrete type, as in the example from [“Generic Collections”](#simple_collections_type_sec)—which
    uses `list[str]`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Postel 法则还告诉我们在发送内容时要保守。函数的返回值始终是一个具体对象，因此返回类型提示应该是一个具体类型，就像来自 [“通用集合”](#simple_collections_type_sec)
    的示例一样—使用 `list[str]`：
- en: '[PRE54]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Under the entry of [`typing.List`](https://fpy.li/8-20), the Python documentation
    says:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [`typing.List`](https://fpy.li/8-20) 的条目中，Python 文档中写道：
- en: Generic version of `list`. Useful for annotating return types. To annotate arguments
    it is preferred to use an abstract collection type such as `Sequence` or `Iterable`.
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`list` 的泛型版本。用于注释返回类型。为了注释参数，最好使用抽象集合类型，如 `Sequence` 或 `Iterable`。'
- en: A similar comment appears in the entries for [`typing.Dict`](https://fpy.li/8-21)
    and [`typing.Set`](https://fpy.li/8-22).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [`typing.Dict`](https://fpy.li/8-21) 和 [`typing.Set`](https://fpy.li/8-22)
    的条目中也有类似的评论。
- en: Remember that most ABCs from `collections.abc` and other concrete classes from
    `collections`, as well as built-in collections, support generic type hint notation
    like `collections.deque[str]` starting with Python 3.9\. The corresponding `typing`
    collections are only needed to support code written in Python 3.8 or earlier.
    The full list of classes that became generic appears in the [“Implementation”](https://fpy.li/8-16)
    section of [PEP 585—Type Hinting Generics In Standard Collections](https://fpy.li/pep585).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`collections.abc` 中的大多数 ABCs 和其他具体类，以及内置集合，都支持类似 `collections.deque[str]`
    的泛型类型提示符号，从 Python 3.9 开始。相应的 `typing` 集合仅需要支持在 Python 3.8 或更早版本中编写的代码。变成泛型的类的完整列表出现在
    [“实现”](https://fpy.li/8-16) 部分的 [PEP 585—标准集合中的类型提示泛型](https://fpy.li/pep585)
    中。
- en: To wrap up our discussion of ABCs in type hints, we need to talk about the `numbers`
    ABCs.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 结束我们关于类型提示中 ABCs 的讨论，我们需要谈一谈 `numbers` ABCs。
- en: The fall of the numeric tower
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字塔的崩塌
- en: 'The [`numbers`](https://fpy.li/8-24) package defines the so-called *numeric
    tower* described in [PEP 3141—A Type Hierarchy for Numbers](https://fpy.li/pep3141).
    The tower is linear hierarchy of ABCs, with `Number` at the top:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[`numbers`](https://fpy.li/8-24) 包定义了在 [PEP 3141—为数字定义的类型层次结构](https://fpy.li/pep3141)
    中描述的所谓*数字塔*。该塔是一种线性的 ABC 层次结构，顶部是 `Number`：'
- en: '`Number`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number`'
- en: '`Complex`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Complex`'
- en: '`Real`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Real`'
- en: '`Rational`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rational`'
- en: '`Integral`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Integral`'
- en: Those ABCs work perfectly well for runtime type checking, but they are not supported
    for static type checking. The [“Numeric Tower”](https://fpy.li/cardxvi) section
    of PEP 484 rejects the `numbers` ABCs and dictates that the built-in types `complex`,
    `float`, and `int` should be treated as special cases, as explained in [“int Is
    Consistent-With complex”](#int_complex_tip).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 ABCs 对于运行时类型检查非常有效，但不支持静态类型检查。PEP 484 的 [“数字塔”](https://fpy.li/cardxvi) 部分拒绝了
    `numbers` ABCs，并规定内置类型 `complex`、`float` 和 `int` 应被视为特殊情况，如 [“int 与 complex 一致”](#int_complex_tip)
    中所解释的那样。
- en: We’ll come back to this issue in [“The numbers ABCs and Numeric Protocols”](ch13.html#numbers_abc_proto_sec),
    in [Chapter 13](ch13.html#ifaces_prot_abc), which is devoted to contrasting protocols
    and ABCs.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [“numbers ABCs 和数字协议”](ch13.html#numbers_abc_proto_sec) 中回到这个问题，在 [第 13
    章](ch13.html#ifaces_prot_abc) 中，该章节专门对比协议和 ABCs。
- en: 'In practice, if you want to annotate numeric arguments for static type checking,
    you have a few options:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果您想要为静态类型检查注释数字参数，您有几个选择：
- en: Use one of the concrete types `int`, `float`, or `complex`—as recommended by
    PEP 488.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `int`、`float` 或 `complex` 中的一个具体类型—正如 PEP 488 建议的那样。
- en: Declare a union type like `Union[float, Decimal, Fraction]`.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个联合类型，如 `Union[float, Decimal, Fraction]`。
- en: If you want to avoid hardcoding concrete types, use numeric protocols like `SupportsFloat`,
    covered in [“Runtime Checkable Static Protocols”](ch13.html#runtime_checkable_proto_sec).
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果想避免硬编码具体类型，请使用像 `SupportsFloat` 这样的数值协议，详见[“运行时可检查的静态协议”](ch13.html#runtime_checkable_proto_sec)。
- en: The upcoming section [“Static Protocols”](#protocols_in_fn) is a prerequisite
    for understanding the numeric protocols.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 即将到来的章节[“静态协议”](#protocols_in_fn)是理解数值协议的先决条件。
- en: 'Meanwhile, let’s get to one of the most useful ABCs for type hints: `Iterable`.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，让我们来看看对于类型提示最有用的 ABC 之一：`Iterable`。
- en: Iterable
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可迭代对象
- en: The [`typing.List`](https://fpy.li/8-20) documentation I just quoted recommends
    `Sequence` and `Iterable` for function parameter type hints.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚引用的 [`typing.List`](https://fpy.li/8-20) 文档建议在函数参数类型提示中使用 `Sequence` 和 `Iterable`。
- en: 'One example of the `Iterable` argument appears in the `math.fsum` function
    from the standard library:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterable` 参数的一个示例出现在标准库中的 `math.fsum` 函数中：'
- en: '[PRE55]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Stub Files and the Typeshed Project
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存根文件和 Typeshed 项目
- en: 'As of Python 3.10, the standard library has no annotations, but Mypy, PyCharm,
    etc. can find the necessary type hints in the [Typeshed](https://fpy.li/8-26)
    project, in the form of *stub files*: special source files with a *.pyi* extension
    that have annotated function and method signatures, without the implementation—much
    like header files in C.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Python 3.10，标准库没有注释，但 Mypy、PyCharm 等可以在 [Typeshed](https://fpy.li/8-26) 项目中找到必要的类型提示，形式为*存根文件*：特殊的带有
    *.pyi* 扩展名的源文件，具有带注释的函数和方法签名，但没有实现——类似于 C 中的头文件。
- en: The signature for `math.fsum` is in [*/stdlib/2and3/math.pyi*](https://fpy.li/8-27).
    The leading underscores in `__seq` are a PEP 484 convention for positional-only
    parameters, explained in [“Annotating Positional Only and Variadic Parameters”](#arbitrary_arguments_sec).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`math.fsum` 的签名在 [*/stdlib/2and3/math.pyi*](https://fpy.li/8-27) 中。`__seq`
    中的前导下划线是 PEP 484 中关于仅限位置参数的约定，解释在[“注释仅限位置参数和可变参数”](#arbitrary_arguments_sec)中。'
- en: '[Example 8-15](#replacer_ex) is another example using an `Iterable` parameter
    that produces items that are `tuple[str, str]`. Here is how the function is used:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-15](#replacer_ex) 是另一个使用 `Iterable` 参数的示例，产生的项目是 `tuple[str, str]`。以下是函数的使用方式：'
- en: '[PRE56]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[Example 8-15](#replacer_ex) shows how it’s implemented.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-15](#replacer_ex) 展示了它的实现方式。'
- en: Example 8-15\. *replacer.py*
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-15\. *replacer.py*
- en: '[PRE57]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[![1](assets/1.png)](#co_type_hints_in_functions_CO6-1)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_type_hints_in_functions_CO6-1)'
- en: '`FromTo` is a *type alias*: I assigned `tuple[str, str]` to `FromTo`, to make
    the signature of `zip_replace` more readable.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromTo` 是一个*类型别名*：我将 `tuple[str, str]` 赋给 `FromTo`，以使 `zip_replace` 的签名更易读。'
- en: '[![2](assets/2.png)](#co_type_hints_in_functions_CO6-2)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_type_hints_in_functions_CO6-2)'
- en: '`changes` needs to be an `Iterable[FromTo]`; that’s the same as `Iterable[tuple[str,
    str]]`, but shorter and easier to read.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`changes` 需要是一个 `Iterable[FromTo]`；这与 `Iterable[tuple[str, str]]` 相同，但更短且更易读。'
- en: Explicit TypeAlias in Python 3.10
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 3.10 中的显式 TypeAlias
- en: '[PEP 613—Explicit Type Aliases](https://fpy.li/pep613) introduced a special
    type, `TypeAlias`, to make the assignments that create type aliases more visible
    and easier to type check. Starting with Python 3.10, this is the preferred way
    to create type aliases:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 613—显式类型别名](https://fpy.li/pep613)引入了一个特殊类型，`TypeAlias`，用于使创建类型别名的赋值更加可见和易于类型检查。从
    Python 3.10 开始，这是创建类型别名的首选方式：'
- en: '[PRE58]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: abc.Iterable versus abc.Sequence
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: abc.Iterable 与 abc.Sequence
- en: Both `math.fsum` and `replacer.zip_replace` must iterate over the entire `Iterable`
    arguments to return a result. Given an endless iterable such as the `itertools.cycle`
    generator as input, these functions would consume all memory and crash the Python
    process. Despite this potential danger, it is fairly common in modern Python to
    offer functions that accept an `Iterable` input even if they must process it completely
    to return a result. That gives the caller the option of providing input data as
    a generator instead of a prebuilt sequence, potentially saving a lot of memory
    if the number of input items is large.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`math.fsum` 和 `replacer.zip_replace` 都必须遍历整个 `Iterable` 参数才能返回结果。如果给定一个无限迭代器，比如
    `itertools.cycle` 生成器作为输入，这些函数将消耗所有内存并导致 Python 进程崩溃。尽管存在潜在的危险，但在现代 Python 中，提供接受
    `Iterable` 输入的函数即使必须完全处理它才能返回结果是相当常见的。这样一来，调用者可以选择将输入数据提供为生成器，而不是预先构建的序列，如果输入项的数量很大，可能会节省大量内存。'
- en: On the other hand, the `columnize` function from [Example 8-13](#columnize_ex)
    needs a `Sequence` parameter, and not an `Iterable`, because it must get the `len()`
    of the input to compute the number of rows up front.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，来自[示例 8-13](#columnize_ex)的 `columnize` 函数需要一个 `Sequence` 参数，而不是 `Iterable`，因为它必须获取输入的
    `len()` 来提前计算行数。
- en: Like `Sequence`, `Iterable` is best used as a parameter type. It’s too vague
    as a return type. A function should be more precise about the concrete type it
    returns.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Sequence` 类似，`Iterable` 最适合用作参数类型。作为返回类型太模糊了。函数应该更加精确地说明返回的具体类型。
- en: Closely related to `Iterable` is the `Iterator` type, used as a return type
    in [Example 8-14](#charindex_ex). We’ll get back to it in [Chapter 17](ch17.html#iterables2generators),
    which is about generators and classic iterators.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Iterable` 密切相关的是 `Iterator` 类型，在 [示例 8-14](#charindex_ex) 中用作返回类型。我们将在[第
    17 章](ch17.html#iterables2generators)中回到这个话题，讨论生成器和经典迭代器。
- en: Parameterized Generics and TypeVar
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化泛型和 TypeVar
- en: A parameterized generic is a generic type, written as `list[T]`, where `T` is
    a type variable that will be bound to a specific type with each usage. This allows
    a parameter type to be reflected on the result type.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化泛型是一种泛型类型，写作 `list[T]`，其中 `T` 是一个类型变量，将在每次使用时绑定到特定类型。这允许参数类型反映在结果类型上。
- en: '[Example 8-16](#generic_sample_ex) defines `sample`, a function that takes
    two arguments: a `Sequence` of elements of type `T`, and an `int`. It returns
    a `list` of elements of the same type `T`, picked at random from the first argument.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例8-16](#generic_sample_ex)定义了`sample`，一个接受两个参数的函数：类型为`T`的元素的`Sequence`和一个`int`。它从第一个参数中随机选择的相同类型`T`的元素的`list`。'
- en: '[Example 8-16](#generic_sample_ex) shows the implementation.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例8-16](#generic_sample_ex)展示了实现。'
- en: Example 8-16\. *sample.py*
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-16。*sample.py*
- en: '[PRE59]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here are two examples of why I used a type variable in `sample`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个例子说明我在`sample`中使用了一个类型变量：
- en: If called with a tuple of type `tuple[int, ...]`—which is *consistent-with*
    `Sequence[int]`—then the type parameter is `int`, so the return type is `list[int]`.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用类型为`tuple[int, ...]`的元组——这与`Sequence[int]`一致——那么类型参数是`int`，因此返回类型是`list[int]`。
- en: If called with a `str`—which is *consistent-with* `Sequence[str]`—then the type
    parameter is `str`, so the return type is `list[str]`.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用`str`——这与`Sequence[str]`一致——那么类型参数是`str`，因此返回类型是`list[str]`。
- en: Why Is TypeVar Needed?
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要TypeVar？
- en: 'The authors of PEP 484 wanted to introduce type hints by adding the `typing`
    module and not changing anything else in the language. With clever metaprogramming
    they could make the `[]` operator work on classes like `Sequence[T]`. But the
    name of the `T` variable inside the brackets must be defined somewhere—otherwise
    the Python interpreter would need deep changes to support generic type notation
    as special use of `[]`. That’s why the `typing.TypeVar` constructor is needed:
    to introduce the variable name in the current namespace. Languages such as Java,
    C#, and TypeScript don’t require the name of type variable to be declared beforehand,
    so they have no equivalent of Python’s `TypeVar` class.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 484的作者希望通过添加`typing`模块引入类型提示，而不改变语言的其他任何内容。通过巧妙的元编程，他们可以使`[]`运算符在类似`Sequence[T]`的类上起作用。但括号内的`T`变量名称必须在某处定义，否则Python解释器需要进行深层更改才能支持通用类型符号作为`[]`的特殊用途。这就是为什么需要`typing.TypeVar`构造函数：引入当前命名空间中的变量名称。像Java、C#和TypeScript这样的语言不需要事先声明类型变量的名称，因此它们没有Python的`TypeVar`类的等价物。
- en: Another example is the `statistics.mode` function from the standard library,
    which returns the most common data point from a series.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是标准库中的`statistics.mode`函数，它返回系列中最常见的数据点。
- en: 'Here is one usage example from the [documentation](https://fpy.li/8-28):'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是来自[文档](https://fpy.li/8-28)的一个使用示例：
- en: '[PRE60]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Without using a `TypeVar`, `mode` could have the signature shown in [Example 8-17](#mode_float_ex).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用`TypeVar`，`mode`可能具有[示例8-17](#mode_float_ex)中显示的签名。
- en: 'Example 8-17\. *mode_float.py*: `mode` that operates on `float` and subtypes^([13](ch08.html#idm46582442199104))'
  id: totrans-386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-17。*mode_float.py*：对`float`和子类型进行操作的`mode`^([13](ch08.html#idm46582442199104))
- en: '[PRE61]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Many uses of `mode` involve `int` or `float` values, but Python has other numerical
    types, and it is desirable that the return type follows the element type of the
    given `Iterable`. We can improve that signature using `TypeVar`. Let’s start with
    a simple, but wrong, parameterized signature:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 许多`mode`的用法涉及`int`或`float`值，但Python还有其他数值类型，希望返回类型遵循给定`Iterable`的元素类型。我们可以使用`TypeVar`来改进该签名。让我们从一个简单但错误的参数化签名开始：
- en: '[PRE62]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When it first appears in the signature, the type parameter `T` can be any type.
    The second time it appears, it will mean the same type as the first.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型参数`T`首次出现在签名中时，它可以是任何类型。第二次出现时，它将意味着与第一次相同的类型。
- en: Therefore, every iterable is *consistent-with* `Iterable[T]`, including iterables
    of unhashable types that `collections.Counter` cannot handle. We need to restrict
    the possible types assigned to `T`. We’ll see two ways of doing that in the next
    two sections.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个可迭代对象都与`Iterable[T]`一致，包括`collections.Counter`无法处理的不可哈希类型的可迭代对象。我们需要限制分配给`T`的可能类型。我们将在接下来的两节中看到两种方法。
- en: Restricted TypeVar
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制的TypeVar
- en: '`TypeVar` accepts extra positional arguments to restrict the type parameter.
    We can improve the signature of `mode` to accept specific number types, like this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypeVar`接受额外的位置参数来限制类型参数。我们可以改进`mode`的签名，接受特定的数字类型，就像这样：'
- en: '[PRE63]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: That’s better than before, and it was the signature for `mode` in the [*statistics.pyi*](https://fpy.li/8-30)
    stub file on `typeshed` on May 25, 2020.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这比以前好，这是2020年5月25日`typeshed`上`statistics.pyi`存根文件中`mode`的签名。
- en: 'However, the [`statistics.mode`](https://fpy.li/8-28) documentation includes
    this example:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，[`statistics.mode`](https://fpy.li/8-28)文档中包含了这个例子：
- en: '[PRE64]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In a hurry, we could just add `str` to the `NumberT` definition:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 匆忙之间，我们可以将`str`添加到`NumberT`的定义中：
- en: '[PRE65]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: That certainly works, but `NumberT` is badly misnamed if it accepts `str`. More
    importantly, we can’t keep listing types forever, as we realize `mode` can deal
    with them. We can do better with another feature of `TypeVar`, introduced next.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这样做是有效的，但如果它接受`str`，那么`NumberT`的命名就非常不合适。更重要的是，我们不能永远列出类型，因为我们意识到`mode`可以处理它们。我们可以通过`TypeVar`的另一个特性做得更好，接下来介绍。
- en: Bounded TypeVar
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有界的TypeVar
- en: Looking at the body of `mode` in [Example 8-17](#mode_float_ex), we see that
    the `Counter` class is used for ranking. Counter is based on `dict`, therefore
    the element type of the `data` iterable must be hashable.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[示例8-17](#mode_float_ex)中`mode`的主体，我们看到`Counter`类用于排名。Counter基于`dict`，因此`data`可迭代对象的元素类型必须是可哈希的。
- en: 'At first, this signature may seem to work:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这个签名似乎可以工作：
- en: '[PRE66]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now the problem is that the type of the returned item is `Hashable`: an ABC
    that implements only the `__hash__` method. So the type checker will not let us
    do anything with the return value except call `hash()` on it. Not very useful.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是返回项的类型是`Hashable`：一个只实现`__hash__`方法的ABC。因此，类型检查器不会让我们对返回值做任何事情，除了调用`hash()`。并不是很有用。
- en: 'The solution is another optional parameter of `TypeVar`: the `bound` keyword
    parameter. It sets an upper boundary for the acceptable types. In [Example 8-18](#mode_hashable_ex),
    we have `bound=Hashable`, which means the type parameter may be `Hashable` or
    any *subtype-of* it.^([14](ch08.html#idm46582441836224))'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是`TypeVar`的另一个可选参数：`bound`关键字参数。它为可接受的类型设置了一个上限。在[示例8-18](#mode_hashable_ex)中，我们有`bound=Hashable`，这意味着类型参数可以是`Hashable`或其任何*子类型*。^([14](ch08.html#idm46582441836224))
- en: 'Example 8-18\. *mode_hashable.py*: same as [Example 8-17](#mode_float_ex),
    with a more flexible signature'
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-18。*mode_hashable.py*：与[示例8-17](#mode_float_ex)相同，但具有更灵活的签名
- en: '[PRE67]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To summarize:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：
- en: A restricted type variable will be set to one of the types named in the `TypeVar`
    declaration.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制类型变量将被设置为`TypeVar`声明中命名的类型之一。
- en: A bounded type variable will be set to the inferred type of the expression—as
    long as the inferred type is *consistent-with* the boundary declared in the `bound=`
    keyword argument of `TypeVar`.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有界类型变量将被设置为表达式的推断类型——只要推断类型与`TypeVar`的`bound=`关键字参数中声明的边界一致即可。
- en: Note
  id: totrans-412
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is unfortunate that the keyword argument to declare a bounded `TypeVar` is
    named `bound=`, because the verb “to bind” is commonly used to mean setting the
    value of a variable, which in the reference semantics of Python is best described
    as binding a name to the value. It would have been less confusing if the keyword
    argument was named `boundary=`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，声明有界`TypeVar`的关键字参数被命名为`bound=`，因为动词“绑定”通常用于表示设置变量的值，在Python的引用语义中最好描述为将名称绑定到值。如果关键字参数被命名为`boundary=`会更少令人困惑。
- en: The `typing.TypeVar` constructor has other optional parameters—`covariant` and
    `contravariant`—that we’ll cover in [Chapter 15](ch15.html#more_types_ch), [“Variance”](ch15.html#variance_sec).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing.TypeVar`构造函数还有其他可选参数——`covariant`和`contravariant`——我们将在[第15章](ch15.html#more_types_ch)中介绍，“Variance”中涵盖。'
- en: Let’s conclude this introduction to `TypeVar` with `AnyStr`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`AnyStr`结束对`TypeVar`的介绍。
- en: The AnyStr predefined type variable
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预定义的AnyStr类型变量
- en: 'The `typing` module includes a predefined `TypeVar` named `AnyStr`. It’s defined
    like this:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing`模块包括一个预定义的`TypeVar`，名为`AnyStr`。它的定义如下：'
- en: '[PRE68]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`AnyStr` is used in many functions that accept either `bytes` or `str`, and
    return values of the given type.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnyStr`在许多接受`bytes`或`str`的函数���使用，并返回给定类型的值。'
- en: Now, on to `typing.Protocol`, a new feature of Python 3.8 that can support more
    Pythonic use of type hints.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`typing.Protocol`，这是Python 3.8的一个新特性，可以支持更具Python风格的类型提示的使用。
- en: Static Protocols
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态协议
- en: Note
  id: totrans-422
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In object-oriented programming, the concept of a “protocol” as an informal interface
    is as old as Smalltalk, and is an essential part of Python from the beginning.
    However, in the context of type hints, a protocol is a `typing.Protocol` subclass
    defining an interface that a type checker can verify. Both kinds of protocols
    are covered in [Chapter 13](ch13.html#ifaces_prot_abc). This is just a brief introduction
    in the context of function annotations.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，“协议”概念作为一种非正式接口的概念早在Smalltalk中就存在，并且从一开始就是Python的一个基本部分。然而，在类型提示的背景下，协议是一个`typing.Protocol`子类，定义了一个类型检查器可以验证的接口。这两种类型的协议在[第13章](ch13.html#ifaces_prot_abc)中都有涉及。这只是在函数注释的背景下的简要介绍。
- en: 'The `Protocol` type, as presented in [PEP 544—Protocols: Structural subtyping
    (static duck typing)](https://fpy.li/pep544), is similar to interfaces in Go:
    a protocol type is defined by specifying one or more methods, and the type checker
    verifies that those methods are implemented where that protocol type is required.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '如[PEP 544—Protocols: Structural subtyping (static duck typing)](https://fpy.li/pep544)中所述，`Protocol`类型类似于Go中的接口：通过指定一个或多个方法来定义协议类型，并且类型检查器验证在需要该协议类型的地方这些方法是否被实现。'
- en: In Python, a protocol definition is written as a `typing.Protocol` subclass.
    However, classes that *implement* a protocol don’t need to inherit, register,
    or declare any relationship with the class that *defines* the protocol. It’s up
    to the type checker to find the available protocol types and enforce their usage.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，协议定义被写作`typing.Protocol`子类。然而，*实现*协议的类不需要继承、注册或声明与*定义*协议的类的任何关系。这取决于类型检查器找到可用的协议类型并强制执行它们的使用。
- en: 'Here is a problem that can be solved with the help of `Protocol` and `TypeVar`.
    Suppose you want to create a function `top(it, n)` that returns the largest `n`
    elements of the iterable `it`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以借助`Protocol`和`TypeVar`解决的问题。假设您想创建一个函数`top(it, n)`，返回可迭代对象`it`中最大的`n`个元素：
- en: '[PRE69]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: A parameterized generic `top` would look like what’s shown in [Example 8-19](#top_undefined_t_ex).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一个参数化的泛型`top`看起来像[示例8-19](#top_undefined_t_ex)中所示的样子。
- en: Example 8-19\. `top` function with an undefined `T` type parameter
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-19。带有未定义`T`类型参数的`top`函数
- en: '[PRE70]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The problem is how to constrain `T`? It cannot be `Any` or `object`, because
    the `series` must work with `sorted`. The `sorted` built-in actually accepts `Iterable[Any]`,
    but that’s because the optional parameter `key` takes a function that computes
    an arbitrary sort key from each element. What happens if you give `sorted` a list
    of plain objects but don’t provide a `key` argument? Let’s try that:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是如何约束`T`？它不能是`Any`或`object`，因为`series`必须与`sorted`一起工作。`sorted`内置实际上接受`Iterable[Any]`，但这是因为可选参数`key`接受一个函数，该函数从每个元素计算任意排序键。如果您给`sorted`一个普通对象列表但不提供`key`参数会发生什么？让我们试试：
- en: '[PRE71]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The error message shows that `sorted` uses the `<` operator on the elements
    of the iterable. Is this all it takes? Let’s do another quick experiment:^([15](ch08.html#idm46582441439040))
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息显示`sorted`在可迭代对象的元素上使用`<`运算符。这就是全部吗？让我们做另一个快速实验：^([15](ch08.html#idm46582441439040))
- en: '[PRE72]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'That confirms it: I can `sort` a list of `Spam` because `Spam` implements `__lt__`—the
    special method that supports the `<` operator.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 那证实了：我可以对`Spam`列表进行`sort`，因为`Spam`实现了`__lt__`——支持`<`运算符的特殊方法。
- en: So the `T` type parameter in [Example 8-19](#top_undefined_t_ex) should be limited
    to types that implement `__lt__`. In [Example 8-18](#mode_hashable_ex) we needed
    a type parameter that implemented `__hash__`, so we were able to use `typing.Hashable`
    as the upper bound for the type parameter. But now there is no suitable type in
    `typing` or `abc` to use, so we need to create it.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，[示例 8-19](#top_undefined_t_ex) 中的 `T` 类型参数应该限制为实现 `__lt__` 的类型。在 [示例 8-18](#mode_hashable_ex)
    中，我们需要一个实现 `__hash__` 的类型参数，因此我们可以使用 `typing.Hashable` 作为类型参数的上界。但是现在在 `typing`
    或 `abc` 中没有适合的类型，因此我们需要创建它。
- en: '[Example 8-20](#comparable_protocol_ex) shows the new `SupportsLessThan` type,
    a `Protocol`.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-20](#comparable_protocol_ex) 展示了新的 `SupportsLessThan` 类型，一个 `Protocol`。'
- en: 'Example 8-20\. *comparable.py*: definition of a `SupportsLessThan` `Protocol`
    type'
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 8-20\. *comparable.py*: `SupportsLessThan` `Protocol` 类型的定义'
- en: '[PRE73]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[![1](assets/1.png)](#co_type_hints_in_functions_CO7-1)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_type_hints_in_functions_CO7-1)'
- en: A protocol is a subclass of `typing.Protocol`.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 协议是 `typing.Protocol` 的子类。
- en: '[![2](assets/2.png)](#co_type_hints_in_functions_CO7-2)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_type_hints_in_functions_CO7-2)'
- en: The body of the protocol has one or more method definitions, with `...` in their
    bodies.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 协议的主体有一个或多个方法定义，方法体中有 `...`。
- en: A type `T` is *consistent-with* a protocol `P` if `T` implements all the methods
    defined in `P`, with matching type signatures.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型 `T` 实现了 `P` 中定义的所有方法，并且类型签名匹配，则类型 `T` 与协议 `P` *一致*。
- en: Given `SupportsLessThan`, we can now define this working version of `top` in
    [Example 8-21](#top_protocol_ex).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 有了 `SupportsLessThan`，我们现在可以在 [示例 8-21](#top_protocol_ex) 中定义这个可工作的 `top` 版本。
- en: 'Example 8-21\. *top.py*: definition of the `top` function using a `TypeVar`
    with `bound=SupportsLessThan`'
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 8-21\. *top.py*: 使用 `TypeVar` 和 `bound=SupportsLessThan` 定义 `top` 函数'
- en: '[PRE74]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Let’s test-drive `top`. [Example 8-22](#top_protocol_test) shows part of a test
    suite for use with `pytest`. It tries calling `top` first with a generator expression
    that yields `tuple[int, str]`, and then with a list of `object`. With the list
    of `object`, we expect to get a `TypeError` exception.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试 `top`。[示例 8-22](#top_protocol_test) 展示了一部分用于 `pytest` 的测试套件。首先尝试使用生成器表达式调用
    `top`，该表达式生成 `tuple[int, str]`，然后使用 `object` 列表。对于 `object` 列表，我们期望得到一个 `TypeError`
    异常。
- en: 'Example 8-22\. *top_test.py*: partial listing of the test suite for `top`'
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 8-22\. *top_test.py*: `top` 测试套件的部分清单'
- en: '[PRE75]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[![1](assets/1.png)](#co_type_hints_in_functions_CO8-1)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_type_hints_in_functions_CO8-1)'
- en: The `typing.TYPE_CHECKING` constant is always `False` at runtime, but type checkers
    pretend it is `True` when they are type checking.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing.TYPE_CHECKING` 常量在运行时始终为 `False`，但类型检查器在进行类型检查时会假装它为 `True`。'
- en: '[![2](assets/2.png)](#co_type_hints_in_functions_CO8-2)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_type_hints_in_functions_CO8-2)'
- en: Explicit type declaration for the `series` variable, to make the Mypy output
    easier to read.^([16](ch08.html#idm46582440867904))
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 显式声明 `series` 变量的类型，以使 Mypy 输出更易读。^([16](ch08.html#idm46582440867904))
- en: '[![3](assets/3.png)](#co_type_hints_in_functions_CO8-3)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_type_hints_in_functions_CO8-3)'
- en: This `if` prevents the next three lines from executing when the test runs.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `if` 阻止了接下来的三行在测试运行时执行。
- en: '[![4](assets/4.png)](#co_type_hints_in_functions_CO8-4)'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_type_hints_in_functions_CO8-4)'
- en: '`reveal_type()` cannot be called at runtime, because it is not a regular function
    but a Mypy debugging facility—that’s why there is no `import` for it. Mypy will
    output one debugging message for each `reveal_type()` pseudofunction call, showing
    the inferred type of the argument.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`reveal_type()` 不能在运行时调用，因为它不是常规函数，而是 Mypy 的调试工具—这就是为什么没有为它导入任何内容。对于每个 `reveal_type()`
    伪函数调用，Mypy 将输出一条调试消息，显示参数的推断类型。'
- en: '[![5](assets/5.png)](#co_type_hints_in_functions_CO8-5)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_type_hints_in_functions_CO8-5)'
- en: This line will be flagged as an error by Mypy.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将被 Mypy 标记为错误。
- en: The preceding tests pass—but they would pass anyway, with or without type hints
    in *top.py*. More to the point, if I check that test file with Mypy, I see that
    the `TypeVar` is working as intended. See the `mypy` command output in [Example 8-23](#top_protocol_mypy_output).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试通过了—但无论是否在 *top.py* 中有类型提示，它们都会通过。更重要的是，如果我用 Mypy 检查该测试文件，我会看到 `TypeVar`
    正如预期的那样工作。查看 [示例 8-23](#top_protocol_mypy_output) 中的 `mypy` 命令输出。
- en: Warning
  id: totrans-462
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of Mypy 0.910 (July 2021), the output of `reveal_type` does not show precisely
    the types I declared in some cases, but compatible types instead. For example,
    I did not use `typing.Iterator` but used `abc.Iterator`. Please ignore this detail.
    The Mypy output is still useful. I will pretend this issue of Mypy is fixed when
    discussing the output.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Mypy 0.910（2021 年 7 月），`reveal_type` 的输出在某些情况下并不精确显示我声明的类型，而是显示兼容的类型。例如，我没有使用
    `typing.Iterator`，而是使用了 `abc.Iterator`。请忽略这个细节。Mypy 的输出仍然有用。在讨论输出时，我会假装 Mypy 的这个问题已经解决。
- en: Example 8-23\. Output of *mypy top_test.py* (lines split for readability)
  id: totrans-464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-23\. *mypy top_test.py* 的输出（为了可读性而拆分的行）
- en: '[PRE76]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[![1](assets/1.png)](#co_type_hints_in_functions_CO9-1)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_type_hints_in_functions_CO9-1)'
- en: In `test_top_tuples`, `reveal_type(series)` shows it is an `Iterator[tuple[int,
    str]]`—which I explicitly declared.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `test_top_tuples` 中，`reveal_type(series)` 显示它是一个 `Iterator[tuple[int, str]]`—这是我明确声明的。
- en: '[![2](assets/2.png)](#co_type_hints_in_functions_CO9-2)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_type_hints_in_functions_CO9-2)'
- en: '`reveal_type(result)` confirms that the type returned by the `top` call is
    what I wanted: given the type of `series`, the `result` is `list[tuple[int, str]]`.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`reveal_type(result)` 确认了 `top` 调用返回的类型是我想要的：给定 `series` 的类型，`result` 是 `list[tuple[int,
    str]]`。'
- en: '[![3](assets/3.png)](#co_type_hints_in_functions_CO9-3)'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_type_hints_in_functions_CO9-3)'
- en: 'In `test_top_objects_error`, `reveal_type(series)` shows it is `list[object*]`.
    Mypy puts a `*` after any type that was inferred: I did not annotate the type
    of `series` in this test.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `test_top_objects_error` 中，`reveal_type(series)` 显示为 `list[object*]`。Mypy
    在任何推断的类型后面加上 `*`：我没有在这个测试中注释 `series` 的类型。
- en: '[![4](assets/4.png)](#co_type_hints_in_functions_CO9-4)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_type_hints_in_functions_CO9-4)'
- en: 'Mypy flags the error that this test intentionally triggers: the element type
    of the `Iterable` `series` cannot be `object` (it must be of type `SupportsLessThan`).'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy标记了这个测试故意触发的错误：`Iterable` `series`的元素类型不能是`object`（必须是`SupportsLessThan`类型）。
- en: A key advantage of a protocol type over ABCs is that a type doesn’t need any
    special declaration to be *consistent-with* a protocol type. This allows a protocol
    to be created leveraging preexisting types, or types implemented in code that
    we do not control. I don’t need to derive or register `str`, `tuple`, `float`,
    `set`, etc. with `SupportsLessThan` to use them where a `SupportsLessThan` parameter
    is expected. They only need to implement `__lt__`. And the type checker will still
    be able do its job, because `SupportsLessThan` is explicitly defined as a `Protocol`—in
    contrast with the implicit protocols that are common with duck typing, which are
    invisible to the type checker.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 协议类型相对于ABCs的一个关键优势是，一个类型不需要任何特殊声明来*与协议类型一致*。这允许创建一个协议利用预先存在的类型，或者在我们无法控制的代码中实现的类型。我不需要派生或注册`str`、`tuple`、`float`、`set`等类型到`SupportsLessThan`以在期望`SupportsLessThan`参数的地方使用它们。它们只需要实现`__lt__`。而类型检查器仍然能够完成其工作，因为`SupportsLessThan`被明确定义为`Protocol`—与鸭子类型常见的隐式协议相反，这些协议对类型检查器是不可见的。
- en: 'The special `Protocol` class was introduced in [PEP 544—Protocols: Structural
    subtyping (static duck typing)](https://fpy.li/pep544). [Example 8-21](#top_protocol_ex)
    demonstrates why this feature is known as *static duck typing*: the solution to
    annotate the `series` parameter of `top` was to say “The nominal type of `series`
    doesn’t matter, as long as it implements the `__lt__` method.” Python’s duck typing
    always allowed us to say that implicitly, leaving static type checkers clueless.
    A type checker can’t read CPython’s source code in C, or perform console experiments
    to find out that `sorted` only requires that the elements support `<`.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '特殊的`Protocol`类在[PEP 544—Protocols: Structural subtyping (static duck typing)](https://fpy.li/pep544)中引入。[示例8-21](#top_protocol_ex)展示了为什么这个特性被称为*静态鸭子类型*：注释`top`的`series`参数的解决方案是说“`series`的名义类型并不重要，只要它实现了`__lt__`方法。”Python的鸭子类型总是允许我们隐式地说这一点，让静态类型检查器一头雾水。类型检查器无法阅读CPython的C源代码，或者执行控制台实验来发现`sorted`只需要元素支持`<`。'
- en: Now we can make duck typing explicit for static type checkers. That’s why it
    makes sense to say that `typing.Protocol` gives us *static duck typing*.^([17](ch08.html#idm46582440752416))
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为静态类型检查器明确地定义鸭子类型。这就是为什么说`typing.Protocol`给我们*静态鸭子类型*是有意义的。^([17](ch08.html#idm46582440752416))
- en: There’s more to see about `typing.Protocol`. We’ll come back to it in Part IV,
    where [Chapter 13](ch13.html#ifaces_prot_abc) contrasts structural typing, duck
    typing, and ABCs—another approach to formalizing protocols. In addition, [“Overloaded
    Signatures”](ch15.html#overload_sec) ([Chapter 15](ch15.html#more_types_ch)) explains
    how to declare overloaded function signatures with `@typing.overload`, and includes
    an extensive example using `typing.Protocol` and a bounded `TypeVar`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多关于`typing.Protocol`的内容。我们将在第四部分回来讨论它，在[第13章](ch13.html#ifaces_prot_abc)中对比结构化类型、鸭子类型和ABCs——另一种形式化协议的方法。此外，[“重载签名”](ch15.html#overload_sec)（[第15章](ch15.html#more_types_ch)）解释了如何使用`@typing.overload`声明重载函数签名，并包括了一个使用`typing.Protocol`和有界`TypeVar`的广泛示例。
- en: Note
  id: totrans-478
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`typing.Protocol` makes it possible to annotate the `double` function presented
    in [“Types Are Defined by Supported Operations”](#types_defined_by_ops_sec) without
    losing functionality. The key is to define a protocol class with the `__mul__`
    method. I invite you to do that as an exercise. The solution appears in [“The
    Typed double Function”](ch13.html#typed_double_sec) ([Chapter 13](ch13.html#ifaces_prot_abc)).'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing.Protocol`使得可以注释[“类型由支持的操作定义”](#types_defined_by_ops_sec)中提到的`double`函数而不会失去功能。关键是定义一个带有`__mul__`方法的协议类。我邀请你将其作为练习完成。解决方案出现在[“类型化的double函数”](ch13.html#typed_double_sec)中（[第13章](ch13.html#ifaces_prot_abc)）。'
- en: Callable
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Callable
- en: 'To annotate callback parameters or callable objects returned by higher-order
    functions, the `collections.abc` module provides the `Callable` type, available
    in the `typing` module for those not yet using Python 3.9. A `Callable` type is
    parameterized like this:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注释回调参数或由高阶函数返回的可调用对象，`collections.abc`模块提供了`Callable`类型，在尚未使用Python 3.9的情况下在`typing`模块中可用。`Callable`类型的参数化如下：
- en: '[PRE77]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The parameter list—`[ParamType1, ParamType2]`—can have zero or more types.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表—`[ParamType1, ParamType2]`—可以有零个或多个类型。
- en: 'Here is an example in the context of a `repl` function, part of a simple interactive
    interpreter we’ll see in [“Pattern Matching in lis.py: A Case Study”](ch18.html#pattern_matching_case_study_sec):^([18](ch08.html#idm46582440727296))'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在我们将在[“lis.py中的模式匹配：案例研究”](ch18.html#pattern_matching_case_study_sec)中看到的一个`repl`函数的示例：^([18](ch08.html#idm46582440727296))
- en: '[PRE78]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'During normal usage, the `repl` function uses Python’s `input` built-in to
    read expressions from the user. However, for automated testing or for integration
    with other input sources, `repl` accepts an optional `input_fn` parameter: a `Callable`
    with the same parameter and return types as `input`.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常使用中，`repl`函数使用Python的`input`内置函数从用户那里读取表达式。然而，对于自动化测试或与其他输入源集成，`repl`接受一个可选的`input_fn`参数：一个与`input`具有相同参数和返回类型的`Callable`。
- en: 'The built-in `input` has this signature on typeshed:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`input`在typeshed上有这个签名：
- en: '[PRE79]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `input` signature is *consistent-with* this `Callable` type hint:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`input`的签名与这个`Callable`类型提示*一致*：'
- en: '[PRE80]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'There is no syntax to annotate optional or keyword argument types. The [documentation](https://fpy.li/8-34)
    of `typing.Callable` says “such function types are rarely used as callback types.”
    If you need a type hint to match a function with a flexible signature, replace
    the whole parameter list with `...`—like this:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 没有语法来注释可选或关键字参数类型。`typing.Callable`的[文档](https://fpy.li/8-34)说“这样的函数类型很少用作回调类型。”如果你需要一个类型提示来匹配具有灵活签名的函数，用`...`替换整个参数列表—就像这样：
- en: '[PRE81]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The interaction of generic type parameters with a type hierarchy introduces
    a new typing concept: variance.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型参数与类型层次结构的交互引入了一个新的类型概念：variance。
- en: Variance in Callable types
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Callable类型中的variance
- en: 'Imagine a temperature control system with a simple `update` function as shown
    in [Example 8-24](#callable_variance_ex). The `update` function calls the `probe`
    function to get the current temperature, and calls `display` to show the temperature
    to the user. Both `probe` and `display` are passed as arguments to `update` for
    didactic reasons. The goal of the example is to contrast two `Callable` annotations:
    one with a return type, the other with a parameter type.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个简单的温度控制系统，其中有一个简单的`update`函数，如[示例8-24](#callable_variance_ex)所示。`update`函数调用`probe`函数获取当前温度，并调用`display`显示温度给用户。`probe`和`display`都作为参数传递给`update`是为了教学目的。示例的目标是对比两个`Callable`注释：一个有返回类型，另一个有参数类型。
- en: Example 8-24\. Illustrating variance.
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-24。说明variance。
- en: '[PRE82]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[![1](assets/1.png)](#co_type_hints_in_functions_CO10-1)'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_type_hints_in_functions_CO10-1)'
- en: '`update` takes two callables as arguments.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`接受两个可调用对象作为参数。'
- en: '[![2](assets/2.png)](#co_type_hints_in_functions_CO10-2)'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_type_hints_in_functions_CO10-2)'
- en: '`probe` must be a callable that takes no arguments and returns a `float`.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`probe`必须是一个不带参数并返回`float`的可调用对象。'
- en: '[![3](assets/3.png)](#co_type_hints_in_functions_CO10-3)'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_type_hints_in_functions_CO10-3)'
- en: '`display` takes a `float` argument and returns `None`.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`display`接受一个`float`参数并返回`None`。'
- en: '[![4](assets/4.png)](#co_type_hints_in_functions_CO10-4)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_type_hints_in_functions_CO10-4)'
- en: '`probe_ok` is *consistent-with* `Callable[[], float]` because returning an
    `int` does not break code that expects a `float`.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`probe_ok`与`Callable[[], float]`一致，因为返回一个`int`不会破坏期望`float`的代码。'
- en: '[![5](assets/5.png)](#co_type_hints_in_functions_CO10-5)'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_type_hints_in_functions_CO10-5)'
- en: '`display_wrong` is not *consistent-with* `Callable[[float], None]` because
    there’s no guarantee that a function that expects an `int` can handle a `float`;
    for example, Python’s `hex` function accepts an `int` but rejects a `float`.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`display_wrong`与`Callable[[float], None]`不一致，因为没有保证一个期望`int`的函数能处理一个`float`；例如，Python的`hex`函数接受一个`int`但拒绝一个`float`。'
- en: '[![6](assets/6.png)](#co_type_hints_in_functions_CO10-6)'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_type_hints_in_functions_CO10-6)'
- en: Mypy flags this line because `display_wrong` is incompatible with the type hint
    in the `display` parameter of `update`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy标记这行是因为`display_wrong`与`update`的`display`参数中的类型提示不兼容。
- en: '[![7](assets/7.png)](#co_type_hints_in_functions_CO10-7)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_type_hints_in_functions_CO10-7)'
- en: '`display_ok` is *consistent-with* `Callable[[float], None]` because a function
    that accepts a `complex` can also handle a `float` argument.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`display_ok`与`Callable[[float], None]`一致，因为一个接受`complex`的函数也可以处理一个`float`参数。'
- en: '[![8](assets/8.png)](#co_type_hints_in_functions_CO10-8)'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_type_hints_in_functions_CO10-8)'
- en: Mypy is happy with this line.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy对这行很满意。
- en: To summarize, it’s OK to provide a callback that returns an `int` when the code
    expects a callback that returns a `float`, because an `int` value can always be
    used where a `float` is expected.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，当代码期望返回`float`的回调时，提供返回`int`的回调是可以的，因为`int`值总是可以在需要`float`的地方使用。
- en: Formally, we say that `Callable[[], int]` is *subtype-of* `Callable[[], float]`—as
    `int` is *subtype-of* `float`. This means that `Callable` is *covariant* on the
    return type because the *subtype-of* relationship of the types `int` and `float`
    is in the same direction as the relationship of the `Callable` types that use
    them as return types.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 正式地说，`Callable[[], int]`是*subtype-of*`Callable[[], float]`——因为`int`是*subtype-of*`float`。这意味着`Callable`在返回类型上是*协变*的，因为类型`int`和`float`的*subtype-of*关系与使用它们作为返回类型的`Callable`类型的关系方向相同。
- en: On the other hand, it’s a type error to provide a callback that takes a `int`
    argument when a callback that handles a `float` is required.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当需要处理`float`时，提供一个接受`int`参数的回调是类型错误的。
- en: 'Formally, `Callable[[int], None]` is not a *subtype-of* `Callable[[float],
    None]`. Although `int` is *subtype-of* `float`, in the parameterized `Callable`
    type the relationship is reversed: `Callable[[float], None]` is *subtype-of* `Callable[[int],
    None]`. Therefore we say that `Callable` is *contravariant* on the declared parameter
    types.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 正式地说，`Callable[[int], None]`不是*subtype-of*`Callable[[float], None]`。虽然`int`是*subtype-of*`float`，但在参数化的`Callable`类型中，关系是相反的：`Callable[[float],
    None]`是*subtype-of*`Callable[[int], None]`。因此我们说`Callable`在声明的参数类型上是*逆变*的。
- en: '[“Variance”](ch15.html#variance_sec) in [Chapter 15](ch15.html#more_types_ch)
    explains variance with more details and examples of invariant, covariant, and
    contravariant types.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '[��Variance”](ch15.html#variance_sec)在[第15章](ch15.html#more_types_ch)中详细解释了variance，并提供了不变、协变和逆变类型的更多细节和示例。'
- en: Tip
  id: totrans-519
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'For now, rest assured that most parameterized generic types are *invariant*,
    therefore simpler. For example, if I declare `scores: list[float]`, that tells
    me exactly what I can assign to `scores`. I can’t assign objects declared as `list[int]`
    or `list[complex]`:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '目前，可以放心地说，大多数参数化的泛型类型是*invariant*，因此更简单。例如，如果我声明`scores: list[float]`，那告诉我可以分配给`scores`的对象。我不能分配声明为`list[int]`或`list[complex]`的对象：'
- en: A `list[int]` object is not acceptable because it cannot hold `float` values
    which my code may need to put into `scores`.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`list[int]`对象是不可接受的，因为它不能容纳`float`值，而我的代码可能需要将其放入`scores`中。
- en: A `list[complex]` object is not acceptable because my code may need to sort
    `scores` to find the median, but `complex` does not provide `__lt__`, therefore
    `list[complex]` is not sortable.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`list[complex]`对象是不可接受的，因为我的代码可能需要对`scores`进行排序以找到中位数，但`complex`没有提供`__lt__`，因此`list[complex]`是不可排序的。
- en: Now we get to the last special type we’ll cover in this chapter.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论本章中最后一个特殊类型。
- en: NoReturn
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NoReturn
- en: This is a special type used only to annotate the return type of functions that
    never return. Usually, they exist to raise exceptions. There are dozens of such
    functions in the standard library.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种特殊类型，仅用于注释永远不返回的函数的返回类型。通常，它们存在是为了引发异常。标准库中有数十个这样的函数。
- en: For example, `sys.exit()` raises `SystemExit` to terminate the Python process.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`sys.exit()`引发`SystemExit`来终止Python进程。
- en: 'Its signature in `typeshed` is:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 它在`typeshed`中的签名是：
- en: '[PRE83]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `__status` parameter is positional only, and it has a default value. Stub
    files don’t spell out the default values, they use `...` instead. The type of
    `__status` is `object`, which means it may also be `None`, therefore it would
    be redundant to mark it `Optional[object]`.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`__status`参数是仅位置参数，并且具有默认值。存根文件不详细说明默认值，而是使用`...`。`__status`的类型是`object`，这意味着它也可能是`None`，因此标记为`Optional[object]`将是多��的。'
- en: In [Chapter 24](ch24.html#class_metaprog), [Example 24-6](ch24.html#checked_class_bottom_ex)
    uses `NoReturn` in the `__flag_unknown_attrs`, a method designed to produce a
    user-friendly and comprehensive error message, and then raise `AttributeError`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第24章](ch24.html#class_metaprog)中，[示例 24-6](ch24.html#checked_class_bottom_ex)在`__flag_unknown_attrs`中使用`NoReturn`，这是一个旨在生成用户友好和全面错误消息的方法，然后引发`AttributeError`。
- en: The last section in this epic chapter is about positional and variadic parameters.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这一史诗般章节的最后一节是关于位置和可变参数。
- en: Annotating Positional Only and Variadic Parameters
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释位置参数和可变参数
- en: 'Recall the `tag` function from [Example 7-9](ch07.html#tagger_ex). The last
    time we saw its signature was in [“Positional-Only Parameters”](ch07.html#positional_only_params):'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下从[示例 7-9](ch07.html#tagger_ex)中的`tag`函数。我们上次看到它的签名是在[“仅位置参数”](ch07.html#positional_only_params)中：
- en: '[PRE84]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Here is `tag`, fully annotated, written in several lines—a common convention
    for long signatures, with line breaks the way the [*blue*](https://fpy.li/8-10)
    formatter would do it:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`tag`，完全注释，写成几行——长签名的常见约定，使用换行符的方式，就像[*蓝色*](https://fpy.li/8-10)格式化程序会做的那样：
- en: '[PRE85]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Note the type hint `*content: str` for the arbitrary positional parameters;
    this means all those arguments must be of type `str`. The type of the `content`
    local variable in the function body will be `tuple[str, ...]`.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '注意对于任意位置参数的类型提示`*content: str`；这意味着所有这些参数必须是`str`类型。函数体中`content`的类型将是`tuple[str,
    ...]`。'
- en: 'The type hint for the arbitrary keyword arguments is `**attrs: str` in this
    example, therefore the type of `attrs` inside the function will be `dict[str,
    str]`. For a type hint like `**attrs: float`, the type of `attrs` in the function
    would be `dict[str, float]`.``'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，任意关键字参数的类型提示是`**attrs: str`，因此函数内部的`attrs`类型将是`dict[str, str]`。对于像`**attrs:
    float`这样的类型提示，函数内部的`attrs`类型将是`dict[str, float]`。'
- en: 'If the `attrs` parameter must accept values of different types, you’ll need
    to use a `Union[]` or `Any`: `**attrs: Any`.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '如果`attrs`参数必须接受不同类型的值，你需要使用`Union[]`或`Any`：`**attrs: Any`。'
- en: 'The `/` notation for positional-only parameters is only available in Python
    ≥ 3.8. In Python 3.7 or earlier, that’s a syntax error. The [PEP 484 convention](https://fpy.li/8-36)
    is to prefix each positional-only parameter name with two underscores. Here is
    the `tag` signature again, now in two lines, using the PEP 484 convention:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 仅位置参数的`/`符号仅适用于 Python ≥ 3.8。在 Python 3.7 或更早版本中，这将是语法错误。[PEP 484约定](https://fpy.li/8-36)是在每个位置参数名称前加上两个下划线。这里是`tag`签名，再次以两行的形式，使用PEP
    484约定：
- en: '[PRE86]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Mypy understands and enforces both ways of declaring positional-only parameters.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy理解并强制执行声明位置参数的两种方式。
- en: To close this chapter, let’s briefly consider the limits of type hints and the
    static type system they support.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章，让我们简要地考虑一下类型提示的限制以及它们支持的静态类型系统。
- en: Imperfect Typing and Strong Testing
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不完美的类型和强大的测试
- en: Maintainers of large corporate codebases report that many bugs are found by
    static type checkers and fixed more cheaply than if the bugs were discovered only
    after the code is running in production. However, it’s essential to note that
    automated testing was standard practice and widely adopted long before static
    typing was introduced in the companies that I know about.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 大型公司代码库的维护者报告说，许多错误是由静态类型检查器发现的，并且比在代码运行在生产环境后才发现这些错误更便宜修复。然而，值得注意的是，在我所知道的公司中，自动化测试在静态类型引入之前就是标准做法并被广泛采用。
- en: 'Even in the contexts where they are most beneficial, static typing cannot be
    trusted as the ultimate arbiter of correctness. It’s not hard to find:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在它们最有益处的情况下，静态类型也不能被信任为正确性的最终仲裁者。很容易找到：
- en: False positives
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 假阳性
- en: Tools report type errors on code that is correct.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 工具会报告代码中正确的类型错误。
- en: False negatives
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 假阴性
- en: Tools don’t report type errors on code that is incorrect.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 工具不会报告代码中不正确的类型错误。
- en: 'Also, if we are forced to type check everything, we lose some of the expressive
    power of Python:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们被迫对所有内容进行类型检查，我们将失去Python的一些表现力：
- en: Some handy features can’t be statically checked; for example, argument unpacking
    like `config(**settings)`.
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些方便的功能无法进行静态检查；例如，像`config(**settings)`这样的参数解包。
- en: Advanced features like properties, descriptors, metaclasses, and metaprogramming
    in general are poorly supported or beyond comprehension for type checkers.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性、描述符、元类和一般元编程等高级功能对类型检查器的支持较差或超出理解范围。
- en: Type checkers lag behind Python releases, rejecting or even crashing while analyzing
    code with new language features—for more than a year in some cases.
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型检查器落后于Python版本，拒绝甚至在分析具有新语言特性的代码时崩溃——在某些情况下超过一年。
- en: Common data constraints cannot be expressed in the type system—even simple ones.
    For example, type hints are unable to ensure “quantity must be an integer > 0”
    or “label must be a string with 6 to 12 ASCII letters.” In general, type hints
    are not helpful to catch errors in business logic.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的数据约束无法在类型系统中表达，甚至是简单的约束。例如，类型提示无法确保“数量必须是大于0的整数”或“标签必须是具有6到12个ASCII字母的字符串”。总的来说，类型提示对捕捉业务逻辑中的错误并不有帮助。
- en: Given those caveats, type hints cannot be the mainstay of software quality,
    and making them mandatory without exception would amplify the downsides.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些注意事项，类型提示不能成为软件质量的主要支柱，强制性地使其成为例外会放大缺点。
- en: Consider a static type checker as one of the tools in a modern CI pipeline,
    along with test runners, linters, etc. The point of a CI pipeline is to reduce
    software failures, and automated tests catch many bugs that are beyond the reach
    of type hints. Any code you can write in Python, you can test in Python—with or
    without type hints.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 将静态类型检查器视为现代CI流水线中的工具之一，与测试运行器、代码检查器等一起。CI流水线的目的是减少软件故障，自动化测试可以捕获许多超出类型提示范围的错误。你可以在Python中编写的任何代码，都可以在Python中进行测试，无论是否有类型提示。
- en: Note
  id: totrans-558
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: 'The title and conclusion of this section were inspired by Bruce Eckel’s article
    [“Strong Typing vs. Strong Testing”](https://fpy.li/8-37), also published in the
    anthology [*The Best Software Writing I*](https://fpy.li/8-38), edited by Joel
    Spolsky (Apress). Bruce is a fan of Python and author of books about C++, Java,
    Scala, and Kotlin. In that post, he tells how he was a static typing advocate
    until he learned Python and concluded: “If a Python program has adequate unit
    tests, it can be as robust as a C++, Java, or C# program with adequate unit tests
    (although the tests in Python will be faster to write).”'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的标题和结论受到Bruce Eckel的文章[“强类型 vs. 强测试”](https://fpy.li/8-37)的启发，该文章也发表在Joel
    Spolsky（Apress）编辑的文集[*The Best Software Writing I*](https://fpy.li/8-38)中。Bruce是Python的粉丝，也是关于C++、Java、Scala和Kotlin的书籍的作者。在那篇文章中，他讲述了他是如何成为静态类型支持者的，直到学习Python并得出结论：“如果一个Python程序有足够的单元测试，它可以和有足够单元测试的C++、Java或C#程序一样健壮（尽管Python中的测试编写速度更快）。”
- en: This wraps up our coverage of Python’s type hints for now. They are also the
    main focus of [Chapter 15](ch15.html#more_types_ch), which covers generic classes,
    variance, overloaded signatures, type casting, and more. Meanwhile, type hints
    will make guest appearances in several examples throughout the book.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们的Python类型提示覆盖到这里。它们也是[第15章](ch15.html#more_types_ch)的主要内容，该章涵盖了泛型类、变异、重载签名、类型转换等。与此同时，类型提示将在本书的几个示例中做客串出现。
- en: Chapter Summary
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: We started with a brief introduction to the concept of gradual typing and then
    switched to a hands-on approach. It’s hard to see how gradual typing works without
    a tool that actually reads the type hints, so we developed an annotated function
    guided by Mypy error reports.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从对渐进式类型概念的简要介绍开始，然后转向实践方法。没有一个实际读取类型提示的工具，很难看出渐进式类型是如何工作的，因此我们开发了一个由Mypy错误报告引导的带注解函数。
- en: Back to the idea of gradual typing, we explored how it is a hybrid of Python’s
    traditional duck typing and the nominal typing more familiar to users of Java,
    C++, and other statically typed languages.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 回到渐进式类型的概念，我们探讨了它是Python传统鸭子类型和用户更熟悉的Java、C++等静态类型语言的名义类型的混合体。
- en: Most of the chapter was devoted to presenting the major groups of types used
    in annotations. Many of the types we covered are related to familiar Python object
    types, such as collections, tuples, and callables—extended to support generic
    notation like `Sequence[float]`. Many of those types are temporary surrogates
    implemented in the `typing` module before the standard types were changed to support
    generics in Python 3.9.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分章节都致力于介绍注解中使用的主要类型组。我们涵盖的许多类型与熟悉的Python对象类型相关，如集合、元组和可调用对象，扩展以支持类似`Sequence[float]`的泛型表示。许多这些类型是在Python
    3.9之前在`typing`模块中实现的临时替代品，直到标准类型被更改以支持泛型。
- en: Some of the types are special entities. `Any`, `Optional`, `Union`, and `NoReturn`
    have nothing to do with actual objects in memory, but exist only in the abstract
    domain of the type system.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类型是特殊实体。`Any`、`Optional`、`Union`和`NoReturn`与内存中的实际对象无关，而仅存在于类型系统的抽象领域中。
- en: We studied parameterized generics and type variables, which bring more flexibility
    to type hints without sacrificing type safety.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了参数化泛型和类型变量，这为类型提示带来了更多灵活性，而不会牺牲类型安全性。
- en: 'Parameterized generics become even more expressive with the use of `Protocol`.
    Because it appeared only in Python 3.8, `Protocol` is not widely used yet—but
    it is hugely important. `Protocol` enables static duck typing: the essential bridge
    between Python’s duck-typed core and the nominal typing that allows static type
    checkers to catch bugs.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Protocol`使参数化泛型变得更加表达丰富。因为它仅出现在Python 3.8中，`Protocol`目前并不广泛使用，但它非常重要。`Protocol`实现了静态鸭子类型：Python鸭子类型核心与名义类型之间的重要桥梁，使静态类型检查器能够捕捉错误。
- en: While covering some of these types, we experimented with Mypy to see type checking
    errors and inferred types with the help of Mypy’s magic `reveal_type()` function.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍一些类型的同时，我们通过Mypy进行实验，以查看类型检查错误，并借助Mypy的神奇`reveal_type()`函数推断类型。
- en: The final section covered how to annotate positional-only and variadic parameters.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一节介绍了如何注释位置参数和可变参数。
- en: Type hints are a complex and evolving topic. Fortunately, they are an optional
    feature. Let us keep Python accessible to the widest user base and stop preaching
    that all Python code should have type hints—as I’ve seen in public sermons by
    typing evangelists.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示是一个复杂且不断发展的主题。幸运的是，它们是一个可选功能。让我们保持Python对最广泛用户群体的可访问性，并停止宣扬所有Python代码都应该有类型提示的说法，就像我在类型提示布道者的公开布道中看到的那样。
- en: 'Our BDFL^([19](ch08.html#idm46582440036816)) emeritus led this push toward
    type hints in Python, so it’s only fair that this chapter starts and ends with
    his words:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的退休BDFL^([19](ch08.html#idm46582440036816))领导了Python中类型提示的推动，因此这一章的开头和结尾都以他的话语开始：
- en: I wouldn’t like a version of Python where I was morally obligated to add type
    hints all the time. I really do think that type hints have their place but there
    are also plenty of times that it’s not worth it, and it’s so wonderful that you
    can choose to use them.^([20](ch08.html#idm46582440034576))
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我不希望有一个我在任何时候都有道义义务添加类型提示的Python版本。我真的认为类型提示有它们的位置，但也有很多时候不值得，而且很棒的是你可以选择使用它们。^([20](ch08.html#idm46582440034576))
- en: ''
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Guido van Rossum
  id: totrans-574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Guido van Rossum
- en: Further Reading
  id: totrans-575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Bernát Gábor wrote in his excellent post, [“The state of type hints in Python”](https://fpy.li/8-41):'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: Bernát Gábor在他的优秀文章中写道，[“Python中类型提示的现状”](https://fpy.li/8-41)：
- en: Type hints should be used whenever unit tests are worth writing.
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只要值得编写单元测试，就应该使用类型提示。
- en: I am a big fan of testing, but I also do a lot of exploratory coding. When I
    am exploring, tests and type hints are not helpful. They are a drag.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我是测试的忠实粉丝，但我也做很多探索性编码。当我在探索时，测试和类型提示并不有用。它们只是累赘。
- en: 'Gábor’s post is one of the best introductions to Python’s type hints that I
    found, along with Geir Arne Hjelle’s [“Python Type Checking (Guide)”](https://fpy.li/8-42).
    [“Hypermodern Python Chapter 4: Typing”](https://fpy.li/8-43) by Claudio Jolowicz
    is a shorter introduction that also covers runtime type checking validation.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: Gábor的文章是我发现的关于Python类型提示的最好介绍之一，还有Geir Arne Hjelle的[“Python类型检查（指南）”](https://fpy.li/8-42)。Claudio
    Jolowicz的[“超现代Python第4章：类型”](https://fpy.li/8-43)是一个更简短的介绍，也涵盖了运行时类型检查验证。
- en: For deeper coverage, the [Mypy documentation](https://fpy.li/8-44) is the best
    source. It is valuable regardless of the type checker you are using, because it
    has tutorial and reference pages about Python typing in general—not just about
    the Mypy tool itself. There you will also find a handy [cheat sheets](https://fpy.li/8-45)
    and a very useful page about [common issues and solutions](https://fpy.li/8-46).
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 想要更深入的了解，[Mypy文档](https://fpy.li/8-44)是最佳来源。它对于任何类型检查器都很有价值，因为它包含了关于Python类型提示的教程和参考页面，不仅仅是关于Mypy工具本身。在那里你还会找到一份方便的[速查表](https://fpy.li/8-45)和一个非常有用的页面，介绍了[常见问题和解决方案](https://fpy.li/8-46)。
- en: The [`typing`](https://fpy.li/typing) module documentation is a good quick reference,
    but it doesn’t go into much detail. [PEP 483—The Theory of Type Hints](https://fpy.li/pep483)
    includes a deep explanation about variance, using `Callable` to illustrate contravariance.
    The ultimate references are the PEP documents related to typing. There are more
    than 20 of them already. The intended audience of PEPs are Python core developers
    and Python’s Steering Council, so they assume a lot of prior knowledge and are
    certainly not light reading.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '[`typing`](https://fpy.li/typing)模块文档是一个很好的快速参考，但它并没有详细介绍。[PEP 483—类型提示理论](https://fpy.li/pep483)包括了关于协变性的深入解释，使用`Callable`来说明逆变性。最终的参考资料是与类型提示相关的PEP文档。已经有20多个了。PEP的目标受众是Python核心开发人员和Python的指导委员会，因此它们假定读者具有大量先前知识，绝对不是轻松阅读。'
- en: As mentioned, [Chapter 15](ch15.html#more_types_ch) covers more typing topics,
    and [“Further Reading”](ch15.html#more_type_hints_further_sec) provides additional
    references, including [Table 15-1](ch15.html#typing_peps_tbl), listing typing
    PEPs approved or under discussion as of late 2021.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，[第15章](ch15.html#more_types_ch)涵盖了更多类型相关主题，而[“进一步阅读”](ch15.html#more_type_hints_further_sec)提供了额外的参考资料，包括[表15-1](ch15.html#typing_peps_tbl)，列出了截至2021年底已批准或正在讨论的类型
    PEPs。
- en: '[“Awesome Python Typing”](https://fpy.li/8-47) is a valuable collection of
    links to tools and references.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '[“了不起的Python类型提示”](https://fpy.li/8-47)是一个有价值的链接集合，包含了工具和参考资料。'
- en: ^([1](ch08.html#idm46582445964528-marker)) [PEP 484—Type Hints](https://fpy.li/8-1),
    “Rationale and Goals”; bold emphasis retained from the original.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.html#idm46582445964528-marker)) [PEP 484—类型提示](https://fpy.li/8-1)，“基本原理和目标”；粗体强调保留自原文。
- en: '^([2](ch08.html#idm46582445928816-marker)) A just-in-time compiler like the
    one in PyPy has much better data than type hints: it monitors the Python program
    as it runs, detects the concrete types in use, and generates optimized machine
    code for those concrete types.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.html#idm46582445928816-marker)) PyPy中的即时��译器比类型提示有更好的数据：它在Python程序运行时监视程序，检测使用的具体类型，并为这些具体类型生成优化的机器代码。
- en: ^([3](ch08.html#idm46582445926464-marker)) For example, recursive types are
    not supported as of July 2021—see `typing` module issue [#182, Define a JSON type](https://fpy.li/8-2)
    and Mypy issue [#731, Support recursive types](https://fpy.li/8-3).
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch08.html#idm46582445926464-marker)) 例如，截至2021年7月，不支持递归类型—参见`typing`模块问题[#182，定义JSON类型](https://fpy.li/8-2)和Mypy问题[#731，支持递归类型](https://fpy.li/8-3)。
- en: ^([4](ch08.html#idm46582445234336-marker)) Python doesn’t provide syntax to
    control the set of possible values for a type—except in `Enum` types. For example,
    using type hints you can’t define `Quantity` as an integer between 1 and 1000,
    or `AirportCode` as a 3-letter combination. NumPy offers `uint8`, `int16`, and
    other machine-oriented numeric types, but in the Python standard library we only
    have types with very small sets of values (`NoneType`, `bool`) or extremely large
    sets (`float`, `int`, `str`, all possible tuples, etc.).
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch08.html#idm46582445234336-marker)) Python没有提供控制类型可能值集合的语法—除了在`Enum`类型中。例如，使用类型提示，你无法将`Quantity`定义为介于1和1000之间的整数，或将`AirportCode`定义为3个字母的组合。NumPy提供了`uint8`、`int16`和其他面向机器的数值类型，但在Python标准库中，我们只有具有非常小值集合（`NoneType`、`bool`）或极大值集合（`float`、`int`、`str`、所有可能的元组等）的类型。
- en: ^([5](ch08.html#idm46582445162944-marker)) Duck typing is an implicit form of
    *structural typing*, which Python ≥ 3.8 also supports with the introduction of
    `typing.Protocol`. This is covered later in this chapter—in [“Static Protocols”](#protocols_in_fn)—with
    more details in [Chapter 13](ch13.html#ifaces_prot_abc).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch08.html#idm46582445162944-marker)) 鸭子类型是一种隐式的*结构类型*形式，Python ≥ 3.8也支持引入`typing.Protocol`。这将在本章后面—[“静态协议”](#protocols_in_fn)—进行介绍，更多细节请参见[第13章](ch13.html#ifaces_prot_abc)。
- en: ^([6](ch08.html#idm46582445123568-marker)) Inheritance is often overused and
    hard to justify in examples that are realistic yet simple, so please accept this
    animal example as a quick illustration of subtyping.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch08.html#idm46582445123568-marker)) 继承经常被滥用，并且很难在现实但简单的示例中证明其合理性，因此请接受这个动物示例作为子类型的快速说明。
- en: '^([7](ch08.html#idm46582444453504-marker)) MIT Professor, programming language
    designer, and Turing Award recipient. Wikipedia: [Barbara Liskov](https://fpy.li/8-14).'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch08.html#idm46582444453504-marker)) 麻省理工学院教授、编程语言设计师和图灵奖获得者。维基百科：[芭芭拉·利斯科夫](https://fpy.li/8-14)。
- en: ^([8](ch08.html#idm46582444129504-marker)) To be more precise, `ord` only accepts
    `str` or `bytes` with `len(s) == 1`. But the type system currently can’t express
    this constraint.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch08.html#idm46582444129504-marker)) 更准确地说，`ord`仅接受`len(s) == 1`的`str`或`bytes`。但目前的类型系统无法表达这个约束。
- en: '^([9](ch08.html#idm46582443927296-marker)) In ABC—the language that most influenced
    the initial design of Python—each list was constrained to accept values of a single
    type: the type of the first item you put into it.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch08.html#idm46582443927296-marker)) 在ABC语言——最初影响Python设计的语言中——每个列表都受限于接受单一类型的值：您放入其中的第一个项目的类型。
- en: ^([10](ch08.html#idm46582443707504-marker)) One of my contributions to the `typing`
    module documentation was to add dozens of deprecation warnings as I reorganized
    the entries below [“Module Contents”](https://fpy.li/8-17) into subsections, under
    the supervision of Guido van Rossum.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch08.html#idm46582443707504-marker)) 我对`typing`模块文档的贡献之一是在Guido van Rossum的监督下将[“模块内容”](https://fpy.li/8-17)下的条目重新组织为子部分，并添加了数十个弃用警告。
- en: ^([11](ch08.html#idm46582442856960-marker)) I use `:=` when it makes sense in
    a few examples, but I don’t cover it in the book. Please see [PEP 572—Assignment
    Expressions](https://fpy.li/pep572) for all the gory details.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch08.html#idm46582442856960-marker)) 在一些示例中，我使用`:=`是有意义的，但我在书中没有涵盖它。请参阅[PEP
    572—赋值表达式](https://fpy.li/pep572)获取所有详细信息。
- en: ^([12](ch08.html#idm46582442746032-marker)) Actually, `dict` is a virtual subclass
    of `abc.MutableMapping`. The concept of a virtual subclass is explained in [Chapter 13](ch13.html#ifaces_prot_abc).
    For now, know that `issubclass(dict, abc.MutableMapping)` is `True`, despite the
    fact that `dict` is implemented in C and does not inherit anything from `abc.MutableMapping`,
    but only from `object`.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch08.html#idm46582442746032-marker)) 实际上，`dict`是`abc.MutableMapping`的虚拟子类。虚拟子类的概念在[第13章](ch13.html#ifaces_prot_abc)中有解释。暂时知道`issubclass(dict,
    abc.MutableMapping)`为`True`，尽管`dict`是用C实现的，不继承任何东西自`abc.MutableMapping`，而只继承自`object`。
- en: ^([13](ch08.html#idm46582442199104-marker)) The implementation here is simpler
    than the one in the Python standard library [`statistics`](https://fpy.li/8-29)
    module.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch08.html#idm46582442199104-marker)) 这里的实现比Python标准库中的[`statistics`](https://fpy.li/8-29)模块更简单��
- en: ^([14](ch08.html#idm46582441836224-marker)) I contributed this solution to `typeshed`,
    and that’s how `mode` is annotated on [*statistics.pyi*](https://fpy.li/8-32)
    as of May 26, 2020.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch08.html#idm46582441836224-marker)) 我向`typeshed`贡献了这个解决方案，这就是为什么`mode`在[*statistics.pyi*](https://fpy.li/8-32)中的注释截至2020年5月26日。
- en: ^([15](ch08.html#idm46582441439040-marker)) How wonderful it is to open an interactive
    console and rely on duck typing to explore language features like I just did.
    I badly miss this kind of exploration when I use languages that don’t support
    it.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch08.html#idm46582441439040-marker)) 多么美妙啊，打开一个交互式控制台并依靠鸭子类型来探索语言特性，就像我刚才做的那样。当我使用不支持它的语言时，我非常想念这种探索方式。
- en: ^([16](ch08.html#idm46582440867904-marker)) Without this type hint, Mypy would
    infer the type of `series` as `Generator[Tuple[builtins.int, builtins.str*], None,
    None]`, which is verbose but *consistent-with* `Iterator[tuple[int, str]]`, as
    we’ll see in [“Generic Iterable Types”](ch17.html#generic_iterable_types_sec).
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch08.html#idm46582440867904-marker)) 没有这个类型提示，Mypy会将`series`的类型推断为`Generator[Tuple[builtins.int,
    builtins.str*], None, None]`，这是冗长的但与`Iterator[tuple[int, str]]`一致，正如我们将在[“通用可迭代类型”](ch17.html#generic_iterable_types_sec)中看到的。
- en: ^([17](ch08.html#idm46582440752416-marker)) I don’t know who invented the term
    *static duck typing*, but it became more popular with the Go language, which has
    interface semantics that are more like Python’s protocols than the nominal interfaces
    of Java.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch08.html#idm46582440752416-marker)) 我不知道谁发明了术语*静态鸭子类型*，但它在Go语言中变得更加流行，该语言的接口语义更像Python的协议，而不是Java的名义接口。
- en: ^([18](ch08.html#idm46582440727296-marker)) REPL stands for Read-Eval-Print-Loop,
    the basic behavior of interactive interpreters.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch08.html#idm46582440727296-marker)) REPL代表Read-Eval-Print-Loop，交互式解释器的基本行为。
- en: ^([19](ch08.html#idm46582440036816-marker)) “Benevolent Dictator For Life.”
    See Guido van van Rossum on the [“Origin of BDFL”](https://fpy.li/bdfl).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch08.html#idm46582440036816-marker)) “终身仁慈独裁者”。参见Guido van Rossum关于[“BDFL起源”](https://fpy.li/bdfl)。
- en: ^([20](ch08.html#idm46582440034576-marker)) From the YouTube video, [“Type Hints
    by Guido van Rossum (March 2015)”](https://fpy.li/8-39). Quote starts at [13’40”](https://fpy.li/8-40).
    I did some light editing for clarity.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch08.html#idm46582440034576-marker)) 来自YouTube视频，[“Guido van Rossum关于类型提示（2015年3月）”](https://fpy.li/8-39)。引用开始于[13’40”](https://fpy.li/8-40)。我进行了一些轻微的编辑以提高清晰度。
- en: '^([21](ch08.html#idm46582439972464-marker)) Source: [“A Conversation with Alan
    Kay”](https://fpy.li/8-54).'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: ^([21](ch08.html#idm46582439972464-marker)) 来源：[“与艾伦·凯的对话”](https://fpy.li/8-54)。
