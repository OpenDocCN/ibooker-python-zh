- en: Chapter 3\. Python Packages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章\. Python 包
- en: In this chapter you’ll learn how to package your Python projects for distribution.
    A *package* is a single file containing an archive of your code along with metadata
    that describes it, like the project name and version.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何为分发打包你的 Python 项目。*包* 是一个单一文件，包含了你的代码的归档及描述它的元数据，比如项目名称和版本。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Python folks use the word *package* for two distinct concepts. *Import packages*
    are modules that contain other modules. *Distribution packages* are archive files
    for distributing Python software—​they’re the subject of this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 社区使用 *包* 这个词来表示两个不同的概念。*导入包* 是包含其他模块的模块。*分发包* 则是用于分发 Python 软件的归档文件，它们是本章的主题。
- en: You can install a package into a Python environment using a package installer
    like pip. You can also upload it to a package repository for the benefit of others.
    The Python Software Foundation (PSF) operates a package repository known as the
    [Python Package Index](https://pypi.org/) (PyPI). If your package is on PyPI,
    anyone can install it by passing its project name to `pip install`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用像 pip 这样的包安装程序将一个包安装到 Python 环境中。你也可以将它上传到一个包仓库，以使他人受益。Python 软件基金会（PSF）运营着一个称为
    [Python Package Index](https://pypi.org/)（PyPI）的包仓库。如果你的包在 PyPI 上，任何人都可以通过将其项目名称传递给
    `pip install` 来安装它。
- en: 'Packaging your project makes it easy to share with others, but there’s another
    benefit. When you install your package, it becomes a first-class citizen of a
    Python environment:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 打包你的项目使其易于与他人共享，但还有另一个好处。当你安装你的包时，它成为 Python 环境中的一等公民：
- en: The interpreter imports your modules from the environment—​rather than an arbitrary
    directory on your filesystem, which may or may not work depending on how you invoke
    Python.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器从环境中导入你的模块，而不是从文件系统中的任意目录导入，这样可能会根据你如何调用 Python 而有所不同，也可能会无法正常工作。
- en: Installers use the package metadata to ensure the environment matches the prerequisites
    of your package, such as the minimum Python version and any third-party packages
    it depends on.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装程序使用包元数据来确保环境符合包的先决条件，例如最低的 Python 版本以及它依赖的任何第三方包。
- en: Installers can generate entry-point scripts that ensure your code always runs
    on the interpreter in the environment. Compare this to hand-written Python scripts,
    which may run on the wrong Python version, or without the required third-party
    packages, or be unable to import their own modules.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装程序可以生成入口点脚本，以确保你的代码始终在环境中的解释器上运行。与手写的 Python 脚本相比，后者可能在错误的 Python 版本上运行，或者没有所需的第三方包，或者无法导入自己的模块。
- en: 'In this chapter, I’ll explain how you can package your Python projects and
    introduce you to tools that help with packaging tasks. The chapter has three parts:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将解释如何打包你的 Python 项目，并介绍一些帮助进行打包任务的工具。本章分为三部分：
- en: 'In the first part, I’ll talk about the life of a Python package. I’ll also
    introduce an example application that you’ll use throughout this book. And I’ll
    ask: why would you want to package your code at all?'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一部分中，我将讨论 Python 包的生命周期。我还将介绍一个示例应用程序，你将在本书中使用它。我会问：为什么你要打包你的代码？
- en: 'In the second part, I’ll introduce Python’s package configuration file, *pyproject.toml*,
    and tools for working with packages: `build`, `hatchling`, and Twine. The tools
    pip, uv, and pipx also make a reappearance. Finally, I’ll introduce Rye, a project
    manager that ties these packaging tools together into a unified workflow. Along
    the way, you’ll learn about build frontends and backends, wheels and sdists, editable
    installs, and the *src* layout.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二部分中，我将介绍 Python 的包配置文件 *pyproject.toml*，以及用于处理包的工具：`build`、`hatchling` 和
    Twine。工具 pip、uv 和 pipx 也会再次出现。最后，我将介绍 Rye，一个将这些打包工具整合到统一工作流程中的项目管理器。在此过程中，你将了解构建前端和后端、wheels
    和 sdists、可编辑安装和 *src* 布局。
- en: In the third part, I’ll look at project metadata in detail—​the various fields
    you can specify in *pyproject.toml* to define and describe your package, and how
    to make efficient use of them.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三部分中，我将详细讨论项目元数据——在 *pyproject.toml* 中定义和描述你的包的各种字段，以及如何高效利用它们。
- en: The Package Lifecycle
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包的生命周期
- en: '[Figure 3-1](#figure_packages_lifecycle) shows the typical lifecycle of a package.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](#figure_packages_lifecycle) 展示了一个包的典型生命周期。'
- en: '![The diagram shows how the author builds a project into a package and uploads
    it to a package index, while the user downloads and installs the package into
    an environment.](assets/hmpt_0301.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![本图示作者如何将项目构建成包并上传到包索引，用户随后将其下载并安装到环境中。](assets/hmpt_0301.png)'
- en: 'Figure 3-1\. The package lifecycle: an author builds a project into a package
    and uploads it to a package index, and then a user downloads and installs the
    package into an environment.'
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. 包的生命周期：作者将项目构建成包并将其上传到包索引，然后用户将包下载并安装到环境中。
- en: '[![1](assets/1.png)](#figure_packages_lifecycle)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#figure_packages_lifecycle)'
- en: 'Everything starts with a *project*: the source code of an application, library,
    or other piece of software.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都始于一个*项目*：应用程序、库或其他软件的源代码。
- en: '[![2](assets/2.png)](#figure_packages_lifecycle)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#figure_packages_lifecycle)'
- en: As an author, your first step is to build a package from the project. The package
    is an installable artifact with a snapshot of your project at this point in time,
    identified by a unique name and version.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为作者，您的第一步是从项目构建一个包。该包是一个可安装的工件，包含项目此时点的快照，由唯一的名称和版本标识。
- en: '[![3](assets/3.png)](#figure_packages_lifecycle)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#figure_packages_lifecycle)'
- en: Next, you publish the package to a well-known repository such as PyPI.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将包发布到知名的存储库，如 PyPI。
- en: '[![4](assets/4.png)](#figure_packages_lifecycle)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#figure_packages_lifecycle)'
- en: A user can now fetch your package by specifying its name and version.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以通过指定其名称和版本获取您的包。
- en: '[![5](assets/5.png)](#figure_packages_lifecycle)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#figure_packages_lifecycle)'
- en: Finally, the user installs your package into their environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用户将您的包安装到他们的环境中。
- en: You can install a freshly built package directly into an environment, without
    uploading it to a package repository first—​for example, when you’re testing your
    package, or when you’re its only user.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接将刚构建的包安装到环境中，而无需先将其上传到包存储库—例如，当您在测试包或您是其唯一用户时。
- en: In real life, tools often combine fetching and installing, building and installing,
    and even building and publishing, into a single command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，工具通常将获取和安装、构建和安装，甚至构建和发布组合为单个命令。
- en: An Example Application
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例应用程序
- en: Many applications start out as small, ad-hoc scripts. [Example 3-1](#example_packages_wikipedia)
    fetches a random article from Wikipedia and displays its title and summary in
    the console. The script restricts itself to the standard library, so it runs in
    any Python 3 environment.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序最初是小型的临时脚本。[示例 3-1](#example_packages_wikipedia) 从维基百科获取随机文章，并在控制台中显示其标题和摘要。该脚本限制于标准库，因此可在任何
    Python 3 环境中运行。
- en: Example 3-1\. Displaying an extract from a random Wikipedia article
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-1\. 显示从随机维基百科文章中提取的内容
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_python_packages_CO1-1)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_python_packages_CO1-1)'
- en: The `API_URL` constant points to the REST API of the English Wikipedia—​or more
    specifically, its `/page/random/summary` endpoint.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`API_URL`常量指向英文维基百科的 REST API，更具体地说是其 `/page/random/summary` 端点。'
- en: '[![2](assets/2.png)](#co_python_packages_CO1-2)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_python_packages_CO1-2)'
- en: The `urllib.request.urlopen` invocation sends an HTTP GET request to the Wikipedia
    API. The `with` statement ensures that the connection is closed at the end of
    the block.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`urllib.request.urlopen`调用发送 HTTP GET 请求到维基百科 API。`with`语句确保连接在块结束时关闭。'
- en: '[![3](assets/3.png)](#co_python_packages_CO1-3)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_python_packages_CO1-3)'
- en: The response body contains the resource data in JSON format. Conveniently, the
    response is a file-like object, so the `json` module can load it like a file from
    disk.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 响应体以 JSON 格式包含资源数据。方便地，响应是一个类似文件的对象，所以`json`模块可以像从磁盘加载文件一样加载它。
- en: '[![4](assets/4.png)](#co_python_packages_CO1-4)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_python_packages_CO1-4)'
- en: The `title` and `extract` keys hold the title of the Wikipedia page and a short
    plain text extract, respectively. The `textwrap.fill` function wraps the text
    so that every line is at most 70 characters long.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`title`和`extract`键分别包含维基百科页面的标题和简短的纯文本摘录。`textwrap.fill`函数用于将文本包装，使每行最多 70
    个字符长。'
- en: 'Store this script in a file called *random_wikipedia_article.py* and take it
    for a spin. Here’s a sample run:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本存储在名为*random_wikipedia_article.py*的文件中并运行它。以下是一个示例运行：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Why Packaging?
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要打包？
- en: Sharing a script like [Example 3-1](#example_packages_wikipedia) doesn’t require
    packaging. You can publish it on a blog or a hosted repository, or send it to
    friends by email or chat. Python’s ubiquity, the “batteries included” approach
    of its standard library, and its nature as an interpreted language make this possible.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 分享像 [示例 3-1](#example_packages_wikipedia) 这样的脚本不需要打包。你可以在博客或托管的仓库上发布它，或通过电子邮件或聊天发送给朋友。Python
    的普及性，其标准库的“电池包含”方法，以及作为解释语言的特性使这一切成为可能。
- en: The ease of sharing modules with the world was a boon to Python’s adoption in
    the early days. The Python programming language predates the advent of language-specific
    package repositories—​PyPI didn’t come about for more than a decade.^([1](ch03.html#id263))
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与世界共享模块的便利性曾是 Python 在早期被广泛采用的一个优势。Python 编程语言早于语言特定的包仓库的出现——PyPI 在十多年后才出现。^([1](ch03.html#id263))
- en: 'Distributing self-contained modules without packaging them seems like a great
    idea at first: You keep your projects free of packaging cruft. They require no
    separate artifacts, no intermediate steps like building, and no dedicated tooling.
    But using modules as the unit of distribution comes with limitations:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 分发未打包的自包含模块似乎一开始是个好主意：你可以保持项目没有打包的杂物。它们不需要单独的工件，也不需要像构建那样的中间步骤或专用工具。但使用模块作为分发单元也有限制：
- en: Projects composed of multiple modules
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由多个模块组成的项目
- en: When your project outgrows a single-file script, you should break it up—​but
    installing a collection of files is cumbersome for your users. Packaging lets
    you keep everything in a single file for distribution.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的项目超出单个文件脚本时，你应该将其拆分开来，但是为用户安装一堆文件很麻烦。打包能让你将所有东西都保持在一个单一文件中进行分发。
- en: Projects with third-party dependencies
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 具有第三方依赖项的项目
- en: Python has a rich ecosystem of third-party packages, so you’re standing on the
    shoulders of giants. But your users shouldn’t need to worry about installing the
    correct version of every package you require. Packaging lets you declare dependencies
    on other packages, which installers satisfy automatically.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Python 拥有丰富的第三方包生态系统，因此你站在巨人的肩膀上。但你的用户不应该担心安装每个所需包的正确版本。打包能让你声明对其他包的依赖关系，安装程序会自动满足这些依赖。
- en: Finding the project
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 查找项目
- en: What’s the repository URL of that useful module again? Or was it on a blog?
    If you publish a package on PyPI, your users only need to know its name to install
    the latest version. The situation is similar in a corporate environment, where
    developers’ machines are configured to use a company-wide package repository.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那个有用模块的仓库网址是什么？还是说在某个博客上？如果你在 PyPI 上发布一个包，你的用户只需知道其名称即可安装最新版本。在企业环境中情况类似，开发者的机器配置为使用公司范围的包仓库。
- en: Installing the project
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 安装项目
- en: Downloading and double-clicking a script won’t work much of the time. You shouldn’t
    need to place modules in arcane directories and perform a special dance so your
    script executes on the correct interpreter. Packaging lets users install your
    project with a single command, in a portable and safe way.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，下载并双击脚本是行不通的。你不应该需要将模块放在神秘的目录中，并执行特殊操作来确保你的脚本在正确的解释器上执行。打包让用户可以用单一命令在可移植和安全的方式下安装你的项目。
- en: Updating the project
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 更新项目
- en: Users need to determine if the project is up-to-date and upgrade it to the latest
    version if it isn’t. As an author, you need a way to let your users benefit from
    new features, bug fixes, and improvements. Package repositories let you publish
    a stream of releases for your project (a subset of the development snapshots you’d
    get from its code repository.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 用户需要确定项目是否为最新版本，并在需要时升级到最新版本。作为作者，你需要一种方法让用户从新功能、错误修复和改进中受益。包仓库让你发布项目的一系列版本（开发快照的一个子集）。
- en: Running the project in the correct environment
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确环境中运行项目
- en: Don’t leave it up to chance if your program runs on a supported Python version,
    with the required third-party packages. Package installers check and, where possible,
    satisfy your prerequisites. They also ensure that your code runs in the environment
    intended for it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让程序在支持的 Python 版本上运行成为偶然，也不要忽视所需的第三方包。包安装程序会检查和在可能的情况下满足你的先决条件。它们还确保你的代码在预期的环境中运行。
- en: Binary extensions
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制扩展
- en: Python modules written in a compiled language like C or Rust require a build
    step. Packaging lets you distribute pre-built binaries for common platforms. Additionally,
    it lets you publish a source archive as a fallback; installers run the build step
    on the end user’s machine.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 用 C 或 Rust 等编译语言编写的 Python 模块需要构建步骤。打包允许您分发常见平台的预构建二进制文件。此外，它允许您发布源代码存档作为备用；安装程序在最终用户的计算机上运行构建步骤。
- en: Metadata
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据
- en: You can embed metadata inside a module, using attributes like `__author__`,
    `__version__`, or `__license__`. But then tools have to execute the module to
    read those attributes. Packages contain static metadata that any tool can read
    without running Python.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在模块内嵌入元数据，使用诸如 `__author__`、`__version__` 或 `__license__` 等属性。但是工具必须执行模块才能读取这些属性。包含静态元数据的包可以在不运行
    Python 的情况下供任何工具读取。
- en: As you’ve seen, packaging solves many problems, but what’s the overhead? In
    short, you drop a declarative file named *pyproject.toml* into your project—​a
    standard file that specifies the project metadata and its build system. In return,
    you get commands to build, publish, and install your package.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，打包解决了许多问题，但有什么开销呢？简而言之，您只需将名为 *pyproject.toml* 的声明文件放入项目中—​这是一个指定项目元数据及其构建系统的标准文件。作为回报，您获得了用于构建、发布和安装包的命令。
- en: 'In summary, Python packages come with many advantages:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Python 包带来了许多优势：
- en: You can easily install and upgrade them
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以轻松安装和升级它们
- en: You can publish them in a package repository
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将它们发布到包存储库中
- en: They can depend on other packages
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以依赖于其他包
- en: They run in an environment that satisfies their requirements
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在满足其要求的环境中运行
- en: They can contain multiple modules
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以包含多个模块
- en: They can contain pre-built binary extensions
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以包含预构建的二进制扩展
- en: They can contain source distributions with automated build steps
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以包含带有自动构建步骤的源分发
- en: They come with metadata that describes the package
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们附带描述包的元数据
- en: The pyproject.toml File
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pyproject.toml 文件
- en: '[Example 3-2](#example_packages_pyproject_toml_small) shows how to package
    the script from [Example 3-1](#example_packages_wikipedia) with a bare minimum
    of metadata—​the project name and version—​as well as an entry-point script. The
    project and the script use hyphens (`random-wikipedia-article`), while the module
    uses underscores (`random_wikipedia_article`). Place the module and the *pyproject.toml*
    file side-by-side in an empty directory.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-2](#example_packages_pyproject_toml_small) 展示了如何使用最少的元数据—​项目名称和版本—​以及一个入口脚本来打包
    [示例 3-1](#example_packages_wikipedia) 中的脚本。项目和脚本使用连字符 (`random-wikipedia-article`)，而模块使用下划线
    (`random_wikipedia_article`)。将模块和 *pyproject.toml* 文件并排放在空目录中。'
- en: Example 3-2\. A minimal pyproject.toml file
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2\. 一个最小的 pyproject.toml 文件
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: PyPI projects share a single namespace—​their names aren’t scoped by the users
    or organizations owning the projects. Choose a unique name such as `random-wikipedia-article-{your-name}`,
    and rename the Python module accordingly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: PyPI 项目共享单一命名空间—​它们的名称不由用户或拥有项目的组织所限定。选择一个唯一的名称，比如 `random-wikipedia-article-{your-name}`，并相应地重命名
    Python 模块。
- en: 'At the top level, the *pyproject.toml* file can contain up to three sections—​or
    *tables*, as the TOML standard calls them:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶层，*pyproject.toml* 文件可以包含最多三个部分—​或者 *表*，正如 TOML 标准所称：
- en: '`[project]`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`[project]`'
- en: The `project` table holds the project metadata. The `name` and `version` fields
    are mandatory. For real projects, you should provide additional information, such
    as a description, the license, and the required Python version (see [“Project
    Metadata”](#section_packages_project_metadata)). The `scripts` section declares
    the name of the entry-point script and the function it should call.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`project` 表包含项目元数据。`name` 和 `version` 字段是必需的。对于真实项目，您应该提供额外的信息，比如描述、许可证和所需的
    Python 版本（参见 [“项目元数据”](#section_packages_project_metadata)）。`scripts` 部分声明入口脚本的名称以及它应该调用的函数。'
- en: '`[build-system]`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`[build-system]`'
- en: The `build-system` table specifies how to build packages for the project (see
    [“Building Packages with build”](#section_packages_build))—specifically, which
    build tool your project uses. I’ve opted for `hatchling` here, which comes with
    [Hatch](https://hatch.pypa.io/), a modern and standards-compliant Python project
    manager.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`build-system` 表指定了如何为项目构建包（参见 [“使用 build 构建包”](#section_packages_build)）—特别是您的项目使用的构建工具。我在这里选择了
    `hatchling`，它随 [Hatch](https://hatch.pypa.io/) 一起提供，这是一个现代且符合标准的 Python 项目管理器。'
- en: '`[tool]`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`[tool]`'
- en: The `tool` table stores configurations for each tool used by the project. For
    example, the Ruff linter reads its configuration from the `[tool.ruff]` table,
    while the type checker mypy uses `[tool.mypy]`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`tool`表存储了项目使用的每个工具的配置。例如，Ruff代码检查器从`[tool.ruff]`表中读取其配置，而类型检查器mypy使用`[tool.mypy]`。'
- en: Building Packages with build
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用build构建包
- en: Let’s create a package for your new project using `build`, a dedicated build
    frontend maintained by the Python Packaging Authority (PyPA). The PyPA is a group
    of volunteers that maintains a core set of software projects used in Python packaging.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`build`为你的新项目创建一个包，这是一个由Python包管理局（PyPA）维护的专用构建前端。PyPA是一组志愿者，负责维护Python打包中使用的一组核心软件项目。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: A *build frontend* is an application that orchestrates the build process for
    a Python package. Build frontends don’t know how to assemble packaging artifacts
    from source trees. The tool that does the actual building is known as the *build
    backend*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*构建前端*是一个为Python包编排构建过程的应用程序。构建前端不知道如何从源代码树中组装打包工件。实际构建的工具称为*构建后端*。'
- en: 'Open a terminal, change to the project directory, and invoke `build` with pipx:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端，切换到项目目录，并使用pipx调用`build`：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By default, `build` creates two kinds of packages for a project, an sdist and
    a wheel (see [“Wheels and Sdists”](#section_packages_wheels_and_sdists)). You
    can find these files in the *dist* directory of your project.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`build`为项目创建两种类型的包，即源分发包（sdist）和轮子（wheel）（参见[“轮子和源分发包”](#section_packages_wheels_and_sdists)）。你可以在项目的*dist*目录中找到这些文件。
- en: As you can see in the output above, `build` delegates the actual work to `hatchling`,
    the build backend you designated in [Example 3-2](#example_packages_pyproject_toml_small).
    A build frontend uses the `build-system` table to determine the build backend
    for the project ([Table 3-1](#table_packages_build_system)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如上输出所示，`build`将实际工作委派给了`hatchling`，你在[示例 3-2](#example_packages_pyproject_toml_small)中指定的构建后端。构建前端使用`build-system`表来确定项目的构建后端（见[表 3-1](#table_packages_build_system)）。
- en: Table 3-1\. The `build-system` table
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. `build-system`表
- en: '| Field | Type | Description |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `requires` | array of strings | The list of packages required to build the
    project |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `requires` | 字符串数组 | 构建项目所需的包的列表 |'
- en: '| `build-backend` | string | The import name of the build backend in the format
    `package.module:object` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `build-backend` | 字符串 | 构建后端的导入名称，格式为`package.module:object` |'
- en: '| `build-path` | string | An entry for `sys.path` needed to import the build
    backend (optional) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `build-path` | 字符串 | 用于导入构建后端所需的`sys.path`条目（可选） |'
- en: '[Figure 3-2](#figure_packages_build) shows how the build frontend and the build
    backend collaborate to build a package.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-2](#figure_packages_build)展示了构建前端和构建后端如何协作构建一个包。'
- en: '![The diagram shows how the build frontend orchestrates a package build, by
    creating a build environment as well as installing and running the build backend.](assets/hmpt_0302.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图示了构建前端如何编排包构建，通过创建构建环境以及安装和运行构建后端。](assets/hmpt_0302.png)'
- en: Figure 3-2\. Build frontend and build backend
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. 构建前端和构建后端
- en: '[![1](assets/1.png)](#figure_packages_build)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#figure_packages_build)'
- en: The build frontend creates a virtual environment, the *build environment*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 构建前端创建了一个虚拟环境，*构建环境*。
- en: '[![2](assets/2.png)](#figure_packages_build)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#figure_packages_build)'
- en: 'The build frontend installs the packages listed under `requires`: the build
    backend itself as well as, optionally, plugins for that backend. These packages
    are known as the *build dependencies*.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 构建前端安装了列在`requires`下的包：构建后端本身以及可选的后端插件。这些包称为*构建依赖项*。
- en: '[![3](assets/3.png)](#figure_packages_build)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#figure_packages_build)'
- en: The build frontend triggers the actual package build, in two steps. First, it
    imports the module or object declared in `build-backend`. Second, it invokes well-known
    functions for creating packages and related tasks, known as *build hooks*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构建前端通过两个步骤触发实际的包构建。首先，它导入了在`build-backend`中声明的模块或对象。其次，它调用了用于创建包和相关任务的众所周知的函数，称为*构建钩子*。
- en: Here’s a simplified version of the commands the build frontend performs when
    you build a wheel for your project:^([2](ch03.html#id264))
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是构建前端在为项目构建轮子时执行的命令的简化版本：^([2](ch03.html#id264))
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Some build frontends let you build in your current environment. If you disable
    build isolation, the frontend only checks for build dependencies. If it installed
    them, the build and runtime dependencies of different packages might conflict.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一些构建前端允许你在当前环境中构建。如果禁用构建隔离，前端仅检查构建依赖项。如果已安装它们，则不同包的构建和运行时依赖项可能会冲突。
- en: Why separate the build frontend from the build backend? It means that tools
    can trigger package builds without knowing the intricacies of the build process.
    For example, package installers like pip and uv build packages on the fly when
    you install from a source directory (see [“Installing Projects from Source”](#section_packages_installing_from_source)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么将构建前端与构建后端分开？这意味着工具可以触发包构建，而无需了解构建过程的复杂性。例如，包安装器如 pip 和 uv 可以在从源代码目录安装时即时构建包（参见
    [“从源码安装项目”](#section_packages_installing_from_source)）。
- en: Standardizing the contract between build frontends and build backends has brought
    tremendous diversity and innovation to the packaging ecosystem. Build frontends
    include `build`, pip, and uv, the backend-agnostic Python project managers Rye,
    Hatch, and [PDM](https://pdm-project.org/latest/), and test automation tools like
    [tox](https://tox.wiki/en/4.14.2/). Build backends include those shipped with
    the project managers [Flit](https://flit.pypa.io/), Hatch, PDM, and [Poetry](https://python-poetry.org/),
    the traditional build backend [setuptools](https://setuptools.pypa.io/), as well
    as exotic builders like [Maturin](https://www.maturin.rs/), a build backend for
    Python modules written in the Rust programming language, and [Sphinx Theme Builder](https://sphinx-theme-builder.readthedocs.io/),
    a build backend for Sphinx documentation themes ([Table 3-2](#table_packages_build_backends)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建前端和构建后端之间标准化合同，极大地增加了包装生态系统的多样性和创新。构建前端包括 `build`、pip 和 uv，不考虑后端的 Python
    项目管理器 Rye、Hatch 以及 [PDM](https://pdm-project.org/latest/)，以及诸如 [tox](https://tox.wiki/en/4.14.2/)
    等测试自动化工具。构建后端包括随项目管理器一起提供的 Flit、Hatch、PDM 和 [Poetry](https://python-poetry.org/)，传统的构建后端
    [setuptools](https://setuptools.pypa.io/)，以及像 [Maturin](https://www.maturin.rs/)
    这样的用 Rust 编写的 Python 模块构建后端，以及 [Sphinx Theme Builder](https://sphinx-theme-builder.readthedocs.io/)，用于
    Sphinx 文档主题的构建后端（见 [Table 3-2](#table_packages_build_backends)）。
- en: Table 3-2\. Build backends
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-2\. 构建后端
- en: '| Project | `requires`^([a](ch03.html#id265)) | `build-backend` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 项目 | `requires`^([a](ch03.html#id265)) | `build-backend` |'
- en: '| --- | --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Flit | `flit-core` | `flit_core.buildapi` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| Flit | `flit-core` | `flit_core.buildapi` |'
- en: '| Hatch | `hatchling` | `hatchling.build` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 孵化 | `hatchling` | `hatchling.build` |'
- en: '| Maturin | `maturin` | `maturin` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| Maturin | `maturin` | `maturin` |'
- en: '| PDM | `pdm-backend` | `pdm.backend` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| PDM | `pdm-backend` | `pdm.backend` |'
- en: '| Poetry | `poetry-core` | `poetry.core.masonry.api` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| Poetry | `poetry-core` | `poetry.core.masonry.api` |'
- en: '| Setuptools | `setuptools` | `setuptools.build_meta` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| Setuptools | `setuptools` | `setuptools.build_meta` |'
- en: '| Sphinx Theme Builder | `sphinx-theme-builder` | `sphinx_theme_builder` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| Sphinx Theme Builder | `sphinx-theme-builder` | `sphinx_theme_builder` |'
- en: '| ^([a](ch03.html#id265-marker)) See the official documentation of each tool
    for any recommended version bounds |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch03.html#id265-marker)) 请参阅每个工具的官方文档，了解推荐的版本范围 |'
- en: Uploading Packages with Twine
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Twine 上传包
- en: It’s time to publish your package. In this section, you’ll use [TestPyPI](https://test.pypi.org),
    a separate instance of the Python Package Index intended for testing and experimentation.
    Just omit the `--repository` and `--index-url` options below to use the real PyPI.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候发布你的包了。在这一节中，你将使用[TestPyPI](https://test.pypi.org)，这是 Python 包索引的一个单独实例，用于测试和实验。只需省略下面的`--repository`和`--index-url`选项，即可使用真实的
    PyPI。
- en: First, register an account using the link on the front page of TestPyPI. Second,
    create an API token from your account page and copy the token to your preferred
    password manager. You can now upload the packages in *dist* using Twine, the official
    PyPI upload tool.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 TestPyPI 的首页使用链接注册一个账户。其次，从你的账户页面创建一个 API 令牌，并将令牌复制到你首选的密码管理器中。现在，你可以使用
    Twine（官方的 PyPI 上传工具）上传 *dist* 中的包。
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Congratulations, you have published your first Python package! Let’s install
    the package from TestPyPI:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，你已经发布了你的第一个 Python 包！让我们从 TestPyPI 安装这个包：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You’re now able to invoke your application from anywhere:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在任何地方调用你的应用程序：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Installing Projects from Source
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从源码安装项目
- en: If you distribute packages for your project, it’s a good idea to install these
    packages locally for development and testing. Running tests against an installed
    package rather than the source code means you’re testing your project the way
    your users see it. And if you’re working on a service, it helps keep development,
    staging, and production as similar as possible.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为项目分发软件包，将这些软件包在本地安装以进行开发和测试是一个好主意。对已安装的软件包运行测试，而不是源代码，意味着您正在测试您的项目，就像您的用户看到的那样。如果您正在开发服务，这将有助于使开发、暂存和生产尽可能相似。
- en: 'You *could* build a wheel with `build` and install it into a virtual environment:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您*可以*使用 `build` 构建一个轮子，并将其安装到虚拟环境中：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There’s a shortcut for this, though. Both pip and uv can install your project
    directly from a source directory, such as `.` for the current directory. Behind
    the scenes, they use the project’s build backend to create a wheel for installation—​they’re
    build frontends just like `build`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，还有一种快捷方式。pip 和 uv 都可以直接从源目录（例如 `.` 代表当前目录）安装您的项目。在幕后，它们使用项目的构建后端创建一个轮子进行安装——它们就像
    `build` 一样是构建前端：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If your project comes with an entry-point script, you can also install it with
    pipx:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目带有入口点脚本，您也可以使用 pipx 安装它：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Editable Installs
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可编辑安装
- en: During development, it saves time to see code changes reflected in the environment
    immediately, without repeatedly installing the project. You could import your
    modules directly from the source tree—​but you’d lose all the benefits of packaging
    your project.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，立即在环境中看到代码更改反映出来，而无需反复安装项目，这样可以节省时间。您可以直接从源树导入模块，但这样做会丧失打包项目的所有好处。
- en: '*Editable installs* achieve the best of both worlds by installing your package
    in a special way that redirects imports to the source tree (see [“Site Packages”](ch02.html#section_environments_site_packages)).
    You can think of this mechanism as a kind of “hot reloading” for Python packages.
    The `--editable` option (`-e`) works with uv, pip, and pipx:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*可编辑安装*实现了最佳效果，通过以特殊方式安装您的软件包，将导入重定向到源树（参见[“站点包”](ch02.html#section_environments_site_packages)）。您可以将这种机制视为
    Python 软件包的一种“热重载”。`--editable`选项（`-e`）与 uv、pip 和 pipx 一起工作：'
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once you’ve installed your package in this way, you won’t need to reinstall
    it to see changes to the source code—​only when you edit *pyproject.toml* to change
    the project metadata or add a third-party dependency.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您以这种方式安装了软件包，您就不需要重新安装它以查看源代码的更改——只有在编辑 *pyproject.toml* 以更改项目元数据或添加第三方依赖项时才需要重新安装。
- en: Editable installs are modeled after the *development mode* feature from setuptools,
    if you’ve been around long enough to be familiar with it. But unlike `setup.py
    develop`, they rely on standard build hooks that any build backend can provide.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可编辑安装是模仿 setuptools 中的*开发模式*功能建立的，如果您已经足够长时间了解它。但与 `setup.py develop` 不同，它们依赖于任何构建后端都可以提供的标准构建钩子。
- en: Project Layout
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目布局
- en: 'Dropping a *pyproject.toml* next to a single-file module is an appealingly
    simple approach. Unfortunately, this project layout comes with a serious footgun,
    as you’ll see in this section. Let’s start by breaking something in the project:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *pyproject.toml* 放在单个文件模块旁边是一种非常简单的方法。不幸的是，这种项目布局带来了一个严重的问题，正如您将在本节中看到的那样。让我们从项目中破坏一些东西开始：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Before publishing your package, run a last smoke test with a locally built
    wheel:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布软件包之前，使用本地构建的轮子进行最后的冒烟测试：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A bug found is a bug fixed. After removing the offending line, verify that
    the program works as expected:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 找到的错误是修复的错误。删除有问题的行之后，验证程序是否按预期工作：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All good, time to cut a release! First, push your fix and a Git tag for the
    new version to your code repository. Next, use Twine to upload the wheel to PyPI:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很好，是时候发布一个版本了！首先，将您的修复和新版本的 Git 标签推送到您的代码存储库。接下来，使用 Twine 将轮子上传到 PyPI：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: But, oh no—​you never rebuilt the wheel. That bug is now in a public release!
    How could that happen?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，天哪——您从未重建过轮子。这个错误现在已经在一个公共版本中！怎么可能发生这种情况？
- en: Running your application with `py -m` protects you from inadvertently running
    an entry-point script from another installation (and it has the advantage of not
    requiring an active environment on macOS and Linux). But it also adds the current
    directory to the front of `sys.path` (see [“Site Packages”](ch02.html#section_environments_site_packages)).
    All along, you’ve been testing the module in your source tree, not the wheel you
    were going to publish!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `py -m` 运行您的应用程序可以防止意外地从另一个安装运行入口点脚本（并且它有不需要在 macOS 和 Linux 上有活动环境的优点）。但它也会将当前目录添加到
    `sys.path` 的前面（参见 [“Site Packages”](ch02.html#section_environments_site_packages)）。一直以来，您一直在源树中测试模块，而不是您打算发布的
    wheel！
- en: You could set the `PYTHONSAFEPATH` environment variable and never think about
    this again—​it’s an alias for `py -P` and omits the current directory from the
    module path. But that would leave your contributors out in the cold—​and yourself,
    whenever you’re working on another machine.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以设置 `PYTHONSAFEPATH` 环境变量，并且永远不再考虑此事——这是 `py -P` 的别名，并省略模块路径中的当前目录。但这将使您的贡献者不被冷落——以及当您在另一台机器上工作时。
- en: Instead, move your module out of the top-level directory so folks can’t import
    it by mistake. By convention, Python source trees go into the *src* directory—​which
    is why the arrangement is known as *src layout* in the Python community.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 取而代之的是，将您的模块移出顶级目录，以免人们误导入它。按照惯例，Python 源树放入 *src* 目录中——这就是为什么在 Python 社区中这种安排被称为
    *src 布局*。
- en: At this point, it also makes sense to convert your single-file module into an
    import package. Replace the *random_wikipedia_article.py* file by a *random_wikipedia_article*
    directory with a *__init__.py* module.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，将单文件模块转换为导入包也是有意义的。通过将 *random_wikipedia_article.py* 文件替换为一个 *random_wikipedia_article*
    目录，其中包含一个 *__init__.py* 模块。
- en: 'Placing your code in an import package is mostly equivalent to having it in
    a single-file module—​but there’s one difference: you can’t run the application
    with `py -m random_wikipedia_article` unless you also add the special *__main__.py*
    module to the package ([Example 3-3](#example_packages_main)).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的代码放入导入包中基本上等同于将其放入单文件模块中——但有一个区别：您不能使用 `py -m random_wikipedia_article` 运行应用程序，除非您还将特殊的
    *__main__.py* 模块添加到包中（参见 [Example 3-3](#example_packages_main)）。
- en: Example 3-3\. The *__main__.py* module
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3\. *__main__.py* 模块
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The *__main__.py* module replaces the `if __name__ == "__main__"` block in *__init__.py*.
    Remove that block from the module.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*__main__.py* 模块替代了 *__init__.py* 中的 `if __name__ == "__main__"` 块。从模块中删除该块。'
- en: 'This leaves you with a classic initial project structure:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给您留下一个经典的初始项目结构：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'An import package makes it easier for your project to grow: you can move code
    into separate modules and import it from there. For example, you could extract
    the code that talks to the Wikipedia API into a function `fetch`. Next, you might
    move the function to a module *fetch.py* in the package. Here’s how you’d import
    the function from *__init__.py*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 导入包使得项目更容易扩展：您可以将代码移到单独的模块中并从那里导入。例如，您可以将与 Wikipedia API 交互的代码提取到一个名为 `fetch`
    的函数中。接下来，您可以将该函数移动到包中的 *fetch.py* 模块中。以下是从 *__init__.py* 导入该函数的方法：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Eventually, *__init__.py* will only contain `import` statements for your public
    API.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，*__init__.py* 将只包含您公共 API 的 `import` 语句。
- en: Managing Packages with Rye
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rye 管理包
- en: Many modern programming languages come with a single tool for building, packaging,
    and other development tasks. You may wonder how the Python community ended up
    with so many packaging tools with disjoint responsibilities.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代编程语言都配备了一个工具来构建、打包和执行其他开发任务。您可能想知道 Python 社区是如何最终拥有如此多的分离职责的打包工具的。
- en: 'The answer has to do with the nature and history of the Python project: Python
    is a decentralized open source project driven by a community of thousands of volunteers,
    with a history spanning more than three decades of organic growth. This makes
    it hard for a single packaging tool to cater to all demands and become firmly
    established.^([3](ch03.html#id266))'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 答案与 Python 项目的性质和历史有关：Python 是一个由成千上万志愿者驱动的分散式开源项目，历史跨越三十多年的有机增长。这使得单一的打包工具难以满足所有需求并牢固确立。^([3](ch03.html#id266))
- en: Python’s strength lies in its rich ecosystem—​and interoperability standards
    promote this diversity. As a Python developer, you have a choice of small single-purpose
    tools that play well together. This approach ties in with the Unix philosophy
    of “Do one thing, and do it well.”
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的优势在于其丰富的生态系统—​和互操作标准促进了这种多样性。作为 Python 开发人员，你可以选择那些良好协同的小型单一目的工具。这种方法符合“做一件事，并做好”的
    Unix 哲学。
- en: But the Unix approach is no longer your only choice. *Python project managers*
    provide a more integrated workflow. Among the first, Poetry (see [Chapter 5](ch05.html#chapter_poetry))
    has set itself the goal of reinventing Python packaging and pioneered ideas such
    as static metadata and cross-platform lock files.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Unix 的方法不再是你唯一的选择。*Python 项目管理器*提供了一个更集成的工作流程。其中首要的是 Poetry（见[第五章](ch05.html#chapter_poetry)），它设定了重新发明
    Python 打包的目标，并倡导了静态元数据和跨平台锁定文件等概念。
- en: '[Rye](https://rye-up.com/), a Python project manager written in Rust, chooses
    a different path. It provides a unified development experience on top of the widely-used
    single-purpose tools you’ve already seen (and are about to see) in this book.
    Started by Armin Ronacher as a private project and first released to the public
    in 2023, it’s now under the stewardship of Astral, the company behind Ruff and
    uv.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[Rye](https://rye-up.com/)是一个用 Rust 编写的 Python 项目管理器，选择了一条不同的道路。它在这本书中已经看到（也即将看到）的广泛使用的单一目的工具之上提供了统一的开发体验。由
    Armin Ronacher 作为私人项目开始，并于 2023 年首次向公众发布，现在由 Astral 管理，Astral 是 Ruff 和 uv 背后的公司。'
- en: Please see Rye’s official documentation for installation instructions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 Rye 的官方文档以获取安装说明。
- en: 'Your first step with Rye is initializing a new project with `rye init`. If
    you don’t pass the project name, Rye uses the name of the current directory. Use
    the `--script` option to include an entry-point script:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `rye init` 初始化新项目是你使用 Rye 的第一步。如果没有传递项目名称，Rye 将使用当前目录的名称。使用 `--script` 选项包含入口点脚本：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Rye initializes a Git repository in *random-wikipedia-article* and populates
    it with a *pyproject.toml* file, an import package `random_wikipedia_article`
    in the *src* directory, a *README.md* with the project description, a *.python-version*
    file with the default Python version, and a virtual environment in *.venv*. Rye
    supports various build backends, with `hatchling` as the default choice.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Rye 在 *random-wikipedia-article* 中初始化了一个 Git 存储库，并用一个 *pyproject.toml* 文件，一个
    *src* 目录中的导入包 `random_wikipedia_article`，一个包含项目描述的 *README.md*，一个包含默认 Python 版本的
    *.python-version* 文件，以及一个位于 *.venv* 中的虚拟环境来填充它。Rye 支持各种构建后端，其中 `hatchling` 是默认选择。
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Many of Rye’s commands are frontends to tools that have become a de-facto standard
    in the Python world, or that promise to become one in the future. The command
    `rye build` creates packages with `build`, the command `rye publish` uploads them
    using Twine, and the command `rye sync` performs an editable install using uv:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Rye 的许多命令是前端工具，这些工具已成为 Python 世界中事实上的标准，或者有望在未来成为标准。`rye build`命令使用`build`创建包，`rye
    publish`命令使用 Twine 上传包，`rye sync`命令使用 uv 执行可编辑安装：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There’s much more to `rye sync`, though. Rye manages private Python installations
    using the Python Standalone Builds project (see [“A Brave New World: Installing
    with Hatch and Rye”](ch01.html#section_python_brave)), and `rye sync` fetches
    each Python version on first use. The command also generates a lock file for the
    project dependencies and synchronizes the environment with that file (see [Chapter 4](ch04.html#chapter_dependencies)).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`rye sync`其实功能远不止于此。 Rye 使用 Python Standalone Builds 项目管理私有 Python 安装（参见[“全新世界：使用
    Hatch 和 Rye 安装”](ch01.html#section_python_brave)），`rye sync`在首次使用时获取每个 Python
    版本。该命令还为项目依赖项生成锁定文件，并将环境与该文件同步（参见[第四章](ch04.html#chapter_dependencies)）。'
- en: Wheels and Sdists
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wheels 和 Sdists
- en: 'In [“Building Packages with build”](#section_packages_build), `build` created
    two packages for your project:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“使用 build 构建包”](#section_packages_build)中，`build` 为您的项目创建了两个包：
- en: '*random_wikipedia_article-0.1.tar.gz*'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*random_wikipedia_article-0.1.tar.gz*'
- en: '*random_wikipedia_article-0.1-py2.py3-none-any.whl*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*random_wikipedia_article-0.1-py2.py3-none-any.whl*'
- en: 'These artifacts are known as *wheels* and *sdists*. Wheels are ZIP archives
    with a *.whl* extension, and they’re *built distributions*—for the most part,
    installers extract them into the environment as-is. Sdists, by contrast, are *source
    distributions*: they’re compressed archives of the source code with packaging
    metadata. Sdists require an additional build step to produce an installable wheel.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工件被称为*wheel*和*sdist*。Wheels是带有*.whl*扩展名的ZIP归档文件，它们是*构建分发*——大多数情况下，安装程序会将它们原封不动地解压到环境中。相比之下，sdist是*源分发*：它们是包含打包元数据的源代码压缩归档文件。需要额外的构建步骤来生成可安装的wheel。
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The name “wheel” for a Python package is a reference to wheels of cheese. PyPI
    was originally known as the *Cheese Shop*, after the Monty Python sketch about
    a cheese shop with no cheese whatsoever. (These days, PyPI serves over a petabyte
    of packages per day.)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Python包的名称“wheel”是对奶酪轮的引用。PyPI最初以*奶酪商店*而闻名，这是源自蒙提·派森有关没有奶酪的奶酪商店的小品。如今，PyPI每天提供超过一PB的软件包。
- en: The distinction between source distributions and built distributions may seem
    strange for an interpreted language like Python. But you can also write Python
    modules in a compiled language. In this situation, source distributions provide
    a useful fallback when no pre-built wheels are available for a platform.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像Python这样的解释语言，源分发和构建分发之间的区别可能显得有些奇怪。但是你也可以使用编译语言编写Python模块。在这种情况下，当某个平台上没有预构建的wheel可用时，源分发提供了一个有用的备选方案。
- en: 'As a package author, you should build and publish both sdists and wheels for
    your releases. This gives users a choice: They can fetch and install the wheel
    if their environment is compatible (which is always the case for a pure Python
    package)—or they can fetch the sdist and build a wheel from it locally (see [Figure 3-3](#figure_packages_wheels_and_sdists)).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 作为包的作者，您应该为您的发布构建和发布sdist和wheels。这样一来，用户可以选择：如果他们的环境兼容（对于纯Python包始终如此），他们可以获取并安装wheel——或者他们可以获取sdist并在本地构建wheel（参见[图3-3](#figure_packages_wheels_and_sdists)）。
- en: '![The diagram shows how the author builds and publishes an sdist and a wheel.
    Users either download and install the wheel, or they download the sdist and build
    and install a wheel from it.](assets/hmpt_0303.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![本图显示了作者如何构建和发布sdist和wheel。用户可以下载并安装wheel，或者下载sdist并从中构建和安装wheel。](assets/hmpt_0303.png)'
- en: Figure 3-3\. Wheels and sdists
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-3\. Wheels和sdists
- en: For consumers of packages, sdists come with a few caveats. First, the build
    step involves arbitrary code execution, which can be a security concern.^([4](ch03.html#id267))
    Second, installing wheels is much faster than installing sdists, especially for
    legacy *setup.py*-based packages. Lastly, users may encounter confusing build
    errors for extension modules if they don’t have the required build toolchain on
    their system.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包的使用者来说，sdist有几个注意事项。首先，构建步骤涉及任意代码执行，这可能是一个安全问题^([4](ch03.html#id267))。其次，安装wheels比安装sdist要快得多，特别是对于基于传统*setup.py*的包来说。最后，如果用户系统上缺少所需的构建工具链，他们可能会遇到扩展模块的构建错误。
- en: Generally, a pure Python package has a single sdist and a single wheel for a
    given release. Binary extension modules, on the other hand, commonly come in wheels
    for a range of platforms and environments.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，纯Python包在给定版本发布时会有一个单独的sdist和一个单独的wheel。另一方面，二进制扩展模块通常会针对一系列平台和环境提供wheels。
- en: Tip
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you’re an author of extension modules, check out the `cibuildwheel` project:
    it automates the building and testing of wheels across multiple platforms, with
    support for GitHub Actions and various other continuous integration (CI) systems.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是扩展模块的作者，请查看`cibuildwheel`项目：它可以自动在多个平台上构建和测试wheels，并支持GitHub Actions和其他各种持续集成（CI）系统。
- en: Core Metadata
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心元数据
- en: If you’re curious, you can extract a wheel using the `unzip` utility to see
    the files installers place in the *site-packages* directory. Execute the following
    commands in a shell on Linux or macOS—​preferably inside an empty directory. If
    you’re on Windows, you can follow along using the Windows Subsystem for Linux
    (WSL).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您感兴趣，可以使用`unzip`实用程序解压缩wheel，以查看安装程序放置在*site-packages*目录中的文件。请在Linux或macOS的Shell中执行以下命令——最好在空目录中执行。如果您使用Windows，可以使用Windows子系统来进行操作。
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Besides the import packages (named `attr` and `attrs` in this case), the wheel
    contains a *.dist-info* directory with administrative files. The *METADATA* file
    in this directory contains the *core metadata* for the package, a standardized
    set of attributes that describe the package for the benefit of installers and
    other packaging tools. You can access the core metadata of installed packages
    at runtime using the standard library:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 除了导入的包（在此案例中命名为 `attr` 和 `attrs`），wheel 包含一个 *.dist-info* 目录，其中包含管理文件。该目录中的
    *METADATA* 文件包含包的核心元数据，一组标准化的属性，用于安装程序和其他打包工具的好处。您可以使用标准库在运行时访问已安装包的核心元数据：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the next section, you’ll see how to embed core metadata in your own packages,
    using the `project` table in *pyproject.toml*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将看到如何在您自己的包中嵌入核心元数据，使用 *pyproject.toml* 中的 `project` 表。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The core metadata standards predate *pyproject.toml* by many years. Most project
    metadata fields correspond to a core metadata field, but their names and syntax
    differ slightly. As a package author, you can safely ignore this translation and
    focus on the project metadata.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 核心元数据标准比 *pyproject.toml* 提前多年。大多数项目元数据字段对应于核心元数据字段，但它们的名称和语法略有不同。作为包作者，您可以安全地忽略此翻译，专注于项目元数据。
- en: Project Metadata
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目元数据
- en: Build backends write out core metadata fields based on what you specify in the
    `project` table of *pyproject.toml*. [Table 3-3](#table_packages_project_metadata)
    provides an overview of all the fields you can use in the `project` table.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你在 *pyproject.toml* 的 `project` 表中指定的内容，构建后端会输出核心元数据字段。[表格 3-3](#table_packages_project_metadata)
    提供了 `project` 表中可用字段的概述。
- en: Table 3-3\. The `project` table
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 3-3\. `project` 表
- en: '| Field | Type | Description |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `name` | string | The project name |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 字符串 | 项目名称 |'
- en: '| `version` | string | The version of the project |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `version` | 字符串 | 项目的版本 |'
- en: '| `description` | string | A short description of the project |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `description` | 字符串 | 项目的简要描述 |'
- en: '| `keywords` | array of strings | A list of keywords for the project |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `keywords` | 字符串数组 | 项目的关键词列表 |'
- en: '| `readme` | string or table | A file with a long description of the project
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `readme` | 字符串或表 | 项目详细描述的文件 |'
- en: '| `license` | table | The license governing the use of this project |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `license` | 表 | 管理该项目使用的许可证 |'
- en: '| `authors` | array of tables | The list of authors |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `authors` | 表的数组 | 作者列表 |'
- en: '| `maintainers` | array of tables | The list of maintainers |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `maintainers` | 表的数组 | 维护者列表 |'
- en: '| `classifiers` | array of strings | A list of classifiers describing the project
    |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `classifiers` | 字符串数组 | 描述项目的分类器列表 |'
- en: '| `urls` | table of strings | The project URLs |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `urls` | 字符串表 | 项目的网址 |'
- en: '| `dependencies` | array of strings | The list of required third-party packages
    |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `dependencies` | 字符串数组 | 所需的第三方包列表 |'
- en: '| `optional-dependencies` | table of arrays of strings | Named lists of optional
    third-party packages (*extras*) |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `optional-dependencies` | 表的数组的字符串 | 可选第三方包的命名列表（*extras*） |'
- en: '| `scripts` | table of strings | Entry-point scripts |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `scripts` | 字符串表 | 入口点脚本 |'
- en: '| `gui-scripts` | table of strings | Entry-point scripts providing a graphical
    user interface |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `gui-scripts` | 字符串表 | 提供图形用户界面的入口点脚本 |'
- en: '| `entry-points` | table of tables of strings | Entry point groups |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `entry-points` | 表的表的字符串 | 入口点组 |'
- en: '| `requires-python` | string | The Python version required by this project
    |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `requires-python` | 字符串 | 该项目所需的 Python 版本 |'
- en: '| `dynamic` | array of strings | A list of dynamic fields |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `dynamic` | 字符串数组 | 动态字段列表 |'
- en: 'Two fields are essential and mandatory for every package: `project.name` and
    `project.version`. The project name uniquely identifies the project itself. The
    project version identifies a *release*—a published snapshot of the project during
    its lifetime. Besides the name and version, there are a number of optional fields
    you can provide, such as the author and license, a short text describing the project,
    or third-party packages used by the project (see [Example 3-4](#example_packages_pyproject_toml_large)).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包必需的两个关键字段是 `project.name` 和 `project.version`。项目名称唯一标识项目本身。项目版本标识一个*发布*—项目在其生命周期中的已发布快照。除名称和版本外，还可以提供一些可选字段，例如作者和许可证，描述项目的简短文本，或项目使用的第三方包（见
    [示例 3-4](#example_packages_pyproject_toml_large)）。
- en: Example 3-4\. A pyproject.toml file with project metadata
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-4\. 带有项目元数据的 pyproject.toml 文件
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the following sections, I’ll take a closer look at the various project metadata
    fields.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将更仔细地研究各种项目元数据字段。
- en: Naming Projects
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目命名
- en: The `project.name` field contains the official name of your project.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.name` 字段包含您项目的官方名称。'
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Your users specify this name to install the project with pip. This field also
    determines your project’s URL on PyPI. You can use any ASCII letter or digit to
    name your project, interspersed with periods, underscores, and hyphens. Packaging
    tools normalize project names for comparison: all letters are converted to lowercase,
    and punctuation runs are replaced by a single hyphen (or underscore, in the case
    of package filenames). For example, `Awesome.Package`, `awesome_package`, and
    `awesome-package` all refer to the same project.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过指定此名称来使用 pip 安装项目。此字段还确定了项目在 PyPI 上的 URL。您可以使用任何 ASCII 字母或数字来命名您的项目，其中可以插入句点、下划线和连字符。打包工具会将项目名称标准化以便比较：所有字母都转换为小写，并且标点符号连续运行被替换为一个单破折号（或者在包文件名的情况下替换为下划线）。例如，`Awesome.Package`、`awesome_package`
    和 `awesome-package` 都指代同一个项目。
- en: Project names are distinct from *import names*, the names users specify to import
    your code. Import names must be valid Python identifiers, so they can’t have hyphens
    or periods and can’t start with a digit. They’re case-sensitive and can contain
    any Unicode letter or digit. As a rule of thumb, you should have a single import
    package per distribution package and use the same name for both (or a straightforward
    translation, like `random-wikipedia-article` and `random_wikipedia_article`).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 项目名称与*导入名称*不同，导入名称是用户指定用于导入您的代码的名称。导入名称必须是有效的 Python 标识符，因此不能有连字符或句点，并且不能以数字开头。它们区分大小写，并且可以包含任何
    Unicode 字母或数字。作为一个经验法则，您应该对每个分发包使用单个导入包，并且两者使用相同的名称（或直接翻译，如 `random-wikipedia-article`
    和 `random_wikipedia_article`）。
- en: Versioning Projects
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目版本管理
- en: The `project.version` field stores the version of your project at the time you
    publish the release.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.version` 字段存储您在发布发布时的项目版本。'
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The Python community has a specification for version numbers to ensure that
    automated tools can make meaningful decisions, such as picking the latest release
    of a project. At the core, versions are a dotted sequence of numbers. These numbers
    may be zero, and trailing zeros can be omitted: `1`, `1.0`, and `1.0.0` all refer
    to the same version. Additionally, you can append certain kinds of suffixes to
    a version ([Table 3-4](#table_packages_version_identifiers)). The most common
    ones identify prereleases: `1.0.0a2` is the second alpha release, `1.0.0b3` is
    the third beta release, `1.0.0rc1` is the first release candidate. Each of these
    precedes the next, and all of them precede the final release: `1.0.0`. Python
    versions can use additional components as well as alternate spellings; refer to
    [PEP 440](https://peps.python.org/pep-0440/) for the full specification.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Python 社区对版本号有一个规范，以确保自动化工具可以做出有意义的决策，比如选择项目的最新发布版。在核心，版本是一个点分隔的数字序列。这些数字可以是零，并且可以省略尾随零：`1`、`1.0`
    和 `1.0.0` 都指代同一个版本。此外，您还可以附加某些类型的后缀到一个版本（参见 [表 3-4](#table_packages_version_identifiers)）。最常见的后缀用于标识预发布版本：`1.0.0a2`
    是第二个 alpha 发布版，`1.0.0b3` 是第三个 beta 发布版，`1.0.0rc1` 是第一个候选发布版。这些版本都在下一个版本之前，所有这些版本都在最终发布版之前：`1.0.0`。Python
    版本还可以使用额外的组件以及备用拼写；请参阅 [PEP 440](https://peps.python.org/pep-0440/) 获取完整的规范。
- en: Table 3-4\. Version Identifiers
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 3-4\. 版本标识符
- en: '| Release Type | Description | Examples |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 发布类型 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Final release | A stable, public snapshot (default) | `1.0.0`, `2017.5.25`
    |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 最终发布 | 稳定的、公开的快照（默认） | `1.0.0`、`2017.5.25` |'
- en: '| Prerelease | Preview of a final release to support testing | `1.0.0a1`, `1.0.0b1`,
    `1.0.0rc1` |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 预发布 | 支持测试的最终发布的预览 | `1.0.0a1`、`1.0.0b1`、`1.0.0rc1` |'
- en: '| Developmental release | A regular internal snapshot, such as a nightly build
    | `1.0.0.dev1` |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 开发版本发布 | 像夜间构建一样的常规内部快照 | `1.0.0.dev1` |'
- en: '| Post-release | Corrects a minor error outside of the code | `1.0.0.post1`
    |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 后发布 | 修正代码之外的次要错误 | `1.0.0.post1` |'
- en: 'The Python version specification is intentionally permissive. Two widely adopted
    cross-language standards attach additional meaning to version numbers: [Semantic
    Versioning](https://semver.org) uses the scheme `major.minor.patch`, where `patch`
    designates bugfix releases, `minor` designates compatible feature releases, and
    `major` designates releases with breaking changes. [Calendar Versioning](https://calver.org)
    uses date-based versions of various forms, such as `year.month.day`, `year.month.sequence`,
    or `year.quarter.sequence`.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Python 版本规范故意宽松。两个广泛采用的跨语言标准附加了版本号的额外含义：[语义化版本](https://semver.org) 使用 `major.minor.patch`
    方案，其中 `patch` 指代 bug 修复版本，`minor` 指代兼容性特性发布，而 `major` 指代带有破坏性变更的发布。[日历版本](https://calver.org)
    使用各种形式的基于日期的版本，如 `year.month.day`、`year.month.sequence` 或 `year.quarter.sequence`。
- en: Dynamic Fields
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态字段
- en: 'The *pyproject.toml* standard encourages projects to define their metadata
    statically, rather than rely on the build backend to compute the fields during
    the package build. Static metadata benefits the packaging ecosystem, because it
    makes the fields accessible to other tools. It also reduces cognitive overhead:
    build backends use the same configuration format and populate the fields in a
    straightforward and transparent way.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*pyproject.toml* 标准鼓励项目静态定义其元数据，而不是依赖于构建后端在打包期间计算字段。静态元数据有利于打包生态系统，因为它使得字段对其他工具可访问。它还减少了认知负担：构建后端使用相同的配置格式，并以直观透明的方式填充字段。'
- en: But sometimes it’s useful to let the build backend fill in a field dynamically.
    For example, the next section shows how you can derive the package version from
    a Python module or Git tag instead of duplicating it in *pyproject.toml*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时让构建后端动态填充字段也很有用。例如，接下来的部分展示了如何从 Python 模块或 Git 标签派生包版本，而不是在 *pyproject.toml*
    中重复它。
- en: 'For this reason, the project metadata standard provides an escape hatch in
    the form of *dynamic fields*. Projects are allowed to use a backend-specific mechanism
    to compute a field on the fly if they list its name under the `dynamic` key:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，项目元数据标准通过 *动态字段* 提供了一种逃生通道：如果项目在 `dynamic` 键下列出其名称，则允许使用后端特定的机制动态计算字段。
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Single-sourcing the project version
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单一来源项目版本
- en: 'Many projects declare their version at the top of a Python module, like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 许多项目在 Python 模块的顶部声明其版本，如下所示：
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Updating a frequently changing item in several locations is tedious and error-prone.
    Some build backends therefore allow you to extract the version number from the
    code instead of repeating it in `project.version`. This mechanism is specific
    to your build backend, so you configure it in the `tool` table. [Example 3-5](#example_packages_pyproject_toml_dynamic_version)
    demonstrates how this works with Hatch.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个位置更新频繁更改的项目是繁琐且容易出错的。因此，一些构建后端允许您从代码中提取版本号，而不是在 `project.version` 中重复它。此机制特定于您的构建后端，因此您需要在
    `tool` 表中配置它。[示例 3-5](#example_packages_pyproject_toml_dynamic_version)演示了 Hatch
    如何运作。
- en: Example 3-5\. Deriving the project version from a Python module
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-5\. 从 Python 模块派生项目版本
- en: '[PRE29]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](assets/1.png)](#co_python_packages_CO3-1)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_python_packages_CO3-1)'
- en: Mark the version field as dynamic.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将版本字段标记为动态。
- en: '[![2](assets/2.png)](#co_python_packages_CO3-2)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_python_packages_CO3-2)'
- en: Tell Hatch where to look for the `__version__` attribute.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉 Hatch 在哪里查找 `__version__` 属性。
- en: 'You can also avoid the duplication by going in the other direction: Declare
    the version statically in *pyproject.toml* and read it from the installed metadata
    at runtime, as shown in [Example 3-6](#example_packages_importlib_metadata_version).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过另一种方式避免重复：在 *pyproject.toml* 中静态声明版本，并在运行时从安装的元数据中读取，如[示例 3-6](#example_packages_importlib_metadata_version)所示。
- en: Example 3-6\. Reading the version from the installed metadata
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-6\. 从安装的元数据中读取版本
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: But don’t go and add this boilerplate to all your projects yet. Reading the
    metadata from the environment isn’t something you want to do during program startup.
    Third-party libraries like `click` perform the metadata lookup on demand—​for
    example, when the user specifies a command-line option like `--version`. You can
    read the version on demand by providing a `__getattr__` function for your module
    ([Example 3-7](#example_packages_importlib_metadata_version_lazy)).^([5](ch03.html#id268))
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，不要在所有项目中都添加此样板代码。在程序启动期间不应执行环境中的元数据查找。第三方库如 `click` 会按需执行元数据查找——例如，当用户指定类似
    `--version` 的命令行选项时。您可以通过为模块提供 `__getattr__` 函数按需读取版本（[示例 3-7](#example_packages_importlib_metadata_version_lazy)）^([5](ch03.html#id268))。
- en: Example 3-7\. Reading the version from the installed metadata on demand
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-7\. 按需从安装的元数据中读取版本
- en: '[PRE31]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Alas, you still haven’t truly single-sourced the version. Most likely, you also
    tag releases in your version control system (VCS) using a command like `git tag
    v1.0.0`. (If you don’t, you should—​if a release has a bug, the version tags help
    you find the commit that introduced it.)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，您仍未真正实现版本的单一来源。最有可能，您还会使用类似 `git tag v1.0.0` 的命令在版本控制系统（VCS）中标记发布（如果没有，请务必——如果发布存在错误，版本标签可帮助您找到引入该错误的提交）。
- en: Luckily, a number of build backends come with plugins that extract the version
    number from Git, Mercurial, and similar systems. This technique was pioneered
    by the `setuptools-scm` plugin. For Hatch, you can use the `hatch-vcs` plugin,
    which is a wrapper around `setuptools-scm` ([Example 3-8](#example_packages_pyproject_toml_hatch_vcs)).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，许多构建后端都带有从Git、Mercurial和类似系统中提取版本号的插件。这种技术由 `setuptools-scm` 插件首创。对于Hatch，您可以使用
    `hatch-vcs` 插件，它是 `setuptools-scm` 的包装器（[示例 3-8](#example_packages_pyproject_toml_hatch_vcs)）。
- en: Example 3-8\. Deriving the project version from the version control system
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-8\. 从版本控制系统中派生项目版本
- en: '[PRE32]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you build this project from a repository and you’ve checked out the tag `v1.0.0`,
    Hatch will use the version `1.0.0` for the metadata. If you’ve checked out an
    untagged commit, Hatch will instead generate a developmental release like `0.1.dev1+g6b80314`.^([6](ch03.html#id269))
    In other words, you read the project version from Git during the package build,
    and from the package metadata at runtime.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从存储库构建此项目并检出了标签 `v1.0.0`，Hatch 将使用版本 `1.0.0` 的元数据。如果您检出了未标记的提交，则Hatch将生成类似
    `0.1.dev1+g6b80314` 的开发版本。^([6](ch03.html#id269)) 换句话说，您可以在包构建期间从Git读取项目版本，并在运行时从包元数据读取。
- en: Entry-point Scripts
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入口点脚本
- en: '*Entry-point scripts* are small executables that launch the interpreter from
    their environment, import a module and invoke a function (see [“Entry-point scripts”](ch02.html#section_environments_scripts)).
    Installers like pip generate them on the fly when they install a package.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*入口点脚本* 是小型可执行文件，它们从其环境启动解释器，导入一个模块并调用一个函数（参见 [“入口点脚本”](ch02.html#section_environments_scripts)）。安装程序如pip在安装包时会动态生成它们。'
- en: The `project.scripts` table lets you declare entry-point scripts. Specify the
    name of the script as the key and the module and function that the script should
    invoke as the value, using the format `*package*.*module*:*function*`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.scripts` 表允许您声明入口点脚本。将脚本名称指定为键，并指定应调用的模块和函数为值，使用格式 `*package*.*module*:*function*`。'
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This declaration allows users to invoke the program using its given name:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此声明允许用户使用其给定名称调用程序：
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `project.gui-scripts` table uses the same format as the `project.scripts`
    table—​use it if your application has a graphical user interface (GUI).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.gui-scripts` 表使用与 `project.scripts` 表相同的格式——如果您的应用程序具有图形用户界面（GUI），请使用此表。'
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Entry Points
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入口点
- en: Entry-point scripts are a special case of a more general mechanism called *entry
    points*. Entry points allow you to register a Python object in your package under
    a public name. Python environments come with a registry of entry points, and any
    package can query this registry to discover and import modules, using the function
    `importlib.metadata.entry_points` from the standard library. Applications commonly
    use this mechanism to support third-party plugins.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*入口点脚本* 是更一般机制 *入口点* 的特例。入口点允许您在包中注册一个Python对象，公开一个名称。Python环境附带一个入口点注册表，任何包都可以查询此注册表以发现和导入模块，使用标准库中的函数
    `importlib.metadata.entry_points`。应用程序通常使用此机制来支持第三方插件。'
- en: The `project.entry-points` table contains these generic entry points. They use
    the same syntax as entry-point scripts, but are grouped in subtables known as
    *entry point groups*. If you want to write a plugin for another application, you
    register a module or object in its designated entry point group.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.entry-points`表格包含这些通用入口点。它们使用与入口点脚本相同的语法，但分组在被称为*入口点组*的子表中。如果你想为另一个应用程序编写一个插件，你可以在其指定的入口点组中注册一个模块或对象。'
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can also register submodules using dotted notation, as well as objects
    within modules, using the format `*module*:*object*`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用点号表示法注册子模块，以及模块内的对象，使用格式 `*module*:*object*`：
- en: '[PRE37]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let’s look at an example to see how this works. Random Wikipedia articles make
    for fun little fortune cookies, but they can also serve as *test fixtures*^([7](ch03.html#id270))
    for developers of Wikipedia viewers and similar apps. Let’s turn the app into
    a plugin for the pytest testing framework. (Don’t worry if you haven’t worked
    with pytest yet; I’ll cover testing in depth in [Chapter 6](ch06.html#chapter_testing).)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来看看它是如何工作的。随机的维基百科文章看起来像是有趣的小幸运饼干，但它们也可以作为*测试固件*^([7](ch03.html#id270))，用于维基百科查看器和类似应用程序的开发者。让我们把这个应用程序转变成
    pytest 测试框架的一个插件。（如果你还没有使用过 pytest，不用担心；我会在[第6章](ch06.html#chapter_testing)中深入讲解测试。）
- en: Pytest allows third-party plugins to extend its functionality with test fixtures
    and other features. It defines an entry point group for such plugins named `pytest11`.
    You can provide a plugin for pytest by registering a module in this group. Let’s
    also add pytest to the project dependencies.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest 允许第三方插件通过测试固件和其他功能来扩展其功能。它定义了一个名为`pytest11`的入口点组，用于这些插件。你可以通过在这个组中注册一个模块来为
    pytest 提供插件。让我们也把 pytest 添加到项目依赖中。
- en: '[PRE38]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For simplicity, I’ve chosen the top-level module that hosted the `main` function
    in [Example 3-1](#example_packages_wikipedia). Next, extend pytest with a test
    fixture returning a random Wikipedia article, as shown in [Example 3-9](#example_packages_wikipedia_pytest_fixture).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我选择了主函数所在的顶级模块，在[示例 3-1](#example_packages_wikipedia)中展示。接下来，扩展 pytest，添加一个测试固件，返回一个随机的维基百科文章，如[示例 3-9](#example_packages_wikipedia_pytest_fixture)所示。
- en: Example 3-9\. Test fixture with a random Wikipedia article
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-9\. 使用随机维基百科文章的测试固件
- en: '[PRE39]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A developer of a Wikipedia viewer can now install your plugin next to pytest.
    Test functions use your test fixture by referencing it as a function argument
    (see [Example 3-10](#example_packages_wikipedia_pytest_test)). Pytest recognizes
    that the function argument is a test fixture and invokes the test function with
    the return value of the fixture.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科查看器的开发者现在可以在 pytest 旁边安装你的插件了。测试函数通过将其作为函数参数引用来使用你的测试固件（参见[示例 3-10](#example_packages_wikipedia_pytest_test)）。Pytest
    识别出函数参数是一个测试固件，并调用带有固件返回值的测试函数。
- en: Example 3-10\. A test function that uses the random article fixture
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-10\. 使用随机文章固件的测试函数
- en: '[PRE40]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](assets/1.png)](#co_python_packages_CO4-1)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_python_packages_CO4-1)'
- en: A real test would run the viewer instead of `print()`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真正的测试会运行查看器而不是`print()`。
- en: '[![2](assets/2.png)](#co_python_packages_CO4-2)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_python_packages_CO4-2)'
- en: Fail the test so we get to see the full output.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让测试失败以便我们能够看到完整的输出。
- en: 'You can try this out yourself in an active virtual environment in the project
    directory:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目目录中的活动虚拟环境中自己尝试这个：
- en: '[PRE41]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Authors and Maintainers
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作者和维护者
- en: The `project.authors` and `project.maintainers` fields contain the list of authors
    and maintainers for the project. Each item in these lists is a table with `name`
    and `email` keys—​you can specify either of these keys or both.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.authors`和`project.maintainers`字段包含项目的作者和维护者列表。这些列表中的每个条目都是一个带有`name`和`email`键的表格—​你可以指定这些键中的任一个或两者都指定。'
- en: '[PRE42]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The meaning of the fields is somewhat open to interpretation. If you start a
    new project, I recommend including yourself under `authors` and omitting the `maintainers`
    field. Long-lived open source projects typically list the original author under
    `authors`, while the people in charge of ongoing project maintenance appear as
    `maintainers`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对字段的含义有些开放于解释。如果你开始一个新项目，我建议在`authors`中包括你自己，并省略`maintainers`字段。长期的开源项目通常在`authors`下列出原始作者，而负责项目持续维护的人员则出现在`maintainers`下。
- en: The Description and README
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述和 README
- en: The `project.description` field contains a short description as a string. This
    field will appear as the subtitle of your project page on PyPI. Some packaging
    tools also use this field when displaying a compact list of packages with human-readable
    descriptions.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.description` 字段包含一个短描述作为字符串。此字段将作为您在 PyPI 上项目页面的副标题出现。一些打包工具在显示可读性描述的紧凑包列表时也使用此字段。'
- en: '[PRE43]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `project.readme` field is typically a string with the relative path to the
    file with the long description of your project. Common choices are *README.md*
    for a description written in Markdown format and *README.rst* for the reStructuredText
    format. The contents of this file appear on your project page on PyPI.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.readme` 字段通常是一个字符串，包含项目长描述文件的相对路径。通常的选择是用于 Markdown 格式的 *README.md*
    和用于 reStructuredText 格式的 *README.rst*。此文件的内容将出现在 PyPI 上的项目页面上。'
- en: '[PRE44]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Instead of a string, you can also specify a table with `file` and `content-type`
    keys.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定带有 `file` 和 `content-type` 键的表格，而不是字符串。
- en: '[PRE45]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can even embed the long description in the *pyproject.toml* file using the
    `text` key.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以使用 `text` 键将长描述嵌入到 *pyproject.toml* 文件中。
- en: '[PRE46]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Writing a README that renders well is not trivial—​often, the project description
    appears in disparate places, like PyPI, a repository hosting service like GitHub,
    and inside official documentation on services like [Read the Docs](https://readthedocs.org).
    If you need more flexibility, you can declare the field dynamic and use a plugin
    like `hatch-fancy-pypi-readme` to assemble the project description from multiple
    fragments.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 编写良好的 README 并非易事—通常，项目描述会出现在不同的地方，例如 PyPI、类似 GitHub 的仓库托管服务，以及像 [Read the Docs](https://readthedocs.org)
    这样的官方文档服务内部。如果需要更多灵活性，您可以声明字段是动态的，并使用像 `hatch-fancy-pypi-readme` 这样的插件从多个片段组装项目描述。
- en: Keywords and Classifiers
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键词和分类器
- en: The `project.keywords` field contains a list of strings that people can use
    to search for your project on PyPI.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.keywords` 字段包含一个字符串列表，供人们在 PyPI 上搜索您的项目使用。'
- en: '[PRE47]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `project.classifiers` field contains a list of classifiers to categorize
    the project in a standardized way.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.classifiers` 字段包含一个分类器列表，以标准化方式对项目进行分类。'
- en: '[PRE48]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: PyPI maintains the [official registry](https://pypi.org/classifiers) of classifiers
    for Python projects. They’re known as *Trove classifiers* and consist of hierarchically
    organized labels separated by double colons ([Table 3-5](#table_packages_trove_classifiers)).
    The Trove project, initiated by Eric S. Raymond, was an early design for an open
    source software repository.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: PyPI 维护 Python 项目的 [官方注册表](https://pypi.org/classifiers)。它们被称为 *Trove classifiers*，由双冒号分隔的分层组织标签组成（见
    [表 3-5](#table_packages_trove_classifiers)）。Trove 项目由 Eric S. Raymond 发起，是一个早期设计的开源软件存储库。
- en: Table 3-5\. Trove Classifiers
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-5\. Trove 分类器
- en: '| Classifier Group | Description | Example |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| 分类器组 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Development Status | How mature this release is | `Development Status ::
    5 - Production/Stable` |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| 开发状态 | 此版本的成熟度 | `Development Status :: 5 - Production/Stable` |'
- en: '| Environment | The environment in which the project runs | `Environment ::
    No Input/Output (Daemon)` |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 环境 | 项目运行的环境 | `Environment :: No Input/Output (Daemon)` |'
- en: '| Operating System | The operating systems supported by the project | `Operating
    System :: OS Independent` |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 操作系统 | 项目支持的操作系统 | `Operating System :: OS Independent` |'
- en: '| Framework | Any framework used by the project | `Framework :: Flask` |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 框架 | 项目使用的任何框架 | `Framework :: Flask` |'
- en: '| Audience | The kind of users served by the project | `Intended Audience ::
    Developers` |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 受众 | 项目服务的用户类型 | `Intended Audience :: Developers` |'
- en: '| License | The license under which the project is distributed | `License ::
    OSI Approved :: MIT License` |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 许可证 | 项目分发的许可证 | `License :: OSI Approved :: MIT License` |'
- en: '| Natural Language | The natural languages supported by the project | `Natural
    Language :: English` |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 自然语言 | 项目支持的自然语言 | `Natural Language :: English` |'
- en: '| Programming Language | The programming language the project is written in
    | `Programming Language :: Python :: 3.12` |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 编程语言 | 项目所用的编程语言 | `Programming Language :: Python :: 3.12` |'
- en: '| Topic | Various topics related to the project | `Topic :: Utilities` |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 主题 | 与项目相关的各种主题 | `Topic :: Utilities` |'
- en: Classifiers are entirely optional. I recommend indicating the development status
    and the supported operating systems, which aren’t covered by other metadata fields.
    If you’d like to include more classifiers, provide one from each classifier group.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 分类器完全是可选的。我建议指明开发状态和支持的操作系统，这些信息在其他元数据字段中没有涵盖。如果你想包含更多分类器，请提供每个分类器组中的一个。
- en: The Project URLs
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 URL
- en: The `project.urls` table allows you to point users to your project homepage,
    source code, documentation, issue tracker, and similar project-related URLs. Your
    project page on PyPI links to these pages using the provided key as the display
    text for each link. It also displays an appropriate icon for many common names
    and URLs.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.urls` 表格允许你将用户指向项目主页、源代码、文档、问题跟踪器和类似项目相关的 URL。你在 PyPI 上的项目页面使用提供的键作为每个链接的显示文本。它还为许多常见名称和
    URL 显示适当的图标。'
- en: '[PRE49]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The License
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许可证
- en: The `project.license` field is a table where you can specify your project license
    under the `text` key or by reference to a file under the `file` key. You may also
    want to add the corresponding Trove classifier for the license.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.license` 字段是一个表格，你可以在 `text` 键下指定项目的许可证，或者通过 `file` 键引用文件。你可能还希望添加相应的
    Trove 分类器来说明许可证。'
- en: '[PRE50]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: I recommend using the `text` key with a [SPDX license identifier](https://spdx.org/licenses/)
    such as “MIT” or “Apache-2.0”. The Software Package Data Exchange (SPDX) is an
    open standard backed by the Linux Foundation for communicating software bill of
    material information, including licenses.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用 `text` 键，并使用类似“MIT”或“Apache-2.0”的 [SPDX 许可证标识符](https://spdx.org/licenses/)。软件包数据交换
    (SPDX) 是 Linux 基金会支持的开放标准，用于传达软件物料清单信息，包括许可证。
- en: Note
  id: totrans-346
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'As of this writing, a Python Enhancement Proposal (PEP) is under discussion
    that changes the `license` field to a string using SPDX syntax and adds a `license-files`
    key for license files distributed with the package: [PEP 639](https://peps.python.org/pep-0639/).'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文撰写时，正在讨论一项 Python 增强提案 (PEP)，该提案将 `license` 字段更改为使用 SPDX 语法的字符串，并添加一个 `license-files`
    键用于包内分发的许可证文件：[PEP 639](https://peps.python.org/pep-0639/)。
- en: 'If you’re unsure which open source license to use for your project, [choosealicense.com](https://choosealicense.com/)
    provides some useful guidance. For a proprietary project, it’s common to specify
    “proprietary”. You can also add the special classifier `Private :: Do Not Upload`
    to prevent accidental upload to PyPI.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '如果不确定要为项目选择哪种开源许可证，[choosealicense.com](https://choosealicense.com/) 提供了一些有用的指导。对于专有项目，通常会指定“proprietary”。你还可以添加特殊的分类器
    `Private :: Do Not Upload`，以防止意外上传到 PyPI。'
- en: '[PRE51]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The Required Python Version
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所需 Python 版本
- en: Use the `project.requires-python` field to specify the versions of Python that
    your project supports.^([8](ch03.html#id271))
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `project.requires-python` 字段来指定你的项目支持的 Python 版本。^([8](ch03.html#id271))
- en: '[PRE52]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Most commonly, people specify the minimum Python version as a lower bound, using
    a string with the format `>=3.x`. The syntax of this field is more general and
    follows the same rules as *version specifiers* for project dependencies (see [Chapter 4](ch04.html#chapter_dependencies)).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，人们将最低 Python 版本指定为下限，使用格式为 `>=3.x` 的字符串。此字段的语法更通用，并遵循项目依赖的 *版本规范* 相同的规则（参见
    [第四章](ch04.html#chapter_dependencies)）。
- en: Tools like Nox and tox make it easy to run checks across multiple Python versions,
    helping you ensure that the field reflects reality. As a baseline, I recommend
    requiring the oldest Python version that still receives security updates. You
    can find the end-of-life dates for all current and past Python versions on the
    [Python Developer Guide](https://devguide.python.org/versions/).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Nox 和 tox 等工具使得在多个 Python 版本上运行检查变得更加容易，帮助你确保字段反映现实情况。作为基准，我建议要求最旧的仍然接收安全更新的
    Python 版本。你可以在 [Python 开发者指南](https://devguide.python.org/versions/) 上找到所有当前和过去
    Python 版本的生命周期终止日期。
- en: There are three main reasons to be more restrictive about the Python version.
    First, your code may depend on newer language features—​for example, structural
    pattern matching was introduced in Python 3.10\. Second, your code may depend
    on newer features in the standard library—​look out for the “Changed in version
    3.x” notes in the official documentation. Third, it could depend on third-party
    packages with more restrictive Python requirements.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 版本更加严格的主要原因有三点。首先，你的代码可能依赖于较新的语言特性——例如，Python 3.10 引入了结构模式匹配。其次，你的代码可能依赖于标准库中的更新特性——请查看官方文档中关于“在
    3.x 版本中变更”的说明。第三，可能依赖于对 Python 版本要求更为严格的第三方包。
- en: Some packages declare upper bounds on the Python version, such as `>=3.8,<4`.
    This practice is discouraged, but depending on such a package may force you to
    declare the same upper bound for your own package. Dependency solvers can’t downgrade
    the Python version in an environment; they will either fail or, worse, downgrade
    the package to an old version with a looser Python constraint. A future Python
    4 is unlikely to introduce the kind of breaking changes that people associate
    with the transition from Python 2 to 3.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 一些包声明Python版本的上限，例如`>=3.8,<4`。虽然不建议这种做法，但是依赖此类包可能会迫使您为自己的包声明相同的上限。依赖解决器无法在环境中降级Python版本；它们要么失败，要么更糟，降级包到带有更宽松Python约束的旧版本。未来的Python
    4不太可能引入像人们从Python 2转向3时那样的重大更改。
- en: Warning
  id: totrans-357
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Don’t specify an upper bound for the required Python version unless you *know*
    that your package is not compatible with any higher version. Upper bounds cause
    disruption in the ecosystem when a new version is released.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您*确信*您的包与任何更高版本不兼容，否则不要为所需的Python版本指定上限。上限会在发布新版本时在生态系统中引起混乱。
- en: Dependencies and Optional Dependencies
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖和可选依赖
- en: The remaining two fields, `project.dependencies` and `project.optional-dependencies`,
    list any third-party packages on which your project depends. You’ll take a closer
    look at these fields—​and dependencies in general—​in the next chapter.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的两个字段，`project.dependencies`和`project.optional-dependencies`，列出了项目依赖的任何第三方包。您将在下一章节更详细地查看这些字段以及依赖关系。
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: Packaging allows you to publish releases of your Python projects, using source
    distributions (*sdists*) and built distributions (*wheels*). These artifacts contain
    your Python modules, together with project metadata, in an archive format that
    end users can easily install into their environments. The standard *pyproject.toml*
    file defines the build system for a Python project as well as the project metadata.
    Build frontends like `build`, pip, and uv use the build system information to
    install and run the build backend in an isolated environment. The build backend
    assembles an sdist and wheel from the source tree and embeds the project metadata.
    You can upload packages to the Python Package Index (PyPI) or a private repository,
    using a tool like Twine. The Python project manager Rye provides a more integrated
    workflow on top of these tools.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 打包允许您发布Python项目的版本，使用源分发（*sdists*）和构建分发（*wheels*）。这些构件包含您的Python模块以及项目元数据，以一种用户可以轻松安装到其环境中的归档格式。标准的*pyproject.toml*文件定义了Python项目的构建系统以及项目元数据。构建前端工具如`build`、pip和uv使用构建系统信息在隔离环境中安装和运行构建后端。构建后端从源代码树中组装sdist和wheel，并嵌入项目元数据。您可以使用类似Twine的工具将包上传到Python包索引（PyPI）或私有仓库。Python项目管理器Rye在这些工具之上提供了更集成的工作流程。
- en: ^([1](ch03.html#id263-marker)) Even the venerable Comprehensive Perl Archive
    Network (CPAN) didn’t exist in February 1991, when Guido van Rossum published
    the first release of Python on Usenet.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#id263-marker)) 即使是备受尊敬的综合Perl存档网络（CPAN），也不存在于1991年2月，当时Guido
    van Rossum在Usenet上发布了Python的第一个版本。
- en: ^([2](ch03.html#id264-marker)) By default, the `build` tool builds the wheel
    from the sdist instead of the source tree, to ensure that the sdist is valid.
    Build backends can request additional build dependencies using the `get_requires_for_build_wheel`
    and `get_requires_for_build_sdist` build hooks.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.html#id264-marker)) 默认情况下，`build`工具从sdist而不是源代码树构建wheel，以确保sdist有效。构建后端可以使用`get_requires_for_build_wheel`和`get_requires_for_build_sdist`构建钩子请求额外的构建依赖。
- en: ^([3](ch03.html#id266-marker)) Python’s packaging ecosystem is also a great
    demonstration of *Conway’s law*. In 1967, Melvin Conway—​an American computer
    scientist also known for developing the concept of coroutines—​observed that organizations
    will design systems that are copies of their communication structure.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.html#id266-marker)) Python的打包生态系统也是*康威定律*的一个很好的演示。1967年，Melvin Conway——一位美国计算机科学家，也因开发协程概念而闻名——观察到组织会设计其通信结构的系统副本。
- en: ^([4](ch03.html#id267-marker)) This is especially true given the existence of
    *typosquatting*—where an attacker uploads a malicious package whose name is similar
    to a popular package—​and *dependency confusion attacks*—where a malicious package
    on a public server uses the same name as a package on a private company repository.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch03.html#id267-marker)) 特别是考虑到*错字滥用*——即攻击者上传一个名字类似于流行包的恶意包——以及*依赖混淆攻击*——即公共服务器上的恶意包使用与私有公司仓库中包名相同的情况。
- en: ^([5](ch03.html#id268-marker)) This nifty technique comes courtesy of my reviewer
    Hynek Schlawack.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch03.html#id268-marker)) 这个巧妙的技巧来自我的审阅者Hynek Schlawack。
- en: ^([6](ch03.html#id269-marker)) In case you’re wondering, the `+g6b80314` suffix
    is a *local version identifier* that designates downstream changes, in this case
    using output from the command `git describe`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch03.html#id269-marker)) 如果您好奇的话，`+g6b80314` 后缀是*本地版本标识符*，指代下游更改，本例中使用了
    `git describe` 命令的输出。
- en: ^([7](ch03.html#id270-marker)) *Test fixtures* set up objects that you need
    to run repeatable tests against your code.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch03.html#id270-marker)) *测试固件* 可以设置您需要对代码运行重复测试的对象。
- en: ^([8](ch03.html#id271-marker)) You can also add Trove classifiers for each supported
    Python version. Some backends backfill classifiers for you—​Poetry does this out
    of the box for Python versions and project licenses.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch03.html#id271-marker)) 您还可以为每个支持的Python版本添加Trove分类器。某些后端会为您填充分类器——例如，Poetry对Python版本和项目许可证可以直接进行此操作。
