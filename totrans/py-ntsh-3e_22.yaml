- en: 'Chapter 22\. Structured Text: HTML'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第22章 结构化文本：HTML
- en: Most documents on the web use HTML, the HyperText Markup Language. *Markup*
    is the insertion of special tokens, known as *tags*, in a text document, to structure
    the text. HTML is, in theory, an application of the large, general standard known
    as SGML, the [Standard Generalized Markup Language](https://oreil.ly/X-3xi). In
    practice, many documents on the web use HTML in sloppy or incorrect ways.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上的大多数文档使用HTML，即超文本标记语言。 *标记* 是在文本文档中插入特殊标记（称为 *标签* ）以结构化文本。HTML 理论上是一种大而普遍的标准应用，称为
    [标准通用标记语言（SGML）](https://oreil.ly/X-3xi)。然而，在实践中，许多网络文档以松散或不正确的方式使用HTML。
- en: HTML was designed for presenting documents in a browser. As web content evolved,
    users realized it lacked the capability for *semantic markup*, in which the markup
    indicates the meaning of the delineated text rather than simply its appearance.
    Complete, precise extraction of the information in an HTML document often turns
    out to be unfeasible. A more rigorous standard called XHTML attempted to remedy
    these shortcomings. XHTML is similar to traditional HTML, but it is defined in
    terms of XML, the eXtensible Markup Language, and more precisely than HTML. You
    can handle well-formed XHTML with the tools covered in [Chapter 23](ch23.xhtml#structured_text_xml).
    However, as of this writing, XHTML has not enjoyed overwhelming success, getting
    scooped instead by the more pragmatic HTML5.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 设计用于在浏览器中呈现文档。随着网络内容的发展，用户意识到它缺乏 *语义标记* 的能力，其中标记指示划分文本的意义而不仅仅是其外观。完全、精确地提取HTML文档中的信息通常是不可行的。一个更严格的标准称为XHTML试图弥补这些缺点。XHTML
    类似于传统的HTML，但是它是以XML（可扩展标记语言）的术语来定义的，比HTML更加精确。您可以使用 [第23章](ch23.xhtml#structured_text_xml)
    中涵盖的工具处理格式良好的XHTML。然而，截至本文撰写时，XHTML 并未取得压倒性成功，而是被更为实用的HTML5所取代。
- en: Despite the difficulties, it’s often possible to extract at least some useful
    information from HTML documents (a task known as *web scraping*, *spidering*,
    or just *scraping*). Python’s standard library tries to help, supplying the html
    package for the task of parsing HTML documents, whether for the purpose of presenting
    the documents or, more typically, as part of an attempt to extract information
    from them. However, when you’re dealing with somewhat-broken web pages (which
    is almost always the case!), the third-party module [BeautifulSoup](https://oreil.ly/9-cUQ)
    usually offers your last, best hope. In this book, for pragmatic reasons, we mostly
    cover BeautifulSoup, ignoring the standard library modules competing with it.
    The reader looking for alternatives should also investigate the increasingly popular
    [scrapy package](https://scrapy.org).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在困难，通常可以从HTML文档中提取至少一些有用信息（称为 *网页抓取*、*蜘蛛行动* 或仅为 *抓取* 的任务）。Python标准库尝试帮助您，提供了用于解析HTML文档的html包，无论是为了呈现文档还是更典型地作为尝试从中提取信息的一部分。然而，当处理有些不完整的网页（这几乎总是情况！）时，第三方模块
    [BeautifulSoup](https://oreil.ly/9-cUQ) 通常是您最后的、最好的希望。在本书中，出于实际原因，我们主要涵盖BeautifulSoup，忽略与其竞争的标准库模块。寻求替代方案的读者也应该调查越来越流行的
    [scrapy 包](https://scrapy.org)。
- en: Generating HTML and embedding Python in HTML are also reasonably frequent tasks.
    The standard Python library doesn’t support HTML generation or embedding, but
    you can use Python string formatting, and third-party modules can also help. BeautifulSoup
    lets you alter an HTML tree (so, in particular, you can build one up programmatically,
    even “from scratch”); an often preferable alternative approach is *templating*,
    supported, for example, by the third-party module [jinja2](http://jinja.pocoo.org),
    whose bare essentials we cover in [“The jinja2 Package”](#the_jinjatwo_package).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 生成HTML和在HTML中嵌入Python也是相当频繁的任务。标准的Python库不支持HTML生成或嵌入，但可以使用Python字符串格式化，并且第三方模块也可以提供帮助。BeautifulSoup
    允许您修改HTML树（因此，特别是可以程序化地构建一个，甚至“从头”开始）；一个常见的替代方法是 *模板化*，例如由第三方模块 [jinja2](http://jinja.pocoo.org)
    支持，我们在 [“jinja2包”](#the_jinjatwo_package) 中提供了基本内容。
- en: The html.entities Module
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: html.entities 模块
- en: The html.entities module in Python’s standard library supplies a few attributes,
    all of them mappings (see [Table 22-1](#attributes_of_htmldotentities)). They
    come in handy whatever general approach you’re using to parse, edit, or generate
    HTML, including the BeautifulSoup package covered in the following section.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库中的 html.entities 模块提供了几个属性，全部都是映射关系（参见 [表 22-1](#attributes_of_htmldotentities)）。无论你用什么一般方法解析、编辑或生成
    HTML，包括下一节介绍的 BeautifulSoup 包，这些属性都很有用。
- en: Table 22-1\. Attributes of html.entities
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 表 22-1\. html.entities 的属性
- en: '| codepoi⁠n⁠t⁠2​n⁠a⁠m⁠e | A mapping from Unicode codepoints to HTML entity
    names. For example, entities.codepoint2name[228] is ''auml'', since Unicode character
    228, ä, “lowercase a with diaeresis,” is encoded in HTML as ''&auml;''. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| codepoi⁠n⁠t⁠2​n⁠a⁠m⁠e | 将 Unicode 代码点映射到 HTML 实体名称。例如，entities.codepoint2name[228]
    是 ''auml''，因为 Unicode 字符 228，ä，“带分音符的小写 a”，在 HTML 中编码为 ''&auml;''。 |'
- en: '| entitydefs | A mapping from HTML entity names to Unicode equivalent single-character
    strings. For example, entities.entitydefs[''auml''] is ''ä'', and entities.entitydefs[''sigma'']
    is ''σ''. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| entitydefs | 将 HTML 实体名称映射到相应的 Unicode 等效单字符字符串。例如，entities.entitydefs[''auml'']
    是 ''ä''，而 entities.entitydefs[''sigma''] 是 ''σ''。 |'
- en: '| html5 | A mapping from HTML5 named character references to equivalent single-character
    strings. For example, entities.xhtml5[''gt;''] is ''>''. The trailing semicolon
    in the key *does* matter—a few, but far from all, HTML5 named character references
    can optionally be spelled without a trailing semicolon, and in those cases both
    keys (with and without the trailing semicolon) are present in entities.xhtml5.
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| html5 | 将 HTML5 命名字符引用映射到等效的单字符字符串。例如，entities.xhtml5[''gt;''] 是 ''>''。键中的尾部分号
    *确实* 重要 —— 少数但远非所有 HTML5 命名字符引用可以选择性地省略尾部分号，在这些情况下，entities.xhtml5 中会同时存在带有和不带有尾部分号的键。
    |'
- en: '| name2codepoint | A mapping from HTML entity names to Unicode codepoints.
    For example, entities.name2codepoint[''auml''] is 228. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| name2codepoint | 将 HTML 实体名称映射到 Unicode 代码点。例如，entities.name2codepoint[''auml'']
    是 228。 |'
- en: The BeautifulSoup Third-Party Package
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BeautifulSoup 第三方包
- en: '[BeautifulSoup](https://oreil.ly/xx57e) lets you parse HTML even if it’s rather
    badly formed. It uses simple heuristics to compensate for typical HTML brokenness,
    and succeeds at this hard task surprisingly well in most cases. The current major
    version of BeautifulSoup is version 4, also known as bs4. In this book, we specifically
    cover version 4.10; as of this writing, that’s the latest stable version of bs4.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[BeautifulSoup](https://oreil.ly/xx57e) 允许你解析 HTML，即使它的格式相当糟糕。它使用简单的启发式方法来弥补典型的
    HTML 损坏，并且在大多数情况下成功地完成这一艰巨任务。当前的 BeautifulSoup 主要版本是版本 4，也称为 bs4。在本书中，我们特别涵盖了版本
    4.10；截至撰写本文时，这是 bs4 的最新稳定版本。'
- en: Installing Versus Importing BeautifulSoup
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装与导入 BeautifulSoup
- en: BeautifulSoup is one of those annoying modules whose packaging requires you
    to use different names inside and outside Python. You install the module by running
    **pip install beautifulsoup4** at a shell command prompt, but when you import
    it in your Python code, you use **import** bs4.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: BeautifulSoup 是那些包装要求你在 Python 内外使用不同名称的烦人模块之一。你可以通过在 shell 命令提示符下运行 **pip install
    beautifulsoup4** 来安装该模块，但在 Python 代码中导入时，你使用 **import** bs4。
- en: The BeautifulSoup Class
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BeautifulSoup 类
- en: 'The bs4 module supplies the BeautifulSoup class, which you instantiate by calling
    it with one or two arguments: first, htmltext—either a file-like object (which
    is read to get the HTML text to parse) or a string (which is the text to parse)—and
    second, an optional parser argument.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: bs4 模块提供了 BeautifulSoup 类，通过调用它并传入一个或两个参数来实例化：第一个是 htmltext —— 可以是类似文件的对象（读取其中的
    HTML 文本以解析），或者是字符串（作为要解析的文本）—— 第二个是可选的解析器参数。
- en: Which parser BeautifulSoup uses
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BeautifulSoup 使用的解析器
- en: If you don’t pass a parser argument, BeautifulSoup “sniffs around” to pick the
    best parser (but you may get a GuessedAtParserWarning warning in this case). If
    you haven’t installed any other parser, BeautifulSoup defaults to html.parser
    from the Python standard library; if you have other parsers installed, BeautifulSoup
    defaults to one of them (lxml is currently the preferred one). Unless specified
    otherwise, the following examples use the default Python html.parser. To get more
    control and to avoid the differences between parsers mentioned in the BeautifulSoup
    [documentation](https://oreil.ly/pxxVI), pass the name of the parser library to
    use as the second argument as you instantiate BeautifulSoup.^([1](ch22.xhtml#ch01fn158))
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有传递解析器参数，BeautifulSoup会“嗅探周围”以选择最佳解析器（但在这种情况下可能会收到GuessedAtParserWarning警告）。
    如果您没有安装其他解析器，则BeautifulSoup将默认使用Python标准库中的html.parser； 如果您已安装其他解析器，则BeautifulSoup将默认使用其中之一（目前首选的是lxml）。
    除非另有说明，否则以下示例使用默认的Python html.parser。 为了获得更多控制并避免BeautifulSoup文档中提到的解析器之间的差异，请在实例化BeautifulSoup时将要使用的解析器库的名称作为第二个参数传递。^([1](ch22.xhtml#ch01fn158))
- en: 'For example, if you have installed the third-party package html5lib (to parse
    HTML in the same way as all major browsers do, albeit slowly), you may call:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你已经安装了第三方包html5lib（以与所有主流浏览器相同的方式解析HTML，尽管速度较慢），你可以调用：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you pass 'xml' as the second argument, you must already have the third-party
    package lxml installed. BeautifulSoup then parses the document as XML, rather
    than as HTML. In this case, the attribute is_xml of soup is **True**; otherwise,
    soup.is_xml is **False**. You can also use lxml to parse HTML, if you pass 'lxml'
    as the second argument. More generally, you may need to install the appropriate
    parser library depending on the second argument you choose to pass to a call to
    bs4.BeautifulSoup; BeautifulSoup reminds you with a warning message if you don’t.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将'xml'作为第二个参数传递时，您必须已经安装了第三方包lxml。 BeautifulSoup然后将文档解析为XML，而不是HTML。 在这种情况下，soup的属性is_xml为**True**；
    否则，soup.is_xml为**False**。 如果您将'xml'作为第二个参数传递，也可以使用lxml解析HTML。 更一般地说，您可能需要根据传递给bs4.BeautifulSoup调用的第二个参数选择安装适当的解析器库；
    如果您没有这样做，BeautifulSoup会通过警告消息提醒您。
- en: 'Here’s an example of using different parsers on the same string:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在同一字符串上使用不同解析器的示例：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Differences between parsers in fixing invalid HTML input
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复无效HTML输入中解析器之间的差异
- en: In the preceding example, 'html.parser' simply inserts the end tag </p>, missing
    from the input. Other parsers vary in the degree to which they repair invalid
    HTML input by adding required tags, such as <html>, <head>, and <body>, as you
    can see in the example.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，'html.parser'仅插入了输入中缺失的结束标记</p>。 其他解析器在通过添加所需标记修复无效的HTML输入方面有所不同，例如<html>、<head>和<body>，您可以在示例中看到。
- en: BeautifulSoup, Unicode, and encoding
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BeautifulSoup、Unicode和编码
- en: 'BeautifulSoup uses Unicode, deducing or guessing the encoding^([2](ch22.xhtml#ch01fn159))
    when the input is a bytestring or binary file. For output, the prettify method
    returns a str representation of the tree, including tags and their attributes.
    prettify formats the string with whitespace and newlines added to indent elements,
    displaying the nesting structure. To have it instead return a bytes object (a
    bytestring) in a given encoding, pass it the encoding name as an argument. If
    you don’t want the result to be “prettified,” use the encode method to get a bytestring,
    and the decode method to get a Unicode string. For example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: BeautifulSoup使用Unicode，根据输入是否为字节串或二进制文件来推断或猜测编码^([2](ch22.xhtml#ch01fn159))。
    对于输出，prettify方法返回树的str表示，包括标签及其属性。 prettify使用空格和换行符添加到元素中以缩进元素，显示嵌套结构。 为了使其返回给定编码的bytes对象（字节串），请将编码名称作为参数传递给它。
    如果您不想结果“漂亮”，请使用encode方法获取字节串，并使用decode方法获取Unicode字符串。 例如：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Navigable Classes of bs4
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: bs4的可导航类
- en: An instance *b* of class BeautifulSoup supplies attributes and methods to “navigate”
    the parsed HTML tree, returning instances of *navigable classes* Tag and NavigableString,
    along with subclasses of NavigableString (CData, Comment, Declaration, Doctype,
    and ProcessingInstruction, differing only in how they are emitted when you output
    them).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类BeautifulSoup的实例*b*提供了“导航”解析HTML树的属性和方法，返回*navigable classes* Tag和NavigableString的实例，以及NavigableString的子类（CData、Comment、Declaration、Doctype和ProcessingInstruction，仅在输出时的不同）。
    。
- en: 'Each instance of a navigable class lets you keep navigating—i.e., dig for more
    information—with pretty much the same set of navigational attributes and search
    methods as *b* itself. There are differences: instances of Tag can have HTML attributes
    and child nodes in the HTML tree, while instances of NavigableString cannot (instances
    of NavigableString always have one text string, a parent Tag, and zero or more
    siblings, i.e., other children of the same parent tag).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可导航类的实例都可以让您继续导航——即几乎使用与*b*本身相同的一组导航属性和搜索方法获取更多信息。存在一些差异：Tag的实例可以在HTML树中具有HTML属性和子节点，而NavigableString的实例不能（NavigableString的实例始终具有一个文本字符串，一个父Tag和零个或多个同级，即同一父标记的其他子节点）。
- en: Navigable Class Terminology
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可导航类术语
- en: When we say “instances of NavigableString,” we include instances of any of its
    subclasses; when we say “instances of Tag,” we include instances of BeautifulSoup
    since the latter is a subclass of Tag. Instances of navigable classes are also
    known as the *elements* or *nodes* of the tree.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说“NavigableString的实例”时，我们包括其任何子类的实例；当我们说“Tag的实例”时，我们包括BeautifulSoup的实例，因为后者是Tag的子类。可导航类的实例也称为树的*元素*或*节点*。
- en: 'All instances of navigable classes have attribute name: it’s the tag string
    for Tag instances, ''[document]'' for BeautifulSoup instances, and **None** for
    instances of NavigableString.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可导航类的实例都有属性名称：对于Tag实例，它是标签字符串，对于BeautifulSoup实例，它是'[document]'，对于NavigableString实例，它是**None**。
- en: Instances of Tag let you access their HTML attributes by indexing, or you can
    get them all as a dict via the .attrs Python attribute of the instance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Tag的实例允许您通过索引访问它们的HTML属性，或者您可以通过实例的.attrs属性将它们全部作为字典获取。
- en: Indexing instances of Tag
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引Tag的实例
- en: When *t* is an instance of Tag, *t*['foo'] looks for an HTML attribute named
    foo within *t*’s HTML attributes and returns the string for the foo attribute.
    When *t* has no HTML attribute named foo, *t*['foo'] raises a KeyError exception;
    just like on a dict, call *t*.get('foo', default=**None**) to get the value of
    the default argument instead of an exception.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当*t*是Tag的实例时，*t*['foo']会查找*t*的HTML属性中名为foo的属性，并返回foo属性的字符串。当*t*没有名为foo的HTML属性时，*t*['foo']会引发KeyError异常；类似于字典上的操作，可以调用*t*.get('foo',
    default=**None**)来获取默认参数值，而不是异常。
- en: A few attributes, such as class, are defined in the HTML standard as being able
    to have multiple values (e.g., <body class="foo bar">...</body>). In these cases,
    the indexing returns a list of values—for example, soup.body['class'] would be
    ['foo', 'bar'] (again, you get a KeyError exception when the attribute isn’t present
    at all; use the get method, instead of indexing, to get a default value instead).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性，如class，在HTML标准中被定义为可以具有多个值（例如，<body class="foo bar">...</body>）。在这些情况下，索引返回一个值列表，例如soup.body['class']将是['foo',
    'bar']（如果属性不存在，再次，您将得到一个KeyError异常；使用get方法而不是索引来获取默认值）。
- en: 'To get a dict that maps attribute names to values (or, in a few cases defined
    in the HTML standard, lists of values), use the attribute *t*.attrs:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得将属性名称映射到值（或在HTML标准中定义的少数情况下，值列表）的字典，请使用属性*t*.attrs：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to Check if a Tag Instance Has a Certain Attribute
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何检查Tag实例是否具有某个特定属性
- en: 'To check if a Tag instance *t*’s HTML attributes include one named ''foo'',
    *don’t* use if ''foo'' in *t*:—the in operator on Tag instances looks among the
    Tag’s *children*, *not* its *attributes*. Rather, use if ''foo'' in *t*.attrs:
    or, better, if *t*.has_attr(''foo''):.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查Tag实例*t*的HTML属性是否包含名为'foo'的属性，请*不要*使用if 'foo' in *t*：——在Tag实例上的in运算符会在Tag的*子级*中查找，而*不是*在其*属性*中查找。而是，请使用if
    'foo' in *t*.attrs：或者更好地，使用if *t*.has_attr('foo')：。
- en: Getting an actual string
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取实际字符串
- en: When you have an instance of NavigableString, you often want to access the actual
    text string it contains. When you have an instance of Tag, you may want to access
    the unique string it contains, or, should it contain more than one, all of them—perhaps
    with their text stripped of any whitespace surrounding it. Here’s how you can
    best accomplish these tasks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有一个NavigableString的实例时，通常希望访问它包含的实际文本字符串。当您有一个Tag的实例时，您可能希望访问它包含的唯一字符串，或者如果包含多个字符串，则希望访问所有这些字符串，也许还带有其周围任何空格的文本剥离。以下是您可以完成这些任务的最佳方法。
- en: When you have a NavigableString instance *s* and you need to stash or process
    its text somewhere, without further navigation on it, call str(*s*). Or, use *s*.encode(codec='utf8')
    to get a bytestring, or *s*.decode() to get a text string (i.e., Unicode). These
    give you the actual string, without references to the BeautifulSoup tree that
    would impede garbage collection (*s* supports all methods of Unicode strings,
    so call those directly if they do all that you need).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个NavigableString实例 *s* 并且需要将其文本存储或处理在其他地方，而不需要进一步对其进行导航时，请调用 str(*s*)。或者，使用
    *s*.encode(codec='utf8') 得到一个字节串，或者 *s*.decode() 得到一个文本字符串（即Unicode）。这些方法给出了实际的字符串，而不包含对BeautifulSoup树的引用，这会妨碍垃圾回收（*s*
    支持Unicode字符串的所有方法，因此如果这些方法满足你的需求，可以直接调用它们）。
- en: Given an instance *t* of Tag containing a single NavigableString instance *s*,
    you can use *t*.string to fetch *s* (or, to just get the text you want from *s*,
    use *t*.string.decode()). *t*.string only works when *t* has a single child that’s
    a NavigableString, or a single child that’s a Tag whose only child is a NavigableString;
    otherwise, *t*.string is **None**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个包含单个NavigableString实例 *s* 的Tag实例 *t*，你可以使用 *t*.string 来获取 *s*（或者，如果只想从 *s*
    获取你想要的文本，可以使用 *t*.string.decode()）。当 *t* 有一个单一子项是NavigableString，或者有一个单一子项是Tag，其唯一子项是NavigableString时，*t*.string
    才有效；否则，*t*.string 为 **None**。
- en: As an iterator on *all* contained (navigable) strings, use *t*.strings. You
    can use ''.join(*t*.strings) to get all the strings concatenated into one, in
    a single step. To ignore whitespace around each contained string, use the iterator
    *t*.stripped_strings (which also skips all-whitespace strings).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为所有包含的（可导航的）字符串的迭代器，使用 *t*.strings。你可以使用 ''.join(*t*.strings) 将所有字符串连接成一个单独的字符串，一次完成。要忽略每个包含字符串周围的空白，请使用迭代器
    *t*.stripped_strings（它还会跳过所有空白字符串）。
- en: 'Alternatively, call *t*.get_text(): this returns a single (Unicode) string
    with all the text in *t*’s descendants, in tree order (equivalent to accessing
    the attribute *t*.text). You can optionally pass, as the only positional argument,
    a string to use as separator. The default is the empty string, ''''. Pass the
    named parameter strip=**True** to have each string stripped of surrounding whitespace
    and all-whitespace strings skipped.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，调用 *t*.get_text()：这将返回一个单一的（Unicode）字符串，其中包含 *t* 的后代中所有的文本，按照树的顺序（等同于访问属性
    *t*.text）。你可以选择传递一个字符串作为分隔符的唯一位置参数。默认为空字符串，''。传递命名参数 strip=**True** 可以使每个字符串去除周围的空白，并跳过所有空白字符串。
- en: 'The following examples demonstrate these methods for getting strings from within
    tags:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了从标签内获取字符串的这些方法：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Attribute references on instances of BeautifulSoup and Tag
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BeautifulSoup和Tag的实例上的属性引用。
- en: The simplest, most elegant way to navigate down an HTML tree or subtree in bs4
    is to use Python’s attribute reference syntax (as long as each tag you name is
    unique, or you care only about the first tag so named at each level of descent).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在bs4中，导航HTML树或子树的最简单、最优雅的方法是使用Python的属性引用语法（只要你命名的每个标签都是唯一的，或者你只关心每个下降级别的第一个命名标签）。
- en: Given any instance *t* of Tag, a construct like *t*.foo.bar looks for the first
    tag foo within *t*’s descendants and gets a Tag instance *ti* for it, then looks
    for the first tag bar within *ti*’s descendants and returns a Tag instance for
    the bar tag.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 给定Tag的任何实例 *t*，类似 *t*.foo.bar 的结构会查找 *t* 的后代中的第一个foo标签，并获取它的Tag实例 *ti*，然后查找
    *ti* 的后代中的第一个bar标签，并返回bar标签的Tag实例。
- en: 'It’s a concise, elegant way to navigate down the tree, when you know there’s
    a single occurrence of a certain tag within a navigable instance’s descendants,
    or when the first occurrence of several is all you care about. But beware: if
    any level of lookup doesn’t find the tag it’s looking for, the attribute reference’s
    value is **None**, and then any further attribute reference raises AttributeError.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道在可导航实例的后代中有某个标签的单一出现，或者当你只关心第一个出现的几个时，这是一种简洁而优雅的导航树的方式。但要注意：如果任何查找层级找不到正在寻找的标签，则属性引用的值为
    **None**，然后任何进一步的属性引用都会引发 AttributeError。
- en: Beware of Typos in Attribute References on Tag Instances
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 警惕标签实例属性引用中的拼写错误。
- en: Due to this BeautifulSoup behavior, any typo you make in an attribute reference
    on a Tag instance gives a value of **None**, not an AttributeError exception—so,
    be especially careful!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种BeautifulSoup的行为，如果在Tag实例的属性引用中存在任何拼写错误，将会得到 **None** 的值，而不是 AttributeError
    异常——因此，请特别小心！
- en: bs4 also offers more general ways to navigate down, up, and sideways along the
    tree. In particular, each navigable class instance has attributes that identify
    a single “relative” or, in plural form, an iterator over all relatives of that
    ilk.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: bs4还提供了更一般的方法沿树向下、向上和侧向导航。特别地，每个可导航类实例都有属性，用于标识单个“相对”的或者复数形式下的所有相同类的迭代器。
- en: contents, children, and descendants
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: contents、children和descendants
- en: 'Given an instance *t* of Tag, you can get a list of all of its children as
    *t*.contents, or an iterator on all children as *t*.children. For an iterator
    on all *descendants* (children, children of children, and so on), use *t*.descendants:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 给定Tag的实例*t*，您可以获取其所有子节点的列表作为*t*.contents，或者作为所有子节点的迭代器的*t*.children。要获取所有*descendants*（子节点、子节点的子节点等），请使用*t*.descendants的迭代器：
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The names that are **None** correspond to the NavigableString nodes; only the
    first one of them is a *child* of the p tag, but both are *descendants* of that
    tag.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为**None**的名称对应于NavigableString节点；它们中的第一个是p标签的*child*，但两者都是该标签的*descendants*。
- en: parent and parents
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: parent和parents
- en: 'Given an instance *n* of any navigable class, its parent node is *n*.parent:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 给定任何可导航类的实例*n*，其父节点是*n*.parent：
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: An iterator on all ancestors, going upwards in the tree, is *n*.parents. This
    includes instances of NavigableString, since they have parents, too. An instance
    *b* of BeautifulSoup has *b*.parent **None**, and *b*.parents is an empty iterator.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在树中向上迭代所有祖先节点的迭代器是*n*.parents。这也包括NavigableString的实例，因为它们也有父节点。BeautifulSoup的实例*b*的*b*.parent是**None**，并且*b*.parents是一个空迭代器。
- en: next_sibling, previous_sibling, next_siblings, and previous_siblings
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: next_sibling、previous_sibling、next_siblings和previous_siblings
- en: 'Given an instance *n* of any navigable class, its sibling node to the immediate
    left is *n*.previous_sibling, and the one to the immediate right is *n*.next_sibling;
    either or both can be **None** if *n* has no such sibling. An iterator on all
    left siblings, going leftward in the tree, is *n*.previous_siblings; an iterator
    on all right siblings, going rightward in the tree, is *n*.next_siblings (either
    or both iterators can be empty). This includes instances of NavigableString, since
    they have siblings, too. For an instance *b* of BeautifulSoup, *b*.previous_sibling
    and *b*.next_sibling are both **None**, and both of its sibling iterators are
    empty:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 给定任何可导航类的实例*n*，其紧邻左侧的兄弟节点是*n*.previous_sibling，紧邻右侧的兄弟节点是*n*.next_sibling；如果*n*没有这样的兄弟节点，则可以是**None**。在树中向左迭代所有左侧兄弟节点的迭代器是*n*.previous_siblings；在树中向右迭代所有右侧兄弟节点的迭代器是*n*.next_siblings（这两个迭代器都可能为空）。这也包括NavigableString的实例，因为它们也有兄弟节点。对于BeautifulSoup的实例*b*，*b*.previous_sibling和*b*.next_sibling都是**None**，其兄弟节点迭代器都是空的：
- en: '[PRE31]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: next_element, previous_element, next_elements, and previous_elements
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: next_element、previous_element、next_elements和previous_elements
- en: 'Given an instance *n* of any navigable class, the node parsed just before it
    is *n*.previous_element, and the one parsed just after it is *n*.next_element;
    either or both can be **None** when *n* is the first or last node parsed, respectively.
    An iterator on all previous elements, going backward in the tree, is *n*.previous_elements;
    an iterator on all following elements, going forward in the tree, is *n*.next_elements
    (either or both iterators can be empty). Instances of NavigableString have such
    attributes, too. For an instance *b* of BeautifulSoup, *b*.previous_element and
    *b*.next_element are both **None**, and both of its element iterators are empty:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 给定任何可导航类的实例*n*，其解析的前一个节点是*n*.previous_element，解析的后一个节点是*n*.next_element；当*n*是第一个或最后一个解析的节点时，其中一个或两者可以是**None**。在树中向后迭代所有先前元素的迭代器是*n*.previous_elements；在树中向前迭代所有后续元素的迭代器是*n*.next_elements（这两个迭代器都可能为空）。NavigableString的实例也具有这些属性。对于BeautifulSoup的实例*b*，*b*.previous_element和*b*.next_element都是**None**，其元素迭代器都是空的：
- en: '[PRE33]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As shown in the previous example, the b tag has no next_sibling (since it’s
    the last child of its parent); however, it does have a next_element (the node
    parsed just after it, which in this case is the 'bold' string it contains).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，b标签没有next_sibling（因为它是其父节点的最后一个子节点）；但是，它确实有一个next_element（紧随其后解析的节点，在本例中是其包含的'bold'字符串）。
- en: bs4 find… Methods (aka Search Methods)
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: bs4的find…方法（又称搜索方法）
- en: Each navigable class in bs4 offers several methods whose names start with find,
    known as *search methods*, to locate tree nodes that satisfy specified conditions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可导航类在bs4中提供了几种方法，这些方法的名称以find开头，称为*搜索方法*，用于定位满足指定条件的树节点。
- en: Search methods come in pairs—one method of each pair walks all the relevant
    parts of the tree and returns a list of nodes satisfying the conditions, while
    the other one stops and returns a single node satisfying all the conditions as
    soon as it finds it (or **None** when it finds no such node). Calling the latter
    method is therefore like calling the former one with argument limit=1, then indexing
    the resulting one-item list to get its single item, but faster and more elegant.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, for any Tag instance *t* and any group of positional and named
    arguments represented by ..., the following equivalence always holds:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The method pairs are listed in [Table 22-2](#bsfour_finddotdotdot_method_pairs).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Table 22-2\. bs4 find... method pairs
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '| find, find_all | *b*.find(...), *b*.find_all(...)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Searches the *descendants* of *b* or, when you pass named argument recursive=**False**
    (available only for these two methods, not for other search methods), *b*’s *children*
    only. These methods are not available on NavigableString instances, since they
    have no descendants; all other search methods are available on Tag and NavigableString
    instances.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Since find_all is frequently needed, bs4 offers an elegant shortcut: calling
    a tag is like calling its find_all method. In other words, when *b* is a Tag,
    *b*(...) is the same as *b*.find_all(...).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Another shortcut, already mentioned in [“Attribute references on instances of
    BeautifulSoup and Tag”](#attribute_references_on_instances_of_be), is that *b*.foo.bar
    is like *b*.find('foo').find('bar'). |
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '| find_next, find_all_next | *b*.find_next(...), *b*.find_all_next(...)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Searches the next_elements of *b*. |
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '| f⁠i⁠n⁠d⁠_⁠n⁠e⁠x⁠t⁠_​s⁠i⁠b⁠l⁠i⁠n⁠g, f⁠i⁠n⁠d⁠_⁠n⁠e⁠x⁠t⁠_​s⁠i⁠b⁠l⁠i⁠n⁠g⁠s |
    *b*.find_next_sibling(...), *b*.find_next_siblings(...)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Searches the next_siblings of *b*. |
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '| find_parent, find_parents | *b*.find_parent(...), *b*.find_parents(...)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Searches the parents of *b*. |
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '| find_previous, f⁠i⁠n⁠d⁠_⁠a⁠l⁠l⁠_​p⁠r⁠e⁠v⁠i⁠o⁠u⁠s | *b*.find_previous(...),
    *b*.find_all_previous(...)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Searches the previous_elements of *b*. |
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '| find_previ⁠o⁠u⁠s⁠_​s⁠i⁠b⁠l⁠ing, find_previ⁠o⁠u⁠s⁠_​s⁠i⁠b⁠lings | *b*.find_previous_sibling(...),
    *b*.find_previous_siblings(...) Searches the previous_siblings of *b*. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: Arguments of search methods
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each search method has three optional arguments: *name**,* *attrs*, and *string**.*
    *name* and *string* are *filters*, as described in the following subsection; *attrs*
    is a dict, as described later in this section. In addition, as mentioned in [Table 22-2](#bsfour_finddotdotdot_method_pairs),
    find and find_all only (not the other search methods) can optionally be called
    with the named argument recursive=**False**, to limit the search to children,
    rather than all descendants.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Any search method returning a list (i.e., one whose name is plural or starts
    with find_all) can optionally take the named argument limit: its value, if any,
    is an integer, putting an upper bound on the length of the list it returns (when
    you pass limit, the returned list result is truncated if necessary).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 返回列表的任何搜索方法（即其名称为复数或以find_all开头）可以选择接受命名参数limit：其值（如果有）为整数，将返回的列表长度上限化（当您传递limit时，如有必要，返回的列表结果将被截断）。
- en: 'After these optional arguments, each search method can optionally have any
    number of arbitrary named arguments: the argument name can be any identifier (except
    the name of one of the search method’s specific arguments), while the value is
    a filter.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些可选参数之后，每个搜索方法可以选择具有任意数量的任意命名参数：参数名称可以是任何标识符（除了搜索方法的特定参数名称），而值是筛选器。
- en: Filters
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 筛选器
- en: 'A *filter* is applied against a *target* that can be a tag’s name (when passed
    as the *name* argument), a Tag’s string or a NavigableString’s textual content
    (when passed as the *string* argument), or a Tag’s attribute (when passed as the
    value of a named argument, or in the *attrs* argument). Each filter can be:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*filter*应用于*target*，*target*可以是标签的名称（当作为*name*参数传递时）、Tag的字符串或NavigableString的文本内容（当作为*string*参数传递时）、或Tag的属性（当作为命名参数的值传递或在*attrs*参数中）。
    每个筛选器可以是：'
- en: A Unicode string
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 字符串
- en: The filter succeeds when the string exactly equals the target.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 筛选器成功时，字符串完全等于目标。
- en: A bytestring
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 字节字符串
- en: It’s decoded to Unicode using utf-8, and the filter succeeds when the resulting
    Unicode string exactly equals the target.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用utf-8解码为Unicode，当生成的Unicode字符串完全等于目标时，筛选器成功。
- en: A regular expression object (as produced by re.compile, covered in [“Regular
    Expressions and the re Module”](ch10.xhtml#regular_expressions_and_the_re_module))
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式对象（由re.compile生成，详见[“正则表达式和re模块”](ch10.xhtml#regular_expressions_and_the_re_module)）
- en: The filter succeeds when the search method of the RE, called with the target
    as the argument, succeeds.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当RE的搜索方法以目标作为参数调用成功时，筛选器成功。
- en: A list of strings
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串列表
- en: The filter succeeds if any of the strings exactly equals the target (if any
    of the strings are bytestrings, they’re decoded to Unicode using utf-8).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何字符串完全等于目标（如果任何字符串为字节字符串，则使用utf-8解码为Unicode）则筛选器成功。
- en: A function object
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象
- en: The filter succeeds when the function, called with the Tag or NavigableString
    instance as the argument, returns True.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Tag或NavigableString实例作为参数调用函数时返回True时，筛选器成功。
- en: '**True**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**True**'
- en: The filter always succeeds.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 筛选器总是成功。
- en: As a synonym of “the filter succeeds,” we also say “the target matches the filter.”
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 作为“筛选器成功”的同义词，我们也说“目标与筛选器匹配”。
- en: Each search method finds all relevant nodes that match all of its filters (that
    is, it implicitly performs a logical **and** operation on its filters on each
    candidate node). (Don’t confuse this logic with that of a specific filter having
    a list as an argument value. That one filter matches when any of the items in
    the list do; that is, the filter implicitly performs a logical **or** operation
    on the items of the list that is its argument value.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每个搜索方法都会查找所有与其所有筛选器匹配的相关节点（即，在每个候选节点上隐式执行逻辑**and**操作）。 （不要将此逻辑与具有列表作为参数值的特定筛选器的逻辑混淆。其中一个筛选器匹配列表中的任何项时，该筛选器隐式执行逻辑**or**操作。）
- en: name
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 名称
- en: 'To look for Tags whose name matches a filter, pass the filter as the first
    positional argument to the search method, or pass it as name=*filter*:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找名称匹配筛选器的标签，请将筛选器作为搜索方法的第一个位置参数传递，或将其作为name=*filter*传递：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: string
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串
- en: 'To look for Tag nodes whose .string’s text matches a filter, or NavigableString
    nodes whose text matches a filter, pass the filter as string=*filter*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找其.string文本与筛选器匹配的Tag节点，或者文本与筛选器匹配的NavigableString节点，请将筛选器作为字符串=*filter*传递：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: attrs
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性
- en: To look for Tag nodes that have attributes whose values match filters, use a
    dict *d* with attribute names as keys, and filters as the corresponding values.
    Then, pass *d* as the second positional argument to the search method, or pass
    attrs=*d*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找具有值匹配筛选器的属性的Tag节点，请使用将属性名称作为键和相应筛选器作为相应值的字典*d*。 然后，将*d*作为搜索方法的第二个位置参数传递，或将attrs=*d*传递。
- en: As a special case, you can use, as a value in *d*, **None** instead of a filter;
    this matches nodes that *lack* the corresponding attribute.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 作为特例，您可以使用*d*中的值**None**而不是筛选器；这将匹配缺少相应属性的节点。
- en: 'As a separate special case, if the value *f* of attrs is not a dict, but a
    filter, that is equivalent to having attrs={''class'': *f*}. (This convenient
    shortcut helps because looking for tags with a certain CSS class is a frequent
    task.)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '作为单独的特殊情况，如果 attrs 的值 *f* 不是字典，而是过滤器，则相当于具有 `attrs={''class'': *f*}`。 （此便捷快捷方式非常有用，因为查找具有特定
    CSS 类的标签是频繁的任务。）'
- en: 'You cannot apply both special cases at once: to search for tags without any
    CSS class, you must explicitly pass attrs={''class'': **None**} (i.e., use the
    first special case, but not at the same time as the second one):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '你不能同时应用这两种特殊情况：要搜索没有任何 CSS 类的标签，必须显式地传递 `attrs={''class'': **None**}`（即使用第一个特殊情况，但不能同时使用第二个）：'
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Matching Tags with Multiple CSS Classes
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配具有多个 CSS 类的标签
- en: Unlike most attributes, a tag’s 'class' attribute can have multiple values.
    These are shown in HTML as a space-separated string (e.g., '<p class='foo bar
    baz'>...'), and in bs4 as a list of strings (e.g., *t*['class'] being ['foo',
    'bar', 'baz']).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数属性不同，标签的 `'class'` 属性可以具有多个值。这些在 HTML 中显示为以空格分隔的字符串（例如，`'<p class='foo bar
    baz'>...'`），在 bs4 中作为字符串列表显示（例如，*t*['class'] 为 `['foo', 'bar', 'baz']`）。
- en: When you filter by CSS class in any search method, the filter matches a tag
    if it matches *any* of the multiple CSS classes of such a tag.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何搜索方法中按 CSS 类过滤时，如果标签的多个 CSS 类中有一个匹配，过滤器将匹配该标签。
- en: To match tags by multiple CSS classes, you can write a custom function and pass
    it as the filter to the search method; or, if you don’t need other added functionality
    of search methods, you can eschew search methods and instead use the method *t*.select,
    covered in the following section, and go with the syntax of CSS selectors.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过多个 CSS 类匹配标签，可以编写自定义函数并将其作为过滤器传递给搜索方法；或者，如果不需要搜索方法的其他增加功能，则可以避免搜索方法，而是使用后续部分中介绍的
    `*t*.select` 方法，并按 CSS 选择器的语法进行操作。
- en: Other named arguments
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他命名参数
- en: 'Named arguments, beyond those whose names are known to the search method, are
    taken to augment the constraints, if any, specified in attrs. For example, calling
    a search method with *foo*=*bar* is like calling it with attrs={''*foo*'': *bar*}.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '命名参数，超出搜索方法已知名称的参数，用于增强已指定的 attrs 约束（如果有）。例如，调用搜索方法带有 `*foo*=*bar*` 相当于带有 `attrs={''*foo*'':
    *bar*}`。'
- en: bs4 CSS Selectors
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: bs4 CSS 选择器
- en: 'bs4 tags supply the methods select and select_one, roughly equivalent to find_all
    and find but accepting as the single argument a string that is a [CSS selector](https://oreil.ly/8bNZk)
    and returning, respectively, the list of Tag nodes satisfying that selector or
    the first such Tag node. For example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: bs4 标签提供 `select` 和 `select_one` 方法，大致相当于 `find_all` 和 `find`，但接受一个字符串作为参数，该字符串是
    [CSS 选择器](https://oreil.ly/8bNZk)，分别返回满足该选择器的 Tag 节点列表或第一个这样的 Tag 节点。例如：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'bs4 supports only a subset of the rich CSS selector functionality, and we do
    not cover CSS selectors further in this book. (For complete coverage of CSS, we
    recommend O’Reilly’s [*CSS: The Definitive Guide*](https://www.oreilly.com/library/view/css-the-definitive/9781449325053/),
    by Eric Meyer and Estelle Weyl.) In most cases, the search methods covered in
    the previous section are better choices; however, in a few special cases, calling
    select can save you the (small) trouble of writing a custom filter function.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'bs4 仅支持丰富的 CSS 选择器功能的子集，在本书中不再详细介绍 CSS 选择器。（要完整了解 CSS，建议阅读 O’Reilly 的 [*CSS:
    The Definitive Guide*](https://www.oreilly.com/library/view/css-the-definitive/9781449325053/)，作者是
    Eric Meyer 和 Estelle Weyl。）在大多数情况下，前一节中介绍的搜索方法是更好的选择；然而，在一些特殊情况下，调用 `select` 可以避免编写自定义过滤函数（稍微麻烦的小事）。'
- en: An HTML Parsing Example with BeautifulSoup
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 BeautifulSoup 进行 HTML 解析的示例
- en: 'The following example uses bs4 to perform a typical task: fetch a page from
    the web, parse it, and output the HTTP hyperlinks in the page:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用 bs4 执行典型任务：从 Web 获取页面、解析页面并输出页面中的 HTTP 超链接：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We first call the instance of class bs4.BeautifulSoup (equivalent to calling
    its find_all method) to obtain all instances of a certain tag (here, tag '<a>'),
    then the get method of instances of the tag in question to obtain the value of
    an attribute (here, 'href'), or **None** when that attribute is missing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先调用类 `bs4.BeautifulSoup` 的实例（等同于调用其 `find_all` 方法），以获取特定标签（这里是 `<a>` 标签）的所有实例，然后再获取该标签实例的
    `get` 方法来获取属性的值（这里是 `'href'`），或者在该属性缺失时返回 **None**。
- en: Generating HTML
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成 HTML
- en: Python does not come with tools specifically meant to generate HTML, nor with
    ones that let you embed Python code directly within HTML pages. Development and
    maintenance are eased by separating logic and presentation issues through *templating*,
    covered in [“Templating”](#templating). An alternative is to use bs4 to create
    HTML documents in your Python code by gradually altering very minimal initial
    documents. Since these alterations rely on bs4 *parsing* some HTML, using different
    parsers affects the output, as mentioned in [“Which parser BeautifulSoup uses”](#which_parser_beautifulsoup_uses).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有专门用于生成HTML的工具，也没有让你直接在HTML页面中嵌入Python代码的工具。通过*模板化*（在[“模板化”](#templating)中讨论），通过分离逻辑和表示问题来简化开发和维护。还可以使用bs4在Python代码中创建HTML文档，逐步修改非常简单的初始文档。由于这些修改依赖于bs4解析某些HTML，因此使用不同的解析器会影响输出，如在[“BeautifulSoup使用哪个解析器”](#which_parser_beautifulsoup_uses)中提到的那样。
- en: Editing and Creating HTML with bs4
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用bs4编辑和创建HTML
- en: 'You have various options for editing an instance *t* of Tag. You can alter
    the tag name by assigning to *t*.name, and you can alter *t*’s attributes by treating
    *t* as a mapping: assign to an indexing to add or change an attribute, or delete
    the indexing to remove an attribute (for example, **del** *t*[''foo''] removes
    the attribute foo). If you assign some str to *t*.string, all previous *t*.contents
    (Tags and/or strings—the whole subtree of *t*’s descendants) are discarded and
    replaced with a new NavigableString instance with that str as its textual content.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑Tag的实例*t*有各种选项。你可以通过赋值给*t*.name改变标签名，通过将*t*视为映射来改变*t*的属性：赋值给索引以添加或更改属性，或删除索引以移除属性（例如，**del**
    *t*['foo']移除属性foo）。如果你将一些字符串赋给*t*.string，那么所有先前的*t*.contents（标签和/或字符串—*t*的整个子树）都将被丢弃，并替换为具有该字符串作为其文本内容的新NavigableString实例。
- en: 'Given an instance *s* of NavigableString, you can replace its textual content:
    calling *s*.replace_with(''other'') replaces *s*’s text with ''other''.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 给定NavigableString实例*s*，你可以替换其文本内容：调用*s*.replace_with('other')将*s*的文本替换为'other'。
- en: Building and adding new nodes
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建和添加新节点
- en: Altering existing nodes is important, but creating new ones and adding them
    to the tree is crucial for building an HTML document from scratch.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 修改现有节点很重要，但从头开始构建HTML文档时创建新节点并将其添加到树中至关重要。
- en: 'To create a new NavigableString instance, call the class with the text content
    as the single argument:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的NavigableString实例，请调用类并将文本内容作为唯一参数：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To create a new Tag instance, call the new_tag method of a BeautifulSoup instance,
    with the tag name as the single positional argument and (optionally) named arguments
    for attributes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的Tag实例，请调用BeautifulSoup实例的new_tag方法，将标签名作为唯一的位置参数，并（可选地）为属性命名参数。
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To add a node to the children of a Tag, use the Tag’s append method. This adds
    the node after any existing children:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要将节点添加到Tag的子节点中，请使用Tag的append方法。这将在任何现有子节点之后添加节点：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you want the new node to go elsewhere than at the end, at a certain index
    among *t*’s children, call *t*.insert(*n, s*) to put *s* at index *n* in *t*.contents
    (*t*.append and *t*.insert work as if *t* is a list of its children).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望新节点不是在结尾，而是在*t*的子节点中的某个索引处，请调用*t*.insert(*n, s*)将*s*放置在*t*.contents的索引*n*处（*t*.append和*t*.insert的工作方式就像*t*是其子节点列表一样）。
- en: If you have a navigable element *b* and want to add a new node *x* as *b*’s
    previous_sibling, call *b*.insert_before(*x*). If instead you want *x* to become
    *b*’s next_sibling, call *b*.insert_after(*x*).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个可导航的元素*b*，想要将一个新节点*x*添加为*b*的previous_sibling，请调用*b*.insert_before(*x*)。如果你希望*x*代替*b*的next_sibling，请调用*b*.insert_after(*x*)。
- en: 'If you want to wrap a new parent node *t* around *b*, call *b*.wrap(*t*) (which
    also returns the newly wrapped tag). For example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将新的父节点*t*包裹在*b*周围，调用*b*.wrap(*t*)（这也返回新包裹的标签）。例如：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Replacing and removing nodes
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换和移除节点
- en: 'You can call *t*.replace_with on any tag *t*: the call replaces *t*, and all
    its previous contents, with the argument, and returns *t* with its original contents.
    For example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何标签*t*上调用*t*.replace_with：该调用将替换*t*及其先前的所有内容为参数，并返回具有其原始内容的*t*。例如：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can call *t*.unwrap on any tag *t*: the call replaces *t* with its contents,
    and returns *t* “emptied” (that is, without contents). For example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何标签*t*上调用*t*.unwrap：该调用将替换*t*及其内容，并返回“清空”的*t*（即，没有内容）。例如：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '*t*.clear removes *t*’s contents, destroys them, and leaves *t* empty (but
    still in its original place in the tree). *t*.decompose removes and destroys both
    *t* itself, and its contents:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*t*.clear移除*t*的内容，销毁它们，并将*t*留空（但仍然位于树中的原始位置）。*t*.decompose移除并销毁*t*本身及其内容：'
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Lastly, *t*.extract extracts and returns *t* and its contents, but does not
    destroy anything.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*t*.extract提取并返回*t*及其内容，但不销毁任何内容。
- en: Building HTML with bs4
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用bs4构建HTML
- en: 'Here’s an example of how to use bs4’s methods to generate HTML. Specifically,
    the following function takes a sequence of “rows” (sequences) and returns a string
    that’s an HTML table to display their values:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了如何使用bs4的方法生成HTML。具体来说，以下函数接受一个“行”（序列）的序列，并返回一个字符串，该字符串是一个HTML表格，用于显示它们的值：
- en: '[PRE62]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here is an example using the function we just defined:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用我们刚刚定义的函数的示例：
- en: '[PRE63]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that bs4 automatically converts markup characters such as <, >, and & to
    their corresponding HTML entities; for example, 'g>h' renders as 'g&gt;h'.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，bs4会自动将标记字符如<, >和&转换为它们对应的HTML实体；例如，'g>h'呈现为'g&gt;h'。
- en: Templating
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板化
- en: To generate HTML, the best approach is often *templating*. You start with a
    *template*—a text string (often read from a file, database, etc.) that is almost
    valid HTML, but includes markers, known as *placeholders*, where dynamically generated
    text must be inserted—and your program generates the needed text and substitutes
    it into the template.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成HTML，通常最好的方法是*模板化*。您可以从一个*模板*开始——一个文本字符串（通常从文件、数据库等读取），它几乎是有效的HTML，但包含*占位符*（称为*占位符*），在动态生成的文本必须插入的位置；您的程序生成所需的文本并将其替换到模板中。
- en: 'In the simplest case, you can use markers of the form {*name*}. Set the dynamically
    generated text as the value for key ''*name*'' in some dictionary *d**.* The Python
    string formatting method .format (covered in [“String Formatting”](ch09.xhtml#string_formatting))
    lets you do the rest: when *t* is the template string, *t*.format(*d*) is a copy
    of the template with all values properly substituted.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，您可以使用形式为{*name*}的标记。将动态生成的文本设置为某个字典*d*中键'*name*'的值。Python的字符串格式化方法.format（在[“字符串格式化”](ch09.xhtml#string_formatting)中讨论）让您完成剩下的工作：当*t*是模板字符串时，*t*.format(*d*)是模板的副本，所有值都得到了正确的替换。
- en: In general, beyond substituting placeholders, you’ll also want to use conditionals,
    perform loops, and deal with other advanced formatting and presentation tasks;
    in the spirit of separating “business logic” from “presentation issues,” you’d
    prefer it if all of the latter were part of your templating. This is where dedicated
    third-party templating packages come in. There are many of them, but all of this
    book’s authors, having used and [authored](https://learning.oreilly.com/library/view/python-cookbook/0596001673/ch03s23.xhtml)
    some in the past, currently prefer [jinja2](https://oreil.ly/PYYm5), covered next.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，除了替换占位符之外，您还会希望使用条件语句，执行循环，并处理其他高级格式和展示任务；在将“业务逻辑”与“展示问题”分离的精神下，您更喜欢所有后者作为模板的一部分。这就是专门的第三方模板化包的用武之地。这里有许多这样的包，但本书的所有作者，都曾使用过并[编写](https://learning.oreilly.com/library/view/python-cookbook/0596001673/ch03s23.xhtml)过其中一些，目前更倾向于使用[jinja2](https://oreil.ly/PYYm5)，接下来进行详细介绍。
- en: The jinja2 Package
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jinja2包
- en: For serious templating tasks, we recommend jinja2 (available on [PyPI](https://oreil.ly/1DgV9),
    like other third-party Python packages, so, easily installable with **pip install
    jinja2**).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于严肃的模板化任务，我们推荐使用jinja2（在[PyPI](https://oreil.ly/1DgV9)上可用，像其他第三方Python包一样，因此可以轻松通过**pip
    install jinja2**安装）。
- en: The [jinja2 docs](https://oreil.ly/w6IiV) are excellent and thorough, covering
    the templating language itself (conceptually modeled on Python, but with many
    differences to support embedding it in HTML, and the peculiar needs specific to
    presentation issues); the API your Python code uses to connect to jinja2, and
    expand or extend it if necessary; as well as other issues, from installation to
    internationalization, from sandboxing code to porting from other templating engines—not
    to mention, precious tips and tricks.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[jinja2文档](https://oreil.ly/w6IiV)非常出色和详尽，涵盖了模板语言本身（在概念上模仿Python，但有许多不同之处，以支持在HTML中嵌入它和特定于展示问题的独特需求）；您的Python代码用于连接到jinja2的API，并在必要时扩展或扩展它；以及其他问题，从安装到国际化，从代码沙箱到从其他模板引擎移植——更不用说宝贵的提示和技巧了。'
- en: In this section, we cover only a tiny subset of jinja2’s power, just what you
    need to get started after installing it. We earnestly recommend studying jinja2’s
    docs to get the huge amount of extra, useful information they effectively convey.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们仅涵盖了 jinja2 强大功能的一小部分，这些足以让你在安装后开始使用。我们强烈建议阅读 jinja2 的文档，以获取大量额外有用的信息。
- en: The jinja2.Environment class
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jinja2.Environment 类
- en: When you use jinja2, there’s always an Environment instance involved—in a few
    cases you could let it default to a generic “shared environment,” but that’s not
    recommended. Only in very advanced usage, when you’re getting templates from different
    sources (or with different templating language syntax), would you ever define
    multiple environments—usually, you instantiate a single Environment instance *env*,
    good for all the templates you need to render.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 jinja2 时，总会涉及一个 Environment 实例——在少数情况下，你可以让它默认为一个通用的“共享环境”，但这不推荐。只有在非常高级的用法中，当你从不同来源获取模板（或使用不同的模板语言语法）时，才会定义多个环境实例——通常情况下，你会实例化一个单独的
    Environment 实例 *env*，用于渲染所有需要的模板。
- en: You can customize *env* in many ways as you build it, by passing named arguments
    to its constructor (including altering crucial aspects of templating language
    syntax, such as which delimiters start and end blocks, variables, comments, etc.).
    The one named argument you’ll almost always pass in real-life use is loader (the
    others are rarely set).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在构建 *env* 时通过向其构造函数传递命名参数的方式进行多种方式的定制（包括修改关键的模板语言语法方面，比如哪些定界符用于开始和结束块、变量、注释等）。在实际使用中，你几乎总是会传递一个名为
    loader 的命名参数（其他很少设置）。
- en: An environment’s loader specifies where to load templates from, on request—usually
    some directory in a filesystem, or perhaps some database (you’d have to code a
    custom subclass of jinja2.Loader for the latter purpose), but there are other
    possibilities. You need a loader to let templates enjoy some of jinja2’s most
    powerful features, such as [*template inheritance*](https://oreil.ly/yhG7y).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 环境的 loader 指定了如何在请求时加载模板——通常是文件系统中的某个目录，或者也许是某个数据库（你需要编写 jinja2.Loader 的自定义子类来实现后者），但也有其他可能性。你需要一个
    loader 来让模板享受 jinja2 的一些最强大的特性，比如 [*template inheritance*](https://oreil.ly/yhG7y)。
- en: You can equip *env*, as you instantiate it, with custom [filters](https://oreil.ly/ouZ9A),
    [tests](https://oreil.ly/2NL9l), [extensions](https://oreil.ly/K4wHT), and so
    on (each of those can also be added later).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在实例化 *env* 时配备自定义 [filters](https://oreil.ly/ouZ9A), [tests](https://oreil.ly/2NL9l),
    [extensions](https://oreil.ly/K4wHT) 等（这些也可以稍后添加）。
- en: In the examples presented later, we assume *env* was instantiated with nothing
    but loader=jinja2.FileSystemLoader('*/path/to/templates*'), and not further enriched—in
    fact, for simplicity, we won’t even make use of the loader argument.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍后的示例中，我们假设 *env* 是通过 loader=jinja2.FileSystemLoader('*/path/to/templates*')
    实例化的，没有进一步的增强——事实上，为简单起见，我们甚至不会使用 loader 参数。
- en: '*env*.get_template(*name*) fetches, compiles, and returns an instance of jinja2.Template
    based on what env.loader(*name*) returns. In the examples at the end of this section,
    for simplicity, we’ll instead use the rarely warranted env.from_string(*s*) to
    build an instance of jinja2.Template from string *s*.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*env*.get_template(*name*) 获取、编译并返回基于 env.loader(*name*) 返回内容的 jinja2.Template
    实例。在本节末尾的示例中，为简单起见，我们将使用罕见的 env.from_string(*s*) 来从字符串 *s* 构建 jinja2.Template
    的实例。'
- en: The jinja2.Template class
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jinja2.Template 类
- en: 'An instance *t* of jinja2.Template has many attributes and methods, but the
    one you’ll be using almost exclusively in real life is:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: jinja2.Template 的一个实例 *t* 拥有许多属性和方法，但在实际生活中你几乎只会使用以下这个：
- en: '| render | *t*.render(...*context*...) The *context* argument(s) are the same
    you might pass to a dict constructor—a mapping instance, and/or named arguments
    enriching and potentially overriding the mapping’s key-to-value connections.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '| 渲染 | *t*.render(...*context*...) *context* 参数与传递给 dict 构造函数的内容相同——一个映射实例，和/或丰富和潜在覆盖映射键值连接的命名参数。'
- en: '*t*.render(*context*) returns a (Unicode) string resulting from the *context*
    arguments applied to the template *t*. |'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*t*.render(*context*) 返回一个（Unicode）字符串，该字符串是应用于模板 *t* 的 *context* 参数后生成的结果。'
- en: Building HTML with jinja2
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 jinja2 构建 HTML
- en: 'Here’s an example of how to use a jinja2 template to generate HTML. Specifically,
    just like in [“Building HTML with bs4”](#building_html_with_bsfour), the following
    function takes a sequence of “rows” (sequences) and returns an HTML table to display
    their values:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用jinja2模板生成HTML的示例。具体来说，就像在[“用bs4构建HTML”](#building_html_with_bsfour)中一样，以下函数接受一个“行”（序列）的序列，并返回一个HTML表格来显示它们的值：
- en: '[PRE65]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The function builds the environment with option autoescape=**True**, to automatically
    “escape” strings containing markup characters such as <, >, and &; for example,
    with autoescape=**True**, 'g>h' renders as 'g&gt;h'.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 函数使用选项autoescape=**True**，自动“转义”包含标记字符如<, >和&的字符串；例如，使用autoescape=**True**，'g>h'渲染为'g&gt;h'。
- en: The options trim_blocks=**True** and lstrip_blocks=**True** are purely cosmetic,
    just to ensure that both the template string and the rendered HTML string can
    be nicely formatted; of course, when a browser renders HTML, it does not matter
    whether the HTML text itself is nicely formatted.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 选项trim_blocks=**True**和lstrip_blocks=**True**纯粹是为了美观起见，以确保模板字符串和渲染的HTML字符串都能被良好地格式化；当然，当浏览器渲染HTML时，HTML文本本身是否良好格式化并不重要。
- en: Normally, you would always build the environment with the loader argument and
    have it load templates from files or other storage with method calls such as *t*
    = *env*.get_template(*template_name*). In this example, just to present everything
    in one place, we omit the loader and build the template from a string by calling
    the method *env*.from_string instead. Note that jinja2 is not HTML- or XML-specific,
    so its use alone does not guarantee the validity of the generated content, which
    you should carefully check if standards conformance is a requirement.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您会始终使用加载器参数构建环境，并通过方法调用如*t* = *env*.get_template(*template_name*)从文件或其他存储加载模板。在这个示例中，为了一目了然，我们省略了加载器，并通过调用方法*env*.from_string从字符串构建模板。请注意，jinja2不是HTML或XML特定的，因此仅使用它并不能保证生成内容的有效性，如果需要符合标准，您应该仔细检查生成的内容。
- en: 'The example uses only the two most common features out of the many dozens that
    the jinja2 templating language offers: *loops* (that is, blocks enclosed in {%
    for ... %} and {% endfor %}) and *parameter substitution* (inline expressions
    enclosed in {{ and }}).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例仅使用jinja2模板语言提供的众多功能中最常见的两个特性：*循环*（即，用{% for ... %}和{% endfor %}括起来的块）和*参数替换*（内联表达式用{{和}}括起来）。
- en: 'Here is an example use of the function we just defined:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们刚定义的函数的一个示例用法：
- en: '[PRE66]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ^([1](ch22.xhtml#ch01fn158-marker)) The BeautifulSoup [documentation](https://oreil.ly/B-xCI)
    provides detailed information about installing various parsers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch22.xhtml#ch01fn158-marker)) BeautifulSoup的[文档](https://oreil.ly/B-xCI)提供了关于安装各种解析器的详细信息。
- en: ^([2](ch22.xhtml#ch01fn159-marker)) As explained in the BeautifulSoup [documentation](https://oreil.ly/vTXcK),
    which also shows various ways to guide, or completely override, BeautifulSoup’s
    guesses about encoding.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch22.xhtml#ch01fn159-marker)) 正如在BeautifulSoup的[文档](https://oreil.ly/vTXcK)中解释的那样，它还展示了各种指导或完全覆盖BeautifulSoup关于编码猜测的方法。
