- en: 6 Testing and prompt engineering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 测试与提示工程
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章内容包括
- en: Understanding the importance of testing Copilot code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试 Copilot 代码的重要性
- en: Using closed-box versus open-box testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用闭盒测试与开盒测试
- en: Addressing errors by Copilot by modifying prompts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过修改提示来解决 Copilot 的错误
- en: Working through examples of testing Copilot-generated code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实例讲解如何测试 Copilot 生成的代码
- en: In chapter 3, we first started to see the importance of testing the code produced
    by Copilot. Testing is an essential skill for anyone writing software because
    it gives you confidence that the code is functioning properly. In this chapter,
    we’ll learn how to test our code thoroughly and how to help Copilot fix code that
    doesn’t work by modifying our prompts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章中，我们首次开始意识到测试 Copilot 生成的代码的重要性。测试是编写软件的每个人都必须掌握的技能，因为它能让你确信代码是否正常工作。在本章中，我们将学习如何全面地测试代码，并通过修改提示帮助
    Copilot 修复无法工作的代码。
- en: Testing is an essential skill that you’ll need to learn how to do well on your
    own, so that you’re able to check that the code works correctly. Copilot can generate
    tests and has been improving in the quality of tests it produces, but we encourage
    you to hold off on using Copilot to generate tests just yet because you need to
    learn to do this well enough on your own to be able to verify that the tests Copilot
    produces are reasonable. This will be true of the next few chapters as well—problem
    decomposition, testing, and debugging are all skills that are essential to learn
    how to do on your own, before asking for Copilot’s help, as you need to know how
    to do it on your own to know if Copilot is doing something reasonable.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个至关重要的技能，你需要学会如何独立做好这件事，以便检查代码是否正确。Copilot 可以生成测试，并且在生成测试的质量上已有所提高，但我们鼓励你暂时不要使用
    Copilot 生成测试，因为你需要先学会如何独立做得足够好，才能验证 Copilot 生成的测试是否合理。这一点在接下来的几章中也适用——问题分解、测试和调试是你必须自己学会的技能，然后才能寻求
    Copilot 的帮助，因为你需要知道自己是否掌握了这些技能，才能知道 Copilot 做的是否合理。
- en: 6.1 Why it’s crucial to test code
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 为什么测试代码至关重要
- en: 'Back in chapter 3, we mentioned that you should test code to make sure it’s
    correct. Unfortunately, in our experience, beginning programmers seem to have
    an aversion to testing! Why? We think a couple of things are at play. The first
    is that there’s this well-documented problem nicknamed the *Superbug*, which is
    that humans, when first learning to code, think the computer can understand the
    intent of the code and respond accordingly [1]. Because they wrote the code and
    the code made sense to them, they find it hard to even imagine that the code might
    not work. The second problem is compounded on the first: if you think your code
    is right, testing can only bring you bad news. If you don’t test, you can’t find
    out if the code is wrong. It’s like the old saying about putting your head in
    the sand.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章中，我们提到过你应该测试代码以确保它的正确性。不幸的是，根据我们的经验，初学编程的程序员似乎对测试有一种排斥感！为什么？我们认为有几个原因。第一个原因是存在一个被广泛记录的问题，叫做*超级错误*，即人类在刚开始学习编程时，往往认为计算机能够理解代码的意图并作出相应的反应[1]。因为他们写的代码对他们来说是有意义的，所以他们很难想象代码可能会不工作。第二个问题是对第一个问题的加剧：如果你认为自己的代码是对的，那么测试只会带来坏消息。如果你不测试，就无法发现代码是否有问题。这就像老话说的，把头埋在沙子里。
- en: Professional software engineers take a completely different approach than new
    programmers. They take testing extremely seriously because a mistake in the code
    can have significant consequences for their company. No one wants to be the person
    whose code causes the company to lose tons of revenue, lets hackers gain access
    to confidential user data, or has the self-driving car cause an accident. Given
    the cost of a mistake, it makes more sense to assume the code is wrong until proven
    otherwise. Only after testing it extensively should we trust that it’s working
    correctly. And, companies don’t just test the code once, they keep the tests in
    their system so every time someone changes code, tests are run not just on the
    changed code but also on any code that the changed code might affect (this is
    called regression testing).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 专业的软件工程师采用的测试方法与新手程序员截然不同。他们对待测试非常严谨，因为代码中的一个错误可能会给公司带来重大后果。没有人愿意成为那个让公司失去大量收入、让黑客访问机密用户数据，或者导致自动驾驶汽车发生事故的人。考虑到错误的成本，假设代码是错误的，直到经过验证是正确的，这种做法更为合理。只有在广泛测试之后，我们才会相信它正常工作。而且，公司不仅仅进行一次测试，他们会将测试保存在系统中，这样每次有人更改代码时，测试不仅会在更改的代码上运行，还会在任何可能受更改代码影响的代码上运行（这就是回归测试）。
- en: Companies take this so seriously that they often write their tests *before*
    writing their code in a process called test-driven development (TDD). This ensures
    everyone agrees on what the code should or shouldn’t do. We don’t think you (as
    readers) need to take this approach for the programs you’re writing with this
    book, but we mention it here to convey how crucial it is to test. Thinking about
    testing before writing code can help you understand what the code should do and
    that will help you write better prompts. In fact, you can include test cases directly
    in your prompts!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 公司非常重视这一点，以至于他们经常在编写代码之前就编写测试，这个过程叫做测试驱动开发（TDD）。这确保每个人都同意代码应该做什么或不应该做什么。我们认为，你（作为读者）不需要采用这种方法来编写本书中的程序，但我们在这里提到它是为了传达测试的重要性。在编写代码之前思考测试可以帮助你理解代码应该做什么，从而帮助你编写更好的提示。事实上，你可以直接在提示中包含测试用例！
- en: 'Finally, let’s remember what we know about Copilot: it makes mistakes. We shouldn’t
    assume anything about the correctness of any code given to us by Copilot. All
    this is to say that any code you’re given by Copilot should be tested before you
    trust it.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们记住关于Copilot的事情：它会犯错。我们不应该假设Copilot给我们的任何代码都是正确的。所有这些意味着，你从Copilot那里获得的任何代码都应该在信任它之前进行测试。
- en: 6.2 Closed-box and open-box testing
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 闭盒测试与开盒测试
- en: There are two ways that software engineers commonly test their code. The first
    is called closed-box testing, and this approach assumes you know nothing about
    how the code works. As such, this kind of testing involves varying the inputs
    and observing the outputs. We often see closed-box testing applied to functions
    or entire programs. The advantage of closed-box testing is that you don’t need
    to look at the code to perform the tests and can therefore focus simply on the
    desired behavior.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师通常有两种方式来测试他们的代码。第一种叫做闭盒测试，这种方法假设你对代码的工作原理一无所知。因此，这种测试方法涉及到改变输入并观察输出。我们通常看到闭盒测试应用于函数或整个程序。闭盒测试的优点在于，你不需要查看代码就可以进行测试，因此可以专注于期望的行为。
- en: The second approach to testing is called open-box testing, and in this approach,
    we look at the code to see where the errors might occur. The advantage of open-box
    testing is that by looking at the particular structure of the code, we may see
    where the code is likely to fail and can design additional tests specific to that
    code. We’ll use both closed-box and open-box testing to come up with test cases
    that combine to strengthen our testing. A brief summary of closed-box and open-box
    testing appears in table 6.1\. In this section, let’s look at how we might test
    some functions using these approaches.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种测试方法叫做开盒测试，在这种方法中，我们查看代码，找出可能出错的地方。开盒测试的优势在于，通过查看代码的具体结构，我们可以发现代码可能出错的位置，并为该部分代码设计额外的测试。我们将同时使用闭盒测试和开盒测试，结合这两种方法来强化我们的测试。闭盒测试和开盒测试的简要总结见表6.1。在本节中，让我们看看如何使用这些方法测试一些函数。
- en: Table 6.1 Brief overview of closed-box and open-box testing
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.1 闭盒测试和开盒测试的简要概述
- en: '| Closed-box testing | Open-box testing |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 闭盒测试 | 开盒测试 |'
- en: '| --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Requires understanding the function specification to test  | Requires both
    the function specification and the code that implements the function to test  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 需要理解函数规格才能测试  | 需要理解函数规格和实现该函数的代码才能测试  |'
- en: '| Tests don’t require an understanding of what the code does.  | Tests should
    be tailored based on how the code was written.  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 测试不需要理解代码的功能。  | 测试应该根据代码的编写方式量身定制。 |'
- en: '| Testers need not have technical expertise about the code they’re testing.  |
    Testers need to be able to understand the code sufficiently well to determine
    which tests may be more important.  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 测试人员不需要具备关于他们测试的代码的技术专长。  | 测试人员需要能够理解代码，以便确定哪些测试可能更为重要。 |'
- en: '| Tests the function by varying inputs and checking against expected results  |
    Can test the function in the same way as closed-box testing but can also have
    more granular tests within a function  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 通过改变输入并检查预期结果来测试函数  | 可以像封闭盒测试一样测试函数，但也可以在函数内进行更细粒度的测试 |'
- en: 6.2.1 Closed-box testing
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 封闭盒测试
- en: Let’s imagine we’re trying to test a function that takes in a list of words
    (strings) and returns the longest word. To be more precise, the function signature
    would be
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正尝试测试一个接受单词列表（字符串）并返回最长单词的函数。更准确地说，函数签名应该是
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The expected input is a list of words. The expected output is the word in that
    list with the most characters. In the event that multiple words are tied for the
    most characters, it should return the first word of that length.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 期望的输入是一个单词列表。期望的输出是该列表中字符数最多的单词。如果多个单词字符数相同，则应返回第一个该长度的单词。
- en: Shorthand for expressing test cases
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表达测试用例的简写
- en: When writing tests for a function, the standard format is to write the function
    name and its input along with the desired outcome. For example, the call
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编写函数测试时，标准格式是写出函数名称及其输入和期望的结果。例如，调用
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: means that if we call the function `longest_word` with the input list `['a',`
    `'bb',` `'ccc']`, then the value returned from the function should be `'ccc'`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们用输入列表`['a', 'bb', 'ccc']`调用`longest_word`函数，那么该函数返回的值应该是`'ccc'`。
- en: 'There are two categories for which we typically think about writing test cases:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们考虑编写测试用例的分类有两种：
- en: '*Common use cases—*These cases include some standard inputs you could imagine
    the function receiving and the corresponding result.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*常见用例—*这些案例包括一些你可以想象函数接收到的标准输入以及相应的结果。'
- en: '***Edge cases—*These cases are uncommon but possible cases that might break
    the code. These are inputs that might test some of the rules for the function
    in more depth or contain unexpected inputs (e.g., a list with all empty strings).**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***边缘案例—*这些案例是不常见的，但可能会破坏代码的情况。这些输入可能会更深入地测试函数的一些规则，或者包含意外输入（例如，包含所有空字符串的列表）。**'
- en: '**Looking back at our `longest_word` function signature in the previous example,
    let’s think about some test cases we might use to test it. Later in the chapter,
    we’ll see how to actually run these test cases to determine whether our code is
    working correctly. Let’s start with *common use cases*. We would likely want to
    include a test with just a few words where one word is longer than the others:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**回顾我们在前一个示例中的`longest_word`函数签名，让我们思考一些我们可能会用来测试它的测试用例。在本章稍后，我们将看到如何实际运行这些测试用例，以判断我们的代码是否正常工作。让我们从*常见用例*开始。我们很可能想包括一个测试，测试几个单词，其中有一个单词比其他单词长：**'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s another test with more words with the longest word appearing elsewhere
    in the list:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个测试，包含更多的单词，且列表中的最长单词出现在其他位置：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And last, let’s have a test with just one word:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来一个只有一个单词的测试：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the program is working for these common uses, our next step would be to think
    about some *edge cases.* Let’s consider some edge cases.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序能够处理这些常见的用例，我们的下一步就是考虑一些*边缘案例*。让我们来考虑一些边缘案例。
- en: 'Say we want to check whether the function conforms to our description by returning
    the first word when there are multiple words of the same length. This test may
    be considered a common case or an edge case, depending on whom you ask:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想检查函数是否符合我们的描述，当有多个相同长度的单词时，返回第一个单词。这个测试可能被视为常见案例或边缘案例，取决于你问谁：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What do we do if all the words in the list have no characters? A string with
    no characters is called an *empty string* and is written as just an empty pair
    of quotes. If all we have is a list of empty strings, then the longest word is
    just the empty string! So, a test with all empty strings should just give us back
    an empty string:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表中的所有单词都没有字符，我们该怎么办？一个没有字符的字符串被称为*空字符串*，写作一个空的引号对。如果我们只有一个空字符串的列表，那么最长的单词就是空字符串！因此，包含所有空字符串的测试应该只会返回一个空字符串：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The term *edge case* comes from the fact that errors often happen at the “edge”
    of execution, meaning either the first or last element. In many loops, mistakes
    can be made when the loop is starting (e.g., forgetting or mishandling the first
    element in the list) or at the end (e.g., forgetting the last element or going
    past the end of the list and trying to access an element that doesn’t exist).
    Especially when the code is likely to have loops processing many elements, you’ll
    want to watch the behavior at the start and end of the loop.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*边缘情况*这个术语来源于这样一个事实：错误通常发生在执行的“边缘”，即第一个或最后一个元素。在许多循环中，错误可能发生在循环开始时（例如，忘记或错误处理列表中的第一个元素）或在结束时（例如，忘记最后一个元素或超出列表的末尾，尝试访问一个不存在的元素）。特别是当代码可能有循环处理多个元素时，你需要注意循环开始和结束时的行为。'
- en: Incorrect input testing
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 错误输入测试
- en: Another category of tests will test the function on how it responds when given
    incorrect input. We won’t talk about this much in our book because we’re assuming
    you’re correctly calling your own functions, but in production code, this kind
    of testing can be common. A few examples of calling this function with incorrect
    inputs might be to give the function a nonexisting list by using the value `None`
    instead of an actual list (e.g., `longest_word(None)`), to give the function an
    empty list (e.g., `longest_word([])`), to give the function a list with integers
    as input (e.g., `longest_word` `([1,2])`), or to provide a list of strings but
    have the strings contain spaces or more than single words (e.g., `longest_word(['hi`
    `there',` `'` `my` `',` `'friend'])`). It’s hard to say what the function should
    do when given incorrect input, and programmers need to decide whether they care
    about this in larger code bases, but we’ll ignore this category of tests in this
    book because we’ll assume you’ll call your own functions in ways that the functions
    are designed to handle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类测试将测试函数在接收到不正确输入时的响应。我们在本书中不会深入讨论这一点，因为我们假设你会正确调用自己的函数，但在生产代码中，这种测试可能很常见。一些调用函数时传递不正确输入的例子可能是通过使用`None`而不是实际列表来传递一个不存在的列表（例如，`longest_word(None)`），给函数一个空列表（例如，`longest_word([])`），给函数传递一个包含整数的列表作为输入（例如，`longest_word([1,2])`），或者提供一个包含字符串的列表，但字符串中含有空格或多个单词（例如，`longest_word(['hi
    there', 'my', 'friend'])`）。很难说当函数接收到不正确的输入时应该做什么，程序员需要决定他们是否关心这一点，但我们在本书中忽略了这一类测试，因为我们假设你会以函数设计所能处理的方式来调用你的函数。
- en: 6.2.2 How do we know which test cases to use?
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 我们怎么知道应该使用哪些测试用例？
- en: In chapter 3, we discussed that good testing involves capturing different categories
    of function calls. One way to find these categories is by using the types of parameters
    and varying their values.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章中，我们讨论了好的测试涉及捕获不同类别的函数调用。找到这些类别的一种方法是通过使用参数类型并改变它们的值。
- en: For example, if the function takes a string or list as a parameter, it may make
    sense to test the case when that string or list is empty, has one element, and
    has multiple elements. If we’re trying to test multiple elements, we might use
    four elements, for example. It likely also wouldn’t make sense to test with five
    or six elements or more because if our code works with four elements, it’s unlikely
    that something could suddenly go wrong when we increase to five. Sometimes, some
    of these test cases may not make sense for a given function; for example, it wouldn’t
    make sense to ask for the longest word in a list that didn’t have any words in
    it, so we wouldn’t test the empty list for our `longest_word` function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果函数接受字符串或列表作为参数，那么测试该字符串或列表为空、只有一个元素或有多个元素的情况可能是合理的。如果我们要测试多个元素的情况，可能会使用四个元素。例如，使用五个或六个元素可能没有意义，因为如果我们的代码能处理四个元素，那么在增加到五个时，不太可能突然出错。有时，某些测试用例对于特定函数可能没有意义；例如，要求从一个没有任何单词的列表中找出最长的单词就没有意义，因此我们不会为`longest_word`函数测试空列表。
- en: As another example, if a function takes two numbers as parameters, it may make
    sense to test when one number is zero, both numbers are zero, one number is negative,
    both numbers are negative, and both numbers are positive.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，如果一个函数接受两个数字作为参数，那么当一个数字为零、两个数字都为零、一个数字为负数、两个数字都为负数以及两个数字都为正数时，测试是有意义的。
- en: Another way to find categories is to think about the specific task of the function.
    For example, for our `longest_word` function, it’s supposed to be finding the
    longest word, so we should test that it’s actually doing that in a typical case.
    And, if multiple words are the longest, it’s supposed to return the first of those,
    so we should have a test case where the list has multiple words that are the longest.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 找到类别的另一种方法是考虑函数的具体任务。例如，对于我们的`longest_word`函数，它应该是找出最长的单词，所以我们应该测试它在典型情况下是否真正执行了这个任务。而且，如果多个单词是最长的，它应该返回第一个这些单词，所以我们应该有一个测试用例，其中列表中有多个最长的单词。
- en: Finding the categories to test is a mix of science and art. We’ve given you
    some rules of thumb here, but what counts as useful test cases often depends on
    the specific functionality being tested. As is so often the case, practicing your
    testing skill is the best way to improve your ability to write useful tests that
    ultimately help you make your code better.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找测试类别是科学与艺术的结合。我们在这里给出了一些经验法则，但什么算是有用的测试用例通常取决于测试的具体功能。正如通常情况一样，练习你的测试技能是提高你编写有用测试的能力的最佳方式，最终有助于你改进代码。
- en: 6.2.3 Open-box testing
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 开盒测试
- en: The big difference between open-box testing and closed-box testing is that open-box
    testing examines the code to see if there are additional kinds of test cases to
    check. In theory, closed-box testing may be sufficient to fully test the function,
    but open-box testing tends to give you more ideas about where the code might be
    failing. Let’s say we asked for Copilot to write our `longest_word` function and
    got back the code shown in the following listing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 开盒测试和闭盒测试之间的最大区别在于，开盒测试会检查代码，以查看是否有其他种类的测试用例需要检查。理论上，闭盒测试可能足以完全测试该函数，但开盒测试通常会给你更多的思路，了解代码可能在哪些地方出错。假设我们要求Copilot编写我们的`longest_word`函数，并且得到了以下列出的代码。
- en: Listing 6.1 Function to find the longest word (incorrect!)
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第6.1号列表 查找最长单词的函数（错误的！）
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 >= is wrong. It should be >.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 `>=`是错的。应该是`>`。'
- en: 'For this example, we intentionally introduced an error in the code to help
    explain the role of open-box testing. Let’s say that when you were thinking through
    your test cases, you forgot to test what happens when there are two words in the
    list of `words` that both have the most characters. Well, reading through this
    code you might spot the following `if` statement:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们故意在代码中引入了一个错误，以帮助解释开盒测试的作用。假设在思考测试用例时，你忘记了测试当`words`列表中有两个单词都拥有最多字符时会发生什么。那么，阅读这段代码时你可能会发现如下的`if`语句：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When reading the `if` statement, you might notice that it’s going to update
    the longest word in the list of words when the length of the most recent element
    is greater than *or equal* to the longest word we’ve seen so far. This is a mistake;
    it should be `>`, not `>=`, but suppose you aren’t sure. This would motivate you
    to write a test case like the one we described previously that has multiple words,
    more than one of which is the longest:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读`if`语句时，你可能会注意到，当最新元素的长度大于*或等于*我们迄今为止见过的最长单词时，它会更新单词列表中的最长单词。这是一个错误；应该是`>`，而不是`>=`，但假设你不确定。这会促使你写一个像我们之前描述的那样的测试用例，其中有多个单词，其中一个或多个是最长的：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This test will fail with the code in listing 6.1 as it would return `'dog'`
    rather than the correct answer of `'cat'`. The test failing is valuable information
    that the code in listing 6.1 is incorrect.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试会在第6.1号列表中的代码中失败，因为它会返回`'dog'`，而不是正确的答案`'cat'`。测试失败是有价值的信息，说明第6.1号列表中的代码是错误的。
- en: As we’ve said, open-box testing is useful because it leads to test cases that
    follow the structure of the code itself. For example, if our code is using a loop,
    we’ll find that loop when doing open-box testing. The loop in listing 6.1 is correct,
    but by seeing the loop in our code, we’ll be reminded to test the edge cases to
    make sure it’s properly handling the first element, the last element, and an empty
    list. In sum, knowing how the code is processing the input often offers insight
    into when the program might be misfunctioning.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，开箱测试很有用，因为它能帮助我们构建符合代码本身结构的测试用例。例如，如果我们的代码使用了一个循环，在进行开箱测试时我们会看到这个循环。列表
    6.1 中的循环是正确的，但通过查看代码中的循环，我们会提醒自己测试边界情况，确保它能够正确处理第一个元素、最后一个元素和空列表。总而言之，了解代码如何处理输入，往往能帮助我们洞察程序可能在哪些情况下出错。
- en: 6.3 How to test your code
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 如何测试你的代码
- en: There are a number of good ways to test your code that vary from quick tests
    you might perform just to check if your code is working for yourself to tests
    that are built into a company’s regression test suite. For production code, Python
    programmers typically use testing tools more powerful and full-featured than what
    we’re about to demonstrate in this chapter. The most common of those tools is
    pytest, which is a module that needs to be installed before it can be used. We
    feel that pytest is beyond what we need here to introduce the core ideas of testing.
    We’ll focus on more lightweight testing to help you gain confidence that the code
    from Copilot works properly. We can do that either by testing at the Python prompt
    or using a built-in Python module called doctest.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多有效的方式来测试你的代码，这些方式从简单的测试开始，可能只是为了检查你的代码是否正常工作，到构建在公司回归测试套件中的测试。对于生产代码，Python
    程序员通常使用比我们在本章展示的更强大、更完整的测试工具。最常见的工具是 pytest，它是一个需要安装才能使用的模块。我们认为 pytest 超出了我们在这里介绍测试核心概念的需求。我们将集中在更轻量级的测试上，以帮助你确保
    Copilot 的代码能够正常工作。我们可以通过在 Python 提示符中测试或使用 Python 内置的模块 doctest 来实现这一点。
- en: 6.3.1 Testing using the Python prompt
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 使用 Python 提示符进行测试
- en: The first way to test is in the Python prompt through the interactive window
    like we have in the previous chapters. The advantage of this testing is that it
    can be quick to run, and you can easily add more tests as a result of output from
    the previous test. The tests we’ve run so far are examples of testing with the
    Python prompt. For example,
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的第一种方式是通过 Python 提示符，在交互窗口中进行，就像我们在之前的章节中所做的那样。这种测试的优点是它运行迅速，而且你可以根据上一个测试的输出轻松地添加更多的测试。到目前为止，我们运行的测试就是通过
    Python 提示符进行的测试。例如，
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In running that test, if you expected the result to be `'cat'`, you’d be pleased
    to see that result. However, if the test shows that your code was wrong, you now
    have the opportunity to go back to fix it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行那个测试时，如果你期望结果是 `'cat'`，你会很高兴看到这个结果。然而，如果测试显示你的代码是错误的，那么你现在有机会回去修正它。
- en: After you fix the code, you’ll want to test the new code. Here is where you
    may go wrong with testing using the Python prompt alone. When you come back to
    test the code you just changed, you might be tempted to run *just* the test case
    that had failed previously. However, in fixing the code to correctly address the
    test case that had failed, you could have introduced an error that would cause
    the *previous* test cases that had already passed to now fail. What you really
    want then is a way to run not just your current test but all previous tests as
    well.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你修复了代码之后，你需要测试新代码。这时候，使用 Python 提示符单独进行测试可能会出错。当你回到刚刚修改过的代码进行测试时，你可能会倾向于仅仅运行之前失败的那个测试用例。然而，在修复代码以正确处理之前失败的测试用例时，你可能引入了一个错误，导致那些已经通过的测试用例现在失败。因此，你真正需要的是一种方法，可以不仅运行当前的测试，还能运行所有之前的测试。
- en: 6.3.2 Testing in your Python file (we won’t be doing it this way)
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 在你的 Python 文件中进行测试（我们不会使用这种方式）
- en: It would be tempting to then put all your test cases in your Python program
    (outside a function, so in the equivalent of a main function) so they can all
    run. This solution addresses the problem with Python prompts that we just described,
    but it introduces a new problem. What happens when you want your Python program
    to perform the main task for which it was designed rather than just run tests?
    You could delete all the tests, but the point was running them again if so desired.
    You could comment them out so you can run them in the future, but that’s not a
    very clean solution either. What we want then is a way to run all our tests on
    our functions when we want to but still have the ability to run the program. The
    way to do this is using a module called doctest.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想将所有测试用例放入你的Python程序中（在函数外部，即在类似主函数的位置），以便它们都能运行。这个解决方案解决了我们刚才描述的Python提示问题，但也引入了一个新问题。当你希望你的Python程序执行其原本设计的主要任务，而不仅仅是运行测试时，会发生什么呢？你可以删除所有测试，但如果希望重新运行它们，那就失去了意义。你也可以将它们注释掉，以便未来可以运行，但这也不是一个很干净的解决方案。那么，我们想要的就是一种方法，能够在需要时运行所有测试，但仍然能够运行程序。做到这一点的方法是使用一个名为doctest的模块。
- en: 6.3.3 doctest
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 doctest
- en: The doctest module is built in to Python. The great thing about using doctest
    is that we simply add our test cases to the docstring that describes the function.
    This beefed-up docstring serves a dual purpose. First, we can use doctest to run
    all those test cases whenever we’d like. Second, it can sometimes help Copilot
    generate better code in the first place or fix already-written code that isn’t
    quite working. Let’s write that `longest_word` function with all the test cases
    included and ready to be executed with doctest (see listing 6.2).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: doctest模块是Python的内置模块。使用doctest的好处在于，我们只需将测试用例添加到描述函数的docstring中。这个增强版的docstring具有双重功能。首先，我们可以随时使用doctest运行所有这些测试用例。其次，它有时能帮助Copilot生成更好的代码，或者修复已经编写但没有完全工作的代码。让我们编写包含所有测试用例并准备好通过doctest执行的`longest_word`函数（见清单6.2）。
- en: Listing 6.2 Using doctest to test the `longest_word` function
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单6.2 使用doctest测试`longest_word`函数
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 Shows the test cases for doctest'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 显示了doctest的测试用例'
- en: '#2 Shows the correct code for the function'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 显示了函数的正确代码'
- en: '#3 Code (in main) that calls doctest to perform the test'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 调用doctest进行测试的代码（在主程序中）'
- en: In this code, we see the docstring with our test cases provided as the prompt
    to Copilot. Copilot generated the correct code to implement this function. We
    then manually wrote the last two lines of the code to perform the testing. When
    run, we get the output in the following listing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们看到docstring中包含了我们提供的测试用例，作为Copilot的提示。Copilot生成了正确的代码来实现这个函数。然后，我们手动编写了最后两行代码来执行测试。运行后，我们得到了如下清单中的输出。
- en: Listing 6.3 Doctest output from running our program in listing 6.2
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单6.3 从运行清单6.2中的程序得到的doctest输出
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#1 First test in longest_word passed'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 longest_word中的第一个测试通过了'
- en: '#2 Second test in longest_word passed'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 longest_word中的第二个测试通过了'
- en: '#3 Third test in longest_word passed'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 longest_word中的第三个测试通过了'
- en: '#4 Fourth test in longest_word passed'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 longest_word中的第四个测试通过了'
- en: '#5 Fifth test in longest_word passed'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 longest_word中的第五个测试通过了'
- en: '#6 There are no tests in main (outside the function).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 主程序中（函数外部）没有测试。'
- en: '#7 longest_word passed all tests.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 longest_word通过了所有测试。'
- en: '#8 0 failed is what you hope to see.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 0失败是你希望看到的结果。'
- en: 'From this output, we can see that each test ran and each test passed. The reason
    these tests ran is because of the last two lines that we added in listing 6.2:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，我们可以看到每个测试都运行并且通过了。之所以这些测试能运行，是因为我们在清单6.2中添加的最后两行代码：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the first line, we import the doctest module. That’s the module that helps
    us test our code by automatically running the test cases when we run our program.
    In the second line, we’re calling the `testmod` function from the doctest module.
    That function call tells doctest to perform all the tests; the argument `verbose=True`
    tells doctest to give us the outcome for all tests, whether they pass or not.
    If we switch to `verbose=False`, it will only give us output if test cases fail
    (`verbose=False` is actually the default, so you can just call the function with
    no arguments, and it will default to not providing output unless one or more tests
    fail). This can be a nice feature as we can keep the doctest running and only
    see the output when tests fail.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们导入了 `doctest` 模块。这个模块帮助我们通过在运行程序时自动运行测试用例来测试代码。在第二行，我们调用了 `doctest` 模块中的
    `testmod` 函数。这个函数调用告诉 `doctest` 执行所有的测试；参数 `verbose=True` 告诉 `doctest` 给出所有测试的结果，无论它们是否通过。如果我们切换为
    `verbose=False`，它只会在测试用例失败时给出输出（`verbose=False` 实际上是默认值，所以你可以在不传递任何参数的情况下调用这个函数，它默认不会提供输出，除非一个或多个测试失败）。这个特性非常有用，因为我们可以让
    `doctest` 继续运行，只有在测试失败时才会看到输出。
- en: In this case, our code passed all the test cases. But let’s experience what
    happens when our code doesn’t pass.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的代码通过了所有测试用例。但是，让我们体验一下当代码未通过时会发生什么。
- en: If we find a word that’s the same length as our current longest word, we should
    ignore it because we always want to return the first longest word if there are
    multiple words tied for the longest. That’s why the correct thing to do is to
    use `>` in the `if` statement (finding a new longest word only if it’s truly longer
    than our current longest word) rather than `>=`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现一个单词与当前最长的单词长度相同，我们应该忽略它，因为当有多个单词的长度相同且为最长时，我们始终希望返回第一个最长的单词。因此，正确的做法是使用
    `>` 在 `if` 语句中（只有当找到的新单词确实比当前最长的单词长时才会更新最长单词），而不是 `>=`。
- en: We can break the code in listing 6.2 then by changing the `>` to `>=`, which
    will cause it to select the last word of the longest length rather than the first.
    Let’s change the following line from
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `>` 改为 `>=` 来破坏清单 6.2 中的代码，这会导致它选择最长长度单词中的最后一个，而不是第一个。让我们将以下行改为：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: to
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 改为：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, the tests shouldn’t all pass. In addition, let’s change the last line to
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试不应该全部通过。另外，让我们把最后一行改为：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By providing no arguments to the `testmod` function, `verbose` is now set to
    `False`. When we run the code, this is the output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不给 `testmod` 函数传递任何参数，`verbose` 现在被设置为 `False`。当我们运行代码时，输出如下：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Doctest conveniently tells us which test was run, what the expected output was,
    and what the function produced instead. This would catch the bug and allow us
    to go back to fix the error.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest` 方便地告诉我们运行了哪些测试、期望的输出是什么，以及函数实际输出了什么。这可以帮助我们捕捉到错误，并返回修复它。'
- en: Test cases aren’t automatically run by Copilot
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Copilot 不会自动运行测试用例。
- en: 'We commonly hear the following question: Why doesn’t Copilot directly incorporate
    the test cases when generating code? For example, if we add test cases, it would
    be nice if Copilot could try to generate functions and only provide us with the
    code that would pass those test cases. Unfortunately, there are some technical
    challenges in doing this, and as of the time of writing, this feature isn’t yet
    included. So, if you add test cases, it just improves the prompt to Copilot but
    doesn’t guarantee that the Copilot code suggestion passes those tests.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常听到这样的问题：为什么 Copilot 在生成代码时不直接结合测试用例？例如，如果我们添加了测试用例，希望 Copilot 能尝试生成函数，并仅提供能够通过这些测试用例的代码。遗憾的是，这样做存在一些技术挑战，截至本文写作时，这个功能尚未包含在内。所以，如果你添加了测试用例，它只会改进对
    Copilot 的提示，但不能保证 Copilot 生成的代码能通过这些测试。
- en: At this point, we’ve seen how to run our tests with both the Python prompt and
    doctest. Now that we know how to test our code, let’s think about how this modifies
    our code design cycle.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到如何通过 Python 提示和 `doctest` 运行测试。现在我们知道如何测试我们的代码了，让我们思考一下这将如何改变我们的代码设计周期。
- en: 6.4 Revisiting the cycle of designing functions with Copilot
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 再次审视与 Copilot 一起设计函数的周期
- en: In chapter 3, we gave you an early version of how to design functions in figure
    3.3\. At that point, we didn’t know as much about examining our code (which we
    learned in chapters 4 and 5) or as much about how to test our code as we do now.
    As such, let’s create a new version of this cycle (figure 6.1) to reflect our
    new understanding.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章中，我们给出了函数设计的早期版本（见图 3.3）。当时，我们并不像现在这样了解如何检查我们的代码（这一点我们在第 4 和第 5 章学到了），也不太清楚如何测试代码。因此，让我们创建这个周期的新版本（图
    6.1），以反映我们新的理解。
- en: '![figure](../Images/6-1.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/6-1.png)'
- en: Figure 6.1 The function design cycle with Copilot, augmented to include more
    about testing
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1 使用 Copilot 的函数设计周期，增加了更多关于测试的内容
- en: 'The figure is a bit more complex than before, but if we examine it closely,
    we can see much of the original process is retained. The things that have been
    added or changed include the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图比之前稍微复杂一些，但如果我们仔细查看，可以看到大部分原始过程都被保留了。新增或更改的内容包括以下几点：
- en: When we write the prompt, we may include doctests as part of that initial prompt
    to help Copilot in generating the code.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写提示时，我们可以将 doctests 作为初步提示的一部分，帮助 Copilot 生成代码。
- en: Having made our way through chapters 4 and 5, we’re in good shape to read the
    code to see whether it behaves properly, so we now have an additional step to
    address what happens when the initial code from Copilot looks wrong. If that occurs,
    we’ll use Ctrl-Enter to explore the Copilot suggestions to hopefully find a solution.
    If we can find such a solution, we’ll select it and move forward. If we can’t,
    we’ll need to revise our prompt to help Copilot generate improved suggestions.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在完成了第 4 和第 5 章的内容后，我们已经具备了良好的能力，能够检查代码是否正常运行，因此现在我们增加了一步来处理当 Copilot 提供的初始代码看起来不对时该怎么办。如果发生这种情况，我们将使用
    Ctrl-Enter 来查看 Copilot 的建议，希望能找到解决方案。如果我们找到了这样的解决方案，我们将选择它并继续前进。如果没有找到，我们需要修改我们的提示，以帮助
    Copilot 生成更好的建议。
- en: After finding code that looks like it could be correct, we’ll run doctest to
    see whether the code passes the doctests we included in the prompt (if we didn’t
    include any, it will pass automatically). If doctest passes, then we can continue
    adding tests and checking them until we’re happy that the code is functioning
    properly. If doctest fails, we’ll need to figure out how to modify the prompt
    to address the failed tests. Once the prompt is modified, it will hopefully help
    Copilot generate new code that may be capable of passing the tests that we’ve
    provided.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在找到看起来正确的代码后，我们将运行 doctest，查看代码是否通过了我们在提示中包含的 doctests（如果我们没有包含任何，它会自动通过）。如果
    doctest 通过，我们可以继续添加测试并检查，直到我们满意代码正常运行。如果 doctest 失败，我们需要弄清楚如何修改提示，以解决失败的测试。一旦提示被修改，希望它能够帮助
    Copilot 生成新的代码，从而通过我们提供的测试。
- en: With this new workflow, we’re in a much better position not only to determine
    whether our code is working properly but also to fix the code if it isn’t already
    working. In the next chapters, we’ll give ourselves even more tools to help when
    the code isn’t working properly, but for now, let’s put this all together by solving
    a new problem and testing the Copilot solutions using the workflow we described
    here.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个新的工作流程，我们不仅能更好地判断代码是否正常工作，还能在代码没有正常工作的情况下修复它。在接下来的章节中，我们将为自己提供更多的工具，以便在代码没有正常工作时提供帮助，但现在，让我们通过解决一个新问题并使用我们在这里描述的工作流程来测试
    Copilot 提供的解决方案，将这些内容整合起来。
- en: 6.5 Full testing example
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 完整的测试示例
- en: Let’s try a problem that we might need to solve to help students decide where
    to sit in in-person classes. Although we’re talking about finding empty seats
    in a classroom, this problem is the same as trying to find the number of empty
    seats in a concert hall, theater, movie theater, or office layout.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个问题，帮助学生决定在面对面课堂上应该坐哪里。虽然我们讨论的是在教室中找到空座位，但这个问题与在音乐会大厅、剧院、电影院或办公室布局中寻找空座位的问题是相同的。
- en: Suppose we have the classroom layout as a two-dimensional list with rows of
    seats. Each seat either contains a space (`'` `'`) or a student (`'S'`) to represent
    an empty or occupied seat, respectively. We’re going to ask Copilot to create
    a function to determine which row we could add the most students to, and along
    the way, we’ll design the tests needed to check whether the code is working properly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个教室布局，表示为一个包含座位排的二维列表。每个座位要么为空格（`'` `'`），要么是一个学生（`'S'`），分别表示空座位或已占用座位。我们将要求
    Copilot 创建一个函数，确定我们可以在哪一排添加最多学生，同时在此过程中，我们还将设计测试，以检查代码是否正常工作。
- en: 6.5.1 Finding the most students we can add to a row
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 找到我们能在一排中增加的最多学生数
- en: We want to figure out the largest number of new students we could add in a single
    row in the classroom. (Equivalently, we’re looking for the largest number of empty
    seats in any row.) For this, let’s start with a somewhat ambiguous prompt and
    see how well Copilot does.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想弄清楚我们能在教室的一排中最多增加多少新学生。（等价地，我们在找出任意一排中空座位最多的数量。）为此，让我们从一个有些模糊的提示开始，看看 Copilot
    的表现如何。
- en: Listing 6.4 Largest number of students we can add to a row
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.4 我们能在一排中增加的最大学生数
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '#1 This is a somewhat ambiguous part of the prompt.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这是提示中一个有些模糊的部分。'
- en: 'For the sake of this example, our prompt wasn’t very good. “How many new students
    can sit in a row?” is a reasonable starting point to give to a human, but it’s
    not that specific, and it’s easy to imagine Copilot struggling to interpret what
    we mean. Copilot might get confused about whether we’re counting the number of
    students or the number of empty seats in a row, or it might return the total number
    of available seats in the classroom rather than in a row. It turns out that our
    prompt confused Copilot, and the code isn’t correct, but before we dive into the
    code, let’s think about what tests we should run. We’ve come up with the following
    set of test cases:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个例子，我们的提示语不太好。“一排可以坐多少新学生？”是给人类的合理起点，但它不够具体，很容易想象 Copilot 在解读我们意思时会感到困惑。Copilot
    可能会搞不清楚我们是要计算学生人数还是每排的空座位数量，或者它可能会返回整个教室的空座位总数，而不是某一排的空座位数。事实证明，我们的提示语确实让 Copilot
    感到困惑，代码也不正确，但在我们深入代码之前，让我们先考虑应该运行哪些测试用例。我们提出了以下一组测试用例：
- en: A classroom with some number of consecutive empty seats and some number of nonconsecutive
    empty seats to make sure it isn’t just counting consecutive empty seats
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个教室，有一些连续的空座位和一些不连续的空座位，确保它不仅仅是在计算连续空座位的数量
- en: A classroom with no empty seats to make sure it returns 0 in that case
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个没有空座位的教室，确保在这种情况下返回 0
- en: A classroom with a row full of empty seats to make sure all are counted, including
    the first and last seats (edge case)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个教室中有一排空座位，确保所有座位都被计算在内，包括第一和最后一个座位（边缘情况）
- en: A classroom with multiple rows with the same number of empty seats to make sure
    it returns just one of those values (and not, perhaps, the sum of the number of
    empty seats across all of these rows)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个教室有多排空座位相同数量的座位，确保它只返回其中一个值（而不是可能返回所有这些排的空座位总和）
- en: Let’s start by adding the first test case and adding the doctest code to run
    the test, as shown in the following listing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加第一个测试用例，并添加 doctest 代码来运行该测试，如下所示。
- en: Listing 6.5 Largest number of students we can add to a row
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5 我们能在一排中增加的最大学生数
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 Doctest for a common case. The \ is necessary in docstring test cases if
    you need to do a newline.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 常见情况的 doctest。如果需要换行，docstring 测试用例中必须使用 \。'
- en: 'When we run this code, we get this output (we cleaned up the formatting of
    the classroom list manually to help with the readability of the answer):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们得到了这个输出（我们手动清理了教室座位列表的格式，以便于答案的可读性）：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Although we’d prefer the code to work, we appreciate that the first test case
    found an error. The row with the most empty seats is the third row with four seats
    available. But the code from Copilot is incorrectly telling us the answer is six.
    That’s pretty odd. Even without reading the code, you might hypothesize that it’s
    counting either the number of seats per row or the maximum number of students
    seated per row. Our test case had a full row of students in the second row, so
    it’s hard to tell. What we can do is change the classroom to be
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们希望代码能够正常工作，但我们很感激第一个测试用例找到了一个错误。空座位最多的排是第三排，有四个空座位。但 Copilot 提供的代码错误地告诉我们答案是六。这个问题很奇怪。即使不读代码，你也可以推测它可能是在计算每排座位数，或者每排可坐的最大学生数。我们的测试用例中第二排已经坐满了学生，因此很难判断。我们能做的是将教室设置为：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '#1 We removed the first student from the second row.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们从第二排删除了第一个学生。'
- en: So, the second row now has five students. When we run the code again, the test
    again fails with the code giving us an answer of five. It seems that the code
    isn’t just telling us the number of seats per row. It must be doing something
    related to where students are sitting. Our next step is to improve the prompt
    and determine whether we can get better code from Copilot, but for completeness,
    let’s first explain what the code was really doing in the following listing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第二行现在有五个学生。当我们再次运行代码时，测试又失败了，代码给出的答案是五。看起来这段代码不仅仅告诉我们每行的座位数。它一定是在做一些与学生座位相关的事情。我们的下一步是改进提示词，看看是否能从
    Copilot 得到更好的代码，但为了完整性，首先让我们解释一下代码在下面的列表中真正的操作。
- en: Listing 6.6 Walkthrough of the incorrect code from Copilot
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6 Copilot 错误代码的详细解析
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Starts with the max_students initialized to 0'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从将 max_students 初始化为 0 开始'
- en: '#2 For each row in the classroom'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 对于课堂中的每一行'
- en: '#3 Initializes the student counter to 0 for this row'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 为这一行初始化学生计数器为 0'
- en: '#4 For each seat in the row'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 对每个座位进行处理'
- en: '#5 If there is a student in the seat, increment the counter.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 如果座位上有学生，递增计数器。'
- en: '#6 If there is an empty seat, reset the counter.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 如果有空座位，重置计数器。'
- en: '#7 Checks to see if the student counter is bigger than seen before and, if
    so, makes that the new maximum seen before'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 检查学生计数器是否大于之前看到的最大值，如果是，则更新最大值。'
- en: You can see from the code description what is happening per line, but at a high
    level, this code is counting the number of consecutive students in each row. It
    does this by initializing a counter to 0 for each row and then incrementing that
    counter as long as it keeps seeing a student in a seat. It also resets the counter
    as soon as it sees an empty seat. The `if` statement at the end of the inner loop
    is a pretty standard way of keeping track of the largest of something seen before,
    and in this case, it’s keeping track of the largest number of consecutive students
    seen. That’s not at all what we wanted, and our poor prompt is partially to blame.
    The key piece, though, is that our test lets us know the code is incorrect. (If
    you spotted the error yourself in reading the code, that’s great too!)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码描述中可以看到每行的操作，但是从宏观上看，这段代码是在统计每行中连续坐着的学生人数。它通过为每行初始化一个计数器为 0，然后在每次看到一个学生坐下时递增计数器。当它看到空座位时，计数器会被重置。内循环结尾的`if`语句是一个相当标准的方式，用于跟踪之前看到的最大值，在这里，它是跟踪最大连续学生数。这完全不是我们想要的，而我们可怜的提示词部分也得为此负责。然而，关键的一点是，我们的测试让我们知道代码是不正确的。（如果你在阅读代码时自己发现了错误，那也很好！）
- en: 6.5.2 Improving the prompt to find a better solution
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 改进提示词以寻找更好的解决方案
- en: Let’s rewrite the prompt, keep the test case, and see whether we can do better
    in the following listing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写提示词，保留测试用例，看看是否能得到更好的结果，见下面的列表。
- en: Listing 6.7 Trying again to find the largest number of students
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.7 再次尝试找出最多的学生人数
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 The improved prompt says we specifically want the maximum number of '' ''
    characters in any given row.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 改进后的提示词明确要求我们在任何给定的行中寻找最多的 `'' ''` 字符。'
- en: '#2 count is a list function that returns the number of the argument in the
    list.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 count 是一个列表函数，返回列表中某个参数出现的次数。'
- en: '#3 Code to keep track of maximum seats'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 用于跟踪最大座位数的代码'
- en: To get this solution, we had to look through the possible Copilot solutions
    using Ctrl-Enter. Some of the solutions now counted the consecutive occurrences
    of `'` `'`, whereas others, like the one in listing 6.7, passed the doctest. Oddly,
    the first time we tried the improved prompt, the suggested solution was correct.
    This is another reminder of why nondeterminism in the Copilot output makes testing
    so important.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到这个解决方案，我们必须通过 Ctrl-Enter 查找 Copilot 的可能解决方案。现在一些解决方案计算了连续出现的 `' '`，而其他的，如
    6.7 列表中的那个，成功通过了 doctest。奇怪的是，当我们第一次尝试改进后的提示词时，推荐的解决方案是正确的。这又提醒我们，Copilot 输出的非确定性使得测试变得如此重要。
- en: Let’s take a minute and look at what made this second prompt better than the
    first. Both prompts had
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间看看是什么让第二个提示词比第一个更好。两个提示词都包含了
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The part of the prompt that led to us receiving the wrong answer was
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 提示词中导致我们收到错误答案的部分是
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The part of the prompt that yielded a correct answer was
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 提示词中得出正确答案的部分是
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can never really know why a large language model (LLM) like Copilot produces
    the answer it does, but let’s remember that it’s trained to just make predictions
    of next words based on the words it’s been given and words that were in its training
    data (i.e., lots of code in GitHub).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远无法真正知道像Copilot这样的大型语言模型（LLM）为什么会给出它的答案，但我们要记住，它是通过基于给定的单词和训练数据中出现过的单词来做出下一个单词的预测（即，GitHub上的大量代码）。
- en: The first prompt asks Copilot to make some inferences, some of which it does
    well, and some not so well. The prompt, in a sense, is asking Copilot to know
    what a row is in a list of lists. Thankfully, that’s really common in programming,
    so it had no problem there.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个提示要求Copilot做出一些推理，有些推理它做得很好，有些则不太好。从某种意义上说，提示是在让Copilot知道在一个列表的列表中，什么是“行”。幸运的是，这在编程中非常常见，因此它在这里没有问题。
- en: Then, the prompt asks Copilot to make the basic logical step of inferring that
    an empty seat is where a *new* student could sit. Here is where Copilot struggled.
    We suspect that because we’re asking about new students sitting in a row, it wasn’t
    able to make the jump to realize that “new” students would require figuring out
    how many students you can *add* or, in other words, how many empty seats there
    are. Instead, Copilot focused on the “students °.°.°. in a row” part of the prompt
    and started counting students in each row. It could have also used the function
    name (which, admittedly, could be better; i.e., `max_empty_seats_per_row`) to
    think it needs to count the maximum number of students. That’s not what we want,
    but we can understand how Copilot makes this mistake.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，提示要求Copilot做出一个基本的逻辑推理，即推断空座位是一个*新*学生可以坐的位置。这里是Copilot遇到困难的地方。我们怀疑是因为我们在询问新学生坐在哪一排时，Copilot没有能够做出推理，意识到“新”学生需要弄清楚你能*添加*多少学生，换句话说，就是有多少个空座位。相反，Copilot专注于提示中的“学生
    °.°.°. 在一排”部分，并开始计算每一排中的学生。它本来也可以利用函数名（说实话，函数名本可以更好，例如`max_empty_seats_per_row`）来思考它需要计算最多的学生数。那并不是我们想要的，但我们能理解Copilot为什么会犯这个错误。
- en: Now let’s talk about why, in response to our vague first prompt, Copilot decided
    to count *consecutive* students in a given row. Maybe counting consecutive students
    is a more common pattern in Copilot’s training data. Maybe it’s because “sit in
    a row” could be interpreted as “sit consecutively.” Or maybe it’s because when
    we were coding this example, we’d been working on another version of the problem
    that asked for consecutive empty seats, and Copilot remembered that conversation.
    We don’t know why Copilot gave us this answer, but we know that our prompt was
    too vague.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来谈谈为什么在面对我们模糊的第一个提示时，Copilot决定计算某一行中*连续*的学生人数。也许计算连续学生是Copilot训练数据中更常见的模式。也可能是因为“坐在一排”可以解释为“坐得连续”。或者也许是因为当我们编写这个示例时，我们正在处理另一个版本的问题，该问题要求计算连续的空座位，而Copilot记住了那次对话。我们不知道Copilot为什么给出这个答案，但我们知道我们的提示太模糊了。
- en: In contrast, our second prompt was more specific in a few ways. First, it clearly
    asks for the maximum. Second, it asks for the number of spaces, or empty seats,
    in a row. That takes away the need for Copilot to infer that an empty seat means
    a spot for a new student. We also used “total” and “given row” to try to get Copilot
    out of its current approach to counting consecutive values, but that didn’t quite
    do the trick. Consequently, we ended up having to sift through Copilot answers
    (using Ctrl-Enter) that were sometimes looking for consecutive empty seats and
    sometimes finding the count of empty seats.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们的第二个提示在几个方面更加具体。首先，它明确要求最大值。其次，它要求计算一排中的空格或空座位的数量。这消除了Copilot推断空座位意味着为新学生留位置的需求。我们还使用了“总计”和“给定行”来试图让Copilot摆脱它当前的连续值计数方法，但这并没有完全解决问题。因此，我们最终不得不筛选Copilot的回答（使用Ctrl-Enter），这些回答有时在寻找连续的空座位，有时则是在寻找空座位的数量。
- en: 6.5.3 Testing the new solution
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.3 测试新解决方案
- en: 'Returning to our example, because the new code passes the current test, let’s
    give it more tests to ensure that it’s behaving correctly. In the next test, we’ll
    check that the code properly returns 0 when there are no empty seats in any rows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的示例，由于新代码通过了当前的测试，让我们再给它做更多的测试，以确保它的行为是正确的。在下一个测试中，我们将检查当任何行中没有空座位时，代码是否能正确返回0：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next test will ensure that the code properly counts all three empty seats
    in a single row (here, the second row) so there isn’t an edge case problem (e.g.,
    it fails to count the first or last element). Admittedly, looking at the code,
    we can see the `count` function is being used, and because that function is built
    in to Python, we should be fairly confident this test will pass. However, it’s
    still safer to test it to make sure:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试将确保代码正确地计算出单行中的所有三个空座位（这里是第二行），以避免出现边缘情况问题（例如，未能计算第一个或最后一个元素）。诚然，从代码中可以看出，`count`
    函数正在被使用，并且由于该函数是Python内置的，我们应该相当有信心这个测试会通过。然而，还是更安全进行测试，以确保：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last test checks to see that Copilot properly handles the case that two
    rows have the same number of empty seats:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个测试检查 Copilot 是否正确处理两个行中空座位数量相同的情况：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After adding these test cases, we again ran the full program, shown in the following
    listing, and all test cases passed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了这些测试用例后，我们再次运行了完整程序，如下所示，所有测试用例都通过了。
- en: Listing 6.8 Full code and doctests for largest number of students
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.8 最大学生人数的完整代码和文档测试
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, we saw how to write a function to solve a problem from start
    to finish. Copilot gave us the wrong answer, partially because of a difficult-to-interpret
    prompt. We figured out that it gave us the wrong answer because the code failed
    on our first test. We then improved the prompt and used the code reading skills
    we learned in the previous two chapters to pick out a solution that looked correct
    for our needs. The new code passed our initial basic test, so we added more test
    cases to see whether the code worked in more situations. After seeing it pass
    those additional tests, we have more evidence that the code is correct. At this
    point, we’ve tested the common cases and edge cases, so we’re highly confident
    that our current code is correct. Regarding testing, this example showed us how
    tests can help us find mistakes *and* give us more confidence that the code will
    function properly.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们演示了如何编写一个函数来从头到尾解决一个问题。Copilot 给出了错误的答案，部分原因是提示语难以理解。我们发现它给出错误答案是因为代码在我们的第一个测试中失败了。然后，我们改进了提示，并利用前两章学到的代码阅读技巧挑选出一个看起来适合我们需求的解决方案。新代码通过了我们最初的基本测试，因此我们添加了更多的测试用例，以验证代码在更多情况下是否有效。在看到它通过这些额外的测试后，我们有了更多证据证明代码是正确的。此时，我们已经测试了常见情况和边缘情况，因此我们对当前的代码非常有信心。关于测试，这个例子展示了测试如何帮助我们发现错误*并*增强我们对代码功能正确性的信心。
- en: '6.6 Another full testing example: Testing with files'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 另一个完整的测试示例：文件测试
- en: In most cases, you’ll be able to test your code by adding examples to the docstring
    like we did in the previous example. However, there are times when testing can
    be a bit more challenging. This is true when you need to test your code against
    some kind of external input. An example is when we need to test code that interacts
    with external websites, but this is more common in advanced code than the kind
    of code you’ll be creating within the scope of this book.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您可以像我们在前面的示例中一样，通过向文档字符串中添加示例来测试代码。然而，有时测试可能会变得更加具有挑战性。当您需要测试与某种外部输入交互的代码时，就会出现这种情况。一个例子是当我们需要测试与外部网站交互的代码，但这种情况在高级代码中更常见，而不是本书范围内的代码。
- en: An example that *is* within the scope of this book is working with files. How
    do you write test cases when your input is a file? Python does support doing this
    in a way internal to the docstring here, but for continuity with what we’ve already
    done, we’re not going to do it that way. Instead, we’ll use external files to
    test our code. Let’s see how to do that by revising our NFL quarterback (QB) example
    from chapter 2.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本书范围内的一个示例是处理文件。当输入是文件时，如何编写测试用例？Python 确实支持在文档字符串内部进行此类操作，但为了保持与我们已做内容的一致性，我们将不采用这种方式。相反，我们将使用外部文件来测试我们的代码。让我们通过修改第二章中的
    NFL 四分卫（QB）示例来看如何做到这一点。
- en: We could walk through an example with the entire file, but because our queries
    about quarterbacks were only for the first nine columns of the file, we’re going
    to strip off the remaining columns of the file to make things more readable. After
    stripping off the remaining columns, table 6.2 shows the first four rows of the
    file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用整个文件走一遍示例，但因为我们查询四分卫的信息仅限于文件的前九列，所以我们将去掉文件中其余的列，以使内容更易读。去除剩余列后，表6.2展示了文件的前四行。
- en: Table 6.2 The first four lines of an abridged version of the NFL dataset
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.2 NFL数据集简化版的前四行
- en: '| game_id | player_id | position | player | team | pass_cmp | pass_att | pass_yds
    | pass_td |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| game_id | player_id | position | player | team | pass_cmp | pass_att | pass_yds
    | pass_td |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 18  | 30  | 203  |
    1  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 18  | 30  | 203  |
    1  |'
- en: '| 201909050chi  | JoneAa00  | RB  | Aaron Jones  | GNB  | 0  | 0  | 0  | 0  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 201909050chi  | JoneAa00  | RB  | Aaron Jones  | GNB  | 0  | 0  | 0  | 0  |'
- en: '| 201909050chi  | ValdMa00  | WR  | Marquez Valdes-Scantling  | GNB  | 0  |
    0  | 0  | 0  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 201909050chi  | ValdMa00  | WR  | Marquez Valdes-Scantling  | GNB  | 0  |
    0  | 0  | 0  |'
- en: We’ll assume that each row in the dataset has just these nine columns for the
    remainder of the example, but we hope it’s not a big stretch to imagine how to
    do this for the full dataset (you’d just need to add all the additional columns
    in each case).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设在接下来的例子中，数据集的每一行仅包含这九列，但我们希望你能理解如何处理完整数据集（你只需要在每种情况下添加所有其他列）。
- en: 'Suppose we want to make a function that takes in the filename of the dataset
    and the name of a player as input and then outputs the total number of passing
    yards that player achieved in the dataset. We’ll assume that the user will be
    providing the data as formatted in the NFL offensive stats file in chapter 2 and
    in table 6.2\. Before we write the prompt or function, how should we test this?
    Well, we have some options:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一个函数，该函数接受数据集的文件名和球员的名字作为输入，然后输出该球员在数据集中所达到的总传球码数。我们假设用户提供的数据格式与第二章和表6.2中的NFL进攻统计文件一致。在编写提示或函数之前，我们该如何进行测试呢？我们有几种选择：
- en: '*Find tests in the larger dataset—*A solution is to give the full dataset to
    the function and multiple player names as inputs. The challenge is figuring out
    whether we’re correct or not. We could open the file in software such as Google
    Sheets or Microsoft Excel and use spreadsheet features to figure out the answer
    for each player. For example, we could open the file as a sheet in Excel, sort
    by player, find a player, and use the sum function in Excel to add up all the
    passing yards for that player. This isn’t a bad solution at all, but it’s also
    a fair bit of work, and if you put enough time into finding the answer for testing,
    you might have already fulfilled your needs and no longer require the Python code!
    In other words, figuring out the answer for the test cases might just give you
    the answer you wanted in the first place, making the code less valuable. Another
    problem is in finding all the edge cases you might want to test: Will your dataset
    have all the edge cases you’d want to test to write a program that will work on
    other datasets later? Yet another drawback of this approach is determining what
    you do when the function is doing something considerably more complicated than
    just summing a value in a bunch of rows. There, figuring out the answers for some
    real test values might be a great deal of work.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在更大的数据集中寻找测试——*一种解决方案是将完整的数据集和多个球员名字作为输入传递给函数。挑战在于确定我们是否正确。我们可以使用Google Sheets或Microsoft
    Excel等软件打开文件，并利用电子表格的功能为每个球员找出答案。例如，我们可以将文件作为表格在Excel中打开，按球员排序，找到某个球员，并使用Excel中的求和函数计算该球员的所有传球码数。这并不是一个坏的解决方案，但它也需要不少工作，如果你花足够的时间去寻找测试答案，你可能已经完成了需求，而不再需要Python代码了！换句话说，弄清楚测试案例的答案，可能就已经得到了你最初想要的答案，这样代码就不那么有价值了。另一个问题是，如何找到所有你想测试的边界情况：你的数据集是否包含所有你想要测试的边界情况，以便编写一个在其他数据集上也能运行的程序呢？这种方法的另一个缺点是，当函数执行的操作比简单地在多行中求和复杂得多时，如何处理这种情况：在这种情况下，弄清楚某些真实测试值的答案可能需要大量的工作。'
- en: '*Create artificial dataset(s) for testing—*Another solution is to create artificial
    datasets where you know the answer to a number of possible queries. Because the
    dataset is artificial, you can add edge cases to see how the code performs in
    those cases without having to find such rare examples in the real dataset. (Sometimes
    the real dataset won’t include those edge cases, but you still want to test them,
    so the code behaves properly if you get an updated or new dataset.)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建人工数据集进行测试——*另一种解决方案是创建人工数据集，在这些数据集中你知道多种可能查询的答案。因为数据集是人工创建的，你可以加入边界情况，看看代码在这些情况下如何表现，而不必在真实数据集中寻找这种罕见的例子。（有时，真实数据集中可能没有这些边界情况，但你仍然希望进行测试，以便当数据集更新或新增时，代码能够正常运行。）'
- en: Given the advantages to creating test cases in an artificial dataset, we’re
    going to proceed with that approach here.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于在人工数据集上创建测试用例的优势，我们将在这里采用这种方法。
- en: 6.6.1 What tests should we run?
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.1 我们应该运行哪些测试？
- en: 'Let’s think through the common cases and edge cases that we would want to test.
    For common cases, we’d want to have a few tests:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下我们希望测试的常见情况和边缘情况。对于常见情况，我们希望有几个测试：
- en: '*A player appears multiple times in different rows of the dataset (nonconsecutively),
    including the last row.* This test makes sure the code iterates over all the players
    before returning a result (i.e., doesn’t make the false assumption that the data
    is sorted by player name).'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个球员在数据集中多次出现（非连续），包括最后一行。* 这个测试确保代码在返回结果之前迭代所有球员（即，不做出数据按球员名字排序的错误假设）。'
- en: '*A player appears in consecutive rows of the dataset.* This test makes sure
    there isn’t some kind of error where consecutive values are somehow skipped.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个球员出现在数据集的连续行中。* 这个测试确保没有出现某种错误，其中连续的值被跳过。'
- en: '*A player appears just once in the dataset.* This test makes sure that the
    sum behaves properly even when it’s just summing one value.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*某球员在数据集中仅出现一次。* 这个测试确保即使只是对一个值求和时，结果也能正常处理。'
- en: '*A non-quarterback could appear in the dataset.* For this, we ensure the code
    is including all players, not just quarterbacks.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据集中可能出现非四分卫球员。* 对此，我们确保代码包含所有球员，而不仅仅是四分卫。'
- en: '*A player has 0 total passing yards in a game.* This checks to make sure that
    the code behaves properly when players don’t have any passing yards. This is a
    common case to test because players can get hurt and miss a game due to the injury.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*某球员在一场比赛中传球码数为0。* 这个测试确保代码在球员没有传球码数时正确运行。因为球员可能因伤缺席比赛，所以这是一个常见的测试情况。'
- en: 'For edge cases, we’d want to test a couple more things:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于边缘情况，我们希望再测试几个内容：
- en: '*The player isn’t in the dataset.* This is actually pretty interesting: What
    do we want the code to do in this case? A reasonable answer is to return that
    they passed for 0 yards. If we asked the dataset how many yards Lebron James (a
    basketball player, not a football player) passed for in the NFL from 2019 to 2022,
    0 is the right answer. However, this may not be the most elegant solution for
    production code. For example, if we ask for the passing yards for Aron Rodgers
    (misspelling Aaron Rodgers), we’d rather have the code tell us he’s not in the
    dataset than that he passed for 0 yards, which could really confuse us when he
    won the league MVP twice during this time frame. To signal that the name was missing,
    we might return a large negative value (e.g., –9999), or we might use something
    called exceptions, but they are beyond the scope of this book.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*该球员不在数据集中。* 这实际上非常有趣：我们希望代码在这种情况下做什么？一个合理的答案是返回他们传球了0码。如果我们询问数据集关于勒布朗·詹姆斯（篮球运动员，而非美式足球运动员）在2019到2022年间在NFL的传球码数，0是正确答案。然而，这可能不是生产代码中最优雅的解决方案。例如，如果我们询问关于亚伦·罗杰斯（拼写错误为Aron
    Rodgers）的传球码数，我们宁愿让代码告诉我们他不在数据集中，而不是说他传了0码，这在他在此期间两次获得联盟MVP的情况下可能会非常混淆我们。为了表示该名字缺失，我们可能会返回一个大负值（例如，-9999），或者我们可能会使用异常处理，但这些超出了本书的讨论范围。'
- en: '*A player has a negative total number of yards across all games or a player
    has a single game with negative yards to ensure the code is properly handling
    negative values.* If you don’t follow American football, this can happen if a
    player catches a ball and is tackled behind the starting point (line of scrimmage).
    It’s unlikely a quarterback would have negative passing yards for an entire game,
    but it could happen if they throw one pass for a loss (negative yards) and get
    hurt at the same time, causing them to not play for the rest of the game.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个球员在所有比赛中的总码数为负，或者某个球员在单场比赛中的码数为负，以确保代码正确处理负值。* 如果你不熟悉美式足球，这种情况可能发生在球员接到球并被擒抱在起始点（进攻线）后面。四分卫在整场比赛中的传球码数为负的情况很少见，但如果他们传出一次负码数的传球，并且在同一时刻受伤，导致他们之后无法继续比赛，那么这种情况是有可能发生的。'
- en: Now that we have an idea of what we want to test, let’s build an artificial
    file that captures these test cases. We could have split these tests across multiple
    files, which would be a reasonable choice to make as well, but an advantage of
    putting them all in one file is that we can keep all of our test cases together.
    Table 6.3 is what we built and saved as test_file.csv.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对测试内容有了大致的了解，接下来让我们构建一个人工文件来捕捉这些测试用例。我们本可以将这些测试分布在多个文件中，这也是一个合理的选择，但将它们放在一个文件中的优点是，我们可以将所有测试用例保存在一起。表6.3是我们构建并保存为test_file.csv的内容。
- en: Table 6.3 Our file to test the NFL passing yards function
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.3 我们的文件来测试NFL传球码数功能
- en: '| game_id | player_id | position | player | team | pass_cmp | pass_att | pass_yds
    | pass_td |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| game_id | player_id | position | player | team | pass_cmp | pass_att | pass_yds
    | pass_td |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 20  | 30  | 200  |
    1  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 201909050chi  | RodgAa00  | QB  | 亚伦·罗杰斯  | GNB  | 20  | 30  | 200  | 1  |'
- en: '| 201909080crd  | JohnKe06  | RB  | Kerryon Johnson  | DET  | 1  | 1  | 5  |
    0  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 201909080crd  | JohnKe06  | RB  | 凯里昂·约翰逊  | DET  | 1  | 1  | 5  | 0  |'
- en: '| 201909080crd  | PortLe00  | QB  | Leo Porter  | UCSD  | 0  | 1  | 0  | 0  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 201909080crd  | PortLe00  | QB  | 莱奥·波特  | UCSD  | 0  | 1  | 0  | 0  |'
- en: '| 201909080car  | GoffJa00  | QB  | Jared Goff  | LAR  | 20  | 25  | 200  |
    1  |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 201909080car  | GoffJa00  | QB  | 贾里德·高夫  | LAR  | 20  | 25  | 200  | 1  |'
- en: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 10  | 15  | 150  |
    1  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 201909050chi  | RodgAa00  | QB  | 亚伦·罗杰斯  | GNB  | 10  | 15  | 150  | 1  |'
- en: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 25  | 35  | 300  |
    1  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 201909050chi  | RodgAa00  | QB  | 亚伦·罗杰斯  | GNB  | 25  | 35  | 300  | 1  |'
- en: '| 201909080car  | GoffJa00  | QB  | Jared Goff  | LAR  | 1  | 1  | –10  | 0  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 201909080car  | GoffJa00  | QB  | 贾里德·高夫  | LAR  | 1  | 1  | –10  | 0  |'
- en: '| 201909080crd  | ZingDa00  | QB  | Dan Zingaro  | UT  | 1  | 1  | –10  | 0  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 201909080crd  | ZingDa00  | QB  | 丹·津加罗  | UT  | 1  | 1  | –10  | 0  |'
- en: '| 201909050chi  | RodgAa00  | QB  | Aaron Rodgers  | GNB  | 15  | 25  | 150  |
    0  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 201909050chi  | RodgAa00  | QB  | 亚伦·罗杰斯  | GNB  | 15  | 25  | 150  | 0  |'
- en: Notice that the data here is entirely artificial. (These aren’t the real statistics
    for any player, as you can tell by the fact that Dan and Leo are now magically
    NFL quarterbacks.) We did keep the names of some real players as well as real
    `game_id`s and `player_id`s from the original dataset. It’s generally a good idea
    to make your artificial data be as close to real data as possible so that the
    tests are genuine and more apt to be representative of what will happen with real
    data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的数据完全是人工构造的。（这些不是任何球员的真实统计数据，你可以从丹和莱奥现在变成NFL四分卫这一点看出来。）我们确实保留了部分真实球员的名字，以及来自原始数据集的真实`game_id`和`player_id`。通常来说，尽量让你的人工数据尽可能接近真实数据，这样测试更为真实，更有可能代表实际数据的情况。
- en: Let’s look at how we incorporated all the test cases in this test file (table
    6.3). Aaron Rodgers occurs multiple times in the file, both consecutively and
    nonconsecutively, and as the last entry. Jared Goff appears multiple times, and
    we gave him an artificial –10 yards in a game (as an elite NFL QB, I hope he’s
    okay with us giving him an artificially bad single game). We kept Kerryon Johnson
    as a running back (RB) from the real dataset and gave him 5 passing yards to make
    sure the solution doesn’t filter for only QBs. Kerryon Johnson also only has one
    entry in the data. We added Leo Porter to the dataset and gave him 0 passing yards
    (he’s pretty sure he’d do anything to not get tackled by an NFL player). We also
    added Dan Zingaro and gave him a completed pass, but for –10 yards, covering the
    case that a single player’s total is negative. Table 6.4 shows what it *should*
    return per player when we run the query for each player.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在这个测试文件中融入所有的测试用例（表6.3）。亚伦·罗杰斯在文件中出现多次，包括连续出现和非连续出现，也作为最后一条记录出现。贾里德·高夫多次出现，我们为他在一场比赛中人工设置了–10码（作为一名顶级NFL四分卫，我希望他能接受我们给他设置一个不太理想的单场比赛数据）。我们保留了凯里昂·约翰逊作为跑卫（RB）并从真实数据集中给了他5码的传球码数，以确保解决方案不会仅仅过滤四分卫。凯里昂·约翰逊在数据中只有一条记录。我们将莱奥·波特添加到数据集中，并为他设置了0码传球码数（他确信自己会尽一切努力避免被NFL球员擒抱）。我们还添加了丹·津加罗并给了他一次成功的传球，但为–10码，覆盖了单个球员的总数据为负的情况。表6.4展示了当我们针对每个球员运行查询时，它*应该*返回的结果。
- en: Table 6.4 Passing yards per player in the test case
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.4 测试用例中每个球员的传球码数
- en: '| Player | Passing yards in the test case |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| Player | Passing yards in the test case |'
- en: '| --- | --- |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Aaron Rodgers  | 800  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 亚伦·罗杰斯  | 800  |'
- en: '| Kerryon Johnson  | 5  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 凯里昂·约翰逊  | 5  |'
- en: '| Leo Porter  | 0  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 莱奥·波特  | 0  |'
- en: '| Jared Goff  | 190  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 贾里德·高夫  | 190  |'
- en: '| Dan Zingaro  | –10  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 丹·津加罗  | –10  |'
- en: 6.6.2 Creating the function
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.2 创建函数
- en: Let’s start with the function name and describe the problem in the docstring.
    This problem may be complicated enough that we’ll need to offer prompts within
    the function to help it know to open the file, process the data, and close the
    file, but let’s try to just describe the function first and see how Copilot does.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从函数名开始，在文档字符串中描述问题。这个问题可能足够复杂，我们可能需要在函数中提供提示，帮助它打开文件、处理数据并关闭文件，但让我们先试着描述函数，看看Copilot如何处理。
- en: Listing 6.9 Function to find total passing yards per player
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.9 查找每个球员总传球码数的函数
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '#1 We abbreviated the function name.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们简化了函数名。'
- en: Before looking at the code produced, we want to point out that we didn’t include
    the test cases for this example because they likely wouldn’t help Copilot. We
    recommend having Copilot generate code prior to you adding test cases if your
    test cases will simply open and use artificial files. Each test case will just
    be a filename, a player, and the expected output. Copilot likely can’t read the
    file that corresponds to that filename and figure out that we’re summing the eighth
    column to get the desired result. This means that giving Copilot the test cases
    isn’t going to add to the quality of the prompt. In fact, the artificial nature
    of our data might even confuse it (e.g., in what scenario does a real NFL player
    have a negative total for passing yards?).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看生成的代码之前，我们想指出的是，我们没有为这个示例包含测试用例，因为它们可能对Copilot没有帮助。如果你的测试用例只是打开并使用人工文件，我们建议你在添加测试用例之前让Copilot生成代码。每个测试用例将只是一个文件名、一个球员和预期的输出。Copilot可能无法读取与该文件名对应的文件，也无法理解我们是在对第八列求和以获得期望的结果。这意味着，给Copilot提供测试用例不会增加提示的质量。事实上，我们数据的人工性质甚至可能让它感到困惑（例如，现实中的NFL球员什么时候会有负的传球码数？）。
- en: Now looking at the code that Copilot gave us, we can see that it’s quite reasonable
    and almost identical to the code we saw in chapter 2\. Given that it seems reasonable
    when we read it, let’s see how to test it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看Copilot给我们的代码，我们可以看到它非常合理，几乎和我们在第二章看到的代码完全相同。既然我们阅读后觉得它合理，让我们看看如何测试它。
- en: 6.6.3 Testing the function
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.3 测试函数
- en: To test the function, we’ll augment the docstring to include our test cases
    for the full piece of code, as shown in the following listing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个函数，我们将增加文档字符串，包含完整代码的测试用例，如下所示。
- en: Listing 6.10 Testing the function to find player passing yards
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.10 测试查找球员传球码数的函数
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '#1 The additional test case for a player not in the dataset'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 针对数据集中没有该球员的额外测试用例'
- en: We ran this code, and all the test cases passed. (We know that all test cases
    passed because there was no output from doctest.) We now have additional evidence
    that the code is functioning properly!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行了这段代码，所有的测试用例都通过了。（我们知道所有的测试用例都通过了，因为doctest没有输出。）现在我们有了额外的证据，证明代码正常运行！
- en: 6.6.4 Common challenges with doctest
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.4 doctest的常见挑战
- en: Let’s rewrite the previous prompt and add a really subtle error to the first
    test, as shown in the following listing.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写之前的提示，并在第一个测试中添加一个非常微妙的错误，如下所示。
- en: Listing 6.11 Mistake in doctest
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.11 doctest中的错误
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '#1 There is an extra space after the 800 that isn’t visible.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 800后面有一个不可见的空格。'
- en: 'When we ran this code, we received this error:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，出现了以下错误：
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: On first glance, this seems really odd. The test case expects 800 and it got
    800, but it’s telling us it failed. Well, it turns out that we made a mistake
    in writing the test case and wrote “800 ” (with a space at the end) rather than
    “800”. This mistake causes Python to think the space is important and causes the
    test to fail. The bad news is that this is a really common problem working with
    doctest! We’ve made this mistake more often than we’d like to admit. The good
    news is it’s really easy to fix by just finding and deleting the space. If a test
    is failing but the output from doctest suggests that it should be passing, always
    check ends of lines for spaces or extra or missing spaces anywhere in your output
    compared to exactly what doctest is expecting.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，这似乎很奇怪。测试用例期望得到800，但得到了800，却告诉我们失败了。实际上，事实是我们在编写测试用例时犯了个错误，写成了“800 ”（后面有空格）而不是“800”。这个错误导致Python认为空格很重要，从而导致测试失败。坏消息是，这是使用doctest时一个非常常见的问题！我们犯这个错误的次数比我们愿意承认的要多。好消息是，只需要找到并删除空格，就能轻松修复。如果一个测试失败了，但doctest的输出提示它应该通过，请始终检查输出的行末是否有空格，或者输出中任何地方的多余或缺失的空格，看看与doctest的预期是否完全一致。
- en: Given that all our test cases passed, we can feel confident returning to the
    larger dataset and using the function we just created. The key thing from this
    example is that we can, and should, create artificial files to test functions
    that work with files. Again, testing is all about gaining confidence that the
    code is working properly, and you want to be sure you test any code you write
    or given to you by Copilot.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们的所有测试用例都通过了，我们可以有信心返回到更大的数据集并使用我们刚刚创建的函数。这个例子中的关键点是，我们可以且应该创建人工文件来测试与文件打交道的函数。再次强调，测试是为了确保代码正常运行，你要确保测试你写的或由Copilot提供的任何代码。
- en: In this chapter as a whole, we learned about the importance of testing code,
    how to test code, and how to do it in two detailed examples. In our examples,
    we wrote and tested functions. But how do we decide which functions should be
    written to solve even larger problems? Well, we figure that out through a process
    known as problem decomposition that we’ll cover in detail in our next chapter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了测试代码的重要性、如何测试代码以及如何通过两个详细的示例进行测试。在我们的示例中，我们编写并测试了函数。那么，我们如何决定应该编写哪些函数来解决更大的问题呢？好吧，我们通过一个被称为问题分解的过程来解决这个问题，我们将在下一章详细介绍这个过程。
- en: 6.7 Exercises
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 练习
- en: 'Given the following scenarios, identify whether closed-box testing or open-box
    testing would be more appropriate and explain why:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定以下场景，确定是闭盒测试还是开盒测试更为合适，并解释为什么：
- en: A tester is given a function specification and needs to ensure that the function
    behaves correctly without looking at the implementation.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试人员收到一个函数规格说明，需要确保该函数在不查看实现的情况下正确执行。
- en: A tester needs to debug a function by writing tests that specifically target
    edge cases revealed by understanding the code implementation.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试人员需要通过编写测试，特别是针对通过理解代码实现而揭示的边缘情况，来调试一个函数。
- en: 'Here is a function with some test cases. Identify which of the following test
    cases are common use cases and which are edge cases:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一个包含一些测试用例的函数。识别以下哪些测试用例是常见用例，哪些是边缘用例：
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '3\. We’re building a program to analyze website traffic. Website traffic is
    represented as a list of dictionaries. Each dictionary has two keys: `"weekday"`
    (a string representing the day of the week) and `"visitors"` (an integer representing
    the number of visitors on that day). The same day of the week can appear in multiple
    dictionaries. Our goal is to find the day of the week with the highest number
    of visitors.'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 我们正在构建一个分析网站流量的程序。网站流量表示为一个字典列表。每个字典有两个键：`"weekday"`（表示星期几的字符串）和`"visitors"`（表示该天访问者数量的整数）。同一个星期几可以出现在多个字典中。我们的目标是找出访问人数最多的星期几。
- en: 'Here’s the initial prompt we gave to an AI code-generation tool:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们给AI代码生成工具的初始提示：
- en: 'def busiest_day(traffic_data): # traffic_data is a list of dictionaries. #
    Find the busiest day.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'def busiest_day(traffic_data): # traffic_data是一个字典列表。# 找出最繁忙的日期。'
- en: The tool generated the following code, but it doesn’t seem quite right.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 工具生成了以下代码，但似乎不太正确。
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Can you explain why and how you would improve the prompt to get the desired
    functionality?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你能解释为什么以及如何改进提示，以获得所需的功能吗？
- en: '4\. Imagine you have a function (`find_highest_grossing_book(filename)`) that
    analyzes book sales data and returns information about the book with the highest
    total revenue. Sales data is stored in a CSV file where each line represents a
    sale. The columns in the CSV file are as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 假设你有一个函数（`find_highest_grossing_book(filename)`），它分析书籍销售数据并返回总收入最高的书籍信息。销售数据存储在一个CSV文件中，每一行代表一次销售。CSV文件的列如下：
- en: '`title`—The title of the book sold (string)'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`title`—书籍的标题（字符串）'
- en: '`author`—The author of the book (string)'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`author`—书籍的作者（字符串）'
- en: '`price`—The price of the book (float)'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`price`—书籍的价格（浮动数值）'
- en: '`quantity`—The number of copies sold for that particular sale (integer)'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`quantity`—该销售的销售数量（整数）'
- en: Create a Python script containing the `find_highest_grossing_book` function
    (implementation not provided here). Include a docstring explaining the function’s
    purpose, and add test cases using the doctest module.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含`find_highest_grossing_book`函数的Python脚本（此处不提供实现）。包含一个说明函数目的的文档字符串，并使用doctest模块添加测试用例。
- en: 5\. Review the provided test cases for the `is_palindrome` function. Identify
    which test cases are incorrect, and explain why. Provide the correct version of
    the test cases.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. 检查提供的`is_palindrome`函数的测试用例。找出哪些测试用例是错误的，并解释原因。提供正确版本的测试用例。
- en: '[PRE37]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 6\. Analyze the test coverage of the `find_max` function. Are there any scenarios
    not covered by the existing test cases? Suggest additional test cases if necessary.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6\. 分析 `find_max` 函数的测试覆盖率。现有的测试用例是否覆盖了所有场景？如有必要，请提出额外的测试用例。
- en: '[PRE38]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Testing is a critical skill when writing software using Copilot.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试是在使用 Copilot 编写软件时一项关键技能。
- en: Closed-box and open-box testing are different approaches to ensuring the code
    is correct. In closed-box testing, we come up with test cases based on what we
    know about the problem; in open-box testing, we additionally examine the code
    itself.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封闭盒测试和开放盒测试是确保代码正确性的不同方法。在封闭盒测试中，我们根据已知的关于问题的信息来设计测试用例；而在开放盒测试中，我们还会额外检查代码本身。
- en: Doctest is a module that comes with Python that helps us test our code.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Doctest 是 Python 自带的一个模块，帮助我们测试代码。
- en: To use doctest, we add test cases to the docstring description of a function.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 doctest 时，我们将测试用例添加到函数的文档字符串描述中。
- en: Creating artificial files is an effective way to test code that uses files.**
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建人工文件是测试使用文件的代码的一种有效方法。**
