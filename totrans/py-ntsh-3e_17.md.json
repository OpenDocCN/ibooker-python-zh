["```py\n`if` __name__ == '__main__':\n `import` doctest\n    doctest.testmod()\n```", "```py\n*`\"\"\"`*\n*`This module supplies a single function reverse_words that reverses`*\n*`a string word by word.`*\n\n*`>>> reverse_words('four score and seven years')`*\n*`'years seven and score four'`*\n*`>>> reverse_words('justoneword')`*\n*`'justoneword'`*\n*`>>> reverse_words('')`*\n*`''`*\n\n*`You must call reverse_words with a single argument, a string:`*\n\n*`>>> reverse_words()`*\n*`Traceback (most recent call last):`*\n *`...`*\n*`TypeError: reverse_words() missing 1 required positional argument: 'astring'`*\n*`>>> reverse_words('one', 'another')`*\n*`Traceback (most recent call last):`*\n *`...`*\n*`TypeError: reverse_words() takes 1 positional argument but 2 were given`*\n*`>>> reverse_words(1)`*\n*`Traceback (most recent call last):`*\n *`...`*\n*`AttributeError: 'int' object has no attribute 'split'`*\n*`>>> reverse_words('𝒰𝓷𝓲𝓬𝓸𝓭𝓮 is all right too')`*\n*`'too right all is 𝒰𝓷𝓲𝓬𝓸𝓭𝓮'`*\n\n*`As a side effect, reverse_words eliminates any redundant spacing:`*\n\n*`>>> reverse_words('with  redundant   spacing')`*\n*`'spacing redundant with'`*\n*`\"\"\"`*\n\n`def` reverse_words(astring):\n    words = astring.split()\n    words.reverse()\n    `return` ' '.join(words)\n\n`if` __name__ == '__main__':\n    `import` doctest\n    doctest.testmod()\n```", "```py\n\"\"\"This module tests function reverse_words\nprovided by module mod.py.\"\"\"\n`import` unittest\n`import` mod\n\n`class` ModTest(unittest.TestCase):\n\n    `def` testNormalCaseWorks(self):\n        self.assertEqual(\n            'years seven and score four',\n            mod.reverse_words('four score and seven years'))\n\n    `def` testSingleWordIsNoop(self):\n        self.assertEqual(\n            'justoneword',\n            mod.reverse_words('justoneword'))\n\n    `def` testEmptyWorks(self):\n        self.assertEqual('', mod.reverse_words(''))\n\n    `def` testRedundantSpacingGetsRemoved(self):\n        self.assertEqual(\n            'spacing redundant with',\n            mod.reverse_words('with   redundant   spacing'))\n\n    `def` testUnicodeWorks(self):\n        self.assertEqual(\n            'too right all is 𝒰𝓷𝓲𝓬𝓸𝓭𝓮'\n            mod.reverse_words('𝒰𝓷𝓲𝓬𝓸𝓭𝓮 is all right too'))\n\n    `def` testExactlyOneArgumentIsEnforced(self):\n        `with` self.assertRaises(TypeError):\n            mod.reverse_words('one', 'another')\n\n    `def` testArgumentMustBeString(self):\n        `with` self.assertRaises((AttributeError, TypeError)):\n            mod.reverse_words(1)\n\n`if` __name__=='__main__':\n    unittest.main()\n```", "```py\n`with` self.assertRaises(*`exceptionSpec`*):\n *`# ...a block of code...`*\n```", "```py\n`with` self.assertRaisesRegex(*`exceptionSpec``,` `regex`*):\n *`# ...a block of code...`*\n```", "```py\n`if` `not` complex_check_if_its_ok(some, thing):\n    self.fail(\n      'Complex checks failed on'\n      f' {some}, {thing}'\n    )\n```", "```py\n`while` self.list_of_cleanups:\n    func, a, k = self.list_of_cleanups.pop()\n    func(*a, **k)\n```", "```py\n`import` unittest\n`from` nose2.tools `import` params\n\n`class` TestCase(unittest.TestCase):\n\n    @params((5, 5), (-1, 1), ('a', `None`, TypeError))\n    `def` test_abs_value(self, x, expected, should_raise=`None`):\n        `if` should_raise `is` `not` `None`:\n            `with` self.assertRaises(should_raise):\n                abs(x)\n        `else`:\n            assert abs(x) == expected\n```", "```py\n`assert` 0.1 + 0.2 == approx(0.3)\n`assert` [0.1, 0.2, 0.1+0.2] == approx([0.1, 0.2, 0.3])\n```", "```py\n@pytest.mark.parametrize\n(\"x,y,expected\", \n [(1, 0, `True`), (0, 1, `False`)])\n`def` test_is_greater(x, y, expected):\n`assert` (x > y) == expected\n```", "```py\n`def` f(x=23):\n    `return` inspect.currentframe()\nprint(inspect.formatargvalues(\n      *inspect.getargvalues(f())))\n*`# prints:`* *`(x=23)`*\n```", "```py\n((n, v) `for` n, v `in` getmembers(obj) \n        `if` filter(v))\n```", "```py\n`class` A: `pass`\n`class` B(A): `pass`\n`class` C(A): `pass`\n`class` D(B, C): `pass`\n`for` c `in` inspect.getmro(D):\n    print(c.__name__, end=' ')\n*`# prints: D B C A object`*\n```", "```py\nx.f()\n```", "```py\nprint(type(x), x)\n*`# or, from v3.8, use an f-string with a trailing '=' to show repr(x)`*\n*`# print(f'{x=}')`*\nx.f()\n```", "```py\n`try`:\n    x.f()\n`except` AttributeError:\n `import` sys`,` inspect\n    print(f'x is type {type(x).__name__}, ({x!r})', file=sys.stderr)\n    print(\"x's methods are:\", file=sys.stderr, end='')\n    `for` n, v `in` inspect.getmembers(x, callable):\n        print(n, file=sys.stderr, end=' ')\n    print(file=sys.stderr)\n `raise`\n```", "```py\nimport sys, inspect\n`def` show_obj_methods(obj, name, show=sys.stderr.write):\n    show(f'{name} is type {type(obj).__name__}({obj!r})\\n')\n    show(f\"{name}'s methods are: \")\n    `for` n, v `in` inspect.getmembers(obj, callable):\n       show(f'{n} ')\n    show('\\n')\n```", "```py\n`try`:\n    x.f()\n`except` AttributeError:\n    show_obj_methods(x, 'x')\n `raise`\n```", "```py\n`def` f():\n `for` i `in` range(1000):\n        g(i)\n`def` g(i):\n `pass`\n```", "```py\n>>> `import` pdb\n>>> `import` fob\n>>> pdb.run('fob.f()')\n```", "```py\n> <string>(1)?()\n(Pdb) break fob.g\nBreakpoint 1 at C:\\mydir\\fob.py:5\n(Pdb) ignore 1 500\nWill ignore next 500 crossings of breakpoint 1.\n(Pdb) continue\n> C:\\mydir\\fob.py(5)\ng()-> pass\n(Pdb) print(i)\n500\n```", "```py\n`def` to_unicode(bytestr):\n    `try`:\n        `return` bytestr.decode()\n    `except` UnicodeError:\n        warnings.warn(f'Invalid characters in \n                      {bytestr!r}',\n                      stacklevel=2)\n        `return` bytestr.decode(errors='ignore')\n```", "```py\n`def` slow(it):\n    result = []\n    `for` item `in` it:\n        result.insert(0, item)\n    `return` result\n\n`def` fast(it):\n    result = []\n    `for` item `in` it:\n        result.append(item)\n    result.reverse()\n    `return` result\n```", "```py\nresult = list(it)\n```", "```py\n`import` profile\nprofile.Profile.bias = *`.``.``.``the` `overhead` `you` `measured``.``.``.`*\nprofile.run('main()', 'somefile')\n```", "```py\n$ python -m timeit -s '*setup statement(s)*' '*statement(s) to be timed*'\n```", "```py\n$ python -m timeit -s 'x=0' 'x=x+1'\n```", "```py\n1000000 loops, best of 3: 0.0416 usec per loop\n```", "```py\n$ python -m timeit -s 'x=0' 'x+=1'\n```", "```py\n1000000 loops, best of 3: 0.0406 usec per loop\n```", "```py\n`import` math\n`def` sin_degrees(x):\n    return math.sin(math.radians(x))\n```", "```py\n_cached_values = {}\n`def` sin_degrees(x):\n    `if` x `not` `in` _cached_values:\n        _cached_values[x] = math.sin(math.radians(x))\n    return _cached_values[x]\n```", "```py\n`def` sin_degrees(x):\n    cache = sin_degrees._cached_values\n    `if` x `not` `in` cache:\n        cache[x] = math.sin(math.radians(x))\n    `return` cache[x]\nsin_degrees._cached_values = {}\n```", "```py\n`def` sin_degrees(x):\n    cache = sin_degrees._cached_values\n    `if` x `not` `in` cache:\n        cache[x] = math.sin(math.radians(x))\n *`# remove oldest cache entry if exceed maxsize limit`*\n        `if` len(cache) > sin_degrees._maxsize:\n            oldest_key = next(iter(cache))\n            del cache[oldest_key]\n    `return` cache[x]\nsin_degrees._cached_values = {}\nsin_degrees._maxsize = 512\n```", "```py\n`import` functools\n@functools.lru_cache(maxsize=512)\n`def` sin_degrees(x):\n    `return` math.sin(math.radians(x))\n```", "```py\n_sin_degrees_lookup = {x: math.sin(math.radians(x))\n                       `for` x `in` range(0, 360+1)}\nsin_degrees = _sin_degrees_lookup.get\n```", "```py\nbig_string = ''.join(temp_list)\n```", "```py\noneway = str(x) + ' eggs and ' + str(y) + ' slices of ' + k + ' ham'\nanother = '{} eggs and {} slices of {} ham'.format(x, y, k)\nyetanother = f'{x} eggs and {y} slices of {k} ham'\n```", "```py\n`from` *`my_module`* `import` *\n```", "```py\n`if` slow_function() `and` fast_function():\n *`#`* *`...`* *`proceed with processing`* *`...`*\n```", "```py\n`if` fast_function() `and` slow_function():\n *`#`* *`...`* *`proceed with processing`* *`...`*\n```", "```py\nany(x**2 > 100 `for` x `in` range(50)) \n*`# returns`* *`True`* *`once it reaches 10, skips the rest`*\n\nodd_numbers_greater_than_1 = range(3, 100, 2)\nall(is_prime(x) `for` x `in` odd_numbers_greater_than_1) \n*`# returns`* *`False`**`: 3, 5, and 7 are prime but 9 is not`*\n\nnext(c `for` c `in` string.ascii_uppercase `if` c in \"AEIOU\")\n*`# returns 'A' without checking the remaining characters`*\n```", "```py\n`def` slower(anobject, ahugenumber):\n    `for` i `in` range(ahugenumber):\n        anobject.amethod(i)\n\n`def` faster(anobject, ahugenumber):\n    themethod = anobject.amethod\n    `for` i `in` range(ahugenumber):\n        themethod(i)\n```", "```py\n`def` slightly_slower(asequence, adict):\n    `for` x `in` asequence:\n        adict[x] = hex(x)\n\n`def` slightly_faster(asequence, adict):\n    myhex = hex\n    `for` x `in` asequence:\n        adict[x] = myhex(x)\n```", "```py\n`import` timeit`,` operator\n\n`def` slow(asequence):\n    result = []\n    `for` x `in` asequence:\n        result.append(-x)\n    `return` result\n\n`def` middling(asequence):\n    `return` list(map(operator.neg, asequence))\n\n`def` fast(asequence):\n    `return` [-x `for` x `in` asequence]\n\n`for` afunc `in` slow, middling, fast:\n    timing = timeit.repeat('afunc(big_seq)',\n                           setup='big_seq=range(500*1000)',\n                           globals={'afunc': afunc},\n                           repeat=5,\n                           number=100)\n    `for` t `in` timing:\n        print(f'{afunc.__name__},{t}')\n```"]