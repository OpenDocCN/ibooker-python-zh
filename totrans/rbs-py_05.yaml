- en: Chapter 4\. Constraining Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many developers learn the basic type annotations and call it a day. But we’re
    far from done. There is a wealth of advanced type annotations that are invaluable.
    These advanced type annotations allow you to constrain types, further restricting
    what they can represent. Your goal is to make illegal states unrepresentable.
    Developers should physically not be able to create types that are contradictory
    or otherwise invalid in your system. You can’t have errors in your code if it’s
    impossible to create the error in the first place. You can use type annotations
    to achieve this very goal, saving time and money. In this chapter I’ll teach you
    six different techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional`'
  prefs: []
  type: TYPE_NORMAL
- en: Use to replace `None` references in your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: '`Union`'
  prefs: []
  type: TYPE_NORMAL
- en: Use to present a selection of types.
  prefs: []
  type: TYPE_NORMAL
- en: '`Literal`'
  prefs: []
  type: TYPE_NORMAL
- en: Use to restrict developers to very specific values.
  prefs: []
  type: TYPE_NORMAL
- en: '`Annotated`'
  prefs: []
  type: TYPE_NORMAL
- en: Use to provide additional description of your types.
  prefs: []
  type: TYPE_NORMAL
- en: '`NewType`'
  prefs: []
  type: TYPE_NORMAL
- en: Use to restrict a type to a specific context.
  prefs: []
  type: TYPE_NORMAL
- en: '`Final`'
  prefs: []
  type: TYPE_NORMAL
- en: Use to prevent variables from being rebound to a new value.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with handling `None` references with `Optional` types.
  prefs: []
  type: TYPE_NORMAL
- en: Optional Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Null references are often referred to as the “billion-dollar mistake,” coined
    by C.A.R. Hoare:'
  prefs: []
  type: TYPE_NORMAL
- en: I call it my billion-dollar mistake. It was the invention of the null reference
    in 1965\. At that time, I was designing the first comprehensive type system for
    references in an object oriented language. My goal was to ensure that all use
    of references should be absolutely safe, with checking performed automatically
    by the compiler. But I couldn’t resist the temptation to put in a null reference,
    simply because it was so easy to implement. This has led to innumerable errors,
    vulnerabilities, and system crashes, which have probably caused a billion dollars
    of pain and damage in the last forty years.^([1](part0007_split_009.html#idm45644755819000))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: While null references started in Algol, they would pervade countless other languages.
    C and C++ are often derided for null pointer dereference (which produces a segmentation
    fault or other program-halting crash). Java was well-known for requiring the user
    to catch `NullPointerException` throughout their code. It’s not a stretch to say
    that these sorts of bugs have a price tag measured in the billions. Think of the
    developer time, customer loss, and system failures due to accidental null pointers
    or references.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why does this matter in Python? Hoare’s quote is about object-oriented
    compiled languages back in the 60s; Python must be better by now, right? I regret
    to inform you that this billion-dollar mistake is in Python as well. It appears
    to us under a different name: `None`. I will show you a way to avoid the costly
    `None` mistake, but first, let’s talk about why `None` is so bad.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is especially illuminating that Hoare admits that null references were born
    out of convenience. It goes to show you how taking the quicker path can lead to
    all sorts of pain later in your development life cycle. Think how your short-term
    decisions today will adversely affect your maintenance tomorrow.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider some code that runs an automated hot dog stand. I want my system
    to take a bun, put a frank in the bun, and then squirt ketchup and mustard through
    automated dispensers, as described in [Figure 4-1](part0007_split_001.html#figure_4_1).
    What could go wrong?
  prefs: []
  type: TYPE_NORMAL
- en: '![Worfklow for the automated hotdog stand](../images/00004.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Workflow for the automated hot dog stand
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Pretty straightforward, no? Unfortunately, there’s no way to really tell. It’s
    easy to think through the happy path, or the control flow of the program when
    everything goes right, but when talking about robust code, you need to consider
    error conditions. If this were an automated stand with no manual intervention,
    what errors can you think of?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a noncomprehensive list of errors I can think of:'
  prefs: []
  type: TYPE_NORMAL
- en: Out of ingredients (buns, hot dogs, or ketchup/mustard).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order cancelled midprocess.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Condiments get jammed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power is interrupted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer doesn’t want ketchup or mustard and tries to move the bun midprocess.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rival vendor switches the ketchup out with catsup; chaos ensues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, your system is state of the art and will detect all of these conditions,
    but it does so by returning `None` when any one step fails. What does this mean
    for this code? You start seeing errors like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be catastrophic if these errors bubbled up to your customers; you
    pride yourself on a clean UI and don’t want ugly tracebacks defiling your interface.
    To address this, you start to code *defensively*, or coding in such a way that
    you try to foresee every possible error case and account for it. Defensive programming
    is a good thing, but it leads to code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This feels, well, tedious. Because any value can be `None` in Python, it seems
    like you need to engage in defensive programming and do an `is None` check before
    every dereference. This is overkill; most developers will trace through the call
    stack and ensure that no `None` values are returned to the caller. That leaves
    calls to external systems and maybe a scant few calls in your codebase that you
    always have to wrap with `None` checking. This is error prone; you cannot expect
    every developer who ever touches your codebase to know instinctively where to
    check for `None`. Furthermore, the original assumptions you’ve made when writing
    (e.g., this function will never return `None`) can be broken in the future, and
    now your code has a bug. And herein lies your problem: counting on manual intervention
    to catch error cases is unreliable.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason this is so tricky (and so costly) is that `None` is treated as a
    special case. It exists outside the normal type hierarchy. Every variable can
    be assigned to `None`. In order to combat this, you need to find a way of representing
    `None` inside your type hierarchy. You need `Optional` types.
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional` types offer you two choices: either you have a value or you don’t.
    In other words, it is optional to set the variable to a value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code indicates that the variable `maybe_a_string` may optionally contain
    a string. That code typechecks just fine, whether `maybe_a_string` contains `"abcdef"`
    or `None`.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, it’s not apparent what this buys you. You still need to use
    `None` to represent the absence of a value. I have good news for you, though.
    There are three benefits I associate with `Optional` types.
  prefs: []
  type: TYPE_NORMAL
- en: First, you communicate your intent more clearly. If a developer sees an `Optional`
    type in a type signature, they view that as a big red flag that they should expect
    `None` as a possibility.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you notice a function returning an `Optional` value, take heed and check
    for `None` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, you are able to further distinguish the absence of value from an empty
    value. Consider the innocuous list. What happens if you make a function call and
    receive an empty list? Was it just that no results were provided back to you?
    Or was it that an error occurred and you need to take explicit action? If you
    are receiving a raw list, you don’t know without trawling through source code.
    However, if you use an `Optional`, you are conveying one of three possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: A list with elements
  prefs: []
  type: TYPE_NORMAL
- en: Valid data to be operated on
  prefs: []
  type: TYPE_NORMAL
- en: A list with no elements
  prefs: []
  type: TYPE_NORMAL
- en: No error occurred, but no data was available (provided that no data is not an
    error condition)
  prefs: []
  type: TYPE_NORMAL
- en: '`None`'
  prefs: []
  type: TYPE_NORMAL
- en: An error occurred that you need to handle
  prefs: []
  type: TYPE_NORMAL
- en: Finally, typecheckers can detect `Optional` types and make sure that you aren’t
    letting `None` values slip through.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add some error cases to this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When run with a typechecker, you get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! The typechecker will not allow you to return a `None` value by default.
    By changing the return type from `Bun` to `Optional[Bun]`, the code will typecheck
    successfully. This will give developers hints that they should not return `None`
    without encoding information in the return type. You can catch a common mistake
    and make this code more robust. But what about the calling code?
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that the calling code benefits from this as well. Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If `dispense_bun` returns an `Optional`, this code will not typecheck. It will
    complain with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Depending on your typechecker, you may need to specifically enable an option
    to catch these sorts of errors. Always look through your typechecker’s documentation
    to learn what options are available. If there is an error you absolutely want
    to catch, you should test that your typechecker does indeed catch the error. I
    highly recommend testing out `Optional` behavior specifically. For the version
    of `mypy` I am running (0.800), I have to use `--strict-optional` as a command-line
    flag to catch this error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in silencing the typechecker, you need to check for `None`
    explicitly and handle the `None` value, or assert that the value cannot be `None`.
    The following code typechecks successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`None` values truly are a billion-dollar mistake. If they slip through, programs
    can crash, users are frustrated, and money is lost. Use `Optional` types to tell
    other developers to beware of `None`, and benefit from the automated checking
    of your tools.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How often do you deal with `None` in your codebase? How confident are you that
    every possible `None` value is handled correctly? Look through bugs and failing
    tests to see how many times you’ve been bitten by incorrect `None` handling. Discuss
    how `Optional` types will help your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Union Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Union` type is a type that indicates that multiple disparate types may be
    used with the same variable. A `Union[int,str]` means that either an `int` *or*
    a `str` can be used for a variable. For instance, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I now want my hot dog stand to break into the lucrative pretzel business. Instead
    of trying to deal with weird class inheritance (we’ll cover more about inheritance
    in [Part II](part0011.html#part_2)) that doesn’t belong between hot dogs and pretzels,
    you simply can return a `Union` of the two.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Optional` is just a specialized version of a `Union`. `Optional[int]` is the
    same exact thing as `Union[int, None]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a `Union` offers much the same benefit as an `Optional`. First, you reap
    the same communication advantages. A developer encountering a `Union` knows that
    they must be able to handle more than one type in their calling code. Furthermore,
    a typechecker is just as aware of `Union` as it is of `Optional`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find `Unions` useful in a variety of applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling disparate types returned based on user input (as above)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling error return types a la `Optional`s, but with more information, such
    as a string or error code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling different user input (such as if a user is able to supply a list or
    a string)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning different types, say for backward compatibility (returning an old
    version of an object or a new version of an object depending on requested operation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And any other case where you may legitimately have more than one value represented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose you had code that called the `dispense_snack` function but was only
    expecting a `HotDog` (or `None`) to be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As soon as `dispense_snack` starts returning `Pretzels`, this code fails to
    typecheck.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The fact that the typechecker errors out in this case is fantastic. If any function
    you depend on changes to return a new type, its return signature must be updated
    to `Union` a new type, which forces you to update your code to handle the new
    type. This means that your code will be flagged when your dependencies change
    in a way that contradicts your assumptions. With the decisions you make today,
    you can catch errors in the future. This is the mark of robust code; you are making
    it increasingly harder for developers to make mistakes, which reduces their error
    rates, which reduces the number of bugs users will experience.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more fundamental benefit of using a `Union`, but to explain it,
    I need to teach you a smidge of *type theory*, which is a branch of mathematics
    around type systems.
  prefs: []
  type: TYPE_NORMAL
- en: Product and Sum Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Unions` are beneficial because they help constrain representable state space.
    *Representable state space* is the set of all possible combinations an object
    can take.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this `dataclass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I have a name, the condiments that can go on top, an error code in case something
    goes wrong, and if something does go wrong, a boolean to track whether I have
    disposed of the item correctly or not. How many different combinations of values
    can be put into this dictionary? A potentially infinite number, right? The `name`
    alone could be anything from valid values (“hotdog” or “pretzel”) to invalid values
    (“samosa”, “kimchi”, or “poutine”) to absurd (“12345”, “”, or “(╯°□°)╯︵ ┻━┻”).
    `condiments` has a similar problem. As it stands, there is no way to compute the
    possible options.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, I will artificially constrain this type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The name can be one of three values: hotdog, pretzel, or veggie burger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The condiments can be empty, mustard, ketchup, or both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are six error codes (0–5); 0 indicates success).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disposed_of` is only `True` or `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now how many different values can be represented in this combination of fields?
    The answer is 144, which is a grossly large number. I achieve this by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 3 possible types for name × 4 possible types for condiments × 6 error codes
    × 2 boolean values for if the entry has been disposed of = 3×4×6×2 = 144.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you were to accept that any of these values could be `None`, the total balloons
    to 420\. While you should always think about `None` while coding (see earlier
    in this chapter about `Optional`), for this thought exercise, I’m going to ignore
    `None values`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sort of operation is known as a *product type*; the number of representable
    states is determined by the product of possible values. The problem is, not all
    of these states are valid. The variable `disposed_of` should only be set to `True`
    if an error code is set to nonzero. Developers will make this assumption, and
    trust that the illegal state never shows up. However, one innocent mistake can
    bring your whole system crashing to a halt. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, a developer is checking `disposed_of` without checking for the
    nonzero error code first. This is a logic bomb waiting to happen. This code will
    work completely fine as long as `disposed_of` is `True` *and* the error code is
    nonzero. If a valid snack ever sets the `disposed_of` flag to `True` erroneously,
    this code will start producing invalid results. This can be hard to find, as there’s
    no reason for a developer who is creating the snack to check this code. As it
    stands, you have no way of catching this sort of error other than manually inspecting
    every use case, which is intractable for large code bases. By allowing an illegal
    state to be representable, you open the door to fragile code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remedy this, I need to make this illegal state unrepresentable. To do that,
    I’ll rework my example and use a `Union`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `snack` can be either a `Snack` (which is just a `name` and `condiments`)
    or an `Error` (which is just a number and a boolean). With the use of a `Union`,
    how many representable states are there now?
  prefs: []
  type: TYPE_NORMAL
- en: For `Snack`, there are 3 names and 4 possible list values, which is a total
    of 12 representable states. For `ErrorCode`, I can remove the 0 error code (since
    that was only for success), which gives me 5 values for the error code and 2 values
    for the boolean for a total of 10 representable states. Since the `Union` is an
    either/or construct, I can either have 12 representable states in one case or
    10 in the other, for a total of 22\. This is an example of a *sum type*, since
    I’m adding the number of representable states together rather than multiplying.
  prefs: []
  type: TYPE_NORMAL
- en: That’s 22 total representable states. Compare that with the 144 states when
    all the fields were lumped in a single entity. I’ve reduced my representable state
    space by almost 85%. I’ve made it impossible to mix and match fields that are
    incompatible with one another. It becomes much harder to make a mistake, and there
    are far fewer combinations to test. Anytime you use a sum type, such as a `Union`,
    you are dramatically decreasing the number of possible representable states.
  prefs: []
  type: TYPE_NORMAL
- en: Literal Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When calculating the number of representable states, I made some assumptions
    in the last section. I limited the number of values that were possible, but that’s
    a bit of a cheat, isn’t it? As I said before, there is almost an infinite number
    of values possible. Fortunately, there is a way to limit the values through Python:
    `Literals`. `Literal` types allow you to restrict the variable to a very specific
    set of values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll change my earlier `Snack` class to employ `Literal` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if I try to instantiate these data classes with wrong values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I receive the following typechecker errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`Literals` were introduced in Python 3.8, and they are an invaluable way of
    restricting possible values of a variable. They are a little more lightweight
    than Python enumerations (which I’ll cover in [Chapter 8](part0012_split_000.html#enum)).'
  prefs: []
  type: TYPE_NORMAL
- en: Annotated Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if I wanted to get even deeper and specify more complex constraints? It
    would be tedious to write hundreds of literals, and some constraints aren’t able
    to be modeled by `Literal` types. There’s no way with a `Literal` to constrain
    a string to a certain size or to match a specific regular expression. This is
    where `Annotated` comes in. With `Annotated`, you can specify arbitrary metadata
    alongside your type annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, the above code will not run, as `ValueRange` and `MatchesRegex`
    are not built-in types; they are arbitrary expressions. You will need to write
    your own metadata as part of an `Annotated` variable. Secondly, there are no tools
    that will typecheck this for you. The best you can do until such a tool exists
    is write dummy annotations or use strings to describe your constraints. At this
    point, `Annotated` is best served as a communication method.
  prefs: []
  type: TYPE_NORMAL
- en: NewType
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While waiting for tooling to support `Annotated`, there is another way to represent
    more complicated constraints: `NewType`. `NewType` allows you to, well, create
    a new type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose I want to separate my hot dog stand code to handle two separate cases:
    a hot dog in its unservable form (no plate, no napkins) and a hot dog that is
    ready to serve (plated, with napkins). In my code, there exist some functions
    that should only be operating on the hot dog in one case or the other. For example,
    an unservable hot dog should never be dispensed to the customer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: However, nothing prevents someone from passing in an unservable hot dog. If
    a developer makes a mistake and passes an unservable hot dog to this function,
    customers will be quite surprised to see just their order with no plate or napkins
    come out of the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than relying on developers to catch these errors whenever they happen,
    you need a way for your typechecker to catch this. To do that, you can use `NewType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A `NewType` takes an existing type and creates a brand new type that has all
    the same fields and methods as the existing type. In this case, I am creating
    a type `ReadyToServeHotDog` that is distinct from `HotDog`; they are not interchangeable.
    What’s beautiful about this is that this type restricts implicit type conversions.
    You cannot use a `HotDog` anywhere you are expecting a `ReadyToServeHotDog` (you
    can use a `ReadyToServeHotDog` in place of `HotDog`, though). In the previous
    example, I am restricting `dispense_to_customer` to only take `ReadyToServeHotDog`
    values as an argument. This prevents developers from invalidating assumptions.
    If a developer were to pass a `HotDog` to this method, the typechecker will yell
    at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It is important to stress the one-way nature of this type conversion. As a developer,
    you can control when your old type becomes your new type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I’ll create a function that takes a unservable `HotDog` and makes
    it ready to serve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice how I’m explicitly returning a `ReadyToServeHotDog` instead of a normal
    `HotDog`. This acts as a “blessed” function; it is the only sanctioned way that
    I want developers to create a `ReadyToServeHotDog`. Any user trying to use a method
    that takes a `ReadyToServeHotDog` needs to create it using `prepare_for_serving`
    first.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to notify users that the only way to create your new type is
    through a set of “blessed” functions. You don’t want users creating your new type
    in any circumstance other than a predetermined method, as that defeats the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, Python has no great way of telling users this, other than a comment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Still, `NewType` is applicable to many real-world scenarios. For example, these
    are all scenarios that I’ve run into that a `NewType` would solve:'
  prefs: []
  type: TYPE_NORMAL
- en: Separating a `str` from a `SanitizedString`, to catch bugs like SQL injection
    vulnerabilities. By making `SanitizedString` a `NewType`, I made sure that only
    properly sanitized strings were operated upon, eliminating the chance of SQL injection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking a `User` object and `LoggedInUser` separately. By restricting `Users`
    with `NewType` from `LoggedInUser`, I wrote functions that were only applicable
    to users that were logged in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking an integer that should represent a valid User ID. By restricting the
    User ID to a `NewType`, I could make sure that some functions were only operating
    on IDs that were valid, without having to check `if` statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 10](part0014_split_000.html#classes), you’ll see how you can use
    classes and invariants to do something very similar, with a much stronger guarantee
    of avoiding illegal states. However, `NewType` is still a useful pattern to be
    aware of, and is much more lightweight than a full-blown class.
  prefs: []
  type: TYPE_NORMAL
- en: Final Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally (pun intended), you may want to restrict a type from changing its value.
    That’s where `Final` comes in. `Final`, introduced in Python 3.8, indicates to
    a typechecker that a variable cannot be bound to another value. For instance,
    I want to start franchising out my hot dog stand, but I don’t want the name to
    be changed by accident.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If a developer accidentally changed the name later on, they would see an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In general, `Final` is best used when the variable’s scope spans a large amount
    of code, such as a module. It is difficult for developers to keep track of all
    the uses of a variable in such large scopes; letting the typechecker catch immutability
    guarantees is a boon in these cases.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Final` will not error out when mutating an object through a function. It only
    prevents the variable from being rebound (set to a new value).'
  prefs: []
  type: TYPE_NORMAL
- en: Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve learned about many different ways to constrain your types in this chapter.
    All of them serve a specific purpose, from handling `None` with `Optional` to
    restricting to specific values with `Literal` to preventing a variable from being
    rebound with `Final`. By using these techniques, you’ll be able to encode assumptions
    and restrictions directly into your codebase, preventing future readers from needing
    to guess about your logic. Typecheckers will use these advanced type annotations
    to provide you with stricter guarantees about your code, which will give maintainers
    confidence when working in your codebase. With this confidence, they will make
    fewer mistakes, and your codebase will become more robust because of it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll move on from type annotating single values, and
    learn how to properly annotate collection types. Collection types pervade most
    of Python; you must take care to express your intentions for them as well. You
    need to be well-versed in all the ways you can represent a collection, including
    in cases where you must create your own.
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](part0007_split_001.html#idm45644755819000-marker)) C.A.R. Hoare. “Null
    References: The Billion Dollar Mistake.” *Historically Bad Ideas*. Presented at
    Qcon London 2009, n.d.'
  prefs: []
  type: TYPE_NORMAL
