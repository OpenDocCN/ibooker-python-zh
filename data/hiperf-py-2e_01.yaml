- en: Chapter 1\. Understanding Performant Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。理解高性能Python
- en: Programming computers can be thought of as moving bits of data and transforming
    them in special ways to achieve a particular result. However, these actions have
    a time cost. Consequently, *high performance programming* can be thought of as
    the act of minimizing these operations either by reducing the overhead (i.e.,
    writing more efficient code) or by changing the way that we do these operations
    to make each one more meaningful (i.e., finding a more suitable algorithm).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程计算机可以被认为是移动数据位并以特定方式转换它们以达到特定结果。然而，这些操作都需要时间成本。因此，*高性能编程*可以被看作是通过减少这些操作的开销（即编写更高效的代码）或者改变执行操作的方式来使每个操作更有意义（即找到更合适的算法）的行为。
- en: Let’s focus on reducing the overhead in code in order to gain more insight into
    the actual hardware on which we are moving these bits. This may seem like a futile
    exercise, since Python works quite hard to abstract away direct interactions with
    the hardware. However, by understanding both the best way that bits can be moved
    in the real hardware and the ways that Python’s abstractions force your bits to
    move, you can make progress toward writing high performance programs in Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于减少代码中的开销，以便更深入地了解我们在其中移动这些位的实际硬件。这可能看起来像是一个徒劳的练习，因为Python很努力地抽象出直接与硬件的交互。然而，通过了解在实际硬件中位移的最佳方式以及Python抽象如何强制您的位移动，您可以在编写Python高性能程序方面取得进展。
- en: The Fundamental Computer System
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本计算机系统
- en: 'The underlying components that make up a computer can be simplified into three
    basic parts: the computing units, the memory units, and the connections between
    them. In addition, each of these units has different properties that we can use
    to understand them. The computational unit has the property of how many computations
    it can do per second, the memory unit has the properties of how much data it can
    hold and how fast we can read from and write to it, and finally, the connections
    have the property of how fast they can move data from one place to another.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 组成计算机的基本组件可以简化为三个基本部分：计算单元、存储单元和它们之间的连接。此外，这些单元每个都有不同的属性，我们可以用来理解它们。计算单元具有每秒可以执行多少次计算的属性，存储单元具有数据容量和读写速度的属性，最后，连接具有从一个地方移动数据到另一个地方的速度属性。
- en: 'Using these building blocks, we can talk about a standard workstation at multiple
    levels of sophistication. For example, the standard workstation can be thought
    of as having a central processing unit (CPU) as the computational unit, connected
    to both the random access memory (RAM) and the hard drive as two separate memory
    units (each having different capacities and read/write speeds), and finally a
    bus that provides the connections between all of these parts. However, we can
    also go into more detail and see that the CPU itself has several memory units
    in it: the L1, L2, and sometimes even the L3 and L4 cache, which have small capacities
    but very fast speeds (from several kilobytes to a dozen megabytes). Furthermore,
    new computer architectures generally come with new configurations (for example,
    Intel’s SkyLake CPUs replaced the frontside bus with the Intel Ultra Path Interconnect
    and restructured many connections). Finally, in both of these approximations of
    a workstation we have neglected the network connection, which is effectively a
    very slow connection to potentially many other computing and memory units!'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些构建块，我们可以在多个复杂程度的级别上讨论标准工作站。例如，标准工作站可以被视为具有中央处理单元（CPU）作为计算单元，连接到随机存取存储器（RAM）和硬盘作为两个单独的存储单元（每个具有不同的容量和读写速度），最后有一条总线连接所有这些部件。然而，我们也可以更详细地了解到CPU本身有几个内存单元：L1、L2，有时甚至是L3和L4缓存，这些缓存容量虽小但速度非常快（从几KB到数十MB）。此外，新的计算机架构通常配备新的配置（例如，Intel的SkyLake
    CPU用Intel Ultra Path Interconnect替换了前端总线并重构了许多连接）。最后，在这两种工作站的近似中，我们忽略了网络连接，这实际上是与潜在的许多其他计算和内存单元连接的非常慢的连接！
- en: To help untangle these various intricacies, let’s go over a brief description
    of these fundamental blocks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助理清这些复杂的细节，让我们简要描述一下这些基本组件。
- en: Computing Units
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算单元
- en: The *computing unit* of a computer is the centerpiece of its usefulness—it provides
    the ability to transform any bits it receives into other bits or to change the
    state of the current process. CPUs are the most commonly used computing unit;
    however, graphics processing units (GPUs) are gaining popularity as auxiliary
    computing units. They were originally used to speed up computer graphics but are
    becoming more applicable for numerical applications and are useful thanks to their
    intrinsically parallel nature, which allows many calculations to happen simultaneously.
    Regardless of its type, a computing unit takes in a series of bits (for example,
    bits representing numbers) and outputs another set of bits (for example, bits
    representing the sum of those numbers). In addition to the basic arithmetic operations
    on integers and real numbers and bitwise operations on binary numbers, some computing
    units also provide very specialized operations, such as the “fused multiply add”
    operation, which takes in three numbers, `A`, `B`, and `C`, and returns the value
    `A * B + C`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的*计算单元*是其实用性的中心 - 它提供了将其接收的任何位转换为其他位或更改当前进程状态的能力。 CPU是最常用的计算单元; 但是，图形处理单元（GPU）作为辅助计算单元正在增加其流行度。
    它们最初用于加速计算机图形，但由于其固有的并行特性而越来越适用于数值应用程序。 这允许许多计算同时进行。 无论其类型如何，计算单元接收一系列位（例如，表示数字的位）并输出另一组位（例如，表示这些数字之和的位）。
    除了对整数和实数的基本算术运算以及对二进制数的按位操作之外，某些计算单元还提供非常专门化的操作，例如“融合乘加”操作，该操作接收三个数字`A`、`B`和`C`，并返回值`A
    * B + C`。
- en: The main properties of interest in a computing unit are the number of operations
    it can do in one cycle and the number of cycles it can do in one second. The first
    value is measured by its instructions per cycle (IPC),^([1](ch01_split_001.xhtml#idm46122429262840))
    while the latter value is measured by its clock speed. These two measures are
    always competing with each other when new computing units are being made. For
    example, the Intel Core series has a very high IPC but a lower clock speed, while
    the Pentium 4 chip has the reverse. GPUs, on the other hand, have a very high
    IPC and clock speed, but they suffer from other problems like the slow communications
    that we discuss in [“Communications Layers”](ch01_split_000.xhtml#understanding_pp_communication).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 计算单元的主要关注属性是它可以在一个周期内执行的操作数以及它可以在一秒内执行的周期数。 第一个值由其每周期指令数（IPC）^[1]（ch01_split_001.xhtml#idm46122429262840）衡量，而后一个值由其时钟速度衡量。
    这两个度量值在制造新计算单元时总是互相竞争。 例如，Intel Core系列具有非常高的IPC但较低的时钟速度，而Pentium 4芯片则相反。 另一方面，GPU具有非常高的IPC和时钟速度，但它们遭受了其他问题的困扰，例如我们在“通信层”中讨论的慢通信。
- en: Furthermore, although increasing clock speed almost immediately speeds up all
    programs running on that computational unit (because they are able to do more
    calculations per second), having a higher IPC can also drastically affect computing
    by changing the level of *vectorization* that is possible. Vectorization occurs
    when a CPU is provided with multiple pieces of data at a time and is able to operate
    on all of them at once. This sort of CPU instruction is known as single instruction,
    multiple data (SIMD).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，虽然增加时钟速度几乎立即加快了所有在计算单元上运行的程序（因为它们能够每秒执行更多计算），但更高的IPC也可以通过改变可能的*向量化*水平，从而
    drasticaly 影响计算。 向量化发生在CPU一次提供多个数据片段并且能够同时对所有数据执行操作时。 这种CPU指令被称为单指令，多数据（SIMD）。
- en: In general, computing units have advanced quite slowly over the past decade
    (see [Figure 1-1](ch01_split_000.xhtml#FIG-performant-historical-clock)). Clock
    speeds and IPC have both been stagnant because of the physical limitations of
    making transistors smaller and smaller. As a result, chip manufacturers have been
    relying on other methods to gain more speed, including simultaneous multithreading
    (where multiple threads can run at once), more clever out-of-order execution,
    and multicore architectures.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，过去十年来计算单元的进展相当缓慢（参见[图1-1](ch01_split_000.xhtml#FIG-performant-historical-clock)）。
    由于使晶体管变得越来越小的物理限制，时钟速度和IPC都停滞不前。 因此，芯片制造商一直依赖其他方法来获得更多速度，包括同时多线程（多个线程可以同时运行），更巧妙的乱序执行和多核架构。
- en: Hyperthreading presents a virtual second CPU to the host operating system (OS),
    and clever hardware logic tries to interleave two threads of instructions into
    the execution units on a single CPU. When successful, gains of up to 30% over
    a single thread can be achieved. Typically, this works well when the units of
    work across both threads use different types of execution units—for example, one
    performs floating-point operations and the other performs integer operations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 超线程向主机操作系统（OS）提供了一个虚拟的第二个 CPU，并且聪明的硬件逻辑尝试将两个指令线程交错到单个 CPU 的执行单元中。成功时，可以比单线程获得高达
    30% 的增益。通常情况下，当两个线程的工作单元使用不同类型的执行单元时，这种方法效果很好——例如，一个执行浮点运算，另一个执行整数运算。
- en: Out-of-order execution enables a compiler to spot that some parts of a linear
    program sequence do not depend on the results of a previous piece of work, and
    therefore that both pieces of work could occur in any order or at the same time.
    As long as sequential results are presented at the right time, the program continues
    to execute correctly, even though pieces of work are computed out of their programmed
    order. This enables some instructions to execute when others might be blocked
    (e.g., waiting for a memory access), allowing greater overall utilization of the
    available resources.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 乱序执行使编译器能够发现线性程序序列的某些部分不依赖于前一个工作的结果，因此这两个工作可以以任何顺序或同时发生。只要按时呈现顺序结果，程序就可以继续正确执行，即使工作片段是按照非编程顺序计算的。这使得一些指令可以在其他指令可能被阻塞（例如，等待内存访问）时执行，从而允许更大的可用资源的整体利用率。
- en: Finally, and most important for the higher-level programmer, there is the prevalence
    of multicore architectures. These architectures include multiple CPUs within the
    same unit, which increases the total capability without running into barriers
    to making each individual unit faster. This is why it is currently hard to find
    any machine with fewer than two cores—in this case, the computer has two physical
    computing units that are connected to each other. While this increases the total
    number of operations that *can* be done per second, it can make writing code more
    difficult!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级程序员来说，最后也是最重要的是多核架构的普及。这些架构在同一单元内包含多个 CPU，这增加了总体能力，而不会遇到使每个单元变得更快的障碍。这就是为什么目前很难找到少于两个核心的任何机器——在这种情况下，计算机有两个物理计算单元彼此连接。虽然这增加了每秒钟*可以*完成的总操作数量，但这可能会使编写代码变得更加困难！
- en: Figure 1-1\. Clock speed of CPUs over time (from [CPU DB](https://oreil.ly/JnJt2))
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. CPU 随时间的时钟速度（来自[CPU 数据库](https://oreil.ly/JnJt2)）
- en: 'Simply adding more cores to a CPU does not always speed up a program’s execution
    time. This is because of something known as [*Amdahl’s law*](https://oreil.ly/GC2CK).
    Simply stated, Amdahl’s law is this: if a program designed to run on multiple
    cores has some subroutines that must run on one core, this will be the limitation
    for the maximum speedup that can be achieved by allocating more cores.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地向 CPU 添加更多核心并不总是会加快程序的执行时间。这是因为有一种被称为[*安达尔定律*](https://oreil.ly/GC2CK)的东西。简单来说，安达尔定律是这样的：如果一个设计为在多个核心上运行的程序有一些子程序必须在一个核心上运行，这将限制通过分配更多核心来实现的最大加速度。
- en: For example, if we had a survey we wanted one hundred people to fill out, and
    that survey took 1 minute to complete, we could complete this task in 100 minutes
    if we had one person asking the questions (i.e., this person goes to participant
    1, asks the questions, waits for the responses, and then moves to participant
    2). This method of having one person asking the questions and waiting for responses
    is similar to a serial process. In serial processes, we have operations being
    satisfied one at a time, each one waiting for the previous operation to complete.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个想让一百人填写的调查问卷，而且每份问卷需要 1 分钟完成，如果我们只有一个人问问题（即这个人去参与者 1，问问题，等待回答，然后移动到参与者
    2），我们可以在 100 分钟内完成这个任务。这种一个人问问题并等待回答的方法类似于串行过程。在串行过程中，我们有操作一个接一个地满足，每个操作等待前一个操作完成。
- en: However, we could perform the survey in parallel if we had two people asking
    the questions, which would let us finish the process in only 50 minutes. This
    can be done because each individual person asking the questions does not need
    to know anything about the other person asking questions. As a result, the task
    can easily be split up without having any dependency between the question askers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们有两个人来提问，我们可以并行进行调查，这样就能在短短的 50 分钟内完成整个过程。这是可能的，因为每个提问者都不需要知道其他提问者的信息。因此，这个任务可以轻松地分割，而不会有任何依赖关系。
- en: Adding more people asking the questions will give us more speedups, until we
    have one hundred people asking questions. At this point, the process would take
    1 minute and would be limited simply by the time it takes a participant to answer
    questions. Adding more people asking questions will not result in any further
    speedups, because these extra people will have no tasks to perform—all the participants
    are already being asked questions! At this point, the only way to reduce the overall
    time to run the survey is to reduce the amount of time it takes for an individual
    survey, the serial portion of the problem, to complete. Similarly, with CPUs,
    we can add more cores that can perform various chunks of the computation as necessary
    until we reach a point where the bottleneck is the time it takes for a specific
    core to finish its task. In other words, the bottleneck in any parallel calculation
    is always the smaller serial tasks that are being spread out.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多提问者将会带来更多的加速，直到我们有一百个人提问。在这一点上，过程将花费 1 分钟，并且仅仅受到参与者回答问题所花费的时间的限制。添加更多提问者不会进一步加速，因为这些额外的人将没有任务可执行
    —— 所有参与者已经在被提问！在这一点上，减少运行调查的总时间的唯一方法是减少个体调查的时间，即问题的串行部分，以完成。同样地，对于 CPU，我们可以添加更多的核心，根据需要执行各种计算的块，直到我们达到一个核心完成其任务所需的时间的瓶颈点。换句话说，任何并行计算中的瓶颈始终是正在分布的较小的串行任务。
- en: Furthermore, a major hurdle with utilizing multiple cores in Python is Python’s
    use of a *global interpreter lock* (GIL). The GIL makes sure that a Python process
    can run only one instruction at a time, regardless of the number of cores it is
    currently using. This means that even though some Python code has access to multiple
    cores at a time, only one core is running a Python instruction at any given time.
    Using the previous example of a survey, this would mean that even if we had 100
    question askers, only one person could ask a question and listen to a response
    at a time. This effectively removes any sort of benefit from having multiple question
    askers! While this may seem like quite a hurdle, especially if the current trend
    in computing is to have multiple computing units rather than having faster ones,
    this problem can be avoided by using other standard library tools, like `multiprocessing`
    ([Chapter 9](ch09_split_000.xhtml#multiprocessing)), technologies like `numpy`
    or `numexpr` ([Chapter 6](ch06_split_000.xhtml#matrix_computation)), Cython ([Chapter 7](ch07.xhtml#chapter-compiling)),
    or distributed models of computing ([Chapter 10](ch10.xhtml#clustering)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 Python 中利用多个核心的一个主要障碍是 *全局解释器锁*（GIL）。GIL 确保 Python 进程一次只能运行一个指令，而不管它当前使用多少个核心。这意味着即使某些
    Python 代码同时可以访问多个核心，但任何时候都只有一个核心在运行 Python 指令。使用调查的前述例子，这意味着即使我们有 100 个提问者，也只能有一个人提问并听取答案。这实际上消除了拥有多个提问者的任何好处！虽然这可能看起来是一个相当大的障碍，特别是如果当前计算的趋势是拥有多个计算单元而不是更快的计算单元，但可以通过使用其他标准库工具来避免这个问题，比如
    `multiprocessing`（[第 9 章](ch09_split_000.xhtml#multiprocessing)），像 `numpy` 或 `numexpr`（[第
    6 章](ch06_split_000.xhtml#matrix_computation)），Cython（[第 7 章](ch07.xhtml#chapter-compiling)），或计算的分布式模型（[第
    10 章](ch10.xhtml#clustering)）。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Python 3.2 also saw [a major rewrite of the GIL](https://oreil.ly/W2ikf), which
    made the system much more nimble, alleviating many of the concerns around the
    system for single-thread performance. Although it still locks Python into running
    only one instruction at a time, the GIL now does better at switching between those
    instructions and doing so with less overhead.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.2 还进行了 [全局解释器锁（GIL）的重大改写](https://oreil.ly/W2ikf)，这使得系统更加灵活，缓解了关于单线程性能的许多担忧。尽管它仍然将
    Python 锁定在一次只能运行一个指令的状态，但现在 GIL 在这些指令之间更加高效地切换，并且开销更小。
- en: Memory Units
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储单位
- en: '*Memory units* in computers are used to store bits. These could be bits representing
    variables in your program or bits representing the pixels of an image. Thus, the
    abstraction of a memory unit applies to the registers in your motherboard as well
    as your RAM and hard drive. The one major difference between all of these types
    of memory units is the speed at which they can read/write data. To make things
    more complicated, the read/write speed is heavily dependent on the way that data
    is being read.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机中的*内存单元*用于存储位。这些位可以是表示程序中变量的位，也可以是表示图像像素的位。因此，内存单元的抽象适用于主板上的寄存器以及RAM和硬盘驱动器。所有这些类型的内存单元之间的一个主要区别在于它们读/写数据的速度。为了让事情变得更加复杂，读/写速度严重依赖于数据读取的方式。
- en: For example, most memory units perform much better when they read one large
    chunk of data as opposed to many small chunks (this is referred to as *sequential
    read* versus *random data*). If the data in these memory units is thought of as
    pages in a large book, this means that most memory units have better read/write
    speeds when going through the book page by page rather than constantly flipping
    from one random page to another. While this fact is generally true across all
    memory units, the amount that this affects each type is drastically different.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，大多数内存单元在读取一大块数据时表现得更好，而不是许多小块数据（这称为*顺序读*与*随机数据*）。如果将这些内存单元中的数据视为大书中的页面，这意味着大多数内存单元在一页一页地翻书时具有更好的读/写速度，而不是不断地从一个随机页面翻到另一个页面。虽然这个事实通常适用于所有类型的内存单元，但这种影响每种类型的程度却是截然不同的。
- en: In addition to the read/write speeds, memory units also have *latency*, which
    can be characterized as the time it takes the device to find the data that is
    being used. For a spinning hard drive, this latency can be high because the disk
    needs to physically spin up to speed and the read head must move to the right
    position. On the other hand, for RAM, this latency can be quite small because
    everything is solid state. Here is a short description of the various memory units
    that are commonly found inside a standard workstation, in order of read/write
    speeds:^([2](ch01_split_001.xhtml#idm46122428772888))
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了读/写速度之外，内存单元还有*延迟*，这可以被描述为设备找到正在使用的数据所需的时间。对于旋转硬盘来说，这种延迟可能很高，因为磁盘需要物理上旋转到速度，并且读取头必须移动到正确的位置。另一方面，对于RAM来说，这种延迟可以相当小，因为一切都是固态的。以下是标准工作站内常见的各种内存单元的简短描述，按照读/写速度的顺序排列：^([2](ch01_split_001.xhtml#idm46122428772888))
- en: Spinning hard drive
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转硬盘
- en: Long-term storage that persists even when the computer is shut down. Generally
    has slow read/write speeds because the disk must be physically spun and moved.
    Degraded performance with random access patterns but very large capacity (10 terabyte
    range).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 长期存储，即使计算机关闭也会保持。由于必须物理旋转和移动磁盘，因此通常具有较慢的读/写速度。随机访问模式下性能下降，但容量非常大（10 TB 范围）。
- en: Solid-state hard drive
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 固态硬盘
- en: Similar to a spinning hard drive, with faster read/write speeds but smaller
    capacity (1 terabyte range).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于旋转硬盘，具有更快的读/写速度但较小的容量（1 TB 范围）。
- en: RAM
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: RAM
- en: Used to store application code and data (such as any variables being used).
    Has fast read/write characteristics and performs well with random access patterns,
    but is generally limited in capacity (64 gigabyte range).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储应用程序代码和数据（如正在使用的任何变量）。具有快速读/写特性，并且在随机访问模式下表现良好，但通常容量有限（64 GB 范围）。
- en: L1/L2 cache
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: L1/L2 缓存
- en: Extremely fast read/write speeds. Data going to the CPU *must* go through here.
    Very small capacity (megabytes range).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 非常快的读/写速度。数据传输到CPU *必须* 经过这里。非常小的容量（兆字节范围）。
- en: '[Figure 1-2](ch01_split_000.xhtml#FIG-performant-memory-units) gives a graphic
    representation of the differences between these types of memory units by looking
    at the characteristics of currently available consumer hardware.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-2](ch01_split_000.xhtml#FIG-performant-memory-units)通过查看当前可用消费类硬件的特性，给出了这些类型内存单元之间差异的图形表示。'
- en: 'A clearly visible trend is that read/write speeds and capacity are inversely
    proportional—as we try to increase speed, capacity gets reduced. Because of this,
    many systems implement a tiered approach to memory: data starts in its full state
    in the hard drive, part of it moves to RAM, and then a much smaller subset moves
    to the L1/L2 cache. This method of tiering enables programs to keep memory in
    different places depending on access speed requirements. When trying to optimize
    the memory patterns of a program, we are simply optimizing which data is placed
    where, how it is laid out (in order to increase the number of sequential reads),
    and how many times it is moved among the various locations. In addition, methods
    such as asynchronous I/O and preemptive caching provide ways to make sure that
    data is always where it needs to be without having to waste computing time—most
    of these processes can happen independently, while other calculations are being
    performed!'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的趋势是，读/写速度和容量成反比—我们试图增加速度时，容量就会减少。因此，许多系统采用分层存储的方法：数据最初以完整状态存储在硬盘中，部分数据移至RAM，然后其中的一小部分再移至L1/L2缓存。这种分层存储的方法使得程序可以根据访问速度的要求将内存保留在不同的位置。当试图优化程序的内存模式时，我们只是在优化数据放置在哪里、如何布局（以增加连续读取的次数）以及在各个位置之间移动多少次。此外，诸如异步I/O和抢占式缓存等方法提供了确保数据始终位于需要的位置的方式，而无需浪费计算时间——大多数这些过程可以独立进行，而其他计算正在执行！
- en: '![Memory Characteristics](Images/hpp2_0102.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![内存特性](Images/hpp2_0102.png)'
- en: Figure 1-2\. Characteristic values for different types of memory units (values
    from February 2014)
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. 不同类型内存单元的特征值（值来自2014年2月）
- en: Communications Layers
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信层
- en: Finally, let’s look at how all of these fundamental blocks communicate with
    each other. Many modes of communication exist, but all are variants on a thing
    called a *bus*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看所有这些基本模块是如何相互通信的。存在许多通信模式，但所有这些模式都是对一种称为*总线*的东西的变体。
- en: The *frontside bus*, for example, is the connection between the RAM and the
    L1/L2 cache. It moves data that is ready to be transformed by the processor into
    the staging ground to get ready for calculation, and it moves finished calculations
    out. There are other buses, too, such as the external bus that acts as the main
    route from hardware devices (such as hard drives and networking cards) to the
    CPU and system memory. This external bus is generally slower than the frontside
    bus.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*前端总线*是RAM和L1/L2缓存之间的连接。它将准备好被处理器转换的数据移入到准备进行计算的暂存区，并将已完成的计算移出。还有其他总线，例如外部总线，它是从硬件设备（如硬盘驱动器和网络卡）到CPU和系统内存的主要路由。这个外部总线通常比前端总线慢。
- en: In fact, many of the benefits of the L1/L2 cache are attributable to the faster
    bus. Being able to queue up data necessary for computation in large chunks on
    a slow bus (from RAM to cache) and then having it available at very fast speeds
    from the cache lines (from cache to CPU) enables the CPU to do more calculations
    without waiting such a long time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，L1/L2缓存的许多好处都归因于更快的总线。在缓慢的总线上（从RAM到缓存）可以排队等待计算所需数据的大块数据，然后在非常快速的缓存行（从缓存到CPU）中可以访问这些数据，这使得CPU在无需等待太长时间的情况下可以进行更多计算。
- en: 'Similarly, many of the drawbacks of using a GPU come from the bus it is connected
    on: since the GPU is generally a peripheral device, it communicates through the
    PCI bus, which is much slower than the frontside bus. As a result, getting data
    into and out of the GPU can be quite a taxing operation. The advent of heterogeneous
    computing, or computing blocks that have both a CPU and a GPU on the frontside
    bus, aims at reducing the data transfer cost and making GPU computing more of
    an available option, even when a lot of data must be transferred.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用GPU的许多缺点来自其连接的总线：由于GPU通常是一个外围设备，它通过PCI总线进行通信，而PCI总线比前端总线慢得多。因此，将数据传输到GPU和从GPU传输数据可能是一项相当耗费精力的操作。异构计算的出现，或者在前端总线上同时具有CPU和GPU的计算块，旨在降低数据传输成本，并使GPU计算成为更可行的选项，即使在必须传输大量数据时也是如此。
- en: In addition to the communication blocks within the computer, the network can
    be thought of as yet another communication block. This block, though, is much
    more pliable than the ones discussed previously; a network device can be connected
    to a memory device, such as a network attached storage (NAS) device or another
    computing block, as in a computing node in a cluster. However, network communications
    are generally much slower than the other types of communications mentioned previously.
    While the frontside bus can transfer dozens of gigabits per second, the network
    is limited to the order of several dozen megabits.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了计算机内部的通信块之外，网络也可以被视为另一个通信块。然而，与先前讨论过的通信块不同，这个通信块更加灵活；网络设备可以连接到存储设备，比如网络附加存储（NAS）设备，或者连接到集群中的计算节点。然而，网络通信通常比先前提到的其他类型的通信慢得多。虽然前端总线可以每秒传输几十个千兆位，但网络的传输速度仅限于数十兆位的数量级。
- en: 'It is clear, then, that the main property of a bus is its speed: how much data
    it can move in a given amount of time. This property is given by combining two
    quantities: how much data can be moved in one transfer (bus width) and how many
    transfers the bus can do per second (bus frequency). It is important to note that
    the data moved in one transfer is always sequential: a chunk of data is read off
    of the memory and moved to a different place. Thus, the speed of a bus is broken
    into these two quantities because individually they can affect different aspects
    of computation: a large bus width can help vectorized code (or any code that sequentially
    reads through memory) by making it possible to move all the relevant data in one
    transfer, while, on the other hand, having a small bus width but a very high frequency
    of transfers can help code that must do many reads from random parts of memory.
    Interestingly, one of the ways that these properties are changed by computer designers
    is by the physical layout of the motherboard: when chips are placed close to one
    another, the length of the physical wires joining them is smaller, which can allow
    for faster transfer speeds. In addition, the number of wires itself dictates the
    width of the bus (giving real physical meaning to the term!).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，巴士的主要属性显而易见：它的速度，即在一定时间内能够传输多少数据。这一属性由两个量合成：一次传输可以移动多少数据（巴士宽度）和巴士每秒可以进行多少次传输（巴士频率）。需要注意的是，一次传输的数据总是顺序的：从内存中读取一块数据并移动到另一个地方。因此，巴士的速度被分解为这两个量，因为它们各自可以影响计算的不同方面：较大的巴士宽度可以帮助矢量化代码（或任何顺序读取内存的代码），因为它可以在一次传输中移动所有相关数据；另一方面，虽然巴士宽度较小，但传输频率非常高，可以帮助那些必须从内存的随机部分进行多次读取的代码。有趣的是，这些属性被计算机设计师改变的一种方式是通过主板的物理布局：当芯片彼此靠近放置时，连接它们的物理导线长度较短，这可以实现更快的传输速度。此外，导线的数量本身决定了巴士的宽度（给“巴士宽度”这一术语赋予了真实的物理意义！）。
- en: Since interfaces can be tuned to give the right performance for a specific application,
    it is no surprise that there are hundreds of types. [Figure 1-3](ch01_split_000.xhtml#FIG-performant-connection-speed)
    shows the bitrates for a sampling of common interfaces. Note that this doesn’t
    speak at all about the latency of the connections, which dictates how long it
    takes for a data request to be responded to (although latency is very computer-dependent,
    some basic limitations are inherent to the interfaces being used).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接口可以调整以提供特定应用程序所需的正确性能，因此不足为奇，会有数百种类型存在。[图 1-3](ch01_split_000.xhtml#FIG-performant-connection-speed)显示了几种常见接口的比特率。请注意，这并没有涉及连接的延迟，后者决定了数据请求的响应时间（尽管延迟非常依赖于计算机本身，但某些基本限制是固有于所使用的接口的）。
- en: '![Connection Speeds](Images/hpp2_0103.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![连接速度](Images/hpp2_0103.png)'
- en: Figure 1-3\. Connection speeds of various common interfaces^([3](ch01_split_001.xhtml#idm46122429019976))
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-3\. 各种常见接口的连接速度^([3](ch01_split_001.xhtml#idm46122429019976))
- en: Putting the Fundamental Elements Together
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将基本元素组合在一起
- en: Understanding the basic components of a computer is not enough to fully understand
    the problems of high performance programming. The interplay of all of these components
    and how they work together to solve a problem introduces extra levels of complexity.
    In this section we will explore some toy problems, illustrating how the ideal
    solutions would work and how Python approaches them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 仅了解计算机的基本组件是不足以完全理解高性能编程问题的。所有这些组件之间的相互作用以及它们如何共同解决问题，引入了额外的复杂性。在本节中，我们将探讨一些玩具问题，说明理想解决方案将如何工作以及Python如何处理它们。
- en: 'A warning: this section may seem bleak—most of the remarks in this section
    seem to say that Python is natively incapable of dealing with the problems of
    performance. This is untrue, for two reasons. First, among all of the “components
    of performant computing,” we have neglected one very important component: the
    developer. What native Python may lack in performance, it gets back right away
    with speed of development. Furthermore, throughout the book we will introduce
    modules and philosophies that can help mitigate many of the problems described
    here with relative ease. With both of these aspects combined, we will keep the
    fast development mindset of Python while removing many of the performance constraints.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：这一部分可能看起来暗淡无光 —— 这一部分的大多数备注似乎都在说Python本质上无法处理性能问题。这是不正确的，有两个原因。首先，在所有“高性能计算组件”中，我们忽略了一个非常重要的组件：开发人员。原生Python在性能上可能缺乏，但它立即以开发速度弥补了这一点。此外，在整本书中，我们将介绍可以相对轻松地缓解许多在此描述的问题的模块和理念。通过结合这两个方面，我们将保持Python的快速开发思维方式，同时消除许多性能限制。
- en: Idealized Computing Versus the Python Virtual Machine
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想化计算与Python虚拟机
- en: 'To better understand the components of high performance programming, let’s
    look at a simple code sample that checks whether a number is prime:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解高性能编程的组成部分，让我们看一个简单的代码示例，检查一个数是否为素数：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s analyze this code using our abstract model of computation and then draw
    comparisons to what happens when Python runs this code. As with any abstraction,
    we will neglect many of the subtleties in both the idealized computer and the
    way that Python runs the code. However, this is generally a good exercise to perform
    before solving a problem: think about the general components of the algorithm
    and what would be the best way for the computing components to come together to
    find a solution. By understanding this ideal situation and having knowledge of
    what is actually happening under the hood in Python, we can iteratively bring
    our Python code closer to the optimal code.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的抽象计算模型来分析这段代码，然后将其与Python运行此代码时发生的情况进行比较。与任何抽象一样，我们将忽略理想化计算机和Python运行代码的许多微妙之处。然而，在解决问题之前进行这种抽象思考通常是一个好方法：思考算法的一般组件以及计算组件共同解决问题的最佳方式是什么。通过理解这种理想情况，并了解Python底层实际发生的情况，我们可以迭代地将我们的Python代码接近最佳代码。
- en: Idealized computing
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理想化计算
- en: When the code starts, we have the value of `number` stored in RAM. To calculate
    `sqrt_number`, we need to send the value of `number` to the CPU. Ideally, we could
    send the value once; it would get stored inside the CPU’s L1/L2 cache, and the
    CPU would do the calculations and then send the values back to RAM to get stored.
    This scenario is ideal because we have minimized the number of reads of the value
    of `number` from RAM, instead opting for reads from the L1/L2 cache, which are
    much faster. Furthermore, we have minimized the number of data transfers through
    the frontside bus, by using the L1/L2 cache which is connected directly to the
    CPU.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码启动时，我们在RAM中存储了`number`的值。为了计算`sqrt_number`，我们需要将`number`的值发送到CPU。理想情况下，我们可以只发送一次值；它将被存储在CPU的L1/L2缓存中，并且CPU将进行计算，然后将值发送回RAM以进行存储。这种情况是理想的，因为我们最小化了从RAM读取`number`值的次数，而是选择了从L1/L2缓存读取，后者速度要快得多。此外，我们通过使用直接连接到CPU的L1/L2缓存，最小化了通过前端总线传输数据的次数。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: This theme of keeping data where it is needed and moving it as little as possible
    is very important when it comes to optimization. The concept of “heavy data” refers
    to the time and effort required to move data around, which is something we would
    like to avoid.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化方面，保持数据在需要的地方并尽量少移动数据的概念非常重要。“重数据”的概念指的是移动数据所需的时间和精力，这是我们希望避免的。
- en: For the loop in the code, rather than sending one value of `i` at a time to
    the CPU, we would like to send both `number` and *several* values of `i` to the
    CPU to check at the same time. This is possible because the CPU vectorizes operations
    with no additional time cost, meaning it can do multiple independent computations
    at the same time. So we want to send `number` to the CPU cache, in addition to
    as many values of `i` as the cache can hold. For each of the `number`/`i` pairs,
    we will divide them and check if the result is a whole number; then we will send
    a signal back indicating whether any of the values was indeed an integer. If so,
    the function ends. If not, we repeat. In this way, we need to communicate back
    only one result for many values of `i`, rather than depending on the slow bus
    for every value. This takes advantage of a CPU’s ability to *vectorize* a calculation,
    or run one instruction on multiple data in one clock cycle.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码中的循环，我们希望将`number`值和多个`i`的值一起发送到CPU，而不是每次仅发送一个`i`值。这是可能的，因为CPU可以向量化操作而不会增加额外的时间成本，这意味着它可以在同一时钟周期内对多个独立的计算进行操作。因此，我们希望将`number`发送到CPU缓存，以及尽可能多的`i`值，CPU缓存可以容纳多少就发送多少。对于每个`number`/`i`对，我们将进行除法运算并检查结果是否为整数；然后我们将发送一个信号返回，指示是否确实有任何值是整数。如果是，则函数结束。如果不是，则重复上述过程。通过这种方式，我们只需为许多`i`的值之一返回一个结果，而不是为每个值都依赖慢速总线。这充分利用了CPU在一个时钟周期内*向量化*计算或在多个数据上运行一条指令的能力。
- en: 'This concept of vectorization is illustrated by the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个向量化的概念可以通过以下代码进行说明：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we set up the processing such that the division and the checking for integers
    are done on a set of five values of `i` at a time. If properly vectorized, the
    CPU can do this line in one step as opposed to doing a separate calculation for
    every `i`. Ideally, the `any(result)` operation would also happen in the CPU without
    having to transfer the results back to RAM. We will talk more about vectorization,
    how it works, and when it benefits your code in [Chapter 6](ch06_split_000.xhtml#matrix_computation).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置处理方式，使得每次处理五个`i`的值时进行除法运算和整数检查。如果正确进行向量化，CPU可以一次完成这一行，而不是对每个`i`进行单独的计算。理想情况下，`any(result)`操作也应在CPU上进行，而不必将结果传输回RAM。我们将在[第6章](ch06_split_000.xhtml#matrix_computation)更详细地讨论向量化的工作原理以及何时有益于你的代码。
- en: Python’s virtual machine
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python的虚拟机
- en: The Python interpreter does a lot of work to try to abstract away the underlying
    computing elements that are being used. At no point does a programmer need to
    worry about allocating memory for arrays, how to arrange that memory, or in what
    sequence it is being sent to the CPU. This is a benefit of Python, since it lets
    you focus on the algorithms that are being implemented. However, it comes at a
    huge performance cost.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器会尽力抽象出正在使用的底层计算元素。程序员在任何时候都不需要担心为数组分配内存、如何安排内存或发送到CPU的顺序。这是Python的一个优点，因为它让你专注于正在实现的算法。然而，这也导致了巨大的性能成本。
- en: 'It is important to realize that at its core, Python is indeed running a set
    of very optimized instructions. The trick, however, is getting Python to perform
    them in the correct sequence to achieve better performance. For example, it is
    quite easy to see that, in the following example, `search_fast` will run faster
    than `search_slow` simply because it skips the unnecessary computations that result
    from not terminating the loop early, even though both solutions have runtime `O(n)`.
    However, things can get complicated when dealing with derived types, special Python
    methods, or third-party modules. For example, can you immediately tell which function
    will be faster: `search_unknown1` or `search_unknown2`?'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，Python在其核心确实运行一组高度优化的指令。然而，关键在于让Python按照正确的顺序执行它们以获得更好的性能。例如，在下面的例子中，很容易看出`search_fast`比`search_slow`运行得更快，仅仅是因为它跳过了不必要的计算，尽管这两种解决方案的运行时间都是`O(n)`。然而，当涉及到派生类型、特殊的Python方法或第三方模块时，情况可能会变得复杂。例如，你能立即判断哪个函数会更快：`search_unknown1`还是`search_unknown2`？
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Identifying slow regions of code through profiling and finding more efficient
    ways of doing the same calculations is similar to finding these useless operations
    and removing them; the end result is the same, but the number of computations
    and data transfers is reduced drastically.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析性能并找到更高效的计算方式来识别代码中的慢速区域，类似于发现这些无用操作并将其删除；最终结果相同，但计算和数据传输的数量大大减少。
- en: One of the impacts of this abstraction layer is that vectorization is not immediately
    achievable. Our initial prime number routine will run one iteration of the loop
    per value of `i` instead of combining several iterations. However, looking at
    the abstracted vectorization example, we see that it is not valid Python code,
    since we cannot divide a float by a list. External libraries such as `numpy` will
    help with this situation by adding the ability to do vectorized mathematical operations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象层的一个影响是无法立即实现向量化。我们初始的素数判断例程将针对每个`i`的值运行一次循环迭代，而不是结合多次迭代。然而，观察抽象化的向量化示例，我们发现它并不是有效的
    Python 代码，因为我们不能将浮点数除以列表。外部库如`numpy`将通过添加执行向量化数学运算的能力来帮助解决这种情况。
- en: Furthermore, Python’s abstraction hurts any optimizations that rely on keeping
    the L1/L2 cache filled with the relevant data for the next computation. This comes
    from many factors, the first being that Python objects are not laid out in the
    most optimal way in memory. This is a consequence of Python being a garbage-collected
    language—memory is automatically allocated and freed when needed. This creates
    memory fragmentation that can hurt the transfers to the CPU caches. In addition,
    at no point is there an opportunity to change the layout of a data structure directly
    in memory, which means that one transfer on the bus may not contain all the relevant
    information for a computation, even though it might have all fit within the bus
    width.^([4](ch01_split_001.xhtml#idm46122435398952))
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python 的抽象性损害了依赖于保持 L1/L2 缓存填充下一个计算所需相关数据的任何优化。这源于多种因素，首先是 Python 对象在内存中的布局并不是最优的。这是
    Python 是一种自动进行垃圾回收的语言的一个后果——内存会在需要时自动分配和释放。这会导致内存碎片化，可能会损害到传输到 CPU 缓存的效果。此外，在任何时候，都没有机会直接在内存中更改数据结构的布局，这意味着总线上的一个传输可能不包含计算所需的所有相关信息，即使它们可能全部适合总线宽度内。^([4](ch01_split_001.xhtml#idm46122435398952))
- en: 'A second, more fundamental problem comes from Python’s dynamic types and the
    language not being compiled. As many C programmers have learned throughout the
    years, the compiler is often smarter than you are. When compiling code that is
    static, the compiler can do many tricks to change the way things are laid out
    and how the CPU will run certain instructions in order to optimize them. Python,
    however, is not compiled: to make matters worse, it has dynamic types, which means
    that inferring any possible opportunities for optimizations algorithmically is
    drastically harder since code functionality can be changed during runtime. There
    are many ways to mitigate this problem, foremost being the use of Cython, which
    allows Python code to be compiled and allows the user to create “hints” to the
    compiler as to how dynamic the code actually is.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个更根本的问题来自于 Python 的动态类型和语言的非编译特性。正如许多 C 程序员多年来所学到的，编译器通常比人更聪明。在编译静态代码时，编译器可以通过许多技巧改变事物的布局以及
    CPU 执行某些指令的方式，以进行优化。然而，Python 并不是编译的：更糟糕的是，它具有动态类型，这意味着在运行时可以更改代码功能，从而在算法上推断出任何可能的优化机会变得极其困难。有许多方法可以缓解这个问题，最重要的是使用
    Cython，它允许将 Python 代码编译，并允许用户创建“提示”，告诉编译器代码实际上有多动态。
- en: Finally, the previously mentioned GIL can hurt performance if trying to parallelize
    this code. For example, let’s assume we change the code to use multiple CPU cores
    such that each core gets a chunk of the numbers from 2 to `sqrtN`. Each core can
    do its calculation for its chunk of numbers, and then, when the calculations are
    all done, the cores can compare their calculations. Although we lose the early
    termination of the loop since each core doesn’t know if a solution has been found,
    we can reduce the number of checks each core has to do (if we had `M` cores, each
    core would have to do `sqrtN / M` checks). However, because of the GIL, only one
    core can be used at a time. This means that we would effectively be running the
    same code as the unparalleled version, but we no longer have early termination.
    We can avoid this problem by using multiple processes (with the `multiprocessing`
    module) instead of multiple threads, or by using Cython or foreign functions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，前面提到的 GIL 如果尝试并行化此代码会影响性能。例如，假设我们将代码更改为使用多个 CPU 核心，以便每个核心获得从 2 到 `sqrtN`
    的一部分数字。每个核心可以为其数字块执行计算，然后在所有计算完成后，核心可以比较其计算结果。虽然我们失去了循环的早期终止，因为每个核心不知道是否找到解决方案，但我们可以减少每个核心需要执行的检查数量（如果我们有
    `M` 个核心，则每个核心必须执行 `sqrtN / M` 次检查）。然而，由于 GIL 的存在，一次只能使用一个核心。这意味着我们实际上正在运行与未并行化版本相同的代码，但我们不再具有早期终止功能。我们可以通过使用多个进程（使用
    `multiprocessing` 模块）而不是多个线程，或者使用 Cython 或外部函数来避免这个问题。
- en: So Why Use Python?
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么为什么要使用 Python？
- en: Python is highly expressive and easy to learn—new programmers quickly discover
    that they can do quite a lot in a short space of time. Many Python libraries wrap
    tools written in other languages to make it easy to call other systems; for example,
    the scikit-learn machine learning system wraps LIBLINEAR and LIBSVM (both of which
    are written in C), and the `numpy` library includes BLAS and other C and Fortran
    libraries. As a result, Python code that properly utilizes these modules can indeed
    be as fast as comparable C code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Python 非常表达丰富且易于学习——新程序员很快发现他们可以在短时间内做很多事情。许多 Python 库封装了用其他语言编写的工具，以便调用其他系统；例如，scikit-learn
    机器学习系统封装了 LIBLINEAR 和 LIBSVM（两者均为用 C 编写的），而 `numpy` 库包括 BLAS 和其他 C 和 Fortran 库。因此，正确使用这些模块的
    Python 代码确实可以与相似的 C 代码一样快。
- en: 'Python is described as “batteries included,” as many important tools and stable
    libraries are built in. These include the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python 被描述为“电池包含”，因为许多重要的工具和稳定的库都内置在其中。这些包括以下内容：
- en: '`unicode` and `bytes`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`unicode` 和 `bytes`'
- en: Baked into the core language
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 内置到核心语言中
- en: '`array`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`array`'
- en: Memory-efficient arrays for primitive types
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 用于原始类型的内存高效数组
- en: '`math`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`math`'
- en: Basic mathematical operations, including some simple statistics
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数学运算，包括一些简单的统计操作
- en: '`sqlite3`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3`'
- en: A wrapper around the prevalent SQL file-based storage engine SQLite3
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕主流 SQL 文件存储引擎 SQLite3 的包装器
- en: '`collections`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections`'
- en: A wide variety of objects, including a deque, counter, and dictionary variants
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 包括 deque、counter 和字典变体在内的各种对象
- en: '`asyncio`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`'
- en: Concurrent support for I/O-bound tasks using async and await syntax
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步和等待语法支持 I/O 密集型任务的并发
- en: 'A huge variety of libraries can be found outside the core language, including
    these:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 核心语言之外可以找到大量的库，包括这些：
- en: '`numpy`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy`'
- en: A numerical Python library (a bedrock library for anything to do with matrices)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 数值计算 Python 库（与矩阵有关的基础库）
- en: '`scipy`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy`'
- en: A very large collection of trusted scientific libraries, often wrapping highly
    respected C and Fortran libraries
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大量受信任的科学库集合，通常封装了备受尊敬的 C 和 Fortran 库
- en: '`pandas`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`'
- en: A library for data analysis, similar to R’s data frames or an Excel spreadsheet,
    built on `scipy` and `numpy`
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 用于数据分析的库，类似于 R 的数据框或 Excel 电子表格，构建在 `scipy` 和 `numpy` 上
- en: scikit-learn
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-learn`'
- en: Rapidly turning into the default machine learning library, built on `scipy`
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 快速成为默认的机器学习库，基于 `scipy` 构建
- en: '`tornado`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`tornado`'
- en: A library that provides easy bindings for concurrency
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 提供易于绑定并发的库
- en: PyTorch and TensorFlow
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: PyTorch 和 TensorFlow
- en: Deep learning frameworks from Facebook and Google with strong Python and GPU
    support
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Facebook 和 Google 的深度学习框架，具有强大的 Python 和 GPU 支持
- en: '`NLTK`, `SpaCy`, and `Gensim`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`NLTK`、`SpaCy` 和 `Gensim`'
- en: Natural language-processing libraries with deep Python support
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 具有深度 Python 支持的自然语言处理库
- en: Database bindings
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库绑定
- en: For communicating with virtually all databases, including Redis, MongoDB, HDF5,
    and SQL
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 用于与几乎所有数据库通信，包括 Redis、MongoDB、HDF5 和 SQL
- en: Web development frameworks
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Web 开发框架
- en: Performant systems for creating websites, such as `aiohttp`, `django`, `pyramid`,
    `flask`, and `tornado`
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 创建网站的高效系统，例如 `aiohttp`、`django`、`pyramid`、`flask` 和 `tornado`
- en: '`OpenCV`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenCV`'
- en: Bindings for computer vision
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉的绑定
- en: API bindings
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: API 绑定
- en: For easy access to popular web APIs such as Google, Twitter, and LinkedIn
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 便于访问流行的 Web API，例如 Google、Twitter 和 LinkedIn
- en: 'A large selection of managed environments and shells is available to fit various
    deployment scenarios, including the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量托管环境和 Shell 可供选择，以适应各种部署场景，包括以下内容：
- en: The standard distribution, available at [*http://python.org*](http://python.org)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准发行版，可在 [*http://python.org*](http://python.org) 获取
- en: '`pipenv`, `pyenv`, and `virtualenv` for simple, lightweight, and portable Python
    environments'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipenv`、`pyenv` 和 `virtualenv`，用于简单、轻量和可移植的 Python 环境'
- en: Docker for simple-to-start-and-reproduce environments for development or production
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker，用于简化启动和重现开发或生产环境的环境
- en: Anaconda Inc.’s Anaconda, a scientifically focused environment
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anaconda Inc. 的 Anaconda，一个专注于科学的环境
- en: Sage, a Matlab-like environment that includes an integrated development environment
    (IDE)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sage，类似 Matlab 的环境，包括集成开发环境（IDE）
- en: IPython, an interactive Python shell heavily used by scientists and developers
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPython，科学家和开发人员广泛使用的交互式 Python shell
- en: Jupyter Notebook, a browser-based extension to IPython, heavily used for teaching
    and demonstrations
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jupyter Notebook，基于浏览器的 IPython 扩展，广泛用于教学和演示
- en: One of Python’s main strengths is that it enables fast prototyping of an idea.
    Because of the wide variety of supporting libraries, it is easy to test whether
    an idea is feasible, even if the first implementation might be rather flaky.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的主要优势之一是能够快速原型化一个想法。由于有多种支持库的支持，即使第一次实现可能有些不稳定，也很容易测试一个想法是否可行。
- en: If you want to make your mathematical routines faster, look to `numpy`. If you
    want to experiment with machine learning, try scikit-learn. If you are cleaning
    and manipulating data, then `pandas` is a good choice.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使您的数学例程更快，请考虑 `numpy`。如果您想尝试机器学习，请试试 scikit-learn。如果您正在清理和操作数据，那么 `pandas`
    是一个很好的选择。
- en: In general, it is sensible to raise the question, “If our system runs faster,
    will we as a team run slower in the long run?” It is always possible to squeeze
    more performance out of a system if enough work-hours are invested, but this might
    lead to brittle and poorly understood optimizations that ultimately trip up the
    team.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，提出问题“如果我们的系统运行得更快，我们作为一个团队长远来看会运行得更慢吗？”是明智的。如果投入足够的工时，总是可以从系统中挤取更多的性能，但这可能导致脆弱且理解不足的优化，最终会使团队陷入困境。
- en: One example might be the introduction of Cython (see [“Cython”](ch07.xhtml#compiling-cython)),
    a compiler-based approach to annotating Python code with C-like types so the transformed
    code can be compiled using a C compiler. While the speed gains can be impressive
    (often achieving C-like speeds with relatively little effort), the cost of supporting
    this code will increase. In particular, it might be harder to support this new
    module, as team members will need a certain maturity in their programming ability
    to understand some of the trade-offs that have occurred when leaving the Python
    virtual machine that introduced the performance increase.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可能是引入 Cython（见 [“Cython”](ch07.xhtml#compiling-cython)），这是一种基于编译器的方法，用于使用类似
    C 的类型注释 Python 代码，以便转换后的代码可以使用 C 编译器编译。虽然速度提升可能令人印象深刻（通常可以达到类似 C 的速度，而付出的努力相对较少），但支持此类代码的成本将会增加。特别是，支持这个新模块可能更加困难，因为团队成员需要在编程能力上具备一定的成熟度，以理解离开引入性能提升的
    Python 虚拟机时发生的某些权衡。
- en: How to Be a Highly Performant Programmer
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何成为一名高效的程序员
- en: Writing high performance code is only one part of being highly performant with
    successful projects over the longer term. Overall team velocity is far more important
    than speedups and complicated solutions. Several factors are key to this—good
    structure, documentation, debuggability, and shared standards.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 编写高性能代码只是长期成功项目中高效性的一部分。整体团队速度比加速和复杂解决方案更为重要。几个关键因素包括良好的结构、文档、调试能力和共享标准。
- en: Let’s say you create a prototype. You didn’t test it thoroughly, and it didn’t
    get reviewed by your team. It does seem to be “good enough,” and it gets pushed
    to production. Since it was never written in a structured way, it lacks tests
    and is undocumented. All of a sudden there’s an inertia-causing piece of code
    for someone else to support, and often management can’t quantify the cost to the
    team.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您创建了一个原型。您没有彻底测试它，也没有让您的团队审核它。它似乎“够好”，于是被推送到生产环境。由于从未以结构化的方式编写，它缺乏测试和文档。突然间，这成为一个惯性代码片段，需要其他人支持，而管理层往往无法量化对团队的成本。
- en: 'As this solution is hard to maintain, it tends to stay unloved—it never gets
    restructured, it doesn’t get the tests that’d help the team refactor it, and nobody
    else likes to touch it, so it falls to one developer to keep it running. This
    can cause an awful bottleneck at times of stress and raises a significant risk:
    what would happen if that developer left the project?'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种解决方案难以维护，它往往保持不受欢迎——它从未重构过，没有测试帮助团队重构它，也没有其他人喜欢接触它，因此落到一个开发人员手中来维护。这在压力时期可能会引起严重的瓶颈，并提高了一个重大风险：如果那位开发人员离开了项目会发生什么？
- en: Typically, this development style occurs when the management team doesn’t understand
    the ongoing inertia that’s caused by hard-to-maintain code. Demonstrating that
    in the longer-term tests and documentation can help a team stay highly productive
    and can help convince managers to allocate time to “cleaning up” this prototype
    code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 典型地，这种开发风格发生在管理团队不理解由难以维护的代码造成的惯性时。在长期来看，测试和文档的证明可以帮助团队保持高效率，并说服管理者分配时间来“清理”这些原型代码。
- en: In a research environment, it is common to create many Jupyter Notebooks using
    poor coding practices while iterating through ideas and different datasets. The
    intention is always to “write it up properly” at a later stage, but that later
    stage never occurs. In the end, a working result is obtained, but the infrastructure
    to reproduce it, test it, and trust the result is missing. Once again the risk
    factors are high, and the trust in the result will be low.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究环境中，通常会使用不良编码实践创建许多Jupyter Notebooks，以迭代思路和不同数据集。意图始终是在稍后的阶段“正确地写出来”，但这一阶段从未出现。最终得到了一个工作结果，但缺少复现、测试和信任结果的基础设施。再次高风险因素，结果的信任度将会很低。
- en: 'There’s a general approach that will serve you well:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个通用的方法会给您带来很大帮助：
- en: Make it work
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让它运行起来
- en: First you build a good-enough solution. It is very sensible to “build one to
    throw away” that acts as a prototype solution, enabling a better structure to
    be used for the second version. It is always sensible to do some up-front planning
    before coding; otherwise, you’ll come to reflect that “We saved an hour’s thinking
    by coding all afternoon.” In some fields this is better known as “Measure twice,
    cut once.”
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先构建一个足够好的解决方案。建议先“建立一个用来丢弃的”原型解决方案，作为第二版本使用更好结构的可能性。在编码之前进行一些前期规划总是明智的；否则，您会发现“我们通过整个下午编码省了一个小时的思考时间。”在某些领域，这更为人熟知为“量一次，切一次”。
- en: Make it right
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 做对
- en: Next, you add a strong test suite backed by documentation and clear reproducibility
    instructions so that another team member can take it on.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您添加一个强大的测试套件，支持文档和清晰的可复现性说明，以便其他团队成员接手。
- en: Make it fast
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 做快
- en: Finally, we can focus on profiling and compiling or parallelization and using
    the existing test suite to confirm that the new, faster solution still works as
    expected.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以专注于分析和编译，或并行化和使用现有的测试套件来确认新的更快解决方案仍然按预期工作。
- en: Good Working Practices
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 良好的工作实践
- en: There are a few “must haves”—documentation, good structure, and testing are
    key.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个“必须具备”的要素——文档、良好的结构和测试至关重要。
- en: Some project-level documentation will help you stick to a clean structure. It’ll
    also help you and your colleagues in the future. Nobody will thank you (yourself
    included) if you skip this part. Writing this up in a *README* file at the top
    level is a sensible starting point; it can always be expanded into a *docs/* folder
    later if required.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目级文档将帮助您坚持清晰的结构。这也将帮助您和您的同事未来。如果您跳过这一部分，没有人会感谢您（包括您自己）。在顶层编写一个*README*文件是一个明智的起点；如果需要的话，随后可以扩展为*docs/*文件夹。
- en: Explain the purpose of the project, what’s in the folders, where the data comes
    from, which files are critical, and how to run it all, including how to run the
    tests.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 解释项目的目的，文件夹中包含什么内容，数据的来源，哪些文件至关重要，以及如何运行所有内容，包括如何运行测试。
- en: Micha recommends also using Docker. A top-level Dockerfile will explain to your
    future-self exactly which libraries you need from the operating system to make
    this project run successfully. It also removes the difficulty of running this
    code on other machines or deploying it to a cloud environment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Micha 还推荐使用 Docker。一个顶级的 Dockerfile 将准确解释需要从操作系统获取哪些库才能使这个项目成功运行。它还消除了在其他机器上运行此代码或部署到云环境中的难度。
- en: Add a *tests/* folder and add some unit tests. We prefer `pytest` as a modern
    test runner, as it builds on Python’s built-in `unittest` module. Start with just
    a couple of tests and then build them up. Progress to using the `coverage` tool,
    which will report how many lines of your code are actually covered by the tests—it’ll
    help avoid nasty surprises.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 *tests/* 文件夹并添加一些单元测试。我们推荐 `pytest` 作为现代测试运行器，它建立在 Python 内置的 `unittest`
    模块之上。先从几个测试开始，然后逐步增加。进而使用 `coverage` 工具，它将报告你的代码有多少行实际被测试覆盖，有助于避免令人不快的惊喜。
- en: If you’re inheriting legacy code and it lacks tests, a high-value activity is
    to add some tests up front. Some “integration tests” that check the overall flow
    of the project and confirm that with certain input data you get specific output
    results will help your sanity as you subsequently make modifications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你继承了旧代码且缺乏测试，那么一个高价值的活动就是首先添加一些测试。一些“集成测试”可以检查项目的整体流程，并确认使用特定输入数据时能够获得特定输出结果，这将有助于你在随后进行修改时保持理智。
- en: Every time something in the code bites you, add a test. There’s no value to
    being bitten twice by the same problem.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每当代码中的某些东西“咬”到你时，添加一个测试。被同一个问题“咬”两次是毫无价值的。
- en: Docstrings in your code for each function, class, and module will always help
    you. Aim to provide a useful description of what’s *achieved* by the function,
    and where possible include a short example to demonstrate the expected output.
    Look at the docstrings inside `numpy` and scikit-learn if you’d like inspiration.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中为每个函数、类和模块添加文档字符串将总是对你有帮助。努力提供有用的描述说明函数*实现*了什么，并在可能时包含一个简短的示例以展示预期的输出。如果需要灵感，可以看看
    `numpy` 和 scikit-learn 中的文档字符串。
- en: Whenever your code becomes too long—such as functions longer than one screen—be
    comfortable with refactoring the code to make it shorter. Shorter code is easier
    to test and easier to support.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你的代码变得过长——比如函数超过一个屏幕长度——要习惯性地重构代码使其变得更短。较短的代码更易于测试和维护。
- en: Tip
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: When you’re developing your tests, think about following a test-driven development
    methodology. When you know exactly what you need to develop and you have testable
    examples at hand—this method becomes very efficient.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发测试时，考虑遵循测试驱动开发方法论。当你确切知道需要开发什么，并且手头有可测试的例子时，这种方法将变得非常高效。
- en: You write your tests, run them, watch them fail, and *then* add the functions
    and the necessary minimum logic to support the tests that you’ve written. When
    your tests all work, you’re done. By figuring out the expected input and output
    of a function ahead of time, you’ll find implementing the logic of the function
    relatively straightforward.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试，运行它们，观察它们失败，*然后*添加函数和必要的最小逻辑来支持你编写的测试。当你的测试全部通过时，你完成了。通过提前确定函数的预期输入和输出，你将会发现实现函数逻辑相对简单。
- en: If you can’t define your tests ahead of time, it naturally raises the question,
    do you really understand what your function needs to do? If not, can you write
    it correctly in an efficient manner? This method doesn’t work so well if you’re
    in a creative process and researching data that you don’t yet understand well.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法提前定义你的测试，这自然会引发一个问题：你真的了解你的函数需要做什么吗？如果不是，你能高效地正确编写它吗？如果你正处于创造性过程中并正在研究尚未完全理解的数据，这种方法可能效果不佳。
- en: Always use source control—you’ll only thank yourself when you overwrite something
    critical at an inconvenient moment. Get used to committing frequently (daily,
    or even every 10 minutes) and pushing to your repository every day.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用源代码控制——当你在不方便的时刻覆盖了一些关键内容时，你只会感谢自己。养成频繁提交（每天或甚至每10分钟提交一次）并每天推送到你的代码库的习惯。
- en: Keep to the standard `PEP8` coding standard. Even better, adopt `black` (the
    opinionated code formatter) on a pre-commit source control hook so it just rewrites
    your code to the standard for you. Use `flake8` to lint your code to avoid other
    mistakes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循标准的 `PEP8` 编码规范。更好的做法是在预提交源控制钩子上采用 `black`（一种有见解的代码格式化工具），这样它会自动将你的代码重写为标准格式。使用
    `flake8` 来检查你的代码，避免其他错误。
- en: Creating environments that are isolated from the operating system will make
    your life easier. Ian prefers Anaconda, while Micha prefers `pipenv` coupled with
    Docker. Both are sensible solutions and are significantly better using the operating
    system’s global Python environment!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建与操作系统隔离的环境将使你的生活更轻松。Ian偏爱Anaconda，而Micha则喜欢`pipenv`与Docker结合使用。两者都是明智的解决方案，显著优于使用操作系统的全局Python环境！
- en: Remember that automation is your friend. Doing less manual work means there’s
    less chance of errors creeping in. Automated build systems, continuous integration
    with automated test suite runners, and automated deployment systems turn tedious
    and error-prone tasks into standard processes that anyone can run and support.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 记住自动化是你的朋友。做更少的手动工作意味着出错的机会更少。自动构建系统、与自动化测试套件运行器的持续集成以及自动化部署系统将单调且容易出错的任务转变为任何人都可以运行和支持的标准流程。
- en: Finally, remember that readability is far more important than being clever.
    Short snippets of complex and hard-to-read code will be hard for you and your
    colleagues to maintain, so people will be scared of touching this code. Instead,
    write a longer, easier-to-read function and back it with useful documentation
    showing what it’ll return, and complement this with tests to confirm that it *does*
    work as you expect.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住可读性远比聪明更重要。复杂且难以阅读的短代码片段将使你和你的同事难以维护，因此人们会害怕触碰这些代码。相反，写一个更长、更易读的函数，并配以有用的文档显示它将返回什么，并通过测试来确认它*确实*按照你的预期工作。
- en: Some Thoughts on Good Notebook Practice
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于良好Notebook实践的一些想法
- en: If you’re using Jupyter Notebooks, they’re great for visual communication, but
    they facilitate laziness. If you find yourself leaving long functions inside your
    Notebooks, be comfortable extracting them out to a Python module and then adding
    tests.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Jupyter Notebooks，它们非常适合视觉交流，但也容易使人变得懒惰。如果你发现自己在Notebooks中留下了长函数，请放心地将它们提取到一个Python模块中，然后添加测试。
- en: Consider prototyping your code in IPython or the QTConsole; turn lines of code
    into functions in a Notebook and then promote them out of the Notebook and into
    a module complemented by tests. Finally, consider wrapping the code in a class
    if encapsulation and data hiding are useful.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在IPython或QTConsole中原型化你的代码；将代码行转换为Notebook中的函数，然后将它们提升到一个模块中，并通过测试来补充。最后，如果封装和数据隐藏是有用的，考虑将代码包装在一个类中。
- en: Liberally spread `assert` statements throughout a Notebook to check that your
    functions are behaving as expected. You can’t easily test code inside a Notebook,
    and until you’ve refactored your functions into separate modules, `assert` checks
    are a simple way to add some level of validation. You shouldn’t trust this code
    until you’ve extracted it to a module and written sensible unit tests.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在Notebook中大量使用`assert`语句来检查你的函数是否按预期行为。在将函数重构到单独的模块之前，`assert`检查是添加某种验证级别的简单方法。在将其提取到模块并编写合理的单元测试之前，你不应该信任这段代码。
- en: Using `assert` statements to check data in your code should be frowned upon.
    It is an easy way to assert that certain conditions are being met, but it isn’t
    idiomatic Python. To make your code easier to read by other developers, check
    your expected data state and then raise an appropriate exception if the check
    fails. A common exception would be `ValueError` if a function encounters an unexpected
    value. The [Bulwark library](https://oreil.ly/c6QbY) is an example of a testing
    framework focused on Pandas to check that your data meets the specified constraints.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`assert`语句来检查代码中的数据应该受到批评。这是一种断言某些条件是否满足的简单方法，但它并不符合Python的惯用法。为了让其他开发人员更容易阅读你的代码，检查你的预期数据状态，如果检查失败，则引发适当的异常。如果函数遇到意外值，常见的异常可能是`ValueError`。[Bulwark库](https://oreil.ly/c6QbY)是一个以Pandas为重点的测试框架示例，用于检查你的数据是否符合指定的约束条件。
- en: You may also want to add some sanity checks at the end of your Notebook—a mixture
    of logic checks and `raise` and `print` statements that demonstrate that you’ve
    just generated exactly what you needed. When you return to this code in six months,
    you’ll thank yourself for making it easy to see that it worked correctly all the
    way through!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想在Notebook的末尾添加一些健全性检查——一些逻辑检查和`raise`以及`print`语句的混合，这些语句表明你刚生成了确实需要的内容。当你在六个月后回到这段代码时，你会感谢自己让它易于看出它始终正确工作！
- en: One difficulty with Notebooks is sharing code with source control systems. [nbdime](https://oreil.ly/PfR-H)
    is one of a growing set of new tools that let you diff your Notebooks. It is a
    lifesaver and enables collaboration with colleagues.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Notebooks时的一个困难是与源代码控制系统共享代码。[nbdime](https://oreil.ly/PfR-H)是一组新工具中的一员，它可以让你比较你的Notebooks。它是一个救命稻草，能够与同事进行协作。
- en: Getting the Joy Back into Your Work
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让工作再次充满乐趣
- en: Life can be complicated. In the five years since your authors wrote the first
    edition of this book, we’ve jointly experienced through friends and family a number
    of life situations, including depression, cancer, home relocations, successful
    business exits and failures, and career direction shifts. Inevitably, these external
    events will have an impact on anyone’s work and outlook on life.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 生活可能很复杂。在我们作者撰写本书第一版五年来，我们通过朋友和家人共同经历了许多生活事件，包括抑郁、癌症、家庭搬迁、成功的企业退出和失败，以及职业方向的转变。不可避免地，这些外部事件会影响任何人的工作和对生活的看法。
- en: Remember to keep looking for the joy in new activities. There are always interesting
    details or requirements once you start poking around. You might ask, “why did
    they make that decision?” and “how would I do it differently?” and all of a sudden
    you’re ready to start a conversation about how things might be changed or improved.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 记得继续寻找新活动中的乐趣。一旦你开始深入探索，总能找到有趣的细节或要求。你可能会问：“为什么他们做出那个决定？”以及“我会怎么做得更好？”突然间，你就准备好开始探讨如何改变或改进事物了。
- en: Keep a log of things that are worth celebrating. It is so easy to forget about
    accomplishments and to get caught up in the day-to-day. People get burned out
    because they’re always running to keep up, and they forget how much progress they’ve
    made.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 记录值得庆祝的事情。忘记成就并被日常琐事所困扰是很容易的。人们之所以会烧尽自己，是因为他们总是为了跟上而奔波，并忘记了自己所取得的多少进步。
- en: We suggest that you build a list of items worth celebrating and note how you
    celebrate them. Ian keeps such a list—he’s happily surprised when he goes to update
    the list and sees just how many cool things have happened (and might otherwise
    have been forgotten!) in the last year. These shouldn’t just be work milestones;
    include hobbies and sports, and celebrate the milestones you’ve achieved. Micha
    makes sure to prioritize his personal life and spend days away from the computer
    to work on nontechnical projects. It is critical to keep developing your skill
    set, but it is not necessary to burn out!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你建立一个值得庆祝的事项清单，并记录你如何庆祝它们。伊恩就保留了这样一个清单——当他去更新这个清单时，他会惊喜地发现在过去的一年里发生了多少酷炫的事情（这些事情本来可能会被遗忘！）。这些庆祝不仅限于工作里的里程碑；包括爱好、运动，以及你取得的各种成就。米卡确保优先处理个人生活，每天远离电脑，专注于非技术项目的工作。保持发展你的技能集团至关重要，但烧尽自己并非必要！
- en: Programming, particularly when performance focused, thrives on a sense of curiosity
    and a willingness to always delve deeper into the technical details. Unfortunately,
    this curiosity is the first thing to go when you burn out; so take your time and
    make sure you enjoy the journey, and keep the joy and the curiosity.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 编程，特别是在性能方面，靠的是一种好奇心和深入技术细节的意愿。不幸的是，当你烧尽了激情时，这种好奇心往往是第一个消失的；所以，请花些时间确保你享受这个旅程，并保持快乐和好奇心。
- en: ^([1](ch01_split_000.xhtml#idm46122429262840-marker)) Not to be confused with
    interprocess communication, which shares the same acronym—we’ll look at that topic
    in [Chapter 9](ch09_split_000.xhtml#multiprocessing).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01_split_000.xhtml#idm46122429262840-marker)) 不要与进程间通信搞混，虽然它们共用同一个缩写——我们将在[第9章](ch09_split_000.xhtml#multiprocessing)中探讨这个主题。
- en: ^([2](ch01_split_000.xhtml#idm46122428772888-marker)) Speeds in this section
    are from [*https://oreil.ly/pToi7*](https://oreil.ly/pToi7).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01_split_000.xhtml#idm46122428772888-marker)) 本节的速度来自[*https://oreil.ly/pToi7*](https://oreil.ly/pToi7)。
- en: ^([3](ch01_split_000.xhtml#idm46122429019976-marker)) Data is from [*https://oreil.ly/7SC8d*](https://oreil.ly/7SC8d).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch01_split_000.xhtml#idm46122429019976-marker)) 数据来自[*https://oreil.ly/7SC8d*](https://oreil.ly/7SC8d)。
- en: ^([4](ch01_split_000.xhtml#idm46122435398952-marker)) In [Chapter 6](ch06_split_000.xhtml#matrix_computation),
    we’ll see how we can regain this control and tune our code all the way down to
    the memory utilization patterns.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch01_split_000.xhtml#idm46122435398952-marker)) 在[第6章](ch06_split_000.xhtml#matrix_computation)中，我们将看到如何重新获得控制权，并调整我们的代码，一直到内存利用模式。
