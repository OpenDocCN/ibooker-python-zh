<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. Adding Changeable/Mutable State &#10;with Dask Actors"><div class="chapter" id="ch07">
<h1><span class="label">Chapter 7. </span>Adding Changeable/Mutable State 
<span class="keep-together">with Dask Actors</span></h1>


<p>Dask is focused on scaling analytic use cases, but you can use it to scale many other types of problems. So far, most of the tools you have used in Dask are functional. Functional programming means that previous calls do not impact future calls. Stateless functions are common in <a data-type="indexterm" data-primary="functional programming" id="id690"/><a data-type="indexterm" data-primary="stateless functions" id="id691"/><a data-type="indexterm" data-primary="functions" data-secondary="stateless" id="id692"/>distributed systems like Dask, as they can safely be re-executed multiple times on failure. Updating the weights of a model during training is an example of state common in data science. One of the most common ways of handling state in a distributed system is with the actor model. This chapter will introduce both the general actor model and Dask’s specific implementation.</p>

<p>Dask futures offer a non-mutable <a data-type="indexterm" data-primary="mutable state" id="id693"/>distributed state, where values are stored on the workers. However, this doesn’t work well for situations in which you want to update the state, like changing a bank account balance (an alternative solution is illustrated in <a data-type="xref" href="#making_bank_acct_actor_ch07_1686239522527">Example 7-1</a>), or updating machine learning model weights during training.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Dask actors have a number of limitations, and we believe that in many cases the right answer is to keep mutable state <em>outside</em> of Dask (like in a database).</p>
</div>

<p>Of course, you don’t have to use distributed mutable state. In some cases, you may choose to not use distributed state and instead put it all in your main program. This can quickly lead to bottlenecks on the node responsible for your main program. Other options include storing your state outside of Dask, like in a database, which has its own trade-offs. While this chapter focuses on how to use the actor model, we conclude with when not to use Dask actors and alternatives for handling state, which is of equal importance.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Dask also has distributed mutable objects, covered in <a data-type="xref" href="ch06.xhtml#dds_scheduling">“Distributed Data Structures for Scheduling”</a>.</p>
</div>






<section data-type="sect1" data-pdf-bookmark="What Is the Actor Model?"><div class="sect1" id="id63">
<h1>What Is the Actor Model?</h1>

<p>In the actor model, actors <a data-type="indexterm" data-primary="actor model" id="actrmd"/>do the following:</p>

<ul>
<li>
<p>Store data</p>
</li>
<li>
<p>Receive and respond to messages, including from other actors and external</p>
</li>
<li>
<p>Pass messages</p>
</li>
<li>
<p>Create new actors</p>
</li>
</ul>

<p>The actor model is a technique of dealing with state in parallel and distributed systems that avoid locks. While proper locking ensures that only one piece of code modifies a given value, it can be very expensive and difficult to get right. A common problem <a data-type="indexterm" data-primary="deadlocking" id="id694"/>with locking is known as deadlocking—this is where resources are acquired/released in an incorrect order that the program can block forever. The slowness and difficulty of locks only increase in distributed systems.<sup><a data-type="noteref" id="id695-marker" href="ch07.xhtml#id695">1</a></sup> The actor model was introduced in 1973 and has since been implemented in most programming languages,<sup><a data-type="noteref" id="id696-marker" href="ch07.xhtml#id696">2</a></sup> with some popular modern implementations including Akka in Scala and the .NET languages.</p>

<p>It can be helpful to think of each actor as a person holding a note about their state, and that person is the only one allowed to read or update the note. Whenever another part of the code wants to access or modify the state, it must ask the actor to do this.</p>

<p>Conceptually, this is very similar to classes in object-oriented programming. However, unlike with generic classes, actors process one request at a time to ensure an actor’s state consistency. To improve the throughput, people often create a pool of actors (assuming they can shard or replicate the actor’s state). We’ll cover an example in the next section.</p>

<p class="pagebreak-after">The actor model is a good fit for many distributed systems scenarios. Here are some typical use cases in which the actor model can be advantageous:</p>

<ul>
<li>
<p>You need to deal with a large distributed state that is hard to synchronize between invocations (e.g., ML model weights, counters, etc.).</p>
</li>
<li>
<p>You want to work with single-threaded objects that do not require significant interaction from external components. This is especially useful for legacy code that is not fully understood.<sup><a data-type="noteref" id="id697-marker" href="ch07.xhtml#id697">3</a></sup></p>
</li>
</ul>

<p>Now that you have an understanding of the <a data-type="indexterm" data-primary="actor model" data-startref="actrmd" id="id698"/>actor model in general, it’s time for you to learn about how Dask implements it, and about its trade-offs.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Dask Actors"><div class="sect1" id="id265">
<h1>Dask Actors</h1>

<p>Dask actors are one implementation of actors, and some of the properties differ between Dask and other systems. Unlike the rest of Dask, Dask actors are not resilient to failures. If the node, or process, running the actor fails, the data inside the actor is lost and Dask is not able to recover from it.</p>








<section data-type="sect2" data-pdf-bookmark="Your First Actor (It’s a Bank Account)"><div class="sect2" id="id64">
<h2>Your First Actor (It’s a Bank Account)</h2>

<p>Creating an actor in Dask is <a data-type="indexterm" data-primary="actors" data-secondary="creating" id="id699"/>relatively simple. To start with, you make a normal Python class with functions that you will call. These functions are responsible for receiving and responding to messages in the actor model. Once you have your class, you <code>submit</code> it to Dask, along <a data-type="indexterm" data-primary="actors" data-secondary="submitting" id="id700"/>with the flag <code>actor=True</code>, and Dask gives you back a future representing a reference <a data-type="indexterm" data-primary="actors" data-secondary="futures" id="id701"/><a data-type="indexterm" data-primary="futures" data-secondary="actors" id="id702"/>to the actor. When you get the <code>result</code> of this future, Dask creates and returns to you a proxy object, which passes any function calls as messages to the actor.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Note this is effectively an object-oriented bank account implementation, except we don’t have any locks since we only ever have a single thread changing the values.</p>
</div>

<p class="pagebreak-after">Let’s take a look at how you can implement a <a data-type="indexterm" data-primary="actors" data-secondary="implementing" id="id703"/>common example actor for a bank account. In <a data-type="xref" href="#making_bank_acct_actor_ch07_1686239522527">Example 7-1</a>, we define three methods—<code>balance</code>, <code>deposit</code>, and 
<span class="keep-together"><code>withdrawal</code></span>—that can be used to interact with the actor. Once the actor is defined, we ask Dask to schedule the actor so that we can call it.</p>
<div id="making_bank_acct_actor_ch07_1686239522527" data-type="example" class="less_space">
<h5><span class="label">Example 7-1. </span>Making a bank account actor</h5>

<pre data-type="programlisting" data-code-language="python"><code class="k">class</code> <code class="nc">BankAccount</code><code class="p">:</code>
    <code class="sd">""" A bank account actor (similar to counter but with + and -)"""</code>

    <code class="c1"># 42 is a good start</code>
    <code class="k">def</code> <code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">balance</code><code class="o">=</code><code class="mf">42.0</code><code class="p">):</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">_balance</code> <code class="o">=</code> <code class="n">balance</code>

    <code class="k">def</code> <code class="nf">deposit</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">amount</code><code class="p">):</code>
        <code class="k">if</code> <code class="n">amount</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">:</code>
            <code class="k">raise</code> <code class="ne">Exception</code><code class="p">(</code><code class="s2">"Cannot deposit negative amount"</code><code class="p">)</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">_balance</code> <code class="o">+=</code> <code class="n">amount</code>
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">_balance</code>

    <code class="k">def</code> <code class="nf">withdrawal</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">amount</code><code class="p">):</code>
        <code class="k">if</code> <code class="n">amount</code> <code class="o">&gt;</code> <code class="bp">self</code><code class="o">.</code><code class="n">_balance</code><code class="p">:</code>
            <code class="k">raise</code> <code class="ne">Exception</code><code class="p">(</code><code class="s2">"Please deposit more money first."</code><code class="p">)</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">_balance</code> <code class="o">-=</code> <code class="n">amount</code>
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">_balance</code>

    <code class="k">def</code> <code class="nf">balance</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">_balance</code>


<code class="c1"># Create a BankAccount on a worker</code>
<code class="n">account_future</code> <code class="o">=</code> <code class="n">client</code><code class="o">.</code><code class="n">submit</code><code class="p">(</code><code class="n">BankAccount</code><code class="p">,</code> <code class="n">actor</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>
<code class="n">account</code> <code class="o">=</code> <code class="n">account_future</code><code class="o">.</code><code class="n">result</code><code class="p">()</code></pre></div>

<p>When you call methods on the resulting proxy object (see <a data-type="xref" href="#using_bank_acct_actor_ch07_1686239559633">Example 7-2</a>), Dask dispatches a remote procedure call and returns a special ActorFuture immediately. This allows you to use actors <a data-type="indexterm" data-primary="ActorFuture" id="id704"/>in a non-blocking fashion. Unlike the generic <code>@dask.delayed</code> calls, these are all routed to the same process, namely the one where Dask has scheduled the actor.</p>
<div id="using_bank_acct_actor_ch07_1686239559633" data-type="example">
<h5><span class="label">Example 7-2. </span>Using the bank account actor</h5>

<pre data-type="programlisting" data-code-language="python"><code class="c1"># Non-blocking</code>
<code class="n">balance_future</code> <code class="o">=</code> <code class="n">account</code><code class="o">.</code><code class="n">balance</code><code class="p">()</code>
<code class="c1"># Blocks</code>
<code class="n">balance</code> <code class="o">=</code> <code class="n">balance_future</code><code class="o">.</code><code class="n">result</code><code class="p">()</code>
<code class="k">try</code><code class="p">:</code>
    <code class="n">f</code> <code class="o">=</code> <code class="n">account</code><code class="o">.</code><code class="n">withdrawal</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code>
    <code class="n">f</code><code class="o">.</code><code class="n">result</code><code class="p">()</code> <code class="c1"># throws an exception</code>
<code class="k">except</code> <code class="ne">Exception</code> <code class="k">as</code> <code class="n">e</code><code class="p">:</code>
    <code class="nb">print</code><code class="p">(</code><code class="n">e</code><code class="p">)</code></pre></div>

<p class="pagebreak-before">The ActorFuture <em>is not serializable</em>, so if you need <a data-type="indexterm" data-primary="ActorFuture" data-secondary="serializability" id="id705"/>to transfer the result of calling an actor, you need to block and get its value, as shown in <a data-type="xref" href="#actorfutures_not_serializable_ch07_1686239609453">Example 7-3</a>.</p>
<div id="actorfutures_not_serializable_ch07_1686239609453" data-type="example">
<h5><span class="label">Example 7-3. </span>ActorFutures are not serializable</h5>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">inc</code><code class="p">(</code><code class="n">x</code><code class="p">):</code>
    <code class="kn">import</code> <code class="nn">time</code>
    <code class="n">time</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
    <code class="n">f</code> <code class="o">=</code> <code class="n">counter</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
    <code class="c1"># Note: the actor (in this case `counter`) is serializable; </code>
    <code class="c1"># however, the future we get back from it is not.</code>
    <code class="c1"># This is likely because the future contains a network connection </code>
    <code class="c1"># to the actor, so need to get its concrete value here. If we don't</code>
    <code class="c1"># need the value, you can avoid blocking and it will still execute.</code>
    <code class="k">return</code> <code class="n">f</code><code class="o">.</code><code class="n">result</code><code class="p">()</code></pre></div>

<p>While having one actor per bank account does a good job of avoiding bottlenecks, since each bank account likely won’t have too many transactions queued, it is slightly inefficient, as there is a non-zero actor overhead. One solution is to extend our bank account actor to support multiple accounts by using a key and hashmap, but if all accounts are inside one actor, this can lead to scaling problems.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Scaling Dask Actors"><div class="sect2" id="id171">
<h2>Scaling Dask Actors</h2>

<p>The actor model described earlier <a data-type="indexterm" data-primary="actors" data-secondary="scaling" id="actrsc"/><a data-type="indexterm" data-primary="scaling" data-secondary="actors" id="sclgctr"/>in this chapter typically assumes that actors are lightweight, meaning they contain a single piece of state, and do not require scal⁠ing/​parallelization. In Dask and similar systems (including Akka), actors are often used for coarser-grained implementations and can require scaling.<sup><a data-type="noteref" id="id706-marker" href="ch07.xhtml#id706">4</a></sup></p>

<p>As with <code>dask.delayed</code>, you can scale actors horizontally (across pro⁠cesses/​machines) by creating multiple actors or vertically (with more resources). Scaling actors horizontally is not as simple as just adding more machines or workers, since Dask cannot break up a single actor across multiple processes.</p>

<p>When scaling actors horizontally, it is up to you to break up the state in such a way that you can have multiple actors handling it. One technique is to use <em>actor pools</em> (see <a data-type="xref" href="#figure0701_ch07_1686049800930">Figure 7-1</a>). These pools can have a static mapping of, say, user → actor, or, in the situation in which the actors share a database, round-robin or other non-deterministic balancing can be used.</p>

<figure><div id="figure0701_ch07_1686049800930" class="figure">
<img src="Images/spwd_0701.png" alt="spwd 0701" width="1061" height="727"/>
<h6><span class="label">Figure 7-1. </span>Scaled actor model using consistent hashing</h6>
</div></figure>

<p>We extend the bank account example to a “bank” where an actor may be responsible for multiple accounts (but not for all of the accounts in the bank). We can then use an actor pool with hashing to route the requests to the correct “branch” or actor, as shown <a data-type="indexterm" data-primary="actors" data-secondary="scaling" data-startref="actrsc" id="id707"/><a data-type="indexterm" data-primary="scaling" data-secondary="actors" data-startref="sclgctr" id="id708"/>in <a data-type="xref" href="#sketchy_bank_ex">Example 7-4</a>.</p>
<div id="sketchy_bank_ex" data-type="example">
<h5><span class="label">Example 7-4. </span>Hashing actor pool example for a bank</h5>

<pre data-type="programlisting" data-code-language="python"><code class="k">class</code> <code class="nc">SketchyBank</code><code class="p">:</code>
    <code class="sd">""" A sketchy bank (handles multiple accounts in one actor)."""</code>

    <code class="c1"># 42 is a good start</code>
    <code class="k">def</code> <code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">accounts</code><code class="o">=</code><code class="p">{}):</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">_accounts</code> <code class="o">=</code> <code class="n">accounts</code>

    <code class="k">def</code> <code class="nf">create_account</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">key</code><code class="p">):</code>
        <code class="k">if</code> <code class="n">key</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">_accounts</code><code class="p">:</code>
            <code class="k">raise</code> <code class="ne">Exception</code><code class="p">(</code><code class="sa">f</code><code class="s2">"</code><code class="si">{</code><code class="n">key</code><code class="si">}</code><code class="s2"> is already an account."</code><code class="p">)</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">_accounts</code><code class="p">[</code><code class="n">key</code><code class="p">]</code> <code class="o">=</code> <code class="mf">0.0</code>

    <code class="k">def</code> <code class="nf">deposit</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">key</code><code class="p">,</code> <code class="n">amount</code><code class="p">):</code>
        <code class="k">if</code> <code class="n">amount</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">:</code>
            <code class="k">raise</code> <code class="ne">Exception</code><code class="p">(</code><code class="s2">"Cannot deposit negative amount"</code><code class="p">)</code>
        <code class="k">if</code> <code class="n">key</code> <code class="ow">not</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">_accounts</code><code class="p">:</code>
            <code class="k">raise</code> <code class="ne">Exception</code><code class="p">(</code><code class="sa">f</code><code class="s2">"Could not find account </code><code class="si">{</code><code class="n">key</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">_accounts</code><code class="p">[</code><code class="n">key</code><code class="p">]</code> <code class="o">+=</code> <code class="n">amount</code>
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">_accounts</code><code class="p">[</code><code class="n">key</code><code class="p">]</code>

    <code class="k">def</code> <code class="nf">withdrawal</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">key</code><code class="p">,</code> <code class="n">amount</code><code class="p">):</code>
        <code class="k">if</code> <code class="n">key</code> <code class="ow">not</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">_accounts</code><code class="p">:</code>
            <code class="k">raise</code> <code class="ne">Exception</code><code class="p">(</code><code class="sa">f</code><code class="s2">"Could not find account </code><code class="si">{</code><code class="n">key</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code>
        <code class="k">if</code> <code class="n">amount</code> <code class="o">&gt;</code> <code class="bp">self</code><code class="o">.</code><code class="n">_accounts</code><code class="p">[</code><code class="n">key</code><code class="p">]:</code>
            <code class="k">raise</code> <code class="ne">Exception</code><code class="p">(</code><code class="s2">"Please deposit more money first."</code><code class="p">)</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">_accounts</code><code class="p">[</code><code class="n">key</code><code class="p">]</code> <code class="o">-=</code> <code class="n">amount</code>
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">_accounts</code><code class="p">[</code><code class="n">key</code><code class="p">]</code>

    <code class="k">def</code> <code class="nf">balance</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">key</code><code class="p">):</code>
        <code class="k">if</code> <code class="n">key</code> <code class="ow">not</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">_accounts</code><code class="p">:</code>
            <code class="k">raise</code> <code class="ne">Exception</code><code class="p">(</code><code class="sa">f</code><code class="s2">"Could not find account </code><code class="si">{</code><code class="n">key</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code>
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">_accounts</code><code class="p">[</code><code class="n">key</code><code class="p">]</code>


<code class="k">class</code> <code class="nc">HashActorPool</code><code class="p">:</code>
    <code class="sd">"""A basic deterministic actor pool."""</code>

    <code class="k">def</code> <code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">actorClass</code><code class="p">,</code> <code class="n">num</code><code class="p">):</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">_num</code> <code class="o">=</code> <code class="n">num</code>
        <code class="c1"># Make the request number of actors</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">_actors</code> <code class="o">=</code> <code class="nb">list</code><code class="p">(</code>
            <code class="nb">map</code><code class="p">(</code><code class="k">lambda</code> <code class="n">x</code><code class="p">:</code> <code class="n">client</code><code class="o">.</code><code class="n">submit</code><code class="p">(</code><code class="n">SketchyBank</code><code class="p">,</code> <code class="n">actor</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code class="o">.</code><code class="n">result</code><code class="p">(),</code>
                <code class="nb">range</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="n">num</code><code class="p">)))</code>

    <code class="k">def</code> <code class="nf">actor_for_key</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">key</code><code class="p">):</code>
        <code class="k">return</code> <code class="bp">self</code><code class="o">.</code><code class="n">_actors</code><code class="p">[</code><code class="nb">hash</code><code class="p">(</code><code class="n">key</code><code class="p">)</code> <code class="o">%</code> <code class="bp">self</code><code class="o">.</code><code class="n">_num</code><code class="p">]</code>


<code class="n">holdens_questionable_bank</code> <code class="o">=</code> <code class="n">HashActorPool</code><code class="p">(</code><code class="n">SketchyBank</code><code class="p">,</code> <code class="mi">10</code><code class="p">)</code>
<code class="n">holdens_questionable_bank</code><code class="o">.</code><code class="n">actor_for_key</code><code class="p">(</code><code class="s2">"timbit"</code><code class="p">)</code><code class="o">.</code><code class="n">create_account</code><code class="p">(</code><code class="s2">"timbit"</code><code class="p">)</code>
<code class="n">holdens_questionable_bank</code><code class="o">.</code><code class="n">actor_for_key</code><code class="p">(</code>
    <code class="s2">"timbit"</code><code class="p">)</code><code class="o">.</code><code class="n">deposit</code><code class="p">(</code><code class="s2">"timbit"</code><code class="p">,</code> <code class="mf">42.0</code><code class="p">)</code><code class="o">.</code><code class="n">result</code><code class="p">()</code></pre></div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Limitations"><div class="sect2" id="id172">
<h2>Limitations</h2>

<p>As previously mentioned, Dask actors <a data-type="indexterm" data-primary="actors" data-secondary="limitations" id="id709"/>are not resilient to machine or process failure. This is a design decision in Dask and is not true for all actor systems. Many, but not all, actor systems offer different options for the persistence and recovery of actors during failure. For example, Ray has the concept of recoverable actors (managed automatically inside of workflows or manually).</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Calls to <code>dask.delayed</code> functions may be retried on failure, and if they call functions on actors, those function calls will then be duplicated. If you cannot have a function replayed, then you need to ensure it is called only from inside other actors.</p>
</div>

<p>Dask’s actor model is less full-featured than Ray’s actor model, much as Ray’s DataFrame is less full-featured than Dask’s. You may wish to consider running Dask on Ray to get the best of both worlds. While Holden is biased, she suggests you check out her book <em>Scaling Python with Ray</em> if you are interested in Ray.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="When to Use Dask Actors"><div class="sect1" id="id173">
<h1>When to Use Dask Actors</h1>

<p>A common problem in the industry is not <a data-type="indexterm" data-primary="actors" data-secondary="use cases" id="id710"/>realizing when our cool new tool is not the right tool for the job. As the saying goes, “When you have a hammer, the whole world looks like a nail.” <em>You likely do not need actors and should stick with tasks if you are not mutating state.</em> It is important for you to remember that there are other options for handling state, as shown in <a data-type="xref" href="#table_ch07_1687457980057">Table 7-1</a>.</p>
<table id="table_ch07_1687457980057">
<caption><span class="label">Table 7-1. </span>Comparison of techniques for managing mutable state</caption>
<thead>
<tr>
<th/>
<th>Local state (e.g., driver)</th>
<th>Dask actors</th>
<th>External distributed state (e.g., ZooKeeper, Ray, or AKKA)</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><strong>Scalability</strong></p></td>
<td><p>No, all state must fit on a single machine.</p></td>
<td><p>State within each actor must fit on a machine, but actors are spread out.</p></td>
<td><p>Yes<sup><a data-type="noteref" id="id711-marker" href="ch07.xhtml#id711">a</a></sup></p></td>
</tr>
<tr>
<td><p><strong>Resilience</strong></p></td>
<td><p>Medium, but no increase in resilience cost (e.g., loss of driver is already catastrophic)</p></td>
<td><p>No, loss of any worker with an actor becomes catastrophic.</p></td>
<td><p>Yes, loss of entire cluster can be recovered from.</p></td>
</tr>
<tr>
<td><p><strong>Performance overhead</strong></p></td>
<td><p>RPC to driver</p></td>
<td><p>Same as <code>dask.delayed</code></p></td>
<td><p>RPC to external system + external systems overhead</p></td>
</tr>
<tr>
<td><p><strong>Code complexity</strong></p></td>
<td><p>Low</p></td>
<td><p>Medium</p></td>
<td><p>High (new library to learn and integrate), extra logic for avoiding duplicate execution</p></td>
</tr>
<tr>
<td><p><strong>Deployment complexity</strong></p></td>
<td><p>Low</p></td>
<td><p>Low</p></td>
<td><p>High (new system to maintain)</p></td>
</tr>
</tbody>
<tbody><tr class="footnotes"><td colspan="4"><p data-type="footnote" id="id711"><sup><a href="ch07.xhtml#id711-marker">a</a></sup> Ray actors still require that the state within an actor must fit on a single machine. Ray has additional tools to shard or create pools of actors.</p></td></tr></tbody></table>

<p>As with most things in life, picking the right technique is a compromise specific to the problem you are trying to solve. We believe that one of the two local (e.g., driver) states, or the use of Ray actors in conjunction with Dask for its analytical powers, can handle most cases in which you need mutable state.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="id266">
<h1>Conclusion</h1>

<p>In this chapter you have learned the basics of how the actor model works as well as how Dask implements it. You’ve also learned some alternatives for dealing with state in a distributed system, and how to choose between them. Dask actors are a relatively new part of Dask and do not have the same resilience properties as delayed functions. The failure of a worker containing an actor cannot be recovered from. Many other actor systems offer some ability to recover from failures, and if you find yourself depending heavily on actors, you may wish to explore alternatives.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="id695"><sup><a href="ch07.xhtml#id695-marker">1</a></sup> See the <a href="https://oreil.ly/btzJK">ZooKeeper documentation</a> for an understanding of ZooKeeper’s distributed performance.</p><p data-type="footnote" id="id696"><sup><a href="ch07.xhtml#id696-marker">2</a></sup> The actor model was extended in 1985 for concurrent computation; see <a href="https://oreil.ly/uPCfx">“Actors: A Model of Concurrent Computation in Distributed Systems”</a> by Gul Abdulnabi Agha.</p><p data-type="footnote" id="id697"><sup><a href="ch07.xhtml#id697-marker">3</a></sup> Think COBOL, where the author left and the documentation was lost, but when you tried to turn it off accounting came running, literally.</p><p data-type="footnote" id="id706"><sup><a href="ch07.xhtml#id706-marker">4</a></sup> A <em>coarse-grained</em> actor is one that may contain multiple pieces of state; a <em>fine-grained</em> actor is one where each piece of state would be represented as a separate actor. This is similar to the concept of <a href="https://oreil.ly/7RMkS">coarse-grained locking</a>.</p></div></div></section></div></body></html>