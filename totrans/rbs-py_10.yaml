- en: 'Chapter 8\. User-Defined Types: Enums'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, I’m going to focus on what a user-defined type is and cover
    the simplest user-defined data type: enumerations. I’ll discuss how to create
    an enumeration that will protect your code from common programming mistakes. I’ll
    then go over advanced features that allow you to express your ideas more clearly,
    such as creating aliases, making enumerations unique, or providing automatically
    generated values.'
  prefs: []
  type: TYPE_NORMAL
- en: User-Defined Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A user-defined type is a type that you, as a developer, create. You define what
    data is associated with the type and what behaviors are associated with your type.
    Each of these types should tie to a singular concept. This will help other developers
    build mental models about your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if I am writing restaurant point-of-sale systems, I would expect
    to come across concepts about the restaurant domain in your codebase. Concepts
    like restaurants, menu items, and tax calculations should all be naturally represented
    in code. If I were to use lists, dictionaries, and tuples instead, I’d force my
    readers to constantly reinterpret the meaning of variables to their more natural
    mappings.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a simple function that calculates a total with tax. Which function
    would you rather work with?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By using the custom type `Restaurant`, you give readers crucial knowledge about
    the behavior of your code. Simple as it may be, it is incredibly powerful to build
    out these domain concepts. Eric Evans, author of *Domain-Driven Design*, wrote,
    “The heart of software is its ability to solve domain-related problems for its
    user.”^([1](part0012_split_011.html#idm45644744508088)) If the heart of software
    is the ability to solve domain-related problems, domain-specific abstractions
    are the blood vessels. They are the support system, the network that flows through
    your codebase, all tying back to the central life giver that is the reason your
    code exists. By building up great domain-related types, you build a healthier
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The most readable codebases are those that can be reasoned about, and it’s easiest
    to reason about the concepts that you encounter in your day to day. Newcomers
    to the codebase will already have a leg up if they are familiar with the core
    business concepts. You’ve spent the first part of this book focusing on expressing
    intent through annotations; this next part will focus on communicating intentions
    by building a shared vocabulary and making that vocabulary available to every
    developer working in the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way you’ll learn how to map a domain concept to a type is through
    Python’s enumeration type: `Enum`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some scenarios, you want a developer to pick one value from a list. Colors
    of a traffic light, pricing plans of a web service, and HTTP methods are all great
    examples of this type of relationship. To express that relationship in Python,
    you should use *enumerations*. Enumerations are a construct that let you define
    the list of values, and developers pick the specific value they want. Python first
    supported enumerations in Python 3.4.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate what makes enumerations so special, let’s suppose you are developing
    an application that makes French cooking more accessible by providing a home-delivery
    network, from baguettes to beignets. It features a menu from which hungry users
    can select and then receive all the ingredients and cooking instructions by mail.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popluar offerings in this app is the customization. Users can
    pick which meat they want, which side, and which sauce to prepare. One of the
    most essential parts of French cooking is its *mother sauces*. These five well-known
    sauces are building blocks for countless other sauces, and I want to programmatically
    add new ingredients to these, creating what’s known as *daughter sauces*. This
    way, users can learn how French sauces are categorized when they order their food.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose I represent the mother sauces as a Python tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What does this tuple communicate to other developers?
  prefs: []
  type: TYPE_NORMAL
- en: This collection is immutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can iterate over this collection to get all the sauces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can retrieve a specific element through static indexing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The immutability and retrieval properties are important for my application.
    I don’t want to add or subtract any mother sauces at runtime (such would be culinary
    blasphemy). Using a tuple makes it clear to future developers that they should
    not change these values. Retrieval lets me choose just one sauce, although it
    is a bit clunky. Every time I need to reference an element, I can do so through
    static indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This unfortunately does not communicate intent. Every time a developer sees
    this, they must remember that `2` means `"Espagnole"`. Constantly correlating
    numbers to sauces wastes time. This is fragile and will invariably cause mistakes.
    Should somebody alphabetically sort the sauces, the indices will change, breaking
    the code. Statically indexing into this tuple will not help the robustness of
    this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To combat this, I’ll make aliases for each of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That’s a bit more code, and still doesn’t make it any easier to index into that
    tuple. Furthermore, there is still a lingering issue in calling code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a function that creates a daughter sauce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I want you to pause a moment and consider what this function tells future developers.
    I’m purposely leaving out the implementation, because I want to talk about first
    impressions; the function signature is the first thing a developer will see. Based
    on the function signature alone, does this function properly convey what is allowed?
  prefs: []
  type: TYPE_NORMAL
- en: 'Future developers would come across code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: And here lies the crux of the problem. On the happy path, a developer can use
    the predefined variables. But if somebody accidentally were to use the wrong sauce
    (after all, `create_daughter_sauce` expects a string, which could be anything),
    you soon get unwanted behavior. Remember, I am talking about developers looking
    at this months (or potentially years) later. They have been tasked to add a feature
    to the codebase, even though they are not familiar with it. By choosing a string
    type, I’m just inviting the wrong values to be supplied later.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Even honest mistakes have ramifications. Did you catch that I left an accent
    off of the “e” in `Velouté`? Have fun debugging that in production.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you want to find a way to communicate that you want a very specific,
    restricted set of values in specific locations. Since you’re in a chapter about
    “enumerations” and I haven’t shown them yet, I’m sure you can guess what the solution
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Enum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s an example of Python’s enumeration, `Enum`, in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To access specific instances, you can just do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is near identical to the string aliases, but there are a few extra benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot accidentally create a `MotherSauce` with an unexpected value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That will certainly limit errors (either with invalid sauces or innocent typos).
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to print out all the values of the enumeration, you can simply
    iterate over the enumeration (no need to create a separate list).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, and crucially, you can communicate your intent in functions that use
    this `Enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This tells all the developers looking at this function that they should be passing
    in a `MotherSauce` enumeration, and not just any old string. It becomes much harder
    to introduce typos or incorrect values. (A user can still pass wrong values if
    they really want to, but they would be in direct violation of what’s expected,
    which is easier to catch—I covered how to catch these errors in [Part I](part0004.html#part_1).)
  prefs: []
  type: TYPE_NORMAL
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What sets of data in your codebase would benefit from an `Enum`? Do you have
    areas of code where developers pass in the wrong value, even though it is the
    right type? Discuss where enumerations would improve your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: When Not to Use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enumerations are great for communicating a static set of choices for users.
    You don’t want to use them where your options are determined at runtime, as you
    lose a lot of their benefits around communicating intent and tooling (it is much
    tougher for a reader of code to know what values are possible if they can change
    in every run-through). If you find yourself in this situation, I recommend a dictionary,
    which offers a natural mapping between two values that can be changed at runtime.
    You will need to perform membership checks if you need to restrict what values
    a user can select, though.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you master the basics of enumerations, there are quite a few things you
    can do to even further refine your usage. Remember, the more specific type you
    choose, the more specific information you convey.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For some enumerations, you might want to explicitly specify that you don’t care
    about the value that the enumeration is tied to. This tells users that they should
    not rely on these values. For this, you can use the `auto()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `auto()` will select monotonically increasing values (1, 2, 3,
    4, 5…). If you would like to control what values are set, you should implement
    a `_generate_next_value_()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Very rarely will you see `_generate_next_value_` defined like this, right inside
    of an enumeration with values. If `auto` is used to indicate that the value doesn’t
    matter, then `_generate_next_value_` indicates that you want very specific values
    for `auto`. It feels contradictory. This is why you typically use `_generate_next_value_`
    in base `Enum` classes, which are enumerations that are meant to be subtyped and
    don’t include any values. The `Flag` class, which you’ll see next, is a good example
    of a base class.
  prefs: []
  type: TYPE_NORMAL
- en: Flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have the mother sauces represented in an `Enum`, you decide that
    you are ready to start serving meals with those sauces. But before you begin,
    you want to be conscious of your customers’ allergies, so you decide to represent
    allergy information for each dish. With your newfound knowledge of `auto()`, setting
    up the `Allergen` enumeration is a piece of cake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And for a recipe, you might track a list of allergens as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This tells readers that a collection of allergens will be unique, and that there
    might be zero, one, or many allergens. This is exactly what you want. But what
    if I wanted all allergen information in the system to be tracked like this? I
    don’t want to rely on every developer remembering to use a set (just one use of
    a list or dictionary can invite wrong behavior). I want some way to represent
    a grouping of unique enumeration values universally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enum` module gives you a handy base class to use—`Flag`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This lets you perform bitwise operations to combine allergens or check if certain
    allergens are present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is great when you want to represent a selection of values (say, something
    that was set through a multi–drop down or a bitmask). There are some limitations,
    though. The values must support the bitwise operations (|, &, etc.). Strings would
    be an example of types that don’t, while integers do. Furthermore, the values
    cannot overlap when bitwise operations are performed. For example, you cannot
    use the values from 1 through 4 (inclusive) for your `Enum` because 4 will “bitwise
    and” for the values 1, 2, and 4 which is probably not what you want. `auto()`
    takes care of this for you because the `_generate_next_value_` of `Flag` automatically
    uses powers of 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The use of flags can express what you mean in very specific circumstances, but
    if you ever want more control of your values, or are enumerating values that don’t
    support bitwise operations, use a nonflag `Enum`.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note, you are free to create your own aliases for built-in multiple
    enumeration selections, as I did with `SEAFOOD` and `ALL_NUTS` above.
  prefs: []
  type: TYPE_NORMAL
- en: Integer Conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two more special case enumerations called `IntEnum` and `IntFlag`.
    These map to `Enum` and `Flag`, respectively, but allow degradation to raw integers
    for comparison. I actually do not recommend using these features, and it’s important
    to understand why. First, let’s look at the problem they intend to solve.
  prefs: []
  type: TYPE_NORMAL
- en: In French cooking, the measurement of certain ingredients is paramount to success,
    so you need to make sure you have that covered as well. You create a metric and
    imperial liquid measure (you want to work internationally, after all) as enumerations,
    but are dismayed to find that you can’t just compare your enumerations to integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code doesn’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'But, if you were to subclass from `IntEnum`, it works just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'An `IntFlag` performs similarly. You’ll see this more when interoperating between
    systems or possibly hardware. If you were not using an `IntEnum`, you would need
    to do something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The convenience of using an `IntEnum` does not often outweigh the drawback of
    being a weaker type. Any implicit conversion to integer hides the true intent
    of the class. Since implicit integer conversion happens, you might run into a
    copy/paste mistake (we’ve all made those, right?) in situations that don’t do
    what you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose somebody were to mistakenly do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If this makes it into production, it will be just fine, no exceptions thrown,
    all tests pass. However, once the `Kitchenware` enumeration changes (maybe it
    adds a `BOWL` into value `8` and moves `CUP` to `10`), this code will now do the
    exact opposite of what it was supposed to. `Kitchenware.CUP` is no longer the
    same as an `ImperialLiquidMeasure.CUP` (there’s no reason they should be linked);
    then you’ll start pouring into larger vessels instead of smaller vessels, which
    probably will create an overflow (of your liquid, not of an integer).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a textbook example of how unrobust code can lead to subtle mistakes
    that won’t become an issue until much later in the codebase’s life. This may be
    a quick fix, but the bug incurs a very real cost. Tests fail (or worse, a customer
    complains about pouring the wrong amount of liquid into a vessel), someone has
    to go crawl through the source code, find the bug, fix it, then take a long coffee
    break after wondering how this ever worked. All because somebody decided to be
    lazy and use an `IntEnum` so that they wouldn’t have to type out `.value` over
    and over again. So pay your future maintainers a favor: don’t use `IntEnum` unless
    you absolutely have to for legacy purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: Unique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One great feature of enumerations is the ability to alias values. Let’s go back
    to the `MotherSauce` enumeration. Maybe the codebase developed on French keyboards
    needs to be adapted to US keyboards, where the keyboard layout is not conducive
    to adding accent marks over vowels. Removing the accents to anglicize the native
    French spelling is a nonstarter for many of the developers (they insist we use
    the original spelling). To avoid an international incident, I will add an alias
    to some of the sauces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With this, there was much rejoicing from all keyboard owners. Enumerations absolutely
    allow this sort of behavior; they can have duplicate values as long as the keys
    are not duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are cases where you want to force uniqueness on the values. Perhaps
    you are relying on the enumeration to always contain a set number of values, or
    perhaps it messes with some of the string representations that are shown to customers.
    No matter the case, if you want to preserve uniqueness in your `Enum`, simply
    add a `@unique` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Creating aliases is more likely than preserving uniqueness in most of the use
    cases I’ve come across, so I default to making enumerations nonunique at first,
    and only adding the unique decorator when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumerations are simple, and often overlooked as a powerful communication method.
    Any time that you want to represent a single value from a static collection of
    values, an enumeration should be your go-to user-defined type. It’s easy to define
    and use them. They offer a wealth of operations, including iteration, bitwise
    operations (in the case of `Flag` enumerations), and control over uniqueness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember these key limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations are not meant for dynamic key-value mappings that change at runtime.
    Use a dictionary for this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flag` enumerations only work with values that support bitwise operations with
    nonoverlapping values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid `IntEnum` and `IntFlag` unless absolutely necessary for system interoperability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next up, I will explore another user-defined type: a `dataclass`. While enumerations
    are great at specifying a relationship about a set of values in just one variable,
    data classes define relationships between multiple variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](part0012_split_001.html#idm45644744508088-marker)) Eric Evans. *Domain-Driven
    Design: Tackling Complexity in the Heart of Software*. Upper Saddle River, NJ:
    Addison-Wesley Professional, 2003.'
  prefs: []
  type: TYPE_NORMAL
