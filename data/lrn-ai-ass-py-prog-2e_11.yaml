- en: 12 Future directions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 未来发展方向
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章内容包括
- en: Using prompt patterns to write and explain code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用提示模式编写和解释代码
- en: Current limitations and future directions of generative AI tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成式AI工具的当前局限性与未来发展方向
- en: In this final chapter, we want to give you a glimpse of the creative ways people
    are currently using generative AI tools such as GitHub Copilot and ChatGPT. For
    example, it’s possible to make Copilot Chat ask you the questions, rather than
    the other way around. And it’s possible to make Copilot take on a different persona
    to be even more helpful to your current programming task. We’re going to keep
    this brief, and it’s not clear how much of this will become standard practice,
    but we want to take this opportunity to demonstrate the power of being creative
    with these new tools. We’ll also talk about some of the current limitations of
    generative AI tools (you’ve seen some of them already in this book!) and offer
    our thoughts on what may be next.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们想给你一个 glimpse（瞥见）目前人们使用生成式AI工具（如GitHub Copilot和ChatGPT）的一些创造性方法的机会。例如，现在可以让Copilot
    Chat问你问题，而不是你去问它。而且，可以让Copilot采取不同的人物角色，以便更好地帮助你完成当前的编程任务。我们会简短地介绍这些内容，虽然目前还不清楚其中有多少会成为标准实践，但我们希望借此机会展示如何通过创造性地使用这些新工具来发挥它们的强大功能。我们还将讨论生成式AI工具的当前局限性（你已经在本书中看到过其中的一些！），并提出我们对未来的看法。
- en: 12.1 Prompt patterns
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 提示模式
- en: Throughout the book, we’ve conveyed why programming directly in Python is a
    very different experience compared to programming using Copilot. Rather than writing
    code, our focus shifts to writing prompts and interacting with the generated code
    to determine whether or not it’s correct, and then fixing it if needed. But along
    with those differences, there are surprising similarities between coding without
    Copilot and coding with Copilot.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们传达了为什么直接用Python编程与使用Copilot编程是非常不同的体验。我们的重点不再是编写代码，而是编写提示语，并与生成的代码进行交互，以确定其是否正确，然后在需要时进行修正。但与这些差异相伴的，还有一些令人惊讶的相似之处，既有不使用Copilot时的编程方式，也有使用Copilot时的编程方式。
- en: 'When programmers write code, they don’t start from scratch each time they write
    a new program. Researchers and programmers have created catalogs of design *patterns*,
    that is, general-purpose ways of organizing programs to make them easier to write,
    debug, and extend. The most famous such catalog is a book called *Design Patterns:
    Elements of Reusable Object-Oriented Software* [1], also known as the “Gang of
    Four book” because it was written by four authors. It requires familiarity with
    object-oriented programming, which we haven’t taught in this book, so we don’t
    recommend picking up that book quite yet. Just know that thousands of programmers
    have saved thousands of hours using the patterns in this book and not reinventing
    the wheel.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员编写代码时，他们并不是每次编写新程序时都从零开始。研究人员和程序员们创建了设计的*模式*，即组织程序的通用方法，使得编写、调试和扩展程序变得更加容易。最著名的这种模式目录是一本名为《*设计模式：可重用面向对象软件的元素*》的书[1]，也被称为“四人帮书”，因为它是由四位作者共同编写的。它要求熟悉面向对象编程，而我们在本书中并未教授这一内容，因此我们不建议你现在就去读这本书。只要知道，成千上万的程序员通过使用这本书中的模式，节省了成千上万个小时的时间，而不是重复发明轮子。
- en: 'As just one example of a design pattern, suppose that you’re writing a computer
    game where a human player plays against the computer. You want to implement several
    AI opponents of varying difficulties (e.g., beginner, intermediate, advanced,
    and expert) to provide different skill levels of opponents for the human. Each
    AI opponent will have its own code for determining its behavior. It would be possible
    to use `if` conditions to determine what the AI opponent should do:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计模式的一个例子，假设你正在编写一个电脑游戏，其中玩家与计算机对战。你希望实现多个具有不同难度（例如：初级、中级、高级和专家级）的AI对手，为人类玩家提供不同的对战技能水平。每个AI对手将拥有自己的代码来决定其行为。可以使用`if`条件来确定AI对手应该做什么：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The downside to doing it that way, though, is organizational. We’d have all
    the AI code for the various AI opponents in the same place. We know from what
    we’ve learned in this book that huge functions like that aren’t easy to design
    and test.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方式的缺点是组织上的。我们会将所有AI对手的AI代码放在同一个地方。从本书所学，我们知道像这样的庞大函数并不容易设计和测试。
- en: The clean way to organize this kind of program is using a pattern called the
    *strategy pattern*. We’re not going to go into details of that pattern here, but
    the important thing is that people have documented this pattern [1] for others
    to use. The pattern documentation tells you its intent (purpose), motivation for
    why we would use it, the structure of the code needed to implement it, and example
    code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 组织这种程序的简洁方式是使用一种名为*策略模式*的模式。我们在这里不会详细讨论该模式，但重要的是，人们已经为他人记录了这一模式[1]。该模式的文档告诉你它的意图（目的）、使用它的动机、实现它所需的代码结构以及示例代码。
- en: Researchers are beginning to catalog patterns that can be used with generative
    AI tools like GitHub Copilot and ChatGPT [2]. They’re called *prompt patterns*,
    and similar to design patterns, they tell you how to construct a prompt to achieve
    a desired goal. The documentation for each of these patterns is similar to the
    documentation for design patterns, but rather than example code, we get example
    prompts that we can use.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员开始对可以与生成式人工智能工具（如GitHub Copilot和ChatGPT）一起使用的模式进行编目[2]。这些模式被称为*提示模式*，类似于设计模式，它们告诉你如何构建提示，以实现期望的目标。每个模式的文档类似于设计模式的文档，但与示例代码不同，我们得到的是可以使用的示例提示。
- en: 'In this book, we’ve spent most of our time on two types of AI responses: generating
    code (by pressing Tab in VS Code) and explaining code (by using Copilot Chat).
    The new prompt patterns that are emerging can help generative AI tools go beyond
    these to help with other code-related tasks.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们大部分时间集中在两种类型的AI回应：生成代码（通过在VS Code中按Tab键）和解释代码（通过使用Copilot Chat）。正在出现的新提示模式可以帮助生成式AI工具超越这些，协助其他与代码相关的任务。
- en: 'To give you a flavor of the state of the art in prompt patterns, we’ll sample
    a couple of them here. For many more, we encourage you to check the catalog of
    prompt patterns that we’ve used [2]. Be warned, though: we’re referring you to
    an academic paper, rather than a beginner’s guide because we’re not aware of any
    beginner’s guides at this time (this is still new stuff).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解提示模式的最新进展，我们将在这里展示其中一些样本。更多的模式，请参考我们所使用的提示模式目录[2]。不过要注意，我们推荐的是一篇学术论文，而不是初学者指南，因为目前我们没有看到任何初学者指南（这仍然是新兴的内容）。
- en: Copilot Chat may not engage in these prompt patterns
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Copilot Chat可能不会参与这些提示模式
- en: At the time of writing, Copilot Chat refuses to engage in some of the cataloged
    prompt patterns, claiming that they are unrelated to programming assistance. While
    some may be less specifically related to programming, they are all designed to
    help programmers. Unlike ChatGPT, Copilot has been designed to try to always stay
    squarely on the topic of programming. If you decide to explore the variety of
    patterns further, you may wish to do so using ChatGPT when your interaction with
    Copilot isn’t productive.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Copilot Chat拒绝参与一些已编目的提示模式，声称它们与编程辅助无关。虽然其中一些可能与编程的关系不那么具体，但它们都旨在帮助程序员。与ChatGPT不同，Copilot被设计成尽量始终专注于编程主题。如果你决定进一步探索这些多样的模式，可能希望在与Copilot的互动不太有效时，使用ChatGPT进行尝试。
- en: 12.1.1 Flipped interaction pattern
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 翻转互动模式
- en: To this point, we’ve been the one requesting code and asking questions, and
    Copilot has been the one answering. But it’s possible to flip the script so that
    Copilot does the asking and we do the answering. This is called the *flipped interaction
    pattern*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直是请求代码并提问，而Copilot则是回答。但有可能翻转剧本，让Copilot来提问，我们来回答。这被称为*翻转互动模式*。
- en: 'The intent of this pattern is to help us interact with the AI when we don’t
    know what information it needs to perform a task. The motivation is that the AI
    may know what to ask us to get to its goal faster than if we provided incomplete
    or unhelpful information. The structure of our prompt will look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的目的是帮助我们与人工智能互动，尤其是在我们不知道它需要什么信息来执行任务时。其动机是，人工智能可能比我们提供不完整或无效信息时，知道应该向我们提问什么，以便更快速地达到目标。我们的提示结构将如下所示：
- en: I would like you to ask me questions to achieve X. You should ask questions
    until we achieve this goal, where X is the goal we’d like to achieve.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你向我提问，以实现X。你应该继续提问，直到我们实现这个目标，其中X是我们希望实现的目标。
- en: This structure isn’t meant to precisely dictate the prompt that we should use.
    Rather, it cues us to the key ideas that we need to convey in the prompt. Here,
    for example, the key ideas are that we want Copilot to ask the questions and that
    we don’t want it to stop until our goal has been achieved.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构并不是为了精确规定我们应该使用的提示词。相反，它提醒我们需要在提示中传达的关键想法。例如，这里的关键想法是我们希望Copilot提问，并且希望它在我们达成目标之前不要停止。
- en: In chapter 3, we wrote a function to keep asking the user for a password until
    they typed a strong password. Suppose we weren’t sure how to design this function.
    We could ask Copilot to design it for us by providing a code prompt, but then
    it might make decisions that we don’t agree with. Instead, we can have Copilot
    ask us the questions. Let’s use Copilot Chat to do this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章中，我们编写了一个函数，不断要求用户输入密码，直到他们输入一个强密码。假设我们不确定如何设计这个函数。我们可以请求Copilot为我们设计它，通过提供代码提示，但那样可能会做出我们不同意的决定。相反，我们可以让Copilot问我们问题。我们来使用Copilot
    Chat来实现这一点。
- en: LPHumanI would like a Python function that keeps asking the user for a password
    until they provide a strong password. Ask me questions one at a time until you
    can write that Python function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我希望有一个Python函数，不断要求用户输入密码，直到他们提供一个强密码。请每次问我一个问题，直到你能编写出这个Python函数。
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Sure, I’d be happy to help
    you write a Python function that keeps asking the user for a strong password!
    Here are some questions to get started:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 当然，我很乐意帮助你编写一个Python函数，不断要求用户输入强密码！以下是一些问题，供你开始：'
- en: What do you consider to be a strong password?
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为什么是强密码？
- en: Should the function have any input parameters?
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数应该有任何输入参数吗？
- en: What should the function return?
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数应该返回什么？
- en: Should the function have any side effects, such as printing messages to the
    console?
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数应该有任何副作用，比如向控制台打印信息吗？
- en: Should the function have any error handling, such as handling invalid input
    from the user?
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数应该有任何错误处理机制吗，比如处理来自用户的无效输入？
- en: Copilot failed to follow our instruction to “Ask me questions one at a time.”
    Let’s remind it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot没有按照我们的指示“每次问我一个问题”来操作。我们来提醒它一下。
- en: LPHumanAsk me the questions one at a time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman每次问我一个问题。
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Sure, let’s start with the
    first question:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 好的，让我们从第一个问题开始：'
- en: What do you consider to be a strong password?
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为什么是强密码？
- en: Now we can start answering the questions. Copilot will use the answers to these
    questions to write the code for us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始回答问题了。Copilot将根据这些答案为我们编写代码。
- en: LPHumanThe password must have at least one uppercase character, at least one
    number, and at least one punctuation mark.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman密码必须至少包含一个大写字母、一个数字和一个标点符号。
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Great, thanks for letting me
    know! Here’s the next question:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 太好了，感谢你告诉我！这是下一个问题：'
- en: 2\. Should the function have any input parameters?
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 这个函数应该有任何输入参数吗？
- en: LPHumanI don’t know. What would they be used for?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我不知道。它们会被用来做什么？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Input parameters are used to
    pass data into a function so that the function can perform some operation on that
    data. For example, if we want to write a function that adds two numbers together,
    we would need to pass those two numbers into the function as input parameters.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 输入参数用于将数据传递到函数中，以便函数对这些数据执行某些操作。例如，如果我们想编写一个将两个数字相加的函数，我们需要将这两个数字作为输入参数传递给函数。'
- en: In the case of our password function, we might want to pass in some parameters
    that define the requirements for a strong password. For example, we might want
    to pass in the minimum length of the password, the required number of uppercase
    characters, the required number of numbers, and the required number of punctuation
    characters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的密码函数中，我们可能希望传入一些参数来定义强密码的要求。例如，我们可能希望传入密码的最小长度、要求的大写字母数量、要求的数字数量以及要求的标点符号数量。
- en: Alternatively, we could hard-code these requirements into the function itself,
    but using input parameters would make the function more flexible and reusable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以将这些要求硬编码到函数中，但使用输入参数会使函数更加灵活和可重用。
- en: LPHumanPlease hard-code them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: LPHumanPlease硬编码它们。
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Sure, we can hard-code the
    password requirements into the function itself. Here’s the next question:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 当然，我们可以将密码要求硬编码到函数本身。接下来是下一个问题：'
- en: 3\. What should the function return?
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 该函数应该返回什么？
- en: LPHumanIt should return the user’s strong password.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman它应该返回用户的强密码。
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Great, thanks for letting me
    know! Here’s the next question:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 太好了，谢谢你告诉我！接下来是下一个问题：'
- en: 4\. Should the function have any side effects, such as printing messages to
    the console?
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 该函数是否应该有副作用，例如向控制台打印消息？
- en: We’ll stop here as we don’t think it’s interesting to read our full interaction.
    We continued our conversation with Copilot and answered questions 4 and 5, and
    Copilot had the information it needed to write the code we wanted. The code we
    ultimately received, after answering all five questions, is shown in the following
    listing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到此为止，因为我们认为阅读完整的交互过程并不有趣。我们继续与Copilot对话并回答了问题4和5，Copilot获取了所需的信息，能够编写我们想要的代码。最终我们收到的代码，在回答完所有五个问题后，显示在以下列表中。
- en: Listing 12.1 Function designed via the flipped interaction pattern
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.1 通过反转交互模式设计的函数
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#1 There’s no way to make this True condition False!'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这个True条件永远无法变为False！'
- en: '#2 If there’s no uppercase character in the password'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 如果密码中没有大写字母'
- en: '#3 If there’s no digit character in the password'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 如果密码中没有数字字符'
- en: '#4 If there’s no punctuation character in the password'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 如果密码中没有标点符号'
- en: '#5 This is how we get out of the “while True” loop.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 这就是我们退出“while True”循环的方法。'
- en: In our `while` loops to this point, we’ve always used a loop condition that
    we hope eventually becomes `False` (otherwise, we’d have an infinite loop). For
    example, we could imagine having a loop that says, in effect, “while the password
    is not valid.” But here, the code is using `while True`, and `True` is a condition
    that can never become `False`. There must be some other way out of the loop—and
    there is! We get out of the loop through a `return` statement when the password
    is valid. That is, instead of “while the password is not valid,” the logic here
    is “loop forever; if the password is valid, stop looping.” The `while True` form
    of `while` loops is a common alternative structure to the style that we’ve seen
    throughout the book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到目前为止的`while`循环中，我们总是使用一个我们希望最终变为`False`的循环条件（否则我们将遇到无限循环）。例如，我们可以想象有一个循环，实际上是“当密码无效时”。但在这里，代码使用的是`while
    True`，而`True`是一个永远不会变为`False`的条件。必须有其他方式可以退出循环——确实有！当密码有效时，我们通过`return`语句退出循环。也就是说，这里的逻辑是“循环永远进行；如果密码有效，则停止循环。”`while
    True`形式的`while`循环是我们在本书中看到的一种常见替代结构。
- en: This code does a good job of implementing our task. It starts with some `print`
    calls to tell the user the rules for strong passwords. It also tells the user
    what’s wrong with their password if, in fact, it isn’t strong. It keeps looping
    until the user enters a strong password. And, when we eventually have a strong
    password from the user, we return it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很好地实现了我们的任务。它首先通过一些`print`调用告诉用户强密码的规则。如果密码不够强，它还会告诉用户密码的错误之处。它会一直循环，直到用户输入一个强密码。当用户最终输入强密码时，我们就返回它。
- en: Now, we already knew how to write this function because of our work in chapter
    3\. And your Python knowledge by this point is sufficiently strong that you can
    cut to the chase and write the function signature for Copilot to write the code
    as we’ve been doing throughout the book. But for tasks with which you’re less
    familiar and may not know where to start, this flipped interaction pattern may
    help.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，鉴于我们在第三章中的工作，我们已经知道如何编写这个函数。到目前为止，你的Python知识已经足够强大，你可以直接切入正题，写出函数签名，让Copilot按照我们在本书中一直做的方式编写代码。但对于一些你不太熟悉的任务，并且可能不知道从哪里开始的情况，这种反转交互模式可能会有所帮助。
- en: 12.1.2 Persona pattern
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 人物模式
- en: 'The intent of this pattern is to have the AI take on a particular persona or
    point of view. Why would we ever be motivated to do this? Well, here’s an example:
    say you’re a student in an introductory Python programming course. Your instructor
    is using Copilot as part of the course, but they are disallowing some Python features
    that they feel detract from learning introductory Python. You could ask Copilot
    to take on the persona of that instructor and then help you check your code to
    find and, if necessary, remove any disallowed Python features. The structure of
    our prompt will look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的目的是让AI扮演特定的角色或观点。为什么我们会有动机这么做呢？举个例子：假设你是一个初学Python编程课程的学生。你的老师在课程中使用Copilot，但他们禁止了一些他们认为会影响学习初级Python的Python功能。你可以要求Copilot扮演这位教师的角色，然后帮助你检查代码，找出并在必要时移除任何不允许使用的Python功能。我们提示的结构看起来会是这样的：
- en: From now on, act as persona X. Provide outputs that persona X would create.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，扮演角色X。提供角色X会创建的输出。
- en: We’ll fill in X with a particular persona. Let’s try this with our introductory
    programming instructor persona. We’ll ask Copilot to play the part, disallowing
    a list of more advanced Python concepts. (Don’t worry if you’ve never heard of
    these!)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一个特定的人物角色来填充X。让我们尝试使用我们介绍性编程教师的角色。我们将要求Copilot扮演这个角色，同时禁止一些更高级的Python概念。（即使你从未听说过这些概念，也不用担心！）
- en: 'LPHumanFrom now on, act as an introductory Python programming instructor. In
    the course that you’re teaching, the following Python features aren’t allowed:
    list comprehensions, generators, “lambda”, and the “any” function. I will provide
    code, and you’ll review the code for any Python features that aren’t allowed and
    suggest how to rewrite the code to not use those features.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman 从现在开始，扮演一名初级Python编程课程的教师。在你教授的课程中，以下Python特性是不允许的：列表推导式、生成器、`lambda`
    以及 `any` 函数。我将提供代码，你将检查这些代码，找出任何不允许使用的Python功能，并建议如何重写代码以不使用这些功能。
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Sure, I can do that! Please
    provide the code you would like me to review.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 好的，我可以做到！请提供你希望我审查的代码。'
- en: Let’s feed it the `get_strong_password` function from the previous section.
    It uses the `any` function, and by our persona rules, that function isn’t allowed.
    Here’s our original code and what Copilot does in response.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输入上一节的 `get_strong_password` 函数。它使用了 `any` 函数，而根据我们的角色规则，这个函数是不允许的。以下是我们原始的代码和Copilot做出的响应。
- en: '**LPHuman**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**LPHuman**'
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot The `get_strong_password` function
    uses the `any` function, which is not allowed in your course. Here’s a modified
    version of the function that does not use the `any` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot `get_strong_password` 函数使用了
    `any` 函数，而你的课程中不允许使用该函数。以下是一个不使用 `any` 函数的修改版本：'
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 The loop that replaces “any”'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 替换“any”的循环'
- en: This version of the function uses a `for` loop to iterate over each character
    in the password and check if it meets the requirements. This approach is more
    verbose than using the `any` function, but it does not use the disallowed Python
    features.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的函数使用 `for` 循环遍历密码中的每个字符，检查它是否符合要求。这个方法比使用 `any` 函数更冗长，但它没有使用被禁止的Python功能。
- en: As Copilot Chat indicated, this program doesn’t use the `any` function. Copilot
    has rewritten the program to avoid that function, thereby following the rules
    set by our Python programming persona.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Copilot Chat所指出的，这个程序没有使用 `any` 函数。Copilot已经重写了程序，避免了使用该函数，从而遵守了我们Python编程角色设定的规则。
- en: The `any` function returns `True` if one or more values in its argument are
    true, and `False` if all values in its argument are false. Behind the scenes,
    `any` must be looking at each value to check whether it’s true or false. Sounds
    like a loop, right? Indeed, a loop is exactly what Copilot has used here to replace
    the `any` function calls.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`any` 函数会返回 `True`，如果它的参数中有一个或多个值为真；如果所有的值都为假，则返回 `False`。在幕后，`any` 必须查看每个值以检查它是对还是错。这听起来像是一个循环，对吧？事实上，Copilot正是用循环来替代
    `any` 函数调用的。'
- en: 12.2 Limitations and future directions
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 限制与未来方向
- en: In our experience working with Copilot (and students) and reading the research
    literature published while we were writing this book, we’ve observed some limitations
    and future possibilities of generative AI models that we wanted to share.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们与Copilot（以及学生）合作的经验中，并阅读了在我们编写本书期间发布的研究文献时，我们观察到了一些生成式AI模型的局限性和未来可能性，我们希望分享这些观察。
- en: 12.2.1 Where Copilot (currently) struggles
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 Copilot（当前）面临的挑战
- en: 'We found that Copilot struggles in three different types of scenarios: contrived
    problems, ill-defined problems, and large tasks.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现 Copilot 在三种不同的场景中遇到了困难：人为设计的问题、不明确的问题和大型任务。
- en: Contrived problems
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 人为设计的问题
- en: 'Shortly after ChatGPT and GitHub Copilot took the world by storm, programming
    instructors feverishly worked to find types of tasks that these tools couldn’t
    do well. One early proposal was to use contrived tasks: tasks made obscure and
    convoluted in an attempt to misdirect tools like Copilot to have them generate
    incorrect code. To us, such tasks seem wholly uninteresting and unfair to students,
    and their use seems to be a last-ditch attempt to retain the previous style of
    programming courses without acknowledging the disruption wrought by tools like
    Copilot. Our sense is that these contrived tasks will eventually be solved by
    Copilot as the models continue to improve, but even if they aren’t, these types
    of problems aren’t generally important to solve anyway.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ChatGPT 和 GitHub Copilot 横扫全球后不久，编程教师们疯狂地寻找这些工具无法做好的任务类型。一项早期提议是使用人为设计的任务：通过使任务变得模糊和复杂，试图引导像
    Copilot 这样的工具生成错误的代码。对我们来说，这些任务完全没有趣味，并且对学生不公平，它们的使用似乎是在试图坚持之前的编程课程风格，而没有意识到像
    Copilot 这样的工具所带来的颠覆性变化。我们的感觉是，随着 Copilot 模型的不断改进，这些人为设计的任务最终会被 Copilot 解决，但即使没有解决，这些问题通常也不是必须要解决的。
- en: Ill-defined problems
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不明确的问题
- en: An ill-defined problem is a problem that hasn’t been precisely specified, meaning
    we don’t exactly know or haven’t decided what we should do in all cases. For example,
    asking Copilot for a function to determine whether a password is strong is ill-defined
    until we define what we mean by “strong password.” Your first thought may be that
    Copilot can’t possibly get better at solving these kinds of problems. After all,
    if we struggle to precisely specify the behavior we want, how are we going to
    communicate the required behavior to Copilot? Ill-defined problems are certainly
    challenging for Copilot, but they aren’t impossible. Remember the flipped interaction
    prompt pattern that we discussed earlier in the chapter? Perhaps, one day soon,
    Copilot will automatically switch into that mode when it doesn’t have enough precision
    from you to solve the problem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不明确的问题是指一个没有被精确描述的问题，这意味着我们并不完全知道或尚未决定在所有情况下应该做什么。例如，要求 Copilot 编写一个函数来判断密码是否强大，这就是一个不明确的问题，直到我们定义“强密码”是什么意思为止。你可能首先认为
    Copilot 不可能在解决这类问题上变得更好。毕竟，如果我们很难精确定义我们想要的行为，怎么能把所需的行为传达给 Copilot 呢？不明确的问题对于 Copilot
    确实是一个挑战，但并不是不可能解决的。还记得我们在本章早些时候讨论的反转交互提示模式吗？也许，不久的将来，当 Copilot 没有足够的精确信息来解决问题时，它会自动切换到这种模式。
- en: Large tasks
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 大型任务
- en: We’ve spent a lot of time throughout the book teaching you how to design small
    functions and how to organize those functions using top-down design to solve large
    problems. We did this because Copilot struggles when given a monolithic task to
    solve. Is this an inherent limitation of tools like Copilot, or can AI get past
    it? We don’t know. Right now, Copilot struggles with problem decomposition, and
    even if it could get that right, probabilities aren’t in its favor. Specifically,
    it has a higher probability of getting something wrong the more code it writes.
    For example, if it needs to write 20 functions to solve a task with each function
    averaging 10 lines, it’s almost certainly going to make a mistake somewhere. But
    it’s also foolish to bet against these systems. With advancements in how Copilot
    learns, perhaps this isn’t that far off after all.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们花了很多时间教你如何设计小功能，以及如何通过自顶向下的设计将这些功能组织起来，以解决大型问题。我们这么做是因为当面对一个整体性的任务时，Copilot
    很难解决。这个问题是类似 Copilot 的工具固有的局限性，还是人工智能能够克服它？我们不知道。现在，Copilot 在问题分解方面很挣扎，即便它能够做到这一点，概率也不在它的一边。具体来说，它写代码越多，出错的概率就越高。例如，如果它需要写
    20 个函数来解决一个任务，每个函数平均 10 行代码，它几乎肯定会在某个地方出错。但与这些系统对抗也是愚蠢的。随着 Copilot 学习方式的进步，也许这一点并不遥远。
- en: 12.2.2 Is Copilot a new programming language?
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 Copilot 是一种新的编程语言吗？
- en: When we write computer code in a language like Python, there’s a compiler behind
    the scenes converting the Python to an assembly code or machine code that the
    computer can understand. There was a time when programmers wrote code in an old
    computer language like Fortran or C, ran the compiler to produce code in assembly
    language, and then checked the assembly code to make sure it was correct. We weren’t
    around then, and it probably didn’t happen that much, but we can understand why
    programmers didn’t trust compilers back then. Compilers were a new technology,
    and it took time to work out the bugs. In addition, the code output from compilers
    was probably fairly inefficient compared to handwritten assembly. But after decades
    of improvements both to correctness and efficiency (compiler optimizations are
    a really exciting and interesting topic for anyone curious!), very few programmers
    ever look at the output of compilers. Could there be a point when humans simply
    use large language models (LLMs) as the primary interface to computers and don’t
    spend much time examining the code they produce? Let’s think about both possible
    answers to this question.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用像Python这样的语言编写计算机代码时，背后有一个编译器将Python代码转换为计算机能够理解的汇编代码或机器代码。曾经有一段时间，程序员用像Fortran或C这样的旧计算机语言编写代码，运行编译器生成汇编语言代码，然后检查汇编代码确保它是正确的。那时候我们还没出现过，可能也不会发生太多这样的情况，但我们能理解为什么当时程序员不信任编译器。编译器是一项新技术，而且需要时间来解决其中的错误。此外，编译器输出的代码相对于手写的汇编代码来说，可能效率较低。但经过几十年的改进，无论是在正确性还是效率方面（编译器优化对于任何好奇的人来说都是一个非常激动人心和有趣的主题！），现在很少有程序员会查看编译器的输出。是否可能会有这样的一天，人类只是将大型语言模型（LLMs）作为与计算机交互的主要接口，而不花太多时间检查它们生成的代码？让我们考虑一下这个问题的两种可能答案。
- en: Why LLMs may not replace programming languages
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么LLMs可能不会取代编程语言
- en: There are reasons to think LLMs won’t become the primary interface for humans
    to program computers. The principle one is that LLMs aren’t a stringent programming
    language. We trust compilers because there’s a programming language specification
    for each programming language and there’s a specified, exact behavior expected
    from each line of code. LLMs don’t have this. It’s just someone writing English
    or another natural language to an LLM. The LLM isn’t bound to interpret the natural
    language in a particular way. It doesn’t have to output the answer based on any
    rigorous specification. And, randomness and nondeterminism make it so the answer
    it gives us could vary or be wrong! Compilers are deterministic and by now are
    a mature, trusted technology. They don’t face these problems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有理由认为LLMs不会成为人类编程计算机的主要接口。最主要的原因是，LLMs不是一种严格的编程语言。我们信任编译器，因为每种编程语言都有其语言规范，并且每行代码都有指定的、精确的预期行为。而LLMs并没有这些。它只是有人用英语或其他自然语言向LLMs输入内容。LLMs并不一定按照某种特定的方式来解释自然语言。它不需要基于任何严格的规范输出答案。而且，由于随机性和非确定性，它给出的答案可能会有所不同或错误！编译器是确定性的，而且现在已经是一个成熟、值得信赖的技术。它们没有这些问题。
- en: Why LLMs may replace programming languages
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么LLMs可能会取代编程语言
- en: There are also reasons to believe that, like compilers, LLMs will get better
    and become our primary programming interface. In fact, for data science, this
    is already starting to happen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 也有理由相信，像编译器一样，大型语言模型（LLMs）将变得更好，并成为我们主要的编程接口。事实上，在数据科学领域，这已经开始发生了。
- en: 'As we’ve learned throughout the book, a key challenge to working with Copilot
    is determining whether the generated code is correct. In a sense, it isn’t fair
    to nonprogrammers: we give Copilot natural language (our preference), and it gives
    us back code that’s not in a natural language (the computer’s preference). It
    would be nice if we could “skip the code” and use natural language not only to
    communicate with Copilot but to receive our answer.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中所学到的，与Copilot合作的一个关键挑战是判断生成的代码是否正确。从某种意义上说，这对非程序员是不公平的：我们给Copilot提供自然语言（我们的偏好），而它给我们回馈的代码却不是自然语言（计算机的偏好）。如果我们可以“跳过代码”，不仅用自然语言与Copilot沟通，还能直接得到我们的答案，那就太好了。
- en: Researchers are beginning to explore this possibility in restricted domains
    of interest to millions of computer users. As one example, let’s think about data
    science. Data scientists make sense of data by exploring the data, visualizing
    the data, and using data to make predictions. Much of what they do involves manipulating
    data in constrained, well-understood ways, such as merging spreadsheets, cleaning
    particular columns of data, or conducting analyses such as clustering the data
    into meaningful categories or simplifying data to focus only on its core underlying
    structure. Data scientists who use Python use many libraries to work with their
    data, but one extremely popular library is called pandas.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员开始在计算机用户关注的受限领域探索这一可能性。举个例子，考虑数据科学。数据科学家通过探索数据、可视化数据以及利用数据进行预测来理解数据。他们所做的许多工作涉及以受限且广为人知的方式操作数据，例如合并电子表格、清理特定数据列，或进行聚类分析将数据划分为有意义的类别，或者简化数据以专注于其核心结构。使用Python的数据显示科学家通常会使用许多库来处理数据，但一个极为流行的库叫做pandas。
- en: 'Researchers have successfully “skipped the code” in this context of doing data
    science with pandas [3]. Here’s how it works:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员成功地在使用pandas进行数据科学的过程中“跳过了代码”[3]。它是如何运作的呢：
- en: The user expresses their intent in a natural language such as English.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户用自然语言表达他们的意图，例如英语。
- en: The AI generates Python code and runs it to get the result (e.g., a table of
    results for an analysis or a new spreadsheet) for the user. Importantly, the user
    doesn’t see this Python code.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AI生成Python代码并运行它，获取用户的结果（例如，分析结果表或新的电子表格）。重要的是，用户看不到这些Python代码。
- en: 'The AI converts the code back to natural language and presents that (not the
    Python code!) back to the user. The natural language that the user gets back is
    in a consistent format that can be reliably interpreted by the AI. The researchers
    describe the purpose of the response from the AI like this: “This is how you should
    ask the system to do what the system thinks you just asked it to do.” The response
    helps the user understand the capabilities of the AI and the types of queries
    that are effective.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AI将代码转换回自然语言，并将其（而不是Python代码！）呈现给用户。用户收到的自然语言是以一致的格式呈现的，AI可以可靠地理解。研究人员这样描述AI回应的目的：“这就是你应该告诉系统做你刚才要求它做的事情的方式。”
    这个回应帮助用户理解AI的能力以及哪些查询是有效的。
- en: The user can edit the natural language from step 3 if it’s not correct. If the
    user makes an edit, they can submit the new prompt, which repeats the cycle.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果自然语言从第三步返回的内容不正确，用户可以进行编辑。如果用户做出修改，他们可以提交新的提示，从而重复整个周期。
- en: 'An example provided by the researchers clarifies this process [3]. Suppose
    we have a spreadsheet with one astronaut per row. Each row has three relevant
    columns: the astronaut’s name, their total time in space, and a comma-separated
    list of missions that they participated in. We want to calculate the average mission
    length for each astronaut.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员提供的一个例子阐明了这个过程[3]。假设我们有一份每行代表一个宇航员的电子表格。每一行有三列相关数据：宇航员的名字、他们在太空的总时长以及他们参与的任务的逗号分隔列表。我们想要计算每个宇航员的平均任务时长。
- en: 'In step 1, the user writes a prompt like “calculate average mission length.”
    In step 2, the AI generates code corresponding to that prompt. It runs the code
    and adds a new column to the user’s spreadsheet containing the average mission
    length. In step 3, the AI converts the code to a list of tasks in natural language,
    such as the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，用户写下类似“计算平均任务时长”的提示。在第二步中，AI生成与该提示相对应的代码。它运行该代码，并将包含平均任务时长的新列添加到用户的电子表格中。在第三步中，AI将代码转换为自然语言的任务列表，如下所示：
- en: Create column “Mission Length.”
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建列“任务时长”。
- en: Column “Space Flight(hr)” divided by (count “,” from column “Missions” + 1).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列“太空飞行（小时）”除以（列“任务”中的逗号数 + 1）。
- en: In step 4, the user can edit the natural language from step 3 and resubmit the
    updated tasks to the AI. Might we be able to “skip the code” in the far broader
    area of “Python programming” rather than the more restricted setting of “data
    science with pandas”? It’s too early to tell. Data manipulation has the benefit
    of working in a visual medium, with spreadsheets and graphs that can be directly
    presented to the user, who may be able to discern whether the analysis looks correct
    or if further prompt engineering is needed. Such visual representations aren’t
    readily apparent for general-purpose programming.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，用户可以编辑第3步中的自然语言，并将更新后的任务重新提交给AI。我们是否能够在更广泛的“Python编程”领域中“跳过代码”，而不是局限于“使用pandas进行数据科学”的更狭窄场景呢？现在还为时过早。数据处理的优势在于它能够以可视化的方式呈现，通过电子表格和图表直接展示给用户，用户可能能判断分析是否正确，或者是否需要进一步的提示工程。这样的可视化表示对于通用编程而言并不容易显现。
- en: Still, we can imagine a new era where humans continue to perform important tasks
    like problem decomposition, specifying program behavior, writing tests, designing
    algorithms, and so on but where the programming of functions is entirely done
    using LLMs. The human tells the AI tool what the program is required to do and
    provides the test cases, and the AI generates the code. The human can then check
    that the program works properly without ever needing to see the code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们仍然能想象一个新时代，在这个时代里，人类继续执行重要任务，如问题分解、指定程序行为、编写测试、设计算法等等，而程序的编写完全由LLM来完成。人类向AI工具说明程序需要做什么，并提供测试用例，AI则生成代码。然后，人类可以检查程序是否正常工作，而无需查看代码。
- en: 'For another take on whether LLMs will replace programming languages, we recommend
    the blog post written by Chris Lattner [4], a programming and compiler expert.
    Lattner argues that, at least in the short term and possibly longer, programming
    languages won’t go away because the code from LLMs can be subtly wrong. So, if
    programming languages are sticking around for a while, the question is: Which
    programming languages should we be using? Lattner says, “The best language for
    an LLM is one that is highly usable and easy to read for humans, but whose implementation
    can scale to many different use cases and applications” [4]. Do existing languages
    meet this goal? Can we do better by designing a programming language that’s easier
    to read than, say, Python? Stay tuned!'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 关于LLM是否会取代编程语言的另一种看法，我们推荐由编程和编译专家Chris Lattner所写的博客文章[4]。Lattner认为，至少在短期内，甚至可能更长时间内，编程语言不会消失，因为LLM生成的代码可能会存在细微的错误。所以，如果编程语言在一段时间内还会存在，那么问题就变成了：我们应该使用哪种编程语言？Lattner表示：“最适合LLM的语言是那种对人类来说易于使用和阅读，但其实现能够扩展到许多不同的用例和应用场景的语言”[4]。现有的语言能达到这一目标吗？我们能否通过设计一种比Python更易读的编程语言来做得更好？敬请期待！
- en: OK, so maybe programming languages go away, or maybe they don’t; maybe they
    change. Regardless, do we need to worry about programmer jobs? We think not. Anyone
    who has worked at a software company will tell you that writing code isn’t the
    only or even main thing that programmers do with their time. Programmers also
    meet with clients to determine what they need. They specify what programs do and
    how they fit together. They check systems for performance and security concerns.
    They work with other teams to coordinate the design of huge pieces of software.
    If the writing code step gets easier, maybe we just get more useful software.
    That’s what happened when we got high-level languages. No one is going to code
    the next killer app in assembly! Compilers improve how we make software. Used
    thoughtfully, we think LLMs can do this too.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，也许编程语言会消失，也许它们不会消失；也许它们会改变。不管怎样，我们是否需要担心程序员的工作？我们认为不需要。任何在软件公司工作过的人都会告诉你，编写代码并不是程序员用来打发时间的唯一，甚至是主要的工作。程序员还需要与客户会面，确定他们的需求。他们会指定程序的功能以及它们如何协同工作。他们检查系统的性能和安全问题。他们与其他团队合作，协调设计大型软件项目。如果编写代码的步骤变得更简单，也许我们只是得到了更有用的软件。这就像我们当初拥有了高级语言一样。没人会用汇编语言来编写下一个杀手级应用程序！编译器提高了我们制作软件的效率。我们认为，LLM如果被谨慎使用，也能达到这一目标。
- en: An exciting future
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 激动人心的未来
- en: Although we’re partially unsure of what’s to come, it’s clear LLMs are going
    to dramatically change the future of programming. Perhaps, for now, they are just
    aids to help software engineers write better code. Perhaps five years from now,
    however, the majority of software will be written by LLMs and only a small subset
    of software engineers will be writing code from scratch. Whichever outcome proves
    true, changes are coming fast, and they’ll likely lead to more people being able
    to write software to meet their needs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们对未来仍然有些不确定，但显然LLM将会极大地改变编程的未来。也许现在它们只是帮助软件工程师编写更好代码的辅助工具。然而，或许五年后，大多数软件将由LLM编写，只有一小部分软件工程师会从零开始编写代码。无论哪种结果最终成真，变化正在迅速到来，它们可能会让更多人能够编写符合自己需求的软件。
- en: 'As of writing, we already have some insights into how these tools are being
    used. In one survey, 92% of software developers reported using these tools on
    a regular basis [5]. Recent studies have found evidence that developers who use
    these tools are more productive than without the tools [6]. In one particularly
    interesting research study conducted at UC San Diego, researchers found that professional
    developers use these tools in two ways: acceleration and exploration [7]. In the
    acceleration phase, developers use these tools to help generate code faster than
    if they wrote it themselves. In the exploration phase, developers use these tools
    to help them find libraries that may be helpful or to understand the existing
    codebase. These findings align with what we’ve been learning in this book, and
    we look forward to the research to come.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，我们已经对这些工具的使用方式有了一些见解。在一项调查中，92%的软件开发人员报告称定期使用这些工具[5]。最近的研究发现，使用这些工具的开发人员比没有使用工具时更具生产力[6]。在一项特别有趣的研究中，UC圣地亚哥的研究人员发现，专业开发人员使用这些工具有两种方式：加速和探索[7]。在加速阶段，开发人员使用这些工具来帮助他们比自己手写代码更快地生成代码。在探索阶段，开发人员使用这些工具来帮助他们找到可能有用的库，或者理解现有的代码库。这些发现与我们在本书中所学的一致，我们期待未来的研究。
- en: More than anything else, we hope that you’re now able to make your own, informed
    decision on how you’ll use LLMs to program and what LLMs may mean for the future
    of programming. At times like these, with some fervently proclaiming, “Programming
    is over!” and others equally fervently proclaiming, “Programming won’t change
    much at all!” [8], it’s important for us to be able to weigh the arguments ourselves
    and the ways that this change may affect us and everyone else. Can these tools
    help us? We think so. We should therefore use them, but use them responsibly.
    Are there concerns? Again, we think so, as we’ve discussed throughout the book.
    We should take steps, such as testing and debugging, to mitigate those concerns.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们希望你现在能够做出自己的、明智的决定，关于如何使用LLM（大语言模型）进行编程，以及LLM可能对编程的未来意味着什么。在这样的时刻，一些人热烈宣称：“编程已经结束！”而另一些人则同样热烈地宣称：“编程几乎不会发生太大变化！”[8]，对我们来说，能够自己权衡这些论点以及这种变化如何影响我们和其他人非常重要。这些工具能帮助我们吗？我们认为可以。因此，我们应该使用它们，但要负责任地使用它们。有担忧吗？同样，我们认为是有的，正如我们在书中所讨论的。我们应该采取措施，如测试和调试，来减轻这些担忧。
- en: The approach to teaching programming that we’ve taken in this book is new. Teachers
    and professors like us have just begun incorporating tools like Copilot into programming
    courses [9], though we’re still working on the balance between when we want learners
    to use Copilot and when we don’t. No matter the balance that programmers choose
    to learn programming, we want to stress to you that you’ve learned absolutely
    essential skills that everyone needs to create good software, whether you’re writing
    code occasionally at work to automate tedious tasks or you’re planning to become
    a professional software engineer. You have a strong foundation going forward,
    wherever your path may take you.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们采用的编程教学方法是全新的。像我们这样的教师和教授才刚刚开始将类似Copilot的工具纳入编程课程[9]，尽管我们仍在努力平衡何时让学习者使用Copilot以及何时不使用这些工具。无论程序员选择什么样的方式来学习编程，我们都希望强调你已经学到了每个人在编写优秀软件时都需要掌握的至关重要的技能，无论你是在工作中偶尔编写代码以自动化繁琐的任务，还是计划成为一名专业的软件工程师。你已经打下了坚实的基础，无论你的道路将带你走向何方。
- en: 12.3 Exercises
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 练习
- en: Explain how the persona pattern can be used to enforce coding standards in a
    company. For example, a company may ask its employees to always use camel case
    (e.g., xVal, ZValOut). Provide an example of a prompt you could use to have GitHub
    Copilot act as a manager enforcing specific coding standards.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释如何使用**人物角色模式**来强制执行公司的编码标准。例如，公司可能要求员工始终使用驼峰命名法（例如：xVal，ZValOut）。提供一个示例提示，说明如何让GitHub
    Copilot充当管理者来执行特定的编码标准。
- en: 'You want to create a Python function that generates a username based on a user’s
    preferred username and full name. The function should follow these rules:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要创建一个Python函数，根据用户的首选用户名和全名来生成一个用户名。该函数应遵循以下规则：
- en: If the preferred username is available (i.e., not already taken), use it.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果首选用户名可用（即尚未被占用），则使用该用户名。
- en: If the preferred username is taken, generate a new username by appending a single
    digit (e.g., 1, 2, 3, … . ) to the preferred username.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果首选用户名已被占用，通过在用户名后附加一个数字（例如1、2、3……）生成一个新的用户名。
- en: If the generated usernames are also taken, use the user’s full name to generate
    a username by combining parts of their first and last name.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果生成的用户名已被占用，使用用户的全名，通过组合其名字和姓氏的一部分来生成用户名。
- en: The function should keep asking for a new preferred username if the generated
    usernames are also taken.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果生成的用户名已被占用，函数应继续请求新的首选用户名。
- en: Which interaction pattern (flipped interaction pattern or persona pattern) would
    you use to design this function with the help of GitHub Copilot? Justify your
    choice, and outline how you would start the interaction.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你会使用哪种交互模式（**反转交互模式**或**人物角色模式**）来设计这个函数，并借助GitHub Copilot？请说明你的选择，并概述你如何开始这个交互。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A prompt pattern is a template to help us construct a prompt to meet a given
    goal.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示模式是一个模板，帮助我们构建一个能够实现特定目标的提示。
- en: 'The flipped interaction pattern flips the script: rather than posing questions
    to the LLM, the LLM poses questions to us.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反转交互模式**（flipped interaction pattern）改变了规则：与其向LLM提问，不如让LLM向我们提问。'
- en: The flipped interaction pattern is useful when we don’t know how to effectively
    prompt the LLM.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反转交互模式**在我们不知道如何有效地向LLM提出提示时非常有用。'
- en: The persona pattern is used to have the AI take on a particular persona, such
    as “introductory programming instructor,” or a specific point of view.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人物角色模式**用于让AI扮演特定的人物角色，例如“初级编程讲师”或某个特定的视角。'
- en: The persona pattern is useful when we want the LLM to respond from a given perspective.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们希望大型语言模型（LLM）从某个特定角度进行回应时，**人物角色模式**（persona pattern）非常有用。
- en: Copilot currently struggles with tasks that are contrived, not well defined,
    or large.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot 当前在处理那些人为设计、定义不清或规模较大的任务时表现较差。
- en: Some believe that LLMs will replace programming languages; others believe that
    programming languages are here to stay.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些人认为，LLM将取代编程语言；而另一些人则认为编程语言将继续存在。
- en: LLMs are helping people perform data science tasks without those people ever
    seeing the underlying programming language code.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型语言模型正在帮助人们完成数据科学任务，而这些人甚至没有接触到底层的编程语言代码。
- en: It may be that programming languages themselves aren’t replaced, but that the
    leading languages will be developed to be more readable than today’s languages.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能编程语言本身不会被取代，但领先的编程语言将会发展得比今天的语言更具可读性。
