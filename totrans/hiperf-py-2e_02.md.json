["```py\nfor z in coordinates:\n    for iteration in range(maxiter):  # limited iterations per point\n        if abs(z) < 2.0:  # has the escape condition been broken?\n            z = z*z + c\n        else:\n            break\n    # store the iteration count for each z and draw later\n```", "```py\nz = -1.8-1.8j\nprint(abs(z))\n```", "```py\n2.54558441227\n```", "```py\nc = -0.62772-0.42193j\nz = 0+0j\nfor n in range(9):\n    z = z*z + c\n    print(f\"{n}: z={z: .5f}, abs(z)={abs(z):0.3f}, c={c: .5f}\")\n```", "```py\n0: z=-0.62772-0.42193j, abs(z)=0.756, c=-0.62772-0.42193j\n1: z=-0.41171+0.10778j, abs(z)=0.426, c=-0.62772-0.42193j\n2: z=-0.46983-0.51068j, abs(z)=0.694, c=-0.62772-0.42193j\n3: z=-0.66777+0.05793j, abs(z)=0.670, c=-0.62772-0.42193j\n4: z=-0.18516-0.49930j, abs(z)=0.533, c=-0.62772-0.42193j\n5: z=-0.84274-0.23703j, abs(z)=0.875, c=-0.62772-0.42193j\n6: z= 0.02630-0.02242j, abs(z)=0.035, c=-0.62772-0.42193j\n7: z=-0.62753-0.42311j, abs(z)=0.757, c=-0.62772-0.42193j\n8: z=-0.41295+0.10910j, abs(z)=0.427, c=-0.62772-0.42193j\n```", "```py\n\"\"\"Julia set generator without optional PIL-based image drawing\"\"\"\nimport time\n\n# area of complex space to investigate\nx1, x2, y1, y2 = -1.8, 1.8, -1.8, 1.8\nc_real, c_imag = -0.62772, -.42193\n```", "```py\ndef calc_pure_python(desired_width, max_iterations):\n    \"\"\"Create a list of complex coordinates (zs) and complex parameters (cs),\n build Julia set\"\"\"\n    x_step = (x2 - x1) / desired_width\n    y_step = (y1 - y2) / desired_width\n    x = []\n    y = []\n    ycoord = y2\n    while ycoord > y1:\n        y.append(ycoord)\n        ycoord += y_step\n    xcoord = x1\n    while xcoord < x2:\n        x.append(xcoord)\n        xcoord += x_step\n    # build a list of coordinates and the initial condition for each cell.\n    # Note that our initial condition is a constant and could easily be removed,\n    # we use it to simulate a real-world scenario with several inputs to our\n    # function\n    zs = []\n    cs = []\n    for ycoord in y:\n        for xcoord in x:\n            zs.append(complex(xcoord, ycoord))\n            cs.append(complex(c_real, c_imag))\n\n    print(\"Length of x:\", len(x))\n    print(\"Total elements:\", len(zs))\n    start_time = time.time()\n    output = calculate_z_serial_purepython(max_iterations, zs, cs)\n    end_time = time.time()\n    secs = end_time - start_time\n    print(calculate_z_serial_purepython.__name__ + \" took\", secs, \"seconds\")\n\n    # This sum is expected for a 1000^2 grid with 300 iterations\n    # It ensures that our code evolves exactly as we'd intended\n    assert sum(output) == 33219980\n```", "```py\ndef calculate_z_serial_purepython(maxiter, zs, cs):\n    \"\"\"Calculate output list using Julia update rule\"\"\"\n    output = [0] * len(zs)\n    for i in range(len(zs)):\n        n = 0\n        z = zs[i]\n        c = cs[i]\n        while abs(z) < 2 and n < maxiter:\n            z = z * z + c\n            n += 1\n        output[i] = n\n    return output\n```", "```py\nif __name__ == \"__main__\":\n    # Calculate the Julia set using a pure Python solution with\n    # reasonable defaults for a laptop\n    calc_pure_python(desired_width=1000, max_iterations=300)\n```", "```py\n# running the above produces:\nLength of x: 1000\nTotal elements: 1000000\ncalculate_z_serial_purepython took 8.087012767791748 seconds\n```", "```py\nfrom functools import wraps\n\ndef timefn(fn):\n    @wraps(fn)\n    def measure_time(*args, **kwargs):\n        t1 = time.time()\n        result = fn(*args, **kwargs)\n        t2 = time.time()\n        print(f\"@timefn: {fn.__name__} took {t2 - t1} seconds\")\n        return result\n    return measure_time\n\n@timefn\ndef calculate_z_serial_purepython(maxiter, zs, cs):\n    ...\n```", "```py\nLength of x: 1000\nTotal elements: 1000000\n@timefn:calculate_z_serial_purepython took 8.00485110282898 seconds\ncalculate_z_serial_purepython took 8.004898071289062 seconds\n```", "```py\npython -m timeit -n 5 -r 1 -s \"import julia1\" \\\n \"julia1.calc_pure_python(desired_width=1000, max_iterations=300)\"\n```", "```py\n5 loops, best of 1: 8.45 sec per loop\n```", "```py\nIn [1]: import julia1\nIn [2]: %timeit julia1.calc_pure_python(desired_width=1000, max_iterations=300)\n```", "```py\n$ /usr/bin/time -p python julia1_nopil.py\nLength of x: 1000\nTotal elements: 1000000\ncalculate_z_serial_purepython took 8.279886722564697 seconds\nreal 8.84\nuser 8.73\nsys 0.10\n```", "```py\n$ /usr/bin/time --verbose python julia1_nopil.py\nLength of x: 1000\nTotal elements: 1000000\ncalculate_z_serial_purepython took 8.477287530899048 seconds\n Command being timed: \"python julia1_nopil.py\"\n User time (seconds): 8.97\n System time (seconds): 0.05\n Percent of CPU this job got: 99%\n Elapsed (wall clock) time (h:mm:ss or m:ss): 0:09.03\n Average shared text size (kbytes): 0\n Average unshared data size (kbytes): 0\n Average stack size (kbytes): 0\n Average total size (kbytes): 0\n Maximum resident set size (kbytes): 98620\n Average resident set size (kbytes): 0\n Major (requiring I/O) page faults: 0\n Minor (reclaiming a frame) page faults: 26645\n Voluntary context switches: 1\n Involuntary context switches: 27\n Swaps: 0\n File system inputs: 0\n File system outputs: 0\n Socket messages sent: 0\n Socket messages received: 0\n Signals delivered: 0\n Page size (bytes): 4096\n Exit status: 0\n```", "```py\n$ python -m cProfile -s cumulative julia1_nopil.py\n...\nLength of x: 1000\nTotal elements: 1000000\ncalculate_z_serial_purepython took 11.498265266418457 seconds\n         36221995 function calls in 12.234 seconds\n\n  Ordered by: cumulative time\n\n  ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n       1    0.000    0.000   12.234   12.234 {built-in method builtins.exec}\n       1    0.038    0.038   12.234   12.234 julia1_nopil.py:1(<module>)\n       1    0.571    0.571   12.197   12.197 julia1_nopil.py:23\n                                              (calc_pure_python)\n       1    8.369    8.369   11.498   11.498 julia1_nopil.py:9\n                                              (calculate_z_serial_purepython)\n34219980    3.129    0.000    3.129    0.000 {built-in method builtins.abs}\n 2002000    0.121    0.000    0.121    0.000 {method 'append' of 'list' objects}\n       1    0.006    0.006    0.006    0.006 {built-in method builtins.sum}\n       3    0.000    0.000    0.000    0.000 {built-in method builtins.print}\n       2    0.000    0.000    0.000    0.000 {built-in method time.time}\n       4    0.000    0.000    0.000    0.000 {built-in method builtins.len}\n       1    0.000    0.000    0.000    0.000 {method 'disable' of\n                                              '_lsprof.Profiler' objects}\n```", "```py\n$ python -m cProfile -o profile.stats julia1.py\n```", "```py\nIn [1]: import pstats\nIn [2]: p = pstats.Stats(\"profile.stats\")\nIn [3]: p.sort_stats(\"cumulative\")\nOut[3]: <pstats.Stats at 0x7f77088edf28>\n\nIn [4]: p.print_stats()\nFri Jun 14 17:59:28 2019    profile.stats\n\n         36221995 function calls in 12.169 seconds\n\n  Ordered by: cumulative time\n\n  ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n       1    0.000    0.000   12.169   12.169 {built-in method builtins.exec}\n       1    0.033    0.033   12.169   12.169 julia1_nopil.py:1(<module>)\n       1    0.576    0.576   12.135   12.135 julia1_nopil.py:23\n                                              (calc_pure_python)\n       1    8.266    8.266   11.429   11.429 julia1_nopil.py:9\n                                              (calculate_z_serial_purepython)\n34219980    3.163    0.000    3.163    0.000 {built-in method builtins.abs}\n 2002000    0.123    0.000    0.123    0.000 {method 'append' of 'list' objects}\n       1    0.006    0.006    0.006    0.006 {built-in method builtins.sum}\n       3    0.000    0.000    0.000    0.000 {built-in method builtins.print}\n       4    0.000    0.000    0.000    0.000 {built-in method builtins.len}\n       2    0.000    0.000    0.000    0.000 {built-in method time.time}\n       1    0.000    0.000    0.000    0.000 {method 'disable' of\n                                              '_lsprof.Profiler' objects}\n```", "```py\nIn [5]: p.print_callers()\n   Ordered by: cumulative time\n\nFunction                                          was called by...\n                                                ncalls  tottime cumtime\n{built-in method builtins.exec}       <-\njulia1_nopil.py:1(<module>)           <-       1    0.033   12.169\n                                               {built-in method builtins.exec}\njulia1_nopil.py:23(calc_pure_python)  <-       1    0.576   12.135\n                                               :1(<module>)\njulia1_nopil.py:9(...)                <-       1    8.266   11.429\n                                               :23(calc_pure_python)\n{built-in method builtins.abs}        <- 34219980   3.163    3.163\n                                               :9(calculate_z_serial_purepython)\n{method 'append' of 'list' objects}   <- 2002000    0.123    0.123\n                                               :23(calc_pure_python)\n{built-in method builtins.sum}        <-       1    0.006    0.006\n                                               :23(calc_pure_python)\n{built-in method builtins.print}      <-       3    0.000    0.000\n                                               :23(calc_pure_python)\n{built-in method builtins.len}        <-       2    0.000    0.000\n                                               :9(calculate_z_serial_purepython)\n                                               2    0.000    0.000\n                                               :23(calc_pure_python)\n{built-in method time.time}           <-       2    0.000    0.000\n                                               :23(calc_pure_python)\n```", "```py\nIn [6]: p.print_callees()\n   Ordered by: cumulative time\n\nFunction                                          called...\n                                              ncalls  tottime  cumtime\n{built-in method builtins.exec}      ->       1    0.033   12.169\n                                              julia1_nopil.py:1(<module>)\njulia1_nopil.py:1(<module>)          ->       1    0.576   12.135\n                                              julia1_nopil.py:23\n                                                (calc_pure_python)\njulia1_nopil.py:23(calc_pure_python) ->       1    8.266   11.429\n                                              julia1_nopil.py:9\n                                                (calculate_z_serial_purepython)\n                                              2    0.000    0.000\n                                              {built-in method builtins.len}\n                                              3    0.000    0.000\n                                              {built-in method builtins.print}\n                                              1    0.006    0.006\n                                              {built-in method builtins.sum}\n                                              2    0.000    0.000\n                                              {built-in method time.time}\n                                        2002000    0.123    0.123\n                                              {method 'append' of 'list' objects}\njulia1_nopil.py:9(...)              -> 34219980    3.163    3.163\n                                              {built-in method builtins.abs}\n\t\t\t\t\t                          2    0.000    0.000\n                                              {built-in method builtins.len}\n```", "```py\n$ kernprof -l -v julia1_lineprofiler.py\n...\nWrote profile results to julia1_lineprofiler.py.lprof\nTimer unit: 1e-06 s\n\nTotal time: 49.2011 s\nFile: julia1_lineprofiler.py\nFunction: calculate_z_serial_purepython at line 9\n\nLine #      Hits  Per Hit   % Time  Line Contents\n==============================================================\n     9                              @profile\n    10                              def calculate_z_serial_purepython(maxiter,\n                                                                      zs, cs):\n    11                            \"\"\"Calculate output list using Julia update rule\"\"\"\n    12         1   3298.0      0.0      output = [0] * len(zs)\n    13   1000001      0.4      0.8      for i in range(len(zs)):\n    14   1000000      0.4      0.7          n = 0\n    15   1000000      0.4      0.9          z = zs[i]\n    16   1000000      0.4      0.8          c = cs[i]\n    17  34219980      0.5     38.0          while abs(z) < 2 and n < maxiter:\n    18  33219980      0.5     30.8              z = z * z + c\n    19  33219980      0.4     27.1              n += 1\n    20   1000000      0.4      0.8          output[i] = n\n    21         1      1.0      0.0      return output\n```", "```py\n$ kernprof -l -v julia1_lineprofiler2.py\n...\nWrote profile results to julia1_lineprofiler2.py.lprof\nTimer unit: 1e-06 s\n\nTotal time: 82.88 s\nFile: julia1_lineprofiler2.py\nFunction: calculate_z_serial_purepython at line 9\n\nLine #      Hits  Per Hit   % Time  Line Contents\n==============================================================\n     9                              @profile\n    10                              def calculate_z_serial_purepython(maxiter,\n                                                                      zs, cs):\n    11                            \"\"\"Calculate output list using Julia update rule\"\"\"\n    12         1   3309.0      0.0      output = [0] * len(zs)\n    13   1000001      0.4      0.5      for i in range(len(zs)):\n    14   1000000      0.4      0.5          n = 0\n    15   1000000      0.5      0.5          z = zs[i]\n    16   1000000      0.4      0.5          c = cs[i]\n    17   1000000      0.4      0.5          while True:\n    18  34219980      0.6     23.1            not_yet_escaped = abs(z) < 2\n    19  34219980      0.4     18.3            iterations_left = n < maxiter\n    20  34219980      0.4     17.3            if not_yet_escaped and iterations_left:\n    21  33219980      0.5     20.5                z = z * z + c\n    22  33219980      0.4     17.3                n += 1\n    23                                        else:\n    24   1000000      0.4      0.5                break\n    25   1000000      0.4      0.5          output[i] = n\n    26         1      0.0      0.0      return output\n```", "```py\nPython 3.7.3 (default, Mar 27 2019, 22:11:17)\nType 'copyright', 'credits', or 'license' for more information\nIPython 7.5.0 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: z = 0+0j\nIn [2]: %timeit abs(z) < 2\n97.6 ns ± 0.138 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)\nIn [3]: n = 1\nIn [4]: maxiter = 300\nIn [5]: %timeit n < maxiter\n42.1 ns ± 0.0355 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)\n```", "```py\n$ kernprof -l -v julia1_lineprofiler3.py\n...\nWrote profile results to julia1_lineprofiler3.py.lprof\nTimer unit: 1e-06 s\n\nTotal time: 48.9154 s\nFile: julia1_lineprofiler3.py\nFunction: calculate_z_serial_purepython at line 9\n\nLine #    Hits  Per Hit % Time  Line Contents\n=======================================================\n   9                            @profile\n  10                            def calculate_z_serial_purepython(maxiter,\n                                                                  zs, cs):\n  11                             \"\"\"Calculate output list using Julia update rule\"\"\"\n  12         1   3312.0    0.0      output = [0] * len(zs)\n  13   1000001      0.4   0.8      for i in range(len(zs)):\n  14   1000000      0.4   0.7          n = 0\n  15   1000000      0.4   0.8          z = zs[i]\n  16   1000000      0.4   0.8          c = cs[i]\n  17  34219980      0.5  38.2          while n < maxiter and abs(z) < 2:\n  18  33219980      0.5  30.7              z = z * z + c\n  19  33219980      0.4  27.1              n += 1\n  20   1000000      0.4   0.8          output[i] = n\n  21         1      1.0   0.0      return output\n```", "```py\nTotal time: 88.334 s\nFile: julia1_lineprofiler3.py\nFunction: calc_pure_python at line 24\n\nLine #      Hits  Per Hit   % Time  Line Contents\n==============================================================\n    24                              @profile\n    25                              def calc_pure_python(draw_output,\n                                                         desired_width,\n                                                         max_iterations):\n    26                               \"\"\"Create a list of complex...\n...\n    44         1          1.0      0.0      zs = []\n    45         1          0.0      0.0      cs = []\n    46      1001          0.7      0.0      for ycoord in y:\n    47   1001000          0.6      0.7          for xcoord in x:\n    48   1000000          0.9      1.0            zs.append(complex(xcoord, ycoord))\n    49   1000000          0.9      1.0            cs.append(complex(c_real, c_imag))\n    50\n    51         1         40.0      0.0      print(\"Length of x:\", len(x))\n    52         1          7.0      0.0      print(\"Total elements:\", len(zs))\n    53         1          4.0      0.0      start_time = time.time()\n    54         1   85969310.0    97.3     output = calculate_z_serial_purepython \\\n                                           (max_iterations, zs, cs)\n    55         1          4.0      0.0      end_time = time.time()\n    56         1          1.0      0.0      secs = end_time - start_time\n    57         1         36.0      0.0      print(calculate_z_serial...\n    58\n    59         1       6345.0      0.0      assert sum(output) == 33219980\n```", "```py\n$ python -m memory_profiler julia1_memoryprofiler.py\n...\n\nLine #    Mem usage    Increment   Line Contents\n================================================\n     9  126.363 MiB  126.363 MiB   @profile\n    10                             def calculate_z_serial_purepython(maxiter,\n                                                                     zs, cs):\n    11                                 \"\"\"Calculate output list using...\n    12  133.973 MiB    7.609 MiB       output = [0] * len(zs)\n    13  136.988 MiB    0.000 MiB       for i in range(len(zs)):\n    14  136.988 MiB    0.000 MiB           n = 0\n    15  136.988 MiB    0.000 MiB           z = zs[i]\n    16  136.988 MiB    0.000 MiB           c = cs[i]\n    17  136.988 MiB    0.258 MiB           while n < maxiter and abs(z) < 2:\n    18  136.988 MiB    0.000 MiB               z = z * z + c\n    19  136.988 MiB    0.000 MiB               n += 1\n    20  136.988 MiB    0.000 MiB           output[i] = n\n    21  136.988 MiB    0.000 MiB       return output\n\n...\n\nLine #    Mem usage    Increment   Line Contents\n================================================\n    24   48.113 MiB   48.113 MiB   @profile\n    25                             def calc_pure_python(draw_output,\n                                                        desired_width,\n                                                        max_iterations):\n    26                                 \"\"\"Create a list of complex...\n    27   48.113 MiB    0.000 MiB       x_step = (x2 - x1) / desired_width\n    28   48.113 MiB    0.000 MiB       y_step = (y1 - y2) / desired_width\n    29   48.113 MiB    0.000 MiB       x = []\n    30   48.113 MiB    0.000 MiB       y = []\n    31   48.113 MiB    0.000 MiB       ycoord = y2\n    32   48.113 MiB    0.000 MiB       while ycoord > y1:\n    33   48.113 MiB    0.000 MiB           y.append(ycoord)\n    34   48.113 MiB    0.000 MiB           ycoord += y_step\n    35   48.113 MiB    0.000 MiB       xcoord = x1\n    36   48.113 MiB    0.000 MiB       while xcoord < x2:\n    37   48.113 MiB    0.000 MiB           x.append(xcoord)\n    38   48.113 MiB    0.000 MiB           xcoord += x_step\n    44   48.113 MiB    0.000 MiB       zs = []\n    45   48.113 MiB    0.000 MiB       cs = []\n    46  125.961 MiB    0.000 MiB       for ycoord in y:\n    47  125.961 MiB    0.258 MiB           for xcoord in x:\n    48  125.961 MiB    0.512 MiB               zs.append(complex(xcoord, ycoord))\n    49  125.961 MiB    0.512 MiB               cs.append(complex(c_real, c_imag))\n    50\n    51  125.961 MiB    0.000 MiB       print(\"Length of x:\", len(x))\n    52  125.961 MiB    0.000 MiB       print(\"Total elements:\", len(zs))\n    53  125.961 MiB    0.000 MiB       start_time = time.time()\n    54  136.609 MiB   10.648 MiB       output = calculate_z_serial...\n    55  136.609 MiB    0.000 MiB       end_time = time.time()\n    56  136.609 MiB    0.000 MiB       secs = end_time - start_time\n    57  136.609 MiB    0.000 MiB       print(calculate_z_serial_purepython...\n    58\n    59  136.609 MiB    0.000 MiB       assert sum(output) == 33219980\n```", "```py\n@profile\ndef calculate_z_serial_purepython(maxiter, zs, cs):\n    \"\"\"Calculate output list using Julia update rule\"\"\"\n    with profile.timestamp(\"create_output_list\"):\n        output = [0] * len(zs)\n    time.sleep(1)\n    with profile.timestamp(\"calculate_output\"):\n        for i in range(len(zs)):\n            n = 0\n            z = zs[i]\n            c = cs[i]\n            while n < maxiter and abs(z) < 2:\n                z = z * z + c\n                n += 1\n            output[i] = n\n    return output\n```", "```py\n@profile\ndef calculate_z_serial_purepython(maxiter, x, y):\n    \"\"\"Calculate output list using Julia update rule\"\"\"\n    output = []\n    for ycoord in y:\n        for xcoord in x:\n            z = complex(xcoord, ycoord)\n            c = complex(c_real, c_imag)\n            n = 0\n            while n < maxiter and abs(z) < 2:\n                z = z * z + c\n                n += 1\n            output.append(n)\n    return output\n```", "```py\n$ ps -A -o pid,rss,cmd | ack python\n...\n15953 96156 python julia1_nopil.py\n...\n$ sudo env \"PATH=$PATH\" py-spy --pid 15953\n```", "```py\nIn [1]: import dis\nIn [2]: import julia1_nopil\nIn [3]: dis.dis(julia1_nopil.calculate_z_serial_purepython)\n 11           0 LOAD_CONST               1 (0)\n              2 BUILD_LIST               1\n              4 LOAD_GLOBAL              0 (len)\n              6 LOAD_FAST                1 (zs)\n              8 CALL_FUNCTION            1\n             10 BINARY_MULTIPLY\n             12 STORE_FAST               3 (output)\n\n 12          14 SETUP_LOOP              94 (to 110)\n             16 LOAD_GLOBAL              1 (range)\n             18 LOAD_GLOBAL              0 (len)\n             20 LOAD_FAST                1 (zs)\n             22 CALL_FUNCTION            1\n             24 CALL_FUNCTION            1\n             26 GET_ITER\n        >>   28 FOR_ITER                78 (to 108)\n             30 STORE_FAST               4 (i)\n\n 13          32 LOAD_CONST               1 (0)\n             34 STORE_FAST               5 (n)\n...\n 19     >>   98 LOAD_FAST                5 (n)\n            100 LOAD_FAST                3 (output)\n            102 LOAD_FAST                4 (i)\n            104 STORE_SUBSCR\n            106 JUMP_ABSOLUTE           28\n        >>  108 POP_BLOCK\n\n 20     >>  110 LOAD_FAST                3 (output)\n            112 RETURN_VALUE\n```", "```py\ndef fn_expressive(upper=1_000_000):\n    total = 0\n    for n in range(upper):\n        total += n\n    return total\n\ndef fn_terse(upper=1_000_000):\n    return sum(range(upper))\n\nassert fn_expressive() == fn_terse(), \"Expect identical results from both functions\"\n```", "```py\nIn [2]: %timeit fn_expressive()\n52.4 ms ± 86.4 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\nIn [3]: %timeit fn_terse()\n18.1 ms ± 1.38 ms per loop (mean ± std. dev. of 7 runs, 100 loops each)\n```", "```py\nIn [4]: import dis\nIn [5]: dis.dis(fn_expressive)\n  2           0 LOAD_CONST               1 (0)\n              2 STORE_FAST               1 (total)\n\n  3           4 SETUP_LOOP              24 (to 30)\n              6 LOAD_GLOBAL              0 (range)\n              8 LOAD_FAST                0 (upper)\n             10 CALL_FUNCTION            1\n             12 GET_ITER\n        >>   14 FOR_ITER                12 (to 28)\n             16 STORE_FAST               2 (n)\n\n  4          18 LOAD_FAST                1 (total)\n             20 LOAD_FAST                2 (n)\n             22 INPLACE_ADD\n             24 STORE_FAST               1 (total)\n             26 JUMP_ABSOLUTE           14\n        >>   28 POP_BLOCK\n\n  5     >>   30 LOAD_FAST                1 (total)\n             32 RETURN_VALUE\n\nIn [6]: dis.dis(fn_terse)\n  8           0 LOAD_GLOBAL              0 (sum)\n              2 LOAD_GLOBAL              1 (range)\n              4 LOAD_FAST                0 (upper)\n              6 CALL_FUNCTION            1\n              8 CALL_FUNCTION            1\n             10 RETURN_VALUE\n```", "```py\nimport time\n\ndef test_some_fn():\n    \"\"\"Check basic behaviors for our function\"\"\"\n    assert some_fn(2) == 4\n    assert some_fn(1) == 1\n    assert some_fn(-1) == 1\n\n@profile\ndef some_fn(useful_input):\n    \"\"\"An expensive function that we wish to both test and profile\"\"\"\n    # artificial \"we're doing something clever and expensive\" delay\n    time.sleep(1)\n    return useful_input ** 2\n\nif __name__ == \"__main__\":\n    print(f\"Example call `some_fn(2)` == {some_fn(2)}\")\n```", "```py\n$ pytest utility.py\n=============== test session starts ===============\nplatform linux -- Python 3.7.3, pytest-4.6.2, py-1.8.0, pluggy-0.12.0\nrootdir: noop_profile_decorator\nplugins: cov-2.7.1\ncollected 0 items / 1 errors\n\n====================== ERRORS =====================\n___________ ERROR collecting utility.py ___________\nutility.py:20: in <module>\n    @profile\nE   NameError: name 'profile' is not defined\n```", "```py\n# check for line_profiler or memory_profiler in the local scope, both\n# are injected by their respective tools or they're absent\n# if these tools aren't being used (in which case we need to substitute\n# a dummy @profile decorator)\nif 'line_profiler' not in dir() and 'profile' not in dir():\n    def profile(func):\n        return func\n```", "```py\n$ pytest utility.py\n=============== test session starts ===============\nplatform linux -- Python 3.7.3, pytest-4.6.2, py-1.8.0, pluggy-0.12.0\nrootdir: /home/ian/workspace/personal_projects/high_performance_python_book_2e/\n         high-performance-python-2e/examples_ian/ian/ch02/noop_profile_decorator\nplugins: cov-2.7.1\ncollected 1 item\n\nutility.py .\n\n============= 1 passed in 3.04 seconds ============\n\n$ kernprof -l -v utility.py\nExample call `some_fn(2)` == 4\n...\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n    20                                           @profile\n    21                                           def some_fn(useful_input):\n    22                                               \"\"\"An expensive function that...\n    23                                               # artificial 'we're doing...\n    24         1    1001345.0 1001345.0    100.0      time.sleep(1)\n    25         1          7.0      7.0      0.0      return useful_input ** 2\n\n$ python -m memory_profiler utility.py\nExample call `some_fn(2)` == 4\nFilename: utility.py\n\nLine #    Mem usage    Increment   Line Contents\n================================================\n    20   48.277 MiB   48.277 MiB   @profile\n    21                             def some_fn(useful_input):\n    22                                 \"\"\"An expensive function that we wish to...\n    23                                 # artificial 'we're doing something clever...\n    24   48.277 MiB    0.000 MiB       time.sleep(1)\n    25   48.277 MiB    0.000 MiB       return useful_input ** 2\n```"]