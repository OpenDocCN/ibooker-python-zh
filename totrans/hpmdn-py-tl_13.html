<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 10. Using Types for Safety and Inspection"><div class="chapter" id="chapter_typing">
<h1><span class="label">Chapter 10. </span>Using Types for Safety and Inspection</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id322">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the 10th chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at <a href="mailto:mail@claudiojolowicz.com">mail@claudiojolowicz.com</a>.</p>
</div></aside>

<p>What’s a type? As a first approximation, let’s say the <em>type</em> of a variable
specifies the kind of values you can assign to it—​for example, integers or
lists of strings. When Guido van Rossum created Python, most popular programming
languages fell into two camps when it came to types: static and dynamic typing.</p>

<p><em>Statically typed</em> languages, like C++, require you to declare the types of
variables upfront (unless the compiler is smart enough to infer them
automatically). In exchange, compilers ensure a variable only ever holds
compatible values. That eliminates entire classes of bugs. It also enables
optimizations: compilers know how much space the variable needs to store its
values.</p>

<p><em>Dynamically typed</em> languages break with this paradigm: they let you assign any
value to any variable. Scripting languages like Javascript and Perl even convert
values implicitly—​say, from strings to numbers. This radically speeds up the
process of writing code. It also gives you more leeway to shoot yourself into
the foot.</p>

<p>Python is a dynamically typed language, yet it chose a middle ground between the
opposing camps. Let’s demonstrate its approach with an example:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">math</code>

<code class="n">number</code> <code class="o">=</code> <code class="nb">input</code><code class="p">(</code><code class="s2">"Enter a number: "</code><code class="p">)</code>
<code class="n">number</code> <code class="o">=</code> <code class="nb">float</code><code class="p">(</code><code class="n">number</code><code class="p">)</code>
<code class="n">result</code> <code class="o">=</code> <code class="n">math</code><code class="o">.</code><code class="n">sqrt</code><code class="p">(</code><code class="n">number</code><code class="p">)</code>

<code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s2">"The square root of </code><code class="si">{</code><code class="n">number</code><code class="si">}</code><code class="s2"> is </code><code class="si">{</code><code class="n">result</code><code class="si">}</code><code class="s2">."</code><code class="p">)</code></pre>

<p>In Python, a variable is just a name for a value. Variables don’t have
types—<em>values</em> do. The program associates the same name, <code>number</code>, first with a
value of type <code>str</code>, then with a value of type <code>float</code>. But unlike Perl and
similar languages, Python never converts the values behind your back, in eager
anticipation of your wishes:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <strong>math.sqrt("1.21")</strong>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: must be real number, not str
</pre>

<p>Python isn’t as forgiving as some of its contemporaries, but consider two
limitations of this type check. First, you won’t see a <code>TypeError</code> until you run
the offending code. Second, the Python interpreter doesn’t raise the error—​the
library function checks explicitly if something other than an integer or
floating-point number was passed.</p>

<p>Most Python functions don’t check the types of their arguments at all. Instead,
they simply invoke the operations they expect their arguments to provide.
Fundamentally, the type of a Python object doesn’t matter as long as its
behavior is correct. Taking inspiration from Vaucanson’s mechanical duck from
the times of Louis XV, this approach is known as <em>duck typing</em>: “If it looks
like a duck and quacks like a duck, then it must be a duck.”</p>

<figure><div class="figure">
<img src="assets/hmpt_10in01.png" alt="An imaginary depiction of Vaucanson's Duck published in the _Scientific American_ magazin in 1899." width="2350" height="935"/>
<h6/>
</div></figure>

<p>As an example, consider the <em>join</em> operation in concurrent code. This operation
lets you wait until some background work completes, “joining” the threads of
control back together, as it were. <a data-type="xref" href="#example_typing_duck">Example 10-1</a> defines a duck-typed
function that invokes <code>join</code> on a number of tasks, waiting for each in turn.</p>
<div id="example_typing_duck" data-type="example">
<h5><span class="label">Example 10-1. </span>Duck-typing in action</h5>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">join_all</code><code class="p">(</code><code class="n">joinables</code><code class="p">):</code>
    <code class="k">for</code> <code class="n">task</code> <code class="ow">in</code> <code class="n">joinables</code><code class="p">:</code>
        <code class="n">task</code><code class="o">.</code><code class="n">join</code><code class="p">()</code></pre></div>

<p>You can use this function with <code>Thread</code> or <code>Process</code> from the standard
<code>threading</code> or <code>multiprocessing</code> modules—​or with any other object that has a
<code>join</code> method with the correct signature. (You can’t use it with strings because
<code>str.join</code> takes an argument—​an iterable of strings.) Duck typing means that
these classes don’t need a common base class to benefit from reuse. All the
types need is a <code>join</code> method with the correct signature.</p>

<p>Duck typing is great because the function and its callers can evolve fairly
independently—​a property known as <em>loose coupling</em>. Without duck typing, a
function argument has to implement an explicit interface that specifies its
behavior. Python gives you loose coupling for free: you can pass literally
anything, as long as it satisfies the expected behavior.</p>

<p>Unfortunately, this freedom can make some functions hard to understand.</p>

<p>If you’ve ever had to read an entire codebase to grasp the purpose of a few
lines within it, you know what I mean: it can be impossible to understand a
Python function in isolation. Sometimes, the only way to decipher what’s going
on is to look at its callers, their callers, and so on
(<a data-type="xref" href="#example_typing_obscure">Example 10-2</a>).</p>
<div id="example_typing_obscure" data-type="example">
<h5><span class="label">Example 10-2. </span>An obscure function</h5>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">_send</code><code class="p">(</code><code class="n">objects</code><code class="p">,</code> <code class="n">sender</code><code class="p">):</code>
    <code class="sd">"""send them with the sender..."""</code>
    <code class="k">for</code> <code class="n">obj</code> <code class="ow">in</code> <code class="n">objects</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">get_all</code><code class="p">():</code>
        <code class="k">if</code> <code class="n">p</code> <code class="o">:=</code> <code class="n">obj</code><code class="o">.</code><code class="n">get_parent</code><code class="p">():</code>
            <code class="n">sender</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">p</code><code class="p">)</code>
        <code class="k">elif</code> <code class="n">obj</code> <code class="ow">is</code> <code class="ow">not</code> <code class="kc">None</code> <code class="ow">and</code> <code class="n">obj</code><code class="o">.</code><code class="n">_next</code> <code class="ow">is</code> <code class="ow">not</code> <code class="kc">None</code><code class="p">:</code>
            <code class="n">_send_next_object</code><code class="p">(</code><code class="n">obj</code><code class="o">.</code><code class="n">_next</code><code class="p">,</code> <code class="n">sender</code><code class="p">)</code></pre></div>

<p>Writing out the argument and return types of the function—​its type
signature—​dramatically reduces the amount of context you need to understand the
function. Traditionally, people have done so by listing the types in a
docstring. Unfortunately, docstrings are often missing, incomplete, or
incorrect. More importantly, there was no formal language for describing the
types in a precise and verifiable way. And without tooling to enforce the type
signatures, they amounted to little more than wishful thinking.</p>

<p>While this kind of problem is mildly annoying in a codebase with a few hundred
lines of code, it quickly turns into an existential threat when you’re dealing
with many millions of lines of code. Python codebases of this size are common at
companies like Google, Meta, Microsoft, and Dropbox, all of which sponsored the
development of static type checkers in the 2010s. A <em>static type checker</em> is a
tool that verifies the type safety of a program without running it. In other
words, it checks that the program doesn’t perform operations on values that
don’t support those operations.</p>

<p>To some extent, type checkers can deduce the type of a function or variable
automatically, using a process called <em>type inference</em>. They become much more
powerful when you give programmers a way to specify types explicitly in their
code. By the middle of the last decade, and thanks in particular to the
foundational work of Jukka Lehtosalo and collaborators,<sup><a data-type="noteref" id="id323-marker" href="ch10.html#id323">1</a></sup> the
Python language acquired a way to express the types of functions and variables
in source code, called <em>type annotations</em> (<a data-type="xref" href="#example_typing_simple">Example 10-3</a>).</p>
<div id="example_typing_simple" data-type="example">
<h5><span class="label">Example 10-3. </span>A function with type annotations</h5>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">format_lines</code><code class="p">(</code><code class="n">lines</code><code class="p">:</code> <code class="nb">list</code><code class="p">[</code><code class="nb">str</code><code class="p">],</code> <code class="n">indent</code><code class="p">:</code> <code class="nb">int</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">str</code><code class="p">:</code>
    <code class="n">prefix</code> <code class="o">=</code> <code class="s2">" "</code> <code class="o">*</code> <code class="n">indent</code>
    <code class="k">return</code> <code class="s2">"</code><code class="se">\n</code><code class="s2">"</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="sa">f</code><code class="s2">"</code><code class="si">{</code><code class="n">prefix</code><code class="si">}{</code><code class="n">line</code><code class="si">}</code><code class="s2">"</code> <code class="k">for</code> <code class="n">line</code> <code class="ow">in</code> <code class="n">lines</code><code class="p">)</code></pre></div>

<p>Type annotations have become the foundation of a rich ecosystem of developer
tools and libraries.</p>

<p>On their own, type annotations mostly don’t affect the runtime behavior of a
program. The interpreter doesn’t check that assignments are compatible with the
annotated type; it merely stores the annotation inside the special
<code>__annotations__</code> attribute of the containing module, class, or function. While
this incurs a small overhead at runtime, it means you can inspect type
annotations at runtime to do exciting stuff—​say, construct your domain objects
from values transmitted on the wire, without any boilerplate.</p>

<p>One of the most important uses of type annotations, though, doesn’t happen at
runtime: static type checkers, like mypy, use them to verify the correctness of
your code without running it.</p>






<section data-type="sect1" data-pdf-bookmark="Benefits and Costs of Type Annotations"><div class="sect1" id="id205">
<h1>Benefits and Costs of Type Annotations</h1>

<p>You don’t have to use type annotations yourself to benefit from them. Type
annotations are available for the standard library and many PyPI packages.
Static type checkers can warn you when you use a module incorrectly, including
when a breaking change in the library means your code no longer works with that
library—​and type checkers can warn you <em>before</em> you run your code.</p>

<p>Editors and IDEs leverage type annotations to give you a better coding
experience, with auto-completion, tooltips, and class browsers. You can also
inspect type annotations at runtime, unlocking powerful features such as data
validation and serialization.</p>

<p>If you use type annotations in your own code, you reap more benefits. First,
you’re also a user of your own functions, classes, and modules—​so all the
benefits above apply, like auto-completion and type checking. Additionally,
you’ll find it easier to reason about your code, refactor it without introducing
subtle bugs, and build a clean software architecture. As a library author,
typing lets you specify an interface contract on which your users can rely,
while you’re free to evolve the implementation.</p>

<p>Even a decade after their introduction, type annotations aren’t free of
controversy—​maybe understandably so, given Python’s proud stance as a
dynamically typed language. Adding types to existing code poses similar
challenges as introducing unit tests to a codebase that wasn’t written with
testing in mind. Just as you may need to refactor for testability, you may need
to refactor for “typability”—replacing deeply nested primitive types and highly
dynamic objects with simpler and more predictable types. You’ll likely find it
worth the effort.</p>

<p>Another challenge is the rapid evolution of the Python typing language. These
days, Python type annotations are governed by the Typing Council, which
maintains a single, living specification of the typing
language.<sup><a data-type="noteref" id="id324-marker" href="ch10.html#id324">2</a></sup> You can expect
this specification to undergo more substantial changes over the coming years.
While typed Python code needs to navigate this evolution, the typing language
makes no exceptions to Python’s backward compatibility policy.</p>

<p>In this chapter, you’ll learn how to verify the type safety of your Python
programs using the static type checker mypy and the runtime type checker
Typeguard. You’ll also see how runtime inspection of type annotations can
greatly enhance the functionality of your programs. But first, let’s take a look
at the typing language that has evolved within Python over the past decade.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="A Brief Tour of Python’s Typing Language"><div class="sect1" id="section_typing_language">
<h1>A Brief Tour of Python’s Typing Language</h1>
<div data-type="tip"><h6>Tip</h6>
<p>Try out the small examples in this section on one of the type-checker
playgrounds:</p>

<ul>
<li>
<p>the <a href="https://mypy-play.net/">mypy Playground</a></p>
</li>
<li>
<p>the <a href="https://pyright-play.net/">pyright Playground</a></p>
</li>
<li>
<p>the <a href="https://pyre-check.org/play">pyre Playground</a></p>
</li>
</ul>
</div>








<section data-type="sect2" data-pdf-bookmark="Variable Annotations"><div class="sect2" id="id207">
<h2>Variable Annotations</h2>

<p>You can annotate a variable with the type of values that it may be assigned
during the course of the program. The syntax for such type annotations consists
of the variable name, a colon, and a type:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">answer</code><code class="p">:</code> <code class="nb">int</code> <code class="o">=</code> <code class="mi">42</code></pre>

<p>Besides the simple built-in types like <code>bool</code>, <code>int</code>, <code>float</code>, <code>str</code>, or
<code>bytes</code>, you can also use standard container types in type annotations, such as
<code>list</code>, <code>tuple</code>, <code>set</code>, or <code>dict</code>. For example, here’s how you might initialize
a variable used to store a list of lines read from a file:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">lines</code><code class="p">:</code> <code class="nb">list</code><code class="p">[</code><code class="nb">str</code><code class="p">]</code> <code class="o">=</code> <code class="p">[]</code></pre>

<p>While the previous example was somewhat redundant, this one provides actual
value: Without the type annotation, the type checker can’t deduce that you want
to store strings in the list.</p>

<p>The built-in containers are examples of <em>generic types</em>—types that take one or
more arguments. Here’s an example of a dictionary mapping strings to integers.
The two arguments of <code>dict</code> specify the key and value types, respectively:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">fruits</code><code class="p">:</code> <code class="nb">dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="nb">int</code><code class="p">]</code> <code class="o">=</code> <code class="p">{</code>
    <code class="s2">"banana"</code><code class="p">:</code> <code class="mi">3</code><code class="p">,</code>
    <code class="s2">"apple"</code><code class="p">:</code> <code class="mi">2</code><code class="p">,</code>
    <code class="s2">"orange"</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code>
<code class="p">}</code></pre>

<p>Tuples are a bit special, because they come in two flavors. Tuples can be a
combination of a fixed number of types, such as a pair of a string and int:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">pair</code><code class="p">:</code> <code class="nb">tuple</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="nb">int</code><code class="p">]</code> <code class="o">=</code> <code class="p">(</code><code class="s2">"banana"</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code></pre>

<p>Another example of this flavor holds coordinates in three-dimensional space:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">coordinates</code><code class="p">:</code> <code class="nb">tuple</code><code class="p">[</code><code class="nb">float</code><code class="p">,</code> <code class="nb">float</code><code class="p">,</code> <code class="nb">float</code><code class="p">]</code> <code class="o">=</code> <code class="p">(</code><code class="mf">4.5</code><code class="p">,</code> <code class="mf">0.1</code><code class="p">,</code> <code class="mf">3.2</code><code class="p">)</code></pre>

<p>The other common use of tuples is as an immutable sequence of arbitrary length.
To accomodate for this, the typing language lets you write an ellipsis for zero
or more items of the same type. For example, here’s a tuple that can hold any
number of integers (including none at all):</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">numbers</code><code class="p">:</code> <code class="nb">tuple</code><code class="p">[</code><code class="nb">int</code><code class="p">,</code> <code class="o">...</code><code class="p">]</code> <code class="o">=</code> <code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">)</code></pre>

<p>Any class you define in your own Python code is also a type:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">class</code> <code class="nc">Parrot</code><code class="p">:</code>
    <code class="k">pass</code>

<code class="k">class</code> <code class="nc">NorwegianBlue</code><code class="p">(</code><code class="n">Parrot</code><code class="p">):</code>
    <code class="k">pass</code>

<code class="n">parrot</code><code class="p">:</code> <code class="n">Parrot</code> <code class="o">=</code> <code class="n">NorwegianBlue</code><code class="p">()</code></pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The Subtype Relation"><div class="sect2" id="id208">
<h2>The Subtype Relation</h2>

<p>The types on both sides of an assignment aren’t necessarily identical. In the
example above, you assign a <code>NorwegianBlue</code> value to a <code>Parrot</code> variable. This
works because a Norwegian Blue is a kind of parrot—​or technically speaking,
because <code>NorwegianBlue</code> is a subclass of <code>Parrot</code>.</p>

<p>In general, the Python typing language requires that the type on the right-hand
side of a variable assignment be a <em>subtype</em> of the type on the left-hand side.
A prime example of the subtype relation is the relationship of a subclass to its
base class, like <code>NorwegianBlue</code> and <code>Parrot</code>.</p>

<p>However, subtypes are a more general concept than subclasses. For example, a
tuple of ints (like <code>numbers</code> above) is a subtype of a tuple of objects. Unions,
introduced in the next section, are yet another example.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Typing rules also permit assignments if the type on the right is <em>consistent</em>
with that on the left. This lets you assign an <code>int</code> to a <code>float</code>, even though
<code>int</code> isn’t derived from <code>float</code>. The <code>Any</code> type is consistent with any other
type (see <a data-type="xref" href="#section_typing_gradual">“Gradual Typing”</a>).</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Union Types"><div class="sect2" id="id209">
<h2>Union Types</h2>

<p>You can combine two types using the pipe operator (<code>|</code>) to construct a <em>union
type</em>, which is a type whose values range over all the values of its constituent
types. For example, you can use it for a user ID that’s either numeric or a
string:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">user_id</code><code class="p">:</code> <code class="nb">int</code> <code class="o">|</code> <code class="nb">str</code> <code class="o">=</code> <code class="s2">"nobody"</code>  <code class="c1"># or 65534</code></pre>

<p>Arguably the most important use of the union type is for “optional” values,
where the missing value is encoded by <code>None</code>. Here’s an example where a
description is read from a <em>README</em>, provided that the file exists:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">description</code><code class="p">:</code> <code class="nb">str</code> <code class="o">|</code> <code class="kc">None</code> <code class="o">=</code> <code class="kc">None</code>

<code class="k">if</code> <code class="n">readme</code><code class="o">.</code><code class="n">exists</code><code class="p">():</code>
    <code class="n">description</code> <code class="o">=</code> <code class="n">readme</code><code class="o">.</code><code class="n">read_text</code><code class="p">()</code></pre>

<p>Union types are another example for the subtype relation: Each type involved in
the union is a subtype of the union. For example, <code>str</code> and <code>None</code> are each
subtypes of the union type <code>str | None</code>.</p>

<p>I skipped over <code>None</code> above when discussing the built-in types. Strictly
speaking, <code>None</code> is a value, not a type. The type of <code>None</code> is called
<code>NoneType</code>, and it’s available from the standard <code>types</code> module. For
convenience, Python lets you write <code>None</code> in annotations to refer to the type,
as well.</p>

<p>Tony Hoare, a British computer scientist who has made foundational contributions
to many programming languages, famously called the invention of null references,
or <code>None</code>, his “billion-dollar mistake”, due to the number of bugs they’ve
caused since their introduction in <code>ALGOL</code> in 1965. If you’ve ever seen a system
crash with an error like the following, you may agree with him. (Python raises
this error if you attempt to access an attribute on an object that’s in fact
<code>None</code>.)</p>

<pre data-type="programlisting" data-code-language="python"><code class="ne">AttributeError</code><code class="p">:</code> <code class="s1">'NoneType'</code> <code class="nb">object</code> <code class="n">has</code> <code class="n">no</code> <code class="n">attribute</code> <code class="s1">'...'</code></pre>

<p>The good news is that type checkers can warn you when you’re using a variable
that’s potentially <code>None</code>. This can greatly reduce the risk of crashes in
production systems.</p>

<p>How do you tell the type checker that your use of <code>description</code> is fine?
Generally, you should just check that the variable isn’t <code>None</code>. The type
checker will pick up on this and allow you to use the variable:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">if</code> <code class="n">description</code> <code class="ow">is</code> <code class="ow">not</code> <code class="kc">None</code><code class="p">:</code>
    <code class="k">for</code> <code class="n">line</code> <code class="ow">in</code> <code class="n">description</code><code class="o">.</code><code class="n">splitlines</code><code class="p">():</code>
        <code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s2">"    </code><code class="si">{</code><code class="n">line</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code></pre>

<p>There are several methods for <em>type narrowing</em>, as this technique is known. I
won’t discuss them all in detail here. As a rule of thumb, the control flow must
only reach the line in question when the value has the right type—​and type
checkers must be able to infer this fact from the source code. For example, you
could also use the <code>assert</code> keyword with a built-in function like
<code>isinstance</code>:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">assert</code> <code class="nb">isinstance</code><code class="p">(</code><code class="n">description</code><code class="p">,</code> <code class="nb">str</code><code class="p">)</code>
<code class="k">for</code> <code class="n">line</code> <code class="ow">in</code> <code class="n">description</code><code class="o">.</code><code class="n">splitlines</code><code class="p">():</code>
    <code class="o">...</code></pre>

<p>If you already <em>know</em> that the value has the right type, you can help out the
type checker using the <code>cast</code> function from the <code>typing</code> module:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">description_str</code> <code class="o">=</code> <code class="n">cast</code><code class="p">(</code><code class="nb">str</code><code class="p">,</code> <code class="n">description</code><code class="p">)</code>
<code class="k">for</code> <code class="n">line</code> <code class="ow">in</code> <code class="n">description_str</code><code class="o">.</code><code class="n">splitlines</code><code class="p">():</code>
    <code class="o">...</code></pre>

<p>At runtime, the <code>cast</code> function just returns its second argument. Unlike
<code>isinstance</code>, it works with arbitrary type annotations.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Gradual Typing"><div class="sect2" id="section_typing_gradual">
<h2>Gradual Typing</h2>

<p>In Python, every type ultimately derives from <code>object</code>. This is true for
user-defined classes and primitive types alike, even for types like <code>int</code> or
<code>None</code>. In other words, <code>object</code> is a <em>universal supertype</em> in Python—​you can
assign literally anything to a variable of this type.</p>

<p>This may sound kind of powerful, but it really isn’t. In terms of behavior,
<code>object</code> is the smallest common denominator of all Python values, so there’s
precious little you can do with it, as far as type checkers are concerned:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">number</code><code class="p">:</code> <code class="nb">object</code> <code class="o">=</code> <code class="mi">2</code>
<code class="nb">print</code><code class="p">(</code><code class="n">number</code> <code class="o">+</code> <code class="n">number</code><code class="p">)</code>  <code class="c1"># error: Unsupported left operand type for +</code></pre>

<p>There’s another type in Python that, like <code>object</code>, can hold any value. It’s
called <code>Any</code> (for obvious reasons) and it’s available from the standard <code>typing</code>
module. When it comes to behavior, <code>Any</code> is <code>object</code>’s polar opposite. You can
invoke any operation on a value of type <code>Any</code>—conceptually, it behaves like the
intersection of all possible types. <code>Any</code> serves as an escape hatch that lets
you opt out of type checking for a piece of code:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Any</code>

<code class="n">number</code><code class="p">:</code> <code class="n">Any</code> <code class="o">=</code> <code class="n">NorwegianBlue</code><code class="p">()</code>
<code class="nb">print</code><code class="p">(</code><code class="n">number</code> <code class="o">+</code> <code class="n">number</code><code class="p">)</code>  <code class="c1"># valid, but crashes at runtime!</code></pre>

<p>In the first example, the <code>object</code> type results in a false positive: the code
works at runtime, but type checkers will reject it. In the second example, the
<code>Any</code> type results in a false negative: the code crashes at runtime, but type
checkers won’t flag it.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>When you’re working in typed Python code, watch out for <code>Any</code>. It can disable
type-checking to a surprising degree. For example, if you access attributes or
invoke operations on <code>Any</code> values, you’ll end up with more <code>Any</code> values.</p>
</div>

<p>The <code>Any</code> type is Python’s hat trick that lets you restrict type checking to
portions of a codebase—​formally known as <em>gradual typing</em>. In variable
assignments and function calls, <code>Any</code> is consistent with every other type, and
every type is consistent with it.</p>

<p>There are at least a couple of reasons why gradual typing is valuable. First,
Python existed without type annotations for two decades, and Python’s governing
body has no intentions to make type annotations obligatory. Therefore, typed and
untyped Python will coexist for the foreseeable future. Second, Python’s
strength comes in part from its ability to be highly dynamic where needed—​for
example, Python makes it easy to assemble or even modify classes on the fly. In
some cases, it’s hard (or outright impossible) to apply strict types to such
highly dynamic code.<sup><a data-type="noteref" id="id325-marker" href="ch10.html#id325">3</a></sup></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Function Annotations"><div class="sect2" id="id211">
<h2>Function Annotations</h2>

<p>As you may recall from <a data-type="xref" href="#example_typing_simple">Example 10-3</a>, type annotations for function
arguments look quite similar to those for variables. Return types, on the other
hand, are introduced with a right arrow instead of a colon—​after all, the colon
already introduces the function body in Python. For example, here’s a
type-annotated function for adding two numbers:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">add</code><code class="p">(</code><code class="n">a</code><code class="p">:</code> <code class="nb">int</code><code class="p">,</code> <code class="n">b</code><code class="p">:</code> <code class="nb">int</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">int</code><code class="p">:</code>
    <code class="k">return</code> <code class="n">a</code> <code class="o">+</code> <code class="n">b</code></pre>

<p>Python functions that don’t include a <code>return</code> statement implicitly return
<code>None</code>. You might expect return type annotations to be optional in this
case, too. This is not the case! As a general rule, always specify the return
type when annotating a function:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">greet</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="nb">str</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="kc">None</code><code class="p">:</code>
    <code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s2">"Hello, </code><code class="si">{</code><code class="n">name</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code></pre>

<p>Type checkers assume that a function without a return type returns <code>Any</code>.
Likewise, function parameters without annotations default to <code>Any</code>. Effectively,
this disables type checking for the function—​exactly the behavior you’d want in
a world with large bodies of untyped Python code.</p>

<p>Let’s take a look at a slightly more involved function signature:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">subprocess</code>
<code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Any</code>

<code class="k">def</code> <code class="nf">run</code><code class="p">(</code><code class="o">*</code><code class="n">args</code><code class="p">:</code> <code class="nb">str</code><code class="p">,</code> <code class="n">check</code><code class="p">:</code> <code class="nb">bool</code> <code class="o">=</code> <code class="kc">True</code><code class="p">,</code> <code class="o">**</code><code class="n">kwargs</code><code class="p">:</code> <code class="n">Any</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="kc">None</code><code class="p">:</code>
    <code class="n">subprocess</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">args</code><code class="p">,</code> <code class="n">check</code><code class="o">=</code><code class="n">check</code><code class="p">,</code> <code class="o">**</code><code class="n">kwargs</code><code class="p">)</code></pre>

<p>Parameters with default arguments, like <code>check</code>, use a syntax similar to
variable assignments. The <code>*args</code> parameter holds the tuple of positional
arguments—​each argument must be a <code>str</code>. The <code>**kwargs</code> parameter holds the
dictionary of keyword arguments—​using <code>Any</code> means that the keyword arguments
aren’t restricted to any specific type.</p>

<p>In Python, you can use <code>yield</code> inside a function to define a <em>generator</em>, which
is an object that produces a series of values you can use in a <code>for</code> loop.
Generators support some behavior beyond iteration; when used only for iteration,
they’re known as <em>iterators</em>. Here’s how you’d write their type:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">collections.abc</code> <code class="kn">import</code> <code class="n">Iterator</code>

<code class="k">def</code> <code class="nf">fibonacci</code><code class="p">()</code> <code class="o">-&gt;</code> <code class="n">Iterator</code><code class="p">[</code><code class="nb">int</code><code class="p">]:</code>
    <code class="n">a</code><code class="p">,</code> <code class="n">b</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code>
    <code class="k">while</code> <code class="kc">True</code><code class="p">:</code>
        <code class="k">yield</code> <code class="n">a</code>
        <code class="n">a</code><code class="p">,</code> <code class="n">b</code> <code class="o">=</code> <code class="n">b</code><code class="p">,</code> <code class="n">a</code> <code class="o">+</code> <code class="n">b</code></pre>

<p>Functions are first-class citizens in Python. You can assign a function to a
variable or pass it to another function—​for example, to register a callback.
Consequently, Python lets you express the type of a function outside of a
function definition. <code>Callable</code> is a generic type takes two arguments—​a list
of parameter types and the return type:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">collections.abc</code> <code class="kn">import</code> <code class="n">Callable</code>

<code class="n">Serve</code> <code class="o">=</code> <code class="n">Callable</code><code class="p">[[</code><code class="n">Article</code><code class="p">],</code> <code class="nb">str</code><code class="p">]</code></pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Annotating Classes"><div class="sect2" id="id212">
<h2>Annotating Classes</h2>

<p>The rules for variable and function annotations also apply in the context of
class definitions, where they describe instance variables and methods. You can
omit the annotation for the <code>self</code> argument in a method. Type checkers can infer
instance variables from assignments in a <code>__init__</code> method:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">class</code> <code class="nc">Swallow</code><code class="p">:</code>
    <code class="k">def</code> <code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">velocity</code><code class="p">:</code> <code class="nb">float</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="kc">None</code><code class="p">:</code>
        <code class="bp">self</code><code class="o">.</code><code class="n">velocity</code> <code class="o">=</code> <code class="n">velocity</code></pre>

<p>The standard <code>dataclasses</code> module generates the canonical method definitions
from the type annotations of any class decorated with <code>@dataclass</code>:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">dataclasses</code> <code class="kn">import</code> <code class="n">dataclass</code>

<code class="nd">@dataclass</code>
<code class="k">class</code> <code class="nc">Swallow</code><code class="p">:</code>
    <code class="n">velocity</code><code class="p">:</code> <code class="nb">float</code></pre>

<p>The dataclass-style definition isn’t only more concise than the handwritten one,
it also confers the class additional runtime behavior—​such as the ability to
compare instances for equality based on their attributes, or to order them.</p>

<p>When you’re annotating classes, the problem of forward references often appears.
Consider a two-dimensional point, with a method to compute its Euclidean
distance from another point:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">math</code>
<code class="kn">from</code> <code class="nn">dataclasses</code> <code class="kn">import</code> <code class="n">dataclass</code>

<code class="nd">@dataclass</code>
<code class="k">class</code> <code class="nc">Point</code><code class="p">:</code>
    <code class="n">x</code><code class="p">:</code> <code class="nb">float</code>
    <code class="n">y</code><code class="p">:</code> <code class="nb">float</code>

    <code class="k">def</code> <code class="nf">distance</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">other</code><code class="p">:</code> <code class="n">Point</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">float</code><code class="p">:</code>
        <code class="n">dx</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">x</code> <code class="o">-</code> <code class="n">other</code><code class="o">.</code><code class="n">x</code>
        <code class="n">dy</code> <code class="o">=</code> <code class="bp">self</code><code class="o">.</code><code class="n">y</code> <code class="o">-</code> <code class="n">other</code><code class="o">.</code><code class="n">y</code>
        <code class="k">return</code> <code class="n">math</code><code class="o">.</code><code class="n">sqrt</code><code class="p">(</code><code class="n">dx</code><code class="o">*</code><code class="n">dx</code> <code class="o">+</code> <code class="n">dy</code><code class="o">*</code><code class="n">dy</code><code class="p">)</code></pre>

<p>While type checkers are happy with this definition, the code raises an exception
when you run it with the Python interpreter:<sup><a data-type="noteref" id="id326-marker" href="ch10.html#id326">4</a></sup></p>

<pre data-type="programlisting" data-code-language="python"><code class="ne">NameError</code><code class="p">:</code> <code class="n">name</code> <code class="s1">'Point'</code> <code class="ow">is</code> <code class="ow">not</code> <code class="n">defined</code><code class="o">.</code> <code class="n">Did</code> <code class="n">you</code> <code class="n">mean</code><code class="p">:</code> <code class="s1">'print'</code><code class="err">?</code></pre>

<p>Python doesn’t let you use <code>Point</code> in the method definition, because you’re not
done defining the class—​the name doesn’t exist yet. There are several ways to
resolve this situation. First, you can write the forward reference as a string
to avoid the <code>NameError</code>, a technique known as <em>stringized</em> annotations.</p>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@dataclass</code>
<code class="k">class</code> <code class="nc">Point</code><code class="p">:</code>
    <code class="k">def</code> <code class="nf">distance</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">other</code><code class="p">:</code> <code class="s2">"Point"</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">float</code><code class="p">:</code>
        <code class="o">...</code></pre>

<p>Second, you can implicitly stringize all annotations in the current module using
the <code>annotations</code> future import:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">__future__</code> <code class="kn">import</code> <code class="n">annotations</code>

<code class="nd">@dataclass</code>
<code class="k">class</code> <code class="nc">Point</code><code class="p">:</code>
    <code class="k">def</code> <code class="nf">distance</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">other</code><code class="p">:</code> <code class="n">Point</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">float</code><code class="p">:</code>
        <code class="o">...</code></pre>

<p>The third method does not help with all forward references, but it does here.
You can use the special <code>Self</code> type to refer to the current
class:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Self</code>

<code class="nd">@dataclass</code>
<code class="k">class</code> <code class="nc">Point</code><code class="p">:</code>
    <code class="k">def</code> <code class="nf">distance</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">other</code><code class="p">:</code> <code class="n">Self</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">float</code><code class="p">:</code>
        <code class="o">...</code></pre>

<p>Beware of a semantic difference in this third version compared to the earlier
ones. If you derived a <code>SparklyPoint</code> class from <code>Point</code>, <code>Self</code> would refer to
the derived class rather than the base class. In other words, you wouldn’t be
able to compute the distance of sparkly points from plain old points.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Type Aliases"><div class="sect2" id="section_typing_aliases">
<h2>Type Aliases</h2>

<p>You can use the <code>type</code> keyword to introduce an alias for a type:<sup><a data-type="noteref" id="id327-marker" href="ch10.html#id327">5</a></sup></p>

<pre data-type="programlisting" data-code-language="python"><code class="nb">type</code> <code class="n">UserID</code> <code class="o">=</code> <code class="nb">int</code> <code class="o">|</code> <code class="nb">str</code></pre>

<p>This technique is useful to make your code self-documenting, and to keep it
readable when the types become unwieldy, as they sometimes do. Type aliases also
let you define types that would otherwise be impossible to express. Consider an
inherently recursive data type such as a JSON object:</p>

<pre data-type="programlisting" data-code-language="python"><code class="nb">type</code> <code class="n">JSON</code> <code class="o">=</code> <code class="kc">None</code> <code class="o">|</code> <code class="nb">bool</code> <code class="o">|</code> <code class="nb">int</code> <code class="o">|</code> <code class="nb">float</code> <code class="o">|</code> <code class="nb">str</code> <code class="o">|</code> <code class="nb">list</code><code class="p">[</code><code class="n">JSON</code><code class="p">]</code> <code class="o">|</code> <code class="nb">dict</code><code class="p">[</code><code class="nb">str</code><code class="p">,</code> <code class="n">JSON</code><code class="p">]</code></pre>

<p>Recursive type aliases are another example of forward references. If your Python
version doesn’t yet support the <code>type</code> keyword, you’ll need to replace <code>JSON</code>
with <code>"JSON"</code> on the right-hand side to avoid a <code>NameError</code>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Generics"><div class="sect2" id="id214">
<h2>Generics</h2>

<p>As you’ve seen at the beginning of this section, built-in containers like <code>list</code>
are generic types. You can also define generic functions and classes yourself,
and it’s quite straightforward to do so. Consider a function that returns the
first item in a list of strings:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">first</code><code class="p">(</code><code class="n">values</code><code class="p">:</code> <code class="nb">list</code><code class="p">[</code><code class="nb">str</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="nb">str</code><code class="p">:</code>
    <code class="k">for</code> <code class="n">value</code> <code class="ow">in</code> <code class="n">values</code><code class="p">:</code>
        <code class="k">return</code> <code class="n">value</code>
    <code class="k">raise</code> <code class="ne">ValueError</code><code class="p">(</code><code class="s2">"empty list"</code><code class="p">)</code></pre>

<p>There’s no reason to restrict the element type to a string: the logic doesn’t
depend on it. Let’s make the function generic for all types. First, replace
<code>str</code> with the placeholder <code>T</code>. Second, mark the placeholder as a <em>type
variable</em> by declaring it in square brackets after the function name. (The name
<code>T</code> is just a convention, you could name it anything.) Additionally, there’s no
reason to restrict the function to lists, because it works with any type over
which you can iterate in a <code>for</code> loop—​in other words, any <em>iterable</em>.</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">collections.abc</code> <code class="kn">import</code> <code class="n">Iterable</code>

<code class="k">def</code> <code class="nf">first</code><code class="p">[</code><code class="n">T</code><code class="p">](</code><code class="n">values</code><code class="p">:</code> <code class="n">Iterable</code><code class="p">[</code><code class="n">T</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="n">T</code><code class="p">:</code>
    <code class="k">for</code> <code class="n">value</code> <code class="ow">in</code> <code class="n">values</code><code class="p">:</code>
        <code class="k">return</code> <code class="n">value</code>
    <code class="k">raise</code> <code class="ne">ValueError</code><code class="p">(</code><code class="s2">"no values"</code><code class="p">)</code></pre>

<p>Here’s how you might use the generic function in your code:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">fruit</code><code class="p">:</code> <code class="nb">str</code> <code class="o">=</code> <code class="n">first</code><code class="p">([</code><code class="s2">"banana"</code><code class="p">,</code> <code class="s2">"orange"</code><code class="p">,</code> <code class="s2">"apple"</code><code class="p">])</code>
<code class="n">number</code><code class="p">:</code> <code class="nb">int</code> <code class="o">=</code> <code class="n">first</code><code class="p">({</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">})</code></pre>

<p>You can omit the variable annotations for <code>fruit</code> and <code>number</code>, by the way—​type
checkers infer them from the annotation of your generic function.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Generics with the <code>[T]</code> syntax are supported in Python 3.12+ and the Pyright
type checker. If you get an error, omit the <code>[T]</code> suffix from <code>first</code> and use
<code>TypeVar</code> from the <code>typing</code> module:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">T</code> <code class="o">=</code> <code class="n">TypeVar</code><code class="p">(</code><code class="s2">"T"</code><code class="p">)</code></pre>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Protocols"><div class="sect2" id="id215">
<h2>Protocols</h2>

<p>The <code>join_all</code> function from <a data-type="xref" href="#example_typing_duck">Example 10-1</a> works with threads,
processes, or any other objects you can join. Duck typing makes your functions
simple and reusable. But how can you verify the implicit contract between the
functions and their callers?</p>

<p><em>Protocols</em> bridge the gap between duck typing and type annotations. A protocol
describes the behavior of an object, without requiring the object to inherit from
it. It looks somewhat like an <em>abstract base class</em>—a base class that doesn’t
implement any methods:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Protocol</code>

<code class="k">class</code> <code class="nc">Joinable</code><code class="p">(</code><code class="n">Protocol</code><code class="p">):</code>
    <code class="k">def</code> <code class="nf">join</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="kc">None</code><code class="p">:</code>
        <code class="o">...</code></pre>

<p>The <code>Joinable</code> protocol requires the object to have a <code>join</code> method that takes
no arguments and returns <code>None</code>. The <code>join_all</code> function can use the protocol to
specify which objects it supports:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">join_all</code><code class="p">(</code><code class="n">joinables</code><code class="p">:</code> <code class="n">Iterable</code><code class="p">[</code><code class="n">Joinable</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="kc">None</code><code class="p">:</code>
    <code class="k">for</code> <code class="n">task</code> <code class="ow">in</code> <code class="n">joinables</code><code class="p">:</code>
        <code class="n">task</code><code class="o">.</code><code class="n">join</code><code class="p">()</code></pre>

<p>Remarkably, this piece of code works with standard library types like <code>Thread</code>
or <code>Process</code>, even though they don’t have any knowledge of your <code>Joinable</code>
protocol—​a prime example of loose coupling.</p>

<p>This technique is known as <em>structural subtyping</em>: it’s the internal structure
of <code>Thread</code> and <code>Process</code> that makes them subtypes of <code>Joinable</code>. By contrast,
<em>nominal subtyping</em> requires you to derive the subtype from the supertype
explicitly.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Compatibility with Older Python Versions"><div class="sect2" id="id216">
<h2>Compatibility with Older Python Versions</h2>

<p>The description above is based on the latest Python release as of this writing,
Python 3.12. <a data-type="xref" href="#table_typing_compatibility">Table 10-1</a> lists typing features that aren’t
yet available on older Python versions, as well as their replacements in those
versions.</p>
<table id="table_typing_compatibility">
<caption><span class="label">Table 10-1. </span>Availability of Typing Features</caption>
<thead>
<tr>
<th>Feature</th>
<th>Example</th>
<th>Availability</th>
<th>Replacement</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>generics in standard collections</p></td>
<td><p><code>list[str]</code></p></td>
<td><p>Python 3.9</p></td>
<td><p><code>typing.List</code></p></td>
</tr>
<tr>
<td><p>union operator</p></td>
<td><p><code>str | int</code></p></td>
<td><p>Python 3.10</p></td>
<td><p><code>typing.Union</code></p></td>
</tr>
<tr>
<td><p>Self type</p></td>
<td><p><code>Self</code></p></td>
<td><p>Python 3.11</p></td>
<td><p><code>typing_extensions.Self</code></p></td>
</tr>
<tr>
<td><p><code>type</code> keyword</p></td>
<td><p><code>type UserID = ...</code></p></td>
<td><p>Python 3.12</p></td>
<td><p><code>typing.TypeAlias</code> (Python 3.10)</p></td>
</tr>
<tr>
<td><p>type parameter syntax</p></td>
<td><p><code>def first[T](...)</code></p></td>
<td><p>Python 3.12</p></td>
<td><p><code>typing.TypeVar</code></p></td>
</tr>
</tbody>
</table>

<p>The <code>typing-extensions</code> library provides backports for many features not
available in older Python versions, see <a data-type="xref" href="#section_typing_nox">“Automating mypy with Nox”</a>.</p>

<p>This concludes our brief tour of Python’s typing language. While there’s a lot
more to typing in Python, I hope that this overview has taught you enough to
make deeper forays into the exciting world of typing on your own.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Static Type Checking with mypy"><div class="sect1" id="id217">
<h1>Static Type Checking with mypy</h1>

<p>Mypy is a widely used static type checker for Python. A static type checker uses
type annotations and type inference to detect bugs in a program without
running it. Mypy was the original reference implementation when the typing
system was codified in PEP 484. This doesn’t mean that mypy is always the first
type checker to implement a new feature of the typing language—​for example, the
<code>type</code> keyword was first implemented in Pyright. However, it’s certainly a good
default choice, and core members of the typing community are involved in its
development.</p>








<section data-type="sect2" data-pdf-bookmark="First Steps with mypy"><div class="sect2" id="id218">
<h2>First Steps with mypy</h2>

<p>Add mypy to the development dependencies of your project—​for example, by adding
a <code>typing</code> extra:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project.optional-dependencies]</code><code class="w"/>
<code class="n">typing</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"mypy&gt;=1.9.0"</code><code class="p">]</code><code class="w"/></pre>

<p>You can now install mypy in the project environment:</p>
<pre data-type="programlisting">$ <strong>uv pip install -e ".[typing]"</strong></pre>

<p>If you use Poetry, add mypy to your project using <code>poetry add</code>:</p>
<pre data-type="programlisting">$ <strong>poetry add --group=typing "mypy&gt;=1.9.0"</strong></pre>

<p>Finally, run mypy on the <em>src</em> directory of your project:</p>
<pre data-type="programlisting">$ <strong>py -m mypy src</strong>
Success: no issues found in 2 source files
</pre>

<p>Let’s type-check some code with a type-related bug. Consider the following
program, which passes <code>None</code> to a function that expects a string:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">textwrap</code>

<code class="n">data</code> <code class="o">=</code> <code class="p">{</code><code class="s2">"title"</code><code class="p">:</code> <code class="s2">"Gegenes nostrodamus"</code><code class="p">}</code>

<code class="n">summary</code> <code class="o">=</code> <code class="n">data</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s2">"extract"</code><code class="p">)</code>
<code class="n">summary</code> <code class="o">=</code> <code class="n">textwrap</code><code class="o">.</code><code class="n">fill</code><code class="p">(</code><code class="n">summary</code><code class="p">)</code></pre>

<p>If you run mypy on this code, it dutifully reports that the argument in the call
to <code>textwrap.fill</code> isn’t guaranteed to be a string:</p>
<pre data-type="programlisting">$ <strong>py -m mypy example.py</strong>
example.py:5: error: Argument 1 to "fill" has incompatible type "str | None";
  expected "str"  [arg-type]
Found 1 error in 1 file (checked 1 source file)
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Revisiting the Wikipedia Example"><div class="sect2" id="section_typing_revisiting">
<h2>Revisiting the Wikipedia Example</h2>

<p>Let’s revisit the Wikipedia API client from <a data-type="xref" href="ch06.html#example_testing_refactored">Example 6-3</a>. In a
fictional scenario, sweeping censorship laws have been passed. Depending on the
country you’re connecting from, the Wikipedia API omits the article summary.</p>

<p>You could store an empty string when this happens. But let’s be principled: An
empty summary isn’t the same as no summary at all. Let’s store <code>None</code> when the
response omits the field.</p>

<p>As a first step, change the <code>summary</code> default to <code>None</code> instead of an empty
string. Use a union type to signal that the field can hold <code>None</code> instead of a
string.</p>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@dataclass</code>
<code class="k">class</code> <code class="nc">Article</code><code class="p">:</code>
    <code class="n">title</code><code class="p">:</code> <code class="nb">str</code> <code class="o">=</code> <code class="s2">""</code>
    <code class="n">summary</code><code class="p">:</code> <code class="nb">str</code> <code class="o">|</code> <code class="kc">None</code> <code class="o">=</code> <code class="kc">None</code></pre>

<p>A few lines below, the <code>show</code> function reformats the summary to ensure a line
length of 72 characters or fewer:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">show</code><code class="p">(</code><code class="n">article</code><code class="p">,</code> <code class="n">file</code><code class="p">):</code>
    <code class="n">summary</code> <code class="o">=</code> <code class="n">textwrap</code><code class="o">.</code><code class="n">fill</code><code class="p">(</code><code class="n">article</code><code class="o">.</code><code class="n">summary</code><code class="p">)</code>
    <code class="n">file</code><code class="o">.</code><code class="n">write</code><code class="p">(</code><code class="sa">f</code><code class="s2">"</code><code class="si">{</code><code class="n">article</code><code class="o">.</code><code class="n">title</code><code class="si">}</code><code class="se">\n\n</code><code class="si">{</code><code class="n">summary</code><code class="si">}</code><code class="se">\n</code><code class="s2">"</code><code class="p">)</code></pre>

<p>Presumably, mypy will balk at this error, just like it did above. Yet, when you
run it on the file, it’s all sunshine. Can you guess why?</p>
<pre data-type="programlisting">$ <strong>py -m mypy src</strong>
Success: no issues found in 2 source files
</pre>

<p>Mypy doesn’t complain about the call because the <code>article</code> parameter doesn’t
have a type annotation. It considers <code>article</code> to be <code>Any</code>, so the expression
<code>article.summary</code> also becomes <code>Any</code>. (<code>Any</code> is infectious.) As far as mypy is
concerned, that expression can be <code>str</code>, <code>None</code>, and a pink elephant, all at the
same time. This is gradual typing in action, and it’s also why you should be
wary of <code>Any</code> types and missing annotations in your code.</p>

<p>You can help mypy detect the error by annotating the parameter as <code>article:
Article</code>. Try actually fixing the bug, as well—​think about how you would handle
the case of summaries being <code>None</code> in a real program. Here’s one way to solve
this:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">show</code><code class="p">(</code><code class="n">article</code><code class="p">:</code> <code class="n">Article</code><code class="p">,</code> <code class="n">file</code><code class="p">):</code>
    <code class="k">if</code> <code class="n">article</code><code class="o">.</code><code class="n">summary</code> <code class="ow">is</code> <code class="ow">not</code> <code class="kc">None</code><code class="p">:</code>
        <code class="n">summary</code> <code class="o">=</code> <code class="n">textwrap</code><code class="o">.</code><code class="n">fill</code><code class="p">(</code><code class="n">article</code><code class="o">.</code><code class="n">summary</code><code class="p">)</code>
    <code class="k">else</code><code class="p">:</code>
        <code class="n">summary</code> <code class="o">=</code> <code class="s2">"[CENSORED]"</code>
    <code class="n">file</code><code class="o">.</code><code class="n">write</code><code class="p">(</code><code class="sa">f</code><code class="s2">"</code><code class="si">{</code><code class="n">article</code><code class="o">.</code><code class="n">title</code><code class="si">}</code><code class="se">\n\n</code><code class="si">{</code><code class="n">summary</code><code class="si">}</code><code class="se">\n</code><code class="s2">"</code><code class="p">)</code></pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Strict Mode"><div class="sect2" id="id220">
<h2>Strict Mode</h2>

<p>Mypy defaults to gradual typing by treating parameters and return values as
<code>Any</code> if they don’t have type annotations. Turn on strict mode in
<em>pyproject.toml</em> to opt out of this lenient default:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[tool.mypy]</code><code class="w"/>
<code class="n">strict</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">true</code><code class="w"/></pre>

<p>The <code>strict</code> setting changes the defaults of a dozen-odd more fine-grained
settings. If you run mypy on the module again, you’ll notice that the type
checker has become a lot more opinionated about your code. In strict mode, both
defining and calling untyped functions will result in an error.<sup><a data-type="noteref" id="id328-marker" href="ch10.html#id328">6</a></sup></p>
<pre data-type="programlisting">$ <strong>py -m mypy src</strong>
__init__.py:16: error: Function is missing a type annotation
__init__.py:22: error: Function is missing a type annotation
__init__.py:30: error: Function is missing a return type annotation
__init__.py:30: note: Use "-&gt; None" if function does not return a value
__init__.py:31: error: Call to untyped function "fetch" in typed context
__init__.py:32: error: Call to untyped function "show" in typed context
__main__.py:3: error: Call to untyped function "main" in typed context
Found 6 errors in 2 files (checked 2 source files)
</pre>

<p><a data-type="xref" href="#example_typing_wikipedia">Example 10-4</a> shows the module with type annotations and
introduces two concepts you haven’t seen yet. First, the <code>Final</code> annotation
marks <code>API_URL</code> as a constant—​a variable to which you can’t assign another
value. Second, the <code>TextIO</code> type is a file-like object for reading and writing
strings (<code>str</code>), such as the standard output stream. Otherwise, the type
annotations should look fairly familiar.</p>
<div id="example_typing_wikipedia" data-type="example">
<h5><span class="label">Example 10-4. </span>The Wikipedia API client with type annotations</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">json</code>
<code class="kn">import</code> <code class="nn">sys</code>
<code class="kn">import</code> <code class="nn">textwrap</code>
<code class="kn">import</code> <code class="nn">urllib.request</code>
<code class="kn">from</code> <code class="nn">dataclasses</code> <code class="kn">import</code> <code class="n">dataclass</code>
<code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Final</code><code class="p">,</code> <code class="n">TextIO</code>

<code class="n">API_URL</code><code class="p">:</code> <code class="n">Final</code> <code class="o">=</code> <code class="s2">"https://en.wikipedia.org/api/rest_v1/page/random/summary"</code>

<code class="nd">@dataclass</code>
<code class="k">class</code> <code class="nc">Article</code><code class="p">:</code>
    <code class="n">title</code><code class="p">:</code> <code class="nb">str</code> <code class="o">=</code> <code class="s2">""</code>
    <code class="n">summary</code><code class="p">:</code> <code class="nb">str</code> <code class="o">=</code> <code class="s2">""</code>

<code class="k">def</code> <code class="nf">fetch</code><code class="p">(</code><code class="n">url</code><code class="p">:</code> <code class="nb">str</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Article</code><code class="p">:</code>
    <code class="k">with</code> <code class="n">urllib</code><code class="o">.</code><code class="n">request</code><code class="o">.</code><code class="n">urlopen</code><code class="p">(</code><code class="n">url</code><code class="p">)</code> <code class="k">as</code> <code class="n">response</code><code class="p">:</code>
        <code class="n">data</code> <code class="o">=</code> <code class="n">json</code><code class="o">.</code><code class="n">load</code><code class="p">(</code><code class="n">response</code><code class="p">)</code>
    <code class="k">return</code> <code class="n">Article</code><code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="s2">"title"</code><code class="p">],</code> <code class="n">data</code><code class="p">[</code><code class="s2">"extract"</code><code class="p">])</code>

<code class="k">def</code> <code class="nf">show</code><code class="p">(</code><code class="n">article</code><code class="p">:</code> <code class="n">Article</code><code class="p">,</code> <code class="n">file</code><code class="p">:</code> <code class="n">TextIO</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="kc">None</code><code class="p">:</code>
    <code class="n">summary</code> <code class="o">=</code> <code class="n">textwrap</code><code class="o">.</code><code class="n">fill</code><code class="p">(</code><code class="n">article</code><code class="o">.</code><code class="n">summary</code><code class="p">)</code>
    <code class="n">file</code><code class="o">.</code><code class="n">write</code><code class="p">(</code><code class="sa">f</code><code class="s2">"</code><code class="si">{</code><code class="n">article</code><code class="o">.</code><code class="n">title</code><code class="si">}</code><code class="se">\n\n</code><code class="si">{</code><code class="n">summary</code><code class="si">}</code><code class="se">\n</code><code class="s2">"</code><code class="p">)</code>

<code class="k">def</code> <code class="nf">main</code><code class="p">()</code> <code class="o">-&gt;</code> <code class="kc">None</code><code class="p">:</code>
    <code class="n">article</code> <code class="o">=</code> <code class="n">fetch</code><code class="p">(</code><code class="n">API_URL</code><code class="p">)</code>
    <code class="n">show</code><code class="p">(</code><code class="n">article</code><code class="p">,</code> <code class="n">sys</code><code class="o">.</code><code class="n">stdout</code><code class="p">)</code></pre></div>

<p>I recommend strict mode for any new Python project, because it’s much easier to
annotate your code as you write it. Strict checks give you more confidence in
the correctness of your program, because type errors are less likely to be
masked by <code>Any</code>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>My other favorite mypy setting in <em>pyproject.toml</em> is the <code>pretty</code> flag. It
displays source snippets and indicates where the error occurred:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[tool.mypy]</code><code class="w"/>
<code class="n">pretty</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">true</code><code class="w"/></pre>
</div>

<p>Let mypy’s strict mode be your North Star when adding types to an existing
Python codebase. Mypy gives you an arsenal of finer and coarser-grained ways to
relax type checking when you’re not ready to fix a type error.</p>

<p>Your first line of defense is a special comment of the form <code># type: ignore</code>.
Always follow it with the error code in square brackets. For example, here’s a
line from mypy’s output above with the error code included:</p>
<pre data-type="programlisting">
__main__.py:3: error: Call to untyped function "main" in typed context
  [no-untyped-call]
</pre>

<p>You can allow this specific call to an untyped function as follows:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">main</code><code class="p">()</code>  <code class="c1"># type: ignore[no-untyped-call]</code></pre>

<p>If you have a module with a large number of untyped calls, you can ignore the
error for the entire module using the following stanza in your <em>pyproject.toml</em>:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[</code><code class="k">tool</code><code class="k">.</code><code class="k">mypy</code><code class="k">.</code><code class="s2">"</code><code class="s2">&lt;module&gt;</code><code class="s2">"</code><code class="k">]</code><code class="w"> </code><a class="co" id="co_using_types_for_safety_and_inspection_CO1-1" href="#callout_using_types_for_safety_and_inspection_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code class="w">
</code><code class="n">allow_untyped_calls</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">true</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_using_types_for_safety_and_inspection_CO1-1" href="#co_using_types_for_safety_and_inspection_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Replace <code>&lt;module&gt;</code> with the module that has the untyped calls. Use double
quotes if the module’s name contains any dots.</p></dd>
</dl>

<p>You can also ignore an error globally, like this:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[tool.mypy]</code><code class="w"/>
<code class="n">allow_untyped_calls</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">true</code><code class="w"/></pre>

<p>You can even disable all type errors for a given module:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[tool.mypy.</code><code class="s2">"&lt;module&gt;"</code><code class="k">]</code><code class="w"/>
<code class="n">ignore_errors</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">true</code><code class="w"/></pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Automating mypy with Nox"><div class="sect2" id="section_typing_nox">
<h2>Automating mypy with Nox</h2>

<p>All through this book, you’ve automated checks for your projects using Nox. Nox
sessions allow you and other contributors to run checks easily and repeatedly
during local development, the same way they’d run on a continuous integration
(CI) server.</p>

<p><a data-type="xref" href="#example_typing_nox_mypy">Example 10-5</a> shows a Nox session for type-checking your project
with mypy:</p>
<div id="example_typing_nox_mypy" data-type="example">
<h5><span class="label">Example 10-5. </span>A Nox session for type checking with mypy</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">nox</code>

<code class="nd">@nox</code><code class="o">.</code><code class="n">session</code><code class="p">(</code><code class="n">python</code><code class="o">=</code><code class="p">[</code><code class="s2">"3.12"</code><code class="p">,</code> <code class="s2">"3.11"</code><code class="p">,</code> <code class="s2">"3.10"</code><code class="p">])</code>
<code class="k">def</code> <code class="nf">mypy</code><code class="p">(</code><code class="n">session</code><code class="p">:</code> <code class="n">nox</code><code class="o">.</code><code class="n">Session</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="kc">None</code><code class="p">:</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">".[typing]"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"mypy"</code><code class="p">,</code> <code class="s2">"src"</code><code class="p">)</code></pre></div>

<p>Just like you run the test suite across all supported Python versions, you
should also type-check your project on every Python version. This practice is
fairly effective at ensuring that your project is compatible with those
versions, even when your test suite doesn’t exercise that one code path where
you forgot about backwards compatibility.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can also pass the target version using mypy’s <code>--python-version</code> option.
However, installing the project on each version ensures that mypy checks your
project against the correct dependencies. These may not be the same on all
Python versions.</p>
</div>

<p>Inevitably, as you type-check on multiple versions, you’ll get into situations
where either the runtime code or the type annotations don’t work across all
versions. For example, Python 3.9 deprecated <code>typing.Iterable</code> in favor of
<code>collections.abc.Iterable</code>. Use conditional imports based on the Python version,
as shown below. Static type checkers recognize Python version checks in your
code, and they will base their type checks on the code relevant for the current
version.</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">sys</code>

<code class="k">if</code> <code class="n">sys</code><code class="o">.</code><code class="n">version_info</code> <code class="o">&gt;=</code> <code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">9</code><code class="p">):</code>
    <code class="kn">from</code> <code class="nn">collections.abc</code> <code class="kn">import</code> <code class="n">Iterable</code>
<code class="k">else</code><code class="p">:</code>
    <code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Iterable</code></pre>

<p>Another sticking point: typing features not yet available at the low end of your
supported Python version range. Fortunately, these often come with backports in
a third-party library named <code>typing-extensions</code>. For example, Python 3.11 added
the useful <code>Self</code> annotation, which denotes the currently enclosing class. If
you support versions older than that, add <code>typing-extensions</code> to your
dependencies and import <code>Self</code> from there:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">sys</code>

<code class="k">if</code> <code class="n">sys</code><code class="o">.</code><code class="n">version_info</code> <code class="o">&gt;=</code> <code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">11</code><code class="p">):</code>
    <code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Self</code>
<code class="k">else</code><code class="p">:</code>
    <code class="kn">from</code> <code class="nn">typing_extensions</code> <code class="kn">import</code> <code class="n">Self</code></pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Distributing Types with Python Packages"><div class="sect2" id="section_typing_distributing">
<h2>Distributing Types with Python Packages</h2>

<p>You may wonder why the Nox session in <a data-type="xref" href="#example_typing_nox_mypy">Example 10-5</a> installs the
project into mypy’s virtual environment. By nature, a static type checker
operates on source code; it doesn’t run your code. So why install anything but
the type checker itself?</p>

<p>To see why this matters, consider the version of the Wikipedia project in
<a data-type="xref" href="ch06.html#example_testing_rich">Example 6-5</a> and <a data-type="xref" href="ch06.html#example_testing_httpx">Example 6-14</a>, where you implemented
the <code>show</code> and <code>fetch</code> functions using Rich and <code>httpx</code>. How can a type checker
validate your use of a specific version of a third-party package?</p>

<p>Rich and <code>httpx</code> are, in fact, fully type annotated. They include an empty
marker file named <em>py.typed</em> next to their source files. When you install the
packages into a virtual environment, the marker file allows static type checkers
to locate their types.</p>

<p>Many Python packages distribute their types inline with <em>py.typed</em> markers.
However, other mechanisms for type distribution exist. Knowing them is useful
when mypy can’t import the types for a package.</p>

<p>For example, the <code>factory-boy</code> library doesn’t yet ship with types—​instead, you
need to install a stubs package named <code>types-factory-boy</code> from PyPI.<sup><a data-type="noteref" id="id329-marker" href="ch10.html#id329">7</a></sup> A <em>stubs package</em> is a Python package containing typing stubs, a
special kind of Python source file with a <em>.pyi</em> suffix that has only type
annotations and no executable code.</p>

<p>If you’re entirely out of luck and types for your dependency simply don’t exist,
disable the mypy error in <em>pyproject.toml</em>, like this:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[</code><code class="k">tool</code><code class="k">.</code><code class="k">mypy</code><code class="k">.</code><code class="err">&lt;</code><code class="k">package</code><code class="err">&gt;</code><code class="k">]</code><code class="w"> </code><a class="co" id="co_using_types_for_safety_and_inspection_CO2-1" href="#callout_using_types_for_safety_and_inspection_CO2-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code class="w">
</code><code class="n">ignore_missing_imports</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">true</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_using_types_for_safety_and_inspection_CO2-1" href="#co_using_types_for_safety_and_inspection_CO2-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Replace <code>&lt;package&gt;</code> with the import name of the package.</p></dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Python’s standard library doesn’t include type annotations. Type checkers vendor
the third-party package <code>typeshed</code> for standard library types, so you don’t have
to worry about supplying them.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Type-Checking the Tests"><div class="sect2" id="id223">
<h2>Type-Checking the Tests</h2>

<p>Treat your tests like you would treat any other code. Type-checking your tests
helps you detect when they use your project, pytest, or testing libraries
incorrectly.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Running mypy on your test suite also type-checks the public API of your project.
This can be a good fallback when you’re unable to fully type your implementation
code for every supported Python version.</p>
</div>

<p><a data-type="xref" href="#example_typing_nox_mypy_full">Example 10-6</a> extends the Nox session to type-check your test
suite. Install your test dependencies, so mypy has access to type information
for pytest and friends.</p>
<div id="example_typing_nox_mypy_full" data-type="example">
<h5><span class="label">Example 10-6. </span>A Nox session for type checking with mypy</h5>

<pre data-type="programlisting" data-code-language="python"><code class="n">nox</code><code class="o">.</code><code class="n">options</code><code class="o">.</code><code class="n">sessions</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"tests"</code><code class="p">,</code> <code class="s2">"lint"</code><code class="p">,</code> <code class="s2">"mypy"</code><code class="p">]</code>

<code class="nd">@nox</code><code class="o">.</code><code class="n">session</code><code class="p">(</code><code class="n">python</code><code class="o">=</code><code class="p">[</code><code class="s2">"3.12"</code><code class="p">,</code> <code class="s2">"3.11"</code><code class="p">,</code> <code class="s2">"3.10"</code><code class="p">])</code>
<code class="k">def</code> <code class="nf">mypy</code><code class="p">(</code><code class="n">session</code><code class="p">:</code> <code class="n">nox</code><code class="o">.</code><code class="n">Session</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="kc">None</code><code class="p">:</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">".[typing,tests]"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"mypy"</code><code class="p">,</code> <code class="s2">"src"</code><code class="p">,</code> <code class="s2">"tests"</code><code class="p">)</code></pre></div>

<p>The test suite imports your package from the environment. The type checker
therefore expects your package to distribute type information. Add an empty
<em>py.test</em> marker file to your import package, next to the <code>__init__</code> and
<code>__main__</code> modules (see <a data-type="xref" href="#section_typing_distributing">“Distributing Types with Python Packages”</a>).</p>

<p>There isn’t anything inherently special about typing a test suite. Recent
versions of pytest come with high-quality type annotations. These help when your
tests use one of pytest’s built-in fixtures. Many test functions don’t have
arguments and return <code>None</code>. Here’s a slightly more involved example using a
fixture and test from <a data-type="xref" href="ch06.html#chapter_testing">Chapter 6</a>:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">io</code>
<code class="kn">import</code> <code class="nn">pytest</code>
<code class="kn">from</code> <code class="nn">random_wikipedia_article</code> <code class="kn">import</code> <code class="n">Article</code><code class="p">,</code> <code class="n">show</code>

<code class="nd">@pytest</code><code class="o">.</code><code class="n">fixture</code>
<code class="k">def</code> <code class="nf">file</code><code class="p">()</code> <code class="o">-&gt;</code> <code class="n">io</code><code class="o">.</code><code class="n">StringIO</code><code class="p">:</code>
    <code class="k">return</code> <code class="n">io</code><code class="o">.</code><code class="n">StringIO</code><code class="p">()</code>

<code class="k">def</code> <code class="nf">test_final_newline</code><code class="p">(</code><code class="n">article</code><code class="p">:</code> <code class="n">Article</code><code class="p">,</code> <code class="n">file</code><code class="p">:</code> <code class="n">io</code><code class="o">.</code><code class="n">StringIO</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="kc">None</code><code class="p">:</code>
    <code class="n">show</code><code class="p">(</code><code class="n">article</code><code class="p">,</code> <code class="n">file</code><code class="p">)</code>
    <code class="k">assert</code> <code class="n">file</code><code class="o">.</code><code class="n">getvalue</code><code class="p">()</code><code class="o">.</code><code class="n">endswith</code><code class="p">(</code><code class="s2">"</code><code class="se">\n</code><code class="s2">"</code><code class="p">)</code></pre>

<p>Finally, let’s indulge in a bout of self-referentialism and type-check the
<em>noxfile.py</em> (<a data-type="xref" href="#example_typing_nox_mypy_fullest">Example 10-7</a>). You’ll need the <code>nox</code>
package to validate your use of Nox. I’ll use a little trick here: When the
session runs, there’s already a suitable environment with Nox installed—​you’re
in it! Instead of creating another environment with Nox, point mypy to the
existing one using its <code>--python-executable</code> option.</p>
<div id="example_typing_nox_mypy_fullest" data-type="example">
<h5><span class="label">Example 10-7. </span>Type-checking the noxfile.py with mypy</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">sys</code>

<code class="nd">@nox</code><code class="o">.</code><code class="n">session</code><code class="p">(</code><code class="n">python</code><code class="o">=</code><code class="p">[</code><code class="s2">"3.12"</code><code class="p">,</code> <code class="s2">"3.11"</code><code class="p">,</code> <code class="s2">"3.10"</code><code class="p">])</code>
<code class="k">def</code> <code class="nf">mypy</code><code class="p">(</code><code class="n">session</code><code class="p">:</code> <code class="n">nox</code><code class="o">.</code><code class="n">Session</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="kc">None</code><code class="p">:</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">".[typing,tests]"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"mypy"</code><code class="p">,</code> <code class="s2">"src"</code><code class="p">,</code> <code class="s2">"tests"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"mypy"</code><code class="p">,</code> <code class="sa">f</code><code class="s2">"--python-executable=</code><code class="si">{</code><code class="n">sys</code><code class="o">.</code><code class="n">executable</code><code class="si">}</code><code class="s2">"</code><code class="p">,</code> <code class="s2">"noxfile.py"</code><code class="p">)</code></pre></div>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Inspecting Type Annotations at Runtime"><div class="sect1" id="id224">
<h1>Inspecting Type Annotations at Runtime</h1>

<p>Unlike in TypeScript, where static types are only available during compilation,
Python type annotations are also available at runtime. Runtime inspection of
type annotations is the foundation for powerful features, and an ecosystem of
third-party libraries has evolved around its use.</p>

<p>The interpreter stores the type annotations in a special attribute named
<code>__annotations__</code> on the enclosing function, class, or module. Don’t access this
attribute directly, however—​consider it part of Python’s plumbing. Python
deliberately doesn’t shield the attribute from you, but it provides a high-level
interface that’s easy to use correctly: the function
<code>inspect.get_annotations()</code>.</p>

<p>Let’s inspect the type annotations of the <code>Article</code> class from
<a data-type="xref" href="#example_typing_wikipedia">Example 10-4</a>:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <strong>import inspect</strong>
&gt;&gt;&gt; <strong>inspect.get_annotations(Article)</strong>
{'title': &lt;class 'str'&gt;, 'summary': &lt;class 'str'&gt;}
</pre>

<p>Recall that the <code>fetch</code> function instantiates the class like this:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">return</code> <code class="n">Article</code><code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="s2">"title"</code><code class="p">],</code> <code class="n">data</code><code class="p">[</code><code class="s2">"extract"</code><code class="p">])</code></pre>

<p>If you can instantiate an <code>Article</code>, it must have a standard <code>__init__</code> method
that initializes its attributes. (You can convince yourself of this fact by
accessing it in the interactive session.) Where does the method come from?</p>

<p>The Zen of Python<sup><a data-type="noteref" id="id330-marker" href="ch10.html#id330">8</a></sup> says, “Special cases aren’t special
enough to break the rules.” Dataclasses make no exception to this principle:
they’re plain Python classes without any secret sauce. Given that the class
doesn’t define the method itself, there’s only one possible origin for it: the
<code>@dataclass</code> class decorator. In fact, the decorator synthesizes the <code>__init__</code>
method on the fly, along with several other methods, using your type
annotations! Don’t take my word for it, though. In this section, you’re going to
write your own miniature <code>@dataclass</code> decorator.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Don’t use this in production! Use the standard <code>dataclasses</code> module, or better:
the <code>attrs</code> library. Attrs is an actively maintained, industry-strength
implementation with better performance, a clean API, and additional features,
and it directly inspired <code>dataclasses</code>.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Writing a @dataclass Decorator"><div class="sect2" id="id225">
<h2>Writing a @dataclass Decorator</h2>

<p>First of all, be a good typing citizen and think about the signature of the
<code>@dataclass</code> decorator. A class decorator accepts a class and returns it,
usually after transforming it in some way, such as by adding a method. In
Python, classes are objects you can pass around and manipulate to your liking.</p>

<p>The typing language allows you to refer to, say, the <code>str</code> class by writing
<code>type[str]</code>. You can read this aloud as “the type of a string”. (You can’t use
<code>str</code> on its own here. In a type annotation, <code>str</code> just refers to an individual
string.) A class decorator should work for any class object, though—​it should
be generic. Therefore, you’ll use a type variable instead of an actual class
like <code>str</code>:<sup><a data-type="noteref" id="id331-marker" href="ch10.html#id331">9</a></sup></p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">dataclass</code><code class="p">[</code><code class="n">T</code><code class="p">](</code><code class="bp">cls</code><code class="p">:</code> <code class="nb">type</code><code class="p">[</code><code class="n">T</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="nb">type</code><code class="p">[</code><code class="n">T</code><code class="p">]:</code>
    <code class="o">...</code></pre>

<p>Type checkers need one more bit to properly understand your <code>@dataclass</code>
decorator: they need to know which methods you’re adding to the class, and which
instance variables they can expect on objects instantiated from the class.
Traditionally, you had to write a type checker plugin to infuse this knowledge
into the tool. These days, the <code>@dataclass_transform</code> marker from the standard
library lets you inform type checkers that the class exhibits dataclass-like
behavior.</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">dataclass_transform</code>

<code class="nd">@dataclass_transform</code><code class="p">()</code>
<code class="k">def</code> <code class="nf">dataclass</code><code class="p">[</code><code class="n">T</code><code class="p">](</code><code class="bp">cls</code><code class="p">:</code> <code class="nb">type</code><code class="p">[</code><code class="n">T</code><code class="p">])</code> <code class="o">-&gt;</code> <code class="nb">type</code><code class="p">[</code><code class="n">T</code><code class="p">]:</code>
    <code class="o">...</code></pre>

<p>With the function signature out of the way, let’s think about how to implement
the decorator. You can break this down into two steps. First, you’ll need to
assemble a string with the source code of the <code>__init__</code> method, using the type
annotations on the dataclass. Second, you can use Python’s built-in <code>exec</code>
function to evaluate that source code in the running program.</p>

<p>You’ve likely written a few <code>__init__</code> methods in your career—​they’re pure
boilerplate. For the <code>Article</code> class, the method would look like this:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">title</code><code class="p">:</code> <code class="nb">str</code><code class="p">,</code> <code class="n">summary</code><code class="p">:</code> <code class="nb">str</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="kc">None</code><code class="p">:</code>
    <code class="bp">self</code><code class="o">.</code><code class="n">title</code> <code class="o">=</code> <code class="n">title</code>
    <code class="bp">self</code><code class="o">.</code><code class="n">summary</code> <code class="o">=</code> <code class="n">summary</code></pre>

<p>Let’s tackle the first step: assembling the source code from the annotations
(<a data-type="xref" href="#example_typing_dataclass_init">Example 10-8</a>). Don’t fret too much about the parameter
types at this point—​just use the <code>__name__</code> attribute of each parameter type,
which will work in many cases.</p>
<div id="example_typing_dataclass_init" data-type="example">
<h5><span class="label">Example 10-8. </span></h5>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code><code> </code><code class="nf">build_dataclass_init</code><code class="p">[</code><code class="n">T</code><code class="p">]</code><code class="p">(</code><code class="bp">cls</code><code class="p">:</code><code> </code><code class="nb">type</code><code class="p">[</code><code class="n">T</code><code class="p">]</code><code class="p">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><code class="nb">str</code><code class="p">:</code><code> </code><a class="co" id="co_using_types_for_safety_and_inspection_CO3-1" href="#callout_using_types_for_safety_and_inspection_CO3-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>    </code><code class="n">annotations</code><code> </code><code class="o">=</code><code> </code><code class="n">inspect</code><code class="o">.</code><code class="n">get_annotations</code><code class="p">(</code><code class="bp">cls</code><code class="p">)</code><code> </code><a class="co" id="co_using_types_for_safety_and_inspection_CO3-2" href="#callout_using_types_for_safety_and_inspection_CO3-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>
</code><code>    </code><code class="n">args</code><code class="p">:</code><code> </code><code class="nb">list</code><code class="p">[</code><code class="nb">str</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="s2">"</code><code class="s2">self</code><code class="s2">"</code><code class="p">]</code><code> </code><a class="co" id="co_using_types_for_safety_and_inspection_CO3-3" href="#callout_using_types_for_safety_and_inspection_CO3-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>    </code><code class="n">body</code><code class="p">:</code><code> </code><code class="nb">list</code><code class="p">[</code><code class="nb">str</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="p">]</code><code>
</code><code>
</code><code>    </code><code class="k">for</code><code> </code><code class="n">name</code><code class="p">,</code><code> </code><code class="nb">type</code><code> </code><code class="ow">in</code><code> </code><code class="n">annotations</code><code class="o">.</code><code class="n">items</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="n">args</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="sa">f</code><code class="s2">"</code><code class="si">{</code><code class="n">name</code><code class="si">}</code><code class="s2">: </code><code class="si">{</code><code class="nb">type</code><code class="o">.</code><code class="vm">__name__</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code><code>
</code><code>        </code><code class="n">body</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="sa">f</code><code class="s2">"</code><code class="s2">    self.</code><code class="si">{</code><code class="n">name</code><code class="si">}</code><code class="s2"> = </code><code class="si">{</code><code class="n">name</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code><code>
</code><code>
</code><code>    </code><code class="k">return</code><code> </code><code class="s2">"</code><code class="s2">def __init__(</code><code class="si">{}</code><code class="s2">) -&gt; None:</code><code class="se">\n</code><code class="si">{}</code><code class="s2">"</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code>
</code><code>        </code><code class="s1">'</code><code class="s1">, </code><code class="s1">'</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">args</code><code class="p">)</code><code class="p">,</code><code>
</code><code>        </code><code class="s1">'</code><code class="se">\n</code><code class="s1">'</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">body</code><code class="p">)</code><code class="p">,</code><code>
</code><code>    </code><code class="p">)</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_using_types_for_safety_and_inspection_CO3-1" href="#co_using_types_for_safety_and_inspection_CO3-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Use a type variable <code>T</code> in the signature to make this generic for any class.</p></dd>
<dt><a class="co" id="callout_using_types_for_safety_and_inspection_CO3-2" href="#co_using_types_for_safety_and_inspection_CO3-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Retrieve the annotations of the class as a dictionary of names and types.</p></dd>
<dt><a class="co" id="callout_using_types_for_safety_and_inspection_CO3-3" href="#co_using_types_for_safety_and_inspection_CO3-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The variable annotation is only required for <code>body</code>. Most type checkers won’t infer that <code>body</code> contains strings because it’s an empty list at this point. I’ve annotated both variables for symmetry.</p></dd>
</dl>

<p>You can now pass the source code to the <code>exec</code> built-in. Apart from the source
code, this function accepts dictionaries for the global and local variables.</p>

<p>The canonical way to retrieve the global variables is the <code>globals()</code> built-in.
However, you need to evaluate the source code in the context of the module where
the class is defined, rather than the context of your decorator. Python stores
the name of that module in the <code>__module__</code> attribute of the class, so you can
look up the module object in <code>sys.modules</code> and retrieve the variables from its
<code>__dict__</code> attribute (see <a data-type="xref" href="ch02.html#section_environments_module_cache">“The Module Cache”</a>):</p>

<pre data-type="programlisting" data-code-language="python"><code class="nb">globals</code> <code class="o">=</code> <code class="n">sys</code><code class="o">.</code><code class="n">modules</code><code class="p">[</code><code class="bp">cls</code><code class="o">.</code><code class="vm">__module__</code><code class="p">]</code><code class="o">.</code><code class="vm">__dict__</code></pre>

<p>For the local variables, you can pass an empty dictionary—​this is where <code>exec</code>
will place the method definition. All that’s left is to copy the method from the
locals dictionary into the class object and return the class. Without further
ado, <a data-type="xref" href="#example_typing_dataclass_decorator">Example 10-9</a> shows the entire decorator.</p>
<div id="example_typing_dataclass_decorator" data-type="example">
<h5><span class="label">Example 10-9. </span>Your own <code>@dataclass</code> decorator</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@dataclass_transform</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="k">def</code><code> </code><code class="nf">dataclass</code><code class="p">[</code><code class="n">T</code><code class="p">]</code><code class="p">(</code><code class="bp">cls</code><code class="p">:</code><code> </code><code class="nb">type</code><code class="p">[</code><code class="n">T</code><code class="p">]</code><code class="p">)</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><code class="nb">type</code><code class="p">[</code><code class="n">T</code><code class="p">]</code><code class="p">:</code><code>
</code><code>    </code><code class="n">sourcecode</code><code> </code><code class="o">=</code><code> </code><code class="n">build_dataclass_init</code><code class="p">(</code><code class="bp">cls</code><code class="p">)</code><code>
</code><code>
</code><code>    </code><code class="nb">globals</code><code> </code><code class="o">=</code><code> </code><code class="n">sys</code><code class="o">.</code><code class="n">modules</code><code class="p">[</code><code class="bp">cls</code><code class="o">.</code><code class="vm">__module__</code><code class="p">]</code><code class="o">.</code><code class="vm">__dict__</code><code> </code><a class="co" id="co_using_types_for_safety_and_inspection_CO4-1" href="#callout_using_types_for_safety_and_inspection_CO4-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>    </code><code class="nb">locals</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="p">}</code><code>
</code><code>    </code><code class="n">exec</code><code class="p">(</code><code class="n">sourcecode</code><code class="p">,</code><code> </code><code class="nb">globals</code><code class="p">,</code><code> </code><code class="nb">locals</code><code class="p">)</code><code> </code><a class="co" id="co_using_types_for_safety_and_inspection_CO4-2" href="#callout_using_types_for_safety_and_inspection_CO4-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>
</code><code>    </code><code class="bp">cls</code><code class="o">.</code><code class="fm">__init__</code><code> </code><code class="o">=</code><code> </code><code class="nb">locals</code><code class="p">[</code><code class="s2">"</code><code class="s2">__init__</code><code class="s2">"</code><code class="p">]</code><code> </code><a class="co" id="co_using_types_for_safety_and_inspection_CO4-3" href="#callout_using_types_for_safety_and_inspection_CO4-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>    </code><code class="k">return</code><code> </code><code class="bp">cls</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_using_types_for_safety_and_inspection_CO4-1" href="#co_using_types_for_safety_and_inspection_CO4-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Retrieve the global variables from the module that defines the class.</p></dd>
<dt><a class="co" id="callout_using_types_for_safety_and_inspection_CO4-2" href="#co_using_types_for_safety_and_inspection_CO4-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>This is where the magic happens: let the interpreter compile the generated code on the fly.</p></dd>
<dt><a class="co" id="callout_using_types_for_safety_and_inspection_CO4-3" href="#co_using_types_for_safety_and_inspection_CO4-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Et voilà—the class now has an <code>__init__</code> method.</p></dd>
</dl>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Runtime Type Checking"><div class="sect2" id="id226">
<h2>Runtime Type Checking</h2>

<p>There’s more you can do with types at runtime besides generating class
boilerplate. One important example is runtime type checking. To see how useful
this technique is, let’s take another look at the <code>fetch</code> function:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">fetch</code><code class="p">(</code><code class="n">url</code><code class="p">:</code> <code class="nb">str</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Article</code><code class="p">:</code>
    <code class="k">with</code> <code class="n">urllib</code><code class="o">.</code><code class="n">request</code><code class="o">.</code><code class="n">urlopen</code><code class="p">(</code><code class="n">url</code><code class="p">)</code> <code class="k">as</code> <code class="n">response</code><code class="p">:</code>
        <code class="n">data</code> <code class="o">=</code> <code class="n">json</code><code class="o">.</code><code class="n">load</code><code class="p">(</code><code class="n">response</code><code class="p">)</code>
    <code class="k">return</code> <code class="n">Article</code><code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="s2">"title"</code><code class="p">],</code> <code class="n">data</code><code class="p">[</code><code class="s2">"extract"</code><code class="p">])</code></pre>

<p>If you’ve paid close attention, you may have noticed that <code>fetch</code> is not
type-safe. Nothing guarantees that the Wikipedia API will return a JSON payload
of the expected shape. You might object that Wikipedia’s
<a href="https://en.wikipedia.org/api/rest_v1/">OpenAPI specification</a> tells us exactly
which data shape to expect from the endpoint. But don’t base your static types
on assumptions about external systems—​unless you’re happy with your program
crashing when a bug or API change breaks those assumptions.</p>

<p>As you may have guessed, mypy silently passes over this issue, because
<code>json.load</code> returns <code>Any</code>. How can we make the function type-safe? As a first
step, let’s replace <code>Any</code> with the <code>JSON</code> type you defined in
<a data-type="xref" href="#section_typing_aliases">“Type Aliases”</a>:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">fetch</code><code class="p">(</code><code class="n">url</code><code class="p">:</code> <code class="nb">str</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Article</code><code class="p">:</code>
    <code class="k">with</code> <code class="n">urllib</code><code class="o">.</code><code class="n">request</code><code class="o">.</code><code class="n">urlopen</code><code class="p">(</code><code class="n">url</code><code class="p">)</code> <code class="k">as</code> <code class="n">response</code><code class="p">:</code>
        <code class="n">data</code><code class="p">:</code> <code class="n">JSON</code> <code class="o">=</code> <code class="n">json</code><code class="o">.</code><code class="n">load</code><code class="p">(</code><code class="n">response</code><code class="p">)</code>
    <code class="k">return</code> <code class="n">Article</code><code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="s2">"title"</code><code class="p">],</code> <code class="n">data</code><code class="p">[</code><code class="s2">"extract"</code><code class="p">])</code></pre>

<p>We haven’t fixed the bug, but at least mypy gives us diagnostics now (edited for
brevity):</p>
<pre data-type="programlisting">$ <strong>py -m mypy src</strong>
error: Value of type "..." is not indexable
error: No overload variant of "__getitem__" matches argument type "str"
error: Argument 1 to "Article" has incompatible type "..."; expected "str"
error: Invalid index type "str" for "JSON"; expected type "..."
error: Argument 2 to "Article" has incompatible type "..."; expected "str"
Found 5 errors in 1 file (checked 1 source file)
</pre>

<p>Mypy’s diagnostics boil down to two separate issues in the function. First, the
code indexes <code>data</code> without verifying that it’s a dictionary. Second, it passes
the results to <code>Article</code> without making sure they’re strings.</p>

<p>Let’s check the type of <code>data</code> then—​it has to be a dictionary with strings
under the <code>title</code> and <code>extract</code> keys. You can express this concisely using
structural pattern matching:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">fetch</code><code class="p">(</code><code class="n">url</code><code class="p">:</code> <code class="nb">str</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Article</code><code class="p">:</code>
    <code class="k">with</code> <code class="n">urllib</code><code class="o">.</code><code class="n">request</code><code class="o">.</code><code class="n">urlopen</code><code class="p">(</code><code class="n">url</code><code class="p">)</code> <code class="k">as</code> <code class="n">response</code><code class="p">:</code>
        <code class="n">data</code><code class="p">:</code> <code class="n">JSON</code> <code class="o">=</code> <code class="n">json</code><code class="o">.</code><code class="n">load</code><code class="p">(</code><code class="n">response</code><code class="p">)</code>

    <code class="k">match</code> <code class="n">data</code><code class="p">:</code>
        <code class="k">case</code> <code class="p">{</code><code class="s2">"title"</code><code class="p">:</code> <code class="nb">str</code><code class="p">(</code><code class="n">title</code><code class="p">),</code> <code class="s2">"extract"</code><code class="p">:</code> <code class="nb">str</code><code class="p">(</code><code class="n">extract</code><code class="p">)}:</code>
            <code class="k">return</code> <code class="n">Article</code><code class="p">(</code><code class="n">title</code><code class="p">,</code> <code class="n">extract</code><code class="p">)</code>

    <code class="k">raise</code> <code class="ne">ValueError</code><code class="p">(</code><code class="s2">"invalid response"</code><code class="p">)</code></pre>

<p>Thanks to type narrowing, the runtime type checks also appease mypy—​in a way,
bridging the worlds of runtime and static type checking. If you’d like to see
the runtime type check in action, you can use the test harness from
<a data-type="xref" href="ch06.html#chapter_testing">Chapter 6</a> and modify the HTTP server to return an unexpected response,
such as <code>null</code> or <code>"teapot"</code>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Serialization and Deserialization with cattrs"><div class="sect2" id="id227">
<h2>Serialization and Deserialization with cattrs</h2>

<p>The function is type-safe now, but can we do better than this? The validation
code duplicates the structure of the <code>Article</code> class—​you shouldn’t need to
spell out the types of its fields again. If your application must validate more
than one input, the boilerplate can hurt readability and maintainability. It
should be possible to assemble articles from JSON objects using only the
original type annotations—​and it is.</p>

<p>The <code>cattrs</code> library provides flexible and type-safe serialization and
deserialization for type-annotated classes such as dataclasses and attrs. It’s
delightfully simple to use—​you pass the JSON object and the expected type to
its <code>structure</code> function and get the assembled object back.<sup><a data-type="noteref" id="id332-marker" href="ch10.html#id332">10</a></sup> There’s also a
<code>destructure</code> function for transforming objects into primitive types for
serialization.</p>

<p>For this last iteration on the Wikipedia example, add <code>cattrs</code> to your
dependencies:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">dependencies</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"cattrs&gt;=23.2.3"</code><code class="p">]</code><code class="w"/></pre>

<p>Replace the <code>fetch</code> function with the three-liner below (don’t run this yet,
we’ll get to the final version in a second):</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">cattrs</code>

<code class="k">def</code> <code class="nf">fetch</code><code class="p">(</code><code class="n">url</code><code class="p">:</code> <code class="nb">str</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Article</code><code class="p">:</code>
    <code class="k">with</code> <code class="n">urllib</code><code class="o">.</code><code class="n">request</code><code class="o">.</code><code class="n">urlopen</code><code class="p">(</code><code class="n">url</code><code class="p">)</code> <code class="k">as</code> <code class="n">response</code><code class="p">:</code>
        <code class="n">data</code><code class="p">:</code> <code class="n">JSON</code> <code class="o">=</code> <code class="n">json</code><code class="o">.</code><code class="n">load</code><code class="p">(</code><code class="n">response</code><code class="p">)</code>
    <code class="k">return</code> <code class="n">cattrs</code><code class="o">.</code><code class="n">structure</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">Article</code><code class="p">)</code></pre>

<p>Deserializing <code>Article</code> objects is now entirely determined by their type
annotations. Besides being clear and concise, this version of the code is
type-safe, thanks to the internal runtime checks in <code>cattrs</code>.</p>

<p>However, you still need to take care of one complication. The <code>summary</code>
attribute doesn’t match the name of its corresponding JSON field, <code>extract</code>.
Fortunately, <code>cattrs</code> is flexible enough to let you create a custom converter
that renames the field on the fly:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">cattrs.gen</code>

<code class="n">converter</code> <code class="o">=</code> <code class="n">cattrs</code><code class="o">.</code><code class="n">Converter</code><code class="p">()</code>
<code class="n">converter</code><code class="o">.</code><code class="n">register_structure_hook</code><code class="p">(</code>
    <code class="n">cattrs</code><code class="o">.</code><code class="n">gen</code><code class="o">.</code><code class="n">make_dict_structure_fn</code><code class="p">(</code>
        <code class="n">Article</code><code class="p">,</code>
        <code class="n">converter</code><code class="p">,</code>
        <code class="n">summary</code><code class="o">=</code><code class="n">override</code><code class="p">(</code><code class="n">rename</code><code class="o">=</code><code class="s2">"extract"</code><code class="p">),</code>
    <code class="p">)</code>
<code class="p">)</code></pre>

<p>Finally, use the custom converter in the <code>fetch</code> function:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">fetch</code><code class="p">(</code><code class="n">url</code><code class="p">:</code> <code class="nb">str</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Article</code><code class="p">:</code>
    <code class="k">with</code> <code class="n">urllib</code><code class="o">.</code><code class="n">request</code><code class="o">.</code><code class="n">urlopen</code><code class="p">(</code><code class="n">url</code><code class="p">)</code> <code class="k">as</code> <code class="n">response</code><code class="p">:</code>
        <code class="n">data</code><code class="p">:</code> <code class="n">JSON</code> <code class="o">=</code> <code class="n">json</code><code class="o">.</code><code class="n">load</code><code class="p">(</code><code class="n">response</code><code class="p">)</code>
    <code class="k">return</code> <code class="n">converter</code><code class="o">.</code><code class="n">structure</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">Article</code><code class="p">)</code></pre>

<p>From a software-architecture perspective, the <code>cattrs</code> library has advantages
over other popular data-validation libraries. It keeps serialization and
deserialization separate from your <em>models</em>—the classes at the core of your
application that express its problem domain and provide all the business logic.
Decoupling the domain model from the data layer gives you architectural
flexibility and improves the testability of your code.<sup><a data-type="noteref" id="id333-marker" href="ch10.html#id333">11</a></sup></p>

<p>There are also practical advantages to the <code>cattrs</code> approach. You can serialize
the same object in different ways if you need to. It’s not intrusive—​it doesn’t
add methods to your objects. And it works with all kinds of types: dataclasses,
attrs-classes, named tuples, typed dicts, and even plain type annotations like
<code>tuple[str, int]</code>.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Runtime Type Checking with Typeguard"><div class="sect1" id="id228">
<h1>Runtime Type Checking with Typeguard</h1>

<p>Do you find the type unsafety of the original <code>fetch</code> function disconcerting?
The issue was easy enough to spot in a short script. But how do you find similar
issues in a large codebase before they cause problems? After all, you ran mypy
in strict mode, and it remained silent.</p>

<p>Static type checkers won’t catch every type-related error. In this case, gradual
typing obscured the issue—​specifically, <code>json.load</code> returning <code>Any</code>. Real-world
code has plenty of situations like this. A library outside of your control might
have overly permissive type annotations—​or none at all. A bug in your
persistence layer might load corrupted objects from disk. Maybe mypy would have
caught the issue, but you silenced type errors for the module in question.</p>

<p>Typeguard is a third-party library and pytest plugin for runtime type checking.
It can be an invaluable tool for verifying the type safety of your code in
situations that elude static type checkers, such as:</p>
<dl>
<dt>Dynamic code</dt>
<dd>
<p>Python code can be highly dynamic, forcing type annotations to be permissive.
Your assumptions about the code may be at odds with the concrete types you end
up with at runtime.</p>
</dd>
<dt>External systems</dt>
<dd>
<p>Most real-world code eventually crosses the boundary to external systems such
as a web service, a database, or the file system. Data you receive from these
systems may not have the shape you expect it to. Its format can also
unexpectedly change from one day to another.</p>
</dd>
<dt>Third-party libraries</dt>
<dd>
<p>Some of your Python dependencies may not have type annotations, or their type
annotations might be incomplete or overly permissive.</p>
</dd>
</dl>

<p>Add Typeguard to your dependencies in <em>pyproject.toml</em>:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">dependencies</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"typeguard&gt;=4.1.5"</code><code class="p">]</code><code class="w"/></pre>

<p>Typeguard comes with a function called <code>check_type</code>, which you can think of as
<code>isinstance</code> for arbitrary type annotations. Those annotations can be quite
simple—​say, a list of floating-point numbers:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">typeguard</code> <code class="kn">import</code> <code class="n">check_type</code>

<code class="n">numbers</code> <code class="o">=</code> <code class="n">check_type</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="nb">list</code><code class="p">[</code><code class="nb">float</code><code class="p">])</code></pre>

<p>The checks can also be more elaborate. For example, you can use the <code>TypedDict</code>
construct to specify the precise shape of a JSON object you’ve fetched from some
external service, such as the keys you expect to find and which types their
associated values should have:<sup><a data-type="noteref" id="id334-marker" href="ch10.html#id334">12</a></sup></p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">typing</code> <code class="kn">import</code> <code class="n">Any</code><code class="p">,</code> <code class="n">TypedDict</code>

<code class="k">class</code> <code class="nc">Person</code><code class="p">(</code><code class="n">TypedDict</code><code class="p">):</code>
    <code class="n">name</code><code class="p">:</code> <code class="nb">str</code>
    <code class="n">age</code><code class="p">:</code> <code class="nb">int</code>

    <code class="nd">@classmethod</code>
    <code class="k">def</code> <code class="nf">check</code><code class="p">(</code><code class="bp">cls</code><code class="p">,</code> <code class="n">data</code><code class="p">:</code> <code class="n">Any</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">Person</code><code class="p">:</code>
        <code class="k">return</code> <code class="n">check_type</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">Person</code><code class="p">)</code></pre>

<p>Here’s how you might use it:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <strong>Person.check({"name": "Alice", "age": 12})</strong>
{'name': 'Alice', 'age': 12}
&gt;&gt;&gt; <strong>Person.check({"name": "Carol"})</strong>
typeguard.TypeCheckError: dict is missing required key(s): "age"
</pre>

<p>Typeguard also comes with a decorator named <code>@typechecked</code>. When used as a
function decorator, it instruments the function to check the types of its
arguments and return value. When used as a class decorator, it instruments every
method in this way. For example, you could slap this decorator onto a function
that reads <code>Person</code> records from a JSON file:</p>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@typechecked</code>
<code class="k">def</code> <code class="nf">load_people</code><code class="p">(</code><code class="n">path</code><code class="p">:</code> <code class="n">Path</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="nb">list</code><code class="p">[</code><code class="n">Person</code><code class="p">]:</code>
    <code class="k">with</code> <code class="n">path</code><code class="o">.</code><code class="n">open</code><code class="p">()</code> <code class="k">as</code> <code class="n">io</code><code class="p">:</code>
        <code class="k">return</code> <code class="n">json</code><code class="o">.</code><code class="n">load</code><code class="p">(</code><code class="n">io</code><code class="p">)</code></pre>

<p>By default, Typeguard only checks the first item in a collection to reduce
runtime overhead. You can change this strategy to check all items in the global
configuration object:<sup><a data-type="noteref" id="id335-marker" href="ch10.html#id335">13</a></sup></p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">typeguard</code>

<code class="n">typeguard</code><code class="o">.</code><code class="n">config</code><code class="o">.</code><code class="n">collection_check_strategy</code> <code class="o">=</code> <code class="n">CollectionCheckStrategy</code><code class="o">.</code><code class="n">ALL_ITEMS</code></pre>

<p>Finally, Typeguard comes with an import hook that instruments all functions and
methods in a module on import. While you can use the import hook explicitly,
arguably its greatest use case involves enabling Typeguard as a pytest plugin
while running your test suite. Let’s add a Nox session that runs the test suite
with runtime type checking:</p>
<div id="example_typing_nox_typeguard" data-type="example">
<h5><span class="label">Example 10-10. </span>Nox session for runtime type checking with Typeguard</h5>

<pre data-type="programlisting" data-code-language="python"><code class="n">package</code> <code class="o">=</code> <code class="s2">"random_wikipedia_article"</code>

<code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="k">def</code> <code class="nf">typeguard</code><code class="p">(</code><code class="n">session</code><code class="p">:</code> <code class="n">nox</code><code class="o">.</code><code class="n">Session</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="kc">None</code><code class="p">:</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">".[tests]"</code><code class="p">,</code> <code class="s2">"typeguard"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"pytest"</code><code class="p">,</code> <code class="sa">f</code><code class="s2">"--typeguard-packages=</code><code class="si">{</code><code class="n">package</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code></pre></div>

<p>Running Typeguard as a pytest plugin lets you track down type-safety bugs in a
large codebase—​provided it has good test coverage. If it doesn’t, consider
enabling runtime type checking for individual functions or modules in
production. Be careful here: Look for false positives from the type checks, and
measure their runtime overhead.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="id229">
<h1>Summary</h1>

<p>Type annotations let you specify the types of variables and functions in your
source code. You can use built-in types and user-defined classes, as well as
many higher-level constructs, such as union types, <code>Any</code> for gradual typing,
generics, and protocols. Stringized annotations and <code>Self</code> are useful for
handling forward references. The <code>type</code> keyword lets you introduce type aliases.</p>

<p>Static type checkers like mypy leverage type annotations and type inference to
verify the type safety of your program without running it. Mypy facilitates
gradual typing by defaulting to <code>Any</code> for unannotated code. You can and should
enable strict mode where possible to allow for more thorough checks. Run mypy as
part of your mandatory checks, using a Nox session for automation.</p>

<p>Type annotations are available for inspection at runtime. They’re the foundation
for powerful features such as class generation with <code>dataclasses</code> or the <code>attrs</code>
library, and automatic serialization and deserialization with the help of the
<code>cattrs</code> library. The runtime type checker Typeguard allows you to instrument
your code to verify the types of function arguments and return values at
runtime. You can enable it as a pytest plugin while running your test suite.</p>

<p>There’s a widespread sentiment that type annotations are for the sprawling
codebases found at giant tech corporations—​and not worth the trouble for
reasonably sized projects, let alone the quick script you hacked together
yesterday afternoon. I disagree. Type annotations make your programs easier to
understand, debug, and maintain, no matter how large they are or how many people
work on them.</p>

<p>Try using types for any Python code you write. Ideally, configure your editor to
run a type checker in the background, if it doesn’t already come with typing
support out-of-the-box. If you feel that types get in your way, consider using
gradual typing—but also consider whether there might be a simpler way to write
your code that gives you type safety for free. If your project has any mandatory
checks, type checking should be a part of them.</p>

<p>With this chapter, the book comes to a close.</p>

<p>Throughout the book, you’ve automated checks and tasks for your project using
Nox. Nox sessions allow you and other contributors to run checks early and
repeatedly during local development, in the same way they’d run on a CI server.
For reference, here’s a listing of the Nox sessions you’ve defined:</p>

<ul>
<li>
<p>Building packages (<a data-type="xref" href="ch08.html#example_nox_build">Example 8-2</a>)</p>
</li>
<li>
<p>Running tests across multiple Python versions (<a data-type="xref" href="ch08.html#example_nox_python">Example 8-5</a>)</p>
</li>
<li>
<p>Running tests with code coverage (<a data-type="xref" href="ch08.html#example_nox_coverage_notify">Example 8-9</a>)</p>
</li>
<li>
<p>Measuring coverage in subprocesses (<a data-type="xref" href="ch08.html#example_nox_coverage_subprocess">Example 8-11</a>)</p>
</li>
<li>
<p>Generating the coverage report (<a data-type="xref" href="ch08.html#example_nox_coverage_report">Example 8-8</a>)</p>
</li>
<li>
<p>Locking the dependencies with uv (<a data-type="xref" href="ch08.html#example_nox_constraints">Example 8-14</a>)</p>
</li>
<li>
<p>Installing dependencies with Poetry (<a data-type="xref" href="ch08.html#example_nox_poetry_install">Example 8-19</a>)</p>
</li>
<li>
<p>Linting with pre-commit (<a data-type="xref" href="ch09.html#example_linting_nox">Example 9-6</a>)</p>
</li>
<li>
<p>Static type checking with mypy (<a data-type="xref" href="#example_typing_nox_mypy_fullest">Example 10-7</a>)</p>
</li>
<li>
<p>Runtime type checking with Typeguard (<a data-type="xref" href="#example_typing_nox_typeguard">Example 10-10</a>)</p>
</li>
</ul>

<p>There’s a fundamental philosophy behind this approach, dubbed “Shift Left.”
Consider the software development lifecycle on a timeline extending from left to
right—​all the way from writing a line of code to running the program in
production. (If you’re Agile minded, picture the timeline as a circle where
feedback from production flows back into planning and local development.)</p>

<p>The earlier you identify a software defect, the smaller the cost of fixing it.
In the best case, you discover issues while they’re still in your editor—​their
cost is near zero. In the worst case, you ship the bug to production. Before
even starting to track down the issue in the code, you may have to roll back the
bad deployment and contain its impact. For this reason, shift all your checks as
far to the left on that imaginary timeline as possible.</p>

<p>(Run checks towards the right of the timeline, as well. End-to-end tests against
your production environments are invaluable for increasing confidence that your
systems are operating as expected.)</p>

<p>Mandatory checks in CI are the main gatekeeper: they decide which code changes
make it into the main branch and ship to production. But don’t wait for CI. Run
checks locally, as early as possible. Automating checks with Nox and pre-commit
helps achieve this goal.</p>

<p>Integrate linters and type checkers with your editor, as well! Alas, people
haven’t yet agreed on a single editor that everybody should use. Tools like Nox
give you a common baseline for local development in your teams.</p>

<p>Automation also greatly reduces the cost of project maintenance. Contributors
run a single command, such as <code>nox</code>, as an entrypoint to the mandatory checks.
Other chores, like refreshing lock files or generating documentation, likewise
only require simple commands. By encoding each process, you eliminate human
error and create a basis for constant improvement.</p>

<p>Thank you for reading this book! While the book ends here, your journey through
the ever-shifting landscape of modern Python developer tooling continues.
Hopefully, the lessons from this book will remain valid and helpful, as Python
continues to reinvent itself.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="id323"><sup><a href="ch10.html#id323-marker">1</a></sup> Jukka Lehtosalo, <a href="https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python">“Our journey to type checking 4 million lines of Python,”</a> September 5, 2019.</p><p data-type="footnote" id="id324"><sup><a href="ch10.html#id324-marker">2</a></sup> <a href="https://typing.readthedocs.io/en/latest/spec/index.html">“Specification for the Python type system.”</a> Last accessed: January 22, 2024.</p><p data-type="footnote" id="id325"><sup><a href="ch10.html#id325-marker">3</a></sup> Tin Tvrtković: <a href="https://threeofwands.com/python-is-two-languages-now-and-thats-actually-great/">“Python is two languages now, and that’s actually great,”</a> February 27, 2023.</p><p data-type="footnote" id="id326"><sup><a href="ch10.html#id326-marker">4</a></sup> In a future Python version, this will work out of the box. See Larry Hastings: <a href="https://peps.python.org/pep-0649/">“PEP 649 – Deferred Evaluation Of Annotations Using Descriptors”</a>, January 11, 2021.</p><p data-type="footnote" id="id327"><sup><a href="ch10.html#id327-marker">5</a></sup> If you see an error message like “PEP 695 type aliases are not yet supported,” just omit the <code>type</code> keyword for now. The type checker still interprets the assignment as a type alias. If you want to be more explicit, you can use the <code>typing.TypeAlias</code> annotation from Python 3.10 upwards.</p><p data-type="footnote" id="id328"><sup><a href="ch10.html#id328-marker">6</a></sup> For brevity, I’ve removed error codes and leading directories from mypy’s output.</p><p data-type="footnote" id="id329"><sup><a href="ch10.html#id329-marker">7</a></sup> As of this writing, the upcoming release of <code>factory-boy</code> is expected to distribute types inline.</p><p data-type="footnote" id="id330"><sup><a href="ch10.html#id330-marker">8</a></sup> Tim Peters: <a href="https://peps.python.org/pep-0387/">“PEP 20 – The Zen of Python,”</a> August 19, 2004.</p><p data-type="footnote" id="id331"><sup><a href="ch10.html#id331-marker">9</a></sup> As of this writing, mypy hasn’t yet added support for PEP 695 type variables. If you get a mypy error, type-check the code in the Pyright playground instead or use the older <code>TypeVar</code> syntax.</p><p data-type="footnote" id="id332"><sup><a href="ch10.html#id332-marker">10</a></sup> In fact, the <code>cattrs</code> library is format-agnostic, so it doesn’t matter if you read the raw object from JSON, YAML, TOML, or another data format.</p><p data-type="footnote" id="id333"><sup><a href="ch10.html#id333-marker">11</a></sup> If you’re interested in this topic, you should absolutely read <a href="https://learning.oreilly.com/library/view/architecture-patterns-with/9781492052197/"><em>Architecture Patterns in Python</em></a>, by Harry Percival and Bob Gregory (Sebastopol: O’Reilly, 2020).</p><p data-type="footnote" id="id334"><sup><a href="ch10.html#id334-marker">12</a></sup> This is less useful than it may seem. <code>TypedDict</code> classes must list every field even if you only use a subset.</p><p data-type="footnote" id="id335"><sup><a href="ch10.html#id335-marker">13</a></sup> If you call <code>check_type</code> directly, you’ll need to pass the <code>collection_check_strategy</code> argument explicitly.</p></div></div></section></div>
</div>


<div id="book-content">
<div id="sbo-rt-content"><section data-type="colophon" epub:type="colophon" class="abouttheauthor" data-pdf-bookmark="About the Author"><div class="colophon" id="id36">
  <h1>About the Author</h1>
  <p><strong>Claudio Jolowicz</strong> is a senior software engineer at
  Cloudflare with nearly two decades of industry experience in Python and C++
  and an open source maintainer active in the Python community. He is the author
  of the Hypermodern Python blog and project template, and co-maintainer of Nox,
  a Python tool for test automation. In former lives, Claudio has worked as a
  legal scholar and as a musician touring from Scandinavia to West Africa. Get
  in touch with him on Mastodon: @cjolowicz@fosstodon.org</p>
</div></section></div>
</div>


<div id="book-content">
<div id="sbo-rt-content"><section data-type="colophon" epub:type="colophon" data-pdf-bookmark="Colophon"><div class="colophon" id="colophon">
  <h1>Colophon</h1>

<p>The animal on the cover of <em>Hypermodern Python Tooling</em> is the Peruvian sheartail (<em>Thaumastura cora</em>), a member of the <em>Mellisugini</em> tribe of bee hummingbirds.</p>

<p>The males of most species in this tribe have specialized tail feathers, often used to produce sounds during courtship display. As shown on the cover of this book, male Peruvian sheartails indeed sport very long, black and white forked tails. The upperparts of both sexes are a luminous green, while males’ throat feathers are a lustrous purple to magenta.</p>

<p>The Peruvian sheartail is one of the smallest hummingbirds, and some believe it to be the lightest of all South American hummingbirds. The sheartail makes its home among the arid coastal shrubland of Peru, as well as in farmland, gardens, and orchards, where it forages flowering plants for nectar. The population is expanding into Chile, and individuals have also been sighted in Ecuador.</p>

<p>Due to its stable population, the Peruvian sheartail has been classified by the IUCN as being of least concern from a conservation standpoint. Many of the animals on O’Reilly covers are endangered; all of them are important to the world.</p>

<p>The cover illustration is by Karen Montgomery, based on an antique line engraving from Wood’s <em>Natural History</em>. The series design is by Edie Freedman, Ellie Volckhausen, and Karen Montgomery. The cover fonts are Gilroy Semibold and Guardian Sans. The text font is Adobe Minion Pro; the heading font is Adobe Myriad Condensed; and the code font is Dalton Maag’s Ubuntu Mono.</p>

</div></section></div>
</div>
</body></html>